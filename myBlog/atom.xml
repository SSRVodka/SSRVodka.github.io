<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SJTU-XHW&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/775cd43db6a8785d6a482dcf308b3be4</icon>
  <subtitle>It&#39;s better to burn out than to fade away.</subtitle>
  <link href="https://sjtuxhw.top/atom.xml" rel="self"/>
  
  <link href="https://sjtuxhw.top/"/>
  <updated>2024-07-28T08:34:22.714Z</updated>
  <id>https://sjtuxhw.top/</id>
  
  <author>
    <name>SJTU-XHW</name>
    <email>sjtuxhw12345@sjtu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Algorithms in AI</title>
    <link href="https://sjtuxhw.top/2024/07/20/Algorithms-in-AI/"/>
    <id>https://sjtuxhw.top/2024/07/20/Algorithms-in-AI/</id>
    <published>2024-07-20T07:23:40.000Z</published>
    <updated>2024-07-28T08:34:22.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-0-Intro"><a href="#Chapter-0-Intro" class="headerlink" title="Chapter 0. Intro"></a>Chapter 0. Intro</h1><h2 id="0-1-The-definition-of-Artificial-Intelligence"><a href="#0-1-The-definition-of-Artificial-Intelligence" class="headerlink" title="0.1 The definition of Artificial Intelligence"></a>0.1 The definition of Artificial Intelligence</h2><ul><li><p>Think rationally -&gt; Think like people -&gt; Act like people -&gt; <strong>Act rationally</strong>.</p><blockquote><p>The system <strong>maximumly achieving predefined goals</strong>.</p><p>-&gt; <strong>Maximize the expected utility.</strong> (最大化预期效用)</p></blockquote></li><li><p>Brains and AI</p><ul><li><p>Why not reverse engineering the brains? -&gt; Not as modular as software.</p></li><li><p>But there are the lessons <strong>learned from the brain</strong> (interleave, 交织在一起):</p><ul><li><p><strong>Memory (data): Judge situations depending on the previous experiences (statistics)</strong>.</p><blockquote><p>e.g., Bayes’ nets, Decision theory, <strong>Machine learning</strong>,…</p></blockquote></li><li><p><strong>Simulation (computation): Predict the future depending on the models</strong>.</p><blockquote><p>e.g., Search, Satisfying constraints, Adversarial and uncertain search,… (<strong>Algorithms</strong>)</p></blockquote></li></ul></li></ul></li></ul><h2 id="0-2-The-History-of-AI"><a href="#0-2-The-History-of-AI" class="headerlink" title="0.2 The History of AI"></a>0.2 The History of AI</h2><h2 id="0-3-The-Applications-of-AI"><a href="#0-3-The-Applications-of-AI" class="headerlink" title="0.3 The Applications of AI"></a>0.3 The Applications of AI</h2><ul><li><strong>Natural language</strong>: speech technology (+context), language processing technologies (Q&amp;A / translation / web search …);</li><li><p><strong>Computer vision</strong> (perception)</p></li><li><p><strong>Game playing</strong>;</p></li><li><strong>Logic</strong>: Theorems provers, NASA fault diagnosis, …</li></ul><h2 id="0-4-Designing-Rational-Agents"><a href="#0-4-Designing-Rational-Agents" class="headerlink" title="0.4 Designing Rational Agents"></a>0.4 Designing Rational Agents</h2><ul><li>Agent: An agent is an entity that perceives and acts.</li><li><strong>Environment -&gt; sensors of an agent -&gt; agent functions -&gt; actuators -&gt; effect on environment</strong>.</li></ul><h1 id="Chapter-1-Search"><a href="#Chapter-1-Search" class="headerlink" title="Chapter 1. Search"></a>Chapter 1. Search</h1><blockquote><p>Discuss agents that <strong>plan ahead</strong> rather than just react to a current situation.</p><p><strong>将现实问题 formalize 为数学问题，并使用算法模拟搜索求解</strong>。</p></blockquote><h2 id="1-1-Reflex-Agents"><a href="#1-1-Reflex-Agents" class="headerlink" title="1.1 Reflex Agents"></a>1.1 Reflex Agents</h2><ul><li><p>They have a current percept, <strong>and maybe make decision based on these memory but <u>without consideration of the consequences of their actions</u>.</strong></p><blockquote><p>仅根据当前状态，直接进行当前最优动作；</p><p>例如，根据当前 successor 的结果谁更接近 goal 就进行什么操作。</p></blockquote></li><li><p>类似贪心算法，有时 rational，但有时并不是；</p></li></ul><h2 id="1-2-Planing-Agents"><a href="#1-2-Planing-Agents" class="headerlink" title="1.2 Planing Agents"></a>1.2 Planing Agents</h2><ul><li><p>They have the model of what the world works, and the goals. <strong>根据一系列动作，结合模型假设后果，并根据后果和目标的关系来决定是否进行这个操作</strong>。</p><blockquote><p>实现 1 (master-mind)：先遍历查找动作序列，再行动（时间花费很大）；</p><p>实现 2 (re-planning)：先遍历最近的动作序列，行动，然后再遍历下一段的动作序列，再行动，以此往复（类似结合了贪心法的动态规划）；</p></blockquote></li><li><p>Optimal Planning（最优计划） &amp; Complete Planning（能解决问题的存在性计划）</p></li></ul><h2 id="1-3-Search-Problem（Uninformed-Search）"><a href="#1-3-Search-Problem（Uninformed-Search）" class="headerlink" title="1.3 Search Problem（Uninformed Search）"></a>1.3 Search Problem（Uninformed Search）</h2><h3 id="1-3-1-Definitions"><a href="#1-3-1-Definitions" class="headerlink" title="1.3.1 Definitions"></a>1.3.1 Definitions</h3><blockquote><p>什么是计算机中的搜索问题？</p></blockquote><ul><li><p>一个搜索问题包含：</p><ul><li><p>状态空间（a state space，存放环境信息）；</p></li><li><p>后继函数（a successor function，包含动作、动作开销）；</p><blockquote><p><strong>有哪些可行的动作？动作执行后的结果状态如何？——这个函数编码了 “how the world works”</strong></p></blockquote></li><li><p>初始状态（a start state）和目标检查（a goal test）；</p></li></ul></li><li><p>搜索问题的解：<strong>就是一个从初始状态到目标状态的动作序列（a sequence of actions / a plan）</strong>.</p></li></ul><blockquote><p><strong>以上可以称为搜索问题的模板，可以看作接口（interface）</strong>，这意味着我们可以将现实生活中的问题抽象到上面的模板中（casting to search problem），再对照模板设计算法，就能解决实际问题。</p></blockquote><h3 id="1-3-2-Examples"><a href="#1-3-2-Examples" class="headerlink" title="1.3.2 Examples"></a>1.3.2 Examples</h3><blockquote><p>搜索问题本质上是一个模型。举例：</p></blockquote><ul><li>城市导航路线图<ul><li>state space: cities;</li><li>successor function: roads (go to adjacent cities with <strong>cost (可以是距离、交通情况等)</strong>);</li><li>start state: 位于起点的状态；</li><li>goal test: <strong>当前状态是否是位于终点的状态</strong>；</li><li>solution: 有向路径；</li></ul></li><li>pac-man 游戏（目标是走到指定位置）<ul><li>state space: (x, y) 实体的位置信息；action: NSEW；successor function: <strong>update location only</strong>；goal test: 是否有 (x,y)==DESTINATION；</li></ul></li><li>pac-man 游戏（目标是吃完所有豆子）<ul><li>state space: (x, y) 位置 + 是否有食物的布尔值；action: NSEW；successor function: <strong>更新位置和食物情况</strong>；goal test: 是否有所有食物布尔值都为 false；</li></ul></li></ul><h3 id="1-3-3-Mathematical-amp-Algorithmic-Representation"><a href="#1-3-3-Mathematical-amp-Algorithmic-Representation" class="headerlink" title="1.3.3 Mathematical &amp; Algorithmic Representation"></a>1.3.3 Mathematical &amp; Algorithmic Representation</h3><ul><li><p><strong>搜索问题的数学表示：状态图和搜索树</strong>（state space graphs &amp; search tree）</p><ul><li><strong>它们一般过于庞大，画不出来，只需要有这样的概念就行</strong>；</li><li>搜索树结点数一般远大于状态图，因为<strong>搜索树中可以有多个结点代表同一个状态</strong>；</li></ul></li><li><p>搜索树（General Tree Search）解决 <strong>等权 / 非等权搜索问题</strong></p><blockquote><p>本部分就是数据结构中图的相关算法。涉及解决<strong>等权图最短路</strong>、<strong>非等正权图最短路</strong>等问题的经典算法。但<strong>有所不同，因为是 Tree Search，所以不会记录 visited 结点——意味着会重复搜索（具体会在 1.5 中进行阐释和改进）</strong>；</p></blockquote><ul><li><p>Important Ideas:</p><ul><li><strong>Fringe (原义条纹 / 边缘，这里指的是 a set of leaf nodes that are waiting to be expanded，通常是存放等待处理的数据结点的结构，可以是栈、队列等)</strong>;</li><li>Expansion (查找过程中再向树中插入合法结点);</li><li>Exploration strategy (<strong>DFS / BFS / Uniform Cost Search</strong>)</li></ul></li><li><p>Pseudo Code:</p><p><img src="imgs/tree_search_pseudo_code.png"></p></li></ul></li><li><p>Search Algorithm Properties of General Tree Search（<strong>针对所有 “利用搜索树” 解决搜索问题的算法</strong>）</p><ul><li><p><strong>如果 expansion strategy 算法是 DFS</strong>：</p><ul><li>实现方式：<strong>栈</strong>；</li><li>时间复杂度为 $O(b^m)$，b 为每个结点的后继结点数量级，m 为搜索树中最大深度的数量级；空间复杂度为 $O(b\cdot m)$；</li><li><strong>算法是 complete 的（如果对于无限树，且存在解，则能够找到至少一个解）</strong>；</li><li><strong>算法不是 optimal 的（DFS 无法自动找到最优解，除非你一直找，再手动比较）</strong>；</li></ul></li><li><p><strong>如果算法是 BFS</strong>：</p><ul><li>实现方式：<strong>队列</strong>；</li><li>时间复杂度为 $O(b^s)$，b 为每个结点的后继结点数量级，s 为搜索到最近的 goal state 所在层数的数量级；空间复杂度也是 $O(b^s)$;</li><li><strong>算法是 complete 的</strong>（不遍历结束、得出结果，则不会退出）；</li><li><strong>如果 cost 是相等的——即等权图，则算法是 optimal 的，因为按照层级（tier）从近处向远处找</strong>；</li></ul></li><li><p>综合上面特点发现，DFS 空间性能更好，但 BFS 能够找到等权情况下的最短路；<strong>那么我们有没有一种算法综合它们的优点呢？有的！它就是 Iterative Deepening</strong>；</p><blockquote><p><strong>Iterative Deepening（迭代深搜）</strong>利用了 DFS 空间优势。在搜索开始后，先执行 DFS，<strong>以 depth=1 和 goal 为终止条件</strong>，如果找到，就结束；否则证明 depth=1 的深度无解，将 depth 结束条件放宽至 depth=2，继续 DFS，以此类推。</p><p>这就将 DFS 和 BFS 的优势结合了起来。</p><p>不用担心每次都把前几层重复检查，因为理论上搜索树每层结点指数增长，下一层结点数往往远大于前几层结点数之和，所以重复检查的部分微不足道。</p></blockquote></li><li><p>Uniform Cost Search（UCS，一致代价搜索） 解决 <strong>Cost-sensitive Search（非等权搜索问题）</strong></p><ul><li>实现方式：<strong>优先级队列</strong>；</li><li>时间复杂度 $O(b^{C^*/\varepsilon})$，b 为每个结点后继结点数量级，C* 为解的 cost 数量级，ε 为各个结点间（每一步）的最小 cost 数量级；空间复杂度与时间相同； </li><li>此算法借鉴了 BFS 的思路，在 expansion 的时候选取 cost 最小的；</li><li><strong>算法在<u>最小权为正数</u>的情况下是 complete 和 optimal 的</strong>。</li><li>优点很好，但缺点也很严重——<strong>一般情况下开销极大，因为遍历了一个正权下的所有状态结点</strong>（可以通过 goal 的信息进行优化，后面介绍，就是 <strong>informed search</strong>）；</li></ul></li></ul></li></ul><h2 id="1-4-Informed-Search"><a href="#1-4-Informed-Search" class="headerlink" title="1.4 Informed Search"></a>1.4 Informed Search</h2><blockquote><p>搜索问题的定义是相同的，只不过 informed search（有提示搜索）的 <strong>expanding strategy</strong> 会考虑到距离 goal 的远近程度（在 uninformed search 的基础上进行改进）而已。</p><p>所以下面仅比较不同的 expanding strategy。</p></blockquote><h3 id="1-4-1-Search-Heuristics"><a href="#1-4-1-Search-Heuristics" class="headerlink" title="1.4.1 Search Heuristics"></a>1.4.1 Search Heuristics</h3><blockquote><p>启发式搜索，<strong>即启发函数</strong>，是后面 informed search 算法的基础。</p></blockquote><ul><li><p>The definition for a heuristic</p><ul><li><p>A function that estimates <strong>how close a state is to a goal</strong>.</p></li><li><p>Designed for a particular search problem （<strong>因为距离判断因问题而异</strong>）；</p><blockquote><p>可以是 Manhattan distance，Euclidean distance……（for pathing）</p></blockquote></li></ul></li><li><p>Examples</p><ul><li>The pac-man game（去往特定的有食物的地点）：“距离”（heuristic function）可以是与终点的欧式距离、曼哈顿距离（因为上下左右移动）；</li><li>The pancake problem（完成从上到下饼依此增大的排列）：heuristics function 可以是<strong>位置正确的煎饼个数</strong>、<strong>位置不正确的最大煎饼编号（因为和汉诺塔类似，势必要先把最大煎饼先挪到底层）</strong>；</li></ul><blockquote><p>具体选择哪种 heuristic function，<strong>可以举几种固定情况（例如画一部分状态图），看谁的 heuristic function 的值在接近 goal 时表现更好</strong>。</p></blockquote></li></ul><h3 id="1-4-2-Expanding-Strategy-Greedy-Search（贪婪法）"><a href="#1-4-2-Expanding-Strategy-Greedy-Search（贪婪法）" class="headerlink" title="1.4.2 Expanding Strategy: Greedy Search（贪婪法）"></a>1.4.2 Expanding Strategy: <strong>Greedy Search（贪婪法）</strong></h3><ul><li>思路：选择 fringe 中 heuristic function 最接近 goal 的结点进行 expand；</li><li>优点：在某些情况下搜索非常迅速，并且开销很小；</li><li>缺陷：局部最优解不一定是全局最优解，即贪婪法不一定是正确的（<strong>算法不一定是 optimal 的</strong>），最坏情况是 <strong>badly-guided DFS</strong>，尤其是当 heuristics function 没选好的时候；</li></ul><h3 id="1-4-3-Expanding-Strategy-A-Search（A-搜索）"><a href="#1-4-3-Expanding-Strategy-A-Search（A-搜索）" class="headerlink" title="1.4.3 Expanding Strategy: A* Search（A* 搜索）"></a>1.4.3 Expanding Strategy: <strong>A* Search（A* 搜索）</strong></h3><blockquote><p>理解 A star Search 前，先以龟兔赛跑的寓言故事（fable）作比：<strong>Uniform Cost Search (uninformed)</strong> 就像 tortoise，虽然缓慢，但会搜索到同一权重下的所有状态情况，如果有的话确保一定找到最优解；<strong>Greedy Search</strong> 就像 hare，非常迅速，但容易走错方向，找不到最优解。</p><p><strong>所以 A star search 相当于是坐在乌龟上的兔子，既结合了 Uniform Cost Search 的稳妥，又具有 Greedy Search 部分的借助 heuristic function 迅速搜索的特点</strong>。现在看看是如何实现的：</p></blockquote><p>以一个例子来阐释：</p><p><img src="imgs/AStar.png" height="275"></p><p>对于这个正权有向图而言，Uniform Cost Search 的 expanding strategy 是按照<strong>当前步的累计 cost（理解为“深度”）<code>g(n)</code> 来评定的</strong>，而 Greedy Search 的 heuristic function 是按照<strong>距离 goal 的加权路径距离和 <code>h(n)</code> 来评定的</strong>。将 <strong>这两个标准相加得到 A* 的评价标准 <code>f(n)</code></strong>，这样既考虑到了下一步的 cost，又考虑到了距离终点的相对位置，达到了一个较好的效果。</p><blockquote><p>因为如果仅仅是 Uniform cost search，则要搜索 6 个结点才能找到 optimal solution；仅用 Greedy Search 只能找到非 optimal 的解；而用 A-star search 只需搜索 4 个结点就找到了 optimal solution.</p><p>有同学可能会问，为什么上面图中 <code>e</code> 结点的 h = 1 而不是 2？因为这和 heuristic function 的取法有关系。这里可能不是到达终点的路径长度和，而是直线距离。</p><p>思考：为什么只能在结点出队的时候才能检查它是不是 goal 然后再结束？进队的时候不行吗？</p><p>答案：不行。进队的时候，没法保证该结点一定比 fringe 内其他所有结点都要优；</p></blockquote><ul><li><p><strong>A* 算法不一定是 optimal 的</strong>，因为可以举出反例：</p><p><img src="imgs/AStar_counterExample.png" height="200px"></p><p>上面的反例可以看出，<strong>如果 heuristic function 函数没有选好，选的过于 pessimistic，那么很有可能会误导 agent，导致正确的 optimal solution 迟迟无法出队</strong>，这就是 A* 不一定 optimal 的原因——<strong>heuristic function 选取失误</strong>。</p></li><li><p>为了减少以上情况的出现，即优化这个算法，我们引入 <strong>Admissibility</strong> 来评价一个 heuristic function：</p><ul><li><p>如果 heuristic function 在<strong>任意</strong>结点的值 $h(n)$ 小于等于实际到 optimal solution 的加权路径长度 $h^<em>(n)$（<strong>我们在不知道结果前时无法得知，但它数学上客观存在</strong>），那么称为 <strong>optimistic heuristic function</strong>，这样的 A\</em> Search 会得到 optimal solution；</p><blockquote><p>即 optimistic (admissible) heuristic function 的定义为：</p><script type="math/tex; mode=display">\forall\space node\space n,\space 0\le h(n)\le h^*(n)\Longrightarrow h(n)\space is\space admissible</script></blockquote></li><li><p>如果 heuristic function 在某一结点的值大于实际到 optimal solution 的加权路径长度，则称为 <strong>pessimistic heuristic function</strong>，这样的 A* Search 很可能无法得到 optimal solution；</p></li></ul><p><strong>重要的是，虽然我们不知道 $h^*(n)$，但这已经足以我们判断一些情况下使用 A* Search 能否得到 optimal solution了</strong>：</p><p>例如在 pac-man game 的例子中，如果取到 goal 的 Manhattan distance 为 heuristic function，那么<strong>它一定是 optimistic 的，所以用 A* Search 一定能得到正确的 optimal solution</strong>（因为 Manhattan distance 考虑没有墙的情况下的距离，一定是乐观的）；</p><p>再例如在 pancake problem 的例子中，如果取 <strong>错位的薄饼的最大编号</strong> 为 heuristic function，那么 <strong>它也一定是 optimistic 的</strong>（因为你至少还要移动编号个数的薄饼次数才能达到 goal）；</p><p><strong>所以到目前为止，选取 heuristic function 的标准一个是举例子看看在某些结点上，$h(n)$ 是否接近 $g(n)$；另一个就是看看能否判断出 optimistic (admissible)，如果能，则能证明 A* Search 算法的 optimality，那么一定比 Uniform Cost Search 要好</strong>。</p></li></ul><h3 id="1-4-4-拓展：A-Search-的-optimality-证明"><a href="#1-4-4-拓展：A-Search-的-optimality-证明" class="headerlink" title="1.4.4 拓展：A* Search 的 optimality 证明"></a>1.4.4 拓展：A* Search 的 optimality 证明</h3><blockquote><p><strong>为啥取了 admissible 的 heuristic function，A* Search 就一定是 optimal 的？</strong></p></blockquote><p><strong>定义命题：</strong></p><script type="math/tex; mode=display">P:\quad h(n)\space is\space admissible\Longrightarrow A^*\space Search\space is\space optimal</script><p>下面证明命题 $P$：</p><ol><li><p>假设 A* Search tree 如下图所示，具有一个 optimal solution A 和 suboptimal solution B，由于二者的任意性，所以只要能证明 A 能在 B 之前出队并 expand，则就能证明 $P$；</p></li><li><p>再假设 B 在 fringe 中的情况（即 B 在搜索队列中），否则 $P$ 直接成立；</p></li><li><p>再假设 A 或 A 的祖先结点一定在 fringe 中，否则<strong>A 及其祖先节点一定都已经 expand 完毕了（因为 A，至少 A 的祖先节点，是 $f(n)$ 值小于 B 的 “候选结点”）</strong>，这个时候 $P$ 也直接成立；所以记在 fringe 中的 A 或其祖先结点为 n，如下图所示；</p></li><li><p>则可以证明 $f(n)\le f(A)$：由 $f(n)$ 的定义可知，$f(n)=g(n)+h(n)$，再由 admissibility 的定义可知，</p><script type="math/tex; mode=display">h(n)\space is\space admissible\Longrightarrow h(n)\le h^*(n)\Longrightarrow g(n)+h(n)\le g(n)+h^*(n)</script><p><strong>即 $f(n)\le g(A)$</strong>；再根据 heuristic function 的定义，$h(A)=0$，所以 $g(A)=f(A)$，进而得出 $f(n)\le f(A)$；</p></li><li><p>能够证明 $f(A)\lt f(B)$：由 suboptimal solution 的定义，$g(A)\lt g(B)$，由于 $h(A)=h(B)=0$，所以 $f(A)\lt f(B)$；</p></li><li><p>由第 4 条和第 5 条，能够证明 n 必然在 B 之前 expand，即 $f(n)\lt f(B)$（因为 $f(n)\le f(A)\lt f(B)$）；</p></li><li><p><strong>由于祖先结点 n 的任意性，所以 A 或 A 的祖先结点一定都在 B 之前 expand</strong>，所以 任意的 optimal solution A 一定在 suboptimal solution B 之前 expand，因此 A* Search 的 solution 必然是 optimal solution，$P$ 成立，原命题得证。</p></li></ol><p><img src="imgs/AStar_optimality_proof.png" height="200px"></p><blockquote><p>Q：为什么第 5 条 $f(A)\lt f(B)$ 不就能说明 A 在 B 前 expand 了吗？</p><p>A：其实不然，我们在第 5 条的时候还缺少一个条件——我们当时还不能证明 A 结点一定在 fringe 当中。我们只知道 A 的祖先结点在 fringe 当中。</p></blockquote><h3 id="1-4-5-How-to-Create-Admissible-Heuristic-Functions"><a href="#1-4-5-How-to-Create-Admissible-Heuristic-Functions" class="headerlink" title="1.4.5 How to Create Admissible Heuristic Functions ?"></a>1.4.5 How to Create Admissible Heuristic Functions ?</h3><ul><li><p>example: 8 puzzle（8 格华容道）</p><p><img src="imgs/8puzzles.png" height="275px"></p><ul><li>取法 1：状态结点 n 中，错位的数字数目定为 heuristic function $h(n)$，此时易得 $h(n)$ 是 admissible 的；</li><li><strong>结论 1</strong>：<strong>将原问题转化为 relaxed-problem heuristic 来讨论</strong>，例如在 8-puzzle 里面，如果能够直接把数字拆下来，直接安装到正确位置，那么这个问题就变简单了，action 数目一定变少了，而这个新问题就叫做 <strong>relaxed-problem</strong>；显然有：<strong>新问题的总步数（cost）小于原问题的 optimal solution 的步数（cost）</strong>；</li><li>取法 2：状态结点 n 中，所有数字距离正确位置的 Manhattan distance 的总和定为 $h(n)$，这个做法就是上述结论的应用。这种取法对应的 relaxed-problem 是 <strong>忽略数字方块之间的格挡限制</strong>，可以证明这种取法的 $h(n)$ 不仅是 admissible 的，而且<strong>比取法 1 更接近真实 optimal solution 的 cost</strong>；</li></ul></li><li><p><strong>总而言之，Heuristic function 的选取就在 <u>node expansion 的空间消耗</u> 和  $h(n)$ <u>计算的时间消耗</u> 之间抉择、权衡</strong>。但一般无论哪个方向，都<strong>必须要是 admissible 的（因为如果不是的话，就不能保证 A* Search 的 optimality，那还不如用 Greedy search）</strong>。</p><ul><li>要么 $h(n)$ 选取一些 admissible 且方便计算的函数，但平均需要更多的 node expansion 才能找到 optimal solution；</li><li>要么 $h(n)$ 选取一些 admissible 且更接近真实 optimal solution cost 的函数，但一般平均需要花费更长时间才能计算出 $h(n)$ 在某一结点的值；</li></ul></li><li><p><strong>结论 2</strong>：两个 admissible heuristic function 的最大值函数一定是更接近于真实 optimal solution cost 的 admissible heuristic function；如下图：</p><p><img src="imgs/h_semilattice.png" height="300px"></p><blockquote><p>注：如果 $\forall n,\space h(n)=0$，则 A* search 退化为 Uniform Cost Search（相当于提供 goal 的信息被 “磨平了”，各结点处都一样了）</p></blockquote></li></ul><h3 id="1-4-6-From-Tree-Search-to-Graph-Search"><a href="#1-4-6-From-Tree-Search-to-Graph-Search" class="headerlink" title="1.4.6 From Tree Search to Graph Search"></a>1.4.6 From Tree Search to Graph Search</h3><p>前面说的算法，从 uninformed search (DFS、BFS、Uniform Cost Search) 到 informed search (Greedy Search、A* Search)，都借助了 <strong>Tree Search</strong> 的思想，没有标注 visited 结点，导致大量重复冗余的 node expansion（同一状态结点入队多次）。</p><p>我们借鉴图算法的思想，只需要在前面 Tree Search 算法中 <strong>expansion strategy 前</strong> 加入 visited 判断，即可变成 Graph Search。具体实现方法可以借助 <strong>closed set</strong>（闭集，就是集合结构的数学名称）（别用列表，因为<strong>线性表查找元素是否存在的时间复杂度远大于集合结构</strong>）</p><p>易得，<strong>Tree Search 算法和同等的 Graph Search 算法的 complete 性质相同</strong>。因为它们理论上都能遍历完有限结点。</p><p>但！<strong>转换为 Graph Search 后，却不一定有同等的 optimality</strong>。因为在某些情况下，如果某些 admissible heuristic function 选的不好，很有可能导致 visited 会放弃掉 optimal solution，例如下面这种情况：</p><p><img src="imgs/AStarGraph_counterExample.png" height="270px"></p><p><strong>这是因为 heuristic function 选取的不一致性（inconsistency）导致的</strong>，通常是因为<strong>两个结点之间的 $h(n)$ 值之差大于它们间的 cost</strong>，导致其中一个结点<strong>需要第二次进队才有可能找到 optimal solution</strong>。这里结点 A 和 C 之间就存在这个问题，$h(A)-h(C)=3\gt cost(A,C)=1$，所以当 C 结点在 A* Tree Search 第二次进队时，才算 optimal solution。如果贸然转换为 Graph Search，就会丢失这个 optimal solution。</p><p>所以，考虑对于一个 admissible heuristic function，如果每两个结点之间的 $h(n)$ 值之差必然小于等于它们之间的 cost，<strong>所以称这个 admissible heuristic 为 consistent 的</strong>。</p><p>只有 heuristic function 是 consistent 的，<strong>越靠 fringe 后面弹出的 node，其 $f(n)$ 越大，越不可能是 optimal solution</strong>，否则不能满足这个特性。</p><p><img src="imgs/consistency_of_heuristics.png" height="275px"></p><ul><li>性质 1： <strong>Consistency 蕴含（implies）Admissibility</strong>（一个 consistent heuristic function 一定是 admissible heuristic function）；</li><li>性质 2：只有选取了 Consistent heuristic function，A* Graph Search 才能保证 optimality，但 A* Tree Search 只需要 Admissible heuristic function 就能保证 optimality；</li></ul><p>因此，<strong>如果选取的 heuristic 具备 consistency</strong>，那么将之前的所有 Tree Search 算法加上 visited 判断变成 Graph Search 算法，均不改变其 completion 和 optimality，并且可以减少 node expansion 的数目，实现算法的优化。</p><p><strong>值得庆幸的是，大部分自然得到的 admissible heuristic functions 都是 consistent 的，尤其是由 relaxed problems 取得的</strong>。所以大可以认为，用 relaxed problems 方法取得的 heuristic functions 都具有 consistency，而无需证明。</p><p>上面的 “一致性” 比较抽象，有位知乎网友 <code>@Hepta</code> 解释的好，截下来给大家参考：</p><p><img src="imgs/zhihu_explain.png" height="400px"></p><p>这可以认为，这个 heuristic function 取得确实是 admissible（每个结点的 $h(n)$ 总趋势都是越接近 goal 就越接近0，并且是<strong>乐观估计</strong>的），但是每个路线上的 “乐观估计程度不相同”，如果存在一种情况：<strong>一个实际更长（cost 更大）的路径比一个实际更短（cost 更小）路径的 $h(n)$ 更乐观——即虽然它们各自都正确反映了 goal 远近的性质（admissible），但相对远近反映不一致（inconsistent），这就是 heuristic function 的不一致性</strong>。</p><p>这种不一致就会影响搜索，导致<strong>suboptimal solution 的路径比 optimal solution 的路径更快到达 solution <u>附近停下来</u></strong>（但总体受到 admissible 的限制，suboptimal solution 不会先进队的），所以这个时候如果附近的结点又恰好唯一，并且还有 visited 不允许重复进队，那么 optimal solution 的路径就会被 suboptimal solution 的路径截断，造成错误地丢失正确最优解。</p><p>所以上面说 “relaxed problems 得到的 admissible heuristic function 都有 consistency” 是符合一般规律的，故意设计的 heuristic function 可能不满足 consistency、满足 admissible，但它一般不能从 relaxed problems 得出。</p><h3 id="1-4-7-补充：Dijkstra-Algorithm-amp-A-Algorithm"><a href="#1-4-7-补充：Dijkstra-Algorithm-amp-A-Algorithm" class="headerlink" title="1.4.7 补充：Dijkstra Algorithm &amp; A* Algorithm"></a>1.4.7 补充：<code>Dijkstra</code> Algorithm &amp; A* Algorithm</h3><p>其实细心的同学已经发现，<code>Dijkstra</code> 算法不就是 A* 算法的特殊情况嘛！当我们仅仅以当前步累计的 cost（去掉距离 goal 的 cost）作为 heuristic function 时，A* 算法就退化为了 <code>Dijkstra</code> 算法。</p><p>它们都只能解决非负边权值图的最短路径问题。</p><h2 id="1-5-Summary"><a href="#1-5-Summary" class="headerlink" title="1.5 Summary"></a>1.5 Summary</h2><p>本章讲述了 <strong>搜索问题</strong> 的基本定义和算法。我们可以总结出：</p><ul><li><p>搜索问题的使用场景：用于一类很特定的问题，它们满足搜索问题的模板。例如地图导航的最短路搜索、没有敌人并且是去往特定位置的 pac-man 游戏；</p></li><li><p>搜索问题中 Agent 的性质：<strong>Planning Agent</strong>，即先根据算法计算，得出一系列动作序列之后再行动，<strong>更关注 master-mind，即固定的动作序列解法来得到最优解</strong>；</p></li><li><p>搜索问题的前提假设：单个 Agent（<strong>没有其他 agent 做出不确定 (uncertain) 或者对抗性 (adversarial) 的 actions 对当前 agent 造成影响</strong>）、可决定的 Actions、完全可观测的 States、离散的 State space；</p></li><li><p>搜索问题的目标</p><ul><li><p><strong>获取路径</strong>：此时 Agent 的性质是 <strong>Planning Agent</strong>，即先根据算法计算，得出一系列动作序列之后再行动，<strong>更关注 master-mind，即固定的动作序列解法（即路径）来得到最优解</strong>；</p><blockquote><p>本章讲述的几乎所有内容都是关于这个方面的；</p></blockquote></li><li><p><strong>获得结果</strong>：此时动作序列并不重要，只关心这个动作序列能否达到 goal；通常这种目标下不会考虑 costs；</p></li></ul></li></ul><p>所以搜索问题的假设很多，在这个问题基础上，我们添加了一些信息，例如路径是否等权？权重大小多少？是否可以用 goal 信息来 inform 搜索的方法？</p><p>对应的算法常见的有：Tree Search 的 DFS、BFS、UCS（都是 uninformed）和 Greedy Search、A Star Search；进一步进行改进还有对应的 Graph Search。</p><p>以后几章，我们将一点点解除这些前提假设的限制，让问题发生变化，并探讨新问题的算法。</p><h1 id="Chapter-2-Constraint-Satisfaction-Problems-CSPs"><a href="#Chapter-2-Constraint-Satisfaction-Problems-CSPs" class="headerlink" title="Chapter 2. Constraint Satisfaction Problems (CSPs)"></a>Chapter 2. Constraint Satisfaction Problems (CSPs)</h1><h2 id="2-1-The-Introduction-to-CSP"><a href="#2-1-The-Introduction-to-CSP" class="headerlink" title="2.1 The Introduction to CSP"></a>2.1 The Introduction to CSP</h2><p>正如上一章总结所说，CSP 只是一种特殊的 “获取结果” 的 Search Problem，它对问题作了如下假设：</p><ul><li>状态空间是个<strong>黑盒</strong>，可以是任何数据结构，无法直接访问状态空间的信息；</li><li>目标测试也可以是任何形式的函数，也是黑盒，只能调用（即从结果上看是否达到目标）；</li><li>后继函数仍然是黑盒，你只能通过调用来取得可能的后继状态；</li></ul><p>因此我们可以问题抽象为新的数学表示：</p><ul><li>CSP 就是 Search Problem 的一个特殊子集，目标本质是找到 goal；</li><li>所有的<strong>状态</strong>可以被定义为一组变量：$X_i$，其值在定义域 $D$ 中变化（<strong>有的时候 $D$ 取决于 $i$</strong>）；</li><li><strong>后继函数</strong>的运作方法类似为这些状态变量赋值；</li><li><strong>目标测试</strong>就是一组<strong>限制条件（Constraints）</strong>，指明了最终的 goal，即可接受的<strong>状态序列（由可接受的一组 $X_i$ 的值组成）</strong>，这也是为什么这个问题被称为 “Constraint Satisfaction Problems”；</li></ul><p>它的应用相当广泛，生活中几乎都能见到。</p><h3 id="2-1-1-Example-1-地图上色"><a href="#2-1-1-Example-1-地图上色" class="headerlink" title="2.1.1 Example 1: 地图上色"></a>2.1.1 Example 1: 地图上色</h3><p>举一个例子，计算机证明 <strong>四色定理</strong> 时需要正确地为地图分配颜色。现在我们想要为地图上一片有划分的区域填色，要求<strong>相邻区域颜色不得相同</strong>。具体做法如下：</p><ol><li>首先把问题抽象为 CSP。很显然，问题的<strong>状态可以由一组区域变量表示</strong>，其定义域为各自不同颜色组成的集合，这里假设有 6 个区域，在 $x_1\sim x_6$；</li><li>这里可以把颜色定义域设置为 3 种颜色：<code>D = &#123; red, green, blue &#125;</code>；</li><li>目标测试（限制条件）<ul><li>Implicit（隐含）：adjacent regions must have different colors（体现在代码中就是每两个相邻区域变量不相等）；</li><li>Explicit（明确）： $(x_i,x_j)\in\{(red,green),(red,blue),\cdots\}$；</li></ul></li><li>解决方案（solution）：就是一组或多组符合限制条件的 $x_i$ 的赋值（assignments），<strong>CSP 问题的解只需要找到一个解即可</strong>；</li></ol><hr><p>除了使用变量 + 限制条件的方法，还有一种方法可以描述 CSP 问题：<strong>Constraint Graphs</strong>：</p><ul><li><p>每个变量由图中的一个结点代替；</p></li><li><p><strong>如果限制条件是 二元 的</strong>（是/否、有/无、等于/不等于，等等），那么可以用结点之间是否连接边来表示；</p><blockquote><p>注意：<strong>限制图的边只是表示哪里有限制，没有说明限制是什么</strong>，所以应该是二元的限制条件；</p></blockquote></li></ul><p>这种<strong>最多每两个变量之间</strong>具有<strong>二元限制条件</strong>的 CSP  问题被称为 Binary CSP，对应的限制图被称为 Binary Constraint Graph；</p><p>相对应的还有<strong>一元限制条件（Unary Constraint）</strong>，即指定变量必须为某特定值；后面会具体说。</p><h3 id="2-1-2-Example-2-N-Queens-问题"><a href="#2-1-2-Example-2-N-Queens-问题" class="headerlink" title="2.1.2 Example 2: N-Queens 问题"></a>2.1.2 Example 2: N-Queens 问题</h3><p>我们听过 “八皇后问题”，那么对于 N-皇后问题，除了使用递归+回溯的经典解法，还可以将其转化为 CSP 求解：</p><ul><li><p>表示方法 1：逐格表示</p><ul><li><p>状态：就是 N × N 的数组，用于保存其上是否存在 “皇后” 棋，定义域为 <code>&#123;0, 1&#125;</code>；</p></li><li><p>目标测试（限制条件）：</p><ol><li>$\forall i,j,k\space(X_{ij},X_{ik})\in\{(0,0),(0,1),(1,0)\}$（不能在同一行）</li><li>$\forall i,j,k\space(X_{ij},X_{kj})\in\{(0,0),(0,1),(1,0)\}$（不能在同一列）</li><li>$\forall i,j,k\space(X_{ij},X_{i+k,\space j+k})\in\{(0,0),(0,1),(1,0)\}$（不能在对角线下半部分）</li><li>$\forall i,j,k\space(X_{ij},X_{i+k,\space j-k})\in\{(0,0),(0,1),(1,0)\}$（不能在对角线上半部分）</li><li>$\sum_{i,j}X_{ij}=N$；</li></ol></li></ul></li><li><p>表示方法 2：列表示</p><ul><li>状态：第 $k$ 行的 queen 位于的列数 $Q_k$，定义域为 <code>&#123;1, 2, ..., N&#125;</code>；</li><li>限制条件：$(Q_1,Q_2)\in\{(1,3),\space(1,4),\cdots\}$ ……;</li></ul></li></ul><h3 id="2-1-3-Example-3-Cryptarithmetic-加密运算"><a href="#2-1-3-Example-3-Cryptarithmetic-加密运算" class="headerlink" title="2.1.3 Example 3: Cryptarithmetic 加密运算"></a>2.1.3 Example 3: Cryptarithmetic 加密运算</h3><p>例如对加法式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    T W O</span><br><span class="line">  + T W O</span><br><span class="line">-----------</span><br><span class="line">  F O U R</span><br></pre></td></tr></table></figure><p>解出每个字母所代表的数字（0 ~ 9）；可以抽象出如下 CSP 问题：</p><ul><li>变量 F、T、U、W、R、O、C1（第一位进位）、C2、C3；定义域 <code>&#123;0,1,...,9&#125;</code>；</li><li>限制条件<ul><li>alldiff(F, T, U, W, R, O)，字母各不相同；</li><li>O + O = R + 10 * C1, ……;</li></ul></li></ul><h3 id="2-1-4-Example-4-Sudoku"><a href="#2-1-4-Example-4-Sudoku" class="headerlink" title="2.1.4 Example 4: Sudoku"></a>2.1.4 Example 4: Sudoku</h3><p>对于数独而言，转化为 CSP 可以是：</p><ul><li>变量即每一个没有填数的方块，定义域 0 ~ 9 的整数；</li><li>限制条件<ul><li>每一行所有元素不得相同；</li><li>每一列所有元素不得相同；</li><li>每一小正方形区域所有元素不得相同；</li><li>本身填有数的方块为 Unary Constraint，要求必须为某个数字；</li></ul></li></ul><h3 id="2-1-5-Example-5-The-Waltz-Algorithm-Deprecated"><a href="#2-1-5-Example-5-The-Waltz-Algorithm-Deprecated" class="headerlink" title="2.1.5 Example 5: The Waltz Algorithm (Deprecated)"></a>2.1.5 Example 5: The Waltz Algorithm (Deprecated)</h3><p>早期计算机视觉使用这个算法来识别 3D 图形的顶点是向外凸，还是向内凹。基本原理是：将立体中的所有顶点作为一个变量，限制条件就是<strong>相邻两个点不能一个是凸顶点，一个是凹顶点</strong>；</p><h2 id="2-2-Varieties-of-CSPs"><a href="#2-2-Varieties-of-CSPs" class="headerlink" title="2.2 Varieties of CSPs"></a>2.2 Varieties of CSPs</h2><h3 id="2-2-1-Varieties-of-Variables"><a href="#2-2-1-Varieties-of-Variables" class="headerlink" title="2.2.1 Varieties of Variables"></a>2.2.1 Varieties of Variables</h3><p>研究 CSPs 算法前，先弄清楚 CSPs 的详细信息。首先 CSP 总的来说有两种变量类型：</p><ul><li>离散型变量（Discrete Variables）<ul><li>有穷定义域（$card(D)=d$）：存在 $O(d^n)$ 种完全指配；例如 二元 CSP，有些是 NP-完全 问题；</li><li>无穷定义域（整型、字符串等）：更加困难，例如工作安排问题（某些问题必须在另一些问题之前完成）；<strong>仅线性约束可解</strong>。</li></ul></li><li>连续型变量（Continuous Variables）<ul><li>例如与时间变化有关的问题，<strong>线性约束可解，并且是多项式时间内可以利用 LP 方法完成</strong>；</li></ul></li></ul><h3 id="2-2-2-Varieties-of-Constraints"><a href="#2-2-2-Varieties-of-Constraints" class="headerlink" title="2.2.2 Varieties of Constraints"></a>2.2.2 Varieties of Constraints</h3><ul><li><p>Unary Constraint：<strong>与单个变量有关，等价于减小定义域</strong>，例如：$x=1$、$y\ne2$；</p></li><li><p>Binary Constraint：<strong>仅与一对变量有关</strong>，例如：$x=y$、$a\ne b$；</p></li><li><p>Higher-order Constraint: involve 3 or more variables，例如 2.1.3 加密计算；</p></li><li><p>Soft Constraint: Preferences（非强制的倾向），实现方法是<strong>加权，并且转化为限制优化问题</strong>；</p><blockquote><p>本章会忽略这种情况，到 <strong>贝叶斯网络</strong> 再讨论这个问题。</p></blockquote></li></ul><h2 id="2-3-The-formulations-for-Binary-CSPs"><a href="#2-3-The-formulations-for-Binary-CSPs" class="headerlink" title="2.3 The formulations for Binary CSPs"></a>2.3 The formulations for Binary CSPs</h2><blockquote><p>本节仅讨论 <strong>Constraint 至多与 2 个变量有关</strong>的问题。</p></blockquote><h3 id="2-3-1-Standard-Search-Formulation"><a href="#2-3-1-Standard-Search-Formulation" class="headerlink" title="2.3.1 Standard Search Formulation"></a>2.3.1 Standard Search Formulation</h3><p>一种常用解决 CSP 问题的方法被称为 Standard Search Formulation，方法将 CSP 问题看作一种特殊的搜索问题，定义如下：</p><ul><li>状态：defined by the values assigned so far；</li><li>初始状态：空指派；</li><li>后继函数：为一个没有指派的变量从定义域种指派一个值；</li><li>目标测试：当前指配是否为完全指派，并且满足所有约束条件；</li></ul><p>现在讨论这种思路下的算法，从最原始的方法开始来一步步优化。</p><p>现在以上面任一个 Example 为例。</p><h4 id="BFS-遍历"><a href="#BFS-遍历" class="headerlink" title="BFS 遍历"></a>BFS 遍历</h4><p>我们考虑最原始的 BFS 遍历，发现这是最差的算法，没有之一。因为这个问题中，所有的解法都在搜索树的最底层。意味着 BFS 需要遍历几乎所有状态才能找到至少一个解。我们大可以直接放弃这个方法。</p><h4 id="DFS-遍历"><a href="#DFS-遍历" class="headerlink" title="DFS 遍历"></a>DFS 遍历</h4><p>在这个问题中，DFS 方法要比 BFS 好一些，<strong>所以这一节中接下来的优化算法都基于此</strong>。这和上一章解决普通 Search Problem 的思路不一样，那个时候的算法几乎都从 BFS 的思路出发（UCS / A Star）。</p><p>实现思路是先一步步沿搜索树向下指派变量，<strong>全部指派结束后，再检查目标测试</strong>，不满足则从栈中弹出最上面的赋值（最后一个赋值），换一个值，如此递归进行。</p><p>实现思路简单，但是非常繁琐，接下来进行优化。</p><h4 id="Backtracking-Search"><a href="#Backtracking-Search" class="headerlink" title="Backtracking Search"></a>Backtracking Search</h4><p>是一种解决 CSP 的 basic uninformed algorithm，思路如下：</p><ul><li><p>一次仅对一个变量进行操作</p><ul><li><strong>变量指派是可交换顺序的，所以首先定下顺序</strong>（例如先赋值 $x=1$，再赋值 $y=2$ 和 先赋值 $y=2$，再赋值 $x=1$ 是等价的），只要将定义域排序，并且按序指派就能实现；</li><li><strong>每一步只需要考虑一个单独变量的指派</strong>；</li></ul></li><li><p><strong>每一步都检查限制条件</strong>：一旦违反条件，立即更换当前最近一次的指派。</p><blockquote><p><strong>这主要因为 CSP 问题在前一步违反条件后，后面指派就没有机会弥补，或者说使状态重新符合条件</strong>。类似一种剪枝。</p></blockquote></li></ul><p>使用以上两个思路优化的 DFS 被称为 Backtracking Search（回溯搜索）；</p><p>这种算法在解决 Example 2 的 N-queens 时，能够解出在 N ≤ 25 范围的问题。</p><p><img src="imgs/backtracking_search_pseudo_code.png" height="300px"></p><p>现在考虑 backtracking 能否继续优化？从以下方面考虑：</p><ul><li>指派定义域排序：<strong>下一个先指派定义域中的谁？按什么顺序？</strong></li><li>中途过滤：<strong>能否在违反限制之前就检测到可能的风险，并且尽早规避？</strong>（使得递归深度减小）</li><li>数据结构：能否进一步改进问题的数据结构，使其更高效？</li></ul><p>先从方便下手的部分开始：中途过滤。</p><p><strong>优化方案 1: Forward Checking</strong></p><p>思路之一是 <strong>Forward Checking</strong>，在为一个变量指派时，同时根据限制<strong>缩小其他变量（必须仅仅是有限制联系的，no further）的定义域</strong>（排除不符合限制的取值）。一旦发现有变量的定义域为空，则提前检测到了违反限制的情况，所以提前排除这种指派，重新为当前变量指派。</p><blockquote><p>In general, forward checking is going to propagate information from assigned values to unassigned values, but <strong>doesn’t provide early detection for all failures</strong> (looming conflicts between unassigned and other unassigned variables).</p></blockquote><p><strong>优化方案 2: Rich Filtering Algorithm - Graph Arc Consistency Checking</strong></p><p>这种方法还可以继续向前预测，因为在地图上色例子中，当地图两个相邻区域定义域只有相同颜色时，也希望被提前检测到。这就需要 <strong>reason from constraint to constraint</strong>（从一个限制条件推广传递至另一个），用到的技术是 <strong>arc consistency</strong>（限制图有向边一致性，<strong>arc 和 edge 都可以指图的边</strong>）。</p><p>在 Forward Checking 中，我们让每一步都按照<strong>给定的限制条件检查并更新定义域</strong>，但是某些限制条件之间可以推出另外的限制条件，让违反限制的情况更早地被检查到。我们可以通过 <strong>arc consistency</strong> 来检查。</p><p>首先给出 arc consistency 的定义：<strong>在限制图中，对于一个 constraint 对应的有向边，如果对起始结点（tail）当前定义域中<u>任意</u>指派，终止结点（head）当前定义域中都<u>存在</u>一个指派，使得二者不违反 constraint，则称这条边是一致的</strong>。</p><p>因此，我们可以发现，前面的 forward checking <strong>只是保证了指向 new assignment（head）的任意有 constraint 结点（tail）的边具有 consistency，没有检查 “unassigned 结点之间边的 consistency”</strong>。</p><p>所以，新方法应该一开始把所有的边放在一个集合中等待遍历。每一轮检查限制条件、更新定义域时，同时对其他所有有 constraint 相连的结点也进行检查（对于 unassigned 结点，一般是双向的），<strong>如果不满足，那么从起始结点的定义域中移除违反限制的取值</strong>（正是因为从起始结点移除，所以 arc consistency 的定义是 ”起始结点任意指派 -&gt; 终止 结点存在指派“）。<strong>非常难过的一点是，如果我们正在遍历 arc 检查 consistency 时，对某个结点（tail）移除了一个 value，那么之前所有指向这个结点（这时作为 head）所建立的 consistency 都不一定成立了，需要重新检查所有指向这个结点的边的 consistency</strong>。</p><p>这个优化算法的名称叫做 <strong>Forward Checking + AC3</strong>，可以保证每次指派后，限制图都有 graph arc consistency。</p><p>这个时候，我们发现每指派一步所进行的 checking 步骤（即 Graph Arc Consistency Checking）过于复杂，以至于我们应该把这个步骤单独提出为一个函数，如下：</p><p><img src="imgs/AC3.png" height="350px"></p><p>每次我们递归地指派一个结点的值，我们在检查是否违反 constraint 的时候，都要调用一次 <code>AC3</code> 函数，进行如下检查：</p><ol><li>获取当前所有结点变量及其定义域，并将限制图中每条<strong>有向边</strong>（如果限制条件是无向的，就等价于放双向边）都放入一个队列中；</li><li>当队列非空时，从队列取出一条有向边（限制条件），检查边的一致性（使用定义），如果违反，那么删去起始结点定义域中导致冲突的值，并且将当前边的起始结点<strong>作为终止结点时的</strong>所有边放入队列，等待重新检查一致性（代码就是 <code>REMOVE-INCONSISTENT-VALUES</code>）；</li><li>重复第 2 步直至队列中没有边（所有边都通过了一致性检查，又或者至少有一条边的定义域为空，即当前指派无解）；</li></ol><p>这里大家会发现，虽然这个算法确实提前避免违反限制的情况，但是时间复杂度是肉眼可见的大（时间复杂度 $O(n^2d^3)$，通过数据结构优化可以达到 $O(n^2d^2)$，n 为结点数量级，d 为 每个结点变量的定义域大小数量级）。所以这里就需要在 <strong>详细的检查以在浅处避免违反限制</strong> 和 <strong>简单的检查但平均递归深度较大时才能发现违反限制并放弃</strong> 这两种情况抉择。</p><blockquote><p>如果数据结点相当多，不希望递归深度很大，那么 AC3 算法为优；如果限制条件相当多，结点数又相对较少，不希望在检查上浪费太多时间，那么 forward checking 算法为优。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-0-Intro&quot;&gt;&lt;a href=&quot;#Chapter-0-Intro&quot; class=&quot;headerlink&quot; title=&quot;Chapter 0. Intro&quot;&gt;&lt;/a&gt;Chapter 0. Intro&lt;/h1&gt;&lt;h2 id=&quot;0-1-The-def</summary>
      
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="AI" scheme="https://sjtuxhw.top/tags/AI/"/>
    
    <category term="Algorithm" scheme="https://sjtuxhw.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Convex &amp; Optimizations</title>
    <link href="https://sjtuxhw.top/2024/06/15/Convex-Optimizations/"/>
    <id>https://sjtuxhw.top/2024/06/15/Convex-Optimizations/</id>
    <published>2024-06-15T07:18:39.000Z</published>
    <updated>2024-07-28T08:23:57.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-Overview"><a href="#Chapter-1-Overview" class="headerlink" title="Chapter 1. Overview"></a>Chapter 1. Overview</h1><p>进入本章前复习基础的数学知识：</p><ul><li><p>Vector Norms（范数）：对于向量 $x=(x_1,x_2,\ldots,x_n)$，$l_p$-norm 定义为：</p><script type="math/tex; mode=display">||x||_p={}^p\sqrt{|x|_1^p+|x|_2^p+\cdots+|x|_n^p}</script><p>正定性：$||x||_p\ge0,\space||x||_p=0\space\iff x=0$；</p><p>非线性性：$||tx||=|t|\space||x||,\space t\in\mathbf{R}$，$||x+y||\le||x||+||y||$（这个不等式并不好证。好证的三角不等式仅限于范数为 2 的特殊情况）；</p></li><li><p>正交阵 $A^TA=I$，因此一定满秩。此外正交阵列向量（或行）一定是相互正交的向量组，且模长为 1（单位正交向量，否则 $A^TA$ 就不是单位向量了）。</p><p>正交阵可以进行对角化 $A=P^{-1}BP$（$B$ 为对角阵，$P$ 为满秩矩阵）。所谓对角化可以感性理解为将这些正交向量组移动到与给定坐标轴的单位向量方向一致的方向上。</p><p>正交变换非常好的性质是 <strong>保范性</strong>。向量经过正交变换后，范数不变（形象理解为几何形状不变）。</p></li><li><p>实对称矩阵与实二次型一一对应。</p><p>实对称阵可以不满秩。但是一定有 $n$ 个实特征值（如果有 $k$ 个相等的特征值，称该特征值为 $k$ 重特征值），或者说 $r(A)$ 个不同的实特征值。</p><p>不相同的实特征值对应的特征向量 <strong>必定相互正交</strong>。</p><p>实对称阵可以进行谱分解（或称特征分解） $A=Q\Lambda Q^T$，可以证明 $Q$ 的每一列都是 $A$ 的一个特征向量（所以 $Q$ 是正交阵），$\Lambda$ 是对角阵，每个对角元对应一个 $A$ 的特征值。</p></li><li><p>Positive definite / positive semi-definite Matrices (正定阵和半正定阵)：若对于任意的 $n$ 维向量 $x\in\mathbf{R}^n$，都有 $x^TAx\ge0$，则称 $A$ 为半正定阵。<u>正定阵是特殊的实对称矩阵，它对应的二次型是正定二次型</u>。正定阵的判定方法如下：</p><ul><li><p>矩阵为对称矩阵，且特征值均为正；</p></li><li><p>矩阵为对称矩阵，且主元符号均为正；</p></li><li><p>矩阵为对称矩阵，其子行列式均为正；</p></li></ul></li></ul><h2 id="1-1-Mathematical-Optimization"><a href="#1-1-Mathematical-Optimization" class="headerlink" title="1.1 Mathematical Optimization"></a>1.1 Mathematical Optimization</h2><p>数学上对于优化问题的定义是：</p><script type="math/tex; mode=display">\begin{aligned}&minimize&f_0(x)&\\&subject\space to&f_i(x)&\le b_i,\quad i\in[1,m]\end{aligned}</script><p>其中</p><ul><li>$x=(x_1,\ldots,x_n)$ 被称为优化变量（optimization variables）;</li><li>$f_0:\mathbf{R}^n\rightarrow\mathbf{R}$ 被称为目标函数（objective function）;</li><li><p>$f_i:\mathbf{R}^n\rightarrow\mathbf{R},i\in[1,m]$ 被称为约束函数（constraint functions）；</p></li><li><p>将使得 $f_0$ 取得最小值，且满足约束条件的向量 $x^*$ 称为最优解（optimal solution）；</p></li></ul><p>常见的应用实例有：</p><ol><li><p>portfolio optimization（投资组合优化）：</p><ul><li>variables: 在不同 assets 上投资的数量；</li><li>constraints: budgets、每个 asset 所能分配的最大/最小金额、最小回报；</li><li>objective：总体风险，或者回报额；</li></ul></li><li><p>device sizing in electronic circuits（电路设计）：</p><ul><li>variables: device widths and lengths；</li><li>constraints: manufacturing limits, timing requirements, maximum area；</li><li>objective: power consumption；</li></ul></li><li><p>data fitting</p><ul><li>variables: model parameters；</li><li>constraints: prior information, parameter limits；</li><li>objective: measure of misfit or prediction error；</li></ul></li></ol><h2 id="1-2-Solving-Optimization-Problems"><a href="#1-2-Solving-Optimization-Problems" class="headerlink" title="1.2 Solving Optimization Problems"></a>1.2 Solving Optimization Problems</h2><p>数学上如何解决这些优化问题？实际上，对于一般的优化问题，相当难以求解，可能是 NP 问题，或者说不能在多项式时间内解决的问题。</p><p>但是我们其中有一类问题是特例，人们研究出了能够高效、可靠解决这类问题的方法，它们就是 <strong>凸优化问题</strong>（Convex Optimization Problem），包括但不限于最小二乘、线性规划、二次规划等等。</p><h3 id="1-2-1-Least-Squares"><a href="#1-2-1-Least-Squares" class="headerlink" title="1.2.1 Least-Squares"></a>1.2.1 Least-Squares</h3><p>最小二乘问题的目标是 $minimize\quad||Ax-b||_2^2$</p><p>目前有准确的解析解：$x^*=(A^TA)^{-1}A^Tb$，软件可以作出精确、高效地解析和运算（时间复杂度 $O(n^2k)$ 其中 $A\in\mathbf{R}^{k\times n}$）；</p><blockquote><p>注：软件层面并不是直接使用解析解运算。有些问题即便没有解析解，也能很简单地运算。解析解是在数学讨论的范围内。</p></blockquote><h3 id="1-2-2-Linear-Programming-LP"><a href="#1-2-2-Linear-Programming-LP" class="headerlink" title="1.2.2 Linear Programming (LP)"></a>1.2.2 Linear Programming (LP)</h3><p>此后会具体阐述的问题。线性规划的定义是：</p><script type="math/tex; mode=display">\begin{aligned}&maximize&c^Tx&\\&subject\space to&a_i^Tx&\le b_i,\quad i\in[1,m]\end{aligned}</script><p>这里一般性线性规划没有解析解，但是借助数学工具，可以以确定的算法步骤，高效可靠地得到答案，时间复杂度 $O(n^2m)$；</p><p>它不像 Least-Square 一样好识别，需要问题转换的技巧；</p><h3 id="1-2-3-Convex-Optimization-Problem"><a href="#1-2-3-Convex-Optimization-Problem" class="headerlink" title="1.2.3 Convex Optimization Problem"></a>1.2.3 Convex Optimization Problem</h3><script type="math/tex; mode=display">\begin{aligned}&minimize&f_0(x)&\\&subject\space to&f_i(x)&\le b_i,\quad i\in[1,m]\end{aligned}</script><p>其中目标函数、约束函数都是凸函数。凸函数定义为：</p><script type="math/tex; mode=display">f_i(\alpha x+\beta y)\le\alpha f_i(x)+\beta f_i(y)</script><p>其中 $\alpha+\beta=1,\space\alpha\ge0,\space\beta\ge0$；</p><blockquote><p>补充：仿射函数定义为 $f_i(\alpha x+\beta y)=\alpha f_i(x)+\beta f_i(y)$；</p></blockquote><ul><li>线性规划、最小二乘法都是 Convex Optimization Problem 的特例；</li><li>没有解析解，但有确定的算法步骤，高效可靠地得到答案，时间复杂度大致为 $\max\left\{n^3,n^2m,F\right\}$，其中 $F$ 为找到 $f_i$ 的一阶、二阶导数（偏导）所需的复杂度；</li><li>难以识别，需要一些技巧。</li></ul><h3 id="1-2-4-Nonlinear-Optimization-NLP-amp-Integer"><a href="#1-2-4-Nonlinear-Optimization-NLP-amp-Integer" class="headerlink" title="1.2.4 Nonlinear Optimization (NLP) &amp; Integer"></a>1.2.4 Nonlinear Optimization (NLP) &amp; Integer</h3><ul><li>Local Optimization Methods：<strong>选好 initial guess，在 feasible point 周围进行优化</strong>；</li><li>Global Optimization Methods：类似穷极法；</li></ul><h1 id="Chapter-2-Convex-Sets"><a href="#Chapter-2-Convex-Sets" class="headerlink" title="Chapter 2. Convex Sets"></a>Chapter 2. Convex Sets</h1><h2 id="2-1-Affine-Set"><a href="#2-1-Affine-Set" class="headerlink" title="2.1 Affine Set"></a>2.1 Affine Set</h2><p><img src="cimgs/affine-set.png"></p><p>仿射集的定义：如果一个仿射集同时包含了点 $x_1$ 和 $x_2$，且二者不相同，那么通过 $x_1$ 和 $x_2$ 直线上所有点的集合都在这个仿射集中。使用 $x=\theta x_1+(1-\theta)x_2$ 表示。</p><blockquote><p>注意，$x$ 是个向量（或者说坐标点）。随着 $\theta$ 的变动，表示的点在直线上滑动。</p></blockquote><p>举例：线性不等式的解集就是一种仿射集 $\left\{x|Ax=b\right\}$（相反地，所有仿射集都能表示为一个线性不等式的解集）；</p><blockquote><p>证明前者：若 $x_1$ 和 $x_2$ 为 $Ax=b$ 的两个不相等的解，那么 $Ax_1=b$，$Ax_2=b$，因此 $A(\theta x_1+(1-\theta)x_2)=\theta Ax_1+(1-\theta)Ax_2=\theta b+(1-\theta)b=b$；</p><p>（可以由 “线性性” 得到这个结论）</p></blockquote><h2 id="2-2-Convex-Set"><a href="#2-2-Convex-Set" class="headerlink" title="2.2 Convex Set"></a>2.2 Convex Set</h2><p>凸集的定义：如果 $x_1$ 和 $x_2$ 是凸集的相异两点，那么 $x_1$ 和 $x_2$ 组成的线段上的所有点也在该凸集内。</p><p>数学表示：$C$ 为凸集 $\Longleftrightarrow$ $\forall x_1,x_2\in C,\space x_1\ne x_2,\space 0\le\theta\le1\Rightarrow \theta x_1+(1-\theta)x_2\in C$；</p><blockquote><p>在 $x_1$ 到 $x_2$ 的线段上的所有点可以由 $x=\theta x_1+(1-\theta)x_2,\space0\le\theta\le1$ 表示。</p></blockquote><p><img src="cimgs/convex-set-def.png"></p><h2 id="2-3-Convex-Combination-Convex-Hull-amp-Convex-Cone"><a href="#2-3-Convex-Combination-Convex-Hull-amp-Convex-Cone" class="headerlink" title="2.3 Convex Combination, Convex Hull &amp; Convex Cone"></a>2.3 Convex Combination, Convex Hull &amp; Convex Cone</h2><p>凸组合的定义：对于一组点 $x_1,\ldots,x_k$，任何可以由 $x=\theta_1x_1+\theta_2x_2+\cdots+\theta_kx_k$ （$\sum\limits_{i=1}^{i=k}\theta_i=1$，$\theta_i\ge0$）表示的点，所构成的集合称为 $x_1,\ldots,x_k$ 的凸组合。</p><blockquote><p>凸组合的仿射系数和为 1.</p><p>一个凸集就是其任意相异两点 $x_1,x_2$ 的凸组合。所以凸集是一种凸组合。</p></blockquote><p>凸包（Convex Hull）的定义：对于一个点集 $S$，$S$ 中所有点的凸组合就称为 $S$ 的凸包，记作 $conv\space S$；</p><blockquote><p>形象的理解就是 <strong>用橡皮筋把最外围的点都包了起来，之后形成的图形，其内部所有的点都包含于凸包</strong>。</p><p>注意！凸包中的点的凸组合不唯一。一个点可以在其他若干个点的多种凸组合中。</p></blockquote><p><img src="cimgs/convex-hull-def.png" height="150px"></p><p>锥组合（Conic Combination）的定义：对于任意两个相异点 $x_1,x_2$，任何可以由 $x=\theta_1x_1+\theta_2x_2,\space \theta_1,\theta_2\ge0$ 表示的点，所构成的集合称为 $x_1,x_2$ 的锥组合。</p><blockquote><p>注意：<strong><u>锥组合没有要求仿射系数和为 1</u>，因此并不能说锥组合等同于凸集</strong>；</p></blockquote><p>凸锥（Convex Cone）的定义：对于一个点集 $S$，$S$ 中所有点的锥组合就称为 $S$ 的凸锥；</p><p><img src="cimgs/convex-cone-def.png" height="200px"></p><p>小小总结一下：</p><p>对于 $S=\left\{x|x=\theta_1x_1+\theta_2x_2\right\}$，其中 $x_1,x_2$ 为相异两点，</p><p>如果 $\theta_1,\theta_2$ 是普通的变量，那么称 $S$ 为 $x_1,x_2$ 的线性组合；</p><p>如果 $\theta_1,\theta_2\ge0$，那么称 $S$ 为 $x_1,x_2$ 的锥组合；</p><blockquote><p> 几何角度的锥组合：$S$ 所代表的区域内任意相异两点，满足原点到该两点连线方向的<u>射线</u>所包围区域中的点都在这个集合内；</p></blockquote><p>如果 $\theta_1+\theta_2=1$，那么称 $S$ 为包含 $x_1,x_2$ 的仿射集；</p><blockquote><p>几何角度的仿射集：$S$ 所代表的区域内任意相异两点所在的<u>直线</u>上的点都在这个集合内；</p></blockquote><p>如果 $\theta_1,\theta_2\ge0$ 且 $\theta_1+\theta_2=1$，那么称 $S$ 为 $x_1,x_2$ 的凸组合，或者说 $S$ 是一个包含 $x_1,x_2$ 的凸集（但没有“凸组合”准确，因为凸组合中的点可以只由 $x_1,x_2$ 凸组合而成）。</p><blockquote><p>几何角度的凸组合：$S$ 所代表的区域内任意相异两点所在的<u>线段</u>上的点都在这个集合内；</p></blockquote><h2 id="2-4-Hyperplanes-amp-Halfspaces"><a href="#2-4-Hyperplanes-amp-Halfspaces" class="headerlink" title="2.4 Hyperplanes &amp; Halfspaces"></a>2.4 Hyperplanes &amp; Halfspaces</h2><p>超平面的定义：$\left\{x|a^Tx=b\right\}$，其中 $a\ne0$（$a$ 为普通向量，0 代表零向量）；</p><p>半空间的定义：$\left\{x|a^Tx\le b\right\}$，其中 $a\ne0$；</p><p>从几何角度看，一个 N 元一次线性等式即可代表一个 N 维超平面，其中系数向量 $a$ 是该超平面的法向量（normal vector）。</p><p>一个 N 元一次线性不等式即可代表一个 N 维半空间，其中系数向量 $a$ 是指向该半空间界面的<u>外法线方向</u>的法向量。</p><p><img src='cimgs/hyperplane-halfspace-def.png' width="500px"></p><p><code>b</code> 向量的值影响的是垂直于 <code>a</code> 方向的超平面 / 半空间的位置；</p><hr><p>结论：</p><ul><li><p>hyperplane 既是仿射集，又是凸集；</p></li><li><p>halfspace 是凸集，但不是仿射集；</p><blockquote><p>回忆一下，仿射集要求集合内任意相异两点的仿射系数和为 1 所表示的点也在这个集合中。在几何角度理解，就是 <strong>区域内任意相异两点所在的直线上的点都在这个集合内</strong>。</p></blockquote></li></ul><p>如果不从几何角度理解，就通过数学语言证明。下面以证明 “halfspace 是凸集” 这一命题为例：</p><p>假设 $x_1,x_2$ 是 halfspace $S$ 上的任意相异两点。</p><p>要证 $S$ 是凸集，即证对 $\forall x=\theta x_1+(1-\theta)x_2,\space\theta\in[0,1]$，都有 $a^Tx\le b$ 成立。</p><p>则由条件 $x_1,x_2$ 是 $S$ 上相异两点可知，$a^Tx_1\le b,\space a^Tx_2\le b$；</p><p>故 $a^Tx=a^T\theta x_1+a^T(1-\theta)x_2\le \theta b+(1-\theta)b=b$，即 $a^Tx\le b$，原命题得证。</p><p>以后对于这类简单的证明不再作赘述。</p><h2 id="2-5-Euclidean-Balls-amp-Ellipsoids"><a href="#2-5-Euclidean-Balls-amp-Ellipsoids" class="headerlink" title="2.5 Euclidean Balls &amp; Ellipsoids"></a>2.5 Euclidean Balls &amp; Ellipsoids</h2><p>欧几里得球的定义：对于一个中心点 $x_c$ 和半径 $r$，定义点集：</p><script type="math/tex; mode=display">B(x_c,r)=\left\{x|\space||x-x||_2\le r\right\}=\left\{x_c+ru|\space||u||_2\le1\right\}</script><p> 为欧几里得球；</p><blockquote><p>注：式中的范数符号已定义在 Chapter 1 中，遗忘可以前往复习。</p></blockquote><p>椭球的定义：对于中心点 $x_c$，定义点集：</p><script type="math/tex; mode=display">\begin{equation}E=\left\{x|(x-x_c)^TP^{-1}(x-x_c)\le1\right\}\end{equation}</script><p>其中 $P\in\mathbf{S}^n_{++}$ （$P$ 为正定阵，正定阵一定是对称阵），上式也被称为二次不等式（quadratic inequality）。</p><p>注意：由解析几何的知识，<strong><u>椭球的半轴向量由 $P$ 的特征向量给出</u>，<u>椭球的半轴长由对应的特征值 $\sqrt{\lambda_i}$ 给出</u></strong>;</p><blockquote><p>因此，$P=r^2I$（$I$ 为单位矩阵）时，椭球就是一个欧几里得球；所以椭球是欧几里得球的泛化（generalization）；</p><p>另注：</p><p>$\mathbf{S}^n$ 表示 $n$ 阶对称阵组成的集合；</p><p>$\mathbf{S}^n_{++}=\left\{X\in S^n|X\succ0\right\}$ 表示所有 $n$ 阶正定阵组成的集合（概率学中的协方差矩阵就是一个正定阵）；</p><p>$\mathbf{S}^n_{+}=\left\{X\in S^n|X\succeq0\right\}$ 表示所有 $n$ 阶半正定阵组成的集合；</p></blockquote><p>当然椭球也可以表示为 $E=\left\{x_c+Au|\space||u||_2\le1\right\}$，其中 $A$ 为非奇异方阵。可以形象地理解为 $A$ “记录了椭球各个方向上的半径”。</p><blockquote><p>另外需要注意的是，$P$ 可以唯一表示一个椭球，这意味着 $P$ 与椭球点集<u>一一对应</u>。</p><p>但是 $A$ 却不能唯一表示一个椭球。因为对任意正交阵 $Q$（定义 $Q^TQ=I$），$AQ$ 表示的是一个椭球。</p><p>证明：</p><script type="math/tex; mode=display">\begin{aligned}&\left\{x_c+Au|\space||u||_2\le1\right\}\\=\space&\left\{x_c+AQQ^Tu|\space||u||_2\le1\right\}\\=\space&\left\{x_c+(AQ)(Q^Tu)|\space||Q^Tu||_2\le1\right\}\quad(||u||_2=||Q^Tu||_2)\\=\space&\left\{x_c+(AQ)u|\space||u||_2\le1\right\}\quad(\forall u)\end{aligned}</script><p>其中 $||u||_2=||Q^Tu||_2$ 由正交阵的保范性（$(Qu)^T(Qu)=u^TQ^TQu=u^Tu\Longrightarrow||Qu||=||u||$）得到。</p><p>再但！如果 $A$ 是个正定阵，那么这个表示又唯一了。</p></blockquote><hr><p>结论：欧几里得球、椭球是一个凸集。</p><h2 id="2-6-Norm-Balls-amp-Norm-Cones"><a href="#2-6-Norm-Balls-amp-Norm-Cones" class="headerlink" title="2.6 Norm Balls &amp; Norm Cones"></a>2.6 Norm Balls &amp; Norm Cones</h2><p>范式球的定义：对于中心点 $x_c$ 和半径 $r$，定义点集 $N_B=\left\{x|\space||x-x_c||\le r\right\}$ 为范式球；</p><blockquote><p>欧几里得球就是 2-范数下的范式球（或称 “二阶球”，second-order Euclidean ball）。</p></blockquote><p>范式锥的定义：定义图 $N_C=\left\{(x,t)|\space||x||\le t\right\},\space x\in\mathbf{R}^n，t\in\mathbf{R}$ 为范式锥；</p><blockquote><p>这里的 “图” 和计算机中 “图” 数据结构的概念不同。</p><p>这里的 “图” 是数学中的图，表示 “N 维坐标与值的二元组” 的集合，感性理解为：通常将 N 维坐标作为 “横轴”，对应的值为 “纵轴”，作出图形。例如 $\left\{(x,f(x))|x\in\mathbf{R}^n,f(x)\in\mathbf{R}\right\}$ 就是 $n$ 维实函数 $f(x)$ 的图。</p><p>这里范式锥的定义实际上是 <strong>上境图（epigraph）</strong>，因为 $t$ 和 $x$ 不是等号关系（函数关系），而是：$||x||\le t$；因此表示的是如下图锥（实心）；</p><p>另外，如果将小于等于改为大于等于，那么就是 亚图（hypograph）；</p></blockquote><p><img src="cimgs/norm-cone-def.png"></p><blockquote><p>范数为 2 时，范式锥又称为 circular cone（圆锥）；</p><p>此时可以写作 $N_C=\left\{(x,t)|\space x^Tx\le t^2\right\},\space x\in\mathbf{R}^n，t\in\mathbf{R}$</p></blockquote><hr><p>结论：范式球、范式锥都是凸集。</p><h2 id="2-7-Polyhedra-Polytopes"><a href="#2-7-Polyhedra-Polytopes" class="headerlink" title="2.7 Polyhedra (Polytopes)"></a>2.7 Polyhedra (Polytopes)</h2><blockquote><p>多面体 Polyhedron 的复数形式。</p><p>这里要讨论的是 polytopes（多胞形，多面体的特殊情况），也就是封闭的多面体。</p><p>但有些作者把这两个词含义颠倒了。所以建议使用时，固定一种说法，然后用 “封闭的” 形容词来区分这两种情况。</p></blockquote><p>多面体的定义：可以由一组有限个线性不等式和等式的解集所描述的集合。</p><script type="math/tex; mode=display">Ax\preceq b,\quad Cx=d</script><p>其中 $A\in\mathbf{R}^{m\times n},\space C\in\mathbf{R}^{p\times n}$，$\preceq$ 为 component-wise inequality，是逐分量不等号，对每个分量都有一个不等式。这强调的是：$A$ 的每一行的行向量 $a$ 与 $x$ 点积都小于等于向量 $b$ 的对于行的值，即 $ax\le b_i$；这个不等式描述了一个半空间，因此 $Ax\preceq b$ 就描述了一组半空间。</p><p><img src="cimgs/poly-def.png"></p><p>所以说，多面体可以由一组超平面和半空间的交集来表示。</p><h2 id="2-8-Positive-Semi-definite-Cone"><a href="#2-8-Positive-Semi-definite-Cone" class="headerlink" title="2.8 Positive Semi-definite Cone"></a>2.8 Positive Semi-definite Cone</h2><p>半正定锥的定义：对于所有半正定阵构成的集合 $\mathbf{S}^n_+$ 一定是凸锥（这里不再局限于之前讨论的 “点” 了，可以扩展到其他可以通过运算来验证定义的对象上）。这个锥被称为半正定锥。</p><blockquote><p>为什么 $\mathbf{S}^n_+$ 一定是凸锥？因为任意两个半正定阵的锥组合一定还是半正定的（回忆锥组合的定义）。</p></blockquote><h2 id="2-9-Operations-that-preserve-Convexity"><a href="#2-9-Operations-that-preserve-Convexity" class="headerlink" title="2.9 Operations that preserve Convexity"></a>2.9 Operations that preserve Convexity</h2><p>介绍不改变凸性的操作。这样做的意义是，可以将上面几种基本的凸形扩展出去，方便证明某些问题的凸性，方便以后转换问题为凸问题。</p><blockquote><p>就像做微积分中的积分问题，我们先讨论几个原子函数，然后通过一些不改变积分值的运算或变换，来得到更复杂函数的积分值。</p></blockquote><p>实际的应用例如，如何判断给定集合是否为凸集？方法如下：</p><ul><li><p>根据凸集的基本定义判断：$C$ is a convex $\Longleftrightarrow x_1,x_2\in C\Rightarrow \theta x_1+(1-\theta)x_2\in C,\space\theta\in[0,1]$；</p></li><li><p><u>根据不改变凸性的操作，将问题等价转换为以上基本凸形</u>。</p></li></ul><p>那么哪些操作不改变凸性？</p><ul><li>intersection：取交集。两个凸集的交集仍然是凸集；</li><li>affine functions：仿射变换。一个凸集经过仿射变换、仿射变换逆变换后仍然是凸集；</li><li>perspective functions：透视函数变换。</li><li>linear-fractional functions：线性分式函数变换。</li></ul><h3 id="2-9-1-Intersection"><a href="#2-9-1-Intersection" class="headerlink" title="2.9.1 Intersection"></a>2.9.1 Intersection</h3><p>我们如何利用交集不改变凸性的性质来解决一些问题呢？</p><p>举个例子，$S=\left\{x\in\mathbf{R}^m|\space|p(t)|\le1,\space |t|\le\dfrac{\pi}{3}\right\}$，其中 $p(t)=\sum\limits_{k=1}^mx_k\cos kt$（$p(t)$ 为三角多项式，trigonometric polynomial）就是一个凸集。</p><p>怎么证明？想识别这个集合的凸性有点困难，因为 $m\ge5$ 的情况下甚至不能表示出这个集合，所以我们肯定不能用凸集的定义了。</p><p>我们想要化简这个集合来方便操作。试想我们定义另一个集合 $S_t=S|_t=\left\{x\in\mathbf{R}^m|\space|p(t)|\le1\right\}$，如果固定 $t$ 为某个常数，情况是不是简单了点？</p><p>这个时候 $S$ 集合就是多个 $S_t$ 集合的<strong>交集</strong>：$S=\bigcap\limits_{|t|\le\pi/3}S_t$，因此我们看看能否证明 $S_t$ 的凸性，就能直接得到 $S$ 的凸性了。</p><blockquote><p>为什么 $S$ 集合是多个 $S_t$ 集合的<strong>交集</strong>？</p><p>可以这么理解，对某个 $t$ 的 $S_t$ 中，可能包含了满足对所有 $|t|\le\dfrac{\pi}{3},|p(t)|\le1$ 的点，也可能包含仅仅在当前的 $t$ 下才满足 $|p(t)|\le1$ 的点。作交集就筛除了不满足 $|t|\le\dfrac{\pi}{3}$ 下 $|p(t)|\le1$ 条件的点。</p><p>这就是性质：</p><script type="math/tex; mode=display">\left\{x|Pred(x,y),y\in A\cup B\right\}=\left\{x|Pred(x,y),y\in A\right\}\cap\left\{x|Pred(x,y),y\in B\right\}</script></blockquote><p>结果发现 $S_t$ 相当容易判断凸性，因为这个时候 $p(t)$ 退化为了关于向量 $x$ 的线性约束条件：</p><script type="math/tex; mode=display">\begin{aligned}S_t=&\left\{x\in\mathbf{R}^m|\space|p(t)|\le1\right\}\\=&\left\{x\in\mathbf{R}^m|-1\le\left[\begin{aligned}\cos t\\\cos 2t\\\cdots\\\cos mt\end{aligned}\right]x\le1\right\}\end{aligned}</script><p>这不就是两个半空间所夹成的区域的点集（取交集）吗！我们知道 halfspace 是凸集，两个 halfspce 的交集也是凸集，因此 $S_t$ 是凸集。</p><p>因为这里 $t$ 是任意的，所以对所有固定的 $t$ 都有 $S_t$ 是凸集，而 $S$ 是所有 $|t|\le\dfrac{\pi}{3}$ 情况的 $S_t$ 的交集，所以 $S$ 是凸集。</p><h3 id="2-9-2-Affine-Function"><a href="#2-9-2-Affine-Function" class="headerlink" title="2.9.2 Affine Function"></a>2.9.2 Affine Function</h3><p>仿射函数定义为：对定义域上任意两个值 $x,y$，对任意的 $\theta\in[0,1]$，都有 $f(\theta x+(1-\theta)y)=\theta f(x)+(1-\theta)f(y)$，因此也是一种非凸非凹的函数。</p><p>假设函数 $f:\mathbf{R}^n\rightarrow\mathbf{R}^m$ 是仿射函数（就是线性变换）；</p><blockquote><p>例如自变量为向量的仿射函数 $f(x)=Ax+b$，其中 $A\in\mathbf{R}^{m\times n},b\in\mathbf{R}^m$；</p></blockquote><p>那么凸集关于仿射函数函数的像（或者说凸集经过仿射变换后得到的集合）一定是凸集：</p><script type="math/tex; mode=display">S\subseteq \mathbf{R}^n\space convex\Longrightarrow f(S)=\left\{f(x)|x\in S\right\}\space convex</script><p>逆变换也是如此。如果一个集合经过仿射变换后的像是凸集，那么原先的集合也是凸集：</p><script type="math/tex; mode=display">C\subseteq\mathbf{R}^m\space convex\Longrightarrow f^{-1}(C)=\left\{x\in\mathbf{R}^n|f(x)\in C\right\}\space convex</script><blockquote><p>甚至这个 $f$ 不是个可逆函数（比如 $f$ 不是单射函数，但 $f$ 作为一个关系而言，是可逆的），上式也成立。</p></blockquote><p>常见的仿射函数有：缩放（scaling）、平移（translation）、投影（projection）等。</p><p>仿射函数可以用在哪些题型上？</p><p>例如线性矩阵不等式的解集 $\left\{x|x_1A_1+x_2A_2+\cdots+x_mA_m\preceq B\right\}$，其中 $A_i,B\in\mathbf{S}^p$ 。</p><p>这个时候，判断这个集合的凸性可以定义一个函数 $f:\mathbf{R}^m\rightarrow\mathbf{S}^p$（将 $m$ 维向量映射到 $p$ 阶对称矩阵上），这个函数定义为 $f(x)=B-\sum\limits_{i=1}^mx_iA_i$。很容易知道 $f$ 的像（集合）一定是一个 positive semi-definite cone（半正定锥，因为对任意的 $x$ 都有 $f(x)\succeq0$，$f(x)\in \mathbf{S}^p$），即凸集，因此原集合（$f(x)$ 的逆像）也是一个凸集。</p><p>再例如双曲锥面，$\left\{x|x^TPx\le(c^Tx)^2,\space c^Tx\ge0\right\}$，其中 $P\in\mathbf{S}^n_+$；</p><p>判断这个集合为凸集，也可以构造一个函数，$f:\mathbf{R}^n\rightarrow (\mathbf{R}^n,\mathbf{R})$，即 $f(x)=(P^{1/2}x,\space c^Tx)$，其中 $(P^{1/2})^2=P$；$f$ 就是个仿射函数（可以按仿射函数定义来测试），并且 $\left\{(x,t)|\space x^Tx\le t^2\right\},\space x\in\mathbf{R}^n，t\in\mathbf{R}$（二阶范式锥）正好是双曲锥面在 $f$ 上的像，因此双曲锥面是个凸集。</p><h3 id="2-9-3-Perspective-amp-Linear-Fractional-Function"><a href="#2-9-3-Perspective-amp-Linear-Fractional-Function" class="headerlink" title="2.9.3 Perspective &amp; Linear-Fractional Function"></a>2.9.3 Perspective &amp; Linear-Fractional Function</h3><p>透视函数定义为 $f:\mathbf{R}^{n+1}\rightarrow\mathbf{R}^n$（所有降低参数 1 个维度的函数）；</p><p>例如 $P(x,t)=\dfrac{x}{t}$，$dom\space P=\left\{(x,t)|t\gt0\right\}$；就是一个透视函数。</p><p>透视函数的像、逆像中有一个是凸集，那么另一个就是凸集。</p><hr><p>线性分式函数是 透视函数 和 仿射函数 的复合，定义为：$f(x)=\dfrac{Ax+b}{C^Tx+d}$，其中 $dom\space f=\left\{c^Tx+d\gt0\right\}$；</p><p>线性分式函数的像、逆像中有一个是凸集，那么另一个就是凸集。</p><h2 id="2-10-Generalized-Inequality"><a href="#2-10-Generalized-Inequality" class="headerlink" title="2.10 Generalized Inequality"></a>2.10 Generalized Inequality</h2><p>为了定义广义不等式（以便对凸优化进行处理、评价），人们引入了 proper cone（正常锥）的概念。</p><p>如果一个凸锥满足：</p><ul><li>K is closed (contains its boundary)</li><li>K is solid (has nonempty interior)</li><li>K is pointed (contains no line)</li></ul><p>那么这个凸锥就是正常锥。常见的正常锥有：</p><ul><li>非负实数集合 $R_+$；</li><li>非负象限 $R^n_+$；</li><li>半正定阵集合 $S^n_+$；</li></ul><p>简而言之，<u>正常锥是为了描述一种抽象的非负关系</u>（可以与离散数学中的偏序关系联系起来考虑），例如对向量而言的广义不等式可以在非负象限内考虑（感性理解：<u>两个向量之差在非负象限内才是广义大于关系</u>）：</p><script type="math/tex; mode=display">x\preceq_{\mathbf{R}^n_+}y\Longleftrightarrow x_i\le y_i</script><p>对于矩阵而言可以在半正定矩阵集合内考虑：</p><script type="math/tex; mode=display">X\preceq_{\mathbf{S}^n_+}Y\Longleftrightarrow Y-X\quad positive\space semidefinite</script><p>这样会发现（和偏序关系一样），广义不等式的许多性质（例如自反性、反对称性、传递性等）都和实数域上的不等关系一样。</p><p>但是，根据离散数学中的定义，广义不等关系不一定是线序关系（可以同时有 $x\npreceq_Ky$ 和 $y\npreceq_Kx$，即二者不可比）；</p><p>但我们仍然可以定义广义不等关系的 “最小元素”（为以后的凸优化做准备），但是因为 “不可比” 关系的存在，“最小” 的概念分裂成了最小元素（minimum，所有的元素都可与这个元素比较，并且是最小的）和 极小元素（minimal，可以与这个元素比较的所有元素都比它大）。它们的含义已经在离散数学的 “关系” 一章定义清楚了。</p><p><img src="cimgs/min-elements-def.png" height="400px"></p><p>如上图，在 $\mathbf{R}^n_+$ 中，凸集 $S_1$ 的最小元素是 $x_1$，因为它可以在 $R^n_+$ 上与其他任何元素比较（即凸集代表的图像全部包含在阴影部分区域内），并且它比所有元素都小；</p><p>凸集 $S_2$ 没有最小元素（因为发现 $\mathbf{R}^n_+$ 总是无法完全盖住这个凸集代表的图形，意味着有些元素间不可比），但它有无穷多个极小元素。其中一个极小元素 $x_2$，因为所有能比较的元素中，没有比它小的（即它的非正轴区域没有任何元素）。可以说 $x_2$ 所在的平边界上所有点都是 $S_2$ 关于 $\mathbf{R}^n_+$ 的极小元素。</p><h2 id="2-11-Seperating-amp-Supporting-Hyperplane-Theorem"><a href="#2-11-Seperating-amp-Supporting-Hyperplane-Theorem" class="headerlink" title="2.11 Seperating &amp; Supporting Hyperplane Theorem"></a>2.11 Seperating &amp; Supporting Hyperplane Theorem</h2><p>超平面分割定理。直觉上非常明显的定理。如果 $C$ 和 $D$ 是两个不相交凸集，那么必然存在向量 $a\ne0$ 和 $b$ 使得：$a^Tx\le b$ 对 $\forall x\in C$ 成立，$a^T x\ge b$ 对 $\forall x\in D$ 成立。感性理解如下图：</p><p><img src="cimgs/SHT.png" width="300px"></p><p>理解：一定存在一个超平面 $\left\{x|a^Tx=b\right\}$ 使得它能够完全划分两个不相交凸集。</p><blockquote><p>在机器学习中，将这个超平面称为 “线性分类器”。</p></blockquote><p>如果要 “严格划分”（去掉等号），还需要作出前提假设：例如 $C$ 是闭集等。</p><hr><p>超平面支持定理。直觉上也非常明显。对于一个凸集 $C$，一定能找到一个点 $x_0$ 以及一个超平面 $\left\{x|a^Tx=ax_0\right\}$ （$a\ne0$）使得 $a^Tx\le a^Tx_0$ 对 $\forall x\in C$ 成立。</p><p>感性理解如下：</p><p><img src="cimgs/SHT2.png" width="250px"></p><p>理解：对凸集边界上任意一点 $x_0$，一定存在一个超平面 $\left\{x|a^Tx=ax_0\right\}$ 使得它能够与凸集相切于该点，并且该点处外法线方向与 $a$ 同向（“移动” 超平面切到这个凸集的该点上）。</p><p>它可以由超平面分割定理证明出来。</p><h2 id="2-12-Dual-Cones"><a href="#2-12-Dual-Cones" class="headerlink" title="2.12 Dual Cones"></a>2.12 Dual Cones</h2><p>对偶锥的定义：对于一个凸锥 $K$，其对偶锥为 $K^*=\left\{y|y^Tx\ge0\space for\space all\space x\in K\right\}$；</p><p>形象理解：对偶锥的画法；</p><p><img src="cimgs/dual-cone-draw.png" height="200px"></p><p>（如果 $K$ 是尖的，那么 $K^*$ 就是钝的，二者是互补、对偶的）数学中有很多种类似的关系，例如共轭、转置等等。</p><p>其中 $\mathbf{R}_+^n$、 $\mathbf{S}^n_+$、二阶范式锥是自对偶的（self-dual）。一阶范式锥和无穷阶范式锥互为对偶锥。</p><p>注意，正常锥的对偶锥一定是正常锥。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-1-Overview&quot;&gt;&lt;a href=&quot;#Chapter-1-Overview&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1. Overview&quot;&gt;&lt;/a&gt;Chapter 1. Overview&lt;/h1&gt;&lt;p&gt;进入本章</summary>
      
    
    
    
    <category term="review" scheme="https://sjtuxhw.top/categories/review/"/>
    
    
    <category term="Math" scheme="https://sjtuxhw.top/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Numeric Analysis for Beginners</title>
    <link href="https://sjtuxhw.top/2024/06/12/Numeric-Analysis-for-Beginners/"/>
    <id>https://sjtuxhw.top/2024/06/12/Numeric-Analysis-for-Beginners/</id>
    <published>2024-06-12T05:11:56.000Z</published>
    <updated>2024-07-28T08:30:58.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-Basic-Concepts"><a href="#Chapter-1-Basic-Concepts" class="headerlink" title="Chapter 1. Basic Concepts"></a>Chapter 1. Basic Concepts</h1><ul><li><p>相对误差与绝对误差；</p></li><li><p>求根问题：$\text{For }f:\mathbf{R}\rightarrow\mathbf{R},\text{ find }x^*\text{ such that }f(x^*)=0$；</p><p>假设有估计解 $x_{est}$，但是 $0\lt |f(x_{est})|\ll1$，那么我们也许不知道 $|x_{est}-x_0|$，但是我们一定知道 $|f(x_{est})-f(x_0)|\equiv|f(x_{est})|$；</p><ul><li><p>前向误差：估计解与实际解的差值（就是上面的 $|x_{est}-x_0|$，一般我们不知道）；</p></li><li><p>后向误差：使得估计值正确所要让 problem statement 改变的 delta（就是上面的 $|f(x_{est})-f(x_0)|\equiv|f(x_{est})|$，一般我们能算出来）；</p></li><li><p>Well-Conditioned（insensitive）：$\text{Small backward error}\Rightarrow\text{Small forward error}$；</p></li><li><p>Poor-Conditioned（sensitive/stiff）：$\text{Small backward error}\nRightarrow\text{Small forward error}$；</p></li><li><p>Condition Number：$CN=\dfrac{\text{Forword Error}}{\text{Backward Error}}$；</p><blockquote><p>在寻根问题中，很容易得到 $CN=\dfrac{1}{|f^\prime(x^*)|}$；</p></blockquote></li></ul></li><li><p>Carefully Implementation</p><ul><li>防止溢出的方法：Element Scaling（例如求 $||\vec{x}||_2$）；</li></ul></li></ul><h1 id="Chapter-2-Linear-System-and-LU"><a href="#Chapter-2-Linear-System-and-LU" class="headerlink" title="Chapter 2. Linear System and LU"></a>Chapter 2. Linear System and LU</h1><h2 id="2-1-Review"><a href="#2-1-Review" class="headerlink" title="2.1 Review"></a>2.1 Review</h2><ul><li><p>Over Determined / Under Determined / Completely Determined.</p><blockquote><p>“高” 的矩阵可能是 over determined（更多限制条件）；</p><p>“宽” 的矩阵可能是 under determined（解更可能有无限个）；</p></blockquote></li><li><p>线性方程组的结论复习：一个线性方程组 $A\vec{x}=\vec{b}$ 有两个不同解 $\vec{x_0},\vec{x_1}$，则它有无穷多解；</p><blockquote><p> $\vec{x_0},\vec{x_1}$ 都是线性方程组的解，则它们的线性组合都是该线性方程组的解；</p></blockquote></li><li><p>经验结论：解线性方程组 $A\vec{x}=\vec{b}$ 能不解 $A^{-1}$ 就不解它（计算量和准确性）；</p></li><li><p>初等行变换：左乘初等矩阵；</p><blockquote><p>初等矩阵是指由单位矩阵经过一次基本行/列变换得到的矩阵。基本行/列变换包括以下三种操作：</p><ul><li><p><strong>交换型初等矩阵</strong>：形式为单位矩阵的两行（或列）交换得到的矩阵。例如，在3阶方阵中，交换第一行和第二行的单位矩阵为：</p><script type="math/tex; mode=display">\left[\begin{matrix}0&1&0\\1&0&0\\0&0&1\end{matrix}\right]</script></li><li><p><strong>倍加型初等矩阵</strong>：单位矩阵的某一行（或列）乘以非零常数后加到另一行（或列）得到的矩阵。例如，在3阶方阵中，将第一行的两倍加到第三行的单位矩阵为：</p><script type="math/tex; mode=display">\left[\begin{matrix}1&0&0\\0&1&0\\2&0&1\end{matrix}\right]</script></li></ul><ul><li><strong>倍乘型初等矩阵</strong>：单位矩阵的某一行（或列）乘以非零常数得到的矩阵。例如，在3阶方阵中，将第三行的元素都乘以2的单位矩阵为：<script type="math/tex; mode=display">\left[\begin{matrix}1&0&0\\0&1&0\\0&0&2\end{matrix}\right]</script></li></ul><p>将一个矩阵左乘对应的初等矩阵就是在对行进行对应的变换；</p><p>将一个矩阵右乘对应的初等矩阵就是在对列进行对应的变换；</p></blockquote></li><li><p>高斯消元：先 forward substitution（将第 i 行的前 i - 1 个元素清零、第 i 个元素置 1），再 back substitution（向之前代入）；</p></li></ul><h2 id="2-2-LU-Factorization"><a href="#2-2-LU-Factorization" class="headerlink" title="2.2 LU Factorization"></a>2.2 LU Factorization</h2><p>LU 分解：当参数矩阵不变，只有 $\vec{b}$ 不同时，我们可以节省重复计算的步骤。这种方法就是 $LU$ 分解。</p><ul><li>我们先将 $A$ 矩阵使用高斯消元为 $A=LU$（$U$ 是高斯消元的 forward substitution 的结果）；</li><li>这样可以分开计算 $L\vec{y}=b$ 中的 $\vec{y}$、$U\vec{x}=\vec{y}$ 解得 $\vec{x}$，每一步都是 $O(n^2)$；并且得到上/下三角矩阵的逆要比一般的 $A$ 简单；</li></ul><p><img src="imgs2/LU.png"></p><h2 id="2-3-Linear-System"><a href="#2-3-Linear-System" class="headerlink" title="2.3 Linear System"></a>2.3 Linear System</h2><ul><li><p>线性回归预测</p></li><li><p>线性系统拟合曲线：n 次试验构建一个线性方程组；</p><p><img src="imgs2/linear-fit.png" height="150px"></p><blockquote><p>线性系统拟合非线性曲线：可以让 $f$ 是非线性的，构建一个非线性函数 $f_{ij}$ 的矩阵；</p><p><img src="imgs2/ffit.png" height="200px"></p><p>一个特殊的例子是范特蒙德系统 $f=a_0+a_1x+a_2x^2+\cdots$；</p><p>我们还可以借助傅里叶展开 $f=a\cos(x+\phi)$；</p></blockquote></li><li><p>$A\vec{x}=\vec{b}$ 无解情况如何接近？凸优化：$\min\limits_{\vec{x}}||A\vec{x}-\vec{b}||_2^2$；</p><p><img src="imgs2/ms.png" height="300px"></p></li><li><p>Tikhonov regularization：这种正则化可以向 under determined 的情况加入限制，有助于防止过拟合、数据抖动、减轻数据噪声影响（对高斯白噪声效果好）等问题：</p><script type="math/tex; mode=display">\min\limits_{\vec{x}}||A\vec{x}-\vec{b}||_2^2+\alpha||\vec{x}||_2^2\quad(0\lt\alpha\le1)\\\Longrightarrow0=2A^TA\vec{x}-2A^T\vec{b}+2\alpha\vec{x}\\\Longrightarrow(A^TA+\alpha I_{n\times n})\vec{x}=A^T\vec{b}</script></li><li></li><li><p>稀疏矩阵存储：变换为低维数据（压缩信息的相关性）；</p><ul><li>普通有规律的矩阵，可以通过一些变换转换为稀疏矩阵；</li></ul></li></ul><h2 id="2-5-Cholesky-Factorization"><a href="#2-5-Cholesky-Factorization" class="headerlink" title="2.5 Cholesky Factorization"></a>2.5 Cholesky Factorization</h2><p>注意到重要的矩阵 $A^TA$ 有如下性质：</p><ul><li>正定对称阵（Positive definite Matrix）其中 $A\ne0$；</li></ul><p>而我们又发现正定对称矩阵的 LU 分解非常特殊，$U=L^T$，所以所有正定对称阵可以分解为 $A=LL^T$，这就是 Cholesky 分解；</p><ul><li><p>在阶数较小的情况，直接可以使用待定系数法求解 $L$；</p></li><li><p>在阶数较大的情况，使用迭代法求解 $L$，算法如下：</p><ol><li><p>初始化 $L=0$（全零矩阵，同时是下三角矩阵）；</p></li><li><p>对矩阵的每一列 $j$：</p><ul><li><p>先计算该列上的对角元 $L_{jj}=\sqrt{A_{jj}-\sum\limits_{k=1}^{j-1}L_{jk}^2}$（$j\gt1$），其中 $L_{11}=\sqrt{A_{11}}$；</p><blockquote><p>不难发现，$L$ 每行对角元只与 $A_{jj}$ 和当前行排在 $L_{jj}$ 之前的元素平方和有关；</p><p>可以将 $A$ 分块，即可推出这个结论；</p></blockquote></li><li><p>在第 $j$ 列中，继续对第 $j$ 行之后的每一行 $i\gt j$，计算 $L_{ij}=\dfrac{1}{L_{jj}}(A_{ij}-\sum\limits_{k=1}^{j-1}L_{ik}L_{jk})$，</p><blockquote><p>结论，$L_{ij}$ 与 $A_{ij}$ 和：排在 $L_{jj}$ 前面的元素向量 与 排在 $L_{ij}$ 前面的元素向量的点积有关；</p></blockquote></li></ul><p>完成上面两个步骤后，矩阵的第 $j$ 列全部计算完成；</p></li></ol></li></ul><h1 id="Chapter-3-Norms-Sensitivity-amp-Conditioning-in-Matrix"><a href="#Chapter-3-Norms-Sensitivity-amp-Conditioning-in-Matrix" class="headerlink" title="Chapter 3. Norms, Sensitivity &amp; Conditioning in Matrix"></a>Chapter 3. Norms, Sensitivity &amp; Conditioning in Matrix</h1><h2 id="3-1-Definitions-of-Norms-in-Matrix"><a href="#3-1-Definitions-of-Norms-in-Matrix" class="headerlink" title="3.1 Definitions of Norms in Matrix"></a>3.1 Definitions of Norms in Matrix</h2><p>引入：在浮点数计算时，如果在处理 $||A\vec{x_0}-\vec{b}||$ 时，它距离 0 有多接近才能相信 $x_0$ 是解？</p><p>也就是说，如何衡量 $(A+\delta A)\vec{x}=\vec{b}+\delta\vec{b}$ 求解下 $\vec{x}$ 解的变换幅度？</p><p>我们再次引入向量的范数：$||\vec{x}||_p=(\sum\limits_{i=1}^nx_i^p)^{1/p}$；</p><blockquote><ul><li>注意到 $p\rightarrow\infty$ 是 $||\vec{x}||=\max\{|x_1|,|x_2|,\ldots,|x_n|\}$；</li><li>$||\vec{x}||=0\quad\text{iff}\quad \vec{x}=0$；</li><li>$||c\vec{x}||=|c|||\vec{x}||,\space c\in\mathbf{R},\vec{x}\in\mathbf{R^n}$；</li><li>$||\vec{x}+\vec{y}||\le||\vec{x}||+||\vec{y}||,\space\forall\vec{x},\vec{y}\in\mathbf{R}$；</li></ul></blockquote><p>我们定义两个范数等价（$||\cdot||_p\equiv||\cdot||_q$） 当且仅当 对于任意 $\vec{x}\in\mathbf{R^n}$，都存在 $c_{low}||\vec{x}||\le||\vec{x}||\le c_{high}||\vec{x}||$（同阶）；</p><blockquote><p>推论：$\mathbf{R^n}$ 上的任意范式等价；</p></blockquote><p>我们再定义矩阵的范数：</p><ul><li><p>定义方法 1，“unrolled construction”（元素形式范数，entrywise norm）：将矩阵 $A_{m\times n}$ 按列展开（第 $n+1$ 列排在第 $n$ 列下方），得到一个 $\vec{a}\in\mathbf{R^{mn}}$ 的向量，而向量 $\vec{a}$ 的范数就是 $A$ 的范数；</p><script type="math/tex; mode=display">||A_{m\times n}||_p=(\sum\limits_{i=1}^m\sum\limits_{j=1}^n|a_{ij}|^p)^{1/p}</script><ul><li>二维元素形式范数又称 “Frobenius Norm”，记作 $||A||_{Fro}$；注意到 $||A||_F=\sqrt{\text{tr}(AA^T)}$；</li></ul></li><li><p>定义方法 2，“induced construction”（诱导范数，又称算子范数，operator norm）：描述了矩阵代表的线性变换 $A$ 对 $\vec{x}$ 作用最长伸展的比例。即：</p><script type="math/tex; mode=display">||A||=\max_{\vec{x}\ne0}\dfrac{||A\vec{x}||}{||\vec{x}||}=\max\limits_{||\vec{x}||=1}||A\vec{x}||</script><p>诱导范数的常用结论如下：</p><ul><li><p>$||A||_1=\max\limits_{1\le j\le n}\sum\limits_{i=1}^m|a_{ij}|$（1-诱导范数就是一列中的元素模之和，再取最大值）；</p></li><li><p>$||A||_\infty=\max\limits_{1\le i\le m}\sum\limits_{j=1}^n|a_{ij}|$（$\infty$-诱导范数就是一行中的元素模之和，再取最大值）；</p></li><li><p>$||A||_2=\sqrt{\max\limits_{k}\lambda_k}$（2-诱导范数，又称谱范数，是 $A$ 的最大奇异值的开根号。也就是说，当 $A$ 不可逆时就是 $A^TA$ 的最大特征值开根号）；</p><blockquote><p>可以从图形方法理解：</p><p><img src="imgs2/matrix-norm2.png" width="400px"></p></blockquote></li></ul></li><li><p>定义方法 3，“eigenvalue construction”（schatten 范数，使用矩阵奇异值定义），具体定义较为复杂，不进一步了解；</p></li></ul><h2 id="3-2-Definition-of-Condition-Number-in-Matrix"><a href="#3-2-Definition-of-Condition-Number-in-Matrix" class="headerlink" title="3.2 Definition of Condition Number in Matrix"></a>3.2 Definition of Condition Number in Matrix</h2><p>我们还要定义一个矩阵的条件数。一般条件数想要看的是一个矩阵构成的线性方程组随误差的变化情况。于是我们需要构建建模一个公式：$(A+\varepsilon\delta A)\vec{x}(\varepsilon)=\vec{b}+\varepsilon\delta\vec{b}$，于是可以得到在误差 $\varepsilon$ 下，</p><ul><li><p>$\vec{x}(\varepsilon)$ 表示在误差 $\varepsilon$ 下的 $\vec{x}$ 测量值；</p></li><li><p>$\dfrac{d\vec{x}}{d\varepsilon}|_{\varepsilon=0}=A^{-1}(\delta\vec{b}-\delta A\vec{x}(0))$ 表示 $\vec{x}$ 随误差的变化率；</p></li><li><p>$||\vec{x}(\varepsilon)-\vec{x}(0)||$ 表示前向误差，$\dfrac{||\vec{x}(\varepsilon)-\vec{x}(0)||}{||\vec{x}(0)||}\le|\varepsilon|||A^{-1}||||A||(\dfrac{||\delta\vec{b}||}{||\vec{b}||}+\dfrac{||\delta A||}{||A||})+O(\varepsilon^2)$ 表示归一化的前向误差；</p><blockquote><p>泰勒展开证明上式；</p></blockquote></li><li><p>于是我们定义方阵 $A\in\mathbf{R^{n\times n}}$ 的条件数为：$\text{cond}\space A\equiv\kappa\equiv||A||||A^{-1}||$；</p><p>如果 $A$ <u>不可逆</u>，则条件数为 $\infty$；</p><blockquote><p>得出结论：$\dfrac{||\vec{x}(\varepsilon)-\vec{x}(0)||}{||\vec{x}(0)||}\le\varepsilon\cdot D\cdot\kappa+O(\varepsilon^2)$；</p></blockquote><p>可以知道，一个矩阵的条件数描述的性质和行列式不一样，条件数与常系数缩放无关；</p></li><li><p><strong>重要推论 1</strong>：$\text{cond}\space A=\dfrac{\max\limits_{\vec{x}\ne0}\frac{||A\vec{x}||}{||\vec{x}||}}{\min\limits_{\vec{y}\ne0}\frac{||A\vec{y}||}{||\vec{y}||}}$（可以使用诱导范数直接推得）；</p></li></ul><p>几何上这么理解：在 $A$ 代表的线性变换下，对任意 $\vec{x}$ 作用<u>伸长最长的比例 与 伸长最短的比例 之比</u>；</p><p><img src="imgs2/matrix-cond.png" height="200px"></p><p>由这个几何关系，我们可以推出第二个推论：</p><ul><li><strong>重要推论 2</strong>：$||A^{-1}\vec{x}||\le||A^{-1}||||\vec{x}||$，因为 $||A^{-1}||$ 就是所有向量拉伸最长的比例了；</li></ul><blockquote><p>注：</p><ul><li>可以知道，一个矩阵的条件数越大，它所构成的线性方程组代表的线性系统对微小扰动越敏感的（解周围小范围变化自变量，总体值变化很大）；而一个矩阵的条件数越接近 1，则这个线性系统对微小扰动越不敏感；</li><li>由于很难求一个矩阵的逆，因此一般对条件数的讨论是讨论其上下界；</li></ul></blockquote><h1 id="Chapter-4-Column-Spaces-amp-QR"><a href="#Chapter-4-Column-Spaces-amp-QR" class="headerlink" title="Chapter 4. Column Spaces &amp; QR"></a>Chapter 4. Column Spaces &amp; QR</h1><p>考虑特殊矩阵的条件数 $\text{cond}\space A^TA\approx(\text{cond}\space A)^2$（在 $A$ 可逆的情况下）；</p><script type="math/tex; mode=display">\begin{aligned}\text{cond}\space A^TA&=||A^TA||\space||(A^TA)^{-1}||\\&\approx||A^T||\space||A||\space||A^{-1}||\space||(A^T)^{-1}||\\&=||A||^2||A^{-1}||^2\\&=(\text{cond}\space A)^2\end{aligned}</script><p>所以，我们对于一般的矩阵可以认为 $A^TA$ 越接近单位矩阵 $I_{n\times n}$，$A\vec{x}=\vec{b}$ 更容易解；</p><p>此外，$A^TA$ 的计算可以这么理解：</p><p><img src="imgs2/AtA.png" height="200px"></p><p>所以等价于我们希望 $A$ 是正交矩阵（各个列向量正交归一），而且<u>恰好正交矩阵代表的变换不改变向量的长度（所以正交矩阵的条件数是 1）</u>；</p><p>现在再回来看 $A^TA\vec{x}=A^T\vec{b}$，我们知道这个线性方程组的解就是 $\min\limits_{\vec{x}}||A\vec{x}-\vec{b}||$ 的解，就相当于将 $A$ 拆成列向量 $(\alpha_1,\alpha_2,\ldots,\alpha_n)$，将 $x_1\alpha_1+x_2\alpha_2+\cdots+x_n\alpha_n$ 逼近 $\vec{b}$（将 $\vec{b}$ 投影到 $A$ 列向量做基向量的线性空间上）；</p><blockquote><p>回忆线性代数的性质：</p><p>对任何实矩阵 $A\in\mathbf{R^{m\times n}}$ 和可逆方阵 $B\in\mathbf{R^{n\times n}}$，有 $\text{col}\space A=\text{col}\space AB$，即<u>对任意矩阵进行初等行变换不影响矩阵的列空间</u>；</p></blockquote><p>那么有没有办法对 $A$ 一直进行初等行变换，使得 $A$ 变成正交阵？这样 $A$ 的列空间不变（即原问题的解不变），但是 $A$ 成正交阵后非常好求解。</p><p>这种方法就是 QR 分解。我们将一般矩阵分解为一个正交阵（$A$ 的一组正交基）和上三角矩阵的乘积（上三角矩阵 $R$ 可以理解为一系列初等行变换）。</p><blockquote><p>显然，对于任意一个 $A$，若 $r(A_{m\times n})=n$（$m\ge n$），则 $A$ 都能进行 QR 分解。</p></blockquote><p>一旦我们将 $A^TA\vec{x}=A^T\vec{b}$ 进行 QR 分解：$A=QR$，那么 $\vec{x}=R^{-1}Q^T\vec{b}$，我们发现 $R$ 上三角矩阵容易求逆，就不需要计算 $A^TA$ 的逆了。</p><p>现在，QR 分解有 2 种方法。</p><ul><li><p>一种是通过 施密特正交化。这很好理解：</p><p><strong>现在回忆线性代数的 施密特正交化。这就是得到 $A=QR$ 的一种方法：</strong></p><ol><li>先对 $A$ 施密特正交化，再归一化就能得到基向量相同的正交矩阵 $Q$；</li><li>反解出 $R$：因为正交矩阵 $Q^TQ=I$，因此 $R=Q^TA$；</li></ol><blockquote><p>那么怎么 Gram-Schmidt 正交化？</p><p>对 $A$ 拆成的一组基 $(\alpha_1,\alpha_2,\ldots,\alpha_n)$，可以这么取正交基：</p><ul><li>$v_1=\alpha_1$，第一个向量随便取；</li><li>$v_2=\alpha_2-\dfrac{\alpha_2\cdot v_1}{v_1\cdot v_1}v_1$，第二个向量取 $\alpha_2$ 的时候，需要剔除第一个取得的基向量相关方向的分量：$\dfrac{\alpha_2\cdot v_1}{v_1\cdot v_1}$ 就是 $\alpha_2$ 在 $v_1$ 上的<u>投影长度</u>！</li><li>$v_3=\alpha_3-\dfrac{\alpha_3\cdot v_2}{v_2\cdot v_2}v_2-\dfrac{\alpha_3\cdot v_1}{v_1\cdot v_1}v_1$，第三个向量就减去 $\alpha_3$ 在 $v_1,v_2$ 上的投影分量就行。</li><li>……（依此类推）</li></ul><p>最后别忘了归一化。</p><p>不难发现，这种操作实际上在不断地对 $A$ 右乘上三角矩阵 $R_i$（进行初等列变换），使得：$AR_1R_2\cdots R_n=Q$；</p><p>相对地，下面的 Householder 变换方法，就是不断地进行正交变换（特别地，镜像变换），调整某一列的其他元素为 0，即不断地对 $A$ 左乘 Householder 矩阵（一种正交阵）$H_i$，使得：$H_nH_{n-1}\cdots H_1=R$；</p></blockquote></li><li><p>另一种是通过 Householder 变换（这是一个著名的变换，它代表了镜像变换，显然是一种正交变换），它所对应的矩阵就是 Householder 矩阵。</p><p>如图：</p><p><img src="imgs2/householder.png" width="300px"></p><p>假设已知一个向量 $\eta$，想要关于某个法线方向 $l$ 对称。为了方便，我们记与 $l$ 正交的一个从 $\eta$ 一边指向另一边的<u>单位向量</u>为 $\omega$，则由几何关系可知对称后的向量 $\xi$ 满足：$\xi-\eta=2\omega(\omega^T\xi)$，其中 $\omega^T\xi$ 就是 $\omega$ 和 $\xi$ 的点积（投影长度）；</p><p>因此 $\eta=(I-2\omega\omega^T)\xi$，我们发现，这镜面变换的矩阵就是 $H=I-2\omega\omega^T$，左乘它会将列向量变换到 $\omega$ 对应法线的 $\omega$ 指向的另一侧。</p><p>紧接着，我们发现这个矩阵 $H$ 有这个性质：</p><p>若 $H$ 为 Householder 矩阵，则 $\left[\begin{matrix}I_r&amp;0\\0&amp;H\end{matrix}\right]$ 也是 Householder 矩阵；</p><p>于是我们可以这么进行迭代：</p><ul><li><p>写 $A$ 的基向量 $(\alpha_1,\alpha_2,\ldots,\alpha_n)$，做第一次 householder 变换，使得 $\omega_1=\dfrac{\alpha_1-||\alpha_1||_2\cdot e_1}{||\alpha_1-||\alpha_1||_2\cdot e_1||_2}$，得到第一个 householder 矩阵 $H_1=I-2\omega_1\omega_1^T$，这样 $H_1A$ 的第一列除了第一个元素全部归 0：</p><blockquote><p>$\omega_1$ 可以理解为 $\alpha_1$ 减去在 $e_1$ 的分量（要镜像的方向已经得到了），再归一化，得到单位的镜像向量；</p><p><strong>$H_1\alpha_1$ 的变换就将 $\alpha_1$ 变换到与 $e_1$ 同一个方向上了。</strong></p></blockquote><p><img src="imgs2/householder-step1.png" width="500px"></p></li><li><p>记 $H_1A$ （注意是变换后的矩阵）关于 $a_{11}$ 的余子式为 $B_1$，则写 $B$ 的基向量 $(\beta_1,\beta_2,\ldots,\beta_{n-1})$，那么同理 $\omega_2=\dfrac{\beta_2-||\beta_2||_2\cdot e_1}{||\beta_2-||\beta_2||_2\cdot e_1||_2}$，得到第二个 householder 矩阵 $H_2=I-2\omega_2\omega_2^T$，这样 $H_2H_1A$ 的第一列和 $H_1A$ 一样、第二列除了前两个元素，后面的元素全部归 0:</p><p><img src="imgs2/householder-step2.png" width="400px"></p><blockquote><p>注意，$e_1$ 总是第一个元素为 1、其他元素为 0 的单位向量；</p></blockquote></li><li><p>重复上面的操作，最后 $H_{n-1}H_{n-2}\cdots H_1A=R$，$R$ 是一个上三角矩阵：</p></li><li><p>这样，我们得到了 $A$ 分解出的 $R$，最后反代 $Q=H_1H_2\cdots H_{n-1}$（注意正交阵的性质）；</p></li></ul></li></ul><h1 id="Chapter-5-Eigenvalue-amp-Eigenvector"><a href="#Chapter-5-Eigenvalue-amp-Eigenvector" class="headerlink" title="Chapter 5. Eigenvalue &amp; Eigenvector"></a>Chapter 5. Eigenvalue &amp; Eigenvector</h1><h2 id="5-1-Overview"><a href="#5-1-Overview" class="headerlink" title="5.1 Overview"></a>5.1 Overview</h2><p>在采集多维数据时，需要考虑各个维度间的相关性，以降低数据的维度。</p><p>举个例子，假设有组（该组有 $m$ 个数据） $n$ 维数据 $(v_1,v_2,\ldots,v_m),\space v_i\in\mathbf{R^n}$。</p><p>如果我们只知道某些维度上的确切数据，于是我们就像想将任意一个 $n$ 维数据用某几个维度去拟合整体数据。这样可以非常方便地讨论数据的整体特性。</p><p>这样，数据矩阵的特征值就能派上用场了。</p><p>除了这个问题，还有其他一些问题可以借助特征值进行解决，例如：</p><ul><li>Optimize $||A\vec{x}||_2$，固定 $||\vec{x}||_2=1$；</li><li>ODE/PDE（常微分方程、偏微分方程）的近似解：$\vec{y}^\prime=B\vec{y}$；</li><li>Rayleigh quotient（瑞利商）：$\dfrac{\vec{x}^TA\vec{x}}{||\vec{x}||_2^2}$；</li></ul><p>回忆下线性代数中对于特征向量/特征值的重要结论：</p><ul><li>每个 $n$ 阶方阵至少有一个特征向量（复向量），最多有 $n$ 个不同的特征值；</li><li>对应不同特征值的特征向量是线性无关的；</li></ul><h2 id="5-2-Review-Diagonalizable-Matrix"><a href="#5-2-Review-Diagonalizable-Matrix" class="headerlink" title="5.2 Review: Diagonalizable Matrix"></a>5.2 Review: Diagonalizable Matrix</h2><p>这里再复习一下矩阵对角化的知识：</p><p><strong>矩阵对角化的意义？</strong></p><ul><li><p>可快速计算 $A^k$；</p></li><li><p>可计算 Markov 过程中的平稳分布 $\pi$；</p></li><li>可计算差分方程 $u_{k+1}=Au_k$ 描述的离散动力系统的长期行为；</li><li>……</li></ul><p><strong>矩阵对角化的方法？</strong></p><ol><li><p>求出矩阵 $A$ 的所有特征值 $\lambda_i$；</p></li><li><p>通过 $A$ 的每个特征值，以及特征值的代数重数，来判断 $A$ 是否可对角化。具体来说：</p><p>代数重数就是在判断特征值重复的次数、几何重数就是在描述特征向量重复的维数（就是零空间的维数）。注意<u>每个特征值的几何重数一定小于等于代数重数</u>（因为对应不同特征值的特征向量是线性无关的，而特征值可以重复）。</p><p>这里 $A$ 要可对角化，就必须满足下面两种情况之一：</p><ul><li><strong>$A$ 的所有 $n$ 个特征值互不相等（代数重数 $n$）</strong>。而由于对于不同特征值的特征向量必然线性无关，所以几何重数一定也为 $n$；</li><li><strong>$A$ 所有重根下，$k$ 重特征值是否有 $k$ 个线性无关的特征向量</strong>。这里就是在要求这个代数重数为 $k$ 的特征值的几何重数是不是也是 $k$；</li></ul><p>所以上面的两个要求总体在说：$A$ 的<u><strong>几何重数和代数重数是否相等</strong></u>？</p><p>如果相等，表示 $A$ 所代表的线性变换没有改变被变换方的维度，因此 $A$ 可以分解为 $n$ 个线性无关的正交基向量。也就是可以相似对角化。如果不满足，则无法相似对角化。</p></li><li><p>最后将特征向量与特征值对应起来：$\Lambda=\text{diag}(\lambda_1,\lambda_2,\ldots,\lambda_n)$，$P=(\alpha_1,\alpha_2,\ldots,\alpha_n)$，则 $P^{-1}AP=\Lambda$；</p></li></ol><h2 id="5-3-Definition-of-Spectrum-Radius-in-Matrix"><a href="#5-3-Definition-of-Spectrum-Radius-in-Matrix" class="headerlink" title="5.3 Definition of Spectrum Radius in Matrix"></a>5.3 Definition of Spectrum Radius in Matrix</h2><p>引入一个新的定义：矩阵的谱半径（或称 “矩阵的谱”）。</p><p><strong>谱半径的意义？</strong></p><ul><li>估计一个矩阵的特征值；</li><li>计算一个不可逆矩阵的广义逆矩阵；</li><li>……</li></ul><p><strong>谱半径的计算？</strong></p><p>$\rho(A)=\max\limits_i|\lambda_i|$（矩阵 $A$ 的谱半径等于其<u>所有特征值的模的最大值</u>。<strong>注意特征值包含复数！</strong>）；</p><p><strong>谱半径和范数的关系？</strong></p><p>谱半径和矩阵范数一样，都是矩阵的函数：$f:R^{m\times n}\rightarrow R$；</p><p>但是它们二者本质上真的不一样，一定要和 2-诱导范数（也就是谱范数）区分开。</p><p>二者间有一些重要结论：</p><ul><li><p>任意复数域上的矩阵 $A$，其谱半径 $\rho(A)$ 不大于 $A$ 的任何一种诱导范数，即：$\rho(A)\le||A||$；</p><blockquote><p>含义：<u>矩阵的谱半径是其任意一种范数的下界</u>；</p><p>作用：使用方便求解的范数对谱半径进行估算；</p></blockquote></li><li><p><code>Gelfand</code> 定理：$\rho(A)=\lim\limits_{k\rightarrow\infty}||A^k||^{1/k}$；</p><ul><li>矩阵序列 $I,A,A^2,\ldots,A^k,\ldots$ 收敛于 0 的充要条件：$\rho(A)\lt1$；</li><li>级数 $I+A+A^2+\cdots$ 收敛于 $(I-A)^{-1}$ 的充要条件：$\rho(A)\lt1$；</li></ul></li></ul><h2 id="5-4-Extend-to-mathbf-C-m-times-n"><a href="#5-4-Extend-to-mathbf-C-m-times-n" class="headerlink" title="5.4 Extend to $\mathbf{C^{m\times n}}$"></a>5.4 Extend to $\mathbf{C^{m\times n}}$</h2><p>现在将线性空间扩展到复数域，我们多出如下定义：</p><ul><li><p>共轭转置 $A^H$；</p></li><li><p>厄密矩阵（Hermitian Matrix）：$A^H=A$；</p><blockquote><p>注意和实对称矩阵不一样。</p><p>由量子力学的厄密算符可以得到如下所有结论（量子力学考题）：</p><ul><li>厄密矩阵所有特征值为实数；</li><li>厄密矩阵属于不同特征值的特征向量相互正交；</li><li>……</li></ul></blockquote><p>厄密矩阵因为是复数域上，和实数域上的实对称矩阵很相似（不如说实对称矩阵是厄密矩阵的特殊情况），所以厄密矩阵和实对称矩阵一样，二者一定可以相似对角化（几何重数一定等于代数重数，或者说一定有 $n$ 个线性无关的基向量）；</p><p>它们相似对角化很简单：$A=X^{-1}\Lambda X=X^T\Lambda X$（显然 $X$ 是正交矩阵）；</p></li></ul><p>再引入一些 “奇怪” 的运算：</p><p>对于一个 半正定/正定 的对称矩阵 $A\in S_{+}$，定义其平方根：$A^{1/2}$，因为一定能找到 $P$ 使得 $P^2=A$；</p><h2 id="5-5-Application-Use-Matrices-to-Solve-Problems"><a href="#5-5-Application-Use-Matrices-to-Solve-Problems" class="headerlink" title="5.5 Application: Use Matrices to Solve Problems"></a>5.5 Application: Use Matrices to Solve Problems</h2><ul><li><p>例如 $\vec{y}^\prime=\lambda\vec{y}$，可以看成一个求导变换 $D\vec{y}=\lambda\vec{y}$，求 $D$ 的特征向量就是 $\vec{y}$ 的解；</p></li><li><p>照片曝光的例子：数据集中有 $n$ 个数据，$\omega_{ij}\ge0$ 表示第 $i$ 和 $j$ 数据集之间的某个指标的相似性，$\omega_{ij}=\omega_{ji}$；我们想将这些数据集以这个指标 $x_i$ 衡量起来，要求相似性越高的数据，$x_i$ 的值也应该相近；</p><p>为了完成这个任务，可以定义一个目标函数 $\sum\limits_{ij}\omega_{ij}(x_i-x_j)^2$，对它最小化优化就行。</p><p>但是需要一些限制条件，防止 $x_i\equiv const$ 无意义的情况，例如 2-范数为 1 $||\vec{x}||_2^2=1$（归一化）、$\vec{1}\cdot\vec{x}=0$（指标 $x_i$ 均值为 0，方便统计）；</p><p>所以目标函数可以简化为：$2x^T(A-W)x$，其中 $W=(\omega_{ij})_{n\times n}$；找到 $A-W$ 的第二小特征值（最小特征值是 0，已经被限制条件排除了）对应的特征向量就是解。</p></li></ul><ul><li>计算 $A^k$：</li></ul><p>对一个实对称阵 $A$，假设其特征值 $\lambda_1,\ldots,\lambda_n$ 从大到小排列（$\lambda_{i+1}\ge\lambda_{i}$），那么它由实对称阵特征向量的完备性，我们可以用 $A$ 特征向量 $(x_1,\ldots,x_n)$ 来表示任意 $n$ 维向量：$A\vec{v}=c_1A\vec{x_1}+\cdots+c_nA\vec{x_n}=c_1\lambda_1\vec{x_1}+\cdots+c_n\lambda_n\vec{x_n}$（和量子力学将力学量使用它对应的算符的本征函数展开是一样的）；</p><p>因此我们发现，$A^k$ 对 $\vec{v}$ 作用的效果就取决于最大的特征值及其特征向量了：</p><p><img src="imgs2/spec.png" width="500px"></p><p>$A^k\vec{v}\approx c_1\lambda_1^k\vec{x_1},\space\text{assume that}\space c_1\ne0,\lambda_1\gt\lambda_2$（$k$ 要求足够大）；</p><blockquote><p>问题是，如果 $|\lambda_1|\gt1$ 时，$A^k\vec{v}\rightarrow\infty$，所以每次迭代都做一次归一化即可：</p><p>$\vec{\omega_k}=A\vec{v_{k-1}},\space\text{ where }\vec{\omega_{k}}=\dfrac{\vec{v_{k-1}}}{||\vec{v_{k-1}}||}$；</p><p>所以通过这个 power iteration 方法我们就能估计出 $A$ 的最大特征值；</p></blockquote><p>又注意到 $A$ 特征值的倒数，<strong>正好是</strong> $A^{-1}$ 对应的特征值：$A\vec{v}=\lambda\vec{v}\Rightarrow A^{-1}\vec{v}=\dfrac{1}{\lambda}\vec{v}$；</p><p>那么对 $A^{-1}$ 进行 power iteration，就能得到 $A$ 的最小特征值。</p><blockquote><p>$A^{-1}$ 的 power iteration 可以借助 $LU$ 分解加速。</p></blockquote><p>另外，由于正确结果收敛较慢，因此我们可以使用 “shifted inverse iteration”：</p><p>$A\vec{v}=\lambda\vec{v}\Rightarrow(A-\sigma I)\vec{v}=(\lambda-\sigma)\vec{v}$，可以得到如下的迭代过程（猜测 $\sigma_k\approx\lambda_k$）：</p><script type="math/tex; mode=display">\vec{\omega_k}=(A-\sigma_k I)^{-1}\vec{v_{k-1}},\space\vec{v_k}=\dfrac{\vec{\omega_k}}{||\vec{\omega_k}||},\space \sigma_{k+1}=\dfrac{\vec{v_{k}}^TA\vec{v_k}}{||\vec{v_k}||_2^2}</script><h2 id="5-6-Similarity-Transformations"><a href="#5-6-Similarity-Transformations" class="headerlink" title="5.6 Similarity Transformations"></a>5.6 Similarity Transformations</h2><ul><li><p>借助 QR 分解进行相似变换：$A=QR$，则 $Q^{-1}AQ=RQ$，所以可以迭代：$A_{k+1}=R_kQ_k,\space A_k=Q_kR_k$；</p><p>好的结论：$A_\infty=Q_\infty R_\infty=R_\infty Q_\infty$；</p></li></ul><h2 id="5-7-SVD-Singular-Value-Decomposition"><a href="#5-7-SVD-Singular-Value-Decomposition" class="headerlink" title="5.7 SVD (Singular Value Decomposition)"></a>5.7 SVD (Singular Value Decomposition)</h2><p>回忆一个矩阵的诱导范数：</p><script type="math/tex; mode=display">||A||=\max_{\vec{x}\ne0}\dfrac{||A\vec{x}||}{||\vec{x}||}=\max\limits_{||\vec{x}||=1}||A\vec{x}||</script><p>注意到 $||\vec{v}||=1$ 时，$||A||^2=||A\vec{v}||^2=\vec{v}A^TA\vec{v}$，因此只需要</p><p>特征值只有方阵才能讨论。有没有一种研究矩阵更普遍特征性质的分解呢？它就是奇异值分解。</p><p>可以证明，任何矩阵可以分解为：$A=U\Sigma V^{-1}$，其中 $U,V$ 为正交矩阵，$\Sigma$ 为对角矩阵（可以不是方阵）；</p><p>在物理上 $U,V$ 表示旋转变换（rotation），$\Sigma$ 表示伸缩变换（scale）；</p><p>那么 $U$、$V$ 代表什么？</p><p>我们发现：$A^TA=V(\Sigma^T\Sigma)V^T$，显然 $\Sigma^T\Sigma$ 是个对角方阵。而 $A^TA$ 有很好的性质：它是半正定、对称矩阵。</p><p>因此我们惊喜地发现，这就相当于对 $A^TA$ 完成了相似对角化。$\Sigma^T\Sigma$ 对角元存放的是 $A^TA$ 的特征值，$V$ 的列存放的是 $A^TA$ 对应的特征向量；</p><p>同理，$AA^T=U(\Sigma^T\Sigma)U^T$，所以，我们得出以下结论：</p><ul><li>$U$ 和 $V$ 分别是 $AA^T$ 和 $A^TA$ 的归一化特征向量组成的正定矩阵；</li><li>$U$ 和 $V$ 特征值<u>按序相同</u>（从大到小排列），对于实矩阵而言都大于等于 0；</li></ul><p>SVD 分解还可以写成一系列 $U,V$ 向量的外积线性组合：$A=\sum\sigma_i\vec{u_i}\vec{v_i}^T$；</p><p>SVD 可以有哪些用处？比如定义一个一般矩阵的 “伪逆”（pseudo inversion）：</p><script type="math/tex; mode=display">A^{+}=V\Sigma^{+}U^T</script><p>注意，对不一定为方阵的对角阵的伪逆：$\Sigma^{+}$ 就是将 $\Sigma$ 对角元的元素求倒数，放在对角位置，并且转置矩阵的长宽。</p><p>伪逆有一些很好的性质：</p><ul><li>当 $A$ 为可逆方阵时，$A^+=A^{-1}$；</li><li>当 $A$ 的行秩大于列秩时（overdetermined），$A^+\vec{b}$ 给出了最小二乘结果；</li><li>当 $A$ 的列秩大于行秩时（underdetermined），$A^+\vec{b}$ 给出了 $A\vec{x}\approx\vec{b}$ 的最小二乘结果；</li></ul><h3 id="5-7-1-Application-Orthogonal-Procrustes-Theorem"><a href="#5-7-1-Application-Orthogonal-Procrustes-Theorem" class="headerlink" title="5.7.1 Application: Orthogonal Procrustes Theorem"></a>5.7.1 Application: Orthogonal Procrustes Theorem</h3><p>考虑一个问题：将一组向量 $A$ 通过正交变换的方式映射到新的一组向量 $QA$，让这组新的向量与给定的一组向量 $B$ 的差异尽可能的小（使用 Frobenius 范数衡量）。这在图像处理领域比较常用。</p><p>用数学方法表达就是，求正交阵：$\hat{Q}=\arg\min\{||QA-B||_{F}\}$（易知，$A,B$ 规模相同）；</p><p>由于 Frobenius 范数可以表达为 $||C||_F=\sqrt{\mathrm{tr}(C^TC)}$，故上式可计算：</p><script type="math/tex; mode=display">\begin{aligned}\hat{Q}&=\arg\min\{\mathrm{tr}((QA-B)^T(QA-B))\}\\&=\arg\min\{\mathrm{tr}(((QA)^T-B^T)(QA-B))\}\\&=\arg\min\{\mathrm{tr}((A^TQ^T-B^T)(QA-B))\}\\&=\arg\min\{\mathrm{tr}(A^TQ^TQA-BA^TQ^T-B^TQA+B^TB)\}\\&=\arg\min\{\mathrm{tr}(A^TA+B^TB-A^TQ^TB-(A^TQ^TB)^T)\}\\&=\arg\min\{\mathrm{tr}(A^TA)+\mathrm{tr}(B^TB)-2\mathrm{tr}(A^TQ^TB)\}\\\end{aligned}</script><p>注意到前两项在确定问题时就已知，所以最小化问题直接转换为最大化问题：</p><script type="math/tex; mode=display">\begin{aligned}\hat{Q}&=\arg\max\{\mathrm{tr}(A^TQ^TB)\}\\&=\arg\max\{\mathrm{tr}(Q^TBA^T)\}\\\end{aligned}</script><p>（注意 $\mathrm{tr}(PQ)=\mathrm{tr}(QP)$）</p><p>下面利用 SVD 分解做一个巧妙变换（假设 $BA^T=U\Sigma V^T$）：</p><script type="math/tex; mode=display">\begin{aligned}\hat{Q}&=\arg\max\{\mathrm{tr}(Q^TBA^T)\}\\&=\arg\max\{\mathrm{tr}(Q^TU\Sigma V^T)\}\\&=\arg\max\{\mathrm{tr}(V^TQ^TU\Sigma)\}\\\end{aligned}</script><p>这样 $V,Q,U$ 都是正交阵，所以 $V^TQ^TU$ 也是正交阵。</p><p>可以简单地证明，$\mathrm{tr}(QA)$ 最大（$Q$ 正交阵）时，$Q=I$；</p><p>此时 $\hat{Q}^T=VU^T$，$\hat{Q}=UV^T$；</p><p>所以这里我们利用 SVD 解出了正交普鲁克定理：</p><p>当 $Q=UV^T$（其中 $BA^T=U\Sigma V^T$）时，$||QA-B||_F$ 有最小值。</p><h3 id="5-7-2-Application-Principal-Component-Analysis-PCA"><a href="#5-7-2-Application-Principal-Component-Analysis-PCA" class="headerlink" title="5.7.2 Application: Principal Component Analysis (PCA)"></a>5.7.2 Application: Principal Component Analysis (PCA)</h3><p>再考虑一个问题，对于相当大的一个数据集，它包含很多维度，我们基于以下目的需要降维：</p><ul><li>使得数据集更易使用；</li><li>降低算法的计算开销；</li><li>去除噪声；</li><li>使得结果容易理解；</li></ul><p>有一种降维方法就是主成分分析方法（PCA），其主要思想是将 $n$ 维特征映射到 $k$ 维上，这k维是全新的正交特征也被称为主成分，是在原有 $n$ 维特征的基础上重新构造出来的 $k$ 维特征；</p><p>可以证明：</p><p>最小化 $||X-CC^TX||_F$（其中 $C\in\mathbf{R^{n\times k}}$，$C^TC=I_{k\times k}$，$C$ 是 $U$ 的前 $k$ 列向量，$X=U\Sigma V^T$）取得的 $C$ 就是 $X$ 的主成分。</p><h1 id="Chapter-6-Non-linear-System"><a href="#Chapter-6-Non-linear-System" class="headerlink" title="Chapter 6. Non-linear System"></a>Chapter 6. Non-linear System</h1><h2 id="6-1-Root-Finding"><a href="#6-1-Root-Finding" class="headerlink" title="6.1 Root Finding"></a>6.1 Root Finding</h2><p>作出一些假设：</p><ul><li><p>连续性；</p><blockquote><p>连续函数满足的定理：中值定理；</p></blockquote></li><li><p>Lipschitz 特性：绝对值增长速率不快于一阶线性函数；</p></li><li><p>$k$ 阶导存在且连续；</p></li></ul><p><strong><u>方法一：二分法（bisection）</u></strong>，利用中值定理锁定根的区间（高中内容），直到根的区间小于一定范围就停止迭代。</p><ul><li><p>优点：无条件收敛（unconditionally converge）；</p><blockquote><p>收敛速度？指数速度减小。</p><p>$|x-x^*|\lt E_k$，其中 $E_k$ 为第 $k$ 轮迭代时的区间宽度（$E_k\le\dfrac{1}{2}E_{k-1},\space E_k=|r_k-l_k|$）；</p></blockquote></li><li><p>缺点：对函数性质要求严格。</p></li></ul><p><strong><u>方法二：不动点法（fixed point）</u></strong>，通过迭代求解 $g(x^<em>)=x^</em>$ 来得到 $f(x)=g(x)-x$ 的零点。</p><p>怎么迭代？方法比较多，但是常用的是最简单的策略：</p><p>simple strategy：将 $g(x_{k-1})$ 作为下一轮迭代的 $x_k$ 的值，直至 $|g(x_k)-x_k|$ 小于一定范围；</p><ul><li><p>优点：计算简单；</p></li><li><p>缺点：$g$ 必须满足 Lipschitz 特性，或者在根 $x^*$ 及迭代范围附近满足 Lipschitz 局部特性，否则迭代发散。</p><blockquote><p>对于满足 Lipschitz 特性的情况，$E_k\le cE_{k-1}$（linear）；</p><p>对于其他一般情况：$E_k=|x_k-x^<em>|=|g(x_{k-1})-g(x^</em>)|\le\dfrac{1}{2}(|g^{\prime\prime}(x^*)|+\varepsilon)E_{k-1}^2$（quadratic）； </p></blockquote></li></ul><p><strong><u>方法三：牛顿法（Newton’s method）</u></strong>，这个方法作出了一个假设，认为函数在零点附近近似线性，可以给出一个猜测值 $x_0$，求该点处切线 $l_0$，取得 $l_0$ 与 x 轴交点为 “更接近零点的点” $x_1$，重复迭代直至稳定。</p><script type="math/tex; mode=display">x_{k+1}=x_k-\dfrac{f(x_k)}{f^\prime(x_k)}</script><p>可以看作求 $g(x)=x-\dfrac{f(x_k)}{f^\prime(x_k)}$ 的不动点。</p><ul><li>优点：在简单情况下收敛很快；</li><li>缺点：<ol><li>$g$ 需要满足局部 Lipschitz 特性，否则不收敛（收敛速度和不动点法同理）；</li><li>$f^\prime(x^*)\ne0$，否则永远无法得到正确解；</li><li>某些函数难以求导数。</li></ol></li></ul><p><strong><u>方法四：割线法（secant method）</u></strong>，利用两相近点间的割线近似为切线的思想（$f^\prime(x)\approx\dfrac{f(x_1)-f(x_2)}{x_1-x_2},\space |x_1-x_2|\rightarrow0$），可以借助两次猜测的点的连线（割线）视作切线：$f^\prime(x_k)\approx\dfrac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$，结合牛顿法解决：</p><script type="math/tex; mode=display">x_{k+1}=x_k-\dfrac{f(x_k)}{f^\prime(x_k)}\approx x_k-\dfrac{f(x_k)(x_k-x_{k-1})}{f(x_k)-f(x_{k-1})}</script><ul><li>优点：计算稍微简单一点；</li><li>缺点：和牛顿法一样存在收敛问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-1-Basic-Concepts&quot;&gt;&lt;a href=&quot;#Chapter-1-Basic-Concepts&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1. Basic Concepts&quot;&gt;&lt;/a&gt;Chapter 1. Ba</summary>
      
    
    
    
    <category term="review" scheme="https://sjtuxhw.top/categories/review/"/>
    
    
    <category term="Math" scheme="https://sjtuxhw.top/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Rabbit MQ</title>
    <link href="https://sjtuxhw.top/2024/06/01/Introduction-to-Rabbit-MQ/"/>
    <id>https://sjtuxhw.top/2024/06/01/Introduction-to-Rabbit-MQ/</id>
    <published>2024-06-01T08:31:33.000Z</published>
    <updated>2024-07-28T08:23:12.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-0-背景"><a href="#Chapter-0-背景" class="headerlink" title="Chapter 0. 背景"></a>Chapter 0. 背景</h1><h2 id="0-1-同步消息和异步消息"><a href="#0-1-同步消息和异步消息" class="headerlink" title="0.1 同步消息和异步消息"></a>0.1 同步消息和异步消息</h2><p>微服务架构下存在很多服务间相互调用的情况。</p><p>我们知道可以通过 <code>OpenFeign</code> 的方式来获取远程服务的响应，但是 <code>OpenFeign</code> 的远程调用是同步的，其优点是同步调用时效强，等待结果返回。但同时会导致：</p><ul><li>代码可扩展性差。</li><li>性能堪忧。相较于相同项目实现的单体架构，同步的微服务调用方式会多出网络等待时间。</li></ul><p>于是我们需要异步调用的方式，这里使用到了<strong>发布-订阅者模式</strong>。</p><p>异步调用的优势是，</p><ul><li>模块间进一步解耦（发布者和订阅者间无需知道相互之间的信息）；</li><li>可拓展性强（scalable），添加实例无需更改代码；</li><li>异步性能有明显提升；</li><li>故障隔离（<strong><u>最终一致性保证</u></strong>）；</li><li>缓存消息，实现流量削峰填谷；</li></ul><p>但是缺点也很明显：</p><ul><li>异步实现无法立即得到结果，时效性差，可能导致数据不一致性；</li><li>不作额外措施，则不能保证最终一致性（下游业务是否成功）。所以业务安全依赖于 broker 的可靠性；</li></ul><h2 id="0-2-Message-Queue-选型"><a href="#0-2-Message-Queue-选型" class="headerlink" title="0.2 Message Queue 选型"></a>0.2 Message Queue 选型</h2><div class="table-container"><table><thead><tr><th>Opt</th><th>RabbitMQ</th><th>ActiveMQ</th><th>RocketMQ</th><th>Kafuka</th></tr></thead><tbody><tr><td>Company</td><td>Rabbit（专一，社区极活跃）</td><td>Apache（大厂支持）</td><td>Alibaba（开源冲业绩）</td><td>Apache</td></tr><tr><td>Language</td><td>Erlang（面向并发的语言）</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>Protocol Support</td><td>AMQP,XMPP,SMTP,STOMP</td><td>OpenWire,STOMP,REST,XMPP,AMQP</td><td>私有协议，只能被 Java 调用（微服务语言限制）</td><td>私有协议</td></tr><tr><td>Availability</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>Monolith Throughput（ops）</td><td>一般（数十万上下）</td><td>差</td><td>高（数十万）</td><td>极高（近数百万）</td></tr><tr><td>Latency</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>Reliability</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table></div><p>可以看出：</p><ul><li><p><code>Kafuka</code> 牺牲了部分可靠性（只确保最终一致性）、消息延迟，换取了极高的消息吞吐量。在对消息准确性要求不高（如日志传输）的情况下推荐；</p></li><li><p><code>RocketMQ</code> 虽然功能丰富，但是 <code>Alibaba</code> 的开源项目大多属于冲业绩，文档和社区支持不佳。</p><p>此外 <code>RocketMQ</code> 依赖于很多 <code>Alibaba</code> 技术栈，如果项目中不打算或者没有 <code>Alibaba</code> 的依赖，那么引入困难；</p><p>另外 <code>RocketMQ</code> 不支持主流协议，只支持他们自己的一套接口，微服务语言局限于 Java；</p></li><li><p><code>ActiveMQ</code> 是早期的项目，指标不如后辈；</p></li></ul><p>因此我们选择 <code>RabbitMQ</code>。</p><h1 id="Chapter-1-Introduction-to-RabbitMQ"><a href="#Chapter-1-Introduction-to-RabbitMQ" class="headerlink" title="Chapter 1. Introduction to RabbitMQ"></a>Chapter 1. Introduction to <code>RabbitMQ</code></h1><h2 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 架构</h2><p><img src="imgs/arch2.png"></p><ul><li><p><code>queue</code>：暂时存储消息的消息队列；队列有两类：</p><ul><li><p>durable queue：持久化队列，信息会被定期持久化到磁盘。这种队列可以提升可靠性，但是会降低性能；</p></li><li><p>non-durable queue：非持久化队列，信息总是保存在内存中。这种队列的速度会快于 durable queue，但是可靠性无法保证（例如不保证掉电不丢失数据）；</p></li></ul></li><li><p><code>virtual host</code>：虚拟主机，起到不同项目数据隔离作用；</p></li><li><p><code>exchange</code>：路由消息的交换机。其作用是接受发布者发送的消息，并将接收到的消息<strong><u>按照交换机的配置</u></strong>路由到所有与其绑定的队列中。本身不具备消息暂存能力；</p><p>交换机的配置（种类，或者说<strong>路由策略</strong>）大致有几种：</p><ul><li><p><code>Fanout</code>（广播）：<code>Fanout</code> 交换机。会将自身接受到的消息批量路由到<strong>所有与之关联的</strong>消息队列中；</p></li><li><p><code>Direct</code>（定向）：<code>Direct</code> 交换机。这种交换机 与 消息队列的关联时需要额外指定一个 <code>bindingKey</code>，并且发布者在向该种交换机发送消息时，必须指定 <code>routingKey</code>。</p><p>于是这种交换机只会将接受到的消息发送给 <code>bindingKey</code> 与这条消息的 <code>routingKey</code> 相同的消息队列中；</p><blockquote><p><code>bindingKey</code> 不要求对于交换机唯一。所以理论上 <code>Direct</code> 交换机的功能覆盖了 <code>Fanout</code> 交换机。</p></blockquote></li><li><p><code>Topic</code>（话题，类似 <code>Kafuka</code> 的按 Topic 订阅）：与 <code>Direct</code> 交换机类似，也以 <code>bindingKey</code> 和 <code>routingKey</code> 为路由依据，但：</p><ul><li><code>bindingKey</code> 这里是 topic，可以使用通配符：<code>#</code> 代表 0 到多个 topic，<code>*</code> 代表 1 个 topic；</li><li><code>routingKey</code> 可以是 topic 的组合，使用 <code>.</code>（period）隔开；</li></ul></li><li><p><code>Headers</code>（请求头）：<code>Headers</code> 交换机，</p></li></ul></li></ul><p>注意，交换机 和 消息队列间的关联需要显式声明 / 配置。</p><h2 id="1-2-Spring-AMQP"><a href="#1-2-Spring-AMQP" class="headerlink" title="1.2 Spring AMQP"></a>1.2 Spring <code>AMQP</code></h2><p><code>RabbitMQ</code> 支持多种协议，其中就包括 <code>AMQP</code>（Advanced Message Queuing Protocol），其他各种语言都有各自的 <code>AMQP</code> 的实现库。</p><p>为了方便起见，在 Spring 项目中常常使用 Spring 框架中实现好的 <code>AMQP</code> 协议接口来完成任务。</p><blockquote><p><code>spring-boot-starter-amqp</code> 依赖内部提供了针对 <code>AMQP</code> 协议的实现，只需引入该依赖即可操作 <code>RabbitMQ</code>；</p><p>引入后需要进行一些配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">virtual-host:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure></blockquote><ul><li>最简单使用：<code>RabbitTemplate.convertAndSend</code> &amp; <code>@RabbitListener</code>；</li></ul><h3 id="1-2-1-Working-Queues-模型"><a href="#1-2-1-Working-Queues-模型" class="headerlink" title="1.2.1 Working Queues 模型"></a>1.2.1 Working Queues 模型</h3><p>Working Queues 模型：多个消费者绑定到一个队列，共同消费队列中的消息；</p><ul><li>结论 1：队列中的消息<strong><u>最多只能被消费一次</u></strong>；所以多个 consumer 监听的情况下，一个消息被某个 consumer 消费后，不会存在于消费队列中被其他 consumer 消费（不存在消息重复）；</li><li>结论 2：队列传递给所有监听它的消费者的<strong><u>默认行为</u></strong>是绝对平均（<strong>轮询</strong>）的，没有考虑到各个机器消费消息的性能（可以用 <code>Thread.sleep</code> 测试）；</li></ul><p>为了改善这个模型下出现的问题，我们可以对这个默认的轮询机制调优：<u>规定每个消费者一次只能获取一条消息，处理完成后才能获取下一条消息</u>；</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在消费者（使用 `@RabbitListener` 注解）所在的模块中配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-Fanout-Exchange"><a href="#1-2-2-Fanout-Exchange" class="headerlink" title="1.2.2 Fanout Exchange"></a>1.2.2 <code>Fanout</code> Exchange</h3><p>为什么需要广播交换机？考虑一个问题，假设一个发布者发布消息后，我们的业务逻辑要求同时有多个其他服务需要接收这个消息并且执行相应逻辑。举个例子，<code>consumer1</code> 和 <code>consumer2</code> 需要在 <code>publisher</code> 发送消息后各自接收一次消息（也就是都执行一次业务逻辑）。</p><p>如果没有广播交换，那么发布者发布的消息在全局范围内只能被一个消费者消费，这就没法实现多个服务都接受到发布者消息的需求了。</p><p>在这种需求下，我们只需要为每个微服务建立一个消息队列，并且对应监听；将这些队列与一个公共的 <code>fanout</code> 交换机关联，就能完成上面的需求。如下图所示：</p><p><img src="imgs/fanout.png"></p><blockquote><p>代码中，如果使用了 <code>fanout</code> 交换机，那么 <code>routingKey</code> 可以指定为空字符串 / <code>null</code>；</p></blockquote><h3 id="1-2-3-Direct-Exchange"><a href="#1-2-3-Direct-Exchange" class="headerlink" title="1.2.3 Direct Exchange"></a>1.2.3 <code>Direct</code> Exchange</h3><ul><li>路由交换机需要与消息队列以 <code>bindingKey</code> 绑定；一个交换机和一个消息队列可以绑定多个 <code>bindingKey</code>；</li><li><p><code>bindingKey</code> 和 <code>routingKey</code> 不存在通配符；</p></li><li><p>路由直接发送到 <code>bindingKey == routingKey</code> 的消息队列中；</p></li></ul><h3 id="1-2-4-Topic-Exchange"><a href="#1-2-4-Topic-Exchange" class="headerlink" title="1.2.4 Topic Exchange"></a>1.2.4 <code>Topic</code> Exchange</h3><ul><li>路由交换机需要与消息队列以 <code>bindingKey</code> 绑定；</li><li><code>bindingKey</code> 允许通配符，<code>#</code> 表示任意 0 至多个 topic，<code>*</code> 表示任意一个；</li><li>路由发送到所有匹配的消息队列中；</li></ul><h3 id="1-2-5-Spring-AMQP-声明交换机-amp-队列"><a href="#1-2-5-Spring-AMQP-声明交换机-amp-队列" class="headerlink" title="1.2.5 Spring AMQP 声明交换机 &amp; 队列"></a>1.2.5 Spring <code>AMQP</code> 声明交换机 &amp; 队列</h3><ul><li><code>Queue</code> 声明队列的类，也可以使用 <code>QueueBuilder</code> 工厂类创建；</li><li><code>Exchange</code> 声明交换机的类，也可以使用 <code>ExchangeBuilder</code> 工厂类创建；</li><li><code>Binding</code> 声明队列和交换机的绑定关系，<code>BindingBuilder</code>（常用）；</li></ul><h4 id="Method-1-Spring-Bean-Configuration-式声明"><a href="#Method-1-Spring-Bean-Configuration-式声明" class="headerlink" title="Method 1. Spring Bean Configuration 式声明"></a>Method 1. Spring Bean Configuration 式声明</h4><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通常在 consumer 段声明，因为 consumer 更需要关注交换机和队列的生成 */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* 构造函数为名称 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;test.fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/* 等价于： */</span></span><br><span class="line">        <span class="comment">/* return ExchangeBuilder.fanoutExchange(&quot;test.fanout&quot;).build(); */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;test.queue1&quot;</span>);</span><br><span class="line">        <span class="comment">/* 等价于（默认 durable queue）： */</span></span><br><span class="line">        <span class="comment">/* return QueueBuilder.durable(&quot;test.queue1&quot;).build(); */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;test.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 自动注入 queue 和 exchange，从上面的 bean 寻找，采用 autowired-by-name 策略 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue</span><span class="params">(Queue fQueue1, FanoutExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fQueue1).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue</span><span class="params">(Queue fQueue2, FanoutExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fQueue2).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-2-Listener-注解式声明"><a href="#Method-2-Listener-注解式声明" class="headerlink" title="Method 2. Listener 注解式声明"></a>Method 2. Listener 注解式声明</h4><p>显然这种方法非常麻烦，主要有以下的问题：</p><ul><li><p>每个方法大同小异，大部分是 boilerplate code；</p></li><li><p>定义步骤相当繁琐每定义一个队列、交换机或者绑定关系，就要新建一个方法；</p></li><li>很多队列或者交换机的 bean，只能通过 <code>autowired-by-name</code> 的方法注入，降低了代码可读性和可维护性；</li></ul><p>于是可以使用另一种定义方式，直接使用 <code>@RabbitListener</code> 提供的 <code>bindings</code> 参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(</span></span><br><span class="line"><span class="meta">    bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &lt;Queue Name&gt;, [durable = &quot;true&quot; | &quot;false&quot;]),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &lt;Exchange Name&gt;, type = ExchangeTypes.?),</span></span><br><span class="line"><span class="meta">        key = &#123; /* bindingKeys [String Array] */ &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><p>只需要声明一个注解即可定义队列、交换机、绑定关系；</p><p>但是上面的 Method 2 可能还是有问题：</p><ul><li><p>配置散落在业务代码中，没有与业务逻辑解耦；</p></li><li><p>这么写可能存在 queue / exchange 重复定义的问题，而且需要保证每次声明同样对象的配置一致。降低了可维护性和可扩展性；</p></li><li>在每个方法前面写这么大段注解，降低代码可读性；</li></ul><p>有什么办法解决吗？可以综合 Method 1 使用 ~</p><h3 id="1-2-6-Spring-AMQP-消息转换器"><a href="#1-2-6-Spring-AMQP-消息转换器" class="headerlink" title="1.2.6 Spring AMQP 消息转换器"></a>1.2.6 Spring <code>AMQP</code> 消息转换器</h3><p>注意，到目前为止，我们没有讨论过队列传输的对象是 <code>POJO</code> 或者是更复杂的 Java 对象的情况。</p><p>我们知道如果传输的是简单的 Java String，则 <code>RabbitMQ</code> 直接在队列上传输字符串；但是对于一般的 Java 对象，<code>RabbitMQ</code> 会使用 Java 内置的序列化实现将对象转为 Java Serializable Object；</p><p>我们跟踪 Spring <code>RabbitTemplate</code> 源码发现，内部对 <code>Object</code>（传递的信息）执行了 <code>convertMessageIfNecessary</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">protected</span> Message <span class="title function_">covertMessageIfNecessary</span><span class="params">(<span class="keyword">final</span> Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Message) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Message) object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getRequiredMessageConverter().toMessage(object, <span class="keyword">new</span> <span class="title class_">MessageProperties</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure><p><code>Message</code> 类型是 <code>AMQP</code> 定义的接口，定义了帮助 <code>AMQP</code> 传输消息的方法。</p><p>我们进一步了解发现 <code>getRequiredMessageConverter()</code> 方法是获取 <code>RabbitTemplate</code> 的实例属性 <code>messageConverter</code>，<strong>其类型是 <code>MessageConverter</code>，默认实现是 <code>SimpleMessageConverter</code></strong>；</p><p>再查看 <code>MessageConverter</code> 的接口实现可以发现 Spring 中存在很多实现，例如 <code>Jackson2XmlMessageConverter / Jackson2JsonMessageConverter / ...</code>；</p><p>那么这些 converter 具体是如何将一般的 <code>Object</code> 转换为 <code>Message</code> 的呢？</p><p>我们找到 <code>MessageConverter</code> 接口的 <code>toMessage()</code> 方法，发现其在 <code>SimpleMessageConverter</code> 中的实现如下：</p><p><img src="imgs/smc-createMessage.png"></p><p>注意到，对于非空非 <code>byte[] / String</code> 类型的可序列化对象，<code>SimpleMessageConverter</code> 会直接将对象序列化（默认 Java 的对象流 <code>ObjectOutputStream</code>）。</p><p>这样做一般情况下没什么，但是在消息中间件中不建议使用，具体有以下几点原因：</p><ul><li><code>JDK</code> 的 <code>ObjectOutputStream</code> 本身存在安全风险（可以轻松反序列化并且进行代码注入）；</li><li><code>JDK</code> 的对象数据流大小往往很大，存放了一些并不需要传输的数据（几个 byte 的数据可能被序列化成几百个 byte 的数据，降低了传输性能，限制了消息吞吐量）；</li></ul><p>这里建议使用 <code>Jackson2JsonMessageConverter</code>。我们只需要在发送模块书写一个 <code>Bean</code> 配置类，然后让 Spring Boot 自动装配即可。</p><blockquote><p>确保引入依赖 <code>com.fasterxml.jackson.core:jackson-databind</code>；</p></blockquote><h2 id="1-3-Spring-AMQP-实战：消息中间件替换-OpenFeign-同步远程调用"><a href="#1-3-Spring-AMQP-实战：消息中间件替换-OpenFeign-同步远程调用" class="headerlink" title="1.3 Spring AMQP 实战：消息中间件替换 OpenFeign 同步远程调用"></a>1.3 Spring <code>AMQP</code> 实战：消息中间件替换 <code>OpenFeign</code> 同步远程调用</h2><blockquote><p>小贴士：如果设置了消费者确认机制并且使用 <code>auto</code> 模式，使用 <code>@RabbitListener</code> 注解的函数返回类型必须是 <code>void</code>。否则 RabbitMQ 会认为 consumer 执行错误。</p></blockquote><h1 id="Chapter-2-MQ-进阶：消息可靠性"><a href="#Chapter-2-MQ-进阶：消息可靠性" class="headerlink" title="Chapter 2. MQ 进阶：消息可靠性"></a>Chapter 2. MQ 进阶：消息可靠性</h1><p>使用 Spring <code>AMQP</code> 进行服务间异步通信可能存在一些问题：</p><ul><li>消息发布方网络丢包，导致消息丢失；</li><li>消息被 MQ 正确接受到后，MQ 宕机导致消息丢失；或者消费者速度较低，MQ 产生内存中的消息积压（内存占满的刷盘期间）可能造成消息丢失；</li><li>在 MQ 发送给消息消费方时，消费方宕机导致消息丢失；</li></ul><p>因为网络的不可靠性，即便我们针对上述问题进行保护措施，仍然可能出现一些问题。我们最终需要一些兜底的机制，至少需要确保消息的最终一致性。</p><p>接下来将会以 RabbitMQ 为例，从上面 4 个角度分析 MQ 如何保证消息的可靠性。</p><h2 id="2-1-消息发布方的可靠性：重连与确认机制"><a href="#2-1-消息发布方的可靠性：重连与确认机制" class="headerlink" title="2.1 消息发布方的可靠性：重连与确认机制"></a>2.1 消息发布方的可靠性：重连与确认机制</h2><h3 id="2-1-1-发送者重连-性能警告"><a href="#2-1-1-发送者重连-性能警告" class="headerlink" title="2.1.1 发送者重连 [性能警告]"></a>2.1.1 发送者重连 [性能警告]</h3><p>发送者重连，在 MQ 与消息发布方连接后，存在连接断开的情况，这可能导致发布方网络丢包；因此需要 MQ 和服务发布方在网络丢失后进行重连，特别地，在 RabbitMQ 中需要<strong><u>在消息发送方</u></strong>进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">connection-timeout:</span> <span class="string">1s</span><span class="comment"># MQ 连接超时时间（连接等待多长时间才算失败，失败后才进行重连）</span></span><br><span class="line">        <span class="attr">template:</span></span><br><span class="line">            <span class="attr">retry:</span></span><br><span class="line">                <span class="attr">enable:</span> <span class="literal">true</span><span class="comment"># 消息重连（默认 false）</span></span><br><span class="line">                <span class="attr">initial-interval:</span> <span class="string">1000ms</span><span class="comment"># 连接失败/断开后的初识等待时间（立即尝试的成功概率小）</span></span><br><span class="line">                <span class="attr">multiplier:</span> <span class="number">1</span><span class="comment"># 尝试等待时间倍数（下次等待时间为上次的倍数。第二次相对于 initial-interval）</span></span><br><span class="line">                <span class="attr">max-attempts:</span> <span class="number">3</span><span class="comment"># 最大尝试次数</span></span><br></pre></td></tr></table></figure><p>但是这种机制是<strong>阻塞式重连</strong>，对业务性能会造成影响，这也是为什么 <code>retry</code> 默认配置是禁用的。如果必须要使用，也需要合理设置超时、等待时长，以及尝试次数；</p><h3 id="2-1-2-发送者确认-性能警告"><a href="#2-1-2-发送者确认-性能警告" class="headerlink" title="2.1.2 发送者确认 [性能警告]"></a>2.1.2 发送者确认 [性能警告]</h3><p>发送者确认：Spring <code>AMQP</code> 提供了 Publish Confirm（消息确认反馈）和 Publisher Return（路由错误返回信息）两种机制。</p><p><strong>在发送者确认机制打开后，当消息发布方向 MQ 发送一条消息，MQ 会返回<u>确认结果</u>给发送方</strong>，确认结果分为以下几种情况：</p><ul><li><p>消息成功投递到 MQ 中，但是路由失败：MQ 通过 Publisher Return 返回路由错误原因，返回 <code>ACK</code> 告知投递成功；</p><blockquote><p>这种情况只可能是：exchange 没有绑定队列 / routing key 没有匹配队列，是开发者原因。与网络、发送方、MQ 都没有关系，所以认为投递成功。</p><p>这种情况重新发送消息是没有意义的，因为错误不会因为重试而修复。</p></blockquote></li><li><p><strong><u>临时消息</u></strong>投递到 MQ 中，且成功入队；MQ 反馈 <code>ACK</code> 告知投递成功；</p><blockquote><p>临时消息对于队列是否是 <code>durable</code> 的没有要求，只要投递到 MQ 中，并且进入队列内存，就算成功；</p></blockquote></li><li><p><strong><u>持久消息</u></strong>投递到 MQ 中，且成功入队，且成功持久化；MQ 反馈 <code>ACK</code> 告知投递成功；</p><blockquote><p>持久消息需要被 MQ 放入 durable 队列中，并且持久化才算投递成功，这样可以防止 MQ 宕机造成消息丢失。</p><p>同时这可能损失一部分性能，所以应该根据业务逻辑来选择持久消息或临时消息。</p></blockquote></li><li><p>其他任何情况都会反馈 <code>NACK</code>，表示投递失败。<strong><u>只有在这种情况下，进行消息重发是正确的、有意义的</u></strong>；</p></li></ul><p>以 RabbitMQ 为例，开启发送者确认机制需要<strong><u>在消息发送方</u></strong>进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span><span class="comment"># 开启 Publish Confirm 机制，指定模式类型</span></span><br><span class="line">        <span class="attr">publish-return:</span> <span class="literal">true</span><span class="comment"># 开启 Publish Return 机制</span></span><br></pre></td></tr></table></figure><p>所谓 Publish Confirm 只包含了 <code>ACK / NACK</code> 的消息，而 Publish Return 则<strong>回调上面第一种投递成功，但路由失败的失败信息</strong>。</p><p>Publish Confirm 的 3 种模式分别为：</p><ul><li><code>none</code>：关闭 Publish Confirm 机制；</li><li><code>simple</code>：同步阻塞等待 MQ 的确认；</li><li><code>correlated</code>：MQ 异步回调方式确认；</li></ul><p>那么如何配置 MQ 的异步回调（confirm callback 和 return callback）？</p><p>事实上，一个 <code>RabbitTemplate</code> 只能配置一个 Return Callback（<strong>需要启用 Publish Return 机制</strong>）。所以需要在 Spring 项目启动过程中配置一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在构造函数完成后执行一次 */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">            <span class="comment">/* RabbitTemplate.ReturnsCallback 是一个函数接口 */</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnMessage</span><span class="params">(ReturnedMessage msg)</span> &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Return callback triggered.&quot;</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                    log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                    log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                    log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                    log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于单条消息而言还有 Confirm Callback（<strong>需要启用 Publish Confirm 机制</strong>），这在每条消息发送前都需要配置一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 CorrelationData，包含消息的全局 ID（MQ 需要区别消息以发送 confirm 或 return）</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(</span><br><span class="line">        UUID.randomUUID().toString()<span class="comment">/* 注：UUID 可能存在性能问题和 MAC 地址安全问题 */</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 2.给 Future 添加 ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(</span><br><span class="line">        <span class="comment">/* ListenableFutureCallback 是一个含有 onFailure 和 onSuccess 的接口 */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">                <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">                log.error(<span class="string">&quot;handle message ack fail&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 请类比 JavaScript 的 Promise，思考为什么即便是投递失败也在 onSuccess 中 */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">                <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">                <span class="keyword">if</span> (result.isAck()) &#123;</span><br><span class="line">                    <span class="comment">// result.isAck()，boolean类型</span></span><br><span class="line">                    <span class="comment">// true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                    log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                    log.error(</span><br><span class="line">                        <span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason()</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;test.direct&quot;</span>, <span class="string">&quot;red1&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要提一点，发送确认也会对性能有较大影响。而且发送丢包的概率较低，所以只建议在亟需确保数据可靠性的极端情况下才需要如此配置。</p><h2 id="2-2-MQ-的可靠性"><a href="#2-2-MQ-的可靠性" class="headerlink" title="2.2 MQ 的可靠性"></a>2.2 MQ 的可靠性</h2><p>如上所述，MQ 可能丢失消息的场景有两类：</p><ul><li>消息被 MQ 正确接受到后，MQ 宕机导致消息丢失；</li><li>消费者速度很低，MQ 产生内存中的消息积压阻塞（内存占满的刷盘期间无法继续入队）可能造成消息丢失；</li></ul><p>具体有两种思路可以解决，一是数据持久化策略，二是 Lazy Queue；</p><h3 id="2-2-1-MQ-的数据持久化-默认"><a href="#2-2-1-MQ-的数据持久化-默认" class="headerlink" title="2.2.1 MQ 的数据持久化 [默认]"></a>2.2.1 MQ 的数据持久化 [默认]</h3><ul><li><p>交换机持久化、队列持久化（默认都是 durable）；</p><blockquote><p>交换机、队列的持久化，是指交换机 / 队列自身的信息也会持久化在磁盘中；</p></blockquote></li><li><p>消息持久化。我们在之前提到，临时消息不会被 MQ 保证持久化到磁盘中，意味着这类消息在掉电后可能丢失。所以如果对一类消息的正确性要求很高，需要将消息设置为持久消息：</p><p>由于 <code>RabbitTemplate</code> 默认的 <code>convertAndSend</code> 方法中的 message converter 都默认构建 Message 为持久的消息，因此我们需要手动构建才能得到临时消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">    .withBody(<span class="string">&quot;Hello, Spring AMQP&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">    .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>如果使用大量数据实验会发现，大量、快速发送临时消息（不会主动刷盘）会不断在内存中积压，其触发的 Page Out（泛指内存耗尽触发的被动刷盘操作）会像数据结构 LSM Tree 的 compaction 操作一样短时间内迅速降低 MQ 的吞吐量，形成一个个性能低谷，总体性能反而小于持久数据（一开始就进行刷盘操作）；</p></li></ul><h3 id="2-2-2-Lazy-Queue-默认"><a href="#2-2-2-Lazy-Queue-默认" class="headerlink" title="2.2.2 Lazy Queue [默认]"></a>2.2.2 Lazy Queue [默认]</h3><p>在 Rabbit MQ 3.12 以后，所有队列默认 Lazy Queue 且无法更改。</p><p>Lazy Queue 的特征是，</p><ul><li>接收到消息后直接存入磁盘，不再存储到内存；</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（可以提前缓存部分消息到内存，最多2048条）；</li></ul><h2 id="2-3-消费者的可靠性"><a href="#2-3-消费者的可靠性" class="headerlink" title="2.3 消费者的可靠性"></a>2.3 消费者的可靠性</h2><h3 id="2-3-1-消费者确认机制"><a href="#2-3-1-消费者确认机制" class="headerlink" title="2.3.1 消费者确认机制"></a>2.3.1 消费者确认机制</h3><p>Spring <code>AMQP</code> 同样存在一种机制，即消费者确认机制（Consumer Acknowledgement）。</p><p>它是为了确认消费者是否成功处理消息。当消费者处理消息结束后，应该向 Rabbit MQ 发送一个回执，告知 Rabbit MQ 自己消息处理状态：</p><ul><li><code>ACK</code>：成功处理消息，Rabbit MQ 从队列（内存以及磁盘）中删除该消息；</li><li><code>NACK</code>：消息处理失败，Rabbit MQ 需要再次投递消息；</li><li><code>REJECT</code>：消息处理失败并拒绝该消息，Rabbit MQ 从队列（内存以及磁盘）中删除该消息；</li></ul><p>这个回执应该在消费者关于该消息所有业务逻辑处理完成后，才能返回，防止出错后无法重试。</p><p>这样的操作非常类似 事务机制。</p><p>Spring <code>AMQP</code> 已经实现了消息确认功能。并允许我们通过配置文件选择ACK处理方式：</p><ul><li><p><code>none</code>：不处理。即消息投递给消费者后立刻 <code>ACK</code>，消息会立刻从 MQ 删除。非常不安全，不建议使用；</p></li><li><p><code>manual</code>：手动模式。需要自己在业务代码中调用 API，发送 <code>ACK</code> 或 <code>REJECT</code>，存在业务入侵，但更灵活；</p></li><li><p><code>auto</code>：自动模式。Spring <code>AMQP</code> 利用 <code>AOP</code> 对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回 <code>ACK</code>.  当业务出现异常时，根据异常判断返回不同结果：</p><ul><li><p>如果是业务异常，会自动返回 <code>NACK</code>，消息会重新进入 <code>Ready</code> 状态投递给对应消费者（重新处于 <code>Ready</code> 状态）；</p><blockquote><p>消费者宕机、抛出 <code>RuntimeException</code> / 其他自定义异常，都认为是 <code>NACK</code>；</p></blockquote></li><li><p>如果是消息处理或校验异常（需要抛出例如 <code>MessageConversionException</code>），自动返回 <code>REJECT</code>；</p><blockquote><p>这就提醒我们，遇到业务逻辑中的格式异常，请不要 throw <code>RuntimeException</code>，不然会被 Spring 认为是业务异常而重新发送！</p></blockquote></li></ul></li></ul><p>我们需要在消息消费方配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">acknowledge-mode:</span> <span class="string">none</span><span class="comment"># 默认不处理，</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2-消费者失败重试机制"><a href="#2-3-2-消费者失败重试机制" class="headerlink" title="2.3.2 消费者失败重试机制"></a>2.3.2 消费者失败重试机制</h3><p>在引入消费者确认机制后，还会出现一个问题：如果 MQ 中积压的消息量过大，导致消费方宕机，在消费者恢复后，没有进行请求热身，MQ 又重发了大量的消息，很有可能会再次导致消费方再次宕机。</p><p>这会给消费方和 MQ 都造成极大的压力。</p><p>为了应对这种情况，MQ 引入了另一种机制来保障消费方的消息可靠性：消费者失败重试机制。在消费者出现异常时按照配置重试，而不是无限的重复入队。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">retry:</span><span class="comment"># 注：发送方重试位于 template 下</span></span><br><span class="line">                    <span class="attr">enabled:</span> <span class="literal">true</span><span class="comment"># 默认 false</span></span><br><span class="line">                    <span class="attr">initial-interval:</span> <span class="string">1000ms</span><span class="comment"># 失败初始等待时间</span></span><br><span class="line">                    <span class="attr">multiplier:</span> <span class="number">1</span></span><br><span class="line">                    <span class="attr">max-attempts:</span> <span class="number">3</span></span><br><span class="line">                    <span class="attr">stateless:</span> <span class="literal">true</span><span class="comment"># 如果业务中含有事务，说明这种消息重递是有状态的，应该 false</span></span><br></pre></td></tr></table></figure><p>在重试超过 <code>max-attempts</code> 后，消息状态转变为 requeue-exhausted，进而转入 <code>MessageRecoverer</code> 中处理。</p><p>Spring <code>AMQP</code> <strong>默认的 <code>MessageRecoverer</code> 的实现是 <code>RejectAndDontRequeueRecoverer</code></strong>，其策略是直接丢弃这条消息，这样做有失消费者安全性。</p><p>除了默认的 recoverer，还有两种：</p><ul><li><p><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，仍然认为返回 <code>NACK</code>，重新入队；</p><blockquote><p>这种策略和不采取失败者重试的策略相比，性能影响会小一点；</p></blockquote></li><li><p><code>RepublishMessageRecoverer</code>：重试耗尽后，将消息（<strong>包括报错信息</strong>）投递到指定交换机，以供其他处理用途；</p><blockquote><p>这种策略也比较合理，认为反复投递无效就应该换一种处理方式。</p><p>但这种方法需要专门配置一个指定的交换机：</p><ul><li>定义接受失败队列、与其绑定的交换机；</li><li>定义 <code>RepublishMessageRecoverer</code> 的 Bean（传入 <code>RabbitTemplate</code>、交换机、队列名称）；</li></ul></blockquote></li></ul><p>这种机制虽然相较于原先确认机制而言，降低了可靠性，但是一定程度上提升了服务的可用性，降低多次/长时间宕机造成的资源浪费风险。</p><h2 id="2-4-业务幂等性保证"><a href="#2-4-业务幂等性保证" class="headerlink" title="2.4 业务幂等性保证"></a>2.4 业务幂等性保证</h2><p>在上面的过程中，有一种情况我们没有考虑：如果消费者的接口不是幂等的，就需要保证消息发送的不重复性。</p><p>也就是说，<strong>假设消费者收到消息后并且处理结束，要给 MQ 发送 <code>ACK</code> 时连接断开了（或者两方有一方宕机了），就可能会导致 MQ 消息重新发送</strong>。这个问题没办法借助 MQ 来解决，因为不是 MQ 本身的问题。</p><p>那么应该如何处理这种情况？</p><h3 id="2-4-1-唯一消息-ID"><a href="#2-4-1-唯一消息-ID" class="headerlink" title="2.4.1 唯一消息 ID"></a>2.4.1 唯一消息 ID</h3><p>第一种思路是唯一消息 ID：给每个消息都设置一个唯一 ID，利用 ID 区分是否是重复消息。</p><ul><li>每一条消息都生成一个唯一的 ID，与消息一起投递给消费者；</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息 ID 保存到数据库；</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ul><blockquote><p>Tips. 这和之前提到的发送者确认机制中创建的 <code>CorrelationData</code> 中的 ID 不一样，前者是作回执用的 ID，它和消费 ID 可以保持消费不一致；</p></blockquote><p>我们可以在定义消息转换器时显式声明让 MQ 创建全局唯一的 Message ID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageCoverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    jmc.setCreateMessageIds(<span class="literal">true</span>);    <span class="comment">/* 默认 false */</span></span><br><span class="line">    <span class="keyword">return</span> jmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Message ID 会存放在 Message 的 Properties 中（不是我们常用的 Payload 中），所以需要我们单独去取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 都需要转换，所以直接使用 Message 类型接收，就能收到 properties 数据 */</span></span><br><span class="line"><span class="meta">@RabbitListener(/* ... */)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    message.getBody();     <span class="comment">/* 返回 byte[] */</span></span><br><span class="line">    message.getMessageProperties();    <span class="comment">/* MessageProperties */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>byte[]</code> 中如果原来是字符串，则可以直接用字符串构造函数构造；</p><p>如果是 自定义的对象，并且使用了 <code>Jackson2JsonMessageConverter</code>，直接用配套的 <code>ObjectMapper</code> 解析就行；</p></li><li><p><code>MessageProperties.getMessageId()</code> 就能获取其中的 <code>message-id</code> 属性（如果有）；</p></li></ul><p>缺点：</p><ul><li><p>业务逻辑嵌入和耦合。给业务引入了原本不需要的逻辑，造成耦合；</p></li><li><p>数据库写影响原本业务性能；</p></li></ul><h3 id="2-4-2-业务逻辑本身判断"><a href="#2-4-2-业务逻辑本身判断" class="headerlink" title="2.4.2 业务逻辑本身判断"></a>2.4.2 业务逻辑本身判断</h3><p>上面的方法虽然通用，但是是侵入式的解决方案。如果业务逻辑允许，我们可以根据原有的业务逻辑判断这次消息是否被处理过。</p><blockquote><p>相当于做了非幂等业务的保护流程。</p><p>例如对于订单业务，如下图，如果在交易服务中的 “标记订单为已支付”，如果用户在支付成功后，“标记订单已支付” 以及完成，正在向 MQ 发送 <code>ACK</code> 时断开连接。此时 MQ 认为消费者未收到。</p><p>如果用户此时发起了退款，交易服务立即更改为退款中，此后 MQ 的连接又恢复了，如果不作处理，则 “已支付” 的状态会覆盖 “退款中” 的状态。</p><p><img src="imgs/pe-example.png" width="400px"></p><p>这种情况除了使用 Message ID 的方法，还可以直接检查 “标记订单已支付” 之前的订单状态，毕竟根据业务逻辑，只有未支付的订单才会需要标记成已支付：</p><p><img src="imgs/pe-example-sol.png" width="600px"></p></blockquote><p> 总结一下：</p><p>如何保证支付服务与交易服务之间的订单状态一致性？</p><ul><li><p>首先，支付服务会正在用户支付成功以后利用 MQ 消息通知交易服务，完成订单状态同步；</p></li><li><p>其次，为了保证 MQ 消息的可靠性，我们采用了发送者确认机制、消费者确认、消费者失败重试等策略，确保消息投递和处理的可靠性。同时也开启了 MQ 的持久化，避免因服务宕机导致消息丢失；</p><blockquote><p>保证消费者至少消费一次。</p></blockquote></li><li><p>最后，我们还在交易服务更新订单状态时做了业务幂等判断，避免因消息重复消费导致订单状态异常。</p></li></ul><p>上面的策略已经比较完善了，但是还是可能存在问题：我们的机制没有问题，但是网络原因，MQ 和消费者间真的一直都没办法建立连接，能否有个兜底机制，至少确保关键的业务（例如支付）数据一致性？</p><h2 id="2-5-延迟任务和延迟消息"><a href="#2-5-延迟任务和延迟消息" class="headerlink" title="2.5 延迟任务和延迟消息"></a>2.5 延迟任务和延迟消息</h2><p>延迟任务是消息一致性的一种兜底方案。</p><p>延迟消息：<strong><u>发送者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。</u></strong></p><p>以下单举例：</p><p><img src="imgs/delay-example.png" width="600px"></p><p>假设交易服务和支付服务间暂时一直无法连接，是否有机制确保二者间的消息一致？</p><p>我们可以引入超时时间的概念，一段时间后，再次向支付服务查询如果成功就改变状态；如果失败则取消。</p><p>在 Rabbit MQ 中可以借助插件来完成延迟任务（默认不支持）。</p><h3 id="2-5-1-死信交换机（dead-letter）"><a href="#2-5-1-死信交换机（dead-letter）" class="headerlink" title="2.5.1 死信交换机（dead-letter）"></a>2.5.1 死信交换机（dead-letter）</h3><p>当一个队列中的消息满足下列情况之一时，就会成为死信（dead letter）：</p><ul><li>消费者使用 <code>REJECT</code> 或 <code>NACK</code> 声明消费失败并且消息的 <code>requeue</code> 参数设置为 <code>false</code> / 使用失败重试机制的 Message Recoverer 是 <code>RejectAndDontRequeueRecoverer</code>；</li><li>消息是一个过期消息（达到了队列或消息本身设置的过期时间），超时无人消费；</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信；</li></ul><p>我们可以在声明交换机时，给定一个属性 <code>dead-letter-exchange</code>，并且与某个队列绑定，那么该队列中的死信就会自动投递到这个交换机中；</p><p>我们可以利用死信交换机的 “超时” 特性，实现延时任务：</p><p><img src="imgs/dead-letter-meme-delay.png"></p><p>我们可以对某个队列声明死信交换机，直接使用 <code>QueueBuilder</code> 的方式定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueueBuilder</span><br><span class="line">    .durable(&lt;queue name&gt;)</span><br><span class="line">    .deadLetterExchange(&lt;dlx exchange name&gt;)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure><p>最后，我们还有在发送消息时还需要指定消息的过期时间，确保最终以规定时间进入死信交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(&lt;normal direct&gt;, &lt;key&gt;, &lt;object&gt;, &lt;post process&gt;)</span><br></pre></td></tr></table></figure><p>在最后一个参数中，传入一个 <code>MessagePostProcessor</code> 函数接口的实现，即可在 object 转换为 <code>Message</code> 对象后再进行处理，以设置超时时间。因为<strong><u>超时时间也位于 Message 的 Properties 中</u></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">postProccessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">        message.getMessageProperties().setExpiration(<span class="string">&quot;10000&quot;</span> <span class="comment">/* 字符串表示的 ms */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 也可以换成 lambda 表达式 */</span></span><br></pre></td></tr></table></figure><h3 id="2-5-2-Rabbit-MQ-延时任务插件"><a href="#2-5-2-Rabbit-MQ-延时任务插件" class="headerlink" title="2.5.2 Rabbit MQ 延时任务插件"></a>2.5.2 Rabbit MQ 延时任务插件</h3><p>需要在 <code>mq-plugins/_data</code> 中加入插件，并且配置 <code>enabled_plugins</code> 文件，加入 <code>rabbitmq_delayed_message_exchange</code> 即可；</p><p>然后，我们需要设置某个交换机的属性为 <code>delayed</code>：</p><ul><li>如果使用 Bean 配置，那么就用 <code>ExchangeBuilder</code> 添加 <code>delayed()</code> 方法；</li><li>如果使用 <code>@RabbitListener(bindings)</code> 的配置，就在 <code>@Exchange</code> 中加入 <code>delayed = &quot;true&quot;</code>；</li></ul><p>最后给要发送的消息指定 properties <code>x-delay</code>，同样使用 post processor，此时对 Message Properties 调用 <code>setDelay(&lt;ms&gt;)</code> （不是 <code>setExpiration</code>）即可；</p><blockquote><p>注意：无论是延时消息，还是死信的生成，其计时依赖 CPU 时钟，所以是 CPU 密集型任务。</p><p>如果超时时间 / 过期时间设置过长，都会导致需要计时的消息大量积压，影响 MQ 性能。</p><p><strong><u>所以无论是死信交换机中的过期时间，还是延时任务的延时时间，都不宜设置过长。</u></strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-0-背景&quot;&gt;&lt;a href=&quot;#Chapter-0-背景&quot; class=&quot;headerlink&quot; title=&quot;Chapter 0. 背景&quot;&gt;&lt;/a&gt;Chapter 0. 背景&lt;/h1&gt;&lt;h2 id=&quot;0-1-同步消息和异步消息&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="MQ" scheme="https://sjtuxhw.top/tags/MQ/"/>
    
    <category term="Web" scheme="https://sjtuxhw.top/tags/Web/"/>
    
    <category term="Microservice" scheme="https://sjtuxhw.top/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>微服务初探</title>
    <link href="https://sjtuxhw.top/2024/05/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%8E%A2/"/>
    <id>https://sjtuxhw.top/2024/05/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%8E%A2/</id>
    <published>2024-05-21T03:27:40.000Z</published>
    <updated>2024-07-28T08:22:38.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-0-基本概念"><a href="#Chapter-0-基本概念" class="headerlink" title="Chapter 0. 基本概念"></a>Chapter 0. 基本概念</h1><ul><li>微服务是一种软件架构风格。专注于单一职责的小型业务为基础，组成复杂大型应用。</li><li>需要解决的问题：服务拆分、远程调用（RPC）、服务治理（可用性与调度）、请求路由、身份认证、配置管 理、分布式事务（一致性问题）、异步通信……</li><li>优点和特征：粒度小、单服务开发便捷，团队自治，服务自治，系统耦合性低；</li><li>缺点：跨模块开发难度大，运维成本高；</li></ul><blockquote><p>对比而言，单体架构：</p><ul><li>优点：架构简单、部署成本低（适用于开发功能相对简单、规模较小的项目）；</li><li>缺点：团队协作成本高，系统发布效率低、系统可用性差（软件可靠性差）；</li></ul></blockquote><ul><li>对应框架：Spring Cloud，全球范围广泛使用的微服务框架；<ul><li>服务注册发现组件：Eureka、Nacos、Consul……</li><li>服务远程调用（RPC）；OpenFeign、Dubbo……</li><li>服务链路监控：Zipkin、Sleuth……</li><li>统一配置管理：Spring Cloud Config、Nacos……</li><li>统一网关路由：Spring Cloud Gateway、Zuul……</li><li>流控、降级、保护：Hystix、Sentinel……</li></ul></li></ul><h1 id="Chapter-1-基于实践学习：将单体架构拆分"><a href="#Chapter-1-基于实践学习：将单体架构拆分" class="headerlink" title="Chapter 1. 基于实践学习：将单体架构拆分"></a>Chapter 1. 基于实践学习：将单体架构拆分</h1><h2 id="1-1-基本思路"><a href="#1-1-基本思路" class="headerlink" title="1.1 基本思路"></a>1.1 基本思路</h2><ul><li>拆分时机：<ul><li>创业项目：先使用单体架构，快速开发、试错；规模扩大后再拆分；</li><li>确定的大型项目：资金充足，目标明确，直接选择微服务架构；</li></ul></li><li>拆分原则：<ul><li>高内聚：每个微服务的职责尽量单一，包含的业务相互关联度高、<strong>完整度高</strong>；</li><li>低耦合：每个微服务的功能要相对独立，尽量减少对其他微服务的依赖；</li></ul></li><li>拆分方式：<ul><li>纵向拆分：按业务模块拆分（用户认证管理、订单管理……）；</li><li>横向拆分：抽取公共服务，提高复用性（用户登录、订单管理中有公共服务，例如风控、日志服务）；</li></ul></li></ul><blockquote><p>具体如何拆分何种模式？</p><ul><li><p>独立 Project：一个单体架构的项目拆分后，将每个 service 放在一个独立 Project 内；</p><p>优点：相当解耦，关联度更低；</p><p>缺点：对于小型项目而言仓库管理臃肿费力；</p><p>适用：大型项目，每个 service 的业务逻辑相当复杂；</p></li><li><p>Maven 聚合：一个单体项目拆分后，所有 service 都存放在一个 project 中，这个 project 专门用于管理依赖，每个 service 都是 project 的一个 module；</p><p>适用：中小型项目，敏捷开发；</p></li></ul></blockquote><h2 id="1-2-远程调用-RPC：以-Spring-RestTemplate-为例"><a href="#1-2-远程调用-RPC：以-Spring-RestTemplate-为例" class="headerlink" title="1.2 远程调用 RPC：以 Spring RestTemplate 为例"></a>1.2 远程调用 RPC：以 Spring <code>RestTemplate</code> 为例</h2><p>拆分的问题：经常会遇到一个服务依赖另一个服务的情况。这可以直接通过服务间远程调用（RPC）来完成。</p><blockquote><p>远程调用 RPC 更像是一种软件协议，能<strong><u>让一个程序和本地执行流程一样，在远端执行一段代码</u></strong>。</p><p>在软件工程原理的 23 个设计模式中，更像是利用了 Proxy 设计模式。调用者无需关心远程信息交互的具体细节，只需按照接口像调用本地服务一样即可完成目标。</p></blockquote><p>在 Spring 中，一种轻量级的远程调用的方法是，使用接口：<code>RestTemplate</code>，调用它就相当于在 Java 代码中向 RESTful API 发送网络请求并且获取回复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">exchange</span><span class="params">(</span></span><br><span class="line"><span class="params">    String url,</span></span><br><span class="line"><span class="params">    HttpMethod method,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> HttpEntity&lt;?&gt; requestEntity,    <span class="comment">/* request body */</span></span></span><br><span class="line"><span class="params">       Class&lt;T&gt; responseType,</span></span><br><span class="line"><span class="params">    Map&lt;String, ?&gt; uriVariables</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>规避类型擦除：<code>new ParameterizedTypeReference&lt;T&gt;() &#123;&#125;</code>；</p></blockquote><p>但是有一些不可避免的问题：</p><ul><li>若代码中写死 <code>url</code>，则 负载均衡、可用性轮换等等策略全部失效；</li><li>若业务逻辑中的远程调用的部分较多，则 <code>RestTemplate</code> 对象散落各处不方便维护；</li><li>……</li></ul><p>于是我们需要更严格、复杂的架构将服务间的远程调用管理起来。一种思路就是 “<strong><u>发布-订阅者模式</u></strong>”；</p><h2 id="1-3-微服务的注册与发现机制"><a href="#1-3-微服务的注册与发现机制" class="headerlink" title="1.3 微服务的注册与发现机制"></a>1.3 微服务的注册与发现机制</h2><h3 id="1-3-1-发布-订阅模式（架构）"><a href="#1-3-1-发布-订阅模式（架构）" class="headerlink" title="1.3.1 发布-订阅模式（架构）"></a>1.3.1 发布-订阅模式（架构）</h3><p>发布-订阅者模式（pub-sub pattern）；</p><p><img src="imgs/pub-sub.png"></p><p>The Pub/Sub (Publisher/Subscriber) model is a messaging pattern used in software architecture to facilitate asynchronous communication between different components or systems. In this model, publishers produce messages that are then consumed by subscribers.</p><p>发布-订阅模型，作为一种消息传递模式，用在一些软件架构中，来实现不同组件、系统间的<strong><u>异步通信</u></strong>。</p><ul><li><p>subscribers：消息的获取方，publishers：消息生产方；</p></li><li><p>topics：一种订阅频道 / 分类（channels / categories）；</p><p>发布者可以按照消息的业务含义为消息打上话题标签（并且无需知道订阅者的特性），而订阅者可以按照 topics 来订阅、获取部分感兴趣的消息（并且无需知道发布者的特性）；</p><p>Topics help categorize messages and enable targeted message delivery to interested subscribers.</p></li><li><p>message brokers：一种中间件/中间人（intermediaries），负责在 publishers 和 subscribers 间使用合适的策略传递消息（调度队列、延时……）；</p><ul><li>message brokers 可以按 topics 维护一些消息队列；</li><li>确保消息发送给正确的订阅者，并且提供额外的特性：<strong><u>消息持久化、可扩展性、可靠性</u></strong>；</li></ul></li><li><p>message：可以是任何形式的数据信息（text, JSON, binary, etc）；</p></li><li><p>subscription：订阅代表了 subscriber 和某个 topics 建立的一个关联。它定义了：</p><ul><li>订阅者订阅了什么 topic 的消息；</li><li>订阅设置，例如是否事务、是否有订阅内容保证（at-most-once / at-least-once）等等；</li></ul></li></ul><p>发布-订阅模型的理论过程：</p><ol><li>发布者创建并发送消息给 pub/sub system，并且根据消息内容类型放入指定 topic 或者说 channel 中；</li><li>订阅者向 pub/sub system 表达需要订阅某个/些 topic 的意愿，有信息就会收到；</li><li><p>message brokers 根据收到发布者的 topic 对收到的消息分类，再根据所有 topics 的订阅情况 forward 给所有订阅了这个 topic 的 subscribers；</p></li><li><p>以上过程全部异步，发布者不需要关心订阅者的状态即可发布；订阅者无需关心发布者的状态即可接受消息。</p></li></ol><p>发布-订阅模型的优势：</p><ul><li>decoupling &amp; scalability：将消息生产方和消息接受方解耦，不仅无需关心对方状态和交互细节，而且 scalable，便捷地增减 publishers 和 subscribers 的数量而无需影响现有组件；</li><li>asynchronous communication：异步通信能力；</li><li>event-driven architecture：发布者和订阅者互不耦合，但发布者的事件行为可以影响订阅者；</li><li>dynamic subscription：允许运行时动态更换订阅，去耦合，全面的灵活性；</li></ul><p>发布-订阅模型的适用场景：</p><ul><li>消息队列系统；</li><li>需要构建 scalable web app 的时候，尤其是在线文档、实时更新的场景；</li><li>微服务架构间的远程通信；</li><li>……</li></ul><p>发布-订阅模型不应该使用的场景：</p><ul><li>对交互时延有极强需求的场景，例如游戏；</li><li>低复杂度的交互场景，例如系统只有两个组件间的交互，贸然引入会增大不必要的复杂度；</li><li>……</li></ul><p>回到微服务远程调用的主题上。为了确保服务远程调用的灵活性、可用性，我们可以借鉴 发布-订阅者模式，通过注册、发现、订阅的流程，动态调度服务的访问方式。</p><p>这样既可以有效地、统一地管理远程访问，提升可维护性，又可以便捷地进行调度，充分利用服务资源。</p><h3 id="1-3-2-注册中心"><a href="#1-3-2-注册中心" class="headerlink" title="1.3.2 注册中心"></a>1.3.2 注册中心</h3><p>在微服务架构中，规避微服务间直接远程调用缺陷的一种方式就是引入注册中心机制，借鉴发布-订阅模式，引入注册中心后的主要步骤如下：</p><ol><li>服务发布者向注册中心注册服务信息（提供何种服务，即 topic，还有地址在哪里）；</li><li>服务订阅者向注册中心订阅感兴趣的服务。此时注册中心可以将<strong><u>当前可用的</u></strong>发布者信息告诉订阅者；</li><li>订阅者（或者注册中心）可以进行负载均衡，选择一个发布者向其请求服务（远程调用）。</li></ol><p>由于我们利用了发布-订阅模式，所以即便是已经获取服务列表的订阅者，也能从注册中心实时获取当前发布者的可用情况。例如：</p><blockquote><p>假设订阅者从注册中心获取了 3 个可能的服务发布者，但是一段时间后其中一个服务提供方 A 宕机。</p><p>这个时候 A 不再通过注册中心的 health check（heart beat），注册中心认为 A 不再有效，于是向所有订阅了 A 服务所在 topic 的所有订阅者推送变更。</p><p>这就保证了订阅者订阅列表的有效性。创建了新的服务实例也是如此！实现了 scalable service，随意增减服务实例数量、负载均衡。</p></blockquote><hr><p>在代码方面，我们知道在 Spring Cloud 中，注册中心有很多实现，例如 Alibaba 的 Nacos，Netflix 的 Eureka。我们就以其中的 Nacos 为例。我们只需要将注册中心部署在固定 IP 的服务器上即可。</p><p>配置好 Nacos，在注册服务客户端（也就是提供服务方）引入 nacos 注册发现服务，还需要对 Spring 进行配置，指定 registry server 的地址和需要的服务名。最后启动这个服务实例即可完成注册！</p><p>而在服务调用端，需要在项目中引入 Nacos Client，它实现了 Spring Cloud 的 <code>DiscoveryClient</code> 接口。</p><p>我们直接注入 <code>DiscoverClient</code>，使用如下方法：</p><ul><li><code>DiscoverClient.getInstances(String serviceName) -&gt; List&lt;ServiceInstance&gt;</code>，<code>serviceName</code> 是服务提供方在 Nacos 中注册的服务名；</li><li>而我们可以通过 <code>ServiceInstance</code> 获取 <code>uri / host / port</code> 信息，手动写负载均衡或其他处理工作。</li></ul><blockquote><p>注：Nacos 需要导入依赖 <code>spring-cloud-starter-alibaba-nacos-discovery</code>，并且进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">nacos.server-addr:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="1-3-3-更优雅的远程调用：OpenFeign"><a href="#1-3-3-更优雅的远程调用：OpenFeign" class="headerlink" title="1.3.3 更优雅的远程调用：OpenFeign"></a>1.3.3 更优雅的远程调用：OpenFeign</h3><h4 id="初步认识-OpenFeign"><a href="#初步认识-OpenFeign" class="headerlink" title="初步认识 OpenFeign"></a>初步认识 OpenFeign</h4><p>但是这里有个问题，我们通过 <code>DiscoverClient</code> 获取可用服务列表，然后再处理一系列可能的异常，然后还要手写 <code>RestTemplate</code> 进行远程调用，最后才能访问服务！</p><p>如此繁琐的远程调用，我们应该进行封装！好在同样有框架能够更轻松地帮助我们完成远程调用：OpenFeign；</p><blockquote><p>注：我们还要对负载均衡算法进行封装。使用 Spring cloud load balancer 就能解决问题。</p></blockquote><p>引入 OpenFeign 的方法如下：</p><ul><li><p>引入 OpenFeign 依赖；</p></li><li><p>在 Springboot Application 启动类注解 <code>@EnableFeignClients</code> 启用 OpenFeign 的特性；</p></li><li><p>定义接口，用于指定要远程调用的服务名、远程调用服务名的 endpoint。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;)</span>    <span class="comment">/* 需要向注册中心申请的服务名 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 告诉 OpenFeign 需要连接远程服务的 endpoint 相当于指定 RestTemplate 的 uri 和 HttpMethod */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    <span class="comment">/* 告诉 OpenFeign 的传入参数、请求体信息，以及服务返回 JSON 对应的类型，相当于指定 RestTemplate 的 RequestEntity，responseType，uriVariables */</span></span><br><span class="line">    List&lt;ItemDto&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样相当于实现了 proxy 设计模式（这个 interface 对应 Spring 生成的实例就是 proxy），在调用远程服务就像调用本地服务一样简单！</p><h4 id="OpenFeign-连接池优化"><a href="#OpenFeign-连接池优化" class="headerlink" title="OpenFeign 连接池优化"></a>OpenFeign 连接池优化</h4><p>OpenFeign 的底层实现非常类似我们手动使用 <code>DiscoverClient</code>，并且考虑负载均衡、服务异常的情况。</p><p>感兴趣的同学可以步进调试观察其底层行为。</p><p>值得注意的是，OpenFeign 底层默认的远程调用的方式是利用 <code>HttpURLConnection</code> 类（位于 <code>FeignBlockingLoadBalancerClient</code> 的 <code>delegate</code> 成员变量），而这个 Java 内置类比较底层，不支持连接池，不像 apache 的 <code>HttpClient</code> 和 <code>OkHttp</code>，可能造成资源利用率较低。</p><p>好在我们可以为 OpenFeign 的底层请求更换具有连接池的连接类，这样可以减小创建和销毁连接的开销，有助于提升程序性能。只需导入依赖相应依赖（例如 <code>feign-okhttp</code>），并且在 <code>application.yaml/properties</code> 中配置开启即可（例如 <code>feign.okhttp.enabled = true</code>）；</p><blockquote><p>注意，是在 OpenFeign 调用方模块设定才有效！</p></blockquote><h4 id="OpenFeign-最佳实践"><a href="#OpenFeign-最佳实践" class="headerlink" title="OpenFeign 最佳实践"></a>OpenFeign 最佳实践</h4><p>到这里仍然没有结束，我们还需要知道 OpenFeign 框架的最佳实践。</p><p>上面介绍引入 OpenFeign 的方法实际上是有严重问题的。我们发现，当单体架构的程序被拆成微服务后，有可能多个服务依赖同一个微服务，难不成所有用到的微服务都要定义一遍像 <code>ItemClient</code> 一样的接口？</p><p>我们知道，代码重复是大忌，这不仅降低了可维护性（增添维护人员心智负担）、可扩展性（修改繁琐，不对修改开发），还降低了代码可读性和正确性。</p><p>正确使用 OpenFeign 的方案有几种：</p><ul><li><p>直接交给服务提供方编写 Feign Client，将服务提供方拆成 3 个模块：</p><ul><li><code>DTO</code> 中包含向服务调用方返回的数据类型；</li><li><code>api</code> 中包含 <code>FeignClient</code> 接口以供调用；</li><li><code>blz</code> 中包含原先的代码业务逻辑；</li></ul><p>最后其他服务只需引用该服务为依赖即可。</p><p>优点：代码逻辑更合理，易于维护，耦合度更低；</p><p>缺点：项目结构更复杂、编写麻烦；</p></li><li><p>创建一个不属于任何一个微服务模块的、同级的 <code>api</code> module，专门管理 <code>FeignClient</code>，主要包含：</p><ul><li><code>client</code>：所有微服务想要向外暴露的 <code>FeignClient</code>；</li><li><code>config</code>：所有微服务的配置类；</li><li><code>dto</code>：所有微服务想要返回的数据类型；</li></ul><p>优点：项目结构清晰，无需改动原先微服务；</p><p>缺点：代码耦合度增加，每个微服务模块都需要引入该模块为依赖（而前一种方法只需引入需要用的模块就行），所有微服务都需要和 <code>api</code> 一起开发；</p><p>但是如果以这种方式创建 <code>FeignClient</code>，没法完成依赖注入（因为 Spring Application 没法自主扫描本包以外的 bean），就需要手动指定接口类型，并将其纳入 IoC Container 中。两种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 SpringApplication 启动类启用 FeignClient 时显示指定 bean 类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方法一：为 Spring 指定 bean 扫描的包名（精确到子包） */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &lt;package name&gt;)</span></span><br><span class="line"><span class="comment">/* 方法二：利用反射手动指定 bean 对应接口的 Class 类型 */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(clients = &#123; &lt;classname&gt;.class &#125;)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="OpenFeign-日志管理"><a href="#OpenFeign-日志管理" class="headerlink" title="OpenFeign 日志管理"></a>OpenFeign 日志管理</h4><p>OpenFeign 框架默认情况下仅在 <code>FeignClient</code> 所在包配置的日志级别为 <code>DEBUG</code> 时才会输出日志，并且自身的日志级别是 <code>NONE</code>（不输出），故需要我们手动配置。</p><blockquote><p>注：OpenFeign 自身的日志级别有 4 种：<code>NONE / BASIC / HEADERS / FULL</code>；</p></blockquote><p>定义 OpenFeign 的日志级别需要完成两件事：</p><ol><li><p>定义配置类，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 没有 @Configuration / @Service 等注解，该 @Bean 不会被纳入 IoC Container */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将配置类配置给指定 / 全局的 <code>FeignClient</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指定 FeignClient */</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;...&quot;, configuration = FeignConfig.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局 FeignClient 默认 */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = FeignConfig.class)</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="1-4-微服务网关"><a href="#1-4-微服务网关" class="headerlink" title="1.4 微服务网关"></a>1.4 微服务网关</h2><p>在大致拆好微服务后，有个问题就随之出现：前端应该如何访问后端服务？难道前端还需要动态获取各个服务的地址？</p><p>肯定不能这样，我们的期望是前后端的解耦，就是说单体架构和微服务架构下，前端是无需改变的，只需要向固定的地址发送不同请求就能得到对应的响应，这就需要一个中间层来完成这个任务。</p><p>这个能将不同服务转发给某个符合条件的微服务的中间层就是网关。网关不仅能完成前面的 forward 的功能，还能<strong><u>配合注册中心</u></strong>进行负载均衡。</p><blockquote><p>功能：</p><ul><li>请求路由（路径针对什么微服务？）；</li><li>转发（帮忙将 HTTP 请求 forward 给某个动态地址的实例）；</li><li>身份校验（检查请求的 <code>Authorization</code> 是否合法）；</li></ul></blockquote><p>这样，我们就不需要在每个微服务中进行身份校验等繁琐工作了。更安全的是，后端微服务甚至不需要向外暴露端口了，只需暴露网关，大大增强安全性。</p><p>此外，引入网关后，后端实现了封装和解耦，在前端看来这和单体架构别无二致。</p><h3 id="1-4-1-微服务网关框架：Spring-Cloud-Gateway"><a href="#1-4-1-微服务网关框架：Spring-Cloud-Gateway" class="headerlink" title="1.4.1 微服务网关框架：Spring Cloud Gateway"></a>1.4.1 微服务网关框架：Spring Cloud Gateway</h3><div class="table-container"><table><thead><tr><th>Spring Cloud Gateway</th><th>Netflix Zuul</th></tr></thead><tbody><tr><td>基于 <code>WebFlux</code> 响应式编程</td><td>基于 <code>Servlet</code> 阻塞式编程</td></tr><tr><td>无需调优即有很好性能</td><td>需要调优才有接近Spring Cloud Gateway 的性能</td></tr><tr><td>正常维护</td><td>更新较慢</td></tr></tbody></table></div><p>基于上述特点，我们以 Spring Cloud Gateway 为例。</p><p>它的使用很简单：导入依赖、编写启动类、编写配置。</p><h4 id="Spring-Cloud-Gateway-配置示例"><a href="#Spring-Cloud-Gateway-配置示例" class="headerlink" title="Spring Cloud Gateway 配置示例"></a>Spring Cloud Gateway 配置示例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">gateway:</span></span><br><span class="line">            <span class="attr">routes:</span><span class="comment"># 路由规则列表</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">&lt;Route</span> <span class="string">ID&gt;</span> <span class="comment"># 独一无二的路由 ID</span></span><br><span class="line">                  <span class="attr">uri:</span> <span class="string">lb://&lt;service</span> <span class="string">name&gt;</span> <span class="comment"># load balance，到指定服务</span></span><br><span class="line">                  <span class="attr">predicates:</span><span class="comment"># 筛选断言条件（列表）</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">Path=/xx/**</span><span class="comment"># 支持通配符</span></span><br><span class="line">                  <span class="attr">filters:</span></span><br><span class="line">                  <span class="bullet">-</span> [<span class="string">...</span>]<span class="string">=[...]</span></span><br><span class="line">            <span class="attr">default-filters:</span></span><br><span class="line">                <span class="bullet">-</span> [<span class="string">...</span>]<span class="string">=[...]</span></span><br></pre></td></tr></table></figure><p>众所周知，<code>application.yaml</code> 中的配置内容相当于 XML Bean，都在向 Spring 框架的类型中填写初始化属性罢了。这里 <code>spring.cloud.gateway.routes</code> 对应的是 <code>Collection&lt;RouteDefinition&gt;</code> 类型。</p><p>其中，<code>predicates</code> 属性可取以下值：</p><div class="table-container"><table><thead><tr><th>Name</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>Host=**.somehost.org,**.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>Query=name, Jack 或者 Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td><td>Weight=group1, 2</td></tr><tr><td>X-Forwarded Remote Addr</td><td>基于请求的来源IP做判断</td><td>XForwardedRemoteAddr=192.168.1.1/24</td></tr></tbody></table></div><p><code>filters</code> 可取以下值：</p><div class="table-container"><table><thead><tr><th>Name</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td><td>AddrequestHeader=headerName,headerValue</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td><td>RemoveRequestHeader=headerName</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td><td>AddResponseHeader=headerName,headerValue</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td><td>RemoveResponseHeader=headerName</td></tr><tr><td>RewritePath</td><td>请求路径重写（ant path 语法）</td><td>RewritePath=/red/?(?\&lt;segment\</td><td>.*), /\\{segment}</td></tr><tr><td>StripPrefix</td><td>去除请求路径中的N段前缀</td><td>StripPrefix=1，则路径/a/b转发时只保留/b</td></tr><tr><td>……</td><td>……</td><td>……</td></tr></tbody></table></div><blockquote><p>一共有 33 种，详见官网。</p></blockquote><p>值得注意的是，filter 是基于 router 生效的、作用于 router 的。Spring Cloud 中的 filter 分为两种：</p><ul><li>GlobalFilter：全局过滤器，作用于所有路由，在声明该过滤器后无需激活即可生效；</li><li>GatewayFilter：路由过滤器，共 33 种，作用于指定路由，默认不生效。上面的在<strong><u>配置文件</u></strong>中写的 <code>filters</code> 就是这个过滤器！</li></ul><h4 id="Spring-Cloud-Gateway-过滤机制-以及-Spring-Security-对比"><a href="#Spring-Cloud-Gateway-过滤机制-以及-Spring-Security-对比" class="headerlink" title="Spring Cloud Gateway 过滤机制 以及 Spring Security 对比"></a>Spring Cloud Gateway 过滤机制 以及 Spring Security 对比</h4><p>这里只介绍了网关 forward 的配置，那么如果想对网关做更进一步的配置（例如身份验证），应该怎么操作？</p><p>首先需要了解 Spring Cloud Gateway 的底层机制。</p><p><img src='imgs/gateway-filters.png'></p><p>这里的思路几乎和 Spring Security 的过滤器链一模一样（责任链模式）。</p><p>因此我们想加入身份验证功能，就需要在 Filter 的 <code>PRE</code> 部分定义检查逻辑。如果符合条件，则允许通过 <code>NettyRoutingFilter</code> 进行转发；否则抛出异常立即拒绝请求。</p><p>现在做身份验证的思路就非常清楚了：自定义一个 Filter 类，最好像 Spring Security 的 <code>OncePerRequestFilter</code> 一样每次请求仅通过一次，插入到 <code>NettyRoutingFilter</code> 之前，就能完成任务。</p><p><strong><u>但是有几点和之前的微服务架构截然不同</u></strong>！！！</p><p>考虑第一点：网关如何向微服务传递当前登录用户的信息？</p><p>注意到现在网关、各个微服务都是独立的服务了，和单体架构不同，我们<strong>不能</strong>通过保存在类似于 <code>SecurityContext</code> 这样的单线程上下文（<code>ThreadLocal</code>）中，把网关中检查的用户信息传给 forward 的目标服务了。</p><p>回忆一下，网关向微服务 forward 实际上已经是一次新的 HTTP 请求了，而且我们之前在 Gateway 的 filters 参数中看到，gateway 可以配置额外添加请求头信息。因此不难想到，我们可以通过在网关的自定义 filter 中加入关于用户信息的请求头就能解决这个问题！</p><p>但再考虑第二个问题：既然网关和微服务间通过传递请求头来完成用户信息传递，那微服务之间相互调用也很频繁，它们默认还是原来的请求方式（<code>Nacos + OpenFeign</code>），没有请求头，难道要更改原来的代码，每个微服务请求 Client Proxy 时还要主动记录和传递用户信息？</p><p>是的！不过幸好 <code>OpenFeign</code> 有另一套方法帮我们加上这个请求头，所以不必担心。</p><p>下面我们来认识一下如何自定义 filter，并且完成身份认证的功能。</p><h4 id="自定义-Global-Filter"><a href="#自定义-Global-Filter" class="headerlink" title="自定义 Global Filter"></a>自定义 Global Filter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义 PRE 部分的 Gateway Global Filter </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 经过该 filter 时，过滤器链的请求上下文，包括 request、response、前面的 filter 写入的信息；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 过滤器链中下一条要执行的 filter</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 类似 JavaScript 中的回调函数。采用了 WebFlux 的非阻塞的、响应式接口，因为 PRE 和 POST 间时间可能很长，所以实际上 POST 部分 filter 是通过定义这个回调的行为来完成的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">    <span class="comment">/* 合理的做法是，和 Spring Security 类似，返回 chain.filter(exchange)，将 filter 链委托给下一级 */</span></span><br><span class="line">    <span class="comment">/* 如果想要阻止请求（例如未认证），那么请拿到 response，set response code，并且返回一个 response.setComplete() 标识请求已经回复（拒绝） */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要注意的是：</p><ul><li>global filter 需要继承于 <code>Ordered</code> 接口；</li><li>并且重写 <code>int getOrder()</code> 方法，这样能为 filter 安排插入顺序。注意：返回的整型越小优先级越高，并且 <code>NettyRoutingFilter</code> 的 order 是最大整型，因此任意一个不是 <code>INT_MAX</code> 的 order 都会让 filter 排在它的前面；</li><li>最后需要使用 <code>@Component</code> 纳入 Spring IoC Container 管理；</li><li>最后还要选一个配置类，使用 <code>@Bean</code> 提供一个 <code>GlobalFilter</code> 实例！！</li></ul><h4 id="自定义-Gateway-Filter"><a href="#自定义-Gateway-Filter" class="headerlink" title="自定义 Gateway Filter"></a>自定义 Gateway Filter</h4><p>这就是我们自定义写在 <code>filters</code> 配置文件中的 filter。本部分为进阶功能，一般使用不到。</p><p>我们需要继承于 <code>AbstractGatewayFilterFactory&lt;Object&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title class_">AbtractGatewayFilterFactory</span>&lt;Config&gt; &#123;</span><br><span class="line">    <span class="comment">/* config 类型请使用你想要的，例如 List 或者自定义类型 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;<span class="keyword">void</span>&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">/* same as Global Filter */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 定义传给 config 的数据类型 */</span></span><br><span class="line">    <span class="meta">@Data</span>    <span class="comment">// lombok</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String a;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        <span class="keyword">private</span> String c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 定义配置参数缩写名（类似设定命令行参数缩写） */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用构造函数告诉 AbstractGatewayFilterFactory config 的配置类型 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintAnyGatewayFilterFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>Config</code> 类型可以换成任何的自定义类型，以完成参数配置需求。如果不需要任何参数，直接使用 <code>Object</code> 类型，后面 3 个函数也就没有必要了。</p><p>这样前缀 <code>PrintAny</code>（去除 <code>GatewayFilterFactory</code>）就是配置名，我们就能自定义 filters 参数了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">gateway:</span></span><br><span class="line">            <span class="attr">routes:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">...</span></span><br><span class="line">                  <span class="attr">uri:</span> <span class="string">...</span></span><br><span class="line">               <span class="attr">predicates:</span> <span class="string">...</span></span><br><span class="line">               <span class="attr">filters: PrintAny:</span> <span class="string">&lt;config&gt;</span><span class="comment"># 需要和自己定义的 config 类型匹配</span></span><br></pre></td></tr></table></figure><p>此外，对于 <code>GatewayFilter</code> 如果想指定顺序，请使用 <code>OrderedGatewayFilter</code> 包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedGatewayFilter</span>(<span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Mono&lt;<span class="keyword">void</span>&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">            <span class="comment">/* same as Global Filter */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="comment">/* order */</span> <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，<code>GatewayFilter</code> 的定义使用了抽象工厂模式，满足了多样化定制需求。</p><h4 id="Spring-Cloud-Gateway-传递用户信息"><a href="#Spring-Cloud-Gateway-传递用户信息" class="headerlink" title="Spring Cloud Gateway 传递用户信息"></a>Spring Cloud Gateway 传递用户信息</h4><p>现在我们来解决之前提到的两个问题：</p><ul><li>网关如何向微服务传递当前登录用户的信息？</li><li>微服务之间相互调用如何使用 <code>OpenFeign</code> 传递用户信息？</li></ul><p>对第一个问题，我们采用如下思路：</p><p><img src="imgs/g2m.png"></p><p>这样我们微服务中的业务在本微服务内就沿用之前的 context 方案，无需更改，只需要修改进入微服务的拦截器即可；</p><p>先看如何更改 <code>GlobalFilter</code> 的请求内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ServerWebExchange.mutate() 方法可以返回已初始化的对象的 builder 以供修改 */</span></span><br><span class="line">exchange.mutate()</span><br><span class="line">    <span class="comment">/* 传递修改 request 的 build 方法 */</span></span><br><span class="line">    .request(builder -&gt; builder.head(<span class="string">&quot;info&quot;</span>, info))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>对于新建拦截器，我们不必在每个微服务中都写一遍，只需在共同依赖的模块中写入即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 识别信息并保存到 context，不作拦截 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 请求结束后，请销毁 context */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得把 Interceptor 配置到 Spring 中，在每次请求前进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="comment">/* 拦截器实例 */</span>);</span><br><span class="line">            <span class="comment">/* .addPathPattern() 可以选择作用的 path pattern，不写就是作用全部 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是还需要注意，这里的 Bean 现在没法被其他用到的模块扫描到，我们需要在这个模块的 <code>resources/META_INF/spring.factories</code> 中，配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">    &lt;package name&gt;.MvcConfig</span></span><br></pre></td></tr></table></figure><p>这样使得在该项目中， Spring 默认会将这个类加入 IoC Container。</p><blockquote><p>注意：在 Spring 3.x 以后，已经全面取消 <code>spring.factories</code> 中的 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 键的作用了。</p><p>在 Spring 3.x 的项目中，上面的配置是无效的，Spring 是不会扫描并且自动装配你指定的类的。</p><p>你需要在 <code>META-INT/spring/</code> 目录下新建一个文件 ``</p></blockquote><p>但是需要注意，这里采用的 <code>WebMvcConfigurer</code> 只能在微服务中生效，不能在 Gateway 中生效（因为 Gateway 是 <code>WebFlux</code> 非阻塞式接口，不能引入 Spring MVC 的接口），所以我们需要条件装配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 MvcConfig 前面的加入注解 */</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span>    <span class="comment">/* 该类是 Spring MVC 的核心 API */</span></span><br></pre></td></tr></table></figure><p>对于第二个问题，我们只需要对 <code>OpenFeign</code> 的请求进行定义：让每次 <code>OpenFeign</code> 触发微服务间调用时，都带上一个自定义的请求头，就像网关传给微服务一样。这里使用 <code>OpenFeign</code> 给的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这同样要定义在所有微服务中都依赖的模块中（因为是配置，所以用 bean 注入）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在某个配置 Feign 的类中 */</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">            <span class="comment">/* 配置请求头 */</span></span><br><span class="line">            template.header(&lt;header name str&gt;, &lt;context&gt; <span class="comment">/* 位于同线程，可用 */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个配置类需要显式配置给 <code>OpenFeign</code>（就像之前配置 Feign 日志的全局配置一样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(value = ..., defaultConfiguration = 该类名)</span></span><br></pre></td></tr></table></figure><h1 id="Chapter-2-微服务理论"><a href="#Chapter-2-微服务理论" class="headerlink" title="Chapter 2. 微服务理论"></a>Chapter 2. 微服务理论</h1><h2 id="2-1-微服务雪崩"><a href="#2-1-微服务雪崩" class="headerlink" title="2.1 微服务雪崩"></a>2.1 微服务雪崩</h2><p>在微服务相互调用中，服务提供者出现故障或阻塞。并且：</p><ul><li>服务调用者没有做好异常处理，导致自身故障；</li><li>或者访问连接一直保持 / 请求速度大于处理速率，致使请求不断堆积在 tomcat 中导致资源耗尽；</li></ul><p>最终，调用链中的所有服务级联失败，导致整个集群故障。</p><p><img src='imgs/avalanche.png' width="500px"></p><p>解决微服务雪崩的思路主要如下：</p><ol><li>尝试避免出现故障 / 阻塞；<ul><li>保证代码的健壮性；</li><li>保证网络畅通；</li><li>能应对较高的并发请求；</li><li><strong>微服务保护</strong>：保护服务提供方；</li></ul></li><li>局部出现故障 / 阻塞后，及时做好预备方案（积极有效的错误处理）；<ul><li><strong>微服务保护</strong>：保护服务调用方；</li></ul></li></ol><h2 id="2-2-微服务保护"><a href="#2-2-微服务保护" class="headerlink" title="2.2 微服务保护"></a>2.2 微服务保护</h2><p>为了应对微服务雪崩，我们有许多解决方案。其中，微服务保护是在业务逻辑代码层面以外的一种重要方案。</p><p>微服务保护有以下一些思路：</p><ul><li><p>请求限流：保护服务提供方。限制访问微服务的请求的并发量，避免服务因流量激增出现故障（<strong>应对访问模式：spike 型</strong>）；</p></li><li><p>线程隔离（舱壁模式）：保护服务消费方。通过限定每个业务能使用的线程数量而将故障业务隔离，避免故障扩散；</p><p><img src="imgs/thread-isolation.png" width="400px"></p></li><li><p>快速失败 和 服务熔断：</p><ul><li>快速失败：给业务编写一个调用失败时的处理的逻辑，称为 <code>fallback</code>。当调用出现故障（比如无线程可用）时，按照失败处理逻辑执行业务并返回，而不是直接抛出异常；</li><li>由<strong>断路器</strong>统计请求的异常比例或慢调用比例，如果超出阈值，则认为<strong>某个微服务业务所对应的所有实例都不可用</strong>，熔断该业务，则拦截该接口的请求。熔断期间，所有请求均 <code>fallback</code> 为快速失败逻辑；</li></ul><p><img src="imgs/fuse.png" width="400px"></p></li></ul><p>以上微服务保护的策略可以使用 <code>Sentinel</code> / <code>Hystrix</code> 框架完成。</p><div class="table-container"><table><thead><tr><th>Metrics or Feature</th><th><code>Sentinel</code></th><th><code>Hystrix</code></th></tr></thead><tbody><tr><td>Belong to</td><td>Spring Cloud Alibaba</td><td>Spring Cloud Netflix</td></tr><tr><td>Thread Isolation</td><td>信号量隔离</td><td>线程池隔离/信号量隔离</td></tr><tr><td>Fuse Policy</td><td>基于慢调用比例或异常比例</td><td>基于异常比率</td></tr><tr><td>Traffic Limiting</td><td>基于 QPS，支持流量整形</td><td>支持</td></tr><tr><td>Fallback</td><td>支持</td><td>支持</td></tr><tr><td>Configuration Method</td><td>基于控制台，重启后失效</td><td>基于注解或配置文件，永久生效</td></tr></tbody></table></div><p>想了解微服务保护框架具体如何使用，请参见官网样例或官方文档。</p><h2 id="2-3-微服务分布式事务"><a href="#2-3-微服务分布式事务" class="headerlink" title="2.3 微服务分布式事务"></a>2.3 微服务分布式事务</h2><blockquote><p>在分布式系统中，如果一个业务需要多个服务合作完成，而且每一个服务都有事务，多个事务必须同时成功或失败，这样的事务就是<strong><u>分布式事务</u></strong>。其中的每个服务的事务就是一个<strong>分支事务</strong>。整个业务称为<strong>全局事务</strong>。</p></blockquote><p>除了微服务雪崩的问题外，微服务设计中还存在一个重难点：如何保证微服务数据 ACID 的性质（如何正确进行分布式事务）。</p><p>以一个商品订单服务为例：</p><p><img src="imgs/inconsistency.png" width="600px"></p><p>如果最终库存服务失败，那么虽然订单服务可能可以识别到错误并且回滚，但是购物车服务与库存服务间没有关系，极有可能不会回滚，造成数据的不一致性。这就是没有保证分布式事务一致性。</p><p>那么我们应该如何保证微服务流程的一致性？</p><p>这个时候需要引入一个分布式事务的协调组件，让各个子事务（分支事务）感知到彼此的事务状态，根据总体的事务状态进行判断，协调全局事务的提交或回滚，这样就能保证事务状态和数据的一致性。</p><p>这个分布式事务的协调组件被称为：<strong>事务协调者（Transaction Coordinator，TC）</strong>；</p><p>除了事务协调者，还需要有一个组件，用于定义单个全局事务的范围（从哪个子事务开始，到哪个子事务结束）。这个组件就被称为：<strong>事务管理器（Transaction Manager，TM）</strong>；</p><p>有了 TC 和 TM，就能准确地定义一个全局事务； </p><p>为了进一步从业务逻辑中解耦，我们额外增添一个组件用于说明某个子事务的事务状态。它的作用是，向 TC 注册子事务，并且报告子事务的事务状态。这就被称为：<strong>资源管理器（Resource Manager，RM</strong>）；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-0-基本概念&quot;&gt;&lt;a href=&quot;#Chapter-0-基本概念&quot; class=&quot;headerlink&quot; title=&quot;Chapter 0. 基本概念&quot;&gt;&lt;/a&gt;Chapter 0. 基本概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;微服务是一种软件架构风格。专</summary>
      
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Web" scheme="https://sjtuxhw.top/tags/Web/"/>
    
    <category term="Microservice" scheme="https://sjtuxhw.top/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore, Mutex, CV</title>
    <link href="https://sjtuxhw.top/2024/05/11/Semaphore-Mutex-CV/"/>
    <id>https://sjtuxhw.top/2024/05/11/Semaphore-Mutex-CV/</id>
    <published>2024-05-11T15:20:35.000Z</published>
    <updated>2024-05-31T15:28:40.658Z</updated>
    
    <content type="html"><![CDATA[<p>学习 ICS 的并行一章之后，笔者有些疑惑，semaphore（信号量）、mutex（互斥锁）、conditional variables（条件变量）这 3 者之间究竟该怎么区分它们的使用场景？</p><p>首先我们需要去阐述清楚它们各自的定义和效果。</p><p>学术界认为 mutex 是 semaphore 的特例，因此像著名的书籍 CSAPP 就先以 semaphore 为例讲了讲并发程序的资源控制问题。但是实际上有相当一部分实践派和语义派认为二者不应该混为一谈。像 Linus 本人在一次将 Linux 内核的一部分 semaphore 重构为 mutex 后，发现不仅改善了代码语义，还在一定程度上提升了性能。这件事也说明了，虽然在理论上一方可以替代另一方，但实践上它们各有所长。</p><h2 id="Semaphore-vs-Mutex"><a href="#Semaphore-vs-Mutex" class="headerlink" title="Semaphore vs Mutex"></a>Semaphore vs Mutex</h2><p>我们先讨论 semaphore。</p><p>CSAPP 中先从 “线程间变量共享” 的情况说起，它指出，程序对内存的更改并不直接在内存上完成，在汇编中可以看到，大致经历了 load（从内存到 CPU 寄存器）、update（在 CPU 寄存器内更新数据）、store（将 CPU 寄存器数据写回内存）这 3 步。</p><p>而根据程序的局部性原理、context switch 的随机性，出现脏读、不可重复读的情况几乎是必然的。这样的话两个线程甚至无法完成简单的累加计算。</p><p>为了解决这个问题，CSAPP 引入了 semaphore，这种做法就等价于建立了一个资源临界区，而 semaphore 的初始值则限制了 <u>能同时访问在 semaphore 保护下的代码 并发执行的线程数量</u>。</p><p>semaphore 中有一个特殊情况，也就是初值为 1 的情况，只允许一个线程并发执行受保护的代码。这种特殊的信号量就被称为 Binary Semaphore。</p><p>现在看 Mutex（互斥锁），我们发现，互斥锁的作用实际上要说明<u>任何线程对 mutex 包含的资源的访问都是互斥的（同一时间仅能有一个线程访问）</u>。</p><p>但是有人说，这不就是 binary semaphore 的定义吗！</p><p>实际上，Binary Semaphore 和  <strong>互斥锁</strong>（<code>mutex</code>）有些微妙的区别。</p><p>Mutex 相比 binary semaphore 增加了<strong>所有权的概念</strong>，<u>一只锁住的 Mutex 只能由给它上锁的线程解开</u>，只有系铃人才能解铃。Mutex 的功能也就因而限制在了构造 unsafe region 的 “围墙” 上。</p><p>Binary semaphore 则可以由任一线程解开。比如某进程读取磁盘并进入睡眠，等待中断读取盘块结束之后来唤醒它，而这种情况 Mutex 是解决不了的。</p><p>这是因为 semaphore 的语义有两个功能：<strong>保护资源 + 通知</strong>。除了限制资源并发数量，semaphore 的释放还能通知等待 semaphore 的线程。</p><p>Mutex 相较 semaphore 的优势在于，Mutex 职责更单一，语义更清晰，实现的效率稍微高一点。</p><h2 id="Semaphore-vs-Conditional-Variable"><a href="#Semaphore-vs-Conditional-Variable" class="headerlink" title="Semaphore vs Conditional Variable"></a>Semaphore vs Conditional Variable</h2><p>你可能会想，semaphore 有通知的语义，那条件变量不也有吗？它们俩又有什么区别呢？</p><p>实际上，你可以把条件变量理解成一个抽象层级更高的机制。</p><p>条件变量实际上是一种<strong>等待队列</strong>，<strong>提供了 “唤醒”（wake）和 “阻塞等待”（blocking-wait）两类操作</strong>，也就是入队时等待、出队时唤醒。不过这个出队条件由条件决定，唤醒和阻塞的机制交由 OS 的系统调用完成。</p><p>它们俩的共同点是，semaphore 和 CV 底层都可以用 Mutex（互斥锁在这里就是低层级同步原语，low-level synchronizing primitive）实现，它们共同的使用场景是<strong>对共享资源访问的同步机制（通知）</strong>。</p><p>然后我们再以使用场景来说明它们的不同点。</p><p>条件变量常常被用于避免资源的 Busy Waiting，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (!queue.empty()) &#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">/* do something */</span><br></pre></td></tr></table></figure><p>这种行为会浪费大量的处理器资源。那么为什么不能有个变量让线程等待在上面，直到 available 后自动提醒这个线程继续运行？</p><p>条件变量的作用就在这里。它可以<u>同步多个线程对于某个条件的判断，当该条件触发时（通常是另一个线程对这个条件变量执行了操作），会随机/全部唤醒正在等待条件的线程</u>。可以说条件变量是有条件的提醒机制。</p><blockquote><p>举个例子，比如并行计算中的 checkpoints 要求线程池中，之前一阶段分配过任务的所有线程都完成计算后，才进行下一阶段的计算任务。这就是多线程的条件，这个场合就适合使用条件变量。</p></blockquote><p>semaphore 虽然也有提醒的意思，但它的语义重点不在条件上，它的重点在于 “<strong>根据某个整数（常常是共享资源的数量）来限制和提醒某个共享资源是否可用</strong>”。</p><p>而这层含义就天然的让 semaphore 比 mutex 和 CV <strong>在语义上更适合解决生产者消费者模型（Consumer / Producer Model）有关的问题</strong>。</p><blockquote><p>因为它们在某些情况下都能解决这个问题，但是语义上有优劣之分。</p></blockquote><p>大家不妨再回想一下 读者/写者模型，在 CSAPP 书中是使用 semaphore 完成的，但是实际上这个模型在语义上更适合 Conditional Variables 完成。因为这需要资源有条件的提醒机制。使用 semaphore 虽然实现上更简单，但是破坏了一部分的语义，也可能出现额外的 “虚假唤醒” 的问题。</p><blockquote><ul><li><p>例如为什么一定要记录当前读者数、等待的写者数、写者数？我不关心呢？是不是增加了冗余复杂度？</p></li><li><p>semaphore 没有显式地提醒某一类等待的线程，而是通过可用数量的方式<strong>间接</strong>展示了资源的可用性。</p><p>这并不准确，在多核、很多线程等待的情况下可能<u>无法像 CV 一样，能控制同时唤醒多个线程，还是只唤醒一个等待的线程</u>。</p></li></ul></blockquote><p>相信在上面的分析中大家以已经看到了，conditional variable 和 semaphore 在实现上能相互替代，只不过有语义和实现复杂度的 trade off 罢了，它们的使用场景也存在重叠的情况。</p><h2 id="Application-Parallel-MST-Algorithm"><a href="#Application-Parallel-MST-Algorithm" class="headerlink" title="Application: Parallel MST Algorithm"></a>Application: Parallel MST Algorithm</h2><p>其中一个比较有名的多线程同步的应用场景是，<strong>并行最小生成树的计算</strong>。由于计算最小生成树是很多算法依赖的基本算法，因此优化这个算法曾是学界比较热门的话题。</p><p>以并行的 Kruskal 算法（基于最小边的贪婪算法）为例，其主体思想与非并行化的 Kruskal 算法大致相同。</p><p>通过对图的划分，将原图分为若干不相交的分区，交由不同的进程或线程计算最小边权，从而达到加速计算的效果。</p><p>整个算法分为由各并行线程完成的 “部分算法” 与由一个主线程完成的 “仲裁算法”。</p><p>在“部分算法”中，当各进程<strong>收到来自全局进程的计算通知</strong>后，选出本分区当中具有最小权重的边并发送给全局进程，并且等待，直到本分区没有待处理的边或收到全局进程的结束通知时结束进程。</p><p>在 “仲裁算法” 中：</p><ol><li>全局进程首先向所有并行进程发送消息获取各分区最小权重边构成队列 $Q_i$；</li><li>接下来循环取出 $Q_i$ 中权值最小的边 $e_j=\min\limits_{i}{e_i}$，并向提供边 $e$ 的进程 $j=\text{argmin }e_i$ 发送消息请求补充新的最小权重边至 $Q_j$ 中；</li><li>如果取出的边 $e_j$ 加入到结果集 $T$ 中不会构成环路则保留此边，若会构成环路则将其丢弃。</li><li>当 $T$ 中的边的数量为 $|V|-1$ 或队列 $Q_i$ 均为空时算法结束，同时通知各进程结束算法。</li></ol><p>这里我们发现有多次的信息的通知语义，而且是针对特定线程。因此这里没法采用 semaphore 和 mutex，采取条件变量控制是较为合适的。</p><h2 id="Extra-Recursive-Mutex-amp-Lock-in-C"><a href="#Extra-Recursive-Mutex-amp-Lock-in-C" class="headerlink" title="Extra: Recursive Mutex &amp; Lock in C++"></a>Extra: Recursive Mutex &amp; Lock in C++</h2><p>C++ STL 库中存在的 Recursive Mutex 就是一个进程加了几次锁，就要释放几次锁，才能解除对资源的锁定。这一般用在一些特殊的业务逻辑场景中。</p><p>Lock 是利用面向对象的方法对 Mutex 进行了包装。在 Lock 的构造函数中加锁、析构函数中解锁，起到在 Lock 生命周期作用域内保护资源的作用，减轻了编码人员的编码负担。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习 ICS 的并行一章之后，笔者有些疑惑，semaphore（信号量）、mutex（互斥锁）、conditional variables（条件变量）这 3 者之间究竟该怎么区分它们的使用场景？&lt;/p&gt;
&lt;p&gt;首先我们需要去阐述清楚它们各自的定义和效果。&lt;/p&gt;
&lt;p&gt;学术</summary>
      
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="GNU" scheme="https://sjtuxhw.top/tags/GNU/"/>
    
    <category term="CSAPP" scheme="https://sjtuxhw.top/tags/CSAPP/"/>
    
    <category term="ICS" scheme="https://sjtuxhw.top/tags/ICS/"/>
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Java Spring Boot 入门</title>
    <link href="https://sjtuxhw.top/2024/05/06/Java-Spring-Boot-%E5%85%A5%E9%97%A8/"/>
    <id>https://sjtuxhw.top/2024/05/06/Java-Spring-Boot-%E5%85%A5%E9%97%A8/</id>
    <published>2024-05-06T11:12:30.000Z</published>
    <updated>2024-05-16T11:35:11.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前置条件：WEB 基础（Socket，HTTP 整套规范），SQL 和数据库基础，Java 语言基础、前端基础（至少了解一种前端框架，本文以 React 为例）；</p></blockquote><h1 id="Chapter-0-Basic-Concepts"><a href="#Chapter-0-Basic-Concepts" class="headerlink" title="Chapter 0. Basic Concepts"></a>Chapter 0. Basic Concepts</h1><h2 id="0-1-Servlet-war-amp-jar"><a href="#0-1-Servlet-war-amp-jar" class="headerlink" title="0.1 Servlet, war &amp; jar"></a>0.1 Servlet, <code>war</code> &amp; <code>jar</code></h2><p>在接触 Web 框架时，你肯定能碰到一个绕不开的词：Servlet。它是什么？</p><p>Servlet 本质上就是一种规范，在 Java 的实现中就是一个 Web 规范接口。</p><p>所以，为什么要有这个规范？让我们回到最初的起点。</p><hr><p>假设你什么框架都不用，想要徒手写一个能提供服务的服务器，那需要做哪些工作？</p><p>其实原理比较简单，遵循当今互联网的 HTTP 协议发报文就行：</p><ul><li>先编写基于多线程的 TCP 服务（Web 3.0 准备改用 UDP 了）；</li><li>然后在一个 TCP 连接中读取 HTTP 请求，发送 HTTP 响应即可；</li></ul><p>但是其中还要考虑一些与网络协议相关、与业务逻辑无关的其他情况：</p><ul><li>识别正确和错误的 HTTP 请求；</li><li>识别正确和错误的 HTTP 头；</li><li>复用 TCP 连接；</li><li>复用线程；</li><li>IO 异常处理；</li><li>…</li></ul><p>说到这里头都大了🥹 这些 “基础工作” 需要耗费大量的时间，并且经过长期测试才能稳定运行。如果我们只需要输出一个简单的 HTML 页面，就不得不编写上千行底层代码，那就根本无法做到高效而可靠地开发！</p><p>人们为了简化这一过程，抽象出了一个中间层：Web Server。</p><p>这些共性的、与业务逻辑无关的东西，我们统统交给现成的轮子（web server）去做，我们只需要在 web server 上写自己的应用，与 web server 做沟通就行。</p><p>进一步地，人们为了统一 “应用程序与 Web Server” 的交互接口，进一步实现功能解耦（即如果换了另一个人写的 web server，上层的应用程序根本不需要变），在 Java 中就定义了一个 Web Server 的接口，称为 Servlet。</p><p>上层应用程序可以通过继承于这个接口创建一个适用于自己程序的、处理 Web Server 发来的信息的类，以便把信息传入自己的业务逻辑中。其关系如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                 ┌───────────┐</span><br><span class="line">                 │My Servlet │</span><br><span class="line">                 ├───────────┤</span><br><span class="line">                 │Servlet API│</span><br><span class="line">┌───────┐  HTTP  ├───────────┤</span><br><span class="line">│Browser│&lt;──────&gt;│Web Server │</span><br><span class="line">└───────┘        └───────────┘</span><br></pre></td></tr></table></figure><p>这里的 Web Server 又被称为 Servlet Container，它的作用就是，解析 client / browser 发起的 request，并组装出 HTTP Request、创建 HTTP Response，将二者交于内部自定义的 Servlet（My Servlet）处理和填充。</p><blockquote><p>像 Tomcat、Jetty、GlassFish 就是一些常见的 Web Server。</p></blockquote><p>现在还有一个问题没解决。如果由 Web Server 来帮助我们完成，那么我们写应用程序时，需要和 Web Server 一起编译打包吗？答案是不需要。</p><p>在 Java 中，我们需要将自己写的 Servlet 以及其他业务逻辑的程序打包成一个 <code>*.war</code> 的文件（和 <code>*.jar</code> 不一样，不能直接运行），然后必须由含有 Servlet API 的 Web Server 动态加载进去执行，所以 Web Server 又叫 Servlet Container。</p><p>那么具体自己如何编写 Servlet 呢？以 <code>javax.Servlet</code> 类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 初始化 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">    <span class="comment">/* 2. 获取配置 */</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/* 3. 发出服务 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line">    <span class="comment">/* 4. 获得信息 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/* 5. 销毁 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从原理上讲，Servlet 可以处理<strong>任何类型</strong>的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web Server。</p><h2 id="0-2-Spring-Spring-MVC-Spring-Boot"><a href="#0-2-Spring-Spring-MVC-Spring-Boot" class="headerlink" title="0.2 Spring, Spring MVC, Spring Boot"></a>0.2 Spring, Spring MVC, Spring Boot</h2><p>除了 Servlet，我们还要弄清楚 Spring 框架以及其中的各种常用术语。Spring MVC、Spring、Spring Boot 有什么关系？</p><p>首先尝试理解一下 Spring 框架。</p><blockquote><p>以下部分内容引用自 <a href="https://blog.csdn.net/codeSmart/article/details/106836336">CSDN Blog - 狂野弘仁</a>；</p></blockquote><p>Spring，一般指代的是 Spring Framework，<strong>它是一个开源的应用程序框架</strong>，提供了一个简易的开发方式，通过这种开发方式，将避免那些可能致使代码变得繁杂混乱的大量的业务/工具对象（由框架来帮你管理这些对象，包括它的创建，销毁等）。</p><p>Spring Framework 最重要也是最核心的特性是依赖注入。所有的 <strong>Spring 模块的核心就是 DI（依赖注入）或者 IoC（控制反转）</strong>。依赖注入或控制反转是 Spring Framework 最大的特性，当我们正确使用这二者时，可以开发出一个高内聚低耦合的应用程序，而这一一个低耦合的应用程序可以轻松的对其实施单元测试。这就是 Spring Framework 解决的最核心的问题。</p><blockquote><p>什么是控制反转？</p><p>是一种软件设计思想，也是 Spring 框架的核心概念之一。</p><p>假设类 <code>A</code> 需要类 <code>B</code> 作为组成部分，那么在传统设计理念下，类 <code>A</code> 初始化时，需要顺便创建 <code>B</code> 的对象，并且要在 <code>B</code> 的全部生命周期内维护它。这样做法虽然正确，但是有几个缺点：</p><ol><li>类型紧耦合。如果想要更换 <code>B</code>，那么需要找到类 <code>A</code> 中所有用到 <code>B</code> 的地方全部去改；</li><li>全盘管理外部对象，加重编写负担，模糊业务逻辑，使维护难以进行。</li></ol><p>于是，人们想出一种方法，将数据对象封装成一个 Java Bean，把这个 Bean 交给一个容器管理（被称为 IoC Container，在 Spring 中由框架代码帮忙完成），要用到它的时候写注解自动注入，提升了组件的重用性，实现组件解耦。</p><p>以 Spring 的两个注解为例：</p><p><code>@Component</code>: 该注解将会告诉 Spring Framework，被此注解标注的类需要纳入到 Bean 管理器（IoC Container）中。<br><code>@Autowired</code>: 告诉 Spring Framework 需要找到一与其类型匹配的对象，并将其自动引入到所需要的类中。</p><p>什么是依赖注入？</p><p>可以这么理解：它们是同一个概念的不同角度描述。通俗来说就是 <strong>IoC是设计思想，DI是实现方式</strong>。二者的终极作用是<u>去除 Java 类之间的依赖关系，实现松耦合</u>，以便于开发测试。例如对于这个类型设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;  </span><br><span class="line"> <span class="keyword">private</span> Weapon weapon;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">// weapon 注入</span></span><br><span class="line"> Player(Weapon weapon)&#123;  </span><br><span class="line">     <span class="built_in">this</span>.weapon = weapon;</span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">     weapon.attack();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeapon</span><span class="params">(Weapon weapon)</span>&#123;  </span><br><span class="line">     <span class="built_in">this</span>.weapon = weapon;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Spring Bean 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;player&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.demo.Player&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">construct-arg</span> <span class="attr">ref</span>=<span class="string">&quot;weapon&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;weapon&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.demo.Gun&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们对于 Weapon 的实例构造并不在 <code>Player</code> 内，而是放在配置文件中，依靠<strong>多态</strong>（<code>Gun</code> 继承于 <code>Weapon</code>）和<strong>反射</strong>（读配置、构造对象，外部设置类的行为）实现依赖注入，让两个业务类解耦合。</p><p>或者说，在依赖解耦合方面，<u>控制反转是设计思想，依赖注入是一个设计模式，配置文件只是形式，反射和多态是底层实施手段</u>。</p></blockquote><p>而 Spring Framework 的其他高级特性，例如：Spring AOP、Spring JDBC、Spring MVC、Spring ORM、Spring Test，它们<u>都不是一个全新的功能</u>。因为在不使用 Spring Framework 的情况下，我们依然能够使用 JDBC 连接数据库、依然能够对视图和数据模型进行控制、依然能够使用第三方的 ORM 框架。</p><p>Spring Framework 只是<u>对这些功能中的逻辑采用上述思想进行解耦合，以及进一步封装</u>。例如 Spring JDBC 与传统的 JDBC 相比，使用 JDBC Template 操作数据库，首先是代码量小了，其次是我们不需要再面对恐怖的 try-catch；</p><blockquote><p>如果你还使用过 C++ 配合 MySQL 原生驱动的组合的话，就完全明白这句话的分量……</p></blockquote><p>再比如 Spring Framework 的 MVC，提供了构建 Web 应用程序的全功能 MVC 模块，实现了 Web MVC 设计模式以及请求驱动类型的轻量级 Web 框架，即采用了 MVC 架构模式的思想，将 Web 层进行职责解耦。基于请求驱动指的是使用请求-响应模型，视图与数据模型分离：</p><ul><li>Dispatcher Servlet；</li><li>ModelAndView；</li><li>ViewResolver；</li></ul><p>这个功能模块是人们利用 Spring 解耦的组件进行进一步整合而得出的。</p><p>而 Spring Boot 就像整合了常用配置的“懒人包”，实现多种自动配置：</p><ul><li><p>如果Hibernate的依赖被放到了类路径上，Spring Boot会自动配置数据源；</p></li><li><p>如果Spring MVC的依赖被放到了类路径上，Spring Boot又会自动配置Dispatcher Servlet；</p></li><li><p>当Spring Boot检测到有新的依赖包添加到类路径上，Spring Boot会采用默认的配置对新的依赖包进行设置，如果我们想自己配置依赖包时，只需要手动覆盖默认的配置项即可；</p></li><li><p>Spring Boot 已经内置了多个 Web server，如 Undertow, jetty, tomcat，因此我们不需要再额外的配置服务器（比如前一节提到的打包为 <code>war</code>，然后部署），就可以完成应用程序的调试工作；</p></li></ul><p>所以，严格意义上讲，Spring Boot 并不是某种框架，它只是为开发人员提供了一个更好的更方便的使用 Spring Framework 的解决方案（相当于人家把环境都自动化配好了）。</p><p><img src="imgs/spring-frame.png"></p><h2 id="0-3-RESTful-API"><a href="#0-3-RESTful-API" class="headerlink" title="0.3 RESTful API"></a>0.3 RESTful API</h2><p>在开始前，还要了解一个概念，什么是 RESTful API（你们互联网事真多😅）。</p><p>在互联网并没有完全流行的初期，移动端也没有那么盛行，页面请求和并发量也不高，那时候人们对网络的接口的要求没那么高。只是写一些静态页面、偶尔用用一些动态页面（jsp，整个页面同时刷新）、然后按照 HTTP 等规范手动 DIY 发一发报文，就能满足绝大多数的使用需求。</p><p>但是随着互联网和移动设备的发展，人们对 Web 应用的使用需求也增加，传统的动态页面由于低效率而渐渐被 HTML + JavaScript (Ajax) 的前后端分离所取代，并且安卓、IOS、小程序等形式客户端层出不穷，客户端的种类出现多元化，<strong>而客户端和服务端就需要接口进行通信</strong>，但接口的<strong>规范性</strong>就又成了一个问题。</p><p>假设服务供应方 <code>A</code> 做了一套通信接口，另一个服务供应方 <code>B</code> 又搓了一套通信接口，那么我想同时用这两家服务，难不成还要应用开发者写两套访问逻辑？太不优雅了！</p><p>所以一套<strong>结构清晰、符合标准、易于理解、扩展方便</strong>让大部分人都能够理解接受的<u>接口风格</u>（或者说共同约定）就显得越来越重要。</p><p>2000 年的时候，有个人在他的博士论文中提出了一套软件架构的设计风格（不是标准，只是一组设计原则、共同约定），它主要用于客户端（或浏览器）和服务器交互类的软件。这个人就是 Roy Thomas Fielding。</p><p>基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>这个设计风格也被他命名为 “表述性状态转移”（Representational State Transfer，REST）的架构风格。满足这个架构风格的接口设计就被称为 RESTful API。</p><p>那么这个风格的特征是什么？或者说它的 “共同约定” 是什么？</p><p>REST 架构的 6 个限制条件，又称为 RESTful 6 大原则：</p><ul><li><p><strong>客户端-服务端分离</strong>（解耦）；</p></li><li><p><strong>无状态的（Stateless）</strong>：服务端不保存客户端状态，客户端保存状态信息每次请求携带状态信息；</p></li><li><p><strong>可缓存性（Cacheability）</strong> ：服务端需回复是否可以缓存以让客户端甄别是否缓存提高效率;</p></li><li><p><strong>统一接口（Uniform Interface）</strong>：通过一定原则设计接口降低耦合，简化系统架构，这是RESTful设计的基本出发点；</p><blockquote><p>这组接口就是针对资源的操作，包括获取、创建、修改、删除。</p><p>恰好对应了 HTTP 协议提供的 GET、POST、PUT 和 DELETE 方法。</p><p>注意，REST 原则强烈不建议接口动作与资源访问标识符混合使用。</p><p>REST 认为，<strong>URI指向资源</strong>、以资源为基础，应该以名词标识，真正的动作应该从 HTTP 的请求动作上识别。</p><p>注 1：Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。URI 包括 URL（Locator）和 URN（Navigator）；</p><p>注 2：一个资源可以是文本（通常以 JSON / HTML / XML 为载体）、二进制流等其他任何数据（一般从数据库中拿到的）；</p></blockquote></li><li><p><strong>分层系统（Layered System）</strong>：客户端对服务端的情况无感，无法直接知道连接的到终端还是中间设备，分层允许灵活地部署服务端项目；</p></li><li><strong>按需代码（Code-On-Demand，可选）</strong>：允许我们灵活的发送一些看似特殊的代码给客户端例如 JavaScript 代码。</li></ul><blockquote><p>当然，RESTful API 也是有缺陷的，例如过于重视资源的作用，导致一些与资源关系不大的场合（例如聊天服务器、通信服务器）如果使用 RESTful Web Service 则反而加重了开发负担。</p></blockquote><h3 id="补充：RESTful-API-设计规范"><a href="#补充：RESTful-API-设计规范" class="headerlink" title="补充：RESTful API 设计规范"></a>补充：RESTful API 设计规范</h3><blockquote><p>本部分摘自 <a href="https://zhuanlan.zhihu.com/p/334809573">知乎专栏</a>；</p></blockquote><p>如果想要自己设计一个 RESTful API（而不是使用各大框架中的办法），那么就要遵循以上的约定。具体来说：</p><p>URL 的 path 是需要认真考虑的，而 RESTful 对 path 的设计做了一些规范，通常一个 RESTful API 的 path 组成如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>version</code>：API 版本号，有些版本号放置在头信息中也可以，通过控制版本号有利于应用迭代；<br><code>resources</code>：资源，RESTful API 推荐用小写英文单词的复数形式；<br><code>resource_id</code>：资源的id，访问或操作该资源；</p></blockquote><p>当然，有时候可能资源级别较大，其下还可细分很多子资源也可以灵活设计 URL 的 path，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/&#123;subresources&#125;/&#123;subresource_id&#125;</span><br></pre></td></tr></table></figure><p>此外，有时可能增删改查无法满足业务要求，可以在 URL 末尾加上 action，例如</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/action</span><br></pre></td></tr></table></figure><p>其中 action 就是对资源的操作。</p><p>从大体样式了解 URL 路径组成之后，对于 RESTful API 的 URL 具体设计的规范如下：</p><ol><li>不用大写字母，所有单词使用英文且小写；</li><li>连字符用中杠 <code>&quot;-&quot;</code> 而不用下杠 <code>&quot;_&quot;</code>；</li><li>正确使用 <code>&quot;/&quot;</code> 表示层级关系,URL的层级不要过深，并且越靠前的层级应该相对越稳定；</li><li>结尾不要包含正斜杠分隔符 <code>&quot;/&quot;</code>；</li><li>URL中不出现动词，用请求方式表示动作；</li><li>资源表示用复数不要用单数；</li><li>不要使用文件扩展名；</li></ol><p>此外，在 RESTful API 中，不同的HTTP请求方法有各自的含义，这里就展示 GET,POST,PUT,DELETE 几种请求 API 的设计与含义分析。针对不同操作，具体的含义如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /collection： 从服务器查询资源的列表（数组）</span><br><span class="line">GET /collection/resource： 从服务器查询单个资源</span><br><span class="line">POST /collection： 在服务器创建新的资源</span><br><span class="line">PUT /collection/resource： 更新服务器资源</span><br><span class="line">DELETE /collection/resource： 从服务器删除资源</span><br></pre></td></tr></table></figure><p>在非 RESTful 风格的 API 中，我们通常使用 GET 请求和 POST 请求完成增删改查以及其他操作，查询和删除一般使用 GET 方式请求，更新和插入一般使用 POST 请求。从请求方式上无法知道 API 具体是干嘛的，所有在 URL 上都会有操作的动词来表示 API 进行的动作，例如：query，add，update，delete 等等。</p><p>而 RESTful 风格的 API 则要求在 URL 上都以名词的方式出现，从几种请求方式上就可以看出想要进行的操作，这点与非 RESTful 风格的 API 形成鲜明对比。</p><p>在谈及 GET,POST,PUT,DELETE 的时候，就必须提一下接口的<strong>安全性和幂等性</strong>，其中安全性是指方法不会修改资源状态，即读的为安全的，写的操作为非安全的。而幂等性的意思是操作一次和操作多次的最终效果相同，客户端重复调用也只返回同一个结果。</p><div class="table-container"><table><thead><tr><th>HTTP Method</th><th>安全性</th><th>幂等性</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>安全</td><td>幂等</td><td>读操作（安全），查询多次结果一致</td></tr><tr><td>POST</td><td>非安全</td><td>非幂等</td><td>写操作（非安全），每次插入后与上次的结果不一样</td></tr><tr><td>PUT</td><td>非安全</td><td>幂等</td><td>写操作（非安全），插入相同数据多次结果一致</td></tr><tr><td>DELETE</td><td>非安全</td><td>幂等</td><td>写操作（非安全），删除相同数据多次结果一致</td></tr></tbody></table></div><h3 id="Tips-调试数据请求时的类型选择"><a href="#Tips-调试数据请求时的类型选择" class="headerlink" title="Tips. 调试数据请求时的类型选择"></a>Tips. 调试数据请求时的类型选择</h3><p>在使用类似 Postman 的工具发送请求时，可能会遇到不同种类可选的数据类型：</p><ul><li><strong>form-data</strong>： 就是 form 表单中的 multipart/form-data，会将表单数据处理为一条信息，用特定标签符将一条条信息分割开，而这个文件类型通常用来上传二进制文件；</li><li><strong>x-www-form-urlencoded</strong>：就是application/x-www-form-urlencoded，是 form 表单默认的 encType，form 表单会将表单内的数据转换为键值对，这种格式不能上传文件；</li><li><strong>raw</strong>：可以上传任意格式的文本，可以上传 Text，JSON，XML 等，但目前大部分还是上传 JSON 格式数据。当后端需要接收 JSON 格式数据处理的时候，可以采用这种格式来测试。</li></ul><blockquote><p>这部分概念太多了，有些概念用到再说。</p></blockquote><h1 id="Chapter-1-Introduction-to-Spring-Boot"><a href="#Chapter-1-Introduction-to-Spring-Boot" class="headerlink" title="Chapter 1. Introduction to Spring Boot"></a>Chapter 1. Introduction to Spring Boot</h1><h2 id="1-1-First-Spring-Boot-Project-A-RESTful-Web-Service"><a href="#1-1-First-Spring-Boot-Project-A-RESTful-Web-Service" class="headerlink" title="1.1 First Spring Boot Project: A RESTful Web Service"></a>1.1 First Spring Boot Project: A RESTful Web Service</h2><p>在进入枯燥的概念和接口学习前，先用简单的方法构建一个简单的 RESTful Web Service 出来。</p><p>首先使用 gradle 构建管理工具创建一个项目，引入依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;3.2.4&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="string">&#x27;1.1.4&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包位置 priv.demo */</span></span><br><span class="line">group = <span class="string">&#x27;priv.demo&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">java &#123;                                                                                   sourceCompatibility = <span class="string">&#x27;21&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;                                                                           mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;                                                                           implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">   testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">tasks.named(<span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个 Java 记录类型作为存放数据的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Greeting</span><span class="params">(<span class="type">long</span> id, String content)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>创建一个资源控制器（相当于 Servlet 的处理逻辑）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">template</span> <span class="operator">=</span> <span class="string">&quot;Hello, %s!&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/greeting&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Greeting <span class="title function_">greeting</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>(counter.incrementAndGet(), String.format(template, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下 <code>@GetMapping(&lt;path&gt;)</code>：保证所以筛选到 <code>&lt;path&gt;</code> 路径的 GET 请求被框架统一转发给被修饰的方法（这里是 <code>greeting</code>）。</p><p>其中，如果要处理 HTTP 尾缀参数，那么被 <code>@GetMapping</code> 修饰的方法强烈建议使用 <code>@RequestParam(&lt;value&gt;, &lt;defaultValue&gt;)</code> 修饰参数，这样能清楚地知道处理参数的情况。</p><p>例如上面的例子中，Servlet 能识别 <code>GET /greeting</code> 的请求，并且调用后端程序的 <code>greeting</code> 方法。返回的 record 对象会被框架自动解析并以 JSON 形式响应客户端（浏览器）。</p><p>由于方法中写了 <code>@RequestParam</code>，因此可以接受任何 <code>/greeting?name=&lt;...&gt;</code> 的后缀参数信息。</p><blockquote><p>除了这里的 <code>@GetMapping</code>，还有 <code>@PostMapping</code>（对应 POST 请求）等等。</p><p>此外，<code>@RequestMapping(method=GET)</code> 等价于 <code>@GetMapping</code>，相当于是其他各种 Mapping 的综合体。</p></blockquote><p>另外，我们使用了 <code>AtomicLong</code> 类型，保证多线程情况下的安全性。<code>counter</code> 为当前运行时请求编号；</p><p>最后，还需要说明，这个类只有使用 <code>@RestController</code> 注解才能发挥作用。</p><p>它的作用是标识这个类作为一个 RESTful API 的资源接收和控制器，并且<u>其中的每个方法都会返回 domain object，而不是一个 view（视图，传统 MVC Controller 都会返回视图）</u>。这个注解等价于 <code>@Controller</code> 和 <code>@ResponseBody</code>（表示这里生成的是 HTTP 响应体）联合使用。</p><p>实际上，使用 <code>@RestController</code> 修饰的类中每个方法返回的 domain object 应该被转为 JSON（就是这里的 Greeting 对象应该转为 JSON）。但是因为有一个库 <code>Jackson 2</code> 的存在，Spring 会自动选择 <code>MappingJackson2HttpMessageConverter</code> 来将 record 实例转为 JSON。</p><p>最后，我们创建一个 <code>main</code> 函数来启动服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestServiceApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RestServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，<code>@SpringBootApplication</code> 相当于以下 3 个注解的结合：</p><ul><li><p><code>@Configuration</code>：将被修饰的类标记为当前 Application 上下文的 Bean 的定义方；</p><blockquote><p>回忆 DI（依赖注入），这里相当于产生 Bean（之前的 Record 类型）的类型。</p></blockquote></li><li><p><code>@EnableAutoConfiguration</code>: 告诉 Spring Boot 根据当前 classpath 中的设置来开始注入 beans，以及其他属性设置。例如，如果 <code>spring-webmvc</code> 在 classpath 中，那么这个注解的含义就是将这个类标记为 Web Application，并且激活一些重要的行为，例如设置启动 <code>DispatcherSevlet</code>；</p></li><li><p><code>@ComponentScan</code>：告诉 Sping 来查找其他的在 <code>priv/demo</code> 中的组件、设置和服务包，并且找到 Controller；</p></li></ul><h2 id="1-2-What-is-MVC"><a href="#1-2-What-is-MVC" class="headerlink" title="1.2 What is MVC?"></a>1.2 What is MVC?</h2><p>MVC 是一种软件设计架构模式，大多数时候应用在 Web Application 中，主要分为 3 层：</p><ul><li>Control Layer：软件控制层。如果用在 Web App 上，这层的职责是<u><strong>解析</strong>从 Web Server 传来的对特定 URL 的请求，并转发给服务程序的相应逻辑块</u>；</li><li>Model Layer：软件模型层。实际上的职责是<u>软件的数据表示</u>（就是对关系型数据库中存储的数据以及表单进行面向对象的表述），能让你轻松地从数据库中取出数据后放入对象中，并且轻松地展示在 Web 页面上；</li><li>View Layer：软件视图层。在传统的 Web 应用架构中，前端的程序主导了这个任务（比如 React、Anngular）。但是在 MVC 架构中，这部分位于后端，并且它的职责是<u>收到从数据库传来的数据，并将其组织在 Web 页面上</u>。</li></ul><h2 id="1-3-What-is-Dispatcher-Servlet"><a href="#1-3-What-is-Dispatcher-Servlet" class="headerlink" title="1.3 What is Dispatcher Servlet?"></a>1.3 What is Dispatcher Servlet?</h2><p>在 Spring MVC 中，有些东西不解释清楚就没法开始。比如一个 Spring MVC 中的概念 Dispatcher Servlet。</p><p>我们知道，Servlet 就是一种 Web Server 和 Web App 间的接口。在 Web App 软件层面只要按照 Servlet 接口实现一个 Servlet 就能与 Web Server 直接交互。</p><p>所谓的 Dispatcher Servlet 是一种编码模式（code pattern），也是 Servlet 的一种实现方式，在 MVC 架构中，作为 Control Layer 的一部分。</p><p>它在概念上主要完成了一件重要的事情：<strong>Request Handling &amp; Mapping</strong>。</p><p>Dispatcher Servlet 实现了 Servlet 接口，能给接收从 Web Server 传来的 HTTP 请求。当一个请求到达 Spring MVC Application 时，它会首先到达 Control Layer 的 Dispatcher Servlet。</p><p>Dispatcher Servlet 会根据 Spring Framework 对于请求的配置（底层配置在 <code>web.xml</code> 中，但 Spring MVC 已经包装在了像 <code>@ReuqestMapping</code> 一类的注解中了），映射（map）到相应的 Controller 中（通常被包装为一个方法）进行处理。</p><p>此后，收到 Dispatcher Servlet 请求的 controller 中会对传入的数据进行详细处理，例如处理请求参数、访问数据库、准备响应体等等。</p><p>再然后，Controller 会将处理好的数据交给指定的 view 进行组装。这里的 View Layer 会生成像 JSP / Thymeleaf templates / JSON 之类的数据结构，并且发送。</p><blockquote><p>Dispatcher Servlet 的这种职责实际上也是采用了一种编码模式，叫做 Front Controller。</p></blockquote><h2 id="1-4-What-does-Models-actually-do"><a href="#1-4-What-does-Models-actually-do" class="headerlink" title="1.4 What does Models actually do?"></a>1.4 What does Models actually do?</h2><p>在 Spring MVC 中，显然一个 Model 作为软件的数据表示，是一个至关重要的部分。但同时也是 Spring MVC 包装较好的部分、较简单的部分。</p><p>一个 Model 通常可以是一个 “POJO”（Plain Old Java Class / Object）；</p><blockquote><p>什么是 POJO？</p><p>Plain Old Java Object 特指那些 <strong>不用 extends / implements 其他外部框架的、不使用外部框架的 annotation 的 Java 类型</strong>。</p><p>简言之，你能不依赖框架写出的手写 Java 类型的实例都是 POJO。例如 Java Bean 就是典型的 POJO（允许 extends Java 原生接口，例如 <code>Serializable</code>）。</p><p>使用 POJO 的优势是，POJO 能够更加贴近、关注业务逻辑，不依赖外部框架代码（与外部框架解耦），不需要考虑外部代码对它的隐式影响。</p></blockquote><p>不过 Model 所包含的功能不止于用 POJO 保存信息，它还要完成一个重要的职责：<u>将 POJO 与关系型数据库表建立关联</u>（这个过程由 Spring JPA 模块完成）。</p><p>那么，接下来如何让 Spring Framework 知道这个 POJO 对应的类型是个 Model，并且如何将 POJO 由 JPA 映射为关系型数据库的表记录呢？</p><p>一般需要做 3 件事：</p><ol><li><p>确定描述 Model 的 POJO 类型。这件事就在告诉 Spring，这个类是个表示数据的类（即 Model），等会 JPA 可以按照这个类型创建关系型数据库的表单；</p><blockquote><p>这件事既可以由 <code>XML</code> 配置来做，也可以由 Spring Boot 包装好的注解 <code>@Entity</code> 来做。</p><p>但是如果加了注解，原来的类就不再是 POJO 类型。所以为了便捷性，需要在规范上作出一些取舍。</p></blockquote></li><li><p>确定 Model 中的哪个数据域为 POJO 的唯一识别符。这个表示建议 JPA 在创建数据库表时，将这个数据类型作为表的 <u>主键</u>；</p><blockquote><p>同样，这件事既可以由 <code>XML</code> 配置来做，也可以由 Spring Boot 包装好的注解 <code>@Id</code> 来做。</p></blockquote></li><li><p>决定 Model 中的哪些数据域是需要框架 / 驱动来生成的，而不是用户（Requests）传入的。这个告诉 JPA，这个数据域外部不会给定，应该由程序根据情况生成。</p><blockquote><p>举个例子，你可能在第二条中，想要为每个同类型的 POJO 维护一个全局唯一的 id，但这个 id 肯定不能由用户指定，通常是数据库的自增键来自动生成。</p><p>在 Spring Boot 中，提供了 <code>@GeneratedValue</code> 注解，相当于告诉 JPA，这个数据域应该生成而不是传入得到（通常是通过数据库当前的信息判断出来）。默认行为是在 JPA 生成数据库表时，将被修饰的数据域生成成为 “auto increment”（这种数据域被称为 database indentity）；</p></blockquote></li></ol><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.persistence.*;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.CreationTimestamp;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.UpdateTimestamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span>   <span class="comment">/* Equivalent to @Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode.  */</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span>    <span class="comment">/* Generate ClassBuilder static class */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;posts&quot;)</span>  <span class="comment">/* Tell JPA to generate data into named table &#x27;books&#x27;. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostInfo</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">/* Equivalent to: UNIQUE + NOT NULL + IMMUTABLE */</span></span><br><span class="line">    <span class="comment">/* It relies on an auto-incremented database column</span></span><br><span class="line"><span class="comment">     * and lets the database generate a new value with each insert operation.</span></span><br><span class="line"><span class="comment">     * But, this prevents it from using different optimization techniques like JDBC batching. */</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long postId;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreationTimestamp</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createdOn;</span><br><span class="line">    <span class="meta">@UpdateTimestamp</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updatedOn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-N-Tier-Architecture"><a href="#1-5-N-Tier-Architecture" class="headerlink" title="1.5 N-Tier Architecture"></a>1.5 N-Tier Architecture</h2><blockquote><p>前置知识：什么是 DTO？</p><p>在 MVC 架构中，有一种对象称数据转移对象（Data Transfer Object）。它的作用是在 Application 的不同层级 / 子系统间传输数据。</p><p>DTO 尤其常用在 N-Tiers 中使用，其好处是减少数据在各部分传输的量，使得程序信息能清晰地相互传输。具体的应用场景如下：</p><ul><li>假设数据库中原本抽象出的对象有很多属性，但是我在某些层级间传输时，只需要用到一部分。那么就没有必要把对象整体传来传去：我们可以定义一个 DTO 类型，属性是原类型的子集，使得功能清晰、传参无负担；</li><li>假设有个方法需要传入 4 个以上参数，那么写方法签名、手动传参就不现实。可以定义一个 DTO 类型来向其传参，语义更清晰；</li></ul><p>所以，DTO 就是一种普通的类型，提取了某个类型的一些属性。</p><p>例如，上一节定义的 <code>PostInfo</code> 中，有一些数据现在不需要在 App 中传输，那么可以这么定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long postId;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>在软件工程中有个非常有趣的事实是，90% 的时候都无需使用软件工程的设计原理（software engineering design patterns），但是应用在底层的架构设计是恰恰又需要用到。</p><p>有一种软件设计架构叫 N-Tier（或者说 N-Tier Repository Pattern，Multi-Tier Architecture），也是接下来我们想要实践的架构。它是一种 C/S 架构设计模式，最广泛的使用方法是将其分为 3 个部分：</p><ul><li><p>Data Tier（Repository）：以 Web 开发为例，通常在 Java 后端服务中，此层是管理数据库的部分（在 Java 中通常封装为一个类型）。它通常具有 CRUD 四种方法，并且充当了在数据库表结果 和 对象之间转换的桥梁；</p><blockquote><p>在 Spring JPA 中提供了一个接口 <code>JpaRepository&lt;EntityType, EntityIdType&gt;</code> 轻松定义 custom query method（这样我们可通过方法名判断出对应的 SQL 语句）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> priv.demo.models.PostInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PostRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;PostInfo, Long&gt; &#123;</span><br><span class="line"> Optional&lt;PostInfo&gt; <span class="title function_">findByPostId</span><span class="params">(Long postId)</span>;</span><br><span class="line"> List&lt;PostInfo&gt; <span class="title function_">findByTitle</span><span class="params">(String title)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>PostRepository</code> 又称 DAO（Data Access Object）类型。DAO 和 DTO 一样，也是一种编码模式（code pattern），它的作用是使用一组 API 将 application tier / bussiness logic 与 persistence layer 隔离开，达到模块解耦的作用。</p></blockquote></li><li><p>Application Tier（Bussiness Logic）：以 Web 开发为例，通常在 Java 后端服务中，此层是通常是 Spring 框架中处理数据的业务逻辑部分；</p><blockquote><p>在使用 Spring MVC 时，除了我们直接写 Controllers 外，还建议抽象出一层 “Service”（服务层），这样可以把处理特定的数据库操作与业务逻辑解耦（即可以表示处理特定业务逻辑所需的操作），这样项目功能改变时就不用担心大幅度改代码，只需要到实现功能的 service 中改动就行，不会有 ”这块代码是干什么“ 的担忧。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo.services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> priv.demo.dto.PostDto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PostService</span> &#123;</span><br><span class="line"> <span class="comment">/* Use predefined DTO in services */</span></span><br><span class="line"> List&lt;PostDto&gt; <span class="title function_">findAllPosts</span><span class="params">()</span>;</span><br><span class="line"> Optional&lt;PostDto&gt; <span class="title function_">findPostsById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们再实现这个接口，注意因为服务抽象肯定需要 repository 的数据库操作，因此需要与 <code>JpaRepository</code> 组合。这个时候就用到了 Spring 的依赖注入的特性，让模块解耦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo.services.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> priv.demo.dto.PostDto;</span><br><span class="line"><span class="keyword">import</span> priv.demo.models.Post;</span><br><span class="line"><span class="keyword">import</span> priv.demo.repositories.PostRepository;</span><br><span class="line"><span class="keyword">import</span> priv.demo.services.PostService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>    <span class="comment">/* provide Spring with PostSerivce Bean */</span></span><br><span class="line">            <span class="comment">/* (可以在写 Controller 时再回来添加)  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PostService</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Use Jpa Repository to achieve goals */</span></span><br><span class="line"> PostRepository postRepository;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Use Spring Dependency Injection: inject repo to de-couple dependencies. */</span></span><br><span class="line"> <span class="comment">/* Also, we need to provide repository from other area.</span></span><br><span class="line"><span class="comment">     * Here we provide Spring with repo in  */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PostServiceImpl</span><span class="params">(PostRepository repository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.postRepository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;PostDto&gt; <span class="title function_">findAllBooks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;PostInfo&gt; posts = postRepository.findAll();</span><br><span class="line">        <span class="keyword">return</span> posts.stream().map((post -&gt; mapToPostDto(post))).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;PostDto&gt; <span class="title function_">findPostsById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        Optional&lt;Post&gt; src = postRepository.findByPostId(id);</span><br><span class="line">        <span class="keyword">return</span> (src.map(PostServiceImpl::mapToPostDto));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@implNote</span> Private self-defined mapper.</span></span><br><span class="line"><span class="comment">     *  Covert model (database representation) to DTO (app representation).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PostDto <span class="title function_">mapToPostDto</span><span class="params">(PostInfo post)</span> &#123;</span><br><span class="line">        <span class="type">PostDto</span> <span class="variable">postDto</span> <span class="operator">=</span> postDto.builder()</span><br><span class="line">                .postId(post.getPostId())</span><br><span class="line">                .title(post.getTitle())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> postDto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，以上从 <code>PostInfo</code>（数据库表示，即 model）向 <code>PostDto</code>（应用程序传输表示，即 DTO）转换时，需要自定义 <code>mapToPostDto</code> 的方法。</p><p>此外，在数组元素处理时，我们还使用了 Java 中类似 JavaScript 的处理方法 <code>map</code>，对数组每个元素的处理方法就变简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt;.stream().map(&lt;mapFunc&gt;);    <span class="comment">/* 返回映射后的 Stream 对象 */</span></span><br><span class="line">Stream.collect(Collectors.toList());    <span class="comment">/* 将产生的 Stream 对象转换回 List&lt;T&gt; */</span></span><br></pre></td></tr></table></figure><p>再聊聊 Controllers 的部分。后面的数据布置都已清晰，剩下来还要布置 Controller 处理 Web Server 发来的请求。</p><p>除了在在 1.1 中见到的 <code>@RestController</code> 可以创建普通的 REST Controller 以外，还有普通的 Controller <code>@Controller</code>（少了将 Controller 方法组织成资源返回值的方法）；</p><p>此外，<code>@RequestMapping()</code> 可以使用、<code>@GetMapping/@PostMapping/@DeleteMapping/...</code> 注解也可以使用。</p></blockquote></li><li><p>Presentation Tier（Frontend）：以 Web 开发为例，通常在前端服务中，此层就是渲染 Web Page 页面的部分，可以由 React 等框架解决。</p></li></ul><h2 id="1-6-CRUD-Read-Data"><a href="#1-6-CRUD-Read-Data" class="headerlink" title="1.6 CRUD: Read Data"></a>1.6 CRUD: Read Data</h2><p>以上的所有知识已经足够我们将前端、后端连接起来。当然，后端如果要处理数据，还得把接下来几节学完。</p><p>现在让我们一起巩固所学，将前端和后端连接起来，先了解 “前端读取后端数据” 的效果如何达成。</p><p>首先，我们由上面的示例，已经能利用 JPA 从数据库中获取数据，并且呈现 JSON 结果了。因此我们只需要修改事先写好的前端，加入 <code>fetch</code> API，读取从后端传来的数据，再呈现在页面上即可。只要你完全了解了上面的理论，那么 read data 就是简单地在前端加上 <code>fetch</code> 获取资源，仅此而已。</p><p>值得注意的是，如果你做的项目也是前后端分离的（服务在不同端口上），那么 CORS 将会是一大问题。请自行查阅资料解决，笔者贴上自己的解决方案（Spring Boot）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configurations</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">corsMappingConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                        <span class="comment">/* Frontend server runs at localhost:3000 */</span></span><br><span class="line">                        .allowedOrigins(<span class="string">&quot;http://localhost:3000&quot;</span>)</span><br><span class="line">                        .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PATCH&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>, <span class="string">&quot;HEAD&quot;</span>)</span><br><span class="line">                        .maxAge(<span class="number">3600</span>)</span><br><span class="line">                        .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-Validation-in-Backend"><a href="#1-7-Validation-in-Backend" class="headerlink" title="1.7 Validation in Backend"></a>1.7 Validation in Backend</h2><p>在后端的 DTO 类型中，往往可以添加许多注解来代替我们完成繁琐且常见的数据校验操作，例如：</p><p><code>@NotNull</code>, <code>@NotBlank</code>, <code>@NotEmpty</code>, <code>@Email</code>, <code>@Min</code>, <code>@Max</code>, <code>@Size</code>, <code>@Pattern</code>, <code>@Phone</code>, <code>@Past</code>；</p><p>以上是库 <code>spring-boot-starter-validation</code> 的校验注解，需要自行安装。但由于它们注解在类的属性上，所以只有当你在 Controller 中获取表单参数时加入 <code>@Valid</code>，并配合 <code>BindingResult</code>（请添加第二参数）才会使这些注解生效。</p><h2 id="1-8-CRUD-Create-Data-Update-Data"><a href="#1-8-CRUD-Create-Data-Update-Data" class="headerlink" title="1.8 CRUD: Create Data / Update Data"></a>1.8 CRUD: Create Data / Update Data</h2><p>用户可能会通过表单向前端提交数据，这个过程通常会造成数据库的某些信息的修改。因此，我们有必要了解一下从前端传入数据，到后端修改数据的过程。</p><p>本节先对 “CRUD” 中的 Create 进行介绍，介绍在以上的 N-Tiers 架构设计中，Create 动作是如何完成的。</p><p>通常情况下，用户会在前端的 <code>&lt;form&gt; &gt; &lt;input&gt;</code> 中填写数据，再 submit，前端会使用 <code>fetch</code> API 向后端发送表单信息。</p><p>对于 Create Data 而言，常常不是幂等的，因此使用 <code>PostMapping</code>，而 Update Data 而言大多数情况下是幂等的，因此使用 <code>PutMapping</code>；</p><p>在 JPA 中，对于简单的数据表而言，一条 <code>repository.save(Entity)</code> 即可完成创建或者更新的操作。</p><h2 id="1-9-CRUD-Delete-Data"><a href="#1-9-CRUD-Delete-Data" class="headerlink" title="1.9 CRUD: Delete Data"></a>1.9 CRUD: Delete Data</h2><p>对于 JPA 的简单表而言，一条 <code>repository.delete(Entity)</code> 即可完成任务。</p><h2 id="1-10-JPQL-Search-Data"><a href="#1-10-JPQL-Search-Data" class="headerlink" title="1.10 JPQL: Search Data"></a>1.10 JPQL: Search Data</h2><p>除了前面的对于数据库的操作过于简单，我们无需写 SQL 语句以外，在用户的搜索场景中，由于搜索条件的复杂性，导致 Spring JPA 生成的 SQL 语句通常有性能问题。</p><p>所以自己写 SQL 语句查询往往是个好选择，开发者还可以根据自己写的 SQL 语句进行自行优化。</p><p>值得注意的是，在模糊搜索中 <code>CONTAINS</code> 和 <code>LIKE</code> 关键字的性能由数据库的类型决定，谨慎使用。</p><p>此外，有两种索引方式：name index、normal index。前者表示在代码中使用参数名嵌入 SQL 索引，后者表示使用类似 <code>?1</code> 指定参数位来嵌入 SQL 索引。</p><p>例如，查找 SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT post FROM posts WHERE post.title LIKE &quot;%hello%&quot;</span><br></pre></td></tr></table></figure><p>那么在 Spring JPA 中，提供了 <code>@Query</code> 方法可以在 <code>JpaRepository</code> 中使用，语法如下（以 name index 为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PostRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;PostInfo, Long&gt; &#123;</span><br><span class="line">    <span class="comment">/* Other methods... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query(&quot;SELECT post FROM Post post WHERE post.title LIKE CONCAT(&#x27;%&#x27;, :input, &#x27;%&#x27;) &quot;)</span></span><br><span class="line">    List&lt;PostInfo&gt; <span class="title function_">searchPost</span><span class="params">(String input)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Other methods... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到：</p><ul><li>在内嵌 SQL 语句中，name index 前使用 <code>:</code> 来标识；</li><li>由于插入了变量，因此字符串需要拼接而不是直接使用；</li></ul><h2 id="1-11-One-To-Many-Spring-Data"><a href="#1-11-One-To-Many-Spring-Data" class="headerlink" title="1.11 One-To-Many Spring Data"></a>1.11 One-To-Many Spring Data</h2><p>关系型数据库中，有一种关系是一对多的数据关系。例如，一个用户可以对应持有多个订单。</p><p>这种关系在 Spring JPA 中以 <code>@OneToMany</code> 来表示。值得注意的是，这种关系是有关联的，通常要求父数据（One）被删除时，与该父数据关联的子数据（Many）需要一并全部删除，这种删除关系被称为 Cascade（级联），更详细的信息请参见数据库教程。</p><p>此外，如果是一对多的关系，在关系型数据库中通常还要联接表的列，以便联接查询。在 Spring JPA 中还提供了 <code>@JoinColumn</code> 注解，可以注解到要存放关联列的表的列 field 中（通常位于 “Many” 子数据表中）。</p><h1 id="Chapter-2-Spring-Security"><a href="#Chapter-2-Spring-Security" class="headerlink" title="Chapter 2. Spring Security"></a>Chapter 2. Spring Security</h1><h2 id="2-1-Spring-Security-Overview-Servlet-App"><a href="#2-1-Spring-Security-Overview-Servlet-App" class="headerlink" title="2.1 Spring Security Overview (Servlet App)"></a>2.1 Spring Security Overview (Servlet App)</h2><p>强烈建议至少阅读 <a href="https://docs.spring.io/spring-security/reference/servlet/architecture.html">官方文档的 架构总览</a> 章节，以获得对于 Spring Security 在 Servlet 应用中的宏观上的认识。</p><p>总结下来，Spring Security 在 Servlet 应用上的架构有如下几个重要的点：</p><ul><li><p>以过滤器（filter）为核心。Spring Security 内置很多层 Filter：</p><p><img src="imgs/filterchain.png" width="200px"></p><p><img src="imgs/filterchain2.png" height="250px"></p><blockquote><p>Spring Security包含了众多的过滤器，这些过滤器形成了一条链，所有请求都必须通过这些过滤器后才能成功访问到资源。</p><ul><li><code>UsernamePasswordAuthenticationFilter</code> 过滤器用于处理基于表单方式的登录认证；</li><li><code>BasicAuthenticationFilter</code> 用于处理基于HTTP Basic方式的登录验证，后面还可能包含一系列别的过滤器（可以通过相应配置开启）；</li><li><code>FilterSecurityInterceptor</code> 用于判断当前请求身份认证是否成功，是否有相应的权限，当身份认证失败或者权限不足的时候便会抛出相应的异常；</li><li><code>ExceptionTranslationFilter</code> 能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常： <code>AuthenticationException</code> 和 <code>AccessDeniedException</code>，其它的异常它会继续抛出。</li></ul><p>另外，可以打印出内部的默认部署的 filters 情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.security.web.session.DisableEncodeUrlFilter@404db674,</span><br><span class="line">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@50f097b5,</span><br><span class="line">org.springframework.security.web.context.SecurityContextHolderFilter@6fc6deb7,</span><br><span class="line">org.springframework.security.web.header.HeaderWriterFilter@6f76c2cc,</span><br><span class="line">org.springframework.security.web.csrf.CsrfFilter@c29fe36,</span><br><span class="line">org.springframework.security.web.authentication.logout.LogoutFilter@ef60710,</span><br><span class="line">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@7c2dfa2,</span><br><span class="line">org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter@4397a639,</span><br><span class="line">org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@7add838c,</span><br><span class="line">org.springframework.security.web.authentication.www.BasicAuthenticationFilter@5cc9d3d0,</span><br><span class="line">org.springframework.security.web.savedrequest.RequestCacheAwareFilter@7da39774,</span><br><span class="line">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@32b0876c,</span><br><span class="line">org.springframework.security.web.authentication.AnonymousAuthenticationFilter@3662bdff,</span><br><span class="line">org.springframework.security.web.access.ExceptionTranslationFilter@77681ce4,</span><br><span class="line">org.springframework.security.web.access.intercept.AuthorizationFilter@169268a7]</span><br></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>Spring Security 认证、授权的大致原理就是，借助这些 filters 判断这个请求是否有效，无效则抛出异常拒绝访问；</p></li><li><p>对 Spring Security 的设置，可以说就是对这些 filters 的配置、自定义；</p><ul><li>配置：可以禁用、启用其中的 filters，为其中的 filters 设置参数等；</li><li>自定义：基于 Spring Security 提供的接口类，自定义 filters；</li></ul></li></ul><p>实际上，Spring Security 相当灵活，能够胜任：认证（像登录工作）、授权（像当前登录用户是否有权限）、外部授权服务器的认证和授权（像 OAuth2 协议）等任务。</p><p>其中，使用用户名-密码的方式认证、授权是最简单的一种，本章不作详细介绍。</p><p>最后，如果你发现自己写了一个配置，测试时却怎么都连不上，可以在 <code>application.properties</code> 内打开测试日志，帮助 debug：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.org.springframework.security</span>=<span class="string">TRACE</span></span><br></pre></td></tr></table></figure><h2 id="2-2-Spring-Security-OAuth2-0"><a href="#2-2-Spring-Security-OAuth2-0" class="headerlink" title="2.2 Spring Security: OAuth2.0"></a>2.2 Spring Security: OAuth2.0</h2><h3 id="2-2-1-OAuth2-0-Overview"><a href="#2-2-1-OAuth2-0-Overview" class="headerlink" title="2.2.1 OAuth2.0 Overview"></a>2.2.1 OAuth2.0 Overview</h3><p>Spring Security 除了普通的自定义用户名-密码验证，还支持 OAuth2.0 外部的授权服务器验证。</p><p>在了解 Spring Security 如何操作前，先了解 OAuth2.0 的协议是什么。</p><p>查看 <a href="https://www.rfc-editor.org/rfc/rfc6749">RFC 6749 标准</a>，其提供了抽象的协议流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--------+                               +---------------+</span><br><span class="line">|        |--(A)- Authorization Request -&gt;|   Resource    |</span><br><span class="line">|        |                               |     Owner     |</span><br><span class="line">|        |&lt;-(B)-- Authorization Grant ---|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(C)-- Authorization Grant --&gt;| Authorization |</span><br><span class="line">| Client |                               |     Server    |</span><br><span class="line">|        |&lt;-(D)----- Access Token -------|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(E)----- Access Token ------&gt;|    Resource   |</span><br><span class="line">|        |                               |     Server    |</span><br><span class="line">|        |&lt;-(F)--- Protected Resource ---|               |</span><br><span class="line">+--------+                               +---------------+</span><br></pre></td></tr></table></figure><p>简单来说，OAuth2.0 协议的过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(A) 用户（就是 resource owner）访问客户端，客户端将用户导向认证服务器。</span><br><span class="line"></span><br><span class="line">(B) 用户选择是否给予客户端授权。</span><br><span class="line"></span><br><span class="line">(C) 假设用户给予授权，认证服务器先生成一个授权码，并返回给用户，认证服务器将用户导向客户端事先指定的“重定向URI”（redirect uri），同时附上一个授权码（code）。</span><br><span class="line"></span><br><span class="line">(D) 客户端收到授权码，附上早先的“重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</span><br><span class="line"></span><br><span class="line">(E) 认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）或更新令牌（refresh token）。</span><br><span class="line"></span><br><span class="line">(F) 客户端验证身份令牌信息的完整性和正确性，并解析获取当前用户信息。</span><br></pre></td></tr></table></figure><p>这就是 OAuth2.0 协议最规范、最完整、最常用、最安全的使用方法：授权码模式。RFC 6749 标准还规定了其他 3 种获取令牌（token）的模式：</p><ul><li>简化模式；</li><li>密码模式；</li><li>客户端模式；</li></ul><p>这些方法的安全性和规范性依次递减。</p><p>此外，我们从上图可知，一个后端程序想要使用 OAuth2.0，我们至少需要搭建：</p><ul><li>一个 OAuth2.0 客户端（用于处理用户、授权服务器、资源服务器之间的交互）；</li><li>一个授权服务器（用户的认证信息存放位置）；</li><li>一个资源服务器（用户的资源存放位置）；</li></ul><p>如果你使用第三方的 OAuth2.0 认证服务，就是说，使用第三方的认证服务来获取这个用户的有限的身份信息，那么只需要开发自己的客户端（client）即可，<strong>授权服务器（Authorization Server）和资源服务器（Resource Server）都是由第三方提供的</strong>。</p><blockquote><p>举个例子，Github 第三方授权见过吧？很多网站都支持 QQ / 微信第三方登录吧？它们的底层都可以使用 OAuth2.0 来完成。</p><p>使用 OAuth2.0 可以验证当前的用户的身份，只不过是：在不需要知道用户的密钥的前提下，将用户的认证、授权委托给第三方（授权服务器）来完成，客户端（client）只要询问第三方，这个用户合不合法、用户的基本信息是什么（<u>有限的信息，给多少取决于第三方授权服务器，以及用户在弹出的授权框里自己指定</u>），就能证明这个用户的身份了。</p></blockquote><p>本章也不说 OAuth2.0 授权服务器、资源服务器的搭建，只说 OAuth2.0 客户端的搭建。</p><p>如果使用的是第三方授权服务器、资源服务器，一般第三方平台会给你接口说明（客户端怎么访问授权服务器和资源服务器），并要求你出示自己的身份，注册一对 <code>client_id</code>、<code>client_key</code>；</p><p>为什么需要你注册一个 <code>client_id/client_key</code> 呢？这是为了保护 App 使用者（最终用户）的合法权益，确保客户端是可信的，不是什么伪造的中间人都可以访问授权服务器、读取用户信息的。</p><p>有了这对 <code>client_id</code>、<code>client_key</code>，就可以认证应用开发者和客户端的身份，在与第三方授权服务器通信时携带，就可以确保客户端是合法的。</p><h3 id="2-2-2-OAuth2-0-Client-in-Spring-Security"><a href="#2-2-2-OAuth2-0-Client-in-Spring-Security" class="headerlink" title="2.2.2 OAuth2.0 Client in Spring Security"></a>2.2.2 OAuth2.0 Client in Spring Security</h3><blockquote><p>那么 Spring Security 是怎么支持 OAuth2.0 的呢？我们不妨先了解一下 Spring Security 的历史：</p><p>大约十年前，Spring 引入了一个社区驱动的开源项目 Spring Security OAuth， 并将其纳入 Spring 项目组合中。到今天为止，这个项目己经发展成为一个成熟的项目，可以支持大部分 OAuth 规范，包括资源服务器、 客户端和授权服务器等。</p><p>然而早期的项目存在一些问题，例如：</p><ul><li>OAuth 是在早期完成的，开发者无法预料未来的变化以及这些代码到底要被怎么使用， 这导致很多 Spring 项目提供了自己的 OAuth 支持，也就带来了 OAuth 支持的碎片化。</li><li>最早的OAuth项目同时支特 OAuth1.0 和 OAuth2.0，而现在 OAuth1.0 早已经不再使用， 可以放弃了。</li><li>现在我们有更多的库可以选择，可以在这些库的基础上去开发，以便更好地支持JWT等新技术。</li></ul><p>基于以上这些原因，官方决定重写 Spring Security OAuth，以便更好地协调 Spring 和 OAuth，并简化代码库，使 Spring 的 OAuth 支持更加灵活。然而，在重写的过程中，发生了不少波折。</p><p>2018年1月30日，Spring 官方发了一个通知，表示要逐渐停止现有的 OAuth2支持，然后在 Spring Security  5中构建下一代 OAuth2.0 支持。这么做的原因是因为当时 OAuth2 的落地方案比较混乱，在 Spring Security  OAuth、 Spring Cloud Security、Spring Boot 1.5.x 以及当时最新的Spring Security  5.x 中都提供了对 OAuth2 的实现。以至于当开发者需要使用 OAuth2 时，不得不问，到底选哪一个依赖合适呢？</p><p>所以 Spring 官方决定有必要将 OAuth2.0 的支持统一到一个项目中，以便为用户提供明确的选择，并避免任何潜在的混乱，同时 OAuth2.0 的开发文档也要重新编写，以方便开发人员学习。所有的决定将在 Spring Security 5 中开始，构建下一代 OAuth2.0 的支持。从那个时候起，Spring Security OAuth  项目就正式处于维护模式。官方将提供至少一年的错识/安全修复程序，并且会考虑添加次要功能，但不会添加主要功能。同时将 Spring Security OAuth 中的所有功能重构到 Spring Security 5.x 中。</p><p>到了2019年11月14日，Spring 官方又发布一个通知，这次的通知首先表示 Spring Security OAuth 在迁往  Spring Security 5.x 的过程非常顺利，大部分迁程工作已经完成了，剩下的将在 5.3 版本中完成迁移，在迁移的过程中还添加了许多新功能。包括对 OpenID Connect1.0 的支持。同时还宣布将不再支持授权服务器，不支持的原因有两个：</p><ol><li>在2019年，已经有大量的商业和开源授权服务器可用；</li><li>授权服务器是使用一个库来构建产品，而 Spring Security 作为框架，并不适合做这件事情。</li></ol><p>一石激起千层浪，许多开发者表示对此难以接受。这件事也在Spring 社区引发了激烈的讨论，好在 Spring 官方愿意倾听来自社区的声音。</p><p>到了2020年4月15日，Spring 官方宣布启动 Spring Authorization server 项目。这是一个由  Spring Security 团队领导的社区驱动的项目，致力于向 Spring 社区提供 Authorization  Server支持，也就是说，Spring 又重新支持授权服务器了。</p><p>于是在 2020年8月21日，Spring Authorization Server 0.0.1 正式发布。</p></blockquote><p>当前的 Spring Security 对于 OAuth2.0 的支持主要分为 2 个部分：</p><ul><li>OAuth2.0 Client（内置提供了强大的 OAuth2.0 登录功能）；</li><li>OAuth2.0 Resources Server；</li></ul><p>授权服务器的部分已经从 Spring Security 项目中独立出去了（Spring Authorization Server）。</p><p>这里就详细讨论 OAuth2.0 客户端的设计和使用。在 Gradle 中这么导入：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-oauth2-client&#x27;</span></span><br></pre></td></tr></table></figure><p>Spring Security OAuth2.0 Client 支持：</p><ul><li>认证：JWT Bearer 令牌的处理；</li><li>授权：授权码的保存、刷新令牌的操作、客户端认证信息的操作、用户认证信息的保存……</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前置条件：WEB 基础（Socket，HTTP 整套规范），SQL 和数据库基础，Java 语言基础、前端基础（至少了解一种前端框架，本文以 React 为例）；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Chapter-0-Basic-</summary>
      
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
    <category term="Java" scheme="https://sjtuxhw.top/tags/Java/"/>
    
    <category term="Spring" scheme="https://sjtuxhw.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习笔记（二）</title>
    <link href="https://sjtuxhw.top/2024/05/02/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://sjtuxhw.top/2024/05/02/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2024-05-02T10:09:13.000Z</published>
    <updated>2024-07-28T07:10:37.791Z</updated>
    
    <content type="html"><![CDATA[<p><i>Reference: Oracle Documentation</i></p><h1 id="Chapter-3-Java-Record-amp-Java-Bean"><a href="#Chapter-3-Java-Record-amp-Java-Bean" class="headerlink" title="Chapter 3. Java Record &amp; Java Bean"></a>Chapter 3. Java Record &amp; Java Bean</h1><h2 id="3-1-Java-Record"><a href="#3-1-Java-Record" class="headerlink" title="3.1 Java Record"></a>3.1 Java Record</h2><p>在 Java 14 以后，官方引入了新的 Java 关键字：<code>record</code>；</p><p>那么这个 <code>record</code> 关键字究竟有什么用处呢？它和我们熟知的 <code>class / interface / abstract class</code> 又有什么区别呢？其实在 Java 14 以前，有一种需求写起来非常的麻烦，正因为这种需求才产生出了 <code>record</code> 关键字。这个需求是什么呢？</p><p>举个例子，假如现在有个应用场景，想要定义一个数据类型，<strong>它只是用来存放一些数据</strong>（例如数据库查询的结果，或者是某个服务的返回信息）。</p><p>在很多实际情况下，我们希望使用这些数据就像 Java 内置基本类型一样，是不可变数据类型。这样做有几点好处：</p><ul><li><p>复制构造时，不是引用传递，因此是深拷贝。这样使用起来和基本类型一样方便，但是又不用担心改错源数据（非引用链接）；</p></li><li><p>确保数据在多线程情况下无需同步，线程安全！</p></li></ul><p>回忆下基础篇中的知识，要让 Java 类型（对象）behaves like 不可变数据类型，就必须确保：</p><ul><li>类型中的每个数据域都是 <u>私有的、常量的</u>（<code>private</code>，<code>final</code>）；</li><li>每个数据域都只能通过 <code>getter</code> 方法获取，不能有任何 <code>setter</code> 方法；</li><li>必须存在公有构造函数，并且构造函数内初始化各个数据域（常量只能这么做）；</li><li>Object 基类继承函数 <code>equals</code> 返回 <code>true</code> 当且仅当类中的每个数据域都相等；</li><li>Object 基类继承函数 <code>hashCode</code> 在类中的每个数据域都相等时，一定返回一样的值；</li><li>Object 基类继承函数 <code>toString</code> 最好包含 类名 和 每个数据域的名称和值； </li></ul><p>好了，假设我们现在想要保存一个 “联系人” 的信息，只包含一个名称、住址。我要定义这个类为不可变数据类型，那么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Persion</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, address);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">other</span> <span class="operator">=</span> (Person)obj;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(name, other.name) &amp;&amp; Objects.equals(address, other.address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, address=&quot;</span> + address + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* standard getters */</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    String <span class="title function_">getAddress</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.address; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……这很难评，仅仅为了将两个基本类型保存为不可变的数据类型，如此大费周章。具体来说，有几点坏处：</p><ul><li><p>许多代码都是和业务逻辑无关的 “模板代码”；</p></li><li><p>这种写法模糊了这个类原本的作用（语义模糊）：仅仅是按不可变数据类型保存两个基本类型而已！</p></li><li><p>很差的扩展性。</p><blockquote><p>现在还只有两个属性，那如果我要再加一个属性呢？</p><p>那么我要修改构造函数、修改<strong>所有的重载方法</strong>、为新的属性添加访问器。可谓麻烦。</p></blockquote></li></ul><hr><p>于是，在 Java 14 中，定义了新的关键字 <code>record</code>，它的含义就是告诉编译器，这是个保存数据的类型，要把它定义成不可变的样子！</p><p>经过上面的铺垫，你就能理解 <code>record</code> 关键字的意义，以及它的作用了。</p><h3 id="3-1-1-记录类型的构造函数"><a href="#3-1-1-记录类型的构造函数" class="headerlink" title="3.1.1 记录类型的构造函数"></a>3.1.1 记录类型的构造函数</h3><p>Java 规定，在使用 <code>record</code> 关键字定义类型时，<strong>默认构造函数存在参数，且与私有数据域一一对应</strong>。</p><p>允许特殊的定义方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, String address)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>你没有看错，上面一行等价于之前用 <code>class</code> 定义的一大堆代码……</p><p>除了简化了默认构造函数，你仍然在此基础上自定义构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 只需括号内声明数据记录类所有的私有数据成员即可 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">    <span class="comment">/* 简化的默认构造函数（被称为 compact constructor），不需要写形参列表、不需要手动对其初始化 */</span></span><br><span class="line">    <span class="keyword">public</span> Person &#123;</span><br><span class="line">        <span class="comment">/* 一般没啥事能做，你可以检查检查传入的参数是否为 null */</span></span><br><span class="line">        Objects.requireNotNull(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 可以重载构造函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">/* 允许委托构造 */</span></span><br><span class="line">        <span class="built_in">this</span>(name, <span class="string">&quot;UNKNOWN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-记录类型的访问器"><a href="#3-1-2-记录类型的访问器" class="headerlink" title="3.1.2 记录类型的访问器"></a>3.1.2 记录类型的访问器</h3><p>和一般的访问器命名法有些差别，记录类型默认的访问器不使用 <code>getXXX</code> 命名，而是使用 <strong>数据成员的名字</strong> 直接命名。</p><p>另外，一般真的不用改记录类型的访问器，如果需要改，那么说明这个类一定不是单纯的数据记录类，请用普通类型定义！</p><h3 id="3-1-3-记录类型的-Object-重写方法"><a href="#3-1-3-记录类型的-Object-重写方法" class="headerlink" title="3.1.3 记录类型的 Object 重写方法"></a>3.1.3 记录类型的 Object 重写方法</h3><p>根据定义，<code>equals</code>、<code>hashCode</code> 一般都不需要你再次重写。</p><p>在某些情况下，你可能想要自定义 <code>toString</code>，这没有问题，就和普通的类重写的方法一样。</p><h3 id="3-1-4-记录类型的静态变量和方法"><a href="#3-1-4-记录类型的静态变量和方法" class="headerlink" title="3.1.4 记录类型的静态变量和方法"></a>3.1.4 记录类型的静态变量和方法</h3><p>虽然不允许有公有可写的属性，但记录类型允许定义 <strong>静态变量、静态方法，它们都可以是公有的</strong>。</p><p>你可以把它们理解成对整个数据类型的配置，或者解释。</p><h2 id="3-2-Java-Bean"><a href="#3-2-Java-Bean" class="headerlink" title="3.2 Java Bean"></a>3.2 Java Bean</h2><p>嗯，实际上，还有一种约定和 Java Record 应用很像的 <strong>Java 类型定义规范</strong>，它的名字是 Java Bean（Java 豆？）。</p><p>没错，Java Bean 是 Java 的一种类型定义规范，和 record 类似，它们的共性是<u>用一个类来盛放一组数据</u>。</p><p>但是，record 追求的是不可变数据类型（数据域不可变性）、一条记录的不可变性和易操作性，而 bean 追求的是：</p><ol><li><p>数据的取出放入的接口不变，保证兼容性；</p></li><li><p>数据序列化（serializable）和<u>传输方便</u>（注：Java Bean 出现的原因就在于此，为了让一组相关数据传输方便）；</p><blockquote><p>不过 Record 也很简单，传输起来也方便，但是不可变，应该看业务需求选择。</p></blockquote></li></ol><p>所以，Java Bean 没有像 record 一样，它规定了一组类型定义方式：</p><ol><li>提供一个默认的无参构造函数；</li><li>需要被序列化并且实现了 Serializable 接口；</li><li>可能有一系列可读写属性，并且一般是 private 的；</li><li>有一系列的 getter 或 setter 方法；</li></ol><p>感性理解一下：想象一下存在这样一个箱子，其内部被分割成几个格子，每个格子用来存放特定的物品，工人取出或者放入物品后封箱，然后叫了个快递把箱子发出去了。这个箱子就是 Java Bean，取出、放入就是 getter、setter，物品就是属性，封箱发出就是序列化和传输。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String newName)</span> &#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> newAge)</span> &#123;</span><br><span class="line">        age = newAge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>Person</code> 类就是合格的 Java Bean（注：<code>Serializable</code> 接口已经在 Java 笔记1 中详细介绍）。</p><h2 id="3-3-Java-Record-与-Java-Bean-的对比"><a href="#3-3-Java-Record-与-Java-Bean-的对比" class="headerlink" title="3.3 Java Record 与 Java Bean 的对比"></a>3.3 Java Record 与 Java Bean 的对比</h2><div class="table-container"><table><thead><tr><th>Java Record</th><th>Java Bean</th></tr></thead><tbody><tr><td>追求不可变数据类型、数据结果表示</td><td>追求数据传输便捷性、数据访问接口规范性</td></tr><tr><td>Java 14+ 使用关键字 record 辅助定义</td><td>纯手工实现约定</td></tr><tr><td>final class，不可被继承，也没有被继承需求</td><td>普通 class，可以被继承</td></tr><tr><td>常用于存放、比较 和 展示数据结果</td><td>常用于完成如数据传输一类的业务逻辑</td></tr></tbody></table></div><h1 id="Chapter-4-反射"><a href="#Chapter-4-反射" class="headerlink" title="Chapter 4. 反射"></a>Chapter 4. 反射</h1><p>Java 中的反射机制是什么？</p><p><img src="imgs/CompileAndExplain.png"></p><p>复习一下 Java 的运行过程。我们知道，Java 虚拟机是一种解释器，是解释 Java 字节码（*.class）的一种程序。其大致运行过程如下：</p><p>运行<strong>类加载器</strong>（ClassLoader）将字节码加载到内存中 —-&gt; 运行<strong>字节码验证器</strong>强制检查 Java 程序合法性和安全性，不符合安全规范的不予运行 —-&gt; 读取内存中的字节码逐句解释为机器码执行；</p><p>可以说，在 Java 源文件编译为字节码之后，就形成了一个个 <code>*.class</code> 文件。这里的每个 <code>*.class</code> 文件都对应着这个类型的必要信息。在 Java 虚拟机中将这些字节码加载到内存中，构建了这个类对应的特殊的表示对象（称为 <code>Class</code> 对象）。这样在引用到这个类的位置就能正确地给出行为。</p><blockquote><p>注意，在 Java 中，<code>Class</code>（首字母大写，和关键字 <code>class</code> 是两回事）本身就是一个类型，是承载类的信息的类（元类，meta-class），它的实例对象就叫 <code>Class</code> 对象。</p></blockquote><p>而所谓的反射，可以说是上面的过程的运行时逆过程：</p><p><u><strong>Java 的反射就是从加载到内存中的 <code>Class</code> 对象，反向获取其中的信息</strong></u>（或者说，反向映射）。</p><h2 id="4-1-反射的意义使用场景"><a href="#4-1-反射的意义使用场景" class="headerlink" title="4.1 反射的意义使用场景"></a>4.1 反射的意义使用场景</h2><p>不过在介绍反射之前，首先谈谈它的坏处：</p><ul><li>破坏了类的封装性（因为反射是从 <code>Class</code> 对象反向获取信息，因此突破了类型可见性修饰符的约束，可以访问某个类的私有成员）；</li><li><p>运行时确定类型，性能肯定不好，丢掉了静态类型语言的性能优势；</p></li><li><p>运行安全问题。</p></li></ul><p>如此重要的缺点，已经注定了 Java 的反射机制不应该被随便使用，并且大部分场合下并不适合使用反射。</p><p>但是因为反射的重要功能，少数场合又不得不用。举几个例子：</p><ul><li>Java codelinter 静态类型代码检查。比如 IDEA 的 LSP Server 在探查某个对象的方法和属性的时候（你在 IDEA 里写个对象，后面加个点就能弹出一堆方法和属性提示），除了分析上下文定义的方法以外，一种重要的手段就是通过反射分析；</li><li>大型框架（例如 Springboot）很多都是配置化的（例如通过 XML 文件配置 Bean），为了保证框架的通用性，可能需要根据配置文件加载不同的类或者对象、调用不同的方法。这个时候就必须使用到反射了，它可以完成 “运行时动态加载需要的加载的对象” 的任务；</li><li>Java 加载某些数据库驱动的时候，需要运行时动态构建类型信息，使用时就要用反射机制；</li><li>某些注解的行为需要反射（下一章 “注解” 所需要了解的知识）。</li></ul><h2 id="4-2-反射-API"><a href="#4-2-反射-API" class="headerlink" title="4.2 反射 API"></a>4.2 反射 API</h2><p>了解它的地位后，在开始使用它。使用 Java 的反射就是使用 <code>java.lang.Class</code> 和 <code>java.lang.reflect.*</code> 的所有 API。</p><p>首先列出可能用到的类型：</p><div class="table-container"><table><thead><tr><th>Java 类型</th><th>类型说明</th></tr></thead><tbody><tr><td><code>Class</code></td><td>用来在内存中描述一个 Java 类（所有继承于 Object 的类）</td></tr><tr><td><code>Constructor</code></td><td>用来在内存中描述一个 Java 类的构造函数信息，包括访问权限和动态调用信息等</td></tr><tr><td><code>Field</code></td><td>用来在内存中描述一个 Java 类或者 Java 接口的数据成员（或者说属性）信息，包括访问权限和动态修改等</td></tr><tr><td><code>Method</code></td><td>用来在内存中描述一个 Java 类或者 Java 接口的成员函数（或者说方法）信息，包括包括访问权限和动态调用信息等</td></tr><tr><td><code>Modifier</code></td><td>用来在内存中描述一个 Java 类或者 Java 接口的所有成员（包括属性、方法）的修饰属性，例如 <code>public/private/static/final/synchronized/abstract</code> 等信息</td></tr></tbody></table></div><h3 id="4-2-1-Class-类型与-Class-实例"><a href="#4-2-1-Class-类型与-Class-实例" class="headerlink" title="4.2.1 Class 类型与 Class 实例"></a>4.2.1 <code>Class</code> 类型与 <code>Class</code> 实例</h3><p>我们知道了，反射需要根据内存中的 <code>Class</code> 对象进行操作，那么怎么得到一个普通类型所对应的 <code>Class</code> 对象呢？Java 提供了 3 种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;Object&gt; 表示任意类型，只要是 Object 的子类 */</span></span><br><span class="line"><span class="comment">/* &lt;Object Instance&gt; 表示任意类型对应的实例对象 */</span></span><br><span class="line">[Method]             &lt;Object Instance&gt;.getClass() -&gt; Class Instance;</span><br><span class="line">[Static Property]     &lt;Object&gt;.class -&gt; Class Instance;</span><br><span class="line">[Static Method]        Class.forName(String className) -&gt; Class Instance;</span><br></pre></td></tr></table></figure><p>下面以获取 <code>String</code> 类对应的 <code>Class</code> 对象为例。</p><ul><li><p>通过该类（一定继承于基类 <code>Object</code>）的实例 中的 <code>getter</code> 方法：<code>&lt;Object&gt;.getClass()</code>；</p><p>这个方法返回是这个对象所在的类型 的对应 <code>Class</code> 实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取的 stringClass 实例对象就是 String 类型在 JVM 内存中对应的 Class 对象 */</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> name.getClass();</span><br></pre></td></tr></table></figure></li><li><p>通过该类的<strong>静态属性</strong>获得这个类所对应的 <code>Class</code> 实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure></li><li><p>利用 <code>Class</code> 类型提供的静态方法，通过类名字符串查找当前内存中的 Class 对象；</p><blockquote><p>这种方法最常用，因为使用反射的时候，几乎都是不知道对象、不知道类型定义、只知道类型名的情况。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;String&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>知道类如何获取某个类型的 <code>Class</code> 对象，那么可以对这个 <code>Class</code> 对象进行哪些操作呢？</p><ul><li><p>判断任意对象是否是这个 <code>Class</code>  对象描述的类的实例，或者其他什么东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* obj 是否是这个 Class 对象描述的类型的实例 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Object obj)</span>;    <span class="comment">/* [Method] */</span></span><br><span class="line"><span class="comment">/* 这个 Class 对象描述的类型是否是 Interface 类型 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterface</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isArray</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isPrimitive</span><span class="params">()</span>;    <span class="comment">/* 判断基本类型 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isAnnotation</span><span class="params">()</span>;    <span class="comment">/* 判断注解 */</span></span><br></pre></td></tr></table></figure></li></ul><p>下面以这个 <code>Class</code> 类型存放的是普通 Java 类为例，叙述常见的方法。</p><blockquote><p>如果 <code>Class</code> 对象中描述的是注解，那么在下一章 “注解” 进行介绍。</p><p>如果 <code>Class</code> 对象中描述的是接口，那么只能获取一些成员信息，可能能调用一些静态方法或属性。</p></blockquote><ul><li><p>从 <code>Class</code> 对象创建实例（哪怕源码中没有这个类的定义也行，只要内存中有这个 <code>Class</code> 对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 按默认构造函数创建实例 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">newInstance</span><span class="params">()</span>;        <span class="comment">/* [Method] */</span></span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Class</code> 对象对应类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取 Class 对象描述的类型的：所有&quot;公有的&quot;构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> Constructor[] getConstructors();</span><br><span class="line"><span class="comment">/* 获取所有的构造方法(包括私有、受保护、默认、公有) */</span></span><br><span class="line"><span class="keyword">public</span> Constructor[] getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取指定的构造函数 */</span></span><br><span class="line"><span class="comment">/* 这里的参数列表是各个参数类型对应的 Class 对象！ */</span></span><br><span class="line"><span class="keyword">public</span> Constructor <span class="title function_">getConstructor</span><span class="params">(Class... parameterTypes)</span>;</span><br><span class="line"><span class="keyword">public</span> Constructor <span class="title function_">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Class</code> 对象对应类的数据成员（属性，静态修饰不作单独区分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取 Class 对象描述的类型的：所有&quot;公有的&quot;属性 */</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields();</span><br><span class="line"><span class="comment">/* 获取所有的属性(包括私有、受保护、默认、公有) */</span></span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取指定名称的属性 */</span></span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getField</span><span class="params">(String fieldName)</span>;</span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getDeclaredField</span><span class="params">(String fieldName)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Class</code> 对象对应类的成员函数（方法，静态修饰不作单独区分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取 Class 对象描述的类型的：所有&quot;公有的&quot;方法 */</span></span><br><span class="line"><span class="keyword">public</span> Method[] getMethods();</span><br><span class="line"><span class="comment">/* 获取所有的属性(包括私有、受保护、默认、公有) */</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取指定名称的属性 */</span></span><br><span class="line"><span class="comment">/* 和构造函数不一样，这里需要先给定方法名 */</span></span><br><span class="line"><span class="keyword">public</span> Method <span class="title function_">getMethod</span><span class="params">(String methodName, Class... parameterTypes)</span>;</span><br><span class="line"><span class="keyword">public</span> Method <span class="title function_">getDeclaredMethod</span><span class="params">(String methodName, Class... parameterTypes)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Class</code> 对象对应类的修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取类型自身的修饰符 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-2-Constructor-类型"><a href="#4-2-2-Constructor-类型" class="headerlink" title="4.2.2 Constructor 类型"></a>4.2.2 <code>Constructor</code> 类型</h3><p>在介绍 <code>Class</code> 类型时，我们了解了如何得到 <code>Constructor</code>（该类的构造函数信息）对象，那么应该如何操作它？</p><p>最常用的方法是 <strong>调用这个构造函数</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* T 为泛型 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> T <span class="title function_">newInstance</span><span class="params">(Object... parameterTypes)</span>;</span><br></pre></td></tr></table></figure><p>警告：这里的参数类型必须要和取得 <code>Constructor</code> 对象时传入的形参类型一致。否则运行时错误。</p><p>还可以获取 <code>Constructor</code> 的其他信息，具体请看官方文档。</p><h3 id="4-2-3-Field-类型"><a href="#4-2-3-Field-类型" class="headerlink" title="4.2.3 Field 类型"></a>4.2.3 <code>Field</code> 类型</h3><p>在介绍 <code>Class</code> 类型时，我们了解了如何得到 <code>Field</code>（该类的属性）对象，那么应该如何操作它？</p><p>常用的方法是，按查找到的属性信息设置对象属性、读取对象属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object target, Object value)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(Object target)</span>;</span><br></pre></td></tr></table></figure><p>这里为什么要给 <code>target</code> 参数呢？因为我们得到的 <code>Field</code> 对象只是保存了原来类型属性的一部分信息，不能指明这个属性是属于具体哪个对象的。所以取值和设置时需要给定对象。</p><p>警告：这里的 <code>value</code> 必须和取得 <code>Field</code> 对象时原本类型一致，否则运行时错误。</p><p>对于私有成员，想要访问它前需要强制越过可见性修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(<span class="type">boolean</span> available)</span>;</span><br></pre></td></tr></table></figure><p>可能产生的异常有 <code>FieldNotFoundException</code>，<code>IllegalAccessException</code> 等等；</p><p>还可以获取 <code>Field</code> 的其他信息，具体请看官方文档。</p><h3 id="4-2-4-Method-类型"><a href="#4-2-4-Method-类型" class="headerlink" title="4.2.4 Method 类型"></a>4.2.4 <code>Method</code> 类型</h3><p>在介绍 <code>Class</code> 类型时，我们也了解了如何得到 <code>Method</code>（该类的方法）对象，那么应该如何操作它？</p><p>常用的方法是，调用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> ObjectObject <span class="title function_">invoke</span><span class="params">(Object target, Object... parameters)</span>;</span><br></pre></td></tr></table></figure><p>如果是私有方法，也需要通过 <code>setAccessible</code> 调整访问可见性。</p><p>还可以获取 <code>Method</code> 的其他信息，具体请看官方文档。</p><h3 id="4-2-5-Modifier-类型"><a href="#4-2-5-Modifier-类型" class="headerlink" title="4.2.5 Modifier 类型"></a>4.2.5 <code>Modifier</code> 类型</h3><p>其实，除了 <code>Class</code> 类型，其他的 <code>Constructor/Field/Method</code> 类型都可以调用 <code>getModifiers()</code> 获取当前字段的修饰符。返回值是 <code>int</code>，但是可以通过 <code>Modifier</code> 静态方法转为可读的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>可以表示的修饰符不仅有可见性修饰符，还有各种像 <code>native / synchronized / transient / volatile / abstract / final / interface</code> 等等，都可以检查到，使用对应的 <code>isXXX()</code> 实例方法即可。</p><h3 id="4-2-6-反射的使用实例"><a href="#4-2-6-反射的使用实例" class="headerlink" title="4.2.6 反射的使用实例"></a>4.2.6 反射的使用实例</h3><ul><li>反射越过泛型检查；</li><li>大型框架（以 SpringMVC 为例）字段名一类的数据类型配置反射处理相当简洁清晰；</li><li>自定义注解（写 <code>RUNTIME</code> 注解逻辑，下一章详细叙述）；</li></ul><h1 id="Chapter-5-注解"><a href="#Chapter-5-注解" class="headerlink" title="Chapter 5. 注解"></a>Chapter 5. 注解</h1><p>Java 中一种语法称为注解，可能在大部分其他的语言中都有。在 Python / TypeScript 中，这种类似的做法称为 “装饰器”。</p><blockquote><p>严格来说，Java 的注解和 Python / TypeScript 的装饰器的机制不一样。因为前者只是改变了执行方式，而后者相当于是一种语法糖，处理后替换了被装饰的对象。但是它们的语法和最终作用真的很像。</p></blockquote><p>这种做法的特征是，在<u>不改变原代码内容和逻辑</u>的基础上，进行一些修饰和包装（就像给解释器注解这段代码的执行方式一样），使得解释执行（或者编译）这段代码时的方式有些许改变。</p><p>你没看错，“注解“ 这个东西本身，不会对原先的代码的逻辑有任何影响（<u>这段代码编译出的字节码不会变</u>），只是<u>做个标记，告诉即将要读取这个注解的对象（可能是编译器、加载器，或者是程序中的其他代码），用约定好的方式来执行这段代码</u>（比如执行之前、执行之后插入了一些其他流程）。</p><h2 id="5-1-注解的使用和分类"><a href="#5-1-注解的使用和分类" class="headerlink" title="5.1 注解的使用和分类"></a>5.1 注解的使用和分类</h2><p>你也许会在一些代码中见到这样的书写方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(<span class="meta">@Param</span> String name)</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Resource(&quot;Hello&quot;)</code> 是有参数的注解，<code>@PostConstruct / @Override</code> 是无参数的注解；</p><p><code>@Resource(&quot;Hello&quot;)</code> 在这个例子中是修饰类的注解，<code>@PostConstruct / @Override</code> 在这个例子中是修饰方法的注解，<code>@Param</code> 在这个例子中是修饰形参的注解。</p><p>注解的使用语法就这些，无非是无参数的 <code>@&lt;AnnotationName&gt;</code>，或者有参数的 <code>@&lt;AnnotationName&gt;(...)</code>，加在它们所指定的对象头部位置。</p><p>要掌握好注解的使用方法，就先把它们按使用特征分类。一般来说，注解是按处理阶段进行分类：</p><ul><li><p>写给编译器看的注解（称为 <strong>编译时注解，Compile-time Annotation</strong>）。</p><p><u>这类注解不会被编译进入 <code>.class</code> 字节码文件，它们在编译后就被编译器扔掉了</u>；举例：</p><ul><li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写（C++ <code>override</code> 关键字有同样的功能）；</li><li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li></ul></li><li><p>写给 <code>classLoader</code> 或者其他加载时 ~ 运行时的工具看的注解（称为 <strong>加载时注解，Load-time Annotation</strong>）。</p><p><u>这类注解会被编译进入 <code>.class</code> 文件，但加载结束后并不会存在于内存中</u>。这类注解只被一些底层库使用，一般我们不必自己处理。</p><p>比如有些工具会在加载 class 的时候，对 class 做动态修改，实现一些特殊的功能。</p></li><li><p>写给运行时某一部分代码看的注解（称为 <strong>运行时注解，Run-time Annotation</strong>）。</p><p>就算是运行时注解，JVM 也并不会通过注解主动进行一些操作。<u>只有部分代码通过 <strong>反射</strong> 读取指定的注解，进行业务逻辑的执行</u>。</p><p><u>这也是最常用的注解形式，在许多框架中都会出现</u>。</p></li></ul><h2 id="5-2-自定义注解"><a href="#5-2-自定义注解" class="headerlink" title="5.2 自定义注解"></a>5.2 自定义注解</h2><p>有些情况下（比如使用框架），你可能会用很多预先定义的注解，但是你很好奇这些注解是怎么运作的，于是你就要了解，一个注解是如何定义、如何生效（进行处理）的。</p><p>搞清楚一个东西的最好方法就是从头开始做一遍，于是你准备动手搓一个自定义的注解出来。</p><h3 id="5-2-1-注解的定义-和-实质"><a href="#5-2-1-注解的定义-和-实质" class="headerlink" title="5.2.1 注解的定义 和 实质"></a>5.2.1 注解的定义 和 实质</h3><p>Java 规定，注解使用 <code>@interface</code> 关键字定义注解。最基本的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFirstAnnotation &#123;</span><br><span class="line">    <span class="comment">/* 强烈建议为注解的每个数据域都设置一个默认值 */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">intData</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">stringData1</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">stringData2</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">/* 建议最常用的数据域名称设置为 value */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的定义和 Java 的记录类型一样简洁，<u>只需要声明要传给注解的参数即可（这些参数直接以访问器的形式定义，如上），不需要定义任何处理逻辑！</u></p><p>因为注解的处理交由某些特定的代码完成（下一节介绍），注解的定义本身 <strong>就仅仅是一个 “注解”，或者说等待处理的标识而已</strong>。</p><p>此外，还需要搞清楚一件事：注解的实质就是一个 Java 类型。所有的注解都继承于接口 <code>java.lang.annotation.Annotation</code>；因此，上面的定义方法只不过也是一种语法糖罢了。</p><p>但是，只有这个定义还不够描述这个注解，比如，<strong><u>这个注解是前面分类中的什么类型？应该在什么阶段、被谁处理（生命周期）？允许修饰谁？</u></strong></p><p>这些信息 <strong>可以交给描述注解的注解，也就是元注解（meta-annotation），来完成</strong>。</p><p>Java 标准库中定义了一大批实用的元注解，所以一般不需要我们自己定义元注解，只要知道怎么使用元注解来定义注解就可以了。常用的元注解如下：</p><ul><li><p><code>@Target(&lt;ElementType/ElementTypes[]&gt;)</code> 元注解：<strong>解释当前注解所能修饰的对象类型</strong>。</p><blockquote><p>参数取值：<code>ElementType.TYPE</code>（允许修饰类、接口），<code>ElementType.FIELD</code>（允许修饰属性），<code>ElementType.METHOD</code>（允许修饰方法），<code>ElementType.CONSTRUCTOR</code>（允许修饰构造函数），<code>ElementType.PARAMETER</code>（允许修饰方法的形式参数）；</p></blockquote></li><li><p><code>@Retention([RetentionPolicy])</code> 元注解：<strong>解释当前注解的声明周期（指定注解类型）</strong>。</p><blockquote><p>可选参数取值：<code>RetentionPolicy.SOURCE</code> 编译时注解、<code>RetentionPolicy.CLASS</code> 加载时注解（默认）、<code>RetentionPolicy.RUNTIME</code> 运行时注解；</p></blockquote></li><li><p><code>@Repeatable(&lt;Annotation Class Instance&gt;)</code> 元注解：<strong>解释当前注解是否可以重复注解同一对象</strong>。</p><blockquote><p>要用的话，直接在注解的定义头部加上 <code>@Repeatable(&lt;AnnotationName&gt;.class)</code>；</p><p>这里需要反射方法传入自定义注解类对应的 <code>Class</code> 对象。</p></blockquote></li><li><p><code>@Inherited</code> 元注解：<strong>解释当前注解是否可继承</strong>。当且仅当 <code>@Target</code> 参数为 <code>ElementType.TYPE</code> 时有效。</p><blockquote><p>这个元注解的意思是，当前注解能不能随着继承交给子类。</p></blockquote></li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个注解只能修饰方法 */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFirstAnnotation &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">intData</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">stringData1</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">stringData2</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个注解既能修饰方法，又能修饰属性 */</span></span><br><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFirstAnnotation2 &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">intData</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">stringData1</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">stringData2</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以注解方法和构造函数的 运行时注解 */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.CONSTRUCTOR</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFirstAnnotation1 &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">intData</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">stringData1</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">stringData2</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-运行时注解的处理"><a href="#5-2-2-运行时注解的处理" class="headerlink" title="5.2.2 运行时注解的处理"></a>5.2.2 运行时注解的处理</h3><p>由于其他两类注解一般用不到（编译时注解由编译器使用，因此我们一般只使用，不编写；加载时注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到），因此此处仅叙述运行时注解的处理。</p><p>从现在开始，下文中的所有 “注解” 都指代 “运行时注解”。</p><p>我们知道，注解本身只是个注解，<u>如果你不做任何处理，那么它将对原本的代码毫无影响，就像注释一样。</u></p><p>我们还知道，注解只是一个 Java 类而已，但是这个类只存放一些参数，不与外界代码有任何关联。</p><p>所以处理注解的方法一目了然：<u>使用上一章介绍的反射机制</u>，不仅能找到所有规定类型的注解，还能让注解发挥指定的效果。</p><p>上一章中，我们只介绍了关于类型、接口的反射 API，这里我们补充一下针对注解的反射 API：</p><ul><li><p>判断 <code>Class</code> 对象本身是否描述的是注解：<code>public boolean isAnnotation();</code>；</p></li><li><p>判断注解是否存在于指定对象上：<code>isAnnotationPresent(&lt;Class Object of Annotation&gt;)</code>；</p><blockquote><p>这个方法在 <code>Class / Field / Method / Constructor</code> 类型中都有。</p></blockquote></li><li><p>从指定对象上获取注解对象：<code>getAnnotation(&lt;Class Object of Annotation&gt;)</code>；</p><blockquote><p>这个方法在 <code>Class / Field / Method / Constructor</code> 类型中都有。</p><p>注意：<u>可能会返回 <code>null</code>，所以使用前请用 <code>isAnnotationPresent</code> 检查！</u></p></blockquote></li><li><p>从方法 / 构造函数中获得参数注解对象：<code>getParameterAnnotations() -&gt; Annotation[][]</code>；</p><blockquote><p>只有在 <code>Method / Constructor</code> 中存在。</p></blockquote></li></ul><p>再回想一下，注解是个类型，里面装的全是传入参数，并且直接提供各个传入参数的访问器方法。</p><p>有了以上的知识，就能写一个自定义的注解了。</p><h3 id="5-2-3-实战：自定义一个运行时注解"><a href="#5-2-3-实战：自定义一个运行时注解" class="headerlink" title="5.2.3 实战：自定义一个运行时注解"></a>5.2.3 实战：自定义一个运行时注解</h3><p>考虑一个需求，我想定义一个修饰属性的运行时注解，如果这个参数是整数，就限制这个参数的范围为注解参数给定的范围；如果这个参数是字符串，那么限制的是字符串长度。其中最大、最小值可选。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File: Range.java */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span>: <span class="keyword">default</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span>: <span class="keyword">default</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* File: RangeChecker.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RangeChecker</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(T obj)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        Class&lt;?&gt; objCls = obj.getClass();</span><br><span class="line">        <span class="keyword">for</span> (Field f: objCls.getFields()) &#123;</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (f.isAnnotationPresent(Range.class)) &#123;</span><br><span class="line">                <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> f.getAnnotation(Range.class);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">originVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    originVal = f.get(obj);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException err) &#123;</span><br><span class="line">                    <span class="comment">/* Controls never reaches here. */</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (originVal <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + f.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (originVal <span class="keyword">instanceof</span> Integer i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; range.min() || i &gt; range.max()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + f.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考一下，<code>RangeChecker</code> 应该什么时候被使用？没错，这取决于你的业务逻辑。注解是 “惰性的”，只有你显式调用注解处理方法，注解的处理才会开始。</p><h1 id="Chapter-6-Functional-Interface"><a href="#Chapter-6-Functional-Interface" class="headerlink" title="Chapter 6. Functional Interface"></a>Chapter 6. Functional Interface</h1><h2 id="6-1-Definitions-and-Examples"><a href="#6-1-Definitions-and-Examples" class="headerlink" title="6.1 Definitions and Examples"></a>6.1 Definitions and Examples</h2><p>Java 中的一个重要特性：函数式接口。实际上，它的规范定义是：</p><p><strong><u>任何一个只存在单一抽象方法（SAM）的接口，都称之为函数接口</u></strong>。</p><p>函数接口提供了和 TypeScript 类似的能力，它让我们可以不那么看重函数签名，仅仅从函数类型（参数、返回值类型）将函数归类。接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>这还可以让我们轻易地将一个函数作为一个参数 / 返回值，实现函数式编程。</p><p>例如，我们可以显式声明使用函数接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, String&gt; intToString = Object::toString;</span><br><span class="line">Function&lt;String, String&gt; quote = s -&gt; <span class="string">&quot;&#x27;&quot;</span> + s + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* compose 是函数接口的接口方法，可以将函数接口组合执行 */</span></span><br><span class="line">Function&lt;Integer, String&gt; quoteIntToString = quote.compose(intToString);</span><br><span class="line"><span class="comment">/* apply 是函数接口的接口方法，执行这个函数接口的实现 */</span></span><br><span class="line">assertEquals(<span class="string">&quot;&#x27;5&#x27;&quot;</span>, quoteIntToString.apply(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 再例如这段业务代码 */</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;EventDto&gt; <span class="title function_">findEventByUuid</span><span class="params">(Long uuid)</span> &#123;</span><br><span class="line">    Optional&lt;Event&gt; event = eventRepository.findByUuidAndNotDeleted(uuid);</span><br><span class="line">    <span class="comment">/* Optional.map 的参数就是一个函数接口，可以更方便、清晰地处理内容的映射关系 */</span></span><br><span class="line">    <span class="keyword">return</span> event.map(Event::mapToEventDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用 <code>new</code> 立即定义、实例化一个函数接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java 中创建一个线程，其中参数类型 Runnable 就是一个函数接口 */</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New thread created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这种原地重载实例化接口的方法，我们可以称为匿名的接口实现。</span></span><br><span class="line"><span class="comment"> * 缺点是接口实现不能复用，优点是代码简洁。</span></span><br><span class="line"><span class="comment"> * 这对于其他任何 interface 都是可行的（不是函数接口也行） */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* P.S. 如果你写了上面的函数接口的匿名实现，在 IDEA 中会提醒你换成匿名函数更简洁 */</span></span><br><span class="line"><span class="comment">/* 这样 Java 就越来越像 TypeScript 了（bushi */</span></span><br></pre></td></tr></table></figure><p>此外，我们所熟知的 Java Lambda 函数（匿名函数）就是一种函数接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; <span class="keyword">new</span> <span class="title class_">HelloClass</span>()</span><br></pre></td></tr></table></figure><p>除了匿名函数，一个类中的静态方法、在同一个类中使用的实例方法都能通过 <code>::</code> 作用域符来<strong><u>转换</u></strong>为函数接口，例如：</p><p>在任意一个类方法中使用 <code>Object::toString</code>（实例方法省略传递 <code>self</code>）、使用静态方法 <code>MyClass::aStaticMethod</code> 等等。</p><h2 id="6-2-Primitive-Function-Specializations"><a href="#6-2-Primitive-Function-Specializations" class="headerlink" title="6.2 Primitive Function Specializations"></a>6.2 Primitive Function Specializations</h2><p>对于 Java primitive types（基本类型），我们没法将它们作为 generic type argument（泛型参数），所以这个时候就必须这么定义基本类型的函数接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ShortToByteFunction</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="title function_">applyAsByte</span><span class="params">(<span class="type">short</span> s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就能操作含有基本类型的函数，作为函数接口了！也可以把它作为参数、返回值，进行便捷的函数式操作。</p><blockquote><p>是不是越看越像 C++ 的函数指针？</p></blockquote><h2 id="6-3-Cosumers-amp-Suppliers"><a href="#6-3-Cosumers-amp-Suppliers" class="headerlink" title="6.3 Cosumers &amp; Suppliers"></a>6.3 Cosumers &amp; Suppliers</h2><p>Suppliers 在 Java 中定义为 <strong><u>不含参数、只有返回值的 函数接口</u></strong>。它常被用在：</p><ul><li><p>数据计算 / 大型对象创建等需要 Lazy Load 的场景，只是先拿到 supplier，真正需要结果的时候才进行计算，实现过程的解耦；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 举例：提供创建对象的方法 */</span></span><br><span class="line">() -&gt; <span class="keyword">new</span> <span class="title class_">ComplicatedClass</span>()</span><br></pre></td></tr></table></figure></li><li><p>大型序列的 Lazy Generate 的场景，类似 Python 的生成器/迭代器，只有获取下一个元素时才进行计算，极大节省资源，例如一个 Fibbonacci 生成器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] fibs = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; fibonacci = Stream.generate(() -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> fibs[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">fib3</span> <span class="operator">=</span> fibs[<span class="number">0</span>] + fibs[<span class="number">1</span>];</span><br><span class="line">    fibs[<span class="number">0</span>] = fibs[<span class="number">1</span>];</span><br><span class="line">    fibs[<span class="number">1</span>] = fib3;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>Consumers 则与 Suppliers 相反，定义为 <strong><u>没有返回值、只含参数的 函数接口</u></strong>。它的应用场景比 Suppliers 更少，通常它隐含着 “side effect” 的含义。</p><p>我们也可以在日志逻辑中见到它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.forEach(name -&gt; log.debug(<span class="string">&quot;Hello, &quot;</span> + name));</span><br></pre></td></tr></table></figure><h2 id="6-4-Predicates-amp-Operators"><a href="#6-4-Predicates-amp-Operators" class="headerlink" title="6.4 Predicates &amp; Operators"></a>6.4 Predicates &amp; Operators</h2><p>在数学上有对应概念的函数接口分别是谓词断言函数 和 操作符。</p><p>谓词断言函数（predicates），可以定义为 参数是一个或多个值、返回值为 boolean 类型的函数接口。在数学上对应的概念：谓词。</p><p>我们常常在 <code>filter</code>、<code>find</code> 这样的接口中见到，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; namesWithA = names.stream()</span><br><span class="line">  .filter(name -&gt; name.startsWith(<span class="string">&quot;A&quot;</span>)    <span class="comment">/* predicates */</span>)</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>操作符（operators），可以定义为 参数（一个或多个）和返回值类型相同的函数接口。</p><p>我们经常在使用 Collection API 时能见到，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; values = Arrays.asList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> values.stream()</span><br><span class="line">  .reduce(<span class="number">0</span>, (i1, i2) -&gt; i1 + i2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;UserDto&gt; <span class="title function_">findUserByUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">    List&lt;User&gt; res = userRepository.findUserByUsername(username);</span><br><span class="line">    <span class="keyword">return</span> res.stream()</span><br><span class="line">        .map(UserService::mapToUserDto)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;i&gt;Reference: Oracle Documentation&lt;/i&gt;&lt;/p&gt;
&lt;h1 id=&quot;Chapter-3-Java-Record-amp-Java-Bean&quot;&gt;&lt;a href=&quot;#Chapter-3-Java-Record-amp-Java-Bean&quot; cl</summary>
      
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
    <category term="Java" scheme="https://sjtuxhw.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Notes: ECF &amp; I/O</title>
    <link href="https://sjtuxhw.top/2024/04/16/CSAPP-Notes-ECF-I-O/"/>
    <id>https://sjtuxhw.top/2024/04/16/CSAPP-Notes-ECF-I-O/</id>
    <published>2024-04-16T05:58:54.000Z</published>
    <updated>2024-05-16T11:34:39.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-13-Exceptional-Control-Flow"><a href="#Chapter-13-Exceptional-Control-Flow" class="headerlink" title="Chapter 13. Exceptional Control Flow"></a>Chapter 13. Exceptional Control Flow</h1><blockquote><p>对应书中第 8 章。</p></blockquote><p>异常控制流是现代计算机系统的一个相当重要的部分。</p><h2 id="13-1-Control-Flow"><a href="#13-1-Control-Flow" class="headerlink" title="13.1 Control Flow"></a>13.1 Control Flow</h2><ul><li><p>控制流：从机器打开到关闭的过程中，处理器只做一件事：<strong>读指令、执行指令，一个周期做一个指令</strong>。多核的机器则每个核心依次交替执行指令。这些<strong>指令序列</strong>被称为控制流。硬件正在执行的<strong>实际指令序列</strong>就被称为<strong>物理控制流</strong>。</p></li><li><p>改变内存中控制流的方法：<strong>分支 &amp; 跳转</strong>，<strong>过程调用 &amp; 返回</strong>（Branches &amp; Jumps &amp; Procedure call and return）；</p><blockquote><p><strong>都是对于程序状态变化的处理</strong>。</p></blockquote></li></ul><p>但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）；</p><p>什么是 “系统级别的状态变化”？</p><ul><li>数据从磁盘 / 网卡到达内存中；</li><li>I/O 设备输入 Ctrl+C；</li><li>系统分时复用的时钟到期了，接下来要打断当前执行的进程；</li><li>除零指令；</li><li>……</li></ul><p>这些事件不能指望应用程序的开发者来解决（应用程序的开发者只负责开发正常的程序控制流），而这应该是 OS 需要处理的事情。为了高效处理以上在执行程序中出现的或意外、或故意的系统级状态变更的情况，OS 有一套策略：<strong>异常控制流（Exception control flow，简称 ECF）</strong>来处理上述情况，这样很多事件就无需应用开发者来考虑了。</p><h2 id="13-2-Exception-Control-Flow-Overview"><a href="#13-2-Exception-Control-Flow-Overview" class="headerlink" title="13.2 Exception Control Flow: Overview"></a>13.2 Exception Control Flow: Overview</h2><p>异常控制流的重要特征之一在于，它们会改变系统级别的状态，<strong>而且存在于计算机系统的各个层级</strong>：</p><p>首先是底层级 ECF 的机制：</p><ol><li><strong>Exception</strong>（异常，又称 <strong>Hardware ECF（硬件异常控制流）</strong>，和我们平时编程的软件异常处理不是一个概念）<ul><li>作用：<strong>响应某些底层系统事件（A System Event）的控制流的变化</strong>；</li><li>实现方法：硬件与操作系统的配合；</li></ul></li></ol><p>再看高级别（既指抽象层面，又指逻辑层面，这意味着下面的机制可能利用到，或者包含了上面的 Exception）的 ECF 的机制：</p><ol><li><strong>Process Context Switch</strong>（进程上下文切换）<ul><li>作用：使操作系统在两个进程间无缝切换；</li><li>实现方法：硬件时钟和操作系统的配合；</li></ul></li><li><strong>Signals</strong>（信号）<ul><li>作用：应用、操作系统、硬件三者之间的异常（不是错误，而是指在上层应用程序正常控制流以外的部分）通信；</li><li>实现方法：操作系统控制；</li></ul></li><li><strong>Nonlocal Jumps</strong>（非本地跳转）<ul><li>作用：<strong>应用程序开发者层面（而非操作系统层面）主动更改程序正常控制流（上面介绍的分支跳转、调用返回），无视正常控制流的规则</strong>（例如不需要等到一个函数返回，就跳到另一个函数执行）；</li><li>实现方法：因为是用户级别，所以由 C library 提供：<code>setjmp()</code>、<code>longjmp()</code>；</li></ul></li></ol><p>了解完计算机中各个层面的 <strong>4 大类 ECF 机制</strong>，我们开始深入探讨各个机制的运作原理。</p><h2 id="13-3-Exception-Control-Flow-Exception"><a href="#13-3-Exception-Control-Flow-Exception" class="headerlink" title="13.3 Exception Control Flow: Exception"></a>13.3 Exception Control Flow: Exception</h2><h3 id="13-3-1-Definitions"><a href="#13-3-1-Definitions" class="headerlink" title="13.3.1 Definitions"></a>13.3.1 Definitions</h3><p>一个异常就是<strong>为了应对一些（软件 / 硬件的）事件，控制流由程序转移到 OS kernel 的过程</strong>。</p><blockquote><ol><li>什么是操作系统内核（OS Kernel）？</li></ol><p>内核是<strong>操作系统在内存中驻留的部分</strong>，你可以理解成当前加载到内存的、运行中的操作系统代码；</p><ol><li>Exception 定义中的 “事件” 具体有哪些？</li></ol><ul><li>除零、算数溢出、page fault（页错误）、I/O 请求完成、键盘设备输入 Ctrl + C；</li><li>……</li></ul></blockquote><h3 id="13-3-2-Process-Procedure"><a href="#13-3-2-Process-Procedure" class="headerlink" title="13.3.2 Process Procedure"></a>13.3.2 Process Procedure</h3><p>Exception 的处理过程如下：</p><p><img src="imgs/exception_flow.png" height="200px"></p><ol><li><p>如图所示，因为以上的事件（event）而改变了系统状态，执行到 $I_{current}$ 的用户代码被立即暂停，此时 exception 将控制权从用户代码转移到内核态代码。这部分内核代码被称为 <strong>exception handler（异常处理程序）</strong>；</p></li><li><p>接着，内核执行异常处理程序代码来处理这个事件，过程被称为 <strong>exception processing（异常处理）</strong>；</p></li><li><p>处理结束后，通常有 3 种情况：返回到原先被打断的指令位置（$I_{current}$，已执行）、返回到被打断的指令的下一条（$I_{next}$，未执行）、终止原用户程序执行。</p></li></ol><h3 id="13-3-3-Implementations-of-Exception"><a href="#13-3-3-Implementations-of-Exception" class="headerlink" title="13.3.3 Implementations of Exception"></a>13.3.3 Implementations of Exception</h3><p>前面介绍过，Exception 是由 OS 和硬件共同实现的，那么具体实现是什么？</p><p>事实上，控制流想要改变，必须依靠硬件改变程序计数器（PC，或者说前面提到的 <code>%rip</code>）。由于 Exception handler 的代码又位于 Kernel code 中，所以实现就很清楚了：</p><ol><li><p><strong>OS 负责组织 Exception Handler 的代码，来处理可能的 Exception</strong>；</p></li><li><p><strong>硬件负责在 Event 出现的时候改变 <code>%rip</code>，使控制流转向 Exception Handler</strong>；</p></li></ol><p>等等，还有一个问题，OS 会预先编写很多类 Exception Handler 以应对不同 Exception 的情况，那么硬件在 Event 发生时，怎么知道转向哪一个 Exception Handler？所以还有一条、再改正一条：</p><ol><li><p><strong>硬件负责在 Event 出现时按种类改变 Exception Table Base Register，通过这个寄存器取得 Exception Table 中存放的 Exception Handler 的地址（硬件规定是虚拟地址），把取得的地址置于 <code>%rip</code> 中，完成转向</strong>；</p></li><li><p>OS 负责在 Kernel 中组织 <strong>Exception Table（异常表）</strong>，告诉硬件何种 event 对应何种 Exception Handler 的地址；</p></li></ol><blockquote><p>什么是 异常表？</p><p>OS 为了将每种 Event 产生的 Exception 与 Exception Handler 对应起来，将每种类型的事件进行编号。<strong>每种类型的事件对应位于的 异常编号（Exception Number，又称为中断向量，Interrupt Vector）</strong>，这个编号被作为一个跳表的索引，而表中装的是各个对应的 Exception Handler 的地址。这个表就称为 <strong>异常表</strong>。</p><p><img src="imgs/exception_table.png" height="300px"></p></blockquote><h3 id="13-3-4-Types-of-Exceptions"><a href="#13-3-4-Types-of-Exceptions" class="headerlink" title="13.3.4 Types of Exceptions"></a>13.3.4 Types of Exceptions</h3><p>上面我们提到过，在 Exception 的处理过程中，最后可能会发生 3 种情况（$I_{current}$、$I_{next}$、abort），这是因为具体发生的 event 不同，其 Exception Handler 的处理方式也不同。所以，我们有必要了解一下 Exception（或者说对应的 event）有哪些种类，exception handler 的默认行为又有哪些。</p><p><strong>Asynchronous Exceptions（异步异常）：又称 Interrupt（中断）</strong></p><ul><li>引发的 Event 的种类：<strong>来自处理器外的事件。通常是 I/O 设备发出的</strong>；</li><li>例子：<ul><li>I/O 设备中断事件（数据从磁盘、网卡等外部设备已到达内存的通知，键盘 Ctrl+C 等）；</li><li>系统分时复用时钟中断（Timer Interrupt），OS 在硬件时钟中定时，要求从用户程序切换到内核中，以便让 OS 取得控制权（这个是<strong>为进程上下文切换提供条件</strong>，让系统决定是否要进行进程上下文切换）；</li></ul></li><li>触发方法 / 系统状态如何改变：电脉冲通知处理器的 <strong>中断引脚</strong>；</li><li>触发后默认行为：<ul><li>可能与当前运行程序无关事件，从 $I_{next}$ 继续向下运行（<strong>recoverable</strong>）；</li></ul></li></ul><p><strong>Synchronous Exceptions（同步异常）</strong></p><ul><li>引发的 Event 的种类：<strong>因为处理器执行某条指令而造成的事件</strong>；</li></ul><p>而同步异常又可以分为几个种类：</p><ol><li><p>Traps（陷阱）</p><ul><li><p>触发方法：<strong>执行程序故意触发系统级别 Exception</strong>；</p></li><li><p>例子：<strong>system calls（系统调用）、breakpoint traps（程序断点）、特殊指令</strong>；</p><blockquote><p><strong>什么是系统调用？</strong></p><p>应用程序的某些功能可能需要使用一些硬件设备，例如 I/O 设备。而这些驱动硬件的程序则嵌在 OS Kernel 中。</p><p>但另一方面，由于安全问题，人们在系统中划分了若干特权级：Ring 0 ~ Ring 3，数字越大，权限越低。应用程序运行在 Ring 3 级别，因此不能直接调用内核函数、无法访问内核数据（位于 Ring 0 级别），因此无法直接使用 I/O 设备。</p><p>那么应用程序为了完成一项使用 I/O 设备的工作，只能调用 OS 准备的专门的接口（称为系统服务）来通知 OS 协助完成。这个过程被称为 <strong>系统调用</strong>。</p><p><strong>系统调用的详细过程？</strong></p><p>首先，系统调用就是调用系统接口的过程，咱首先得了解 x86-64 架构下系统调用有哪些接口。以 x86-64 Linux 为例：</p><p><img src="imgs/system_calls.png" height="250px"></p><p>每一个系统调用接口都有一个唯一的编号，这个编号由 OS 分配，例如 <code>read</code> 是 0 号；</p><p>以打开文件这个 I/O 操作为例，应用程序想要将磁盘中的数据读到内存中，那么：</p><ol><li><p>程序先调用 C library 封装好的函数 <code>open/fopen</code>；</p></li><li><p>C library 的 <code>open/fopen</code> 经过几层包装，接着调用系统接口 <code>__open</code>（上面的 2 号系统调用），其汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000000e5d70 &lt;__open&gt;:</span><br><span class="line">...</span><br><span class="line">e5d79: b8 02 00 00 00         mov $0x2,%eax # openis syscall #2</span><br><span class="line">e5d7e: 0f 05                 syscall # Return value in %rax</span><br><span class="line">e5d80: 48 3d 01 f0 ff ff     cmp $0xfffffffffffff001,%rax</span><br><span class="line">...</span><br><span class="line">e5dfa: c3 retq</span><br></pre></td></tr></table></figure><p>我们可以看到，系统调用的 calling conventions 与普通函数不一样：</p><ul><li><strong>第一传入参数必须是 系统调用编号，并且存放在 <code>%rax</code> 中</strong>，这里是 2，表示 2 号系统调用；</li><li><strong>其他传入参数依此放在：<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%r10</code>、<code>%r8</code>、<code>%r9</code></strong>；</li><li><strong>返回值也放在 <code>%rax</code> 中</strong>；</li><li><strong>使用 <code>errno</code> 宏来记录系统调用的状态或错误情况</strong>；</li><li><strong><code>%rcx</code> 、<code>%r11</code> 可能被破坏：<code>%rcx</code> 存放 $I_{next}$ 地址方便返回，<code>%r11</code> 用于存放 <code>rflags</code>，也即当前程序的 conditional codes</strong>；</li></ul></li><li><p>当处理器执行到系统调用汇编指令时，触发 <code>Trap</code>（Exception），相应值传入 Exception Table Base Register；硬件通过该寄存器找到 Exception table 中的相应 Exception handler（x86-64 通常是 software interrupt exception handler），将 <code>%rip</code> 地址改为该 handler 的地址，于是控制流转向 OS Kernel；</p></li><li><p>OS Kernel 处理系统调用的 exception handler 会按之前的 conventions 读取各参数值，执行对应系统调用服务。完成后，先切换特权级等信息，再读取 <code>%rcx</code> 和 <code>%r11</code> 中的信息，将控制流转交给 user mode 中原程序的 $I_{next}$；</p></li><li><p>最终系统调用成功返回的话，open 返回一个 <strong>file descriptor（文件描述符，一个区别已打开文件的小整数编号）</strong>，以供后续读写调用使用。</p></li></ol></blockquote></li><li><p>触发后默认行为：从 $I_{next}$ 继续向下执行（<strong>recoverable</strong>）；</p></li></ul></li><li><p>Faults（错误）</p><ul><li><p>触发方法：程序执行了一条指令，<strong>无意引发了硬件或软件层面的问题</strong>，从而产生 Exception；</p></li><li><p>例子：<strong>page fault（页错误，possibly recoverable）</strong>、<strong>protection fault（访问权限错误，unrecoverable）</strong>，<strong>floating point exceptions（浮点异常，例如除零错，unrecoverable）</strong>；</p><blockquote><p><strong>什么是页错误 和 访问权限错误？</strong></p><p>首先计算机中存在两个部分物理内存和虚拟内存。操作系统为了将离散、有限的资源抽象为连续、近乎无限的资源给应用程序使用，并将各个程序隔离开，使用了复杂的策略。</p><p>在<strong>内存的使用</strong>层面，操作系统和硬件配合引入了 “虚拟内存” 的概念，操作系统维护了一个从物理内存（简称 PM）到虚拟内存（简称 VM）的映射（还记得 Memory Hierarchy 最后介绍的 TLB cache 吗？就是为这个准备的），<strong>将主存（main memory）上离散的空间映射到连续的虚拟内存空间上</strong>。</p><p>这个 “映射” 存在处理器芯片的 MMU（Memory Managing Unit） 中，这个映射的数据结构被称为 <strong>页表</strong>。为了充分利用主存（物理内存）的空间，页表将 PM 和 VM 切分为很小的块（大家能懂往瓶子里装石子、沙子、水的道理吧？），这些很小的数据块被称为 <strong>页</strong>，而页表就是将这些虚拟内存页映射到物理内存页，如下：</p><p><img src="imgs/page_table.png" height="300px"></p><p>那么这样能同时完成两个目标：</p><ul><li>充分利用有限物理空间，为应用程序提供连续的虚拟空间；</li><li>每个应用程序间的虚拟内存很容易实现隔离（页表数据不同就行，这样哪怕相同的虚拟地址，映射到的物理地址也不同），相互不影响对物理内存的访问。</li></ul><p>每个应用程序所能看到的就是完整的虚拟内存，其中有独立的运行时栈。运行在 CPU 上的应用程序也直接使用虚拟地址，因为 VMA 出 CPU 前会经过 MMU 转换为物理地址，再向硬件请求。</p><p>但是！为了节约空间，操作系统不会一次性将全部的虚拟内存（地址 0 ~ FFFFFFFF）全部用页表映射上物理内存（一来大小不够，二来浪费资源），只是先为虚拟内存的必要部分（例如程序栈的 data 段、code 段、shared libraries 段、stack 段等）分配物理内存、记录在页表上。其余部分被称为<strong>未被分配的段</strong>。这个有 2 种可能：</p><ul><li>应用程序没有权限（执行 kernel space 段，或执行了标记为不可执行的栈区），或这里确实不应该有数据；</li><li>应用程序确实向操作系统申请了大量空间，不过有些还没使用过，OS 自己还<strong>没有</strong>将这段区域通过页表建立与物理内存的映射。</li></ul><p>所以，当程序指令访问上述 2 种段的时候，硬件发现在页表中找不到对应的物理地址，于是发出一个 Synchronous Exception，其类型是 Page Fault。</p><p>如果是因为访问了上面第一种情况的 “未分配的段”，那么在进入 Exception Handler 后，操作系统发现程序确实不应该访问这里，那么操作系统向原进程<strong>发送 SIGSEGV 信号 / SIGGPF 信号（Segmentation Fault 软件信号，或者 Protection Fault 软件信号，前面介绍过，这些信号是另一种 ECF 机制，下下节讨论）</strong>，控制流直接离开原程序（abort），属于 <strong>unrecoverable</strong> 类型；</p><p>如果是因为访问了上面第二种情况的 “未分配的段”，那么操作系统发现是自己没分配，于是在 Exception Handler 中，OS 会将一段新的物理地址分配给虚拟内存，记录在页表中，<strong>回到 $I_{current}$ 的位置</strong>，属于 <strong>recoverable</strong> 类型；</p></blockquote></li><li><p>触发后默认的行为：回到 $I_{current}$（recoverable），或者终止（unrecoverable）；</p></li></ul></li><li><p>Aborts（终止）</p><ul><li><p>触发方法：程序执行了一条神奇的指令，硬件层面严重错误，操作系统对应的 Exception Handler  也没辙，默认行为就是终止程序；</p></li><li><p>例子：<strong>illegal instruction（非法指令，通常因为低特权程序执行了高特权指令，或者压根汇编指令就有问题）、parity error（硬件奇偶校验错误）、machine check（硬件检查未知错误）</strong>；</p><blockquote><p>后两种可能是机器被宇宙射线击中，发生了 bits flop，或者硬件电路出问题了；</p></blockquote></li><li><p>默认行为：<strong>abort（unrecoverable）</strong>；</p></li></ul></li></ol><h3 id="13-3-5-Summary-of-Exception"><a href="#13-3-5-Summary-of-Exception" class="headerlink" title="13.3.5 Summary of Exception"></a>13.3.5 Summary of Exception</h3><p>13.3 中，我们介绍了非常底层级的一种硬件 ECF 机制：Exceptions，请大家回忆：<strong>Exception 的 概念、处理过程、实现方法、种类以及各种类之间的处理模式</strong>。</p><p><img src="imgs/exception_taxonomy.png" height="200px"></p><table>    <tr>        <th>Exception Type</th>        <td>Interrupt</td>        <td>Traps</td>        <td>Faults</td>        <td>Aborts</td>    </tr>    <tr>        <th>Recoverable</th>        <td>✔</td>        <td>✔</td>        <td>Possibly</td>        <td>❌</td>    </tr>    <tr>        <th>Return to</th>        <td>I next</td>        <td>I next</td>        <td>I current / abort</td>        <td>abort</td>    </tr></table><p>这种低层级的控制转移可以由操作系统和硬件联合实现，也是其他高级 ECF 机制的基础。</p><h2 id="13-4-Exception-Control-Flow-Process-Context-Switch"><a href="#13-4-Exception-Control-Flow-Process-Context-Switch" class="headerlink" title="13.4 Exception Control Flow: Process Context Switch"></a>13.4 Exception Control Flow: Process Context Switch</h2><p>要了解进程上下文切换，首先要了解什么是进程。</p><h3 id="13-4-1-Process"><a href="#13-4-1-Process" class="headerlink" title="13.4.1 Process"></a>13.4.1 Process</h3><ul><li><p>定义：一个进程是一个正在运行的程序的实例。</p><blockquote><p>与程序（program）不同，程序可以看作存在于 <code>*.c</code> 文件中的、存在于二进制文件的 <code>.text</code> 区域的、存在于已加载内存的字节中。</p><p>进程是计算机科学中最为影响深远的思想之一。</p></blockquote></li><li><p>进程的 3 种状态：Running、Blocked（Stopped）、Terminated</p></li><li><p><strong>进程提供的 2 个关键抽象</strong>：</p><ol><li><p>Logical Control Flow：</p><ul><li>每个进程都感觉自己独占了 CPU 资源，不用担心寄存器、CPU 的重要数据被更改；</li><li>这种逻辑上的控制流的隔离机制来源于 <strong>OS 内核和硬件提供的重要 ECF —— Process  Contest Switching</strong>；</li></ul><blockquote><p>啥是 Logical Control Flow，在本节结束后你就会知道。</p></blockquote></li><li><p>Private Address Space：</p><ul><li>每个进程都感觉自己独占了主存资源，不用担心别的程序未经同意访问自己的资源；</li><li>这种隔离机制来源于 <strong>OS 和硬件提供的重要抽象：Virtual Memory</strong>（前面说过）；</li></ul></li></ol><p>以上的两个抽象为操作系统提供了<strong>多进程执行与并发（Multiprocessing &amp; Concurrency）的能力</strong>。</p></li><li><p>基于上面 2 条关键抽象，我们的进程满足：</p><ol><li>有整套独立的虚拟内存空间，互不干扰；</li><li>有看起来能够持续执行的 CPU 及稳定的寄存器资源；</li></ol></li></ul><h3 id="13-4-2-How-does-Multiprocessing-work-on-single-processor"><a href="#13-4-2-How-does-Multiprocessing-work-on-single-processor" class="headerlink" title="13.4.2 How does Multiprocessing work on single processor ?"></a>13.4.2 How does Multiprocessing work on single processor ?</h3><p>那么，操作系统是如何同时运行多个进程的呢？我们以仅有一个处理器核为例。</p><p>我们在 13.3.4 中曾经提到过 “系统时钟中断和分时复用”。操作系统想要随时能够取得控制权，就需要<strong>借助硬件时钟，每隔一段时间触发一次时钟中断（interrupt）的 exception，让程序从用户态回到内核态</strong>，由操作系统判断情况，是否要进行一些调度或者切换等处理操作。</p><p>为了充分利用 CPU 等资源，同时运行多个进程，操作系统对每个进程的单次执行时间设置较短（大约 1 ms 量级），<strong>一旦该进程执行时间片耗尽</strong>，那么操作系统会<strong>借助时钟中断的机会</strong>触发一种高级的 ECF: Process Context Switch，将处理器上下文数据切换到另一个进程继续执行。</p><p>这里 “进程的上下文数据” 就是 <strong>能够让系统处理器从其他进程回到当前进程所需额外的数据</strong>。由于每个进程独享一段虚拟内存，所以原本在虚拟内存中的上下文数据无需另外保存。所以，进程的上下文数据一般指 <strong>处理器芯片中的各个寄存器的值、内核数据结构（页表、进程表、文件表等，都放在 kernel space 中）以及各进程虚拟内存总体的物理位置</strong>。</p><p>那么这样也不难理解为什么 OS 和硬件能做到在各个进程之间的无缝切换了。我们小小总结一下：</p><ul><li><p>什么是 Process Context Switch？</p><p>进程上下文切换是指 OS 和硬件 控制处理器保存在当前进程的上下文数据，并切换到另一个进程继续执行的过程。这种交替执行的方式被称为 <strong>interleaving</strong>；</p></li><li><p>为什么需要 Process Context Switch？</p><p>这能够让操作系统利用有限的 CPU 执行多进程任务（multiprocessing），充分利用系统资源，也不至于让一个进程卡死就波及到其他进程的执行。也就是说，<strong>interleaving 可以实现 multiprocessing</strong>；</p></li><li><p>什么时候出现 Process Context Switch？</p><ol><li><strong>（必定）当 Hardware Timer 触发了时钟中断 Exception</strong>；</li><li><strong>（必定）当该进程出现耗时的系统调用时，这种系统调用被称为 “慢系统调用”</strong>（通常是类似 <code>read/write/sleep</code> 的系统调用），哪怕该进程时间片没耗尽，操作系统依然会 suspend 这个进程（进程转为 blocked 状态）；</li><li><strong>（可能）当该进程出现了普通的系统调用</strong>，控制权流转到 OS Kernel 中，操作系统会根据情况（例如优先级等情况，在操作系统课程中的 <code>scheduling</code> 一节介绍）选择是否进行进程上下文切换。</li></ol><blockquote><p>我们发现这三种原因全都是 <strong>Exception</strong>，因此说底层 Hardware ECF 为高级 ECF 提供了基础条件。</p></blockquote></li><li><p>底层的 Process Context Switch 如何实现 / 进行的？</p><p>step 1. 因为上面所述的 3 种原因之一，当前进程执行到某一位置时暂停，并暂时转移到内核态，控制流交给 OS；</p><p>step 2. OS 判断当前是否应该进行 Process Context Switch，如果不是，则退出内核态，恢复原程序执行。不过大部分情况是应该进行切换的，因此进入下一步；</p><p>step 3. 确认要进行进程切换后，操作系统会评估各个进程的<strong>优先级、进程状态等信息</strong>，按照评估结果决定切换到哪个进程上，这个做出决定的内核程序段被称为 <strong>scheduler</strong>；</p><p>step 4. 操作系统在切换前找到原进程的信息，将上下文的处理器中的各个寄存器值存入该进程的虚拟内存中，然后转到 scheduled process 中，从 scheduled process 的虚拟内存中读出处理器的上下文数据，继续执行 scheduled process，过程如下：</p><p><img src="imgs/context_switch.png" height="200px"></p></li><li><p>在 Context Switch 中需要注意的是：</p><ul><li>OS Kernel 并不是一个单独的进程，OS Kernel 的数据存在于每个进程中，作为它们的一部分。通常数据位于各进程虚拟内存 <strong>栈区的下层（用户态不可访问）</strong>；</li></ul></li></ul><h3 id="13-4-3-Concurrency-amp-Parallelism-amp-Interleaving"><a href="#13-4-3-Concurrency-amp-Parallelism-amp-Interleaving" class="headerlink" title="13.4.3 Concurrency &amp; Parallelism &amp; Interleaving"></a>13.4.3 Concurrency &amp; Parallelism &amp; Interleaving</h3><p>之前我们讨论的实现 multiprocessing 的方式是 interleaving，而计算机科学中还有两个概念叫 <strong>并发（concurrency）和 并行（parallelism）</strong>，它们之间的关系是什么？我们来对比一下：</p><ul><li>并发：指<strong>在一个较短的时间内同时执行多条任务或进程</strong>，它是一种<strong>执行策略</strong>，我们可以由多种方案来实现这个策略；</li><li>交织（interleaving）：指<strong>交替（在时间上 sequential）执行多条任务或进程，但 “appeals to”（看起来像是）同时在执行所有任务</strong>，这个名词通常被用作多任务或分时复用的系统中，表明<strong>处理器短时间内在不同任务间切换以达到同时执行的效果</strong>。</li><li>并行：指<strong>严格同时地执行多条任务或进程</strong>，主要的目标是利用<strong>多核 / 多处理器</strong>共同工作的杠杆作用来同时地执行任务，提升系统性能；</li></ul><p>我们将上面的概念解析成几个容易理解的观点：</p><ol><li>并发是一个很广的概念，它可以通过多种机制实现，比如 并行（simultaneous execution）、交织（sequential execution with rapid switching），所以说 <strong>并行和交织都是实现并发的途径</strong>；</li><li>交织则强调在一个处理器上，充分利用有限资源执行多个任务，而并行则强调在多个处理器相互协作，同时处理不同的任务，达到 1+1 &gt; 2 的效果；</li></ol><p>可能还有同学会问，那多进程（multiprocessing）和它们又有啥关系？</p><p>实际上，我们上面讨论的都是抽象层面的策略和方案，它们可以针对计算机系统中的进程，也可以针对其他的任务。所以<strong>并发、并行、交织都是实现多进程的思路之一</strong>。</p><h3 id="13-4-4-Concurrent-Process"><a href="#13-4-4-Concurrent-Process" class="headerlink" title="13.4.4 Concurrent Process"></a>13.4.4 Concurrent Process</h3><p>理解了并行、并发、交织的概念后，我们再来看<strong>进程的并发</strong>。进程的并发有以下重要的概念：</p><p>首先我们在 16.1 中介绍过，物理控制流（大家回忆一下）是指硬件上正在执行的实际指令序列。现在，我们将每一个进程都看作一个 <strong>Logical Control Flow</strong>（逻辑控制流），所谓逻辑控制流就是<strong>从这个进程的开始到最终 terminated 的全过程</strong>（包括中间 blocked 的部分）。画一对图大家就理解了：</p><p><img src="imgs/physical_control_flow.png" height="200px"></p><p>如上图，假设在一个处理器上，进程 A、B、C 的物理控制流如图所示。我们可以看到这采取了一种多进程交替执行的方式实现了进程的并发。所以它所对应的逻辑控制流是：</p><p><img src="imgs/logical_control_flow.png" height="200px"></p><p>我们可以形象地理解，进程逻辑控制流就是将它的物理控制流从头至尾连接起来。</p><blockquote><p>注意：如果 <code>graph 2</code> 是物理控制流，那么这个行为就是多核并行了。</p></blockquote><p>在这个基础上，我们做出如下定义：</p><ul><li>如果两个进程的逻辑控制流在时间上相互重叠（overlap in time），那么称这两个进程是<strong>并发执行</strong>（concurrently）的；</li><li>否则称这两个进程是<strong>顺序执行</strong>（sequentially）的；</li></ul><h3 id="13-4-5-Process-Control"><a href="#13-4-5-Process-Control" class="headerlink" title="13.4.5 Process Control"></a>13.4.5 Process Control</h3><p>在了解很多进程的理论后，我们需要转向实践层面的学习。现代 Linux 系统提供了很多控制进程的<strong>系统级函数</strong>（C library 中包装的系统调用接口），这些函数操作进程的过程称为 “<strong>进程控制</strong>”，而这些<strong>系统级函数最终大多数都会进行系统调用</strong>。</p><p>以 x86-64 Linux 为例，大多数系统函数的规范是：</p><ul><li><p>如果执行出错，则返回 <strong>-1</strong>，同时设定全局宏 <code>errno</code> 来提示出错的原因。</p><blockquote><p>因此在使用系统级函数时，有一个约定俗成的硬性规定（hard and fast rule）：<strong>当调用系统级函数后，必须检查其返回值，已确认其是否正确执行</strong>。</p><p>某些特别的系统级函数除外，例如 <code>exit</code>、<code>free</code> 返回 <code>void</code> 类型；</p></blockquote></li></ul><p>首先遇到的第一个进程控制的系统级函数，用于<strong>复制 / 创建进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>作用：复制一个与当前进程一模一样的进程。复制出的进程被称为原进程的<strong>子进程</strong>，父进程的含义不解释。</p></li><li><p><strong>注意，一模一样是进程的虚拟内存中的几乎所有数据都一致，但父进程和子进程虚拟内存相互独立（相当于 deep copy）</strong>；</p><ul><li>虚拟地址、进程总体程序栈数据都一样；</li><li>文件标识符直接可以继承使用，也就是可以访问任何父进程已打开的文件；</li><li>父、子进程间 PID、页表等信息不一致；</li></ul></li><li><p>返回值：<strong>在父、子进程中分别返回一次。</strong></p><ul><li>当创建进程失败后，返回 -1；</li><li>当进程创建成功，且当前进程为父进程时，返回<strong>子进程的 PID（正整数）</strong>；</li><li>当进程创建成功，且当前进程为子进程时，返回 <strong>0</strong>；</li></ul></li><li><p>⚠ 使用提示：</p><ol><li><p>此方法创建的新进程与原进程的<strong>运行的顺序和同步性完全不能保证</strong>（即在逻辑控制流中没有明确先后关系）。因此输出时序具有随机性，在编程时不应该假设二者的执行顺序；</p></li><li><p>适宜使用<strong>树状拓扑图的结构</strong>（这被称为 <strong>进程图，process graph</strong>）分析存在多个 fork 进程控制的情况；</p><blockquote><p><strong>进程图的使用方法</strong></p><p>一个进程图是分析<strong>并发程序</strong>的语句<strong>部分执行顺序</strong>的有力工具。</p><ul><li>进程图是一个有向无环图（DAG，没有自环、重边），图的每个顶点代表每条语句的执行情况；</li><li><code>a -&gt; b</code> 表示 a 语句发生在 b 语句之前，二者<strong>在逻辑控制流上有明确先后关系</strong>；</li><li>进程图的<strong>边</strong>可以标注当前情况下<strong>变量的值</strong>；</li><li>进程图的<strong>点</strong>可以标注当前语句的<strong>输出或其他信息</strong>；</li><li>进程图的<strong>任意一种拓扑排序与一种可能的执行顺序</strong><u><strong>一一对应</strong></u>（所有拓扑排序则代表所有所有可能的执行顺序）；</li></ul><p>这里一个常见考题：给出一个含有很多 <code>fork()</code> 的程序，要求写出输出情况；</p></blockquote></li></ol></li></ul><p>其次，我们还可以<strong>获取进程号（PID）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>二者作用：获取当前进程 / 获取父进程 PID；</li><li>返回值：当前进程 / 父进程 PID；</li></ul><p>系统级函数还可以<strong>终止一个进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><ul><li>作用：以 <code>status</code> 状态数终止这个进程；</li><li>约定：<code>status</code> 状态数 0 表示正常退出，非零代表异常退出；</li><li>返回值：不返回任何值，一个进程只会执行一次；</li></ul><p>系统级函数还可以<strong>让一个进程主动进入 stopped 状态并持续一段时间</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;    <span class="comment">/* in &lt;unistd.h&gt; */</span></span><br></pre></td></tr></table></figure><ul><li>作用：让当前进程进入 stopped 状态 suspend 起来，不接受 OS 调度，直到 <code>sec</code> 秒后恢复 running 状态；</li><li>返回值：进程实际<strong>还剩多少秒没有 sleep</strong>（因为中途可能会被信号等 ECF 机制打断）；</li></ul><p>系统级函数也可以<strong>让一个进程无限期进入 stopped 状态，直到向其传入任意信号</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>作用：当前进程进行系统调用，直接进入 stopped 状态；</li><li>返回值：如果控制流能回来，那么总是返回 -1；</li></ul><hr><p>此外，系统函数还提供了 <strong>回收子进程（Reaping Child Process）</strong> 的能力。</p><p>为了了解这是什么意思，我们有必要 recap 一下在 16.4.1 中介绍的 Process 的概念。从编程人员的角度来看，一个进程具有 3 种状态（运行、阻塞 和 终止）。现在我们结合之前了解到的 Process Context Switch 和进程调度的基础知识，再重新认识一下这 3 种状态：</p><ul><li><p>Running：处于该状态的进程<strong>可能正在被执行</strong>，<strong>也可能是退出了阻塞状态，等待被 OS 调度执行</strong>；</p></li><li><p>Stopped：处于该状态的进程<strong>已挂起（suspended），并且无法被 OS 调度，除非有信号通知</strong>；</p></li><li><p>Terminated：处于该状态的进程<strong>已经永久结束运行</strong>；</p><blockquote><p>进程终止的 3 点原因：</p><ol><li>收到一个<strong>默认行为是终止进程的信号</strong>；</li><li><code>main</code> 流程执行完毕；</li><li>进程种的程序主动调用 <code>exit</code> 函数；</li></ol></blockquote></li></ul><p>我们发现，改变进程状态的方法是<strong>操作系统与应用程序间的</strong>高级 ECF：<strong>信号</strong>；而信号的发出又需要 硬件 ECF（Exception）作为条件。</p><blockquote><p>下一节会提及高级 ECF 信号的机制，举个例子，Ctrl + C -&gt; Interrupt Exception -&gt; Kernel 发出 SIGINT -&gt; 信号提醒进程进行默认行为）。</p></blockquote><p>除此之外，我们还看到，进程的状态中有一个是 terminated，这说明<strong>操作系统在一个进程终止后，会一直保存这个进程的状态和部分数据（包括退出状态、多种 OS 表），直到它被 “回收（reaped）”</strong>。那么为什么进程结束了还需要等待回收？为何不直接清除这个进程的数据？</p><p>这是因为，我们通常需要知道<strong>进程退出的一些状态信息（正常退出，还是因为其他原因退出）</strong>，如果 OS 在进程结束后就直接清除数据，那么我们无从知晓其中的信息。</p><p>通常情况下，在一个进程从永久退出执行，直到被回收的时间段内，我们将这个进程称为 <strong>zombie</strong>（僵尸进程，在 <code>ps</code> 命令下显示 <code>&lt;defunct&gt;</code>）。</p><p>那么进程最终应该由谁回收？答案是<strong>父进程或者是系统根进程 <code>init</code> (PID = 1)</strong>。父进程如果想要等待在子进程退出后获取子进程的退出状态，那么就需要使用系统级函数 <code>wait</code> 和 <code>waitpid</code>。准确地说，它们并不是 wait 进程结束，而是 wait 进程状态的改变；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *child_status)</span>;    <span class="comment">/* Equivalent to waitpid(-1, &amp;s, 0); */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* child_status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><p>由于 <code>wait</code> 是对 <code>waitpid</code> 的默认包装，因此我们这里仅介绍 <code>waitpid</code>；</p><ul><li><p>第一参数 <code>pid</code> 指定父进程要等待的子进程的 PID；如果传入 <strong>-1</strong>，则表示<strong>等待任意一个子进程状态改变即返回</strong>；如果传入 <strong>0</strong>，则表示<strong>等待任意一个与调用进程同进程组的子进程状态改变即返回</strong>；</p><blockquote><p>“状态改变”，而不是永久终止（terminated）。</p></blockquote></li><li><p>第二参数 <code>child_status</code> 应该传入一个整型地址，函数返回时会将子进程的状态码（<strong>和退出码不一样，需要专门的宏进行读取</strong>）填写进去；如果传入 <strong>NULL</strong>，则表示不关心子进程的状态，只是等待指定的子进程状态改变；</p><blockquote><p>读取该参数的宏位于 <code>&lt;sys/wait.h&gt;</code> 头文件中：</p><p><code>WIFEXITED(child_status)</code>：返回子进程是否被正常终止（调用了 <code>_exit(2)/exit(3)</code> 或从 <code>main</code> 返回）；</p><p><code>WEXITSTATUS(child_status)</code>：返回子进程的退出状态（当且仅当 <code>WIFEXISTED</code> 为真的时候有效）；</p><p><code>WIFSIGNALED(child_status)</code>：返回子进程是否被信号终止；</p><p><code>WTERMSIG(child_status)</code>：返回终止子进程信号的编号（当且仅当 <code>WIFSIGNALED(child_status)</code> 为真时有效）；</p><p>还有 <code>WCOREDUMP(child_status)</code>、<code>WIFSTOPPED(child_status)</code>、<code>WSTOPSIG(child_status)</code>、<code>WIFCONTINUED(child_status)</code> 等，大家可以用到再查；</p></blockquote></li><li><p>第三参数 <code>options</code> 常用的参数有 4 个，可以由按位或运算符连接：</p><ul><li><p>0：指定 <code>waitpid</code> 函数<strong>阻塞</strong>，直到子进程状态改变、获取信息后才返回；</p></li><li><p><code>WNOHANG</code>：指定 <code>waitpid</code> 函数<strong>非阻塞</strong>，如果子进程状态还没改变，那么立即返回；</p></li><li><p><code>WUNTRACED</code>：指定 <code>waitpid</code> 在子进程<strong>不是因为 <code>ptrace</code> 而进入 stopped 状态时</strong>也直接返回；</p><blockquote><p>什么是 <code>ptrace</code> ?</p><p><code>ptrace</code> 是 Linux 的<strong>另一个系统调用</strong>，为一个进程提供了<strong>观察</strong>和<strong>控制</strong>另一个进程的执行过程的能力，同时也提供<strong>检查</strong>和<strong>改变</strong>另一个进程的内存值以及相关寄存器信息。</p><p>大名鼎鼎的 <code>gdb</code> 和系统工具 <code>strace</code> 都是基于 <code>ptrace</code> 完成调试工作 和 逆向工程的。</p><p>这里的 <code>ptrace</code> 的系统级函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span>       </span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid, <span class="type">void</span> *addr, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure><p>事实上，当 <code>ptrace</code> 被调用来 attach 一个进程时，首先进入 syscall（Exception），操作系统在 exception handler 中的默认行为是通过<strong>信号</strong>沟通 <code>ptrace</code> 所在进程 和 attach 的进程，最后该进程会进入 <strong><code>Traced</code> 状态</strong>（一个与 Stopped 状态几乎相同的状态，都是暂时中止进程执行和调度），等待 <code>ptrace</code> 所在进程的调试工作。</p></blockquote></li><li><p><code>WCONTINUED</code>：指定 <code>waitpid</code> 在子进程接受到信号 <code>SIGCONT</code> 而从 stopped 状态恢复为 running 状态时，也直接返回；</p></li></ul></li><li><p>返回值：如果成功执行，则返回状态改变的子进程 PID（<strong>如果指定了 <code>WNOHANG</code>，并且指定的子进程存在，但是子进程还没改变状态，那么直接返回 0</strong>）；如果执行错误，那么返回 -1，错误码位于 <code>errno</code>；</p></li></ul><p>这两个函数不仅可以查看子进程的退出状态，而且也告诉操作系统，“如果子进程结束，则可以直接回收该进程了”。</p><blockquote><p>测试发现，如果 <code>waitpid</code> 是<strong>非阻塞</strong>的话，子进程结束仍然不能直接被回收。</p></blockquote><p>如果父进程不想了解子进程的退出情况（<strong>没有调用上述两个函数</strong>），或者<strong>在子进程结束前就退出了（那么这时，子进程被称为孤儿进程，orphaned child process）</strong>，那么操作系统<strong>会自动将回收权交给 <code>init</code> 根进程，等待孤儿进程结束后直接回收</strong>。</p><p>这种回收的流程可以总结为：</p><p><img src="imgs/reap_process.png"></p><blockquote><p>⚠ 一种可能的内存泄漏的情形：</p><p>在一个长期运行的服务器上，系统可能运行了大量的进程。对于一些服务程序，<code>init</code> 根进程不会回收这些 zombie 进程，因为服务器是长期运行的，也等不到父进程结束的情况。如果父进程不显式回收子进程，那么会导致 zombie 进程堆积，内存溢出，甚至内核崩溃。</p></blockquote><p>⚠ <strong>另外，还有一个要点，即 <code>waitpid</code> 只能等待父进程的直接子进程（immediate child process），它无法等待子进程的子进程的结束并返回信息的</strong>。</p><hr><p>最后，系统级函数还提供了<strong>更改当前进程运行的程序</strong>的功能（毕竟之前只提供了 <code>fork()</code> 通过复制创建进程）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> _Nullable argv[],</span></span><br><span class="line"><span class="params">           <span class="type">char</span> *<span class="type">const</span> _Nullable envp[])</span>;</span><br></pre></td></tr></table></figure><p>这条系统级函数也是系统调用的接口，可以在<strong>当前进程中加载并运行指定程序</strong>。</p><ul><li><p>第一参数 <code>pathname</code>：可执行文件名，它可以是二进制文件，也可以是由 <code>#!interpreter</code> 开头的脚本（Linux 约定俗成，在脚本文件前注释解释器名，例如 <code>#!/bin/bash</code>）；</p></li><li><p>第二、参数 <code>argv[]</code> 和 <code>envp[]</code> 分别是参数列表和环境变量列表，可以为空；</p><p><code>envp</code> 的设置就是简单字符串：<code>&quot;&lt;name&gt;=&lt;value&gt; ...&quot;</code>，或者使用 <code>getenv</code>、<code>putenv</code>、<code>printenv</code> 进行解析和设置环境变量字符串；</p><blockquote><p>注：<code>envp[]</code> 会在执行前由 OS append 几个参数，参数就是系统环境变量；</p></blockquote></li><li><p>返回值：<strong>仅在执行错误（找不到指定文件）时返回 -1</strong>；</p></li></ul><p>⚠ 注意，在当前进程运行该指令后，<strong>如果正确执行，那么程序控制流永远不会回到该指令的下一行，程序整体会在虚拟内存中完全被替换为新运行的程序，即完全覆盖当前程序虚拟空间，包括 code 区、data 区、stack 区等等</strong>，仅保留 PID、file descriptor 和 signal context（信号上下文）。</p><p>这意味着，正确执行的情况下，<strong><code>execve</code> 不会有返回值</strong>。</p><p>这还意味着，如果你想开发一个 Linux shell，那么你使用 <code>execve</code> 时，应该 <code>fork</code> 一个子进程出来，然后在子进程中执行该命令。否则当前程序会被覆盖。</p><p>当新的程序被从可执行文件加载到虚拟内存后，程序的虚拟内存的结构应该是这样（不包括 kernel space）：</p><p><img src="imgs/new_user_stack.png" height="350px"></p><blockquote><p>有同学可能会问，为啥不做一个<strong>同时创建一个进程并运行指定程序的系统调用呢？</strong>实际上，设计者从实用性和冗余性两个方面考虑，<code>fork</code> 非常有用，例如对于一个并发服务器而言，想要创建多个副本来响应 client，那么只需要 fork 就行；</p><p>而且你可以在运行指定程序前、fork 之后的时间内可以做一些其他自定义的准备工作，非常灵活。</p></blockquote><h3 id="13-4-6-Summary-of-Process-amp-Process-Control"><a href="#13-4-6-Summary-of-Process-amp-Process-Control" class="headerlink" title="13.4.6 Summary of Process &amp; Process Control"></a>13.4.6 Summary of Process &amp; Process Control</h3><p>在本节中，我们学习了一种高级的 ECF 机制：Process Context Switch。为了深入讨论这个话题，我们首先了解了进程的概念（一个正在运行的程序的实例），以及进程重要的 2 个抽象——对 CPU（logical control flow 是连续的）和 主存（private address space 是独享的）的抽象。</p><p>另外，我们从 “系统如何充分利用有限资源实现多进程并发” 的问题入手，了解了当今 Linux 操作系统<strong>利用 Timer Interrupt Exception</strong>（分时复用和时间片轮转）<strong>和 系统调用</strong> 达到 Process Context Switch 的目的，进而实现多进程执行的 interleaving。于是 进程上下文切换的 <strong>What、Why、When、How</strong> 四个问题都得到了解答。</p><p>其中，我们还详细比较了 interleaving、parallelism、concurrency、multiprocessing 的概念的异同，分析了怎么看 Physical Control Flow、怎么画 Logical Control Flow、怎么判断进程是 concurrent 还是 sequential 执行的。</p><p>最后一部分，在实际编程层面，我们介绍了控制 process 的、包装了系统调用的<strong>系统级函数</strong>，它们分别有：<code>fork</code>、<code>getpid</code>、<code>getppid</code>、<code>exit</code>、<code>sleep</code>、<code>waitpid(wait)</code>、<code>execve</code>。我们重点分析了这些函数的参数、返回值的含义，以及调用时的注意事项和技巧。</p><p>例如分析多重 <code>fork</code> 的进程图，<code>fork</code> 和 <code>execve</code> 的独特返回方式，<code>waitpid</code> 的复杂参数，最重要的点之一还是 “<strong>为什么要有进程回收、怎么进行进程回收</strong>” 的问题。</p><p>不过，我们在这节多次提到信号的概念，足以说明信号在操作系统与应用程序间的 ECF 的重要性。下节我们就讨论高级 ECF 中的信号（signal）机制。</p><h2 id="13-5-Exception-Control-Flow-Signals"><a href="#13-5-Exception-Control-Flow-Signals" class="headerlink" title="13.5 Exception Control Flow: Signals"></a>13.5 Exception Control Flow: Signals</h2><p>信号是由 OS 进行管理的软件信号，信号的种类和规范都由 OS 制定，完成 OS 和应用程序间的通信，实现高级的 Exception Control Flow；因此，我们需要先了解一下 OS（以 x86-64 Linux 为例）进程的继承结构，这样有助于在分析信号的时候不至于晕头转向。</p><h3 id="13-5-1-Linux-Process-Hierarchy-amp-Shell-Example"><a href="#13-5-1-Linux-Process-Hierarchy-amp-Shell-Example" class="headerlink" title="13.5.1 Linux Process Hierarchy &amp; Shell Example"></a>13.5.1 Linux Process Hierarchy &amp; Shell Example</h3><p>在 Linux 中，只有一种方法创建新的进程 —— <code>fork</code>；而由 <code>fork</code> 创建的进程有明确的父子关系，因此，Linux 中的所有程序所在进程实际上形成了一个层次结构：<strong>进程树</strong>。</p><p>在 Linux 启动的第一个进程是 <code>init</code> 根进程（PID = 1），其后所有生成的进程均为 <code>init</code> 的子进程。<code>init</code> 进程一般会创建 2 类进程：</p><ul><li><p><code>Daemon</code>：守护进程，是一类长期运行的程序，用来提供服务（例如对于一个 web 服务器，那么可能运行的服务是 apache 服务 <code>httpd</code>）；</p></li><li><p><code>login shell</code>：登录进程，这个进程运行的是命令行程序，为用户提供命令行接口，这样用户在登录后，可以以特定用户的身份，通过输入命令的方式与程序进行交互；</p><blockquote><p>例如用户输入 <code>echo &quot;Hello, Linux.&quot;</code> 的指令并回车，发生的是如下情况：</p><p><img src="imgs/login_shell.png" height="200px"></p></blockquote></li></ul><p>知道了这个道理，再结合上一节我们接触到的 process control 的系统级函数，我们就可以开始自己尝试用 C 写一个系统命令行了。我们来看看这个小型的命令行程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Fgets</span><span class="params">(<span class="type">char</span>* dst, <span class="type">int</span> cnt, FILE* input)</span>;    <span class="comment">/* 定义略，就是对 fgets 的包装 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* line, <span class="type">char</span>* argv[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];    <span class="comment">/* command line */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* read */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* evaluate */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS];    <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];        <span class="comment">/* Holds modifiled command line */</span></span><br><span class="line">    <span class="type">int</span> bg;                    <span class="comment">/* Should the job run in bg or fg ? */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;        <span class="comment">/* Ignore empty lines */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123;    <span class="comment">/* Check if it is a builtin command */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;    <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, atgv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>细心的同学会发现，这个程序有个严重的 bug —— 它只对运行在 foreground（前台）的程序进行回收，对运行在 background（后台）的程序则仅仅是打印一条信息，就不再关心了。前一节我们讨论过，像 shell 这样长期运行的程序如果不回收其子进程，会导致 zombie 的堆积，引发内存泄漏的问题。</p><p>那么问题来了，对于运行在后台的子进程，我们不想等待，但该如何知道它何时结束，并且回收呢？这个问题的解决方案就是<strong>利用 Exception Control Flow</strong>，因为只有它能够不按照应用程序原先控制流，而是转向 OS Kernel，让 OS Kernel 配合通知我们的 shell 后台子进程的情况。这就是本节的主角，也是这类问题的解决方案 —— 信号（高级的 ECF 机制之一）。</p><h3 id="13-5-2-The-Features-of-Signals"><a href="#13-5-2-The-Features-of-Signals" class="headerlink" title="13.5.2 The Features of Signals"></a>13.5.2 The Features of Signals</h3><ul><li>定义：信号是一种软件产生的，<strong>用来通知进程，系统中某一种事件发生的小型信息</strong>。</li></ul><p>我们发现，信号的定义很像之前的 Hardware ECF（Exception），它们都是某种事件发生时触发的信息通知机制，但是后者是<strong>硬件和操作系统层面</strong>（包括 Asynchronous Exception 的硬件引脚 Interrupt 和 Synchronous Exception 的处理器触发进入 Exception table），前者则完全是<strong>由操作系统软件产生的软件层面的信息</strong>，抽象层级更高。</p><ul><li><p>发送方：通常是 <strong>OS Kernel</strong>，有时是<strong>一个 Process 请求内核（利用 <code>syscall</code> 这个 Exception）来向另一个进程发送</strong>（所以本质上<strong>只有</strong> OS Kernel 有权限发送信号）；</p></li><li><p>接收方：总是一个 Process；</p></li><li><p>发送时机：<strong>总是因为</strong>处理器触发了一个 Hardware ECF，进入某个 Exception Handler 中的行为，可能有以下两个原因：</p><ol><li>System call（<code>trap</code>）：有几种<strong>向另一个进程发送特定信号的系统调用</strong>：<code>kill</code>（不是专门 terminated 进程的系统调用，而是用来发信号的，名字起的不好！），和之前我们接触过的 <code>ptrace</code> 等；</li><li>其他 unintended hardware ECF（例如 Interrupt（典型是 <code>Ctrl+C/D/Z</code> 键盘 I/O）、Fault（常见是 Page Fault、Floating Point Exception）等等）；</li></ol></li><li><p>接收时机：？？？（<strong>我们在下一节介绍</strong>）</p></li><li><p>内容：它真的很小，<strong>仅仅是一个小整型 ID（1 ~ 30）</strong>，来代表信号的种类；</p><p>不过每个整型在 OS 中对应唯一的信号类型和含义。下面是常见的几个信号：</p><table>    <tr style="text-align: center;">        <th>ID</th>        <th>Name</th>        <th>Default Action</th>        <th>Corresponding Event</th>    </tr>    <tr>        <td>2</td>        <td>SIGINT</td>        <td>Terminate</td>        <td>User typed ctrl-c</td>    </tr>    <tr>        <td>9</td>        <td>SIGKILL</td>        <td>Terminate</td>        <td>Kill program (<b>cannot override or ignore</b>)</td>    </tr>    <tr>        <td>11</td>        <td>SIGSEGV</td>        <td>Terminate &amp; Core dump</td>        <td>Segmentation violation</td>    </tr>    <tr>        <td>14</td>        <td>SIGALRM</td>        <td>Terminate</td>        <td>Timer signal</td>    </tr>    <tr>        <td>17</td>        <td>SIGCHLD</td>        <td>Ignore</td>        <td>Child stopped or terminated</td>    </tr></table><p>我们解释一些上面的信号。</p><p>首先，<code>SIGINT</code> 就是我们对前台运行的程序触发 <code>Ctrl+C</code> 按键后，首先发生 Asynchronous Exception（Interrupt），通知处理器，处理器按照 Exception 处理流程转移到 OS Kernel 中处理 Keyboard Interrupt 的 Exception Handler 中，发现这是个 <code>Ctrl+C</code>，因此向目标进程发送一个 <code>SIGINT</code> 信号，然后把 Control Flow 交还 user mode 的 $I_{next}$；同时，目标进程收到信号会进行默认行为 —— terminated（可以 override，即自己设计接收信号的 procedure）；</p><p>对于 <code>SIGKILL</code> 过程类似上面的情况，但是它一般利用 <code>kill -9</code> 指令，进行了系统调用，通过 <code>trap</code> 来发送信号；</p><p>对于 <code>SIGSEGV</code>，一般是处理器访问非法地址后出现 <code>page fault</code>，可能发送这个信号；</p><p>对于 <code>SIGALRM</code>，一般可以用作自定义信号，利用硬件时钟进行一些任务（例如设置与超时相关的行为）；</p><p>对于 <code>SIGCHILD</code>，一般在<strong>一个进程的子进程的状态改变后</strong>，OS Kernel 会向该父进程发送这条信号，但默认行为是忽略。如果父进程是一个 long-run program 并且不使用阻塞的 <code>waitpid</code>，那么我们在父进程中应该主动捕获这个信号，防止发生子进程的内存泄漏；</p><blockquote><p>除此之外，我们在前面还见到过 <code>SIGFPE</code>、<code>SIGGPE</code> 等等信号，用到时再查也不迟；</p></blockquote></li></ul><h3 id="13-5-3-Implementations-of-Sending-a-Signal"><a href="#13-5-3-Implementations-of-Sending-a-Signal" class="headerlink" title="13.5.3 Implementations of Sending a Signal"></a>13.5.3 Implementations of Sending a Signal</h3><p>那么，通过上面的解释，我们大致知道了，OS Kernel 大多是借助 Exception（Hardware ECF）这个时机来实现信号的发送的，但具体是如何进行的呢？</p><p>实际上，OS Kernel 向某个进程发送信号是通过<strong>改变目标进程上下文的状态数据</strong>来实现的。</p><blockquote><p>Linux 官方文档原文：</p><p>Kernel sends a signal to a destination process by updating some state in the context of the destination process.</p></blockquote><p>对，仅仅是目标进程的上下文的某个数据改变了，仅此而已。</p><p>那么，目标进程的响应机制呢？主要有以下几种：</p><ul><li><p><strong>Ignore</strong>：忽略该信号；</p></li><li><p><strong>Terminate</strong>：该进程终止，或被迫终止（不是中止，stopped）；</p></li><li><p><strong>Catch</strong>：捕获信号并处理（这里捕获信号并处理的程序称为 <strong>Signal Handler</strong>，<strong>它与 Exception Handler 不一样，它位于用户态代码中——也就是说，咱可以自己在 C 程序中设计 Signal Handler</strong>）；</p><p>对于 catch 这个选项而言，我们还要了解一下 signals 到达目标进程后的过程：</p><p><img src="imgs/signal_procedure.png" height="200px"></p><p>但是，在<strong>信号到达后、进程 A 收到（就是感知到）并处理之前</strong>的一段时间内，由于<strong>某个给定的时刻，只能有一个类型的待处理信号</strong>（因为信号是一个整型，发送信号就是改变一个数据，没有队列这个数据结构，所以重复发就会覆盖，下面会看到这种数据结构）。所以有两个问题：</p><ol><li>我们不能继续给这个进程发送信号，那么 OS 应该怎么知道目标进程有没有收到？</li><li>进程 A 是按照普通控制流正常运行的，怎么让它去临时接收这个信号呢？</li></ol><p>实际上，这引入了信号的 2 个概念：<strong>Pending 和 Blocked</strong>；不仅如此，我们还要了解 <strong>进程组的概念</strong>，然后我们才能完整地解释信号的收发过程。</p></li></ul><hr><p>下面是 13.5.3 的知识补充：</p><h4 id="13-5-3-1-Signal-Concepts-Pending-amp-Blocked"><a href="#13-5-3-1-Signal-Concepts-Pending-amp-Blocked" class="headerlink" title="13.5.3.1 Signal Concepts: Pending &amp; Blocked"></a>13.5.3.1 Signal Concepts: Pending &amp; Blocked</h4><p>其实信号也存在状态，其中两个特殊的状态是 pending 和 blocked：</p><ul><li>如果一个信号被 OS Kernel 发送，但是还没有被目标进程接收（感知并处理），那么这个信号处于 Pending 状态；（<strong>重复一遍，没有队列数据结构</strong>）</li><li>如果一个信号被 OS Kernel 发送，但是目标进程显式地阻塞特定信号的接收（感知但保留信号不处理），那么这个信号处于 Blocked 状态，除非该进程主动 unblock；</li></ul><p>从这里我们可以知道，<strong>pending 状态的 signals 至多只会被目标进程接收一次，但 blocked 状态的 signals 可以接收多次</strong>；</p><p>我们说过，信号只是一个表示信号类型的小整型，存不了其他数据，因此<strong>信号的状态是由 OS Kernel 维护的</strong>。</p><p>OS Kernel 中<strong>保存了各进程的 Pending / Blocking bits 组成的 bit vectors</strong>，位于每个进程的上下文虚拟内存的 kernel space 中。维护方法如下。</p><p><strong>对于 Pending Signals</strong>；</p><ul><li>当一个另一个进程的 OS Kernel 向当前（目标）进程发送<strong>第 k 号</strong>信号，那么当前进程的 OS Kernel 会设置当前进程的 Signal Pending Vector 的<strong>第 k 位</strong>为有效位（假设是 1）；</li><li>当当前进程接收了这个信号 k，那么当前进程的 OS Kernel 会设置当前进程的 Signal Pending Vector 的第 k 位为无效位（对应是 0）；</li></ul><p><strong>对于 Blocked Signals</strong>：</p><blockquote><p>Signal Blocked Vector 相当于是对 Signal Pending Vector 的<strong>掩码</strong>（被称为 <strong>signal mask，信号掩码</strong>）。</p></blockquote><p>如果 block / unblock 特定信号，那么目标进程会使用 <strong><code>sigprocmask</code>（又一个系统调用）</strong>显式设置掩码位对应的 Pending Signal 是否有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> <span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> oldset)</span>;</span><br></pre></td></tr></table></figure><p>具体用法见 13.5.5 节；</p><h4 id="13-5-3-2-Process-Concept-Process-Groups"><a href="#13-5-3-2-Process-Concept-Process-Groups" class="headerlink" title="13.5.3.2 Process Concept: Process Groups"></a>13.5.3.2 Process Concept: Process Groups</h4><p>在 Linux 下，每个进程都明确属于一个进程组。那么如何为一个新产生的进程分配进程组？</p><p>实际上，进程组的分配有专门的系统调用（又来几个系统调用）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">/* Equivalent to getpgid(currentPID); */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">/* Equivalent to setpgid(currentPID, currentPID); */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>上述函数执行失败返回值均为 -1，均会设置 <code>errno</code>，注意检查。</p></blockquote><p>注意，进程组号 PGID 和进程 PID 是共用类型 <code>pid_t</code> 的。</p><p>此外，创建一个进程，<strong>默认的进程组号与父进程的进程组号相同</strong>。进程属于且仅能属于一个进程组；</p><p>这样的话，可以方便我们向<strong>在同一进程组中的所有进程都发送信号</strong>。例如，如果我们使用系统调用 <code>kill</code> 来给一个进程或进程组发送信号（以包装好的系统命令为例。当然，C library 也包装了一个系统级函数 <code>kill</code>，能够在 C 中向另一个进程发送信号）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 12345</span><br></pre></td></tr></table></figure><p>上面的指令就表示请求 bash 调用系统调用 <code>kill</code>，向<strong>进程号</strong>为 <code>12345</code> 的一个进程发送 9 号信号（<code>SIGKILL</code>）；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 -12344</span><br></pre></td></tr></table></figure><p>上面的指令由于进程号前加了一个短 dash，因此被解释为 <strong>进程组号</strong>，上面的行为是向<strong>进程组号</strong>为 <code>12344</code> 的所有进程发送 9 号信号。</p><p>然后我们回过头解释一下 <code>Ctrl+C/Z</code> 是如何发送信号的。如下图。</p><p><img src="imgs/process_group.png" height="300px"></p><p>首先，我们在 bash 中输入的指令和我们之前了解的一样，分为前台和后台任务；bash shell 在 <code>fork</code> + <code>execve</code> 一个指令的时候，会根据指令后面有没有 <code>&amp;</code> 来判断这是条前台还是后台任务。如果是前台任务，那么创建进程后还会进行系统调用，将前台任务放到<strong>前台进程组</strong>中。前台进程在一个 shell 主进程中只有一个，所以一般这个前台进程组由 shell 进程直接管理。</p><p>如果我们按下 Ctrl+C/Z，那么 Interrupt Exception Handler 的默认行为就是向 shell 进程发送 <code>SIGINT/SIGSTP</code> 信号；而 shell 定义了对于该信号的 Signal Handler，也就是<strong>向前台进程组中所有进程发送 <code>SIGINT/SIGSTP</code></strong>（不影响后台进程）。这就完成了一次键盘 I/O 信号的发送和传递。</p><blockquote><p>注：<code>SIGSTP</code> 信号的默认行为是让目标进程的状态 suspend 到 stopped 状态，直到接收到 <code>SIGCONT</code> 信号后才恢复。</p></blockquote><hr><h4 id="Back-to-13-5-3"><a href="#Back-to-13-5-3" class="headerlink" title="Back to 13.5.3"></a>Back to 13.5.3</h4><p>了解了信号的状态和管理的知识 和 进程组的知识，我们再回到 13.5.3，看看<strong>完整的信号处理过程</strong>应该是什么样子的。</p><p>考虑一个会经常出现的情形：某一个进程 A 正在执行，进程 B 的 OS Kernel 想向进程 A 发送一个第 k 号信号，怎么办？OS 是这么做的：</p><p><code>step 1.</code> 在某次 Process Context Switch 中，OS 的 scheduler 决定切换到 Process B，于是按照 Process Context Switch 的规范进行切换（保存当前进程上下文数据到当前进程的虚拟内存中，读 Process B 的进程上下文数据并加载到处理器中）；<strong>在运行 B 的代码前，OS Kernel 会按照想要发送给 A 的信号（k）来更改  A 的 Kernel space 中的 Pending Vector（将第 k bit 置为有效位 1）</strong> 然后转入用户态，正式运行 Process B 的代码；</p><p><code>step 2.</code> 在执行 Process B 一段时间后，处理器触发了 Exception（Interrupt、Trap、Recoverable Fault），于是控制流重新进入内核态。假如 scheduler 决定切换到另一个进程（也就是目标进程）A，<strong>那么在正式切换前，Kernel 会检查进程 A 的 signal 情况：使用 <code>pnb = pending &amp; ~blocked</code> 计算出上次 Kernel 发给这个进程的信号的集合，<code>pnb</code> 就是所有未被阻塞的信号的 bit vector</strong>；</p><ul><li>如果 <code>pnb == 0</code>，那么说明当前没有收到未阻塞的信号，OS Kernel 会继续进行 Context Switch 操作，切换到 Process A；</li><li>否则，OS Kernel 会选择 <code>pnb</code> 中最低非零位的 bit（假设第 k 位）作为信号接收。那么，OS Kernel 将 pending vector 第 k 位置为无效位（0），<strong>并且执行对应 k 号信号的 Signal Handler</strong>，<strong>此后重新回到 step 2 计算并检查 <code>pnb</code>，直至 <code>pnb == 0</code></strong>；</li></ul><p>这样信号的发送和接收的流程就形成了闭环：</p><ul><li><strong>信号接收时机：在 Process Context Switch 进入目标进程前统一检查并接收</strong>；</li></ul><p>于是我们可以说：</p><p><strong>信号的发送和接收依靠 Process Context Switch 实现，而 Process Context Switch 又是依靠 Hardware ECF（Exception）来实现的，三者抽象层级依次升高，密不可分，分别构成了硬件与操作系统、操作系统与应用程序间的 ECF 交互机制</strong>。</p><h3 id="13-5-4-Signal-Handlers-amp-Default-Action"><a href="#13-5-4-Signal-Handlers-amp-Default-Action" class="headerlink" title="13.5.4 Signal Handlers &amp; Default Action"></a>13.5.4 Signal Handlers &amp; Default Action</h3><p>好了，到目前为止，我们已经大致将信号机制的脉络捋清了。还有一点，我们之前就很想了解的：<strong>怎么自定义 signal handlers 呢？</strong> 这就需要我们更改一个进程收到某个信号的默认行为（Default Action）了。</p><p>提供修改信号 Default Action 的还是一个<strong>系统调用</strong>：<code>signal</code>（名字和 <code>kill</code> 一样有误导性。这里 <code>signal</code> 系统调用不是发送信号，而是设置进程对于信号的 default action）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">handler_t</span> *<span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注 ：<code>handler_t*</code> 类型被 <code>typedef</code> 为一个函数指针类型 <code>void(*)(int)</code>；</p></blockquote><ul><li><p>第一参数 <code>signum</code>：要修改该进程默认行为的信号编号（在 <code>&lt;signal.h&gt;</code> 中有宏定义可供使用）；</p></li><li><p>第二参数 <code>handler</code>：类型为 <code>void(*)(int)</code> 的函数指针，即为 signal handler（其参数也为信号编号）；</p><blockquote><p>如果是要设置 Ignore / Terminate 为默认行为，那么它们（函数指针）在 <code>&lt;signal.h&gt;</code> 还有特定的宏：<code>SIG_IGN</code>、<code>SIG_DFL</code>；</p></blockquote></li><li><p>返回值：如果执行成功，则返回传入的 signal handler 指针；否则返回宏 <code>SIG_ERR</code>（0）；</p></li></ul><p>可是问题又来了。我们知道，signal handler 会在 Process Context Switch 前被调用，调整程序的 control flow。因此，signal handler 用户态代码 和 普通代码一样，都可以作为<strong>并发流（concurrent flow）</strong>。以前我们接触的并发流都是不同进程间的 control flow。不同进程间资源不共享，它们间的切换依靠 Process Context Switch；</p><p>但是！一旦引入了 signal handler，<strong>signal handler 本身是和原进程并发的</strong>，而它又会共享原进程的一切资源，这可能出现问题（<strong>什么问题？在 16.5.6 节讨论</strong>）</p><p>我们结合 signal handler，顺便复习一下 16.5.3 中的内容，从另一个角度来看<strong>完整的信号收发过程和并发</strong>的情况：</p><p><img src="imgs/full_signal_procedure.png" height="300px"></p><ul><li>首先我们知道，如果有一个进程 B 想要想要给 Process A 发送信号，那么在某次从 Process A  Process Context  Switch 到 Process B <strong>前</strong>（置位操作不一定正好发生在 Process Context Switch 时，可以在此之前），Kernel 就为 Process A 的 Pending Vector 置了有效位（如上图最上面的箭头）；</li><li>随后通过 Process Context Switch 后，控制流进入 Process B；</li><li>一段时间后，如果再次出现了一个 Process Context Switch，决定向 Process A 跳转，那么在进入 A 正式执行前，会检查其 <code>pnb</code> 向量是否为 0（如上图下面的箭头），然后按 default action 进入位于 user code 中的 <code>handler</code>（signal handler）中；</li><li>当 <code>handler</code> 执行完成后，控制流再次进入 kernel code 进行一些准备（例如恢复 $I_{next}$ 数据）；</li><li>最后控制流真正回到 user code 的 $I_{next}$ 的位置继续执行；</li></ul><h3 id="13-5-5-Nested-Signal-Handlers"><a href="#13-5-5-Nested-Signal-Handlers" class="headerlink" title="13.5.5 Nested Signal Handlers"></a>13.5.5 Nested Signal Handlers</h3><p>⚠ 这会出现一种情况 “Nested Signal Handlers”，因为在运行在 signal handler 时，毕竟也是 user code，也有可能发生 process context switch：</p><p><img src="imgs/nested_signal_handlers.png" height="250px"></p><p>为啥要讨论这种情况？因为 <strong>OS Kernel 对已经正在处理同类型信号时（即位于该信号的 Signal Handler 时），会自动阻塞该进程对同类型信号的接收</strong>。这种信号阻塞方式称为 <strong>Implicit blocking（隐式阻塞）</strong>；</p><blockquote><p>例如上图，如果程序位于第（4）步，那么它既会阻塞 <code>S</code> 信号，又会阻塞 <code>T</code> 信号的接收。</p></blockquote><p>而我们之前 16.3.5.1 介绍过的 <code>sigprocmask</code> 系统调用，则是程序可以显式地修改对信号的阻塞情况。</p><p>我们再回顾一下它的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> <span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> oldset)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>sigset_t</code> 就是之前我们说的 Pending Bit Vector 的数据；</p></blockquote><ul><li>第一参数 <code>how</code> 可不是信号编号，因为信号编号应该是 <code>set</code> 的 bit 位；它是 <strong><code>sigprocmask</code> 要执行的行为</strong>，具体也是由宏定义的：<ul><li><code>SIG_BLOCK</code>：将指定参数 <code>set</code> 的有效位加入现在的 blocking bit vector，阻塞指定信号（<code>blocked |= set</code>）；</li><li><code>SIG_UNBLOCK</code>：将指定参数 <code>set</code> 中的有效位从现在的 blocking bit vector 移除，停止阻塞某种信号（<code>blocked ^= set</code>）；</li><li><code>SIG_SETMASK</code>：直接将参数 <code>set</code> 作为 blocking bit vector（<code>blocked = set</code>）；</li></ul></li><li>第二参数 <code>set</code> 是一个与 pending bit vector 格式相同的数据，作用在第一参数中能看到，具体我们怎么操作这个向量并且填上去，还有专门设置这个 vector 的函数：<ul><li><code>sigemptyset</code>：返回一个空的 pending bit vector 数据；</li><li><code>sigfillset</code>：返回一个每个信号位都有效的 pending bit vector 数据；</li><li><code>sigaddset</code>：返回一个在输出 pending bit vector 基础上置位指定信号位的新的 pending bit vector 数据；</li><li><code>sigdelset</code>：同理，删除；</li></ul></li><li>第三参数在接下来的例子中就能看到。</li></ul><p><strong>这个虽然很多，但很重要！！！在 Shell Lab 中会用到</strong>。</p><p>为什么我们要用到它们呢？直接交给 OS Kernel 隐式阻塞不好吗？<strong>我们不妨考虑一个场景，如果程序中有一串代码不希望被用户用 Ctrl+C 打断，那么我们就需要暂时显式地阻塞 <code>SIGINT</code> 信号</strong>，下面就是例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> mask, prev_mask;</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line">sigaddset(&amp;mask, SIGINT);</span><br><span class="line"><span class="comment">/* Block SIGINT and save previous blocked set */</span></span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Code region that will not be interrupted by SIGINT */</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Restore previous blocked set, unblocking SIGINT */</span></span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>看完这串代码你大概能明白 <code>sigprocmask</code> 的第三个参数的含义了：以指针传入，<strong>存储以前的信号掩码信息，便于之后的恢复工作</strong>。</p><h3 id="13-5-6-Safe-Signal-Handling-⚠IMPORTANT"><a href="#13-5-6-Safe-Signal-Handling-⚠IMPORTANT" class="headerlink" title="13.5.6 Safe Signal Handling [⚠IMPORTANT]"></a>13.5.6 Safe Signal Handling [⚠IMPORTANT]</h3><p>讨论完前面的知识，相信大家心里有点数了——信号非常难缠，不仅约定、机制和系统调用接口贼多，而且你必须小心再小心，否则会出大问题：</p><ul><li><p>不正确地处理信号会导致一些系统级问题，包括但不仅限于：</p><ul><li><p>内存泄漏（zombie 堆积等原因）；</p></li><li><p>共享内存访问冲突（<strong>死锁 dead lock、段错误 Segmentation fault 等问题都会出现</strong>。由于 signal handlers 与普通 user code 共享内存，但它们是并发的，很像一对<strong>并发的线程，thread</strong>），<strong>你要像写多线程程序一样小心，保证线程安全性</strong>；</p><blockquote><p>为什么？这还是因为 signal handlers 和 普通程序构成了<strong>并发流</strong>。</p><p>因为在 signal handler 执行前后，原程序都停留在 $I_{current}$ 的位置上，这样在 Logical Control Flow 上看，它们是并发的，<strong>几乎和两个线程的效果一样</strong>。</p><p>如果原程序正在改变一个诸如链表一样的数据结构，结果被 Exception 打断，进入了 signal handler；那么如果 signal handler 也改变了这个链表，当控制流回到原程序时，<strong>原程序并不知道自己的链表被改变了，因为从他的角度看，它还一步指令都没执行呢！</strong></p><p>⚠ 相信我，这种 Bug 非常难找，因为就算 <code>gdb</code> 也只能逐线程、逐进程地看。</p><p>所以在写 signal handlers 的时候，请<strong>一定注意访问全局 / 其他共享变量时的安全问题</strong>！！！</p></blockquote></li></ul></li><li><p>信号除了类型，没有其他语义。这是因为多个信号可能在接收时发生覆盖。<strong>因此我们不能用信号进行计数（即计信号发送了几次）</strong>！</p></li><li><p>不同版本的 Linux 中，<strong>信号的语义不同，难以移植</strong>；</p><ul><li>某些老旧系统在触发自定义的 signal handler 后，会重新变为 default action，需要重新设置。不过在 Linux 上不用担心；</li><li>某些系统根本不会在进程处理该类型信号时隐式阻塞；</li></ul><blockquote><p>为了解决这个问题，我们可以利用 <code>sigaction</code> 进行覆写处理。</p></blockquote></li><li><p>某些<strong>慢系统调用</strong>（类似 <code>read</code> 这样一定会触发 Process Context Switch 的）会使得 <code>errno</code> 变为 <code>EINTR</code>；</p><blockquote><p>因为如果触发慢系统调用的进程先于系统调用退出，那么系统调用会发生错误，并且设置 <code>errno</code> 为 <code>EINTR</code>；</p><p><strong>所以如果你在程序中发现这种错误，就重新进行这个系统调用</strong>；</p></blockquote></li></ul><p>那么怎样做是安全的呢？</p><ol><li><p>Signal Handlers 写的越简单越好，尽量能不往里面加代码，就不加；</p><blockquote><p>比如，你可以在一个信号函数中只是设置一个全局变量，然后立即返回；</p></blockquote></li><li><p>仅使用 <strong>异步信号安全（async-signal-safe）的</strong> 函数；</p><blockquote><p>什么是<strong>异步信号安全</strong>的函数？</p><p>它是指，一种函数是可重入（reentrant）的，也就是说，<strong>它访问的所有变量（包括指针的指向）都在自己的栈帧上</strong>。这样的函数在多线程、进程信号 handle 的时候，一定不会出现共享内存访问冲突，啥时候运行都不会改变语义。</p><p>事实上，POSIX 标准中保证了以下几种（共 117 种）函数一定是异步线程安全的：</p><p><code>_exit</code>（和 <code>exit</code> 不一样！它是系统调用接口，<code>exit</code> 是 C library 包装的系统级函数）、<code>write</code>、<code>wait</code>、<code>waitpid</code>、<code>sleep</code>、<code>kill</code>、……</p><p><strong>但不幸的是</strong>：</p><p><code>printf</code>、<code>sprintf</code>、<code>malloc</code>、<code>exit</code> 这些<strong>涉及 I/O 访问的、改变进程状态的系统调用或系统级函数</strong>大多都不是异步信号安全的，请谨慎在 signal handlers 里添加！</p><p>为什么它们不安全？因为它们会使用<strong>锁</strong>来对 I/O 设备或者变量进行读写，在 “多线程” 一章你会明白，这样很容易导致经典的死锁。</p><p><strong>所以……你一般没法在 signal handlers 里面打印输出内容……</strong>除非你能设计出一个能够对 signal handler 安全的 I/O 库。</p></blockquote></li><li><p>每次进入、退出 signal handlers 时<strong>应该保存、恢复 <code>errno</code> 变量，有助于系统错误追踪</strong>；</p><blockquote><p>因为在 signal handlers 被中断后，<strong>其他的 signal handlers 可能会更改掉 <code>errno</code></strong>；</p></blockquote></li><li><p><strong>在读写共享 / 全局变量时，请阻塞所有其他信号！！！</strong>这步操作保证当前 Signal Handler 不会被同进程的其他 signal handler 打断，<strong>相当于在多线程程序中加入读写锁</strong>；</p></li><li><p>如果你的 signal handlers 要用到一个全局变量，<strong>请将它声明为 <code>volatile</code></strong>。这一步也是在多线程编程中常见的。</p><blockquote><p>我们复习一下 C 中的关键字 <code>volatile</code>，这个关键字可以：<strong>阻止编译器优化由该关键字修饰的变量</strong>，即始终不将它放入寄存器中，<strong>每次读取都从内存中进行</strong>。这样做的好处是，多线程程序中的 <code>volatile</code> 变量不会发生值修改不同步的情况。</p><p>我们考虑以下情况：如果一个 signal handler 是修改某全局变量 <code>flag</code> 然后返回；该进程程序主体会定时检查这个 <code>flag</code>，做出相应动作。</p><p>如果我们在声明 <code>flag</code> 的时候，不加这个关键字，那么很有可能 <code>flag</code> 的值会被编译器解释成直接放到寄存器中，然后仅仅修改寄存器中的值。这样<strong>主程序可能永远也收不到 signal handler 更改的 <code>flag</code></strong>。</p></blockquote></li><li><p>如果你的全局变量是 <strong>仅读写的简单类型</strong>（数组、标准库中的容器是聚合类型，不是简单类型），除了加上 <code>volatile</code>，还建议使用 <code>sig_atomic_t</code> 类型。<strong>这就相当于多线程编程中的原子操作（<code>atomic&lt;&gt;</code>）</strong>；</p></li><li><p>对于一些慢系统调用，如果希望提升程序健壮性，应该在执行完检查是否 <code>errno == EINTR</code>，查看中途慢系统调用是否会被 Process Context Switch 阻断产生偶然错误；</p></li></ol><p>那么一个超级有难度的考题就来了——<strong>判断给定程序的异步信号安全性</strong>。来看下面一个程序：</p><p>这个 <code>fork14()</code> 想将自己创建的所有子进程通过信号的方式回收。这样做对吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ccount = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">child_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = wait(<span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">    ccount--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Handler reaped child &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>((<span class="type">long</span>)pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; \n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fork14</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid[N];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ccount = N;</span><br><span class="line">    signal(SIGCHLD, child_handler);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid[i] = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* Child exits */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ccount &gt; <span class="number">0</span>) <span class="comment">/* Parent spins */</span></span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很遗憾，这样写可以说没有一点异步信号安全性。能够成功回收应该是小概率事件。</p><p>我们从简入繁地分析一下：</p><ul><li>上面的信号处理程序没有保存和恢复 <code>errno</code>，这样会造成不必要的错误追踪的麻烦；</li><li>很显然，<code>printf</code> 不是信号安全的，极其容易发生死锁。要么不用，要么换成异步信号安全的函数；</li><li><code>ccount</code> 变量没有添加 <code>volatile</code> 关键字，可能被编译器优化，甚至在 <code>child_handler</code> 减少了 <code>ccount</code> 后，<code>main</code> 都无法感知；</li><li>最严重的一个问题是，<strong>任何时候，都不应该用收到信号的次数来作为真正发送信号的次数</strong>。因为前面介绍过信号的发送和接收的过程：从信号发送给进程，到进程真正接收，中间至少间隔 2 次 Process Context Switch。在此期间，<strong>由于没有队列数据结构，所有重复的相同信号都会被覆盖成一次信号</strong>。此外，在进程处理该信号的同时，还有隐式阻塞的问题，也会产生相同信号覆盖的情况。</li></ul><p>现在我们来改正。当我们收到一个 <code>SIGCHILD</code> 信号时，应该假设有多个子进程都结束了（因为无法计数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">child_handler2</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="type">int</span> oldErrno = errno;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">while</span> ((pid = wait(<span class="literal">NULL</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ccount--;    <span class="comment">/* 这里改成了回收子进程数，而不是依靠信号数来直接计数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)    <span class="comment">/* 说明上一个 wait 还没等完 */</span></span><br><span class="line">        sio_error(<span class="string">&quot;wait error&quot;</span>);    <span class="comment">/* 安全 I/O 库 */</span></span><br><span class="line">    errno = oldErrno;    <span class="comment">/* 用完 errno 后恢复它 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一个更难的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123; <span class="comment">/* Reap child */</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">        deletejob(pid); <span class="comment">/* Delete the child from the job list */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span> &amp;&amp; errno != ECHILD)</span><br><span class="line">        sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 5 */</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* Initialize the job list (a queue) */</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></span><br><span class="line">            execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); <span class="comment">/* Parent */</span></span><br><span class="line">        addjob(pid); <span class="comment">/* Add the child to the job list */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里的错误很难发现。在我们很早以前说 <code>fork</code> 的时候就讲过，<strong>不能保证父子进程的运行的时间顺序</strong>。这里可能会发生一个问题：<strong>在父进程 <code>addjob</code> 之前，<code>execve</code> 的子进程可能已经结束</strong>。这就意味着，父进程将一个已经结束的 job 加入 job list 中，这样任务队列永远不会为空。</p><p>如果要想 debug 找出，难点在于，你很难弄清楚各个父子进程间的 interleaving 的执行关系。所以在写信号的时候，一不留神就可能写出一个很恶心的 bug，还找不出来。</p><p>改正方法是，<strong>我们没法控制子进程和父进程执行的顺序，但我们可以控制 signal handler 执行的时机</strong>。我们在创建子进程前，阻塞所有信号（<strong>为什么？</strong>）。 在子进程中，在任务开始前，解除阻塞（<strong>又是为什么？</strong>）。</p><p>在创建子进程前阻塞所有信号，是为了<strong>让父进程在将任务添加到任务列表后，再考虑信号接收问题，防止 signal handler 在父进程还没加入任务列表时就被触发</strong>；</p><p>在创建子进程后，子进程开始后、<code>execve</code> 前解除阻塞，是因为要让 <code>SIGCHILD</code> 信号放出去，否则切换执行程序后就没有机会了。</p><p>于是改正后的程序长这样（<code>handler</code> 没有问题）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 5 */</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">    signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* Initialize the job list*/</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child process */</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">            execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>); <span class="comment">/* Parent process */</span></span><br><span class="line">        addjob(pid); <span class="comment">/* Add the child to the job list */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了这个方面的知识，我们可以明白一件事，我们在写一个这样的前后台程序的时候，如果不放心，可以用 <strong>进程图</strong> 模拟一下，确认自己的程序在各种极限情况下都能正常工作。</p><p>还有一个问题。在 shell lab 中，其实是不允许在 <code>main</code> 中写 <code>wait</code> 的，因为普通的 shell 程序都会将前台子进程的控制也交给信号，这样可以将前后台的处理方式大致统一。那么，<strong>怎么设计主程序能够显式的等待信号</strong>呢？别看这个好像很好办，实际要考虑的东西多得惊人。例如下面的一个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchild_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* Main is waiting for nonzero pid */</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">/* Do something */</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 10 */</span></span><br><span class="line">    signal(SIGCHLD, sigchild_handler);</span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="comment">/* Child: do somthing... */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">        <span class="comment">/* Wait for SIGCHLD to be received (wasteful!) */</span></span><br><span class="line">        <span class="keyword">while</span>(!pid)</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">/* Do some work after receiving SIGCHLD */</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能够写出上面的程序，那么前面的内容你都已经掌握了。这是个正确的程序，但是美中不足的是，父进程在等待子进程的时候，使用 <code>while (!pid);</code>，这样的做法比较低效，大部分 CPU 资源都浪费在无意义的 <code>while</code> 循环中了。</p><p>那么这个时候有同学可能会说，这简单，我可以在 <code>while(!pid)</code> 循环中加入一个 <code>pause</code> 系统调用，这样有 <code>SIGCHILD</code> 或者 <code>SIGINT</code> 触发后，程序可以自动从 <code>pause</code> 中退出，然后判断一遍 <code>pid</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!pid) pause();</span><br></pre></td></tr></table></figure><p>很可惜，这样<strong>可能会造成死锁</strong>。我们不妨画一个进程图，发现如果子进程向父进程发送信号，而且 Process Context Switch 的位置位于 <code>while (!pid)</code> 和 <code>pause()</code> 之间，那么，程序会先接收并处理 <code>SIGCHILD</code> / <code>SIGINT</code> 然后进入 <code>pause</code>。想象一下，如果这正好是最后一个给父进程发信号的进程呢？那么父进程会永远 stopped 在 <code>pause</code> 中。</p><p>同学还想了，那我换成 <code>sleep(1)</code> 不就不会死锁了吗？行是行，但是每隔一秒才检查一次子进程会严重拖慢程序运行速度。而设置为其他的固定时间，要么太慢（速度问题），要么太快（和没有 <code>sleep</code> 的效率一样低下）。</p><p>那么我们可不可以不那么快地恢复对 <code>SIGCHILD</code> 的响应（第 25 行）？让 “恢复 <code>SIGCHILD</code> 响应” 和 “<code>pause</code> 执行” 成为一对原子操作。那么答案就是新的系统调用：<strong><code>sigsuspend</code></strong>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure><p>它等价于以下 3 条指令的 <strong>整体原子操作</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>这样，我们只需要在阻塞 <code>SIGCHILD</code> 的时候，在 <code>while</code> 循环中调用 <code>sigsuspend(&amp;prev)</code>，这样  “取消 <code>SIGCHILD</code> 阻塞” 的行为 和 “<code>pause()</code> 执行” 的行为就原子化了，无需担心中间的死锁问题。这样如果有信号，并且交由 signal handlers 处理后，重新开始对 <code>SIGCHILD</code> 的阻塞，并检查 <code>pid</code>，完美实现要求。于是改进代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchild_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* Main is waiting for nonzero pid */</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">/* Do something */</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 10 */</span></span><br><span class="line">    signal(SIGCHLD, sigchild_handler);</span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="comment">/* Child: do somthing... */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Wait for SIGCHLD to be received */</span></span><br><span class="line">        <span class="comment">/* SIGCHILD is still blocked */</span></span><br><span class="line">        <span class="keyword">while</span>(!pid)</span><br><span class="line">            sigsuspend(&amp;prev);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Unblock SIGCHLD (optional) */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* Do some work after receiving SIGCHLD */</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-5-7-Summary-of-Signals"><a href="#13-5-7-Summary-of-Signals" class="headerlink" title="13.5.7 Summary of Signals"></a>13.5.7 Summary of Signals</h3><p>在讨论信号有关概念之前，我们先认识了 Linux 中的 “进程树” 这种进程层次结构。我们了解到，Linux 一号进程是 <code>init</code> 进程，它是所有进程的父进程。<code>init</code> 进程则会启动两类进程，一种是 <code>Daemon</code> 守护进程，另一种是 <code>Login Shell</code> 命令行。</p><p>我们利用之前对于进程控制的知识尝试写了一个小的 Demo，却发现对于运行在后台的子进程，我们没有办法 handle 它们。为了解决这个问题，我们引入了 Linux 系统中的信号的概念。</p><p>信号是一个小整型，由 OS Kernel 发出，用来通知进程事件发生、要求处理的一种高级 ECF 机制。</p><p>信号的发送和接收的非同时性决定了信号必须在 OS Kernel 中以一种数据结构存储起来，以供目标进程对信号的接收。这种数据结构非常朴素，只是一个 Pending bit vector 和一个 Blocked bit vector，这样的存储方式注定了 <strong>信号在接收过程中可能被覆盖</strong>，因此接收信号的次数不能代表信号发送的次数；</p><p>信号机制运作的流程看起来很简单：</p><ol><li><p>某一时刻，位于某个进程的 OS Kernel 向 Process A 发送一个信号，于是改变了 Process A 的 Pending bit vector；</p></li><li><p>当某次 Process Context Switch 即将切换到 Process A 前，OS Kernel 检查 <code>pnb = pending &amp; ~blocking</code> 的情况；发现有信号，那么对每个信号都进行处理：进入对应的 signal handler 并重置该位 pending bit vector；</p><blockquote><p>由于 signal handler 位于用户态，共享了原程序的一切内存，因此 signal handler 和 原程序在 Logical Control Flow 上成为一对共享资源的<strong>并行流</strong>，这个情况与多线程等效，但<strong>给信号处理和数据访问带来了极大的不安全性</strong>。</p></blockquote></li><li><p>signal handler 执行中，由于是用户态代码，所以仍然可能会出现 Process Context Switch，因此免不了有 Nested Signals Handlers 的情况。不过，一般的 OS Kernel 会帮助我们将正在处理的相同信号阻塞起来（<strong>隐式阻塞</strong>），防止多次调用相同的 signal handler；</p></li><li><p>在 signal handlers 调用完成后，控制流先回到 OS Kernel 恢复 $I_{next}$ 等必需数据然后继续原程序 $I_{next}$ 执行。</p></li></ol><p>只是，别小看这个 <strong>同进程并行流的不安全性</strong>，如果在书写 signal handlers 时处理不当，那么可能造成相当大的危害。</p><p>我们从处理多线程程序安全性的同样思路出发，提出了以下几点避免<strong>异步信号冲突</strong>的解决方案：</p><ol><li>signal handlers 尽量保持简洁，使用 <strong>异步信号安全</strong> 的函数；</li><li>每次进入、退出 signal handler 时要及时保存、恢复 <code>errno</code>，因为 signal handler 内部可能有系统调用错误，为了防止系统错误难以追踪，我们最好这么做；</li><li>在同时被原程序、Signal Handler 使用的共享变量前应该声明 <code>volatile</code> 关键字，对于仅读写的简单类型最好使用 <code>sig_atomic_t</code> 类型；</li><li>在原程序、Signal Handler 操作共享变量时，应该阻塞其他所有信号，防止同进程的 interleaving 造成共享资源访问冲突；</li><li>不以信号接收次数来计信号发送次数；</li><li>对于含有 <code>fork</code> + 信号的程序设计，如果拿不准，建议画进程图，因为你不能假设父子进程的先后顺序，及时进行信号阻塞。这通常是造成共享资源访问冲突的常见点；</li><li>最后，对于显式等待信号的问题，我们可以使用 <code>sigsuspend</code> 系统调用，保证 <strong>取消阻塞和暂停等待两步操作的原子性</strong>。</li></ol><p>此外，我们还认识了进程组，一种关联多个进程，可以同时向进程组中所有进程发送信号的机制。</p><p>最后，列举一下我们在这一节中学习到了哪些系统调用（包括系统级函数）：<code>setpgrp</code>、<code>setpgid</code>、<code>getpgrp</code>、<code>getpgid</code>、<code>signal</code>、<code>sigprocmask</code>、<code>sigemptyset</code>、<code>sigfillset</code>、<code>sigaddset</code>、<code>sigdelset</code>、<code>sigsuspend</code>；</p><h2 id="13-6-Non-local-Jump"><a href="#13-6-Non-local-Jump" class="headerlink" title="13.6 Non-local Jump"></a>13.6 Non-local Jump</h2><blockquote><p>Powerful (but dangerous) user-level mechanism for transferring control to an arbitrary location.</p></blockquote><p>略</p><h1 id="Chapter-14-System-Level-I-O"><a href="#Chapter-14-System-Level-I-O" class="headerlink" title="Chapter 14 System Level I/O"></a>Chapter 14 System Level I/O</h1><p>本章将讨论操作系统较为底层的 I/O，在 Unix 和其他类型的操作系统上一样支持。</p><h2 id="14-1-Unix-I-O-Overview"><a href="#14-1-Unix-I-O-Overview" class="headerlink" title="14.1 Unix I/O Overview"></a>14.1 Unix I/O Overview</h2><p>我们先讨论 Unix 上的 I/O 的原因是，比起其他的操作系统，Unix 中的 I/O 更加简单并且一致。我们都知道在 Unix 类系统上，<strong>一切皆文件</strong>，而这些文件本质上上一个 m bytes 的<strong>字节序列（a sequence of bytes）</strong>，<strong>不去区分文件的类型</strong>，所以 Unix 操作系统实际上基本不了解文件内部的详细结构。它将文件看作存放在磁盘或外部存储介质上的某段数据，并且提供打开、写入、关闭等标准操作。</p><p>正因如此，即使是一些 I/O Device，甚至是操作系统内核也能抽象表示为具体的文件。</p><blockquote><p><code>/dev/sdaN</code>: Unix 的 N 号磁盘分区；</p><p><code>/dev/ttyN</code>：Unix 的 N 号终端（为何叫 TTY？因为早期人们多使用 “电传打字机（teletype）” 用于描述打字机与计算机的接口）；</p><p><code>/boot/vmlinuz-xxx-generic</code>：Unix 的内核镜像文件；</p><p><code>/proc</code>：Unix 的内核数据结构；</p><p><code>/var/run/*.sock</code>、<code>/run/*.sock</code>、<code>/dev/shm/*.sock</code>：Unix 的网络套接字文件；</p><p>补充：什么是套接字（socket）？</p><p>在网络一章会深入讨论。简单来说，就是在互联网规范中，当机器通过互联网通信时，消息是一段通过写入套接字这个数据结构来发送的，另一端通过读取套接字的内容来接收的。</p></blockquote><p>这样的简洁明了的抽象（elegant mapping of files to devices）就允许 Unix 类操作系统内核以一套简单的接口完成对文件和设备的访问。<strong>这套简单、核心的接口被成为 Unix I/O</strong>：</p><ul><li><p>打开、关闭文件：<code>open()</code>、<code>close()</code>；</p></li><li><p>读写文件：<code>read()</code>、<code>write()</code>；</p></li><li><p>当前文件位置（注意，<strong>不是当前文件路径</strong>：是 current file position，而不是 current file path）；</p><ul><li><p>作用：indicates next offset into file to read or write（<strong>提示下一次向文件中写或读的字节偏移量，即下次从哪里读写</strong>）；</p></li><li><p>接口：<code>lseek()</code>，改变当前文件指针的指向；</p></li><li><p>特征：<strong>只有某些文件有这个接口</strong>。因为对那些文件而言，没法移动、备份和恢复先前的已读入的数据，也无法提前接收未写入的数据。</p><blockquote><p>例如 socket 文件就是没有这种接口的，因为它无法在时间上进行跳转，只能在数据包进入时对其读写；</p></blockquote></li></ul></li></ul><p>由于这些文件本质上还是不同的具体事物，在客观上有内在差别（就像一些类都继承于一个公共类，但它们终究需要实现不同功能）。这些文件属性上的差别则可以抽象为<strong>文件类型</strong>。</p><p>Unix 中的文件类型有以下几种：</p><ul><li>Regular file：普通文件（存储于磁盘驱动器上）；</li><li>Directory：一组特定文件的索引文件，其中的条目描述了其他文件的位置和属性；</li><li>Socket：与另一台机器上的一个进程沟通的文件；</li><li>Named pipes（<strong>FIFOs</strong>，先入先出型数据结构）：管道流文件。Unix 上一些程序的输出，同时也是另外一些文件的输入；</li><li>Symbolic links：符号链接。Unix 上又称软链接（与硬链接相对）；</li><li>Character and block devices：字符设备与块设备。其抽象在操作系统的设备访问层，其名称与实际物理设备特性无必然联系。<ul><li>操作系统能够<strong>随机访问固定大小数据块（chunks）</strong>的设备称为块设备（例如磁盘、软盘、CD、flash memory 等）；</li><li>操作系统只能<strong>按照字符流的方式有序访问</strong>的设备称为字符设备（例如串口、键盘等）；</li></ul></li></ul><p>本章着重讨论前三种文件，因为它们比较常见。</p><h2 id="14-2-Unix’s-Files"><a href="#14-2-Unix’s-Files" class="headerlink" title="14.2 Unix’s Files"></a>14.2 Unix’s Files</h2><h3 id="14-2-1-Regular-Files"><a href="#14-2-1-Regular-Files" class="headerlink" title="14.2.1 Regular Files"></a>14.2.1 Regular Files</h3><p>普通文件可以包含任何类型的数据。一般情况下，操作系统并不会试图分析文件内部的细节，因此操作系统内核<strong>并不知道</strong>文本文件（plain text）和二进制文件（binary）之间的差别。</p><p>注意，区分文件内容是文本还是二进制数据通常发生在应用程序层级（更高级别）。</p><blockquote><p>文本文件和二进制文件的差别：<strong>仅含有代表 ASCII / Unicode 字符的数据的文件被称为文本文件，否则被称为二进制文件</strong>；</p><p>二进制文件可以是：actual object file、图片音视频文件等等，它们包含<strong>直接以某种形式编码的字节序列</strong>；</p></blockquote><p>文本文件有个重要特征，就是它们可以看作<strong>由一系列文本行（text lines）构成</strong>的文件。通常情况下，文本行是一个以 <strong>newline 字符</strong>结尾的字符（char）序列。</p><blockquote><p>事实上，newline 字符在不同操作系统平台上定义不同，例如 Unix 上将 <code>0xa</code>（<code>\n</code>）代表的字符 <strong>line feed（LF）character</strong> 作为换行符，而 Windows 则约定以两个字符 <code>0xd 0xa</code>（<code>\r\n</code>）代表的字符 Carriage Return &amp;&amp; Line Feed（CRLF）character 作为换行符。</p><p>二者的区别与历史中的 typewriter（打字机）有关，因为换行（垂直运动，即 Line Feed）和回车（水平复位运动，即 Carriage Return）是打字机作为机械设备在换到下一行必须要做的两个运动，Windows 保留了这层含义。</p></blockquote><h3 id="14-2-2-Directories"><a href="#14-2-2-Directories" class="headerlink" title="14.2.2 Directories"></a>14.2.2 Directories</h3><p>在 Unix 操作系统（或者说操作系统中的文件系统）中，每个目录文件包含了一个 “链接” 数组，每个 “链接” 建立了一个从文件名到文件的映射关系。</p><p>每一个目录文件包含<strong>至少两个 entries</strong>：<code>.</code>（a link to itself，链接到自身）和 <code>..</code>（a link to the parent directory in the directory hierarchy，链接到目录层次中的上层目录）；</p><p>Unix 的文件系统层次结构与 Linux 相近，因此 Unix 文件系统层次结构就不再赘述。</p><p>而 <strong>当前工作目录（current working directory，<code>cwd</code>）</strong>是由 OS Kernel 维护的数据，每个进程下的不一定一致。可以通过使用 <code>cd</code> 改变当前进程的该数据；</p><p>在 Unix 和其他多数操作系统中，<strong>Pathnames（路径名）</strong>是文件层次结构中导向某个特定文件的导航方式，可以由目录文件的链接名称组成。</p><h2 id="14-3-Basic-Operations"><a href="#14-3-Basic-Operations" class="headerlink" title="14.3 Basic Operations"></a>14.3 Basic Operations</h2><p>本节的系统级函数和宏大多在 <code>&lt;fcntl.h&gt;</code>（file control）中；</p><h3 id="14-3-1-Opening-Files"><a href="#14-3-1-Opening-Files" class="headerlink" title="14.3.1 Opening Files"></a>14.3.1 Opening Files</h3><p>针对各类文件的基本操作方式之一是打开文件。它的实质是<strong>提醒 OS Kernel 已经做好访问该文件的一切准备</strong>。对此 Unix 有一个系统级函数 <code>open</code>，常用声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>第一参数可以是绝对路径，也可以是相对路径；</p></li><li><p>第二参数是 2 的某次幂的标志量（flag），允许按位运算。说明文件的打开方式（结合一些头文件，可以得到相关宏定义，例如 <code>O_RDONLY</code> 只读等）；</p></li><li><p>第三参数是文件权限位，即读取 / 创建文件的权限，可取的参数见官方文档：</p><p><img src="imgs/perm_modes.png" height="500px"></p></li><li><p>返回值体现了一个非常重要的思想：<strong>文件描述符</strong>。如果文件打开错误，则返回 <strong>-1</strong>（I/O 操作的失败情况比普通情况多很多，一定在实际使用描述符前检查是否成功打开）；</p><blockquote><p>什么是文件描述符（file descriptor）？</p><p>文件标识符是<strong>用来标识当前程序正在操作的某个已打开文件的小整型（这个小整型只有 0 ~ 1024 的范围）</strong>。</p><p>它们是按照打开顺序依此编号（从运行程序开始编号），所以大部分机器有最大打开文件数量的限制。这意味着打开了超过限制数量的文件将会造成文件资源泄漏。其中机器各方面的限制可以由以下指令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a</span><br></pre></td></tr></table></figure><p>另外一个值得注意的点是，在<strong>每个进程一创建的时候就会有 3 个已创建的文件：0（<code>stdin</code>）、1（<code>stdout</code>）、2（<code>stderr</code>），它们都是由 Unix Shell 打开并创建的</strong>（请回忆前一章的进程树并考虑为什么）。</p><p>其他具体内容将在 <strong>17.5.2</strong> 中讨论。</p></blockquote></li></ul><p>注：本章的系统级函数都非常底层，有些函数直接使用整型文件描述符。为了使用规范，如果你想用 <code>stdin/stdout/stderr</code> 这类文件时，请不要直接使用 <code>0/1/2</code>，更建议使用宏 <code>STDIN_FILENO/STDOUT_FILENO/STDERR_FILENO</code>；</p><h3 id="14-3-2-Closing-Files"><a href="#14-3-2-Closing-Files" class="headerlink" title="14.3.2 Closing Files"></a>14.3.2 Closing Files</h3><p>关闭文件的系统级函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> file_descriptor)</span>;</span><br></pre></td></tr></table></figure><p>你可能会好奇，为什么这个也要有返回值，难道关闭一个文件也会报错？答案是肯定的。</p><p>在多线程编程中（就像之前提到的，它们会共享内存和数据结构），可能会出现关闭一个已经被关闭的文件的情况，这种情况也会发生问题。</p><h3 id="14-3-3-Reading-Files-amp-Writing-Files"><a href="#14-3-3-Reading-Files-amp-Writing-Files" class="headerlink" title="14.3.3 Reading Files &amp; Writing Files"></a>14.3.3 Reading Files &amp; Writing Files</h3><p>Unix 系统级函数提供了一种块读取和块写入的方式，即从当前文件指针位置开始，向后指定长度的空间的数据读入缓冲区 / 向文件写缓冲区内容，并且更新文件指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> file_descriptor, <span class="type">void</span> *buffer, <span class="type">size_t</span> buf_size)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> file_descriptor, <span class="type">void</span> *buffer, <span class="type">size_t</span> buf_size)</span>;</span><br></pre></td></tr></table></figure><p>值得注意的是，如果正确运行，那么 <code>read</code> / <code>write</code> 的返回值是<strong>实际读取 / 写入的字节数</strong>（因为从当前文件指针到最后不一定有 <code>buf_size</code> 大小的数据，这种情况称之为 <strong>short read / short write</strong>）；错误则返回 <strong>-1</strong>；而（对于 <code>read</code> 而言）如果返回 0，说明已经到达 <code>EOF</code>；</p><blockquote><p>这里介绍一个之前提到的非常有名的工具 <code>strace</code>；这个工具的功能非常强大，不过现在我们先介绍一些简单的使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace &lt;prog&gt;</span><br></pre></td></tr></table></figure><p>以上指令在运行指定程序的同时，会跟踪并向  <code>stdout</code> 打印程序使用到的<strong>所有系统调用（system call）情况</strong>；</p><p>有时候看到很乱的情况，可能是终端上 <code>stderr</code> 和 <code>stdout</code> 交织输出的原因。</p><p>如果加上参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=&lt;syscall_name[,...]&gt; &lt;prog&gt;</span><br></pre></td></tr></table></figure><p>那么就仅仅追踪指定名称的系统调用情况。</p></blockquote><p>那么，什么时候会出现 short read / short write？</p><ul><li>读文件时遇到 EOF；</li><li>从<strong>终端</strong>读一个文本行；</li><li>读写网络套接字；</li><li>……</li></ul><p>其实，short read / short write 一直是应用程序层面较为棘手的问题，所以我们一般看到很多涉及 I/O 的库几乎都将这个低层级的 I/O 接口封装起来。</p><blockquote><p>为什么棘手？</p><p>其实，short read / write 在普通程序中的问题还影响不大，因为大多数是向磁盘中写文件，而向磁盘写不会出现 EOF，因此没有 short write；从磁盘读发生 short read 只要跳出读循环就行，影响也不大）。</p><p>但是在网络套接字的读写方面影响很大。考虑一个场景，你要用 socket 发一个网络包，但是写不下的值还要判断，而且还有可能因为其他偶然原因触发 <code>EINTR</code>，并且在循环中重新拿出来再发一次。</p><p>不仅如此，网络向 socket 中发送可能是一部分一部分收到的，因此可能<u>短读后还能继续读</u>！</p></blockquote><h2 id="14-4-The-RIO-Package"><a href="#14-4-The-RIO-Package" class="headerlink" title="14.4 The RIO Package"></a>14.4 The RIO Package</h2><p>为了解决 short read / short write 对应用程序编程开发带来的麻烦，有一种对 I/O 接口的封装方式是 CMU 教授开发的 RIO Package. 这个包提供了对于底层的 Unix I/O 的包装，能够使得程序在处理 I/O 方面有较强的健壮性（robust）和较好的效率，尤其是后面章节要讨论的、受 short read / write 影响较大的网络编程。</p><p>RIO Package 提供了 2 种不同级别的 I/O 文件接口。</p><p>其中，较低级别的 I/O 接口只是对上面说到的低级 Unix I/O 进行了简单的封装，以应对 short read / write 的情况；函数 <code>rio_readn</code>  和 <code>rio_writen</code> 就是这样较低级别的封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rio_writen 永远不会 short count. */</span></span><br><span class="line"><span class="comment">/* rio_readn 当正常执行时，返回 num 代表实际读取的字节数（和 Unix I/O 不同，这是产生 short count 的唯一情况）；遇到 EOF 返回 0；*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二者遇到错误都返回 -1，errno 由系统级函数 read/write 设置 */</span></span><br></pre></td></tr></table></figure><p>这两个函数属于对二进制数据的非缓冲式的读入和输出（unbuffered input &amp; output of binary data），在未读够 / 未写够指定字节数的数据之前不会返回。对于 <code>rio_readn</code>，如果是处理具有很多数据的网络套接字，那么在当前套接字读完、总体数据未读完的情况下<strong>挂起并等待</strong>；如果是读到了与给定字节数不同的时候出现 EOF，那么会返回错误；</p><p>对于 <code>rio_writen</code>，<strong>对于使用者的情况会比 <code>rio_readn</code> 简单些，所以也只需要包装到这个层次即可</strong>，因为使用者只需担心网络问题，这个函数本身会在要求的字节数内通过循环发送套接字（因为一个 socket 规范只有 1500 bytes 左右，具体大小取决于它位于哪个协议层）；</p><p>另一类是带缓冲区的 I/O 接口（<code>rio_readinitb</code>、<code>rio_readlineb</code>、<code>rio_readnb</code>），比前一类封装更高级一些，也是很多库对于 Unix I/O 常见的包装形式。它们的做法是在用户代码空间创建一个小型缓冲区（mini-buffer），用来存放已读入但未被应用程序使用的 bytes，或者为程序创建一块空间以便未来输出到文件或网络中；</p><blockquote><p>这种<strong>缓冲区的思想</strong>也存在与计算机的相当多的方面。</p></blockquote><p>带缓冲区的 RIO 有两种，一种是基于文本的，另一种是基于字节（二进制数据）的。如下代码注释，可见，在网络套接字的文本行阅读方面，<code>rio_readlineb</code> 非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read a text line of up to `maxlen` bytes from file `fd` and store the line in `usrbuf`.</span></span><br><span class="line"><span class="comment"> * Stopping Conditions:</span></span><br><span class="line"><span class="comment"> * - `maxlen` bytes read;</span></span><br><span class="line"><span class="comment"> * - EOF encountered;</span></span><br><span class="line"><span class="comment"> * - Newline (`\n`) encountered</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read up to `n` bytes from file `fd` and store them in `usrbuf`.</span></span><br><span class="line"><span class="comment"> * Stopping Conditions:</span></span><br><span class="line"><span class="comment"> * - `maxlen` bytes read;</span></span><br><span class="line"><span class="comment"> * - EOF encountered;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当正常执行时，返回 num 代表实际读取的字节数（和 Unix I/O 不同，这是产生 short count 的唯一情况）；*/</span></span><br><span class="line"><span class="comment">/*遇到 EOF 返回 0；遇到错误返回 -1，errno 由系统级函数 read 设置 */</span></span><br></pre></td></tr></table></figure><p>这种 RIO 库的健壮性还在于，<code>rio_readlineb</code> 和 <code>rio_readnb</code> 允许对一个文件描述符进行交织运行（多线程中对一个文件描述符），但别和 <code>rio_readn</code> 连用；</p><p>至于含缓冲区的 RIO 的实现也不难，它的目标就是设计一个读取内容的缓冲地带，让重复的读取内容不至于每次访问 I/O 都使用系统调用；举个例子：</p><p><img src="imgs/rio_readnb.png" height="300px"></p><p>如上图，假设程序想要读取系统上的一个 Unix file，那么该文件从头至 current file position 就是我们想要的 buffered portion；在读取的时候，<code>rio_readnb/rio_readlineb</code> 会按 buffered portion 的大小在 user code space 中创建一个同等大小的缓冲区（上图 buffer），由 <code>rio_buf</code> 指针管理这片空间的起始地址，由 <code>rio_bufptr</code> 管理当前程序读到 buffer 的哪里；而 <code>rio_cnt</code> 则代表当前还有多少数据没有读入缓冲区；</p><p>因此，根据 <code>rio buffer</code> 的使用分析，我们发现维护 <code>rio_t</code> 的结构体应该是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;</span><br><span class="line">    <span class="type">int</span> rio_cnt;</span><br><span class="line">    <span class="type">char</span> *rio_bufptr;</span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE];</span><br><span class="line">&#125; <span class="type">rio_t</span>;</span><br></pre></td></tr></table></figure><p>更多的内容大家可以通过阅读 RIO Package 的源码获取，并且可以在此基础上包装属于自己的 routines；</p><h2 id="14-5-File-Metadata-Sharing-and-Redirection"><a href="#14-5-File-Metadata-Sharing-and-Redirection" class="headerlink" title="14.5 File Metadata, Sharing and Redirection"></a>14.5 File Metadata, Sharing and Redirection</h2><h3 id="14-5-1-Metadata"><a href="#14-5-1-Metadata" class="headerlink" title="14.5.1 Metadata"></a>14.5.1 Metadata</h3><p>几乎所有操作系统平台上，每个文件中都有一个非常重要的部分是文件元数据（file metadata）。所谓 metadata 就是文件中实际包含的数据的信息，例如<strong>应用层级的文件类型信息、文件权限信息（R/W/X）、文件所有权信息、创建/访问/修改时间……</strong></p><blockquote><p>什么？你说 Windows 上创建一个文本文件，然后把后缀名删了，好像就没有了？其实操作系统在创建文件、在显示到桌面之前就将文件元信息设置好了，不信你看看右击属性。</p></blockquote><p>在 Unix 系统中，这种 metadata 以一个结构体 <code>stat</code> 进行存储，这种结构体类型也是 C library 函数 <code>stat</code>、<code>fstat</code>（查看文件元数据的函数）的返回值类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Metadata returned by the stat and fstat functions */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>st_dev; <span class="comment">/* Device */</span></span><br><span class="line">    <span class="type">ino_t</span>st_ino; <span class="comment">/* inode */</span></span><br><span class="line">    <span class="type">mode_t</span>st_mode; <span class="comment">/* Protection and file type */</span></span><br><span class="line">    <span class="type">nlink_t</span>st_nlink; <span class="comment">/* Number of hard links */</span></span><br><span class="line">    <span class="type">uid_t</span>st_uid; <span class="comment">/* User ID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>st_gid; <span class="comment">/* Group ID of owner */</span></span><br><span class="line">    <span class="type">dev_t</span>st_rdev; <span class="comment">/* Device type (if inode device) */</span></span><br><span class="line">    <span class="type">off_t</span>st_size; <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blksize; <span class="comment">/* Blocksize for filesystem I/O */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blocks; <span class="comment">/* Number of blocks allocated */</span></span><br><span class="line">    <span class="type">time_t</span> st_atime; <span class="comment">/* Time of last access */</span></span><br><span class="line">    <span class="type">time_t</span> st_mtime; <span class="comment">/* Time of last modification */</span></span><br><span class="line">    <span class="type">time_t</span> st_ctime; <span class="comment">/* Time of last change */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *statbuf)</span>;    <span class="comment">/* `fd` should be a valid open file descriptor. */</span></span><br></pre></td></tr></table></figure><p>如何用这些数据？一般情况下，我们可以借助一些 C library 内置宏来检查数据的含义。这里不多赘述，以一个程序为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">char</span> *type, *readok;</span><br><span class="line">    </span><br><span class="line">    Stat(argv[<span class="number">1</span>], &amp;stat);</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(stat.st_mode))    <span class="comment">/* Determine file type. */</span></span><br><span class="line">        type = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(stat.st_mode))</span><br><span class="line">        type = <span class="string">&quot;directory&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> type = <span class="string">&quot;other&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (stat.st_mode &amp; S_IRUSER)    <span class="comment">/* Check read access. */</span></span><br><span class="line">        readok = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> readok = <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;type: %s, read: %s\n&quot;</span>, type, readok);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>知识补充：Unix 系统中的 man page 的正确使用方法。</p><p>我们都知道，Unix 中的 <code>man</code> 指令相当于一个帮助文档，通常情况下，<code>man &lt;fname&gt;</code> 会进入 <code>fname</code> 所添加的帮助文档的<strong>第一章</strong>中。你可以使用 <code>man &lt;chapterN&gt; &lt;fname&gt;</code> 来指定查看第几章的 <code>fname</code> 文档。</p><p>在 man 程序管理帮助文档的规范中，每章的内容有明确的使用范围：</p><p>man 的第一章通常介绍 <code>fname</code> 作为一个<strong>系统指令</strong>（编译为了一个二进制文件放在系统中）的使用方法，通常包含一些该命令的命令行技巧和参数；</p><p>man 的第二章通常介绍 <code>fname</code> 作为一个<strong>系统级函数/系统调用</strong>在源码中的使用方法，通常包含了一些该函数的 API 文档内容和声明；</p><p>有些 <code>fname</code> 既在 Unix 中包装成了二进制的程序供命令行使用，又在头文件和系统的链接库中存在，以供源码使用（例如 <code>kill</code>），所有会同时存在这两章。</p><p>man 还有更多的章节，一般到第 8 章，其中的含义可以自行搜寻。</p></blockquote><h3 id="14-5-2-File-Sharing-amp-File-Descriptor"><a href="#14-5-2-File-Sharing-amp-File-Descriptor" class="headerlink" title="14.5.2 File Sharing &amp; File Descriptor"></a>14.5.2 File Sharing &amp; File Descriptor</h3><p>之前我们用了很长时间的 “file descriptor” 这个名词，接下来将讨论一下所有的文件在程序中如何用 file descriptor 进行标识，或者说，背后的机制是怎样的。</p><blockquote><p>⚠ <strong>这里是考试的难点！！！光听老师讲、看这部分的信息，想把题目做对是不够的！需要自行研究习题和历年考题。</strong></p></blockquote><p>OS 内部很多内部数据结构都与具体执行中的进程有关，例如前面提到的页表、用户栈、OS Kernel 等等，它们都存放在这个进程对应的虚拟内存中。</p><p>文件描述符也不例外，<strong>每个进程都会在其虚拟内存中维护唯一一个描述符表（descriptor table）</strong>。</p><p>还有两种非常特殊的数据结构，一种是 <strong>文件表（open file table）</strong>，另一种是 <strong>虚拟结点表（v-node table）</strong>；<strong>它们被计算机中所有进程共享</strong>；</p><p>如图所示：</p><p><img src="imgs/fd.png"></p><p>很早之前我们就了解过，文件描述符为 0、1、2 的特殊含义，这里不再赘述。</p><p>我们需要注意以下几点：</p><ul><li><p>v-Node Table 就是 Unix files 的 <code>stat</code> 结构体的表，每个 v-Node Table 与物理存储器上的文件<strong>一一对应</strong>（双射），无论文件是否被打开；</p></li><li><p>Descriptor Table 各个 entry 的内容存放的是<strong>指向各个 Open File Table 的指针</strong>，也表示<strong>当前进程已打开但未关闭的文件</strong>。而描述符相当于是对 Descriptor Table 的<strong>索引</strong>；</p></li><li><p>Open File Tables 由 OS Kernel 维护。每个 Open File Table 的第一个字段即为指向 v-Node Table 的指针，与每个 v-Node Table 的关系<strong>必然是函数关系，但既不是单射也不是满射</strong>；</p><blockquote><p>即：</p><ol><li><p>对任意一个 Open File Table 而言，它必然指向一个唯一的 v-Node Table（即物理文件）；</p></li><li><p>存在两个 Open File Table 它们指向<strong>同一个物理文件（也就是同一个 v-Node Table）</strong>，但他们本身不一定完全相同，因为它们的字段 <strong><code>File pos</code> 是分别由各个打开进程维护的</strong>。</p><p><strong>这意味着程序调用了两次 <code>open</code>，但是参数是同一个 filename</strong>（再次强调：<strong>可能在不同的进程中，而且 <code>File pos</code> 不一定相同</strong>），如下图：</p></li></ol><p><img src="imgs/fd_same_open.png" height="300px"></p><ol><li><p>允许一个 v-Node Table 不被任何 Open File Table 指向。</p><p><strong>这意味着这个物理文件还没有被程序的任何进程打开过</strong>。</p></li></ol></blockquote></li><li><p>每个 Open File Table 的第二个字段是 <code>refcnt</code>（reference count，引用计数），这个字段表明这个 Open File Table 被描述符表中的多少个 entry 指向；</p><blockquote><p>为什么要有这项数据？</p><p>因为在程序中，可能出现多进程（尤其是 <code>fork()</code> 产生）共享文件资源的情况，这时 OS 需要追踪内存分配，如果程序结束时，OS 需要回收这些部分（引用次数为 0 时不会立即清除）。堆的内存管理也有这种机制，不过比这个复杂很多。</p></blockquote></li></ul><p>有个相当重要的点，回忆一下，之前讨论 <code>fork</code> 的时候提到，创建的子进程总是可以直接继承使用父进程的文件描述符，达到二者共享文件资源的目的。但是，之前说描述符表是由每个进程的 OS Kernel 单独维护的。</p><p>那么这样的情况下，父子进程共享的文件资源是如何实现的？如下图过程：</p><p><img src="imgs/file_sharing_before.png" height="300px"></p><p><img src="imgs/file_sharing_after.png" height="300px"></p><p>总结一下父子进程共享文件描述符的要点：</p><ul><li>子进程<strong>完全复制</strong>父进程的描述符表；</li><li>父进程描述符表中指向的所有文件表的引用计数各加 1；</li></ul><p>因此我们得知，<strong>父子进程共享的不是物理文件，而是 Open File Tables</strong>（共用了文件指针）；这意味着父子进程任意一方读写文件，二者的文件指针一起变化；</p><p>⚠ <strong>最重要的是，每个进程都必须显式调用 <code>close</code>（除了 0、1、2 号文件），才能最终使引用计数为 0，操作系统才能回收。</strong></p><h3 id="14-5-3-I-O-Redirection"><a href="#14-5-3-I-O-Redirection" class="headerlink" title="14.5.3 I/O Redirection"></a>14.5.3 I/O Redirection</h3><p>再思考一个问题，Unix Shell 是如何实现 I/O 管道流和重定向的功能的呢？实际上，这个功能的实现也与文件描述符表有关。我们以一个例子为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> &gt; foo.txt</span><br></pre></td></tr></table></figure><p>这个指令将 <code>ls</code> 命令输出的结果重定向到 <code>foo.txt</code> 文件中，实际在 shell 的源码中应该使用了一个特殊的系统级函数（再次提示，系统级函数是<strong>系统调用的封装</strong>）：<code>dup2</code>；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* More: */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;    <span class="comment">/* uses the lowest-numbered unused descriptor for the new descriptor. */</span></span><br></pre></td></tr></table></figure><ul><li>作用：<strong>先将描述符为 <code>newfd</code> 的文件关闭以释放资源，再将描述符为 <code>oldfd</code> 的 descriptor table entry 复制到指定描述符为 <code>newfd</code> 的 entry 中</strong>；<ul><li>⚠ 如果 <code>oldfd</code> 是无效的描述符（即 descriptor table 在该位置的 entry 不指向有效的 open file table），则 <code>dup2</code> 执行错误，<strong>这个时候 <code>newfd</code> 对应的资源不会关闭</strong>；</li><li>⚠ 如果 <code>oldfd</code> 是有效的描述符，但是 <code>newfd == oldfd</code>，<strong>那么 <code>dup2</code> 什么都不会做，直接返回 <code>newfd</code></strong>;</li></ul></li><li>返回值：如果正确执行，则返回更新后的 <code>newfd</code>；如果执行错误，则返回 <strong>-1</strong> 并且设置 <code>errno</code>；</li></ul><p>切记，这条指令相当危险，除非你是在设计与操作系统层级很近的应用程序（例如 shell），否则不用轻易使用它，因为它能轻易将你绕晕，不知道哪些文件还没有释放。</p><h3 id="14-5-4-Standard-I-O"><a href="#14-5-4-Standard-I-O" class="headerlink" title="14.5.4 Standard I/O"></a>14.5.4 Standard I/O</h3><p>这里的库是 C standard library 包装的一些更高层级的 I/O 接口，它和之前我们接触到的 Unix I/O、RIO 的关系如下：</p><p><img src="imgs/IO_interface.png"></p><p>这些标准 I/O 实际上是 C 的一部分。先归一归类，大家都比较熟悉了：</p><ul><li>Opening and closing files（<code>fopen</code>、<code>fclose</code>）；</li><li>Reading and writing files（<code>fread</code>、<code>fwrite</code>）；</li><li>Reading and writing text files（<code>fgets</code>、<code>fputs</code>）；</li><li>Formatted reading and writing（<code>fscanf</code>、<code>fprintf</code>）；</li></ul><p>不仅如此，你见到的很多 standard I/O 都带有 buffering，所以规避了很多低层级的操作。</p><p>那么 standard I/O 的 buffer 和 RIO 的 buffer 有什么不同呢？</p><p><strong>在功能上</strong>，standard I/O 对于终端文件（terminal）或普通文件的访问方面包装显然要远远优于 RIO；但是 standard I/O 没有考虑到一些网络套接字方面的细节和小问题，所以在<strong>网络套接字的读写方面</strong>用起来还是 RIO 更胜一筹。</p><p><strong>在 buffer 设计上</strong>，standard I/O buffer 有一套 <strong>flush 机制</strong>。</p><p>对于写的情况，standard I/O 的 buffer 仅当出现以下情况之一时，才将 buffer 整体写入 Unix file，这么做可以减少系统调用次数，提升程序性能：</p><ul><li>标准输出函数（<code>fprintf/sprintf/...</code>）的结尾含有 <code>\n</code> 换行（<strong>换行结尾</strong>）；</li><li>Standard I/O 内部的 buffer 已经写满（<strong>缓冲占满</strong>）；</li><li>执行标准输出函数的进程从 <code>main</code> 函数退出了（<strong>程序结束</strong>）；</li><li>程序显式地调用 <code>fflush(FILE*)</code> 刷新缓冲区（<strong>手动刷新</strong>）；</li></ul><p>而 RIO 设定了固定大小的 buffer，并根据用户输入的读取或写入的大小分次进行系统调用，二者各有利弊。</p><p>综上，RIO 比 standard I/O 更适宜用在网络套接字读写方面，而 standard I/O 则在其他大部分文件读写的情况下表现更加优秀。</p><h2 id="14-6-Summary-of-System-I-O"><a href="#14-6-Summary-of-System-I-O" class="headerlink" title="14.6 Summary of System I/O"></a>14.6 Summary of System I/O</h2><p>本章开始，我们介绍了 Unix File 的概念和常见类型。对于 Unix File 的基本操作，则被操作系统抽象成了 Unix I/O（有系统级函数、系统调用），这些操作非常底层，不过有优势也有劣势：</p><ul><li>Pros<ul><li>Unix I/O 是<strong>最通用、开销最小的 I/O 接口形式</strong>（其他所有 I/O 库都基于此）；</li><li>Unix I/O 提供了一系列访问文件 metadata 的函数（<code>stat</code>、<code>fstat</code>）；</li><li>⚠ <strong>重大优点：它们都是 异步信号安全 的，可以用在 signal handlers 中</strong>；</li></ul></li><li>Cons<ul><li>应对 short counts 的处理很麻烦（尤其是应对 <code>EINTR</code> 和网络传输时），容易出错；</li><li>想要按照文本行读取出一行也很麻烦，也易错；</li></ul></li></ul><p>Standard I/O 非常优秀，同样有它的优缺点：</p><ul><li>Pros<ul><li>使用特殊的 buffer 机制，减少了系统调用的访问次数；</li><li>自动解决 short counts 的异常问题；</li></ul></li><li>Cons<ul><li>不提供访问文件元信息的接口；</li><li>其中的函数几乎<strong>都不是</strong>异步信号安全的函数；</li><li>不适宜用在读写网络套接字上，很容易出错；</li></ul></li></ul><p>最后，根据各个 I/O 的封装特性和抽象层级，我们可以总结出这些 I/O 库的选择注意事项 和 推荐：</p><p><strong>⚠ 注意事项 ⚠</strong></p><ol><li><p><strong>在条件允许的情况下，尽可能使用抽象层级高的 I/O 库</strong>；</p><blockquote><p>这样可以避免一些诸如 <code>EINTR</code>（之前提到，这个系统错误码是因为运气不好，重新调用一次就能修复）等底层奇奇怪怪的信息或错误；</p></blockquote></li><li><p><strong>使用 I/O 库的接口前，一定弄清楚接口的具体作用和逻辑</strong>；</p><ul><li><p>例如<strong>读二进制文件不能用 识别文本信息 的接口</strong>（例如用 <code>rio_readlineb</code> 去读图片、用 <code>strlen/strcpy</code> 去操作 socket 数据）；</p><blockquote><p>因为大多数识别文本信息的接口，尤其是按行输入的，会识别文本中的换行符（<code>0xa</code> 或 <code>0xd 0xa</code>，即 <code>EOL</code>，end of line），并以此分割读入；</p><p>不仅如此，它们还会把 byte value 0 解释为文本结束（end of string），这样会导致读入操作提前结束。而 <code>0x0</code> 只不过是二进制数据中一个数据而已，只有字符串是以 0 结尾的。</p></blockquote></li></ul></li><li><p><strong>Standard I/O 和 RIO 不应该混合使用！因为二者内部维护的 buffer 不同，在运行中可能出现干扰和错误</strong>；</p></li></ol><p><strong>ℹ 使用建议 ℹ</strong></p><ol><li>当 I/O 操作的对象是 <strong>disk / terminal files</strong> 的时候，使用 Standard I/O 最佳；</li><li>当需要一些尽量底层的操作（例如写 signal handlers 时），或者极其需要程序性能的时候（少见），使用 raw I/O（Unix I/O）；</li><li>当 I/O 操作的对象是网络 socket 文件时，最好使用 RIO 来处理一些特殊的情况，例如 <code>EINTR</code> 和针对网络的 short counts 的处理；</li></ol><hr><p>补充知识：操作目录文件</p><p><strong>唯一推荐对 directory 的操作：打开、读取 entries</strong>；</p><p>看下面的这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *directory;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">de</span>;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">if</span> (!(directory = opendir(dir_name)))</span><br><span class="line">        error(<span class="string">&quot;Failed to open directory&quot;</span>);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != (de = readdir(directory))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found file: %s\n&quot;</span>, de-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    closedir(directory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-13-Exceptional-Control-Flow&quot;&gt;&lt;a href=&quot;#Chapter-13-Exceptional-Control-Flow&quot; class=&quot;headerlink&quot; title=&quot;Chapter 13. Exceptiona</summary>
      
    
    
    
    <category term="review" scheme="https://sjtuxhw.top/categories/review/"/>
    
    
    <category term="GNU" scheme="https://sjtuxhw.top/tags/GNU/"/>
    
    <category term="CSAPP" scheme="https://sjtuxhw.top/tags/CSAPP/"/>
    
    <category term="ICS" scheme="https://sjtuxhw.top/tags/ICS/"/>
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt</title>
    <link href="https://sjtuxhw.top/2024/04/10/CSAPP-Notes-Memory-Hierarchy-Cache-Opt/"/>
    <id>https://sjtuxhw.top/2024/04/10/CSAPP-Notes-Memory-Hierarchy-Cache-Opt/</id>
    <published>2024-04-10T02:01:25.000Z</published>
    <updated>2024-05-16T11:34:41.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-10-The-Memory-Hierarchy"><a href="#Chapter-10-The-Memory-Hierarchy" class="headerlink" title="Chapter 10. The Memory Hierarchy"></a>Chapter 10. The Memory Hierarchy</h1><blockquote><p>本章将介绍系统的内存分层架构。</p></blockquote><p>之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。</p><p>正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。</p><h2 id="10-1-Storage-Technologies-amp-Trends"><a href="#10-1-Storage-Technologies-amp-Trends" class="headerlink" title="10.1 Storage Technologies &amp; Trends"></a>10.1 Storage Technologies &amp; Trends</h2><p>在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。</p><h3 id="10-1-1-Random-Access-Memory-RAM"><a href="#10-1-1-Random-Access-Memory-RAM" class="headerlink" title="10.1.1 Random-Access Memory (RAM)"></a>10.1.1 Random-Access Memory (RAM)</h3><p>当前大多数人所熟知的 “内存” 的一部分就是<strong>随机访问存储器（RAM）</strong>，它具有以下的特征：</p><ul><li><p>RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；</p></li><li><p>RAM 常常被打包放在 CPU 芯片中；</p></li><li><p>RAM 中每一个基本的存储单元被称为 <strong>单元胞</strong>（Cell），一个单元胞中存放 1 bit 数据；</p></li><li><p>很多个 RAM 芯片共同工作，组成了计算机的 <strong>主存</strong>（主存储器）。</p></li><li><p>RAM 分为 2 类，它们之间<strong>根据存储单元胞的实现方式来区分</strong>：</p><ul><li>SRAM（Static RAM），静态随机存储器；</li><li>DRAM（Dynamic RAM），动态随机存储器；</li></ul><table>    <tr>        <td></td>        <td>Trans. per bit</td>        <td>Access time</td>        <td>Needs refresh?</td>        <td>Needs EDC?</td>        <td>Cost</td>        <td>Applications</td>    </tr>    <tr>        <td>SRAM</td>        <td>4 or 6</td>        <td>1 ×</td>        <td>No</td>        <td>Maybe</td>        <td>100 ×</td>        <td>Cache Memories</td>    </tr>    <tr>        <td>DRAM</td>        <td>1</td>        <td>10 ×</td>        <td>Yes</td>        <td>Yes</td>        <td>1 ×</td>        <td>Main memories, frame buffers</td>    </tr></table><blockquote><p>注：<code>Trans. per bit</code> 表示每 bit 需要多少根晶体管，<code>EDC</code> 指电子数据捕获。</p><p>从上面这张表可以得知，SRAM 比 DRAM 成本高很多，因为 SRAM 的每个储存单元胞都更加复杂。正因如此，SRAM 的访问速度远远快于 DRAM，因此常被用在 Cache Memories（高速缓存器）中（成本也是高速缓存通常大小比较小的原因之一）。</p><p><strong>Needs EDC</strong> 的含义是指，必须用一定的电压作用在存储单元胞的两端，否则一断电就会丢失电荷，数据也会丢失（<strong>又称 Volatile Memories</strong>）。这也是 RAM 需要插电用的原因（当然，如果把它从电源上拔下后迅速扔进液氮中，可以保留其中数据，因为电荷散失速度可以忽略）。</p><p>DRAM 被广泛应用于主存、图形显卡的 <strong>帧缓存（frame buffer）</strong>中。</p></blockquote></li></ul><h3 id="10-1-2-Nonvolatile-Memories"><a href="#10-1-2-Nonvolatile-Memories" class="headerlink" title="10.1.2 Nonvolatile Memories"></a>10.1.2 Nonvolatile Memories</h3><p><strong>ROMs</strong></p><p>除了 RAM，计算机存储系统中另一类存储器是 <strong>非易失性存储器</strong>，它们在计算机断电后仍然能保存数据。请回忆数电中介绍的几种电子元件：</p><ul><li><strong>ROM</strong>（Read-Only Memory，只读存储器），出厂时就编程完成，通常电路烧在板子上不可更改；</li><li><strong>PROM</strong>（Programmable ROM，可编程只读存储器），只能对电路编程一遍；</li><li><strong>EPROM</strong>（Erasable PROM，可清除可编程只读存储器），可以被特殊作用清除电路信息（UV / X-rays）；</li><li><strong>EEPROM</strong>（Electrically Erasable PROM，电驱动可清除可编程只读存储器），可以使用电路、电子清除其中信息，但只能反复清除重写 100,000 次。</li></ul><blockquote><p>它们的电路结构想必各位脑海中都非常清楚对吧？</p></blockquote><p>其中，大家所熟知的 <strong>闪存（Flash Memory）</strong>，就是许多 EEPROM 元件组成的。</p><blockquote><p>Tips. 计算机存储系统中的<strong>主存</strong>包括了 <strong>ROM 和 RAM</strong>，但闪存作为 ROM 的一种，<strong>也是现代最常用的 ROM</strong>，也可以和机械硬盘一起被用在<strong>外存</strong>中。</p></blockquote><p>这些 ROM 的作用很广泛，主要有以下几个方面：</p><ul><li>普通 ROM <strong>常被用作重要的、不应该被更改的数据的存储</strong>，例如 BIOS（存储计算机系统启动时的指令 + boot 引导程序）、Controllers for disks（硬盘控制器）、Network Cards（网卡）、Graphics accelerator（图形加速器）、Security subsystem（安全子系统）；</li><li>它们（闪存）还会被用在 <strong>固态硬盘</strong>（SSD，Solid State Disk，代替转圈易坏的机械硬盘，用在笔记本电脑、手机、mp3 播放器、平板等设备，系统会把 SSD 看成机械硬盘）中；</li></ul><p><strong>机械硬盘</strong></p><p>除了 ROM 一类的非易失性存储器，还有 <strong>外存</strong>（外部存储器）也是非易失性存储器。我们这里介绍有代表性的机械硬盘：</p><ul><li><p>结构包括传动臂、SCSI 连接口、盘片、盘片轴……</p></li><li><p>硬盘中包含一系列盘片（platter），每个盘片有两个面，每个面上涂有磁性材料，并且存在一圈圈同心圆（concentric rings），被称为 <strong>磁道（tracks）</strong>，每个磁道包含若干 <strong>扇区（sectors）</strong>，扇区之间会有空隙间隔（gaps），<strong>一个扇区通常的大小是 512 bytes</strong>；</p><p><img src="imgs/disk_geometry.png" height="240px"></p><p>盘片轴（spindle）连接一系列盘片，<strong>每个盘片相同位置对齐的磁道称为 Aligned tracks，在垂直方向组成一个圆柱</strong>，这个相同位置的磁道所组成的元素称为 <strong>柱面</strong>，数据按照不同柱面进行存储，同一柱面的数据连续（为啥按柱面存？因为方便机械臂访问）。</p><p><img src="imgs/disk_geometry_multi_platter.png" height="240px"></p></li><li><p>传动臂悬浮在盘片上方，隔着一层薄薄的空气。其末端读写头可以感知编码位的磁场变化；</p></li><li><p>机械磁盘内置电子设备，用于控制传动臂的移动等操作，其驱动程序一般存于 ROM 中；</p></li><li><p>机械性质决定了机械硬盘的读写速率慢于 RAM 和 ROM；</p></li><li><p>硬盘承载量取决于 <strong>数据记录密度（recording density，1 inch 磁道段中能存放多少 bit 信息）、磁道密度（track density）、面密度（Areal density，前面二者的乘积）</strong>；</p></li></ul><blockquote><p>⚠ 易错点警告：对于硬盘来说，它的承载量单位 GB 是特殊的：<strong>1 GB = $10^9$ Bytes</strong>，这与之前我们见到的衡量二进制数据大小的单位 GiB（<strong>其简称也叫 GB，1 GiB = $2^{30}$ Bytes</strong>）是不一样的。</p><p>这么说就明白了：<strong>承载量单位应该分开来看</strong>：1 G | B，1 吉 (Giga) = $10^9$；</p><p>而<strong>衡量二进制数据大小的单位是个整体</strong>： 1 | GiB，GiB 本身是 gibibyte（giga-binary byte），是 byte 单位的 $2^{30}$ 倍；</p><p>最常见的是计网的考题：<strong>1 MB/s 在 1 s 内传输的数据量略小于 1 MB</strong>，因为承载量速率单位 1 MB/s 是 $10^6$ Bytes / s，而数据大小 1 MiB 是 $2^{20}=1024^2$ Bytes；</p></blockquote><ul><li><p>在很早以前的机械硬盘中，每个磁道的扇区数目固定，这会导致大量的空间浪费。所以现代的机械磁盘<strong>将许多磁道划分为一个个不相交子集，称为记录区（recording zones）</strong>：</p><ul><li>每个处于同一记录区中的磁道含有相同的扇区数，它取决于最内侧磁道；</li><li>每个记录区中的磁道的扇区数不同，越靠近内圈的记录区中磁道的扇区数越少；</li><li><strong>因此我们使用平均扇区数 / 磁道数来计算承载量</strong>；</li></ul><p>如下图，阴影部分为一个记录区，含有许多扇区数相同的磁道：</p><p><img src="imgs/recording_zone.png" height="200px"></p><blockquote><p>题型：计算磁盘承载量</p><p><strong>承载量 = 每个扇区的 byte 数（通常 512 bytes）× 一个磁道中平均扇区数 × 一个盘面中的磁道数 × 一个盘片上表面数目（对三维生物来说=2）× 每个磁盘的盘片数</strong>；</p></blockquote></li><li><p>机械硬盘借助悬浮在盘面上方的传动臂进行读取，许多传动臂在磁盘同一半径处读写，其搜索读取读取速度取决于三个因素：<strong>寻道时间（一般最长，大约 3~9 ms）、旋转延迟、传输时间</strong>。</p><p><img src="imgs/disk_op.png" height="200px"><img src="imgs/disk_access_time.png" height="200px"></p></li><li><p>关于数据访问的耗时，有一些数字可以了解一下：</p><ul><li><p>一般情况下机械硬盘的 <strong>寻道时间 &gt; 旋转延迟 ≈ 4 ms &gt;&gt; 传输时间</strong>；</p><blockquote><p>机械硬盘访问扇区的第一个 bit 耗时最多，其他几乎不耗时；</p></blockquote></li><li><p>SRAM 访问 8 bytes 数据平均需要 4 ns，DRAM 需要 60 ns，<strong>而机械磁盘比 SRAM 慢 40000 倍，比 DRAM 慢 2500 倍</strong>；</p></li></ul></li><li><p>硬盘（机械 / SSD）的<strong>逻辑块（Logical Disk Blocks）</strong>：现代硬盘提供了一个面向 CPU 的更简单的抽象。硬盘的可用扇区被抽象为一组 b-sized 的逻辑块（编号从 0 开始）；</p><ul><li><p>每个逻辑块是<strong>扇区大小的整数倍</strong>（跳过 gaps），最简单的情况下，一个逻辑块就是一个扇区；</p></li><li><p>磁盘控制器来保持从物理扇区到逻辑块之间的<strong>映射</strong>（间接层面、抽象层面）；</p><blockquote><p>这允许磁盘控制器保留一部分 <strong>柱面</strong>（前面提到的存储信息按照同心磁道组成的柱面） 不进行映射，作为 <strong>备用柱面</strong>。</p><p>当某一柱面上的一个扇区损坏，那么磁盘控制器可以直接将数据复制到备用柱面，然后磁盘就能继续正常工作。</p><p><strong>这就是为什么磁盘的 “格式容量”（formatted capacity）比实际容量小</strong>。</p></blockquote></li></ul></li></ul><p><strong>固态硬盘</strong></p><p>固态硬盘作为一种更新的、用来代替机械磁盘的外存形式，其控制器接口和机械磁盘一样，所以 CPU 一视同仁，不过它的速度介于 DRAM 和 机械硬盘之间。</p><p>其内部<strong>全部由闪存构建</strong>，并且由一个固件（firmware）称为闪存翻译层（<strong>flash translation layer</strong>）充当控制器（其作用和机械硬盘的磁盘控制器相当）；</p><p>数据在 SSD 中是以 <strong>页（page）</strong> 为单位从闪存中读取和写入的。页的大小 512 KB ~ 4 KB，块（block，和之前提到的 CPU 所认为的逻辑块<strong>不同</strong>，下面解释）一般包含 32 ~ 128 页，<strong>取决于 SSD 实现的技术</strong>；</p><blockquote><p>这里所说的 “块” 为啥和之前的 “逻辑块” 不同？</p><p>首先明确，这是个术语重叠的现象。这里的 SSD 中的 “块” 是闪存的性质导致的。目前技术下闪存的数据擦除是<strong>成块成块擦除</strong>，这意味着一次会同时擦除多个页。因此，人们把<strong>闪存一次擦除的一组页集合称为 “块”</strong>。</p><p>因此，想要修改某个块中的某个页，需要 <strong>将该块全部擦除（之前应该复制到其他位置）</strong> / <strong>找到一个已被擦除的块</strong> 才能写入；</p><p>现代的闪存翻译层中实现了很多专有算法，能够延长 SSD 的使用寿命，例如缓存技术。</p></blockquote><p><img src="imgs/ssd_struct.png" height=240></p><p>固态硬盘的读写效率大致是 <strong>随机访问 300 MB/s 左右，顺序访问 500 MB/s 左右</strong>（Intel SSD 730 的数据），可以说<strong>在计算机的存储系统的层次结构中，随机访问总是比顺序访问更耗时</strong>。其中 SSD 写入速度都略低于读取速度，这是因为闪存写入前需要擦除原先数据。总的来说，SSD 的访问速度大约比机械硬盘快 10 倍左右。</p><p>其实，SSD 和机械硬盘各有优劣，相较于机械硬盘，SSD 具有以下特征：</p><ul><li>（优势）没有机械移动，更快、耗能更低、更结实（较不易摔坏），适合用在便携设备中；</li><li>（劣势）可能磨损，但问题不大，一般生命周期中可以写 100 PB+ 的数据（足够用多年）；</li></ul><p>最后看一下各种存储介质和 CPU 时钟频率的关系：</p><p><img src="imgs/CPU_memory_gap.png" height="400px"></p><blockquote><p>2003 年，CPU 设计达到性能能源瓶颈，其发展从增大时钟频率转向增大 CPU 内核数。</p></blockquote><h3 id="10-1-3-Traditional-Bus-Structure-Connecting-CPU-and-Memory"><a href="#10-1-3-Traditional-Bus-Structure-Connecting-CPU-and-Memory" class="headerlink" title="10.1.3 Traditional Bus Structure Connecting CPU and Memory"></a>10.1.3 Traditional Bus Structure Connecting CPU and Memory</h3><p>说完计算机存储系统的硬件，那么它们是怎么与 CPU 建立连接，进而抽象出 “内存空间” 和 “存储空间” 的呢？</p><p><img src="imgs/io_bus.png" width="600px"></p><blockquote><p>其中 I/O 桥是另外的一些芯片组，另一些芯片的集合。</p></blockquote><p><strong>CPU 访问主存</strong></p><p>上面的图仅仅是比较简单粗略的抽象，不要较真。在比较老的计算机架构中（因为现代系统有专有的总线设计，非常复杂），采用 <strong>总线（bus）</strong>来连接 CPU 和主存的，数据通过总线在主存和 CPU 间来回传输。<strong>并且总线通常与其他多种设备共享</strong>。</p><p>正常情况下，CPU 中的 ALU 根据汇编机器指令只需访问最近的寄存器就行；如果指令要求它访问内存，那么 ALU 会交由总线接口（Bus Interface）去从主存中取出相应位置的数据。</p><p>大家可以思考一下，在上面这幅图中，<code>movq %rax, $A</code> （A 为内存地址）和 <code>movq $A, %rax</code> 应该如何形象表示？</p><p>大家不难发现，<strong>寄存器离 CPU 很近，所以访问速度很快</strong>，通常在 3 个时钟周期左右就能读写到值。但是内存（图中 Memory Devices 芯片组）离 CPU 相当远，中间的步骤相当多，所以<strong>对内存读写所消耗的时间大约是对寄存器读写耗时的 100 倍左右</strong>。这就是计算机内存系统引入所发现的其中一个性能损耗。</p><p><strong>CPU 访问外部设备（以外存: 磁盘为例）</strong></p><p>再来看 I/O 总线（I/O Bus），它将各个设备与 I/O 桥连接，<strong>使得外部设备能和主存一样被 CPU 访问</strong>。I/O Bus 看起来是一条线，可实际不是如此。因为在老式的计算机中，它被称为 PCI 总线（广播总线），主干连接到各个设备，任何设备只要更改其上的数据，其他设备就能发现。</p><p>但现代的 I/O 总线并不是一条线了，它采用了 PCI Express 的总线结构，并不像上面画的一样，它是 <strong>点对点地连接两个设备</strong>，实现不同（我们不会深入讨论），但提供的功能就像图上画的一样。所以可以把 I/O Bus 看作一组电子线路即可。</p><p>其中 Disk、Mouse、Keyboard、Monitor 等设备使用细双箭头，表示它们不是焊在主板上，而是插入主板上的控制器（adapter、controller）来连接。</p><p>考虑如果 CPU 想要访问某个磁盘设备的某个扇区，那么会进行如下步骤：</p><ul><li>CPU 生成一个三元组（triple）：<strong>指令</strong>（read / write）、<strong>逻辑块编号</strong>、该块中的数据要放到哪个<strong>内存地址</strong>中（CPU 先从磁盘读入内存，再从内存读入 CPU 寄存器，反方向亦然），并且当前线程的程序暂停执行（如果是 I/O 阻塞的话），等待数据传输；</li><li>三元组通过总线接口、I / O 桥、I / O 总线传给磁盘控制器；</li><li>磁盘控制器通过读取与该逻辑块对应的任何扇区（一个逻辑块可能包含很多扇区）读入磁盘缓存；</li><li>磁盘控制器取得总线控制权，并且<strong>将数据通过 I/O 总线、I/O 桥和内存总线直接送往指定内存地址，而无需将数据传给 CPU</strong>；</li><li>数据传输结束后，磁盘控制器借助 “I/O 总线 - I/O 桥” 从<strong>新的通路</strong>（不经过总线接口）直接用电信号触发 CPU 的某个<strong>引脚</strong>，这个信号代表一种<strong>中断（interrupt）</strong>，通知 CPU 该扇区已被复制，此时暂停的程序继续执行；</li></ul><h2 id="10-2-Locality"><a href="#10-2-Locality" class="headerlink" title="10.2 Locality"></a>10.2 Locality</h2><p>无论是 8.1.2 中介绍的各自存储介质在物理层面上的性能约束，还是 8.1.3 中介绍的数据读取流程上的性能限制，都是计算机存储系统需要解决的重要问题，否则，在硬件上计算机就难以继续提升运行速度了。</p><p>其实，弥补 CPU 和内外存读写速率之间差距的机制之一就是<strong>程序的基本属性之一：局部性（locality）</strong>。</p><p>局部性原则：程序倾向于使用 “<strong>内存地址接近或等于最近使用过的数据/指令地址的</strong>” 那些数据和指令。</p><blockquote><p>原文：Programs tend to use data and instructions with addresses near or equal to those they have used recently.</p></blockquote><p>这个原则来源于程序编写的逻辑——<strong>当程序访问到某个内存地址上的数据，那么在不久的将来，有很大的可能程序会访问该数据项或者附近的数据项</strong>。</p><p>这种局部性有两种表现形式：</p><ul><li><p>时间局部性（Temporal Locality）：最近引用的存储器位置可能在不久的将来再次被引用；</p></li><li><p>空间局部性（Spatial Locality）：如果访问了一个存储器的位置，那么有很大可能在将来会访问一个临近的位置；</p></li></ul><blockquote><p>例子：识别代码中的局部性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> sum += a[i];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure><p>这串代码中，有对<strong>数据的引用</strong>（Data references，转为汇编后会引用数据，通常只要有变量就有数据的引用）。</p><p>例如上面的数组 <code>a</code>，其元素在内存上连续，索引 i 每自增一个单位就访问一下（称为 stride-1 reference pattern），属于空间局部性；上面的变量 <code>sum</code> 在循环的每次迭代中都会被引用，属于时间局部性；</p><p>还有对<strong>指令的引用（Instruction references）</strong>，例如循环中每一次都会执行循环体的内容，属于时间局部性；再比如程序代码顺序执行，本身就属于空间局部性。</p></blockquote><p>不同编写方法的代码，其局部性不同。这就需要开发者训练观看的能力。举一个很简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array1</span><span class="params">(<span class="type">int</span> a[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_array2</span><span class="params">(<span class="type">int</span> a[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们考虑对数据的引用，<strong>回忆 6.1 中对于 Nested Array 的内存排列的知识</strong>，数组数据连续排列且<strong>行优先</strong>，所以我们发现，使用 <code>sum_array2</code> 方式遍历数组，其<strong>数据相距距离很远</strong>，这意味着程序的局部性差于 <code>sum_array1</code>。而事实上，<code>sum_array2</code> 也真的会比 <code>sum_array1</code> 慢一个数量级；</p><blockquote><p>例题：请修改以下代码，使得它满足 stride-1 reference pattern（即更优的程序局部性）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array_3d</span><span class="params">(<span class="type">int</span> a[M][N][N])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i, j, k, sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">     <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">         <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">             sum += a[k][i][j];</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="10-3-Conclusions-for-10-1-amp-10-2"><a href="#10-3-Conclusions-for-10-1-amp-10-2" class="headerlink" title="10.3 Conclusions for 10.1 &amp; 10.2"></a>10.3 Conclusions for 10.1 &amp; 10.2</h2><p>没错，前面两节全部在为存储系统的层次结构<strong>做准备</strong>，之后我们才开始正式讨论 Memory Hierarchy。在此之前，我们先小总结一下前面的内容。</p><p>在本章开始，我们认识了计算机存储系统在硬件层面的两大组成：主存和外存。主存由 RAM（又分为 SRAM 和 DRAM）组成；外存则是硬盘（又分为机械硬盘、SSD）、可移动磁盘为主。</p><blockquote><p>广义的内存包括：主存（RAM）、全部 ROM、Cache（高速缓存存储器）；</p></blockquote><p>我们紧接着比较了 SRAM 和 DRAM 的特征、异同，以及它们所使用的场合；对于 ROM，我们了解了不同的 ROM 类型，还有闪存的定义。</p><p>在外存方面，我们详细介绍了机械磁盘的物理结构（磁盘控制器、盘面、柱面、磁道、扇区、记录区、承载量计算、访问耗时分析、逻辑块），并类比出功能相同、实现不同的固态硬盘物理结构（闪存翻译层、页、块）。</p><p>于是，我们从上面存储介质的物理结构中分析并得出 <strong>其数据访问模式的性能限制和优劣</strong>。</p><p>最后，我们分析了 <strong>CPU 访问主存</strong> 和 <strong>CPU 访问外存</strong> 的情况和流程，从中我们得知了在内存读取的流程中也存在着性能的限制或者说损失。</p><p>基于这些物理结构的限制，我们讨论出代码结构层面能够在一定程度上弥补这些性能鸿沟的性质：<strong>局部性</strong>。我们根据 <strong>存储设备的物理结构</strong> 和 <strong>数据存放的方式</strong>，可以设计写出更符合程序局部性的代码，这在一定程度上可以缓解 CPU 和内存之间访问的性能差距。</p><p>而观察代码的局部性，就需要对数据在内存中的 layout，还有储存设备的工作原理有一个很好的认识，这就是前几章、前几节的内容。</p><p><strong>这些存储介质的物理特性，和程序的局部性相辅相成，相得益彰，为人们提供一种 “怎样设计存储系统” 的建议和信息。</strong></p><p>接下来，我们将基于这些存储介质的物理性质，讨论在其上所建立的层次结构，和这些层次结构是如何抽象硬件，尽可能地为上层的计算机软件提供更连续完整的资源的。</p><h2 id="10-4-Memory-Hierarchy-amp-Idea-of-Caching"><a href="#10-4-Memory-Hierarchy-amp-Idea-of-Caching" class="headerlink" title="10.4 Memory Hierarchy &amp; Idea of Caching"></a>10.4 Memory Hierarchy &amp; Idea of Caching</h2><p>下图是计算机存储系统的一个层次结构图。</p><p>其中，寄存器是访问速度最快的存储结构，它在每个 CPU 时钟周期内都可以直接访问到（大小最小、数量很少、价格最贵、速度最快）；</p><p>接下来的是由 SRAM 组成的高速缓存存储器（Cache Memory），也处于 CPU 芯片内部，既不是主存，也不是寄存器；大小虽然是 MB 级，但已经比寄存器大多了。其中 3 层 Cache Memory 的具体结构将在下一章进行深入讨论；</p><p>再向下是 DRAM 组成的计算机的主存，一般你能看到的 “内存条” 就是它的组合结构，也是普通人经常说的 “内存”（狭义内存），一般从几个 G 到 几十 G 不等，程序运行内存（或者说后面要提到的<strong>虚拟内存</strong>）就是它的一部分；</p><p>最底层的像本地硬盘结构，甚至云端存储结构，空间一般都很大，但访问效率低下。</p><p><img src="imgs/memory_hierarchy_example.png" height="400px"></p><p><strong>设计的核心：在 Memory Hierarchy 中，每一层都包含着从下一层所检索的数据</strong>（例如 CPU 寄存器保存着从 L1 高速缓存中取出的数据，依此类推）；</p><p>这样设计的原因是为了充分利用各个层级资源的特征，将整体数据访问效率最大化（<strong>底层是极大的数据池，却能够以极快的速度进行访问</strong>）。</p><p>这么做之所以有效，是因为 <strong>缓存思想（Caching）的存在</strong>。</p><p>这里所说的缓存，<strong>不是高速缓存存储器（Cache memories），而是一种思想</strong>。<strong>作为一个更小、更快的存储设备，充当更慢设备中数据的暂存区域、能更快访问的数据子集</strong>。例如，主存 可以看成是本地硬盘的 缓存，这样一旦从磁盘获取数据，就无需在磁盘上访问它，在上一个层级内存中访问，速度得到提升。依此类推，<strong>缓存的思想在 Memory Hierarchy 中逐级传播</strong>。</p><blockquote><p>第 k 层更快、更小的存储设备，就是第 k+1 层更慢、更大存储设备的 缓存。</p></blockquote><p>在真实场景中，每当程序访问一个不在缓存设备（第 k 层）中的数据，都会从第 k+1 层检索，并复制到第 k 层缓存起来。这是因为，<strong>根据程序的局部性</strong>，相较于第 k+1 层的设备，会更经常访问第 k 层设备中的数据，这就是 Memory Hierarchy 能最大化数据访问效率的原因。</p><hr><p>在详细介绍高速缓存存储器（狭义的 Cache）前，我们简单介绍一下<strong>缓存的实现</strong>，因为缓存思想存在于存储层次结构的每一层。</p><p><img src="imgs/general_cache_concept.png" height="240px"></p><p>储存数据的下层设备的空间（k+1 层）通常被分为一个个固定大小的块（blocks），缓存设备和下层设备间传输的数据以块为单位进行。</p><blockquote><p>如果第 k+1 层是 Web 云端存储介质，那么 blocks 通常以文件形式传给磁盘（第 k 层，缓存设备）；</p><p>如果第 k+1 层是主存，那么 blocks 可能是以某个特定大小的数据块传给高速缓存存储器（第 k 层，缓存设备）；</p><p>……</p></blockquote><p>在任意时间点，第 k 层的缓存设备中的数据都是第 k+1 层设备数据的一个子集。</p><p>对于 CPU 请求一个位于第 k+1 层的某个位置的数据这种情况，则 CPU 会先去层级最高的设备中寻找（假设找到第 k 层），则有两种情况：</p><ul><li><p>如果恰好找到了（假设请求如下图绿色块 14 的数据），那么 CPU 就直接从缓存（第 k 层）中读走这个数据，无需向下请求数据，总体提升了效率。这种情况称为 <strong>Cache Hit</strong>（缓存命中）；</p><p><img src="imgs/cache_hit.png" height="240px"></p></li><li><p>如果没有找到，那么 CPU 就需要从更下一层取得此数据块，并<strong>将它存放在缓存设备中</strong>。这种情况称为 <strong>Cache Miss</strong>（缓存不命中）；其本身又分为 3 个类型：</p><ul><li><p>Cold（compulsory）Miss：缓存为空，所以 Miss，不可避免；</p></li><li><p>Capacity Miss：由于较小的缓存空间而导致的不命中，通常是因为程序的工作集大于缓存空间所致。可以由增大缓存空间而减少；</p><blockquote><p>工作集（working set）：当前不断被程序访问的块，也即活跃的缓存块（active cache block）；</p></blockquote></li><li><p>Conflict Miss：由于大部分缓存设备（尤其硬件缓存）必须设计的比较简单，它限制了缓存块的放置位置（例如第 i 块必须放在 <code>i mod sizeof(Cache)</code> 的位置，很类似 hash table 的碰撞），这与缓存实现方式有关，也在下一章进一步讨论；</p></li></ul><p><img src="imgs/cache_miss.png" height="240px"></p></li></ul><p>最后，我们总结一下缓存在存储系统各层级的实现情况：</p><p><img src="imgs/caching_in_hierarchy.png" height="400px"></p><blockquote><p>注：TLB（Translation Lookaside Buffer，后备缓冲）是一个在虚拟内存中使用的缓存，<strong>是虚拟地址翻译为物理地址的翻译过程的缓存</strong>；</p></blockquote><p>需要注意的是，<strong>各个层级的缓存究竟是由谁实现和管理的</strong>，这是缓存思想的一个重点，也能解释早在第 3 章的疑问——<strong>汇编代码中找不到管理高速缓存存储器的代码</strong> 的原因。</p><p>例如，当寄存器看作缓存设备时，是编译器决定用哪个寄存器、用多少个寄存器（怎么用的 conventions 是 ABI 决定的）；</p><p>综上，缓存思想存在于计算机系统的几乎每个用到数据 I/O 的地方。</p><p>下一章将讨论 Memory Hierarchy 中一个具体的部分 <strong>高速缓存存储器</strong>，来深入了解缓存思想。</p><h1 id="Chapter-11-Cache-Memories"><a href="#Chapter-11-Cache-Memories" class="headerlink" title="Chapter 11. Cache Memories"></a>Chapter 11. Cache Memories</h1><blockquote><p>本章讲述 Memory Hierarchy 缓存思想中的重要一个体现：高速缓存存储器（Cache memories），它介于寄存器和内存之间，充当缓存设备的角色。</p></blockquote><p>回忆上一章的内容，高速缓存器本质上是一种由 SRAM 组成的、由硬件直接管理的小型缓存存储设备：<strong>Cache memories are small, fast SRAM-based memories managed automatically in hardware</strong>.</p><p>它一般封装于 CPU 芯片中，几乎和寄存器距离 CPU 核心同样近（只是由于电路存取特性导致其慢于寄存器），存储主存中被频繁引用的数据块。</p><h2 id="11-1-General-Cache-Organization"><a href="#11-1-General-Cache-Organization" class="headerlink" title="11.1 General Cache Organization"></a>11.1 General Cache Organization</h2><p>那么硬件是如何管理高速缓存存储器中的数据，在 CPU 需要的时候进行寻找呢？我们首先需要借鉴<strong>层次架构中一般的缓存模型</strong>，它们共同有一种缓存的管理方式和 layout；</p><p>首先，缓存本身就需要极速，这意味着设计缓存机制必须<strong>以非常严格且简单的方式去组织缓存模型</strong>，便于各个设备层级间进行查找。于是人们设计了下面的缓存数据组织形式：</p><p><img src="imgs/general_cache_organization.png" height="350px"></p><p>缓存空间中一般包含 $S=2^s$ 个数据组（set），每一组又包含 $E=2^e$ 个数据行（line，图中<strong>横着排列</strong>），每一数据行由大小为 $B=2^b$ bytes（B binary digits）的数据区块和一个 tag 区、一个 valid bit 组成；现在解释一下目前可能有的疑惑：</p><ul><li>valid bit 指示当前缓存数据行中的数据实际上也真实存在于下层的存储介质中，可以直接使用（例如第一次打开机器的时候，这些数据区块位置上是随机 bits，因此这些 valid bit 会提示数据区块无效）；</li><li>tag 位（标记位）编码了这串数据位于下层存储介质的位置，在 CPU 搜索时有用；</li><li>为何无论是组数、数据行数还是每个数据行中的字节数都是 2 的幂次呢？<strong>这是一个非常重要的点。因为，缓存空间按照 内存地址的数码的各个位 来直接对应该内存数据应该存放的位置</strong>。这个比较抽象，后面的例子就会慢慢理解。</li></ul><p>其中高速缓存块的大小 <u>不包含 Tag 和 valid 部分</u>，也就是说，高速缓存的大小 $C=S\times E\times B$；</p><h2 id="11-2-Read-Cache"><a href="#11-2-Read-Cache" class="headerlink" title="11.2 Read Cache"></a>11.2 Read Cache</h2><p>那么缓存是如何被读取的？详细数据结构（和具体存储设备有关）又是什么样子的？</p><p>实际上，程序在运行中可能请求了下层存储介质中某个位置的数据，我们<strong>以高速缓存存储器和主存间查找数据的关系为例</strong>。步骤如下：</p><ul><li>假设程序指令要求引用主存中虚拟内存的某个地址（设为 <code>X</code>）的数据，那么 CPU 会向高速缓存存储器请求 <code>X</code> 地址下的值；</li><li>这个请求的地址会被 高速缓存存储器 <strong>直接用来查找缓存存放的位置（即这个地址的数据存放在）</strong>。其中 <code>X</code> 会被 高速缓存存储器 <strong>解析成</strong>如下图所示的结构（<strong>这就是为什么上面的 <code>S</code>、<code>E</code>、<code>B</code> 都是 2 的幂</strong>。看着这张图你能想明白吗？还不能明白的话，后面会有更具体的例子）：</li></ul><p><img src="imgs/addr_B.png" height="125px"></p><ul><li>高速缓存存储器 <strong>首先 extract <code>X</code> 中 s bits 的 <code>set index</code></strong>（缓存组索引）看作为 unsigned int，用它找到缓存空间中特定的组（和数组索引很像）；</li><li>高速缓存存储器 接着<strong>并行检查（依赖于硬件电路的检查机制）</strong>该组中所有的数据行，将 tag 字段与每个数据行中的 tag 进行比较。如果找到了相同的 tag，那么再检查 valid bit 是否指示有效。所以会出现以下情况：<ul><li><strong>情况一</strong>：该组的数据行中不存在 tag 与 <code>X</code> 一致的行，<strong>说明请求的数据块不在缓存中（Cache miss）</strong>；</li><li><strong>情况二</strong>：该组的数据行找到了 tag 与 <code>X</code> 一致的行，但 valid bit 指示无效，<strong>说明请求的数据块无效，当前也不在缓存中（Cache miss）</strong>；</li><li><strong>情况三</strong>：该组的数据行找到了 tag 与 <code>X</code> 一致的行，并且 valid bit 指示有效，<strong>Cache hit</strong>！</li></ul></li><li>如果是 cache hit，那么<strong>extract</strong> <code>X</code> 中 b bits 的 <code>block offset</code>，从该数据行的数据区块开头地址加上这个 offset，将得到的地址再数据行中剩余部分规定大小读出，直接传给 CPU，结束查找过程；</li><li>如果是 cache miss，那么高速缓存存储器会放弃查找，将原本的请求地址 <code>X</code> 传给下一级存储设备（主存），那么查找工作交给主存（重复上面类似的步骤）。<strong>注意，当主存找到数据向上提交时，再次给到高速缓存存储器</strong>，将数据放在高速缓存存储器的应该是 <code>X</code> 的位置<strong>缓存起来</strong>（通常会覆盖相同位置的其他数据），然后高速缓存存储器再将数据向上提交给 CPU；</li></ul><p>总体呈现出 <strong>“逐层向上缓存数据，逐层向下查找数据”</strong> 的形式。</p><h3 id="11-2-1-Direct-Mapped-Cache-Simulation"><a href="#11-2-1-Direct-Mapped-Cache-Simulation" class="headerlink" title="11.2.1 Direct-Mapped Cache Simulation"></a>11.2.1 Direct-Mapped Cache Simulation</h3><p>下面详细解释上面的步骤。为了便于理解，我们首先从简单的情况讨论，<strong>当每一个缓存组只包含一个数据行的情况，这种情况被称为 “直接映射”（Direct-Mapped Cache Simulation）</strong>：</p><p>假设某个机器的内存空间大小 M = 16 bytes（可以用 4-bit digit 代表地址），缓存空间中含有 4 个组（S = 4），每个组含有一个数据行（E = 1），每个数据行含有 2 bytes 的数据区块（B = 2）。</p><p>在数据区块中，block offset 的长度为 1 byte（b = 1，因为数据区块只有 2 bytes，一般有 $B=2^b$），set index 的长度为 2 bytes（s = 2，因为缓冲区只有 4 组数据组，有 $S=2^s$）；</p><p>现在程序开始运行的时候，分别请求内存地址（$X$）为 0、1、7、8、0 的 1 byte 数据；</p><p>现在，高速缓存存储器中的所有数据行的 valid bit 都是 0（假设 0 代表无效，1 代表有效），并且开始接受 CPU 请求内存地址 $X = 0 = 0000_2$ 的数据 的请求。</p><p>首先，$X$ 的 block offset <strong>就是中间 2 bit</strong>，<code>00</code>，所以在 <code>set 0</code>（第 0 组）中寻找；然后，将 $X$ 的 tag 位（即最左边的 1 bit，0）与 <code>set 0</code> 的 tag 比较（是随机数），再看 valid bit 是 0，所以 cache miss（cold miss），如下动画（本人不会 Acrobat Animate，比较粗糙）：</p><p><img src="imgs/directMappedCacheSimulation_part1.gif"></p><p>思考两个问题，第一个，为什这里的 tag 是 0 ？这是因为，我们在给定的 set offset 下（组相同），前面的 t bit（t=1）的 tag 位<strong>只是用来区分数据行</strong>的，<strong>借助了原内存地址 <code>X</code> 的前 t bits 数据</strong>而已，没有实际意义。</p><p>第二个，为什么这里要从 main memories 中同时读入 0、1 地址的数据？也就是说，为什么设定 <code>B == 2</code> 呢？<strong>这是因为，除去 set offset 的 2 bits、tag 的 1 bit，剩下内存地址 <code>X</code> 数码还有 1 bit 留给 block offset</strong>，因此 <code>X</code> 只能在该组的数据行中索引 2 bytes 的数据。</p><p>细细体会上面的话，你会发现这就是缓存空间如此设置、<code>X</code> 如此解析的原因（这里设计的和 IEEE 浮点数表示法一样巧妙，不容易用语言描述）。</p><hr><p>好了，又有同学会好奇了，既然这些索引本身没有意义，只是借助了原地址的数码，<strong>那为什么设计缓存索引的人一定要 <code>set index</code> 在中间、tag 在最前面、block index 在最后面呢</strong>？</p><p>这个问题非常有水平，这和<strong>二进制数码的变化方式有关</strong>。我们这里就分析对比 2 种解释 <code>X</code> 地址的方式：</p><ul><li>Middle Bits Indexing：就是上面的 <code>X</code> 的结构，Tag 在前、<code>Set index</code> 在中间、<code>Block index</code> 在最后；</li><li>High Bits Indexing：<code>Set index</code> 在前、Tag 在中间、<code>Block index</code> 在最后；</li></ul><p>我们接下来<strong>将缓存空间的组标为不同颜色，再把内存中将要分配到哪一组的数据块填上相同的颜色</strong>，发现结果如下：</p><p><img src="imgs/middle_bits_indexing.png" width="360px"><img src="imgs/high_bits_indexing.png" width="360px"></p><p>我们发现，<strong>如果用 high bits indexing，那么内存地址相近的内存区域很容易被分配到相同的缓存组中，根据<u>空间局部性</u>，这样做会导致发生 conflict miss 的概率大大增加</strong>。所以，在缓存效率上，middle bits indexing 是优于 high bits indexing 的。其他情况同理。</p><p>这就是设计者们为什么要如此设计内存地址 <code>X</code> 在缓存中的这种解析方法。</p><hr><p>继续看接下来的过程动画：</p><p><img src="imgs/directMappedCacheSimulation_part2.gif"></p><p>我们发现，5 次访问中，有<strong>高达 4 次的 cache miss</strong>。后面 2 次的 cache miss 都是 conflict miss，完全能够由 提高每组的数据行数（<code>E</code> 的大小）来避免。<strong>因此，缓存结构中 <code>E</code> 的大小越大越好（也就是每组中的数据行越多越好）</strong>。但是我们前面提到，一个组中各个数据行<strong>使用并行比较</strong>，这个操作依赖硬件的多路判断——<strong>也就是说，<code>E</code> 越大，硬件电路越复杂，硬件越贵</strong>。所以真实计算机硬件中会进行取舍，选择一个特定的 <code>E</code> 值。</p><blockquote><p>当代（21 世纪初）市面上的常见的单组中数据行数目取值 <code>E = 8</code>，最大有 <code>E = 16</code>，是 Intel 的 16 路相联 L3 三级缓存。</p></blockquote><p>事实上，<code>B</code>（数据区块的大小，block size）也是越大越好，因为越大越可以利用局部性，提升缓存命中概率。但 <code>B</code> 受限于<strong>两个因素</strong>：一是<strong>硬件成本</strong>（例如 Cache memories 由 昂贵的 SRAM 组成），二是<strong>块复制的时间代价</strong>，因为如果想要把很大的数据区块从内存挪至缓存中，也是一个不小的开销。</p><p>综合上面的考虑，设计者真正确定缓存空间各个参数的步骤如下：</p><ol><li><strong>确定合适的数据区块（就是在数据行中的那个字段）大小 <code>B</code></strong>（通常被称为<strong>固定的缓存高级设计参数</strong>。Intel 一般 64 bytes）；</li><li>根据实际应用场景和硬件成本情况<strong>确定大致的缓存空间总大小</strong>（也是固定的缓存高级设计参数之一）；</li><li>根据硬件和实际情况<strong>确定数据组的关联性（associativity，即一个数据组中有多少数据行）<code>E</code></strong>；</li><li>由 1、2、3 就能计算出大致的<strong>缓存数据组数（<code>S</code>）</strong>。</li></ol><blockquote><p>最极端的情况是 <strong>全相关联高速缓存（Fully Associative Caches）</strong>，缓存空间中只有一个组（<code>S = 1</code>，所有数据行在一个组中），这个时候如果能够并行比较，那么缓存效率是极高的。但是通常由于上述原因，我们大多数时候只能在<strong>软件级别的缓存 或者 在主存和硬盘之间的缓存模式（因为硬盘读取时间开销很大，值得我们使用复杂算法来获得更高的缓存效率，我们在“虚拟内存”一章会讨论）</strong>中找到这种组织形式。</p></blockquote><h3 id="11-2-2-E-Way-Set-Associative-Cache-Simulation"><a href="#11-2-2-E-Way-Set-Associative-Cache-Simulation" class="headerlink" title="11.2.2 E-Way Set Associative Cache Simulation"></a>11.2.2 E-Way Set Associative Cache Simulation</h3><p>除了直接映射，还有一个稍微复杂点的例子，<strong>当不改变上面例子中的缓存空间大小，讨论每个缓存组包含 2 个数据行的情况，这也被称为 “2-Way Set Associative Cache（2 路相连高速缓存）Simulation”</strong>。</p><p>这个时候 tag 变为 2-bit，set index 变为 1-bit，block index 还是 1-bit；</p><p>我们有类似上面 Directed-Mapped Cache Simulation 相近的步骤，如下图：</p><p><img src="imgs/2_way_associative_cache_sim.png" height="300px"></p><blockquote><p>注意到一点，当关联性大于 1 的时候，同一个数据组中可能不同的数据行的 tag 可能是相同的，那么当我们想要覆盖数据的时候，就涉及到了<strong>选择覆盖</strong>的问题，它可以通过设计算法来完成。</p><p>根据<strong>局部性原理的逆定理（通常成立）</strong>，如果一个数据长时间不被引用，那么它在未来的某个时间也不太可能被引用。所以，最常见的算法是 <strong>“最近最少使用” 策略（Least Recently Used Strategy）</strong>，这种算法一般不需要额外的 bit 存储数据，只是从硬件层面跟踪在缓存中数据的使用频率（如按序保存虚拟时间戳），确保无效的数据行最先被覆盖，然后是使用频次更低的数据先被覆盖。</p></blockquote><p>助记：</p><ul><li><code>b</code> 位不同，<code>s</code>，<code>t</code> 位相同，也位于同一个组中；</li><li>每 $2^{b+s}$ bytes 就排在同一个组内；</li></ul><h2 id="11-3-Write-Cache"><a href="#11-3-Write-Cache" class="headerlink" title="11.3 Write Cache"></a>11.3 Write Cache</h2><p>事实上，真正要更改某些数据恐怕比读数据更难，因为我们的缓存机制通常会产生多份数据的复制品。例如层级从低到高：硬盘、主存、L1 / L2 / L3 高速缓存，其中可能包含了同一份数据的副本。</p><p>于是在程序要求修改内存（仍然以 高速缓存存储器 和 内存 这对存储同样有 2 种情况 <strong>write-hit</strong> 和 <strong>write-miss</strong>：</p><p>如果遇到 <strong>write-hit</strong>（要写的内存数据就在缓存设备中）的情况，由于数据分布特殊性，那么有两种处理方法：</p><ul><li><p><strong>Write-through</strong>：立即将数据写入缓存（即覆盖当前行）并主动刷新（flush）到内存；</p><ul><li>优势：内存始终是缓存的镜像，二者数据同步；</li><li>劣势：从 CPU 到 内存，时间开销必然很大；</li></ul></li><li><p><strong>Write-back</strong>：先把数据写入缓存，但不立即刷新，直到下一个数据要覆盖这个数据行的时候，才更新到内存中（defer write to memory until replacement of line，<strong>只是尽可能推迟了写入内存的时间</strong>）；</p><ul><li><p>优点：如果数据的 dirty bit 指示没有被污染时，那么覆盖这一行就不用执行 write 操作；</p></li><li><p>特点：<strong>这种方法需要一个标记（dirty bit），用来指示当前数据和内存中是否相同，即是否有被修改过</strong>；</p><p><img src="imgs/dirty_bit.png" height="100px"></p></li><li><p>劣势：必然存在 <strong>write-miss</strong> 现象，因为如果修改的内存数据不在缓存中，那么就需要与内存交互；</p></li></ul></li></ul><p>如果遇到的是 <strong>write-miss</strong>，那么也有 2 种方法（<strong>和 write-hint 是对称的操作</strong>）：</p><ul><li><strong>Write-allocate</strong>：写分配，在 write-miss 后，<strong>先将原数据从内存读入缓存，转换为 write-hit 的情况，再 write-back（仅修改缓存 + dirty bit）</strong>；</li><li><strong>No-write-allocate</strong>：直接写入内存，不加载到缓存（缓存中没有这个数据所在的数据行，因为本来就是 write-miss）；</li></ul><p>一般情况下，由于对称性，人们一般选择 “<strong>write-back + write-allocate</strong>” 或 “write-through + no-write-allocate” 的策略中的其中一对（根据实际情况）；</p><h2 id="11-4-The-Hierarchy-of-Cache-Memories"><a href="#11-4-The-Hierarchy-of-Cache-Memories" class="headerlink" title="11.4 The Hierarchy of Cache Memories"></a>11.4 The Hierarchy of Cache Memories</h2><p>讨论完了缓存读写的具体的逻辑实现，我们再来看看实际上硬件是如何对应这些实现的。同样以 高速缓存存储器 为例。<strong>到目前为止，我们都假设计算机系统中只有一个高速缓存存储器的缓存空间</strong>，但是实际上，早在前面第 8 章中就介绍了，一般计算机中有 L1、L2、L3 3 类 Cache memories。它们在硬件上是如何设置和协调的呢？</p><p>以 Intel Core i7 芯片为例，它的高速缓存层次结构如下：</p><p><img src="imgs/intel_i7_cache_hierarchy.png" height="300px"></p><p>如图，一般情况下，现代 CPU 有 4（桌面系统）/ 8 ~ 12（服务器类系统）个核，<strong>每个核可以各自并行，独立执行各自的指令流</strong>，每个处理器内核可以包含<strong>各自的</strong>通用寄存器（位于存储系统层次结构 L0）.</p><p>在其中，每个核还会有 2 种 L1 Cache。其中一种是 <strong>d-cache（data cache，1 级数据高速缓存器）</strong>，另一种是 <strong>i-cache（instruction cache，1 级指令高速缓存器</strong>）。它们的读取时延（4 个时钟周期）仅次于寄存器，正因速度和成本的关系，它们的大小非常小，只有约 32 KB；它们的关联性一般是 8 路（一个缓存组中有 8 个数据行）；</p><p>在 L1 Cache 的下一层是 L2 Cache（L1 和），只有一种联合的高速缓存器（unified cache，同时包含某个核的数据和指令的缓存），读取速度稍慢（10 个时钟周期）于 L1 Cache，也是 8 路关联性，不过大小稍微大一点，有 256 KB；</p><p>再下层的 L3 Cache 不在 CPU 的核内，是被所有核心所共享的联合高速缓存存储器。8 bytes 大小、16 路关联性，但访问时延长达 40 ~ 75 个时钟周期；</p><p><strong>它们间的关系和之前所说的各个层级的缓存设备一模一样，都是 “逐层向上缓存数据，逐层向下查找数据”</strong>。</p><p>根据这些实际的物理结构，我们考虑一下高速缓存存储器的性能和损耗情况。我们建立如下的衡量指标（Cache Performance Metrics）：</p><ul><li>Miss Rate:  cache memories 不可避免的会发生 cache miss，这就是 cache memories 性能可能产生损耗的原因之一；<ul><li>定义：缓存未命中次数 / 总访问次数（ = <strong>1 - hit rate</strong>）；</li><li>一般情况下，L1 Cache 的 未命中率在 3 ~ 10%，L2 Cache 在 1% 左右，<strong>和缓存大小紧密相关</strong>（<strong>如此低的 Miss Rate 得益于 程序局部性</strong>）；</li></ul></li><li>Hit Time：虽然有时缓存成功命中，但从缓存的数据行中传输到处理器中仍然需要时间。<ul><li>定义：从检查标志位，到 hit 直接返回 block 中的缓存数据所需时间；</li></ul></li><li>Miss Penalty：由于 Miss Rate，从内存传输到缓存和 CPU 中通常会花费更多时间；<ul><li>定义：从检查标志位，到 miss、从内存读取数据，直到数据传回 CPU 所需时间；</li><li>一般情况下从主存中读取数据大约花费 50 ~ 200 个时钟周期（如果在其他的存储系统的层次中，花费可能大得多）；</li></ul></li></ul><p><strong>事实上，这些一次两次看似影响不大的 Cache miss 和 hit，对系统性能影响相当大！数学证明表明，99% 的 hit rate 的系统性能比 97% 的 hit rate 对应的系统性能迅速 2 倍</strong>！</p><blockquote><p>主要是因为 miss penalty 很大，miss rate 的权重远大于 hit rate 的权重。因此我们通常看 miss rate 而不是 hit rate；</p></blockquote><p>那么我们分析之前的 cache 参数对性能的影响：</p><ul><li>cache 总大小影响：增大同时 <strong>提高命中率，但增加 hit time</strong>;</li><li><p>block size ($B$) 大小影响：增大同时 <strong>更能利用程序空间局部性（提升 space locality 好的程序的 hit rate），但数据行数 $E$ 会变少（temporal locality 好的程序的 hit rate 会降低），并且会提高 miss penalty</strong>；</p></li><li><p>associativity ($E$) 大小影响：<strong>降低了 conflict miss 的可能性，但是提升了比较数据行的硬件成本、增加了命中时间、增加了 miss penalty（因为 replacement 的选择也更复杂）</strong>；</p></li></ul><h2 id="11-5-Performance-Impact-of-Cache"><a href="#11-5-Performance-Impact-of-Cache" class="headerlink" title="11.5 Performance Impact of Cache"></a>11.5 Performance Impact of Cache</h2><h3 id="11-5-1-Writing-Cache-Friendly-Code-Ⅰ"><a href="#11-5-1-Writing-Cache-Friendly-Code-Ⅰ" class="headerlink" title="11.5.1 Writing Cache Friendly Code Ⅰ"></a>11.5.1 Writing Cache Friendly Code Ⅰ</h3><p>考虑上一节惊人的缓存性能的情况，我们确实应该写出一些 Cache Friendly 的代码，<strong>这是优化代码性能的一个重要方面</strong>。在分析了缓存的特性和程序局部性之后，我们可以这样来充分利用高速缓存带给程序的性能提升：</p><ul><li><p>关注<strong>经常被调用的</strong>函数中<strong>执行次数最多的内层循环</strong>的性质，积极对它进行算法层面优化；</p></li><li><p>尽量使用重复的变量引用，而不是很多的全局变量（利用了时间局部性，减少 cache miss 的可能）；</p><blockquote><p>它和 第 15. 章的 CSE 优化不冲突，后者是尽量避免 Memory Alias；</p></blockquote></li><li><p>尽量使用 stride-1 reference patterns（或者说<strong>程序循环的步长尽量小</strong>，尤其是逐个访问数组元素，这就将 cache block 的优点发挥了出来，利用了空间局部性，减小 cache miss 的可能）；</p></li></ul><p><strong>总结：我们分析缓存的组织原理和特性，是进一步定量地（如上面的指标）去体现、印证程序局部性的概念</strong>。</p><h3 id="11-5-2-The-Memory-Mountain"><a href="#11-5-2-The-Memory-Mountain" class="headerlink" title="11.5.2 The Memory Mountain"></a>11.5.2 The Memory Mountain</h3><p>之前简单地对缓存组成的分析，让我们看到了关注缓存能够对程序带来较显著地性能影响。那么这节我们更深入地去探究缓存对程序性能的影响。</p><p>首先引入一个概念：</p><ul><li>Read throughput（吞吐量，或者说 read bandwidth，读带宽）：<strong>单位时间内从内存中读取数据的最大字节数</strong>，单位 MB/s；</li></ul><p>于是，我们可以绘制一个 <strong>时间局部性、空间局部性 关于 机器吞吐量的三维坐标图（存储器山）</strong>，以此展示缓存对程序性能的重要影响。</p><p>其中，我们以访问数组的程序为例。我们将遍历数组的步长作为衡量程序空间局部性的指标（步长越大，空间局部性越小），将一次读取数组元素数量作为衡量程序时间局部性的指标（一次取出的数据越多，访问到相同地址数据的机会越小，时间局部性越小）；</p><p>如图：</p><p><img src="imgs/memory_mountain.png" height="350px"></p><p>我们<strong>从读取数据量 size 的方向</strong>看图，会发现 memory mountain 有一个个像山脊一样的结构，这恰好对应了从 L1 到 Memories 的数据引用的平均性能（小的数据量更有可能在每次遍历时放在同一个缓存的 block 中，发生 cache miss 的机会就更小，只需要依靠更接近寄存器层级的缓存设备就能得到答案）；</p><p><img src="imgs/space-loc-stat.png" height="350px"></p><p>而<strong>从数组访问步长 stride 的方向</strong>看图，会发现随着步长的增加，整体有一个负向的斜率。而随着步长大到一定程度，负向的斜率趋于平缓，这是因为<strong>步长大过了缓存 block size，导致几乎每次都会存在 Cache miss，就很难得到缓存的增益了</strong>。</p><p><img src="imgs/temporal-loc-stat.png" height="350px"></p><h3 id="11-5-3-Writing-Cache-Friendly-Code-Ⅱ-Rearranging-loops-to-improve-spacial-locality"><a href="#11-5-3-Writing-Cache-Friendly-Code-Ⅱ-Rearranging-loops-to-improve-spacial-locality" class="headerlink" title="11.5.3 Writing Cache Friendly Code Ⅱ - Rearranging loops to improve spacial locality"></a>11.5.3 Writing Cache Friendly Code Ⅱ - Rearranging loops to improve spacial locality</h3><p>借助上面对于 memory mountain 的进一步分析，我们还可以想到更多的具体<strong>利用缓存来优化程序性能的方法</strong>。</p><p>例如，我们<strong>以矩阵乘法运算为例</strong>，我们假定以下的条件：</p><ul><li>N × N 方阵，元素为 double（8 bytes）类型；</li></ul><p>那么按照正确的一般矩阵相乘的方法，总单位运算次数 $O(N^3)$；</p><p>事实上，计算的一般方法有许多种（但都是 结果矩阵 $C=(c_{ij})_{N\times N}$ 的元素 $c_{ij}=a_{ik}\cdot b_{kj}$），我们<strong>这里着重讨论缓存的效率受代码安排的影响，也即，什么样的矩阵乘法最能充分利用缓存</strong>。</p><p>首先来对不同策略的矩阵乘法分析 Miss Rate：</p><ul><li>前提假设<ul><li>机器缓存空间的 <strong>块大小（<code>B</code>）为 32 Bytes（能够一次性放下 4 个 double 数据）</strong>；</li><li>矩阵维度 <code>N</code> 非常大（$\dfrac{1}{N}\approx0$）;</li><li>缓存空间的总大小不足以装下矩阵的多个行；</li></ul></li><li>分析方法：<strong>检查内层循环的函数访问模式</strong>（因为外层循环次数不可避免）；</li></ul><p>由于运算的方式固定，我们可以通过更换内外层循环顺序（共 $3!=6$ 种）来看究竟哪种方法最好。</p><p>在分析前，先再次回顾一下 C 中数组的 memory layout：</p><ul><li>二维数组的<strong>至少每一行的数据空间是 contiguous 的</strong>，并且<strong>行优先（row major）</strong>；</li><li>stride-1 逐个访问数组行的方法最能利用 spacial locality，它的 $miss\space rate=\dfrac{sizeof(a_{ij})}{B}$，其中 $B$ 是缓存空间的块大小；</li><li>stride-1 逐个访问较大数组列的方法完全无法利用 spacial locality，因为 每一列同一行的元素一定不在同一个缓存数据块中（之前已经假设 “缓存空间的总大小不足以装下矩阵的多个行”），因此 miss rate = 1（100% cache miss）；</li></ul><p><strong>情况 1：先固定 i（A 的行），再固定 j（B 的列），最后遍历 k（A 第 i 行每一列、B 第 j 列每一行）</strong></p><p><img src="imgs/cache_analysis_matrix_multiply_ijk.png" height="200px"></p><p>这种情况下，<strong>对每一个最内层循环</strong>：</p><ul><li>每次要求从内存中取出 A 矩阵的同行相邻元素，<strong>miss rate = 8 / 32 = 0.25</strong>；</li><li>每次要求从内存中取出 B 矩阵的同列相邻元素，<strong>miss rate = 1</strong>；</li><li>每次要求从内存中取出 C 矩阵的一个元素，所以对单个元素而言 <strong>miss rate 近似为 0</strong>；</li></ul><p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 0 次，cache miss 次数 1.25 次</strong>；</p><p>这种情况与 <strong><code>jik</code></strong> 顺序的情况相同；</p><p> <strong>情况 2：先固定 k（B 的行），再固定 i（A 固定位置 第 i 行 第 k 列），最后遍历 j（C 的第 i 行每一列）</strong></p><p><img src="imgs/cache_analysis_matrix_multiply_kij.png" height="175px"></p><p>这种情况下，<strong>对每一个最内层循环</strong>：</p><table>    <tr>        <th>Op Matrix</th>        <td>A</td>        <td>B</td>        <td>C</td>    </tr>    <tr>        <th>Miss Rate</th>        <td>0.0</td>        <td>0.25</td>        <td>0.25</td>    </tr></table><p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 1 次，cache miss 次数 0.5 次</strong>；</p><p>这种情况与 <strong><code>ikj</code></strong> 顺序的情况相同；</p><p><strong>情况 3：先固定 j（C 的第 j 列每一行），再固定 k（A 的第 k 列），最后遍历 i（固定 B 遍历 C 的 列）</strong></p><p><img src="imgs/cache_analysis_matrix_multiply_jki.png" height="175px"></p><p>这种情况下，<strong>对每一个最内层循环</strong>：</p><table>    <tr>        <th>Op Matrix</th>        <td>A</td>        <td>B</td>        <td>C</td>    </tr>    <tr>        <th>Miss Rate</th>        <td>1.0</td>        <td>0.0</td>        <td>1.0</td>    </tr></table><p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 1 次，cache miss 次数 2.0 次</strong>；</p><p>这种情况与 <strong><code>kji</code></strong> 顺序的情况相同；</p><hr><p>综合上面的三种情况，我们进行实际的测试，发现结果如我们所料：</p><p><img src="imgs/core_i7_matrix_multiply_perf.png" height="300px"></p><p>事实证明，<strong><code>kij/ikj</code> 遍历方法（固定 A / B 的位置，遍历剩下一个运算矩阵的行，来得到结果矩阵的行）是最能利用 cache memories 的优势的方法</strong>，而我们最常用的 <code>ijk</code> 方法却不是最好的方法。</p><h3 id="11-5-4-Writing-Cache-Friendly-Code-Ⅲ-Using-blocking-to-improve-temporal-locality"><a href="#11-5-4-Writing-Cache-Friendly-Code-Ⅲ-Using-blocking-to-improve-temporal-locality" class="headerlink" title="11.5.4 Writing Cache Friendly Code Ⅲ - Using blocking to improve temporal locality"></a>11.5.4 Writing Cache Friendly Code Ⅲ - Using blocking to improve temporal locality</h3><p>上一节的例子主要以矩阵乘法为例，从提升<strong>空间局部性</strong>的层面来充分利用缓存、提示程序缓存效率。本节将从另一个角度——提升程序<strong>时间局部性</strong>来讨论如何写出缓存友好的代码。</p><p>再举一个针对矩阵乘法的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="type">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmm</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                c[i*n + j] += a[i*n + k] * b[k*n + j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的乘法而言，我们作如下假设：</p><ul><li>机器缓存空间的 <strong>块大小（<code>B</code>）为 64 Bytes（能够一次性放下 8 个 double 数据）</strong>；</li><li>矩阵维度 <code>N</code> 非常大（$\dfrac{1}{N}\approx0$）;</li><li>缓存空间的总大小不足以装下矩阵的多个行；</li></ul><p>在这种情况下，最内层的循环中，每一个循环的 cache miss 平均次数为：$\dfrac{n}{8}+n=\dfrac{9}{8}n$，于是总的 cache miss 的数量在 $\dfrac{9n^3}{8}$ 左右，显然，这样的 cache miss 数量会显著影响程序性能和对缓存的利用。于是，一种利用时间局部性的方法就出现了：</p><p><strong>我们在每次内存循环取矩阵乘法的 $C$ 的单元的时候，将单独取一个改为选取一个 block（小型块），如图所示，block 的宽度为 $B$：</strong></p><p><img src="imgs/multi_simple.png" height="150px"></p><p>改为：</p><p><img src="imgs/multi_block.png" height="150px"></p><p>即计算代码改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="type">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmm</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i+=B)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j+=B)</span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k+=B)</span><br><span class="line">                    <span class="comment">/* B x B mini matrix multiplications */</span></span><br><span class="line">                    <span class="keyword">for</span> (i1 = i; i1 &lt; i+B; i1++)</span><br><span class="line">                        <span class="keyword">for</span> (j1 = j; j1 &lt; j+B; j1++)</span><br><span class="line">                            <span class="keyword">for</span> (k1 = k; k1 &lt; k+B; k1++)</span><br><span class="line">                                c[i1*n+j1] += a[i1*n + k1]*b[k1*n + j1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们再次分析 cache miss 的情况。</p><p>假设选取的 $B$ 的大小能够被缓存利用：$3B^2\lt C$，那么：</p><ul><li><p>每一个 sub-block（子块）内部的 cache miss 数量：$\dfrac{B^2}{8}$；</p></li><li><p>每一次行循环的 cache miss 数：$\dfrac{2n}{B}\cdot\dfrac{B^2}{8}=\dfrac{nB}{4}\sim O(nB)$；</p></li><li>总的 cache miss 数：$\dfrac{nB}{4}\cdot(\dfrac{n}{B})^2=\dfrac{n^3}{4B}$；</li></ul><p>总而言之，这样的改进并没有根本上提升算法的时间复杂度，但是它却能确确实实地减少常数级别的 cache miss 数量（$\dfrac{9}{8}n^3\rightarrow\dfrac{1}{4B}n^3$），在一定程度上达到提升时间局部性的效果。这样，只要我们选择满足 $3B^3\lt C$ 的最大的 $B$ 的取值，就能找到这种思路的最优计算方法。</p><p>为什么能够引起如此大的常数优化呢？主要是以下原因：</p><ul><li>我们在选取 block 的时候，相当于加载了一个地址上更相邻的、之后能被反复使用的变量，因为我们缩小了矩阵乘法的 $N$，逐个 block 攻破，这样的矩阵乘法更能利用时间局部性；<ul><li>输入数据 $3n^2$，计算 $2n^3$，而每个元素需要被使用 $O(n)$ 次；</li></ul></li></ul><h3 id="11-5-5-Cache-Performance-Summary"><a href="#11-5-5-Cache-Performance-Summary" class="headerlink" title="11.5.5 Cache Performance Summary"></a>11.5.5 Cache Performance Summary</h3><p>在 11.5 节中，我们通过几个例子了解到，<strong>虽然我们无法显式控制 cache 的存储方式，但是通过对于程序局部性的分析，我们可以更高效地利用 cache，从而提升程序允许效率。</strong>这主要可以从两个方面下手：</p><ul><li>使用 stride-1 reference pattern、关注内层循环的步长和方式，以提升程序的空间局部性；</li><li>多次使用相同的局部变量、分块访问，以提升程序的时间局部性；</li></ul><h1 id="Chapter-12-Program-Optimization"><a href="#Chapter-12-Program-Optimization" class="headerlink" title="Chapter 12. Program Optimization"></a>Chapter 12. Program Optimization</h1><blockquote><p>One of the themes for this chapter: </p><ul><li>去除程序不必要的工作、编写编译器友好代码、提升运行速度；</li><li>利用机器代码特性，针对特定机器对程序优化；</li></ul></blockquote><p>编译器无法理解一些内容，例如 int 数据类型可能只用到相当小的范围、procedure call 究竟是什么意思，等待。编译器只是针对一些特定情况，对照 “cookbook” 进行有选择地优化。其遇到复杂或者特殊情况的 “保底” 方案是不对代码进行优化。</p><p>初始思路：查看程序汇编代码哪些地方没被优化，找到对应的源码部分进行重写，直至重构成编译器友好代码（只要不过度牺牲程序可读性就行）。</p><h2 id="12-1-Goals-of-Optimization"><a href="#12-1-Goals-of-Optimization" class="headerlink" title="12.1 Goals of Optimization"></a>12.1 Goals of Optimization</h2><ul><li>Minimize number of instructions<ul><li>避免重复计算；</li><li>避免不必要的计算；</li><li>避免较大计算量的操作（例如乘、除）；</li></ul></li><li>Avoid waiting for memory<ul><li>尽量将数据和运算过程放在 register 中，而非内存中；</li><li>使用 cache-friendly 的方式访问内存；</li><li>尽早从内存加载数据，并且加载次数越少越好；</li></ul></li><li>Avoid branching<ul><li>不要写出不必要的判断结构；</li><li>写成让 CPU 容易预测分支的代码（流水线）；</li><li>尽量解开循环，分摊分支的开销；</li></ul></li><li>Make good use of locality &amp; cache: 写出程序局部性良好的代码、充分利用缓存机制（10.2 &amp; 11.X）；</li></ul><h2 id="12-2-Limits-to-Compiler-Optimization"><a href="#12-2-Limits-to-Compiler-Optimization" class="headerlink" title="12.2 Limits to Compiler Optimization"></a>12.2 Limits to Compiler Optimization</h2><ul><li><p>无法优化算法的渐进时间复杂度；</p></li><li><p>绝不会改变程序语义、行为；</p></li><li><p>编译时仅仅分析每个函数一次（inline 函数除外）；</p><blockquote><p>目前 Whole-program analysis (“LTO”) 比较受欢迎，尽管开销很大；</p></blockquote></li><li><p>无法很好地针对运行时的输入内容进行优化</p><ul><li>可能出现最坏情况，尤其是面对非法输入的时候；</li></ul></li></ul><h2 id="12-3-Generally-Useful-Optimizations"><a href="#12-3-Generally-Useful-Optimizations" class="headerlink" title="12.3 Generally Useful Optimizations"></a>12.3 Generally Useful Optimizations</h2><blockquote><p>本部分的优化技巧不针对特定的编译器或者处理器，具有普适性。</p><p>绝大多数编译器在一定的优化等级下，都能优化本节的情况，但是我们应该学习这些方法。</p><p>注：一个能看到优化过程的网站：<a href="https://godbolt.org/z/Es5s8qsvj">COMPILER EXPLORER</a></p></blockquote><p>根据 12.1 中的目标，我们可以整理出一些常见的情况，这些情况下编译器能够优化，或者说具有普适性的优化策略，主要有以下两类：</p><ul><li>Local Optimizations (<strong>work inside a single basic block</strong>)<ul><li>Constant folding（常数折叠）</li><li>Strength reduction（计算强度削减）</li><li>Dead code elimination（死代码剔除）</li><li>Local CSE（Local Common Subexpression Elimination，局部的相似子表达式复用）</li><li>……</li></ul></li><li>Global Optimizations (<strong>process the entire control flow graph of a function</strong>)<ul><li>Loop transformations（循环结构转换）</li><li>Code motion（代码移动）</li><li>Inlining（内联化）</li><li>Global CSE（全局的相似子表达式复用）</li></ul></li></ul><p>这章仅仅叙述它们的思路，不涉及具体实现，因为具体实现就涉及到编译原理（AST 语法树等知识）；</p><h3 id="12-3-1-Constant-Folding"><a href="#12-3-1-Constant-Folding" class="headerlink" title="12.3.1 Constant Folding"></a>12.3.1 Constant Folding</h3><p>常数折叠的方法主要有以下几个方面：</p><ul><li><p>直接运算代码中的常数表达式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> mask = <span class="number">0xFF</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 优化为：</span></span><br><span class="line"><span class="type">long</span> mask = <span class="number">0xFF00</span>;</span><br></pre></td></tr></table></figure></li><li><p>直接运算一切可以常量化的表达式，例如针对常量调用的库函数、常量输入等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> namelen = <span class="built_in">strlen</span>(<span class="string">&quot;Harry Bovik&quot;</span>);</span><br><span class="line"><span class="comment">// 优化为：</span></span><br><span class="line"><span class="type">size_t</span> namelen = <span class="number">11</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-3-2-Dead-Code-Elimination"><a href="#12-3-2-Dead-Code-Elimination" class="headerlink" title="12.3.2 Dead Code Elimination"></a>12.3.2 Dead Code Elimination</h3><p>死代码删除方法的思路主要来源于 12.1 中的 “Avoid Branching” 和 “Minimize number of instructions”，分为以下几种情况：</p><ul><li><p>删除语义上不可能执行到的代码（无效代码）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Hello, 0&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Hello, 1&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Hello, 1&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除结果被覆盖的代码（也是无效代码）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">23</span>; x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">x = <span class="number">42</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这类优化方式看起来很蠢，但也很重要，因为有时候这些死代码不容易被肉眼识别，或者在编译器进行其他优化过程中，在语义树上出现了，那么就需要这种方法来清理。</p><h3 id="12-3-3-Common-Subexpression-Elimination"><a href="#12-3-3-Common-Subexpression-Elimination" class="headerlink" title="12.3.3 Common Subexpression Elimination"></a>12.3.3 Common Subexpression Elimination</h3><p>CSE 的思路就是根据 AST 树的特征，约去<strong>重复计算</strong>，从而降低运算量，例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处展示的是 Local CSE */</span></span><br><span class="line"></span><br><span class="line">up = val[(i<span class="number">-1</span>)*n + j];</span><br><span class="line">down = val[(i+<span class="number">1</span>)*n + j];</span><br><span class="line">left = val[i*n + j - <span class="number">1</span>];</span><br><span class="line">right = val[i*n + j + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以改为：</span></span><br><span class="line"><span class="type">long</span> inj = i*n + j;</span><br><span class="line">up = val[inj - n];</span><br><span class="line">down = val[inj + n];</span><br><span class="line">left = val[inj - <span class="number">1</span>];</span><br><span class="line">right = val[inj + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">norm[i] = v[i].x * v[i].x + v[i].y * v[i].y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">elt = &amp;v[i];</span><br><span class="line">x = elt-&gt;x;</span><br><span class="line">y = elt-&gt;y;</span><br><span class="line">norm[i] = x * x + y * y;</span><br></pre></td></tr></table></figure><h3 id="12-3-4-Code-Motion"><a href="#12-3-4-Code-Motion" class="headerlink" title="12.3.4 Code Motion"></a>12.3.4 Code Motion</h3><p>I.e., reduce frequency with which computation performed（也是降低代码重复运算频率，不过是在 global 范围进行）</p><ul><li><p>If it will always produce same result（这种改动<strong>语义不变</strong>）；</p></li><li><p>Especially moving code out of loop（常见于将代码移出循环结构，但为了保持语义，要求移动的代码在每次循环中的结果不变）；</p></li><li><p>Example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_row</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> i, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        a[n*i + j] = b[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为（将 n*i 这个与循环无关的变量提出循环，避免重复运算）：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_row</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> i, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">int</span> ni = n * i;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        a[ni + j] = b[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-3-5-Inlining"><a href="#12-3-5-Inlining" class="headerlink" title="12.3.5 Inlining"></a>12.3.5 Inlining</h3><p>I.e., copy body of a function into its caller(s);</p><p>对于一些短的、计算开销小的非递归函数，即便编程人员不指定 <code>inline</code> 关键字，编译器也应该识别到并且内联操作。这样做的好处有两点：</p><ul><li>消除函数调用的栈帧分配开销；</li><li>为其他许多优化方法<strong>创造条件</strong>。例如，对代码中的一些函数内联，可以被编译器找到例如 dead code elimination、constant fold 的机会；</li></ul><p>这是个例子：</p><p><img src="imgs/inlining_example1.png"></p><p>缺点：</p><ul><li>这种优化方法在某些情况下（内联函数很长、开销很大）会导致整体代码空间占用变大、速度降低；</li><li>对调试工具、profiling 工具不友好；</li></ul><h3 id="12-3-6-Strength-Reduction"><a href="#12-3-6-Strength-Reduction" class="headerlink" title="12.3.6 Strength Reduction"></a>12.3.6 Strength Reduction</h3><p>I.e., replace costly operation with simpler one.（计算量减小）</p><ul><li>可以用移位、加法尽量代替乘法、除法（优化的比例取决于不同的机器）；</li></ul><h2 id="12-4-Obstacles-for-Compiler-to-Optimization"><a href="#12-4-Obstacles-for-Compiler-to-Optimization" class="headerlink" title="12.4 Obstacles for Compiler to Optimization"></a>12.4 Obstacles for Compiler to Optimization</h2><p>现在反过来看，有哪些操作会阻碍编译器优化？</p><p>阻碍编译器优化的原因之一就是期间调用了其他函数，这样 gcc 可能就无法识别到优化方法。还有一个主要原因就是 “内存别名” 的存在。</p><h3 id="12-4-1-Optimization-Blocker-1-Procedure-Calls"><a href="#12-4-1-Optimization-Blocker-1-Procedure-Calls" class="headerlink" title="12.4.1 Optimization Blocker #1: Procedure Calls"></a>12.4.1 Optimization Blocker #1: Procedure Calls</h3><p>典型例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，循环判断条件中有一个函数 <code>strlen(s)</code>，我们都知道这是计算字符串长度的函数。但是<strong>编译器不知道</strong>，它认为<strong>这个函数有可能在每次循环中，返回值可能改变</strong>，所以不会把它优化为一个常数，而是保持<strong>每次循环判断时，都重新调用 <code>strlen(s)</code></strong>。</p><p>可是，<code>strlen(s)</code> 的复杂度是  $O(n)$ 啊！这样好端端的 $O(n)$ 能实现的函数被硬生生干成了 $O(n^2)$ ……</p><p>所以，正确的做法是，先把 <code>strlen(s)</code> 算出来。更好的主意是，<strong>干脆不使用 <code>strlen()</code>，因为判断字符串结束原本就是能在循环中发现的情况</strong>，并且把数组索引改成指针取值，这样还能再节省常数时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *s &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            *s -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回过头来，为什么绝大多数的编译器没法优化这种 procedure calls 的情况？主要有几点原因：</p><ul><li>Procedure may have side effects; 就像前面说的，编译器不知道运行这个 procedure 会不会改变当前环境中其他变量的值，所以不敢贸然改变 procedure 运行顺序；</li><li>Procedure 会出现重载、重写的情况，这些函数有不同版本，可能分布在不 同文件中，只有编译结束，链接的时候才知道最终用的函数是谁。对于虚函数而言，甚至要在运行时才知道调用的是哪一个同名函数；所以更不敢随意判断某个 procedure 的作用，也就无法解决上面的问题；</li><li>如果全面分析所有同名 procedure，并且找到它们的含义、作用，那么编译开销过大，非常不现实；</li></ul><p>综上，编译器一般的做法是<strong>将 procedure 看作一个黑盒，行为不确定，所以一般不会优化它的执行顺序</strong>。因此，开发者应该清楚意识到函数的作用，并且重视它执行的位置对代码性能的影响。</p><h3 id="12-4-2-Optimization-Blocker-2-Memory-Aliasing"><a href="#12-4-2-Optimization-Blocker-2-Memory-Aliasing" class="headerlink" title="12.4.2 Optimization Blocker #2: Memory Aliasing"></a>12.4.2 Optimization Blocker #2: Memory Aliasing</h3><p>先看示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sum rows is of n x n matrix a and store in vector b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum_rows1</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        b[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">               b[i] += a[i*n + j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看起来性能上没什么问题，大多数人都会如此实现代码。但是我们看看对应的 x86-64 汇编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># sum_rows1 inner loop</span><br><span class="line">.L4:</span><br><span class="line">    movsd(%rsi,%rax,8), %xmm0# FP load</span><br><span class="line">    addsd(%rdi), %xmm0# FP add</span><br><span class="line">    movsd%xmm0, (%rsi, %rax, 8)# FP store</span><br><span class="line">    addq$8, %rdi</span><br><span class="line">    cmpq%rcx, %rdi</span><br><span class="line">    jne.L4</span><br></pre></td></tr></table></figure><p>我们发现，小小的 <code>b[i] += a[i*n + j]</code> 竟然有两次对内存的操作（从内存读到寄存器，计算后再写回内存），为什么会这样？为什么不直接在内存中计算？</p><p>这是因为 <strong>Memory Alias（内存别名）在 C 中是允许的</strong>。比如，如果我这么调用 <code>sum_rows1</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> A[<span class="number">9</span>] =</span><br><span class="line">    &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">          <span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,</span><br><span class="line">         <span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* B = A+<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">sum_rows1(A, B, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>那么，第二参数 <code>B</code> 就是 <code>A</code> 的一部分的<strong>内存别名</strong>，也就是说，程序有两个指针指向一块内存地址，这样的话，在每次 <code>B[i] = 0</code> 后，就会改变 <code>A</code> 的内容，从而改变求和的值。因此编译器仍然不敢直接优化。</p><p>问题在于，我们知道这个函数的作用是数组列求和，我们不会传入两个内存别名。但是编译器不知道——因为要检查所有的 memory alias 开销也非常大，所以编译器默认程序中都存在内存别名。</p><p><strong>所以解决方法是</strong>，我们暗示编译器这里不会有内存别名导致循环中数组值的更改：<strong>在求和时不直接加到 <code>b</code> 中，而是以临时局部变量存储，求和循环结束后同一赋值给 <code>b</code></strong>，这样在一次求和循环中编译器就不会重复从内存读取信息了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sum rows is of n x n matrix a and store in vector b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum_rows1</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">double</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">               val += a[i*n + j];</span><br><span class="line">        b[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样内层求和循环的汇编码就变得简单了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># sum_rows1 inner loop</span><br><span class="line">.L10:</span><br><span class="line">    addsd(%rdi), %xmm0# FP load + add</span><br><span class="line">    addq$8, %rdi</span><br><span class="line">    cmpq%rax, %rdi</span><br><span class="line">    jne.L10</span><br></pre></td></tr></table></figure><blockquote><p>实际上，内存读写仍然是耗时大头，所以改写后性能提升不会非常明显。</p></blockquote><p>对开发者而言，应该习惯于在循环前引入一些局部变量（<strong>Accumulate in temporary</strong>），尤其是含有数组索引的循环，这样能够暗示编译器按照没有内存别名的情况处理。</p><p>总结一下就是：</p><ul><li>多使用临时局部变量来存放中间值，尤其是在循环中；</li><li>使用更严格的关键字，例如 <code>int[]</code> 好过 <code>int*</code> 来让编译器知道不会有 memory alias；</li></ul><p>上面的几种优化技巧都是比较简单和零碎的，不宜死记硬背，应该贯通在实践当中。下面从另一个角度考虑优化问题。</p><h2 id="12-5-Machine-Dependent-Optimization"><a href="#12-5-Machine-Dependent-Optimization" class="headerlink" title="12.5 Machine-Dependent Optimization"></a>12.5 Machine-Dependent Optimization</h2><blockquote><p>这类优化取决于处理器机器和系统，根据汇编处理方式进行优化。</p></blockquote><p>表面上与机器无关的优化方法都考虑得差不多了，但在机器层面还有一些优化的方法。为了考虑这些方法，我们需要先了解机器的简单组成和基本运作原理。下面是上个世纪末的处理器的大概的设计样式：</p><p><img src="imgs/modern_CPU_design.png" height="400px"></p><p>底层机制过于复杂，一般人短时间内几乎不可能理解，所以这里仅仅浅浅介绍一下。</p><p>CPU 执行代码时，借助了多种方法和技术，构建了健全的硬件设施，使得其执行指令的速度远远快于一条一条读取执行的速度。其中一种技术被称为 “超标量乱序执行” 技术（super-scalar out of order execution），它的思路可以理解为：CPU 一次性读入大量机器指令，再将顺序的指令拆开，发现逻辑上某两句间不相互依赖，于是 CPU 可以不按顺序、尽可能多地同时执行这些代码。</p><blockquote><p>Superscalar（超标量）</p><ul><li>每个时钟周期执行多个操作；</li><li>指令级并行（CPU 自主发现指令间依赖关系，并行执行没有依赖关系的指令）；</li></ul><p>Out-of-order execution（乱序执行）</p><ul><li><strong>Instruction Control Unit (ICU)</strong>: Fetch / Decode / Write Back; <strong>Execution Unit (EU)</strong>: Execute / Memory;</li><li>Fetch Control: Branch Prediction（比 Y86-64 的更高级） + Speculative Execution;</li><li>Instruction Decode</li></ul></blockquote><p>指令的这种特性被称为 <strong>指令级并行性（instruction level parallelism）</strong>；</p><p>上图的 Instruction Control 展示了 CPU 如何从高速缓存中抓取指令，并放入运算单元的。<strong>注意，这里所有的操作都使用缓存和寄存器</strong>，因为其他储存介质（包括内存）都太慢了。</p><p>上面<strong>在一个时钟周期中处理、执行多条指令的处理器</strong>被称为 Super-scalar Processor，它们通常一次性获取一串指令流，并动态地进行调度和执行。它的好处是 <strong>充分利用了代码中的指令级并行性</strong>，所以大多数现代 CPU 都是超标量的，并且现代 CPU 的执行模型也几乎都是乱序执行的模型。</p><p>现代 CPU 的策略是乱序执行，固然非常复杂，比之前讨论过的按序执行的<strong>流水线（pipelining）</strong> 更复杂。</p><p>流水线的基本思想是，<strong>处理器将每个计算分解为一系列不同阶段，每个阶段都有一个专用硬件可以独立完成。于是，当一个计算阶段的硬件空闲下来时，就可以接受下一个数据的计算工作</strong>。</p><p>其中，除法运算无法被分解在流水线上进行，一次操作 3 ~ 30 个时钟周期，所以是一个昂贵的操作。</p><blockquote><p>这些并行性都是单个 CPU 的单核的并行性，不涉及多核并行。</p></blockquote><p>总的来说，在机器层面上，程序的优化上限有两点：</p><ol><li><p>Latency Bound: 当 一系列指令被执行时必须按照严格的顺序进行 时，也就是说后一条指令依赖前一条的结果，此时程序的性能会受到限制。<strong>这种瓶颈（data dependency）限制了指令级别的并行性</strong>（没有 Y86-64 的 data forwarding）；</p><blockquote><p>其计算方法就是，<strong>一条指令 / 操作 最原本的 latency 时延，与承载量无关</strong>；</p></blockquote></li><li><p>Throughout Bound：处理器的运算单元所能达到的最大承载量（computing capacity，通常与对应运算单元数目、运算单元种类有关），这也是程序性能的最终上界。</p></li></ol><hr><p>接下来，借助流水线的知识，我们再分析一下现代处理器内部各个模块是如何进行协作的，以便我们针对特定机器进行优化。</p><p>对于现代处理器，主要就分为以上的两个部分：Instruction Control Unit &amp; Execution Unit。其中  Instruction Control Unit 的主要结构如下：</p><p><img src="imgs/ICU.png" height="200px"></p><ul><li><p>对于 Fetch Control Logic，采用的技术就类似在流水线中介绍的 Branch Prediction + Speculative Execution；</p><blockquote><p>前者（branch mis-prediction）表示一种预测下一条指令位置的技术（是否选择分支的策略、预测目标分支的策略）；后者（speculative execution）表示在分支预测后，还没有确定是否正确就立即取出预测位置的指令进行执行。如果后面检查出现错误，则恢复到原先的状态；</p></blockquote></li><li><p>对于 Instruction Decoding Logic，它的工作就有些不一样。为了充分利用指令集并行资源，该逻辑块：</p><ul><li><p>将传入的指令数据继续分解为 primitive instructions，每个 primitive instruction 都存在更简单的算术、加载、存储的任务，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addq %rax, 8(%rdx)</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">load 8(%rdx) -&gt; t1</span><br><span class="line">addq %rax, t1 -&gt; t2</span><br><span class="line">store t2, 8(%rdx)</span><br></pre></td></tr></table></figure><p>下一步，为了方便交给下面的 Execution Unit 进行并行运算，中间存在一个 <strong>寄存器重命名</strong> 的步骤（后面再描述具体原因），根据原本一条指令所对应的 primitive instructions 用到的临时寄存器，<strong>按使用依赖关系对版本进行编号</strong>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">    .L25:         # Loop:</span><br><span class="line">    vmulsd (%rdx),%xmm0,%xmm0     # t *= data[i]</span><br><span class="line">    addq $8, %rdx         # Increment data+i</span><br><span class="line">    cmpq %rax,%rdx         # Comp to data+len</span><br><span class="line">    jne .L25         # if !=, goto Loop</span><br><span class="line">            |</span><br><span class="line">            v</span><br><span class="line">    load (%rdx.0)       -&gt; t.1</span><br><span class="line">    mulq t.1, %xmm0.0   -&gt; %xmm0.1</span><br><span class="line">    addq $8, %rdx.0     -&gt; %rdx.1</span><br><span class="line">    cmpq %rax, %rdx.1   -&gt; cc.1</span><br><span class="line">    jne-taken cc.1</span><br><span class="line"></span><br><span class="line">而 Execution Unit 部分的主要结构如下图所示：</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;imgs/EU.png&quot; height=&quot;200px&quot;&gt;</span><br><span class="line"></span><br><span class="line">我们发现这里存在很多单独的运算单元，可以从 ICU 部分接收更多指令（$\mu$ code，即上面的 primitive instructions），并行进行不同种类 $\mu$ code 的运算。</span><br><span class="line"></span><br><span class="line">Data Cache 是存放最近访问的 / 临时的数据的地方。遵循 Memory Hierarchy，支持 EU 运算单元的快速存取，稍晚些时候会根据情况向 ICU 的 register files  以及 memory 写入数据。</span><br><span class="line"></span><br><span class="line">此外，Branch 模块不是用来运算某个分支是否应该跳转，而是用来计算分支预测是否正确。若预测错误，则 Branch 会通知丢弃该分支中执行得到的所有数据（利用 ICU 中的 Retirement Unit 不允许错误数据写入，并通知 Data Cache 标记无效数据），否则保留数据并写入；</span><br><span class="line"></span><br><span class="line">同时，ICU 中的 Retirement Unit 跟踪当前过程所有正在执行的指令，确保数据存取符合 sequential 语义。大致逻辑如下：</span><br><span class="line"></span><br><span class="line">当一个指令被 decode，它的信息会被放入一个 FIFO 队列中，直到两种情况之一才会从队头出队：</span><br><span class="line"></span><br><span class="line">1. Retirement Unit 发现该指令的所有 primitive instructions 被执行完，并且所有涉及通向该指令的 branch prediction 都是正确的，这条指令才会被 “retired”，结果写入程序寄存器中；</span><br><span class="line">2. 如果 Retirement Unit 发现该指令途中某个 prediction 是错误的，那么这个指令会被 “flushed”，计算结果会被抛弃，不会写入寄存器中。</span><br><span class="line"></span><br><span class="line">&gt; 注：上图所描述的 “Arithmetic Operation” 单元是被特化来执行整型、浮点型的不同组合的运算的（就是说，这些单元能执行多种不同操作，例如既能整型运算又能浮点型运算）。这样不致于程序对硬件资源的利用率不好。</span><br><span class="line"></span><br><span class="line">那么，“乱序执行” 技术如何实现？很简单，在 ICU 的 Instruction Decode Logic 给出 $\mu$ code 后，由于 $\mu$ code 的临时寄存器只需要记住版本，可以随意选取，因此设计了一个类似任务队列的指派单元，将上面发出的 $\mu$ code 根据**当前 EU 硬件空余情况**分发下去执行。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;imgs/ICU-dispatch.png&quot; height=&quot;200px&quot;&gt;</span><br><span class="line"></span><br><span class="line">**为了加速一条指令到另一条指令的结果传送，处理器引入了一个机制，就是提到的 “寄存器重命名”。这些信息被共享在 renaming table 中（如上图下方的一条长横线）。当运算单元接到 $\mu$ code 后，会立即进行运算（非依赖地并行），将寄存器名、版本号组成的 二元组 $(u,t)$ 写入这个列表中**。</span><br><span class="line"></span><br><span class="line">&gt; 注：这个表维护每个寄存器 $u$ 与更新的重命名版本标记 $t$ 之间的关系。</span><br><span class="line">&gt;</span><br><span class="line">&gt; &lt;u&gt;这个表只包含未 “退役” 的寄存器条目。如果指令在表中没找到某个寄存器，那么说明值在寄存器文件中&lt;/u&gt;，需要的指令这时才会向寄存器文件请求查找。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 每当 Branch 确定了分支结果后，才会通知 retirement unit 将正确的分支上运行的结果写入寄存器。这个时候也会重整 renaming table；</span><br><span class="line"></span><br><span class="line">等待某个版本 $t$ 的指令可以在表中得到数据，这种方式就是一种形式的 “数据转发”（比 Y86-64 的 data forwarding 更快）。&lt;u&gt;通过这种机制，能让依赖前一操作的操作尽快开始，而不需要存入寄存器文件再读出来。&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">&gt; 这个 renaming table 就避开了 Y86-64 中的 control hazard，即便 branch prediction 还没有验证、不能更改程序寄存器，也依然能临时存放一些计算好的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最后，为了定性分析其中的运算效率，我们定义：</span><br><span class="line"></span><br><span class="line">- Issue Time（发送时延）：一个 $\mu$ code 从 ICU 发向 EU 的一个运算单元后，下一条 $\mu$ code 被发送到同一运算单元的时间间隔（硬件限制）；</span><br><span class="line"></span><br><span class="line">- Latency（延迟）：在一个 $\mu$ code 被发送到指定运算单元后，该运算单元需要多长时间来运算；</span><br><span class="line"></span><br><span class="line">  &gt; latency 的计算与 capacity 无关，只与这个指令运算本身的时间有关。</span><br><span class="line"></span><br><span class="line">- Capacity（硬件承载量）：一个处理器对于某种运算，运算单元的数量。</span><br><span class="line"></span><br><span class="line">- Max Throughput（最大吞吐量）：$T=\dfrac&#123;Capacity&#125;&#123;Issue\space Time&#125;$；</span><br><span class="line"></span><br><span class="line">- Throughput Bound（吞吐量界限）：最大吞吐量的倒数，描述了 **执行一条指令在吞吐量的限制下，需要的时间界限**；</span><br><span class="line"></span><br><span class="line">- Latency Bound（延迟界限）：等于延迟本身。描述了 **顺序执行一条指令（就是延迟的限制下）的时间界限**。</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;imgs/intel-instr-metrics.png&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  &gt; 如上图，我们从 `Intel Core i7 Haswell` 处理器的指标可以发现，Add / Multi 在 Latency &gt;= 1 的情况下，仍然有 Issue Time = 1，说明内置了流水线技术。并且，可以通过 Latency 反推流水线有多少个 stages。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 我们还发现，divider 没有内置流水线，因为 Issue Time = Latency Time，**这说明了一个除法运算不能被分割成多个 stages，必须等待前一个计算完成才能继续计算下一个**；</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 同时，不同种类的除法运算（如数据类型）耗时不同，相同点是耗时很长。</span><br><span class="line">  </span><br><span class="line">  &lt;img src=&quot;imgs/ops-CPE.png&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  这个图的数据就是由上一个图的信息得到的。所有运算的 latency 对应上面硬件限制的 latency time；Throughput 则是由 Capacity / Issue Time 得到的。</span><br><span class="line">  </span><br><span class="line">  **但是，虽然整型加法有 4 个运算单元，但是 Throughput 只有 0.5，主要是因为处理器最多只有 2 个 load 单元**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 12.5.0 Data-Flow Representation: Machine-level Profiling</span><br><span class="line"></span><br><span class="line">在利用我们已有对于 Modern Processor 的认识来 tuning 程序前，我们还要掌握一种分析机器指令级运算效率的图：Data-Flow 图。</span><br><span class="line"></span><br><span class="line">**它展现了不同操作间数据的 dependency 是如何限制执行顺序，并形成关键路径的**。这个关键路径就是该组机器指令的执行时间下界。</span><br><span class="line"></span><br><span class="line">以一个结构体数据类型为例：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">/* data structure for vectors */</span><br><span class="line">/* we can use different declarations for data_t */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    size_t len;</span><br><span class="line">    data_t *data;</span><br><span class="line">&#125; vec;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>其中的一个函数是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retrieve vector element and store at val. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_vec_element</span><span class="params">(vec* v, <span class="type">size_t</span>, idx, <span class="type">data_t</span>* val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= v-&gt;len) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">/* Out of range. */</span></span><br><span class="line">    *val = v-&gt;data[idx];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个函数进行<strong>基准测试（Benchmark Computation）</strong>：</p><ul><li><p>测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;        <span class="comment">/* 将可能重复计算的部分提出循环 */</span></span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)    <span class="comment">/* 不使用额外的 procedure 来重复检查 v-&gt;len */</span></span><br><span class="line">        t = t OP d[i];</span><br><span class="line">    *dest = t;                    <span class="comment">/* 不直接在循环内给数组赋值，使用 local variable */</span></span><br><span class="line">&#125;                                <span class="comment">/* 暗示编译器没有 memory alias */</span></span><br></pre></td></tr></table></figure><p>我们将使用不同数据类型（<code>data_t</code> 分别是 <code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>），针对不同运算和值（<code>OP</code> 分别是 <code>+</code>、<code>*</code>，<code>IDENT</code> 分别是 0、1）；</p></li><li><p>测试指标：<strong>CPE (Cycle Per Element)</strong></p><ul><li>Convenient way to express performance of program that operates on vectors or lists.</li><li><strong>在这里，CPE 就是一个时钟周期中的进行 <code>OP</code> 运算的次数，总时长指标 <code>T = CPE * n + Overhead</code></strong>（这里 overhead 就是 n = 0 时的基础开销）；</li><li>tips: 在检查代码性能时，不应该以真实时间做单位（例如 nanosecond），应该使用处理器内部时钟周期作为单位更有用。因为开发者无法控制处理器频率，但是可以控制并衡量操作的时钟周期。</li></ul></li></ul><p>生成的机器指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L25:                                 # Loop:</span><br><span class="line">    vmulsd (%rdx), %xmm0, %xmm0# Multiply acc by data[i]</span><br><span class="line">    addq $8, %rdx # Increment data+i</span><br><span class="line">    cmpq%rax, %rdx # Compare to data+length</span><br><span class="line">    jne.L25 # If !=, goto Loop</span><br></pre></td></tr></table></figure><p>其对应的 primitive instructions 及 data-flow diagram 如下：</p><p><img src="imgs/data-flow-example.png"></p><p>我们能将这个 loop 中使用到的寄存器进行分类：</p><ul><li>read-only：只作为这个 iteration 的源值，例如这里是 <code>%rax</code>；</li><li>write-only：只作为这个 iteration 的目的地，这里没有；</li><li>local：这个 iteration 内部使用的寄存器（运算单元随取随用），比如这里的 <code>CC</code>；</li><li>loop：既作为这个 iteration 的写目的地，又作为下个 iteration 的源值，例如这里的 <code>%rdx</code>、<code>%xmm0</code>；</li></ul><p><strong>我们发现，<u>loop 类寄存器的操作链决定了这个 data-flow 的关键路径</u></strong>（因为循环不依赖的寄存器可以并在其他步骤同时执行）。</p><p>由此可以将 loop 类寄存器涉及的路径抽取出，根据依赖关系画出新的 data-flow：</p><p><img src="imgs/data-flow-example-critical.png" height="400px"></p><p>结合实验数据可知，这条链就是限制程序性能的关键。</p><p>现在我们尝试一些措施将循环 “展开”（unrolling loop），例如每个循环进行两个数组操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine5</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>)</span><br><span class="line">        t = (t OP d[i]) OP d[i+<span class="number">1</span>];        <span class="comment">/* Loop Unrolling (2x1). */</span></span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现性能结果更加接近 Latency Bound：</p><p><img src="imgs/comb5.png"></p><p>分析编译器生成的汇编代码可知，原来在一个周期中的两条运算指令的 Load 被提到前面的位置上，相当于右图：</p><p><img src="imgs/comb5-explain.png" width="450px"><img src="imgs/seq1.png" width="350px"></p><p>由于这些乘法运算仍然前后依赖，所以尽管我们进行 unrolling loop 来减小每个 iteration 造成的开销，仍然无法超过 latency bound。</p><p>那么，如果我们使用 <strong>多个循环累计变量</strong>（Separate Accumulator，奇偶元素分开计算，最后合并），就能手动提高并行性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine6</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> x0 = IDENT;</span><br><span class="line">    <span class="type">data_t</span> x1 = IDENT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Combine 2 elements at a time. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        x0 = x0 OP d[i];</span><br><span class="line">        x1 = x1 OP d[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Finish any remaining elements. */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)</span><br><span class="line">        x0 = x0 OP d[i];</span><br><span class="line">    *dest = x0 OP x1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次绘制 data-flow 图会发现，关键路径变为 2 条，意味着关键路径长度被缩短，解释如右图：</p><p><img src="imgs/comb6-explain.png" width="450px"><img src="imgs/seq3.png" width="350px"></p><p>再换一种方法，如果我们更换运算结合的顺序（被称为 <strong>Re-association Transformation</strong>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine7</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>)</span><br><span class="line">        t = t OP (d[i] OP d[i+<span class="number">1</span>]);        <span class="comment">/* re-association */</span></span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也能发现，两条乘法指令的依赖关系改变了：每两条乘法指令只有一条在关键路径上：</p><p><img src="imgs/comb7-explain.png" width="450px"><img src="imgs/seq2.png" width=350px></p><p>这两种方式（separate accumulator、re-association）都能大幅度缩短关键路径，让程序性能突破 latency 瓶颈，接近吞吐量：</p><p><img src="imgs/combs-comp.png"></p><p>如果 separate accumulator 展开 10 次，就能更大限度利用机器资源。</p><p>但是，无论是 unrolling loop，还是 separate accumulator，都有一个界限：register spilling（寄存器溢出）。如果中间步骤展开过多，超过了已有寄存器数量，<strong>这时处理器会用内存来代替，反而会降低运行效率</strong>。</p><p>此外，之前我们提到了尽管整数加法有 4 个器件，但 throughput 不会超过 0.5，是因为 load/store 的约束。而我们之前看到的例子中，load 似乎不在关键路径上（因为之前的 load 只依赖于索引 i）。其实，load/store 操作也会和之前的 multiply 一样成为某些程序的关键路径，例如链表程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">long</span> data;</span><br><span class="line">&#125; list_ele, *list_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">list_len</span><span class="params">(list_ptr ls)</span> &#123;</span><br><span class="line">    <span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L3:</span><br><span class="line">    addq$1, %rax</span><br><span class="line">    movq(%rdi), %rdi</span><br><span class="line">    testq%rdi, %rdi</span><br><span class="line">    jne.L3</span><br></pre></td></tr></table></figure><p>这个时候加载的结果决定下一条操作的地址时，load 指令（<code>movq</code> 的其中一个 $\mu$ code）就是关键路径上的一环了。我们发现这种循环的 CPE 约 4.00，说明：<u><strong>load 的 latency 约 4.00</strong></u>。</p><p>除了 load，store 也会成为关键路径的一环。来看两个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_array</span><span class="params">(<span class="type">long</span>* dest, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dest[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_read</span><span class="params">(<span class="type">long</span> *src, <span class="type">long</span> *dst, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> cnt = n;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cnt) &#123;</span><br><span class="line">        *dst = val;</span><br><span class="line">        val = (*src) + <span class="number">1</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>func1</code> 的 CPE 能达到 1.0，很好解释，是因为 store <strong>暂时不影响寄存器值（前面提到 pending write 到 renaming table）</strong>，不会产生数据依赖，因此可以完全流水线化，这也是最佳情况（throughput bound）。</p><p>但是 <code>func2</code>，如果 <code>src != dst</code>，那么 CPE 约为 1.3；但是如果 <code>src == dst</code>，那么 CPE 上升到 7.3（下降了 6 个 cycles）！这可以用 data-flow 分析出。</p><p>先写出汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.L3:</span><br><span class="line">    movq%rax, (%rsi)</span><br><span class="line">    movq(%rdi), %rax</span><br><span class="line">    addq$1, %rax</span><br><span class="line">    subq$1, %rdx</span><br><span class="line">    jne.L3</span><br></pre></td></tr></table></figure><p><code>movq %rax, (%rsi)</code> 会被分解为两条 primitive instruction：<code>s_addr</code>（计算目标内存地址，由单独的运算单元完成）、<code>s_data</code>（数据 store）。</p><p>如果 store 的数据依赖于前一步的 load（read-write dependency），那么根据汇编代码可以画出：</p><blockquote><p>其中 <code>movq</code></p></blockquote><p><img src="imgs/data-flow-load-store.png"></p><p>如果 <code>src != dst</code>，那么箭头 3 不存在，关键路径将是 <code>sub</code>（CPE 约 1.3）；</p><p>如果 <code>src == dst</code>，那么箭头 3 的依赖关系就存在，关键路径就是 <code>s_data -&gt; load -&gt; add</code>（CPE 约 7.3）。</p><p>此外，还有一些在机器层面影响性能的其他因素：</p><h3 id="12-5-1-Branch-Misprediction-Recovery"><a href="#12-5-1-Branch-Misprediction-Recovery" class="headerlink" title="12.5.1 Branch Misprediction Recovery"></a>12.5.1 Branch Misprediction Recovery</h3><p>我们在 4.2.2 中提到过，机器层面的分支预测技术（Branch Prediction）就是为了让 CPU 流水线的效率得到充分利用而诞生的。在很多情况下，如果我们不使用条件移动的话，那么在分支预测错误的时候，很有可能整个流水线的指令和数据全部需要重新载入，这将耗费大量的运算资源和时间。</p><p>所以第一个思路就是从降低 <strong>Branch Misprediction Penalty</strong> 方面着手。首先了解一下分支预测技术的大概原理是啥。分支预测技术在早期使用的是简单的 heuristic：向后分支（backwards branches）经常是判断（if），向前分支（forwards branches）经常是循环（loop）。我们可以通过一些算法<strong>跟踪这些分支（尤其是循环）的历史行为，如果它经常通过某一分支，那么以后预测该分支的可能性会大一点</strong>。</p><p>这种预测方法在有些代码中效果显著，但是另一些代码（<strong>例如强数据依赖、强随机数据</strong>）中效果极差，甚至导致更多的 Branch Misprediction Penalty；</p><p>因此接近这个方面问题的可能途径如下：</p><ul><li>减少分支结构的数量：<ul><li>Transform loops（尽量转换、消除不必要的循环）</li><li>Unroll loops（下面介绍）</li><li>Use Conditional Moves（4.2.2）</li></ul></li><li>使得分支<strong>更容易被分支预测器预测</strong><ul><li>为循环中的数据排序（需要权衡）</li><li>尽量避免间接的分支结构（因为间接分支基本上都没有预测依据）<ul><li>函数指针判断跳转</li><li>虚函数运行时判断跳转</li></ul></li></ul></li></ul><p>这里介绍一下 unroll loops 的思路。unroll loops 就是<strong>将循环中的代码成倍数展开，达到均摊 Branch Misprediction Penalty 的目的</strong>。同时，这种方法还能为其他的优化方法创造条件（例如 CSE、Code Motion、Scheduling 等）。方法的示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts; i++)</span><br><span class="line">    A[i] = B[i]*k + C[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    A[i  ] = B[i  ]*k + C[i  ];</span><br><span class="line">    A[i+<span class="number">1</span>] = B[i+<span class="number">1</span>]*k + C[i+<span class="number">1</span>];</span><br><span class="line">    A[i+<span class="number">2</span>] = B[i+<span class="number">2</span>]*k + C[i+<span class="number">2</span>];</span><br><span class="line">    A[i+<span class="number">3</span>] = B[i+<span class="number">3</span>]*k + C[i+<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方法有两个明显的缺陷，一是如果过度展开，会增长代码长度，同样会影响性能。所以需要根据数据量进行权衡；二是在某些循环中，依赖 i 进行判断的场合，这种展开就不适用了。</p><h3 id="12-5-2-Scheduling"><a href="#12-5-2-Scheduling" class="headerlink" title="12.5.2 Scheduling"></a>12.5.2 Scheduling</h3><p>在上面的流程中，除了 Branch Misprediction Penalty，还有一种会影响 CPU 运算性能的情况——数据读取和写入。I/O 操作的开销一直是处理器设计者头疼的地方，尽管现在有高速缓存器来进行弥补，但数据的存取在运算过程中还是尽量能少就少。</p><p>因此，<strong>将源代码中读取、写入的部分和运算的部分分开（最好在运算前就读入所有必需的数据、在所有运算后才写入必要的数据），能够让处理器的性能发挥到最大</strong>（这个优化也可以由编译器完成）。这种方法就称为代码调度（Scheduling）。</p><p>例如 12.5.1 中的代码还可以继续优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    B0 = B[i]; B1 = B[i + <span class="number">1</span>]; B2 = B[i + <span class="number">2</span>]; B3 = B[i + <span class="number">3</span>];</span><br><span class="line">    C0 = C[i]; C1 = C[i + <span class="number">1</span>]; C2 = C[i + <span class="number">2</span>]; C3 = C[i + <span class="number">3</span>];</span><br><span class="line">    A[i  ] = B0*k + C0;</span><br><span class="line">    A[i+<span class="number">1</span>] = B1*k + C1;</span><br><span class="line">    A[i+<span class="number">2</span>] = B2*k + C2;</span><br><span class="line">    A[i+<span class="number">3</span>] = B3*k + C3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，这样的操作对于有些情况也不适用，比如在一些业务逻辑下，读取操作必须在一群算数运算之间出现。</p><h2 id="12-6-Summary"><a href="#12-6-Summary" class="headerlink" title="12.6 Summary"></a>12.6 Summary</h2><p>本章讲述了一些程序优化的基本思路，主要从两个方向描述。</p><p>一个是与机器无关方向的优化小技巧，而这些技巧也常常会内置在编译器中，成为编译工作的一个部分。它们大致可以分为以下几类：</p><ul><li>局部的优化：例如 <strong>常数折叠、计算强度减小（通过更换运算符实现）、死代码剔除、局部的相近表达式复用消除</strong>；</li><li>全局的优化：例如 <strong>循环结构转换、代码移动（减少不必要的运算）、内联化、全局的相近表达式复用消除</strong>；</li></ul><p>在这个方面，我们考虑了相反的情况——什么样的编码会阻碍编译器帮助我们进行上面的优化。</p><ul><li>Procedure Calls：我们应该在代码设计时，充分考虑函数调用的位置对于性能影响；</li><li>Memory Alias：尤其是在循环结构中，多使用局部变量暂存中间结果，或者使用更严格的关键字；</li></ul><p>这都在提醒我们编码时，能尽早确定的定值，尽量存在局部变量中，以防编译器认为中间存在变数，而不敢于进行优化。</p><p>另一个是与具体机器有关方向的优化技巧（但是目前世界上的机器种类就这些，所以理论上也有一定的普适性，例如 ARM 架构和 x86 架构都能使用这种优化来提升性能），编译器不一定会帮你做这些优化，这是因为这些方法有着各自的局限性。</p><p>我们分析了现代 CPU 的结构特性，找到了 3 处可以进行优化的地方，一个是分支预测的部分，一个是代码中的 I/O 调度，另一个是运算顺序和方法。</p><p>首先我们了解了分支预测器的原理和性质，我们发现想要弥补 Branch Misprediction Penalty，就需要从两个方面入手：</p><ol><li>让它少预测点，就少错一点（减少分支结构）。这方面的方法大致有 <strong>循环转换、unrolling loops 和 conditional moves（回想之前的 General Condition Translation）</strong>；</li><li>提升它预测的正确率。依从分支预测器的原理，我们可以让每次产生的分支判断的结果有迹可循。总的来说，我们可以通过<strong>为需要的判断数据排序</strong>（局限性强）、<strong>减少编码一些难以预测的结构</strong>（例如函数指针判断、虚函数）。</li></ol><p>在 I/O 调度方面我们发现，CPU 频繁地从高速缓存器中读入和写出数据也会降低程序性能，因此在编码过程中写出能够让汇编码中读内存次数越少的源码越好。因此，这里的重要建议是<strong>将源代码中读取、写入的部分和运算的部分分开（最好在运算前就读入所有必需的数据、在所有运算后才写入必要的数据）</strong>。</p><p>本章最后以一个计算例子说明，通过<strong>分析关键路径</strong>，使用 Re-association Transformation、Separate Accumulator 来让更多的乘法运算并行起来。</p><p>当然，当我们利用以上技术（例如 loop unrolling）优化到一定程度后，其他方面的问题就变成了关键路径上的问题。例如 unrolling 过多时，发生 register spilling（寄存器用完了，开始使用内存）影响性能。</p><p><img src="imgs/ch15-summary.png" height="250px"></p><p>最后介绍一个优化的规则：Amdahl‘s Law</p><script type="math/tex; mode=display">S=\dfrac{T_{old}}{T_{new}}=\dfrac{1}{(1-\alpha)+\dfrac{\alpha}{K}}\Longrightarrow S_{\infty}=\dfrac{1}{1-\alpha}</script><p>$(1-\alpha)$ 代表不能被优化的部分，$K$ 代表能被优化的部分最快被优化多少倍。</p><p>当能优化的部分优化到极限后，加速比极限为 $S_\infty$。<strong>表达式说明一个通俗的道理：选择优化时间占比更大的部分（$\alpha$ 更大），优化的效果、优化的极限就更好（$S_\infty$ 更大）</strong>。</p><p>也就是说，我们应该在优化时找关键路径、找 hot spot（热点位置）。这就是 profiling。</p><p>当今的 profiling 工具有哪些？Unix 上有 <code>gprof</code>、<code>perf</code>，它们的思路是 <strong>random sampling</strong>，间隔一定时间进行指令中断，统计函数执行的次数、统计当前调用栈（可以发现调用关系、递归情况），用频率代表出现总时长占比。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-10-The-Memory-Hierarchy&quot;&gt;&lt;a href=&quot;#Chapter-10-The-Memory-Hierarchy&quot; class=&quot;headerlink&quot; title=&quot;Chapter 10. The Memory Hierarc</summary>
      
    
    
    
    <category term="review" scheme="https://sjtuxhw.top/categories/review/"/>
    
    
    <category term="GNU" scheme="https://sjtuxhw.top/tags/GNU/"/>
    
    <category term="CSAPP" scheme="https://sjtuxhw.top/tags/CSAPP/"/>
    
    <category term="ICS" scheme="https://sjtuxhw.top/tags/ICS/"/>
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript笔记</title>
    <link href="https://sjtuxhw.top/2024/03/18/TypeScript%E7%AC%94%E8%AE%B0/"/>
    <id>https://sjtuxhw.top/2024/03/18/TypeScript%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-18T14:56:29.000Z</published>
    <updated>2024-03-18T15:10:46.953Z</updated>
    
    <content type="html"><![CDATA[<p><i>Written by SJTU-XHW</i></p><p><i>Reference: </i> MDN Doc &amp;&amp; TypeScript Doc</p><p><i>本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h1 id="Chapter-1-与-JS-比较：类型声明-与-作用域"><a href="#Chapter-1-与-JS-比较：类型声明-与-作用域" class="headerlink" title="Chapter 1. 与 JS 比较：类型声明 与 作用域"></a>Chapter 1. 与 JS 比较：类型声明 与 作用域</h1><p>TypeScript 是个静态类型语言，<strong>变量类型/对象成员/函数签名 在定义后就不能更改！</strong></p><ul><li><p>定义变量时，请使用规范的类型声明定义方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Variable */</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">bar</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, TypeScript!&quot;</span>;</span><br><span class="line"><span class="comment">/* Function */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>天大的福音：<strong>只声明变量、不赋值就使用会报错！这下不用担心讨厌的 <code>undefined</code> 了</strong>；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>而且开启了编译选项 <code>strictNullChecks</code> 后，<code>undefined</code> 也是个独立的类型，不能赋给除了 <code>undefined</code> 类型以外的其他类型！</p></li><li><p>不允许给变量中途赋予不同类型的值；</p></li></ul><p>此外，<strong>比 JavaScript 更加暖心的操作是：TypeScript 全面支持 <u>块级作用域</u>！</strong>定义在块级作用域内的变量、类型等等不再能被外界读到了！</p><h1 id="Chapter-2-TypeScript-编译"><a href="#Chapter-2-TypeScript-编译" class="headerlink" title="Chapter 2. TypeScript 编译"></a>Chapter 2. TypeScript 编译</h1><p>TypeScript 不提供运行环境，全部交给 JavaScript，自己只提供转换为 JavaScript 的编译器 <code>tsc</code>，甚至这个编译器也是 JavaScript 的一个库，可以用 <code>npm</code> 安装。</p><p>编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。</p><p>因此，TypeScript 的类型检查只是编译时的类型检查，而不是运行时的类型检查。一旦代码编译为 JavaScript，运行时就不再检查类型了。</p><p>TypeScript 的编译器 <code>tsc</code> 的简单使用如下：</p><ul><li><p>安装：<code>npm install -g typescript</code>；</p></li><li><p>编译单个 TS 文件，或多个没有层次依赖关系的 TS 文件：<code>tsc a.ts[, b.ts, ...]</code>；</p><blockquote><p>分别生成 <code>a.js, b.js, ...</code>；</p></blockquote></li><li><p><code>--outFile</code> 编译为一个指定的 JavaScript：<code>tsc a.ts[, b.ts, ...] --outFile XXX.js</code>；</p></li><li><p><code>--outDir</code> 指定输出目录；</p></li><li><p><code>--target</code> 指定编译 JavaScript 标准（建议 <code>es2015</code> 及以上）；</p></li></ul><p>如果项目更复杂一点，就需要 <code>tsconfig.json</code> 管理编译过程（考虑 Java 的 Gradle 和 C++ 的 CMakeLists）。其简单结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;file1.ts&quot;</span><span class="punctuation">,</span> <span class="string">&quot;file2.ts&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/app.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这时候直接运行 <code>tsc</code> 等价于原来的 <code>tsc file1.ts file2.ts --outFile dist/app.js</code>；</p><p>更复杂的使用以后介绍。</p><h1 id="Chapter-3-TypeScript-类型系统"><a href="#Chapter-3-TypeScript-类型系统" class="headerlink" title="Chapter 3. TypeScript 类型系统"></a>Chapter 3. TypeScript 类型系统</h1><h2 id="3-1-新的辅助类型"><a href="#3-1-新的辅助类型" class="headerlink" title="3.1 新的辅助类型"></a>3.1 新的辅助类型</h2><p>和 JavaScript 不一样的是，TypeScript 提供了 3 种特殊类型：<code>any</code>、<code>unknown</code>、<code>never</code>，它们是为了配合静态类型系统更好的发挥功能而创造出来的。</p><h3 id="3-1-1-Any-类型"><a href="#3-1-1-Any-类型" class="headerlink" title="3.1.1 Any 类型"></a>3.1.1 Any 类型</h3><p>当给变量声明 <code>any</code> 类型时，<strong>TypeScript 会关闭这个变量的类型检查，这个变量单独变为 “动态类型”</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">x</span>(<span class="number">1</span>); <span class="comment">// OK</span></span><br><span class="line">x.<span class="property">foo</span> = <span class="number">100</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="string">&quot;foo&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>如你所见，肯定要避免使用 <code>any</code> 类型，不然你为什么不用 JavaScript？</p><p>频繁使用 <code>any</code> 会导致 TypeScript 丧失静态类型的优势，具体来说有几个坏处：</p><ul><li><p>干扰类型推断和编译前错误检查：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">any</span>, y: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></li><li><p>静态类型污染：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 不报错</span></span><br><span class="line"></span><br><span class="line">y * <span class="number">123</span>; <span class="comment">// 不报错</span></span><br><span class="line">y.<span class="title function_">toFixed</span>(); <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure></li></ul><p>即使你不使用 <code>any</code> 类型，也要注意编译器可能<strong>自动推断 <code>any</code> 类型</strong>，这通常是因为开发者不良开发习惯所导致的 —— <strong>声明、定义变量 / 定义函数 时，不进行类型标注</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">let</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上变量、函数声明全部会被编译器推断为 <code>any</code>，从而干扰类型检查！</p><p>总之，<u>对于 TypeScript 的 <code>any</code> 类型，请敬而远之！自己不写 <code>any</code>，也别让编译器推断出 <code>any</code></u>。这是编译器实在没法进行类型检查时候的下下策。</p><blockquote><p>还是那句话，不然你为什么不直接用 JavaScript？</p></blockquote><h3 id="3-1-2-Unknown-类型"><a href="#3-1-2-Unknown-类型" class="headerlink" title="3.1.2 Unknown 类型"></a>3.1.2 Unknown 类型</h3><p>为了防止 <code>any</code> 的类型污染等问题，人们定义了一种比 <code>any</code> 类型严格的辅助类型 <code>unknown</code>，规则如下：</p><ul><li>允许给 <code>unknown</code> 类型变量赋予任何类型的值；</li><li><strong>不允许将 <code>unknown</code> 类型变量赋予其他确定类型（即除了 <code>any</code> 和 <code>unknown</code>）的值</strong>；</li><li><strong>不允许使用 <code>unknown</code> 类型的方法、属性</strong>；</li><li>只能对 <code>unknown</code> 类型进行有限的运算：逻辑运算、判断相等运算、<code>typeof</code>、<code>instanceof</code>，其他运算均不可以；</li></ul><p>违反以上规则，编译器会抛出错误。</p><p>但是 <code>unknown</code> <strong>允许<u>类型缩窄</u></strong>（比如一开始没法确定这个数据的类型，但是后面要处理时确定了，这种情况就不需要使用 <code>any</code> 了），如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: <span class="built_in">unknown</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> s === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">  s.<span class="property">length</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在作用域中，<code>s</code> 类型被缩窄为 <code>string</code>，变成了确定类型，就可以使用确定类型的一切方法和属性了。</p><p>总之，<strong>某些逻辑下，实在无法确定类型，应该优先使用 <code>unknown</code> 类型，避免 <code>any</code> 出现</strong>。</p><h3 id="3-1-3-Never-类型"><a href="#3-1-3-Never-类型" class="headerlink" title="3.1.3 Never 类型"></a>3.1.3 Never 类型</h3><p>从集合论的角度，人们定义了这个类型，含义是 <strong>空类型</strong>，可以赋给任何类型的变量。</p><p>你可能会好奇，那被赋予 <code>never</code> 类型的变量内部的值怎么办？</p><p>问出这个问题说明你还没有明白 <code>never</code> 的使用场景：<strong>在函数中，它标识控制流永远无法到达函数返回的时候；在变量中，它标识永远都不会用到该变量</strong>。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, TypeScript!&quot;</span>);    <span class="comment">// 编译器会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是错误的，因为函数能够执行到最后，返回的是 <code>undefined</code> 类型的对象，而不是空。</p><blockquote><p>如果你只是想标识函数不返回值，请使用 <code>undefined</code> / <code>void</code> 作为返回类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, TypeScript!&quot;</span>);  <span class="comment">// Correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>这样才是正确使用方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    <span class="comment">/* Control Never Reaches Here! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-新的基本类型-和-引用类型"><a href="#3-2-新的基本类型-和-引用类型" class="headerlink" title="3.2 新的基本类型 和 引用类型"></a>3.2 新的基本类型 和 引用类型</h2><p>复习一下 JavaScript 中有几种基本类型和引用类型：</p><p><code>boolean</code>、<code>string</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>、<code>object</code>（狭义对象类型也是个基本类型，和广义对象类型 <code>Object</code> 不同，仅包含所有引用类型，如 Array 等内置引用类型）、<code>undefined</code>、<code>null</code>；</p><blockquote><p>补充 JavaScript 不常用的类型使用方法：</p><ul><li><code>bigint</code>：<strong>在 JavaScript 中，使用 <code>bigint</code> 需要数字尾缀 <code>n</code></strong>，例如 <code>123n</code>；</li></ul></blockquote><h3 id="3-2-1-TypeScript-的对象"><a href="#3-2-1-TypeScript-的对象" class="headerlink" title="3.2.1 TypeScript 的对象"></a>3.2.1 TypeScript 的对象</h3><p>这里得说明一下，对象（引用类型）的定义和 JavaScript <strong>显著不同</strong>。</p><p>因为 TypeScript 作为一种静态类型语言，不允许定以后更改数据成员。因此你这么写，编译器会报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">o1</span>: <span class="title class_">Object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">o2</span>: <span class="built_in">object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">o1.<span class="property">foo</span>; <span class="comment">// TypeError</span></span><br><span class="line">o2.<span class="property">foo</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>因为你定义的 <code>o1/o2</code> 类型是原生的 <code>object/Object</code>，都只有原生的属性和方法，<code>foo</code> 属性在赋值时就被抛弃了。</p><p><strong>要想自定义对象的属性和方法，要么定义对象类型，要么定义 <code>class</code>（TypeScript 的类，后面讲）</strong>；</p><h3 id="3-2-2-TypeScript-值类型"><a href="#3-2-2-TypeScript-值类型" class="headerlink" title="3.2.2 TypeScript 值类型"></a>3.2.2 TypeScript 值类型</h3><p>TypeScript 规定，单个值也是一种类型，称为“值类型”，不常用，它常常用在联合 / 交叉类型中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">name</span>: <span class="string">&quot;Hello&quot;</span>;    <span class="comment">// 只能被赋予 &quot;Hello&quot;，其他内容都会报错。</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-TypeScript-常量类型"><a href="#3-2-3-TypeScript-常量类型" class="headerlink" title="3.2.3 TypeScript 常量类型"></a>3.2.3 TypeScript 常量类型</h3><p>所有使用 <code>const</code> 关键字修饰的 TypeScript 的变量都是常量，它们不能被更改。</p><p>你可以把这个变量理解为 <strong>以初次赋予的值为值类型的变量</strong>。</p><h3 id="3-2-4-TypeScript-对象类型"><a href="#3-2-4-TypeScript-对象类型" class="headerlink" title="3.2.4 TypeScript 对象类型"></a>3.2.4 TypeScript 对象类型</h3><h4 id="3-2-4-1-使用方法"><a href="#3-2-4-1-使用方法" class="headerlink" title="3.2.4.1 使用方法"></a>3.2.4.1 使用方法</h4><p>而 “对象类型” 则<strong>可以很方便地（无需定义接口 interface、类型 class）定义对象并指定临时类型</strong>，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">testFunc1</span>(<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">testFunc2</span>: <span class="function">(<span class="params">c: <span class="built_in">string</span>, d: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">boolean</span>;    <span class="comment">// 箭头函数式声明</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    <span class="title function_">testFunc1</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? a.<span class="title function_">toString</span>() : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    testFunc2 = <span class="keyword">function</span>(<span class="params">c, d</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c === d.<span class="built_in">parseInt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-2-对象类型的特性"><a href="#3-2-4-2-对象类型的特性" class="headerlink" title="3.2.4.2 对象类型的特性"></a>3.2.4.2 对象类型的特性</h4><p>一旦声明某个对象的对象类型后，赋值一定要分毫不差地按照类型来，否则编译器不会接受，即<u><strong>不允许</strong></u>以下行为：</p><ul><li>增添对象类型中不存在的字段、删除对象类型中已有的字段；</li><li>定义+赋值时，少给一个成员赋值，或者给不存在的成员赋值；</li></ul><p>但是它也允许一些特性以在合理的范围内支持灵活性：</p><ul><li><p>允许数据域添加 可选修饰符 <code>?</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span> | <span class="literal">undefined</span>; <span class="comment">// 注意进行类型缩窄</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>允许数据域添加 只读修饰符 <code>readonly</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">resident</span>: &#123;<span class="comment">// 只读数据域如果是对象，则允许更改数据域，不允许更改对象引用</span></span><br><span class="line">        <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">        <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只读数据域和普通数据域间传递，与 C 的 <code>const</code> 修饰类型和普通类型的方法一样，不再赘述。</p></li><li><p>允许 <u><strong>数据域索引</strong></u>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TestObjT</span> = &#123;</span><br><span class="line">    [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>TestObjT</code> 的含义是，<strong>不管这个对象有多少属性，只要属性名为字符串，且属性值也是字符串，就符合这个类型声明</strong>，比如可以这么定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">tobj</span>: <span class="title class_">TestObjT</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="attr">baz</span>: <span class="string">&quot;3&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，对象类型的数据域索引中 property 类型允许 <code>string</code>、<code>number</code>、<code>symbol</code>；</p><p>不过这个特性不建议使用，因为对类型的约束过于宽泛。</p></li></ul><h4 id="3-2-4-3-解构赋值-与-对象类型"><a href="#3-2-4-3-解构赋值-与-对象类型" class="headerlink" title="3.2.4.3 解构赋值 与 对象类型"></a>3.2.4.3 解构赋值 与 对象类型</h4><p>和 python 的解构语法类似，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, axe = matplotlib.pyplot.subplots()</span><br><span class="line">[a, _] = curStr.split(<span class="string">&#x27;/&#x27;</span>)</span><br></pre></td></tr></table></figure><p>TypeScript 的解构要求指定 <strong>对象类型</strong>，其实有两种语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 obj **按序**解构到指定的变量，必须声明成对象的对象类型（type of obj）</span></span><br><span class="line">&lt;qualifiers&gt; &#123;var1, var2, ...&#125;: &lt;type of obj&gt; = obj;</span><br><span class="line">// 自定义解构顺序</span><br><span class="line">&lt;qualifiers&gt; &#123;objProp1: var1, objProp2: var2, ...&#125;: &lt;type of obj&gt; = obj；</span><br></pre></td></tr></table></figure><p>第一种语法很好理解，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  id,</span><br><span class="line">  name,</span><br><span class="line">  price,</span><br><span class="line">&#125;: &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = product;</span><br></pre></td></tr></table></figure><p>但我们发现 “自定义解构顺序” 的写法非常迷惑，因为大括号内的冒号不再指类型，而是指数据域的映射关系，例如很多新手会这么写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">shape</span>: <span class="title class_">Shape</span>;</span><br><span class="line">    <span class="attr">xpos</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">shape</span>: &#123;<span class="attr">width</span>: <span class="number">1</span>, <span class="attr">height</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="attr">xpos</span>: <span class="number">0.0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">shape</span>: <span class="title class_">Shape</span>, <span class="attr">xpos</span>: <span class="built_in">number</span>&#125; = obj;</span><br></pre></td></tr></table></figure><p>最后一句话的含义是什么？如果你认为这是第一种语法，按序把 <code>obj</code> 的 <code>shape</code> 和 <code>xpos</code> 属性赋给了外部的 <code>shape</code>、<code>xpos</code> 变量，<strong>那么就大错特错了！</strong></p><p>因为要牢记：<u><strong>解构语法中的冒号不再作为类型尾缀，而是作为数据域映射的含义</strong></u>，在这里，解构语法一旦出现冒号，就一定是第二条语法。</p><p>上面的最后一条语句的真正含义是，<strong>将 <code>obj</code> 的 <code>shape</code> 数据域赋给外围以 “Shape” 为变量名的变量，它的类型名也是 <code>Shape</code>！</strong>（number 同理）</p><h4 id="3-2-4-4-对象类型的结构类型原则（Structual-Typing-Principle）"><a href="#3-2-4-4-对象类型的结构类型原则（Structual-Typing-Principle）" class="headerlink" title="3.2.4.4 对象类型的结构类型原则（Structual Typing Principle）"></a>3.2.4.4 对象类型的结构类型原则（Structual Typing Principle）</h4><p>只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structual typing）。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">A</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">B</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对象 B 满足 A 的结构特征，说明 B 的对象类型 <strong>兼容</strong> A 的对象类型，因此 B 可以直接赋给 A，但反过来不行。</p><h4 id="3-2-4-5-对象类型的最小可选属性规则"><a href="#3-2-4-5-对象类型的最小可选属性规则" class="headerlink" title="3.2.4.5 对象类型的最小可选属性规则"></a>3.2.4.5 对象类型的最小可选属性规则</h4><p>如果一个对象类型所有属性都由 可选修饰符 修饰，按语义理解的话，所有对象都会符合这个定义。</p><p>TypeScript 为了防止类型模糊，规定：</p><p>当一个对象类型所有属性都由 可选修饰符 修饰，那么要定义一个该类型的对象，<strong>至少要含有一个可选属性</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Options</span> = &#123;</span><br><span class="line">    a?: <span class="built_in">number</span>;</span><br><span class="line">    b?: <span class="built_in">number</span>;</span><br><span class="line">    c?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">Options</span> = &#123;</span><br><span class="line">    <span class="attr">d</span>: <span class="number">123</span>, <span class="comment">// TypeError</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: <span class="title class_">Options</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>;    <span class="comment">// Correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-5-TypeScript-的联合类型-与-交叉类型"><a href="#3-2-5-TypeScript-的联合类型-与-交叉类型" class="headerlink" title="3.2.5 TypeScript 的联合类型 与 交叉类型"></a>3.2.5 TypeScript 的联合类型 与 交叉类型</h3><p>联合类型 <code>var x: A | B</code> 表示 <code>x</code> 既可以是 <code>A</code> 类型，又可以是 <code>B</code> 类型；</p><p>这其实是暂时无法判断类型的最正确的处理方法。</p><p>它仅允许使用二者类型共同的属性或方法，否则编译器会抛出错误。必须使用 <strong>缩窄类型</strong> 才可以针对性地使用属性和方法。</p><p>交叉类型 <code>var y: A &amp; B</code> 表示 <code>x</code> 必须既是 <code>A</code> 类型，又是 <code>B</code> 类型，<strong>最常见用作对象属性的临时合成</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span> &amp; <span class="built_in">string</span>;    <span class="comment">// 编译器认为无法取得，是 never 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123; <span class="attr">foo</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">bar</span>: <span class="built_in">string</span> &#125;;    <span class="comment">// 具有 foo, bar 两个数据成员的对象类型</span></span><br></pre></td></tr></table></figure><h3 id="3-2-6-TypeScript-类型别名"><a href="#3-2-6-TypeScript-类型别名" class="headerlink" title="3.2.6 TypeScript 类型别名"></a>3.2.6 TypeScript 类型别名</h3><p>TypeScript 中的关键字 <code>type</code>，现在完全可以理解为 C 的 <code>typedef</code>，就是<strong>定义一个类型（值类型、对象类型、联合类型、交叉类型，等等）的别名</strong>，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">TA</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">testFunc1</span>(<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">testFunc2</span>: <span class="function">(<span class="params">c: <span class="built_in">string</span>, d: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">TB</span> = <span class="variable constant_">TA</span> &amp; &#123; <span class="attr">z</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="variable constant_">TB</span> = &#123;</span><br><span class="line">    <span class="comment">/* Definitions */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p><strong>别名不允许重名！</strong></p></li><li><p>别名的有效范围是当前的块级作用域（例如定义在大括号内、函数内，在外面就没有效用了）；</p></li><li><p>别名支持使用表达式定义，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">World</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="string">`hello <span class="subst">$&#123;World&#125;</span>`</span>;</span><br></pre></td></tr></table></figure></li><li><p>别名是类型相关代码，因此在编译为 JavaScript 后会被完全清除。</p></li></ul><h3 id="3-2-7-TypeScript-typeof-运算符"><a href="#3-2-7-TypeScript-typeof-运算符" class="headerlink" title="3.2.7 TypeScript typeof 运算符"></a>3.2.7 TypeScript <code>typeof</code> 运算符</h3><p>JavaScript 的 <code>typeof</code> 返回的是对应类型的字符串；</p><p>实际上，在 TypeScript 中保留了 JavaScript 的 <code>typeof</code>，又增添了一个新的 <code>typeof</code> 运算符，返回的是 <strong>TypeScript 类型（比如基本类型、值类型、对象类型等等）</strong>，由于是类型，因此这种运算符不能用于值运算，只能放在类型推导中。</p><p>举个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="keyword">typeof</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个 <code>typeof</code> 是 TypeScript 新增的返回类型的 <code>typeof</code>，只能用于类型推导，参数不能是<strong>表达式</strong>（前面的类型别名可以）。在编译后会被完全清除；</p><p>第二个 <code>typeof</code> 是 JavaScript 原生的 <code>typeof</code>，返回的是字符串，可以用于值运算。</p><h2 id="3-3-TypeScript-中的数组：基本类型和内置引用类型"><a href="#3-3-TypeScript-中的数组：基本类型和内置引用类型" class="headerlink" title="3.3 TypeScript 中的数组：基本类型和内置引用类型"></a>3.3 TypeScript 中的数组：基本类型和内置引用类型</h2><h3 id="3-3-1-定义和使用"><a href="#3-3-1-定义和使用" class="headerlink" title="3.3.1 定义和使用"></a>3.3.1 定义和使用</h3><p>这里和 JavaScript 动态类型语言不像，而是更接近 Java 的静态类型。</p><p><strong>TypeScript 数组所有成员的类型必须相同，但是成员数量是不确定的</strong>，<u>不论是基本类型数组 <code>type[]</code> 还是 内置类型 <code>Array&lt;Type&gt;</code></u>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">arr</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>内置类型 Array 被改成了更像 Java 的泛型，方法和 JavaScript 原生都是一样的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">arr</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>和 JavaScript 一样，可以通过修改 <code>length</code> 属性直接增减成员。</p><p>由于长度不定，因此 <strong>TypeScript 的数组越界也不会报错</strong>，只会返回 <code>undefined</code>；</p><p><code>Array</code> 内置类型和 JavaScript 原生用法几乎一致，方法不再赘述。</p><h3 id="3-3-2-只读数组"><a href="#3-3-2-只读数组" class="headerlink" title="3.3.2 只读数组"></a>3.3.2 只读数组</h3><p>不仅是 JavaScript，大多数语言都认为数组及其他形式的对象都是 <strong>可变数据类型</strong>，因此把数组本身定义为 <code>const</code> 是不会阻止数组被修改的。我们以 C++ 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">size_t</span> s): <span class="built_in">arrSize</span>(s), <span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[s] &#123;<span class="number">0</span>&#125;) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;<span class="keyword">delete</span>[] arr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> arrSize;</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setter</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        arr[idx] = val;    <span class="comment">// OK！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>setter</code> 函数使用 <code>const</code> 修饰，也没能阻止数组被修改。</p><p>为了限制可变数据类型的修改问题，C++ 采用的是常量指针的方法，声明不允许修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 上面的 arr 声明改成： */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> <span class="type">const</span>* arr;</span><br></pre></td></tr></table></figure><p>这样数组就不再可以被修改，上面的 <code>setter</code> 也会让编译器报错。</p><p>那么 TypeScript 是怎么做的？答案是加 <code>readonly</code> 关键字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">0</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这样无论是使用删除、修改、新增数组成员的方法都会报错。我们可以将 <code>readonly number[]</code> 和 <code>number[]</code> 视为两个类型。</p><p>为此，TypeScript 设计了泛型 <code>Readonly&lt;T&gt;</code> 和 <code>ReadonlyArray&lt;T&gt;</code>，效果类似。</p><h3 id="3-3-3-多维数组"><a href="#3-3-3-多维数组" class="headerlink" title="3.3.3 多维数组"></a>3.3.3 多维数组</h3><p>和 Java 定义很像，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">multi</span>: <span class="built_in">number</span>[][] = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><blockquote><p>Java 写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] multi = &#123;</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="type">int</span>[][] multi = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-4-TypeScript-元组"><a href="#3-4-TypeScript-元组" class="headerlink" title="3.4 TypeScript 元组"></a>3.4 TypeScript 元组</h2><p>和 Python 的思想一样，允许在一个组内放入不同类型的数据。</p><p>一般情况下，<strong><u>元组的长度是确定的、每个元素的类型必须明确指定</u>，因此越界访问、不按定义的类型来赋值都会报错</strong>。</p><p>其类型定义的方法和数组不一样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];    <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>] = [<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="literal">true</span>];    <span class="comment">// 元组</span></span><br></pre></td></tr></table></figure><p>有时候不能省略类型定义，特别是只有一个元素的时候，因为可能会被编译器误判为数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>];    <span class="comment">// 编译器认为是数组</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">b</span>: [<span class="built_in">number</span>] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><strong>不过 “元组长度是确定的”，而不是 “固定的”</strong>，是因为有 2 个例外：</p><ul><li><p>可选类型修饰符 <code>?</code>（<strong>只能位于元组类型列表尾部</strong>）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>?] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li><li><p>扩展运算符（又称 REST 运算符），表示不限制数量的同类元素，可以不位于类型列表尾部，在一个类型声明中只能使用一次：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]];    <span class="comment">// 注意，这不是数组。数组请用 ...&lt;T&gt;[][]</span></span><br><span class="line"><span class="keyword">type</span> t2 = [<span class="built_in">string</span>, ...<span class="built_in">boolean</span>[], <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> t3 = [...<span class="built_in">boolean</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure></li></ul><p>如果没有使用扩展运算符，那么元组的长度就能确定，<strong>可以使用 <code>length</code> 进行长度推断</strong>：</p><p>如果使用了扩展运算符，<code>length</code> 推断就会被看作数组。</p><h2 id="3-5-TypeScript-函数"><a href="#3-5-TypeScript-函数" class="headerlink" title="3.5 TypeScript 函数"></a>3.5 TypeScript 函数</h2><h3 id="3-5-1-定义与使用"><a href="#3-5-1-定义与使用" class="headerlink" title="3.5.1 定义与使用"></a>3.5.1 定义与使用</h3><p>定义方法和 JavaScript 一样，但是类型声明是有讲究的。</p><p>普通定义方法这么加类型声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">txt: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>赋值函数表达式这么加：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">hello</span>: <span class="function">(<span class="params">txt: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> = <span class="keyword">function</span>(<span class="params">txt</span>) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="keyword">var</span> hello = <span class="keyword">function</span>(<span class="params">txt: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>技巧：想要套用其他函数的签名，就用 <code>typeof</code> 运算符，如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">myAdd</span>: <span class="keyword">typeof</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>箭头函数这么加：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = (<span class="attr">txt</span>: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>由于函数也是一个对象，所以我们可以这么自定义函数的类型（在想要给函数加属性的时候有用）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line">f.<span class="property">version</span> = <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   (参数列表): 返回值</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">add</span>: &#123;</span><br><span class="line">  (<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125; = f;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-可选参数-与-默认值"><a href="#3-5-2-可选参数-与-默认值" class="headerlink" title="3.5.2 可选参数 与 默认值"></a>3.5.2 可选参数 与 默认值</h3><p>TypeScript 在静态类型的同时允许参数可选、默认值（它们肯定不能同时使用）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFunc</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">myFunc = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y === <span class="literal">undefined</span>) &#123;    <span class="comment">// 用到可选参数时请判断</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params">x: <span class="built_in">number</span> = <span class="number">0</span>, y: <span class="built_in">number</span> = <span class="number">0</span></span>): [<span class="built_in">number</span>, <span class="built_in">number</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，传入 <code>undefined</code> 参数就能触发默认值（如果有的话）。</p><h3 id="3-5-3-参数解构-解包"><a href="#3-5-3-参数解构-解包" class="headerlink" title="3.5.3 参数解构 (解包)"></a>3.5.3 参数解构 (解包)</h3><p>JavaScript 原生支持参数解构。在 TypeScript 中则需要声明类型才能使用。</p><p>要解构的参数大多数情况下，要么是对象，要么是数组 / 元组，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[x, y]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">s</span>(<span class="params">&#123; a, b, c &#125;: &#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; c: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法请类比 “对象类型” 一节的解构赋值，也要注意两类语法的区别。</p><h3 id="3-5-4-剩余参数-args"><a href="#3-5-4-剩余参数-args" class="headerlink" title="3.5.4 剩余参数 (args)"></a>3.5.4 剩余参数 (args)</h3><p>使用之前在元组一节提到的 REST 运算符即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rest 参数被包装成数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">joinNumbers</span>(<span class="params">...nums: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest 参数被包装成元组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">...args: [<span class="built_in">boolean</span>, <span class="built_in">number</span>?]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 rest 参数被包装成元组，其中的元素也可以是可选参数。</p><h3 id="3-5-5-只读参数"><a href="#3-5-5-只读参数" class="headerlink" title="3.5.5 只读参数"></a>3.5.5 只读参数</h3><p>和 C++ 的 <code>const</code> 修饰参数一模一样。不多赘述：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arraySum</span>(<span class="params">arr: <span class="keyword">readonly</span> <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-6-函数重载"><a href="#3-5-6-函数重载" class="headerlink" title="3.5.6 函数重载"></a>3.5.6 函数重载</h3><p>TypeScript 因为有类型，所以支持了 JavaScript 所不支持的 重载。</p><p>使用方法很简单，要注意的点和其他静态类型语言一样（避免签名模糊等问题）。</p><p>不过 TypeScript 中，如果能用联合类型避免重载，就用联合类型。</p><h2 id="3-6-TypeScript-的类"><a href="#3-6-TypeScript-的类" class="headerlink" title="3.6 TypeScript 的类"></a>3.6 TypeScript 的类</h2><p>TypeScript 作为真正的静态类型语言，和 JavaScript 相比，最大的差异是引入了真正的开发者可定义的类。</p><h3 id="3-6-1-定义"><a href="#3-6-1-定义" class="headerlink" title="3.6.1 定义"></a>3.6.1 定义</h3><p>下面的示例概括了 TypeScript 类基本的使用方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">string</span> = <span class="string">&quot;abc&quot;</span>;        <span class="comment">// 允许类内初始化</span></span><br><span class="line">    p!: <span class="built_in">number</span>;                <span class="comment">// ！修饰符告诉编译器该类型不为空，可以不在类内、构造函数内初始化</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">q</span>: <span class="built_in">number</span>;        <span class="comment">// 和 Java 的 const 一样，仅允许初始化一次</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类的构造函数名只能是 construtor，允许可选、默认参数</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">_x: <span class="built_in">number</span>, _y: <span class="built_in">number</span>, _q: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="comment">// 类内的 this 对象就和其他面向对象的静态语言一样含义。具体含义见章末</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = _x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = _y;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">q</span> = _q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类中的方法不需要 function 修饰。但方法一定需要定义在类内</span></span><br><span class="line">    <span class="comment">// 如果要定义在类外，就是在初始化为对象后再进行赋值了</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">a</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类中的构造函数、其他方法都允许重载</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">r</span>: <span class="built_in">number</span>, <span class="attr">s</span>: <span class="built_in">number</span>, ...<span class="attr">args</span>: <span class="built_in">number</span>[]): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="attr">init</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span> + r + s + args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, init);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-2-类的可见性修饰符"><a href="#3-6-2-类的可见性修饰符" class="headerlink" title="3.6.2 类的可见性修饰符"></a>3.6.2 类的可见性修饰符</h3><p>TypeScript 的类更像 C++ 的结构体，<strong>不加可见性修饰符，默认 <code>public</code></strong>。</p><p>使用方法同其他面向对象的静态类型语言，略。</p><h3 id="3-6-3-类的访问器"><a href="#3-6-3-类的访问器" class="headerlink" title="3.6.3 类的访问器"></a>3.6.3 类的访问器</h3><p>如果你学过 Python，那么恭喜，TypeScript 的访问器 <code>set</code>、<code>get</code> 可以<strong>完全按照</strong> Python 的装饰器 <code>@setter</code>、<code>@getter</code> 理解。</p><p>定义方法如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> _name!: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问器前加入 get / set 关键字</span></span><br><span class="line">    <span class="comment">// 访问器的名字必须与要定义的属性名相同</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="title class_">String</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外访问，直接当作普通属性使用，但会调用 get 实时计算</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">test</span>: T = <span class="keyword">new</span> T;</span><br><span class="line">test.<span class="property">name</span> = <span class="string">&quot;Hello&quot;</span>;    <span class="comment">// 调用了 set 访问器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">name</span>);    <span class="comment">// 调用了 get 访问器</span></span><br></pre></td></tr></table></figure><p>根据它们的用途，可以很显然地知道：</p><ul><li><code>get</code> 访问器不能有参数；</li><li>如果一个属性不存在 <code>set</code> 访问器，那么这个参数只读，等价于被 <code>readonly</code> 修饰；</li></ul><h3 id="3-6-4-类的静态成员"><a href="#3-6-4-类的静态成员" class="headerlink" title="3.6.4 类的静态成员"></a>3.6.4 类的静态成员</h3><p>和 Java、C++ 一样，使用 <code>static</code> 关键字修饰静态变量。</p><p>但是！和其他语言不太一样，TypeScript 的静态成员（属性和方法）不能由实例调用，只能由类名调用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">printX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">t</span>: <span class="title class_">MyClass</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>;</span><br><span class="line">t.<span class="title function_">printX</span>();    <span class="comment">// TypeError</span></span><br><span class="line">t.<span class="property">x</span>;        <span class="comment">// TypeError</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">printX</span>();    <span class="comment">// Correct</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">x</span>;            <span class="comment">// Correct</span></span><br></pre></td></tr></table></figure><h3 id="3-6-5-类的继承"><a href="#3-6-5-类的继承" class="headerlink" title="3.6.5 类的继承"></a>3.6.5 类的继承</h3><p>和 Java 一样，TypeScript 使用 <code>extend</code> 关键字进行类的继承。</p><p>还是和 Java 一样，TypeScript 也有 <code>super</code> 关键字，可以 <strong>用来调用父类构造函数、调用父类中已被重写的方法等等</strong>。</p><p>类继承时，不同可见性修饰符下对应数据域的继承原则与 Java、C++ 类似，但是有差别：</p><ul><li><p>父类 protected 的数据成员，子类 <strong>可以转为 public，但不能转为 private</strong>；</p></li><li><p>子类可以定义与父类同名不同类型的属性，但是如果希望它们的赋值关联，则需要 <code>declare</code> 关键字修饰；</p></li></ul><h3 id="3-6-6-抽象类"><a href="#3-6-6-抽象类" class="headerlink" title="3.6.6 抽象类"></a>3.6.6 抽象类</h3><p>和 C++ / Java 一样，TypeScript 中的抽象类关键字也是 <code>abstract</code>、也不允许实例化、不允许 <code>private</code> 修饰、抽象成员不允许有实现。</p><p>同时，TypeScript 允许使用 <code>abstract</code> 修饰抽象类的<strong>数据成员（Java 和 C++ 做不到）</strong>、成员函数，强制要求子类（非抽象类）实现。</p><p>值得注意的是，<strong>一个类最多只能继承于一个抽象类（再多就应该用接口 interface 了）</strong>。</p><h3 id="3-6-7-FAQ-类中的-this-在-TypeScript-里究竟是什么"><a href="#3-6-7-FAQ-类中的-this-在-TypeScript-里究竟是什么" class="headerlink" title="3.6.7 FAQ: 类中的 this 在 TypeScript 里究竟是什么"></a>3.6.7 FAQ: 类中的 <code>this</code> 在 TypeScript 里究竟是什么</h3><p>我们知道，在 JavaScript 中，<code>this</code> 含义丰富：</p><ul><li><p>在方法中，this 表示该方法所属的对象；</p></li><li><p>如果单独使用，this 表示全局对象；</p></li><li><p>在函数中，this 表示全局对象（严格模式下为 <code>undefined</code>）；</p></li></ul><p>那么在 TypeScript 的类中，含义就和其他面向对象语言类似，是指 “该方法所在类的当前对象”。</p><p>实际上，这里还有几个问题没有解决：</p><ol><li>在 JavaScript 中允许定义一个原型，充当面向对象编程的工具。它允许将一个对象的方法赋给另一个变量，<strong>赋予后，<code>this</code> 将跟随新的变量脱离原来的作用域</strong>。在 TypeScript 中，这种行为是怎样的？</li><li>如果在 JavaScript 的原型中使用闭包/箭头函数，那么在其中的 <code>this</code> 将不再指代当前对象，除非手动传递 <code>this</code> 的值。在 TypeScript 中的行为是怎样的？</li></ol><p>针对第一个问题，TypeScript 为了防止改变函数语义（本来的 <code>this</code> 是类中对象，如果将函数赋给其他变量后 <code>this</code> 就成为了新变量作用域中的 <code>this</code>），<strong>允许类中方法第一参数声明 <code>this</code> 类型（就像 Python 的 <code>self</code>）</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> tt = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">test</span>(<span class="attr">this</span>: <span class="title class_">Test</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">tt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论在哪里，只要 typescript 检测到第一个参数是 this，就会自动将当前环境 this 填充进去，并且不会在 JavaScript 中展现出来。</p></blockquote><p>这样，如果赋给其他变量后，一旦涉及改变了 <code>this</code> 的函数调用，编译器会指出错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="title class_">Test</span>.<span class="property">test</span>;</span><br><span class="line"></span><br><span class="line">b.();    <span class="comment">// TypeError, 因为此时的 this 是全局对象</span></span><br></pre></td></tr></table></figure><blockquote><p>该参数可以省略（但省略后会回到 JavaScript 的行为）。</p></blockquote><p>当然，你可以在构造函数中，使用 JavaScript 原生方法 <code>bind</code> 将方法与类的 <code>this</code> 环境绑定，这样无论怎么赋值，都是那个对象对应的方法了 —— 这也是最稳妥的做法。</p><p>对第二个问题，TypeScript 也需要担心语义问题，因此如果你打开了 <code>noImplicitThis</code> 编译选项，那么 TypeScript 编译器会直接报错。否则其行为和 JavaScript 一致。</p><hr><p>最后补充一个 TypeScript 的小特性：</p><p>TypeScript 中的类能作为类型使用，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="attr">value</span>: <span class="built_in">string</span>): <span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-TypeScript-的接口"><a href="#3-7-TypeScript-的接口" class="headerlink" title="3.7 TypeScript 的接口"></a>3.7 TypeScript 的接口</h2><h3 id="3-7-1-定义和使用"><a href="#3-7-1-定义和使用" class="headerlink" title="3.7.1 定义和使用"></a>3.7.1 定义和使用</h3><p>TypeScript 的接口和 Java 非常类似：接口和抽象类一样抽象，<strong>方法全是抽象方法（不能有实现）</strong>、可省略所有的 <code>abstract</code> 关键字。但是属性不是常量属性（只读）而是抽象属性（不允许赋值），因为在 TypeScript 中 <code>abstract</code> 可以修饰数据成员。</p><p>如下由于接口算是个抽象类，因此接口间可以继承，和 Java 的接口继承一样，要注意冲突问题。</p><p>此外，接口还可以继承于 <code>type</code>（类型别名，它和接口的区别是什么？接下来再讨论）。</p><p>甚至接口还能继承于普通的 <code>class</code>。此时 <code>class</code> 中所有的属性、方法全部保持类型，变成对应的抽象属性、抽象方法。<strong>这里我们可以知道，被接口继承的类不能有 <code>private</code>/<code>protected</code> 修饰的成员，因为这样会导致 “无法实现的抽象成员” 的出现</strong>。</p><h3 id="3-7-2-接口合并"><a href="#3-7-2-接口合并" class="headerlink" title="3.7.2 接口合并"></a>3.7.2 接口合并</h3><p>这只是个特性，并不希望你为了使用它而使用，只是在必须的时候才使用。因为这样会降低你的代码可读性。</p><ul><li><p>情况 1：如果你重复定义了接口，那么这两次定义的内容会合并：</p><ul><li>同名函数 -&gt; 重载，同名属性 -&gt; 联合类型，不同名的直接并列；</li><li><strong>如果有不能联合/重载的部分</strong>，编译器会抛出错误；</li></ul></li><li><p>情况 2：如果你对某几个不同名的接口使用了类型联合运算符，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">s</span>: <span class="title class_">Inter1</span> | <span class="title class_">Inter2</span>;</span><br></pre></td></tr></table></figure><p>这就相当于显示将不同名的接口合并为一个接口 <code>s</code>，合并规则和同名接口合并相同；</p></li></ul><h3 id="3-7-3-接口-Interface-和类型别名-type-的异同"><a href="#3-7-3-接口-Interface-和类型别名-type-的异同" class="headerlink" title="3.7.3 接口 (Interface) 和类型别名 (type) 的异同"></a>3.7.3 接口 (Interface) 和类型别名 (type) 的异同</h3><p>相同点：都能创建一个类型、定义方式极其类似。</p><p>不同点：</p><ul><li><code>type</code> 可以定义非对象类型，而 <code>interface</code> 只能定义对象类型；</li><li><p><code>interface</code> <strong>可以继承、合并</strong>，而 <code>type</code> 不行，重复定义同名 <code>type</code> 会报错；</p></li><li><p><code>type</code> 内部不能使用 <code>this</code> 指代当前对象，<code>interface</code> 则可以；</p></li></ul><p>总结：除去一些复杂的类型运算，其他情况优先使用 <code>interface</code>；</p><h2 id="3-8-TypeScript-的泛型"><a href="#3-8-TypeScript-的泛型" class="headerlink" title="3.8 TypeScript 的泛型"></a>3.8 TypeScript 的泛型</h2><p>TypeScript 的泛型定义、使用方法与 Java 相同，可以用在类、函数、接口、类型别名、对象上，并且<strong>可以指定默认类型</strong>，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;<span class="title class_">NumType</span> = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  value!: <span class="title class_">NumType</span>;</span><br><span class="line">  add!: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> <span class="title class_">NumType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"></span><br><span class="line">foo.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">foo.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TypeScript 中，<strong>泛型的另一种常用方式是：作为类型参数的约束条件</strong>。</p><p>如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> comp&lt;T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: T) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样约束了 <strong>传入的类型必须是具有 <code>length: number</code> 字段的对象</strong>，减少了代码犯错的概率。</p><p>我们可以总结为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">TypeParam</span> <span class="keyword">extends</span> <span class="title class_">ConstraintType</span>&gt;</span><br></pre></td></tr></table></figure><p>表示类型参数必须是 <code>ConstraintType</code> 的子类型。</p><p>不过为了代码可读性，还是提出以下建议：</p><ul><li>尽量少用泛型：降低了代码可读性；</li><li>泛型的类型参数越少越好；</li></ul><h2 id="3-9-TypeScript-Enum-类型"><a href="#3-9-TypeScript-Enum-类型" class="headerlink" title="3.9 TypeScript Enum 类型"></a>3.9 TypeScript Enum 类型</h2><h3 id="3-9-1-定义与使用"><a href="#3-9-1-定义与使用" class="headerlink" title="3.9.1 定义与使用"></a>3.9.1 定义与使用</h3><p>和其他大多数静态语言一样，TypeScript 也有枚举类型。它的枚举类型更像 C++ 11 的 <code>enum Class</code>，定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title class_">Red</span>,</span><br><span class="line">    <span class="title class_">Green</span>,</span><br><span class="line">    <span class="title class_">Blue</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>值从 0 递增，但值不重要；</li><li>是个类型也是值（变量不能和枚举类型同名），因此可以 <code>Color.Red</code> 这样调用，增强代码可读性；</li><li>枚举值只读，可以是自身类型（<code>Color</code>）也可以是 <code>number</code>（因此枚举类型做参数时，传入一切 <code>number</code> 都不报错）；</li></ul><p>通常建议枚举类型前加 <code>const</code> 修饰，这样可以帮助编译器优化代码，提升性能：<code>const enum</code>；</p><h3 id="3-9-2-特性"><a href="#3-9-2-特性" class="headerlink" title="3.9.2 特性"></a>3.9.2 特性</h3><ul><li><p>同名枚举类型会像同名接口的行为一样合并；</p></li><li><p>允许字符串做枚举类型的值，要设置，则全员都设置，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">MediaTypes</span> &#123;</span><br><span class="line">    <span class="title class_">JSON</span> = <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="variable constant_">XML</span> = <span class="string">&quot;application/xml&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="title class_">Accept</span>: <span class="title class_">MediaTypes</span>.<span class="property">JSON</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>字符串枚举可以由联合类型代表：<code>function move(where: &quot;Up&quot; | &quot;Down&quot; | &quot;Left&quot; | &quot;Right&quot;);</code></p></li><li><p>在 C++ 的枚举类型中，有很多人抱怨不方便通过枚举值打印出枚举成员的字符串名。在 TypeScript 中就有方法：<strong>反向映射</strong>，我们调用 <code>EnumClass[n]</code> 就能得到索引为 <code>n</code> 的枚举成员的字符串名。</p><blockquote><p>这与 TypeScript 编译器将 <code>enum</code> 翻译成 JavaScript 的方式有关：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="title class_">Apple</span>,</span><br><span class="line"> <span class="title class_">Banana</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Test</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Test</span>) &#123;</span><br><span class="line"> <span class="comment">// 相当于两句赋值：Test[&quot;Apple&quot;] = 0, Test[0] = &quot;Apple&quot;;</span></span><br><span class="line"> <span class="title class_">Test</span>[<span class="title class_">Test</span>[<span class="string">&quot;Apple&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"> <span class="title class_">Test</span>[<span class="title class_">Test</span>[<span class="string">&quot;Banana&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Test</span> || <span class="title class_">Test</span> = &#123;&#125;);</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="3-9-3-keyof-关键字与枚举类型"><a href="#3-9-3-keyof-关键字与枚举类型" class="headerlink" title="3.9.3 keyof 关键字与枚举类型"></a>3.9.3 <code>keyof</code> 关键字与枚举类型</h3><p>在 TypeScript 中，<code>keyof</code> 关键字有点类似 Python 的 <code>__dict__</code> 属性，<strong>针对对象 / 类，返回对应类型的所有属性、方法名</strong>，不过 TypeScript 的返回是 “<strong>属性/方法名字符串组成的联合类型</strong>”（就是个字符串枚举类型！），而 Python 返回的是对象数组。</p><p>还有一点值得注意，TypeScript 枚举类型想要使用 <code>keyof</code> 获取成员名字符串联合类型，必须加 <code>typeof</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  B = <span class="string">&quot;b&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;A&#x27;|&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="keyword">typeof</span> <span class="title class_">MyEnum</span>;</span><br></pre></td></tr></table></figure><p>否则会被编译器当作 <code>number</code> 类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot; |</span></span><br><span class="line"><span class="comment">// &quot;toPrecision&quot; | &quot;valueOf&quot; | &quot;toLocaleString&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="title class_">MyEnum</span>;</span><br></pre></td></tr></table></figure><h2 id="3-10-TypeScript-的类型断言"><a href="#3-10-TypeScript-的类型断言" class="headerlink" title="3.10 TypeScript 的类型断言"></a>3.10 TypeScript 的类型断言</h2><p>类型断言的存在，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型（而不是改变这个值的类型）。<u>TypeScript 一旦发现存在类型断言，<strong>并且 原类型 兼容 断言的类型</strong>，就不再对该值进行类型推断，而是直接采用断言给出的类型</u>。</p><blockquote><p>再次强调：<strong>断言的前提是 原类型 兼容 断言的类型</strong>！</p></blockquote><p>由于 TypeScript 新版本支持了 React 的 JSX 语法，因此如果你要使用 JSX，则不能用旧语法（<code>&lt;assertType&gt;value</code>，这里的尖括号是真的尖括号），应该使用新语法：<code>value as assertType</code>；</p><p>那么你可能会问，TypeScript 编译器的类型推断不是已经足够了吗？虽然它增强了语言灵活性，但让人来控制类型推断不会导致出错可能性增加？</p><p><strong>确实！它不能乱用，否则会出大问题。</strong></p><p>但是只要在适当的场合使用就能发挥它的优势。以下是常用场景：</p><h3 id="3-10-1-代替明确的类型缩窄"><a href="#3-10-1-代替明确的类型缩窄" class="headerlink" title="3.10.1 代替明确的类型缩窄"></a>3.10.1 代替明确的类型缩窄</h3><p>早在 3.2.5 节中就提到，对于一些联合类型，我们必须使用类型缩窄，才能使用某个特定类型的方法，以此避免运行时的类型错误，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>): <span class="built_in">string</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 可能返回 null，也可能返回 string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">test</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="title function_">doSomething</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型缩窄</span></span><br><span class="line"><span class="keyword">if</span> (test !== <span class="literal">null</span>)</span><br><span class="line">    test.<span class="title function_">toUpperCase</span>();</span><br></pre></td></tr></table></figure><p>现在，假设 <strong>我们根据代码逻辑，<u>明确知道</u> <code>test</code> 肯定不会为 <code>null</code>，但是编译器不知道</strong>，还以为可能是 <code>null</code>。</p><p>这个时候我们可以明确告诉编译器，它不可能为 <code>null</code>，于是这么用就无需使用类型缩窄了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">test</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="title function_">doSomething</span>();</span><br><span class="line"></span><br><span class="line">(test <span class="keyword">as</span> <span class="built_in">string</span>).<span class="title function_">toUpperCase</span>();</span><br></pre></td></tr></table></figure><h3 id="3-10-2-直接量的常量断言"><a href="#3-10-2-直接量的常量断言" class="headerlink" title="3.10.2 直接量的常量断言"></a>3.10.2 直接量的常量断言</h3><h4 id="基本类型直接量"><a href="#基本类型直接量" class="headerlink" title="基本类型直接量"></a>基本类型直接量</h4><p>我们知道，TypeScript 的常量是不能被改变的量，那么常量声明语法 <code>as const</code> 就可以<strong>将基本类型直接量变为对应的值类型</strong>，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;TypeScript&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>这样在编译时，TypeScript 编译器会将 <code>s</code> 看作 <code>&quot;TypeScript&quot;</code> 值类型。这样有什么用呢？<strong>对 直接量 的常量断言，是<u>看作对应的值类型</u></strong>。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;JavaScript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lang</span> = <span class="string">&quot;JavaScript&quot;</span> | <span class="string">&quot;TypeScript&quot;</span> | <span class="string">&quot;Python&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setLang</span>(<span class="params">language: Lang</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setLang</span>(s); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>这里 <code>Lang</code> 类型是等价于枚举类型，如果传入普通字符串，即便值和枚举量一致，但编译器没法保证类型正确性。</p><p>所以我们可以这么做：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;JavaScript&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>这样编译器会将 <code>s</code> 看作 <code>&quot;JavaScript&quot;</code> 值类型，保证以后也不会更改，因此修复了这个问题。当然也与直接用 <code>const</code> 等价：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&quot;JavaScript&quot;</span>;</span><br></pre></td></tr></table></figure><p>不过值得注意的是：<strong>常量断言不能用于 已被赋值（定义）的变量！</strong>因为 TypeScript 不允许中途更改变量的读写性质。</p><h4 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h4><p>如果将 <code>as const</code> 类型断言修饰对象，那么和修饰基本类型直接量的行为就有些不同了。</p><p><u><strong>也就是说，这个时候 <code>const</code> 修饰符和 <code>as const</code> 断言就有区别了！</strong></u></p><ul><li><code>const</code> 修饰对象直接量时，只是不允许更改对象引用，但其中数据可更改（因为是可变数据类型）；</li><li><code>as const</code> 断言对象直接量时，<strong>其中所有数据域 / 成员都改为只读属性</strong>。</li></ul><p>例如：</p><ul><li><p>数组 / 元组直接量 -&gt; <u><strong>只读元组</strong></u>（同时确定了长度、类型 和值）；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a1 的类型推断为 number[]</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a2 的类型推断为 readonly [1, 2, 3] （元组）</span></span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure></li><li><p>对象直接量 -&gt; 数据域全部只读；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: number; y: number; &#125;，普通对象常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: 1; y: number; &#125;，数据域直接量常量断言 的 对象常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v3 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 类型是 &#123; readonly x: 1; readonly y: 2; &#125;，常量断言 的 对象常量</span></span><br></pre></td></tr></table></figure></li></ul><p>那么这样做有什么用？举个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">nums</span>: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">add</span>(...nums);        <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>如果我想<strong>将已知长度的数组解构传给函数</strong>，但 <code>const</code> 修饰，甚至是 <code>readonly</code> 修饰，也并不能说明这是个定长度为 2、定内容的数组，只能说明这个数组对象引用不会变，所以编译器认为不行。</p><p>这个时候使用 <code>as const</code> 断言就能提示编译器这个数组是<strong>只读元组</strong>，并且长度为 2，每个位置上的类型都是值类型，能作为参数传递而不出问题。</p><h3 id="3-10-3-非空断言"><a href="#3-10-3-非空断言" class="headerlink" title="3.10.3 非空断言"></a>3.10.3 非空断言</h3><p>和 “明确缩窄类型” 的作用很像，但非空断言只针对 “空类型的类型缩窄”。就是根据代码逻辑，明确知道某些对象的类型不可能为 <code>null / undefined</code>，<strong>在节省不必要的判断的同时，让编译器不报错</strong>。</p><p>但请注意！<strong>一定要确定 “肯定非空” 的逻辑！</strong>否则会出现运行时问题。</p><p><strong>如果不能确保，就请通过手动检查来缩窄类型！</strong></p><p>使用非空断言的语法就是前面提到的：尾缀非空断言运算符 <code>!</code>；</p><p>举个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)!;</span><br></pre></td></tr></table></figure><p>表示 <code>document</code> 中肯定有 ID 为 <code>root</code> 的元素，不用考虑空的情况了。</p><p>还有种场景是在之前提到过的，如果类中有些属性要在类外、构造函数外初始化，需要给该属性加非空断言，不然编译器认为没有初始化实例属性（如果你的属性定义没有 <code>null</code> 类型的话）而报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>; <span class="comment">// TypeError</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Empty</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x!: <span class="built_in">number</span>; <span class="comment">// Correct</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Empty</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-4-类型断言函数"><a href="#3-10-4-类型断言函数" class="headerlink" title="3.10.4 类型断言函数"></a>3.10.4 类型断言函数</h3><p>一类函数，如果它的作用是：“保证参数符合某种类型，不符合就抛出错误，符合就什么都不做”，那么就将这类函数称为 “类型断言函数”。</p><p>由于断言函数要么不返回（<code>void</code>），要么抛出错误（<code>never</code>），因此为了断言函数的语义清晰性，TypeScript 3.7 引入了断言函数声明写法，以判断字符串类型为例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value: <span class="built_in">unknown</span></span>): asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;string&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Not a string&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果断言函数返回结果（不符合断言函数标准的行为），也会报错。</p><p>如果是判断真值（不为 <code>false</code>、<code>undefined</code>、<code>null</code>）的话，断言函数还能更简单地书写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">condition: <span class="built_in">unknown</span>, message: <span class="built_in">string</span></span>): asserts condition &#123;</span><br><span class="line">    <span class="keyword">if</span> (!condition) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样这个函数就和 Python 的 <code>assert</code> 关键字行为类似了。</p><hr><p>补充：TypeScript 的 <code>is</code> 关键字</p><p>TypeScript 中，<code>is</code> 除了充当类型断言函数的尾缀关系，还能作为<strong>类型判断函数（用于判断参数类型，返回值一定为 <code>boolean</code> 类型）</strong>的尾缀关系，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">pet: Fish | Bird</span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但 <code>is</code> 关键字也<strong>仅限于</strong>这两类判断函数的尾缀，以此更清晰地表示这类函数的逻辑。</p><h1 id="Chapter-4-TypeScript-模块与命名空间"><a href="#Chapter-4-TypeScript-模块与命名空间" class="headerlink" title="Chapter 4. TypeScript 模块与命名空间"></a>Chapter 4. TypeScript 模块与命名空间</h1><h2 id="4-1-模块"><a href="#4-1-模块" class="headerlink" title="4.1 模块"></a>4.1 模块</h2><h3 id="4-1-1-定义"><a href="#4-1-1-定义" class="headerlink" title="4.1.1 定义"></a>4.1.1 定义</h3><p>TypeScript 文件有 2 类：</p><ul><li>一种是全局的脚本文件。<strong>类似 <code>shell</code> 脚本，其中的变量、函数等等内容可以直接被其他接下来调用的所有文件访问到</strong>；</li><li>另一种是 TypeScript 模块。模块内部的变量、函数、类只在内部可见，对于模块外部是不可见的，这就相当于 C++ 这类语言的普通文件。</li></ul><p>Q: 这两种文件如何区分？</p><p>A: <strong>任何包含 import 或 export 语句的文件，就是一个模块（module）。相应地，如果文件不包含 export 语句，就是一个全局的脚本文件。</strong></p><p>Q: 既然模块对外部具有封装性，那么它们间如何相互调用？</p><p>A: 答案很简单，模块暴露给外部的接口，必须用 <code>export</code> 命令声明；如果其他文件要使用模块的接口，必须用 <code>import</code> 命令来输入。</p><h3 id="4-1-2-特性"><a href="#4-1-2-特性" class="headerlink" title="4.1.2 特性"></a>4.1.2 特性</h3><ul><li><code>export &#123;&#125;;</code> 语句不会进行任何操作，但是这个文件的内部变量对外不再可见；</li><li>TypeScript 允许导入导出 <code>type</code>（类型别名），需要 <code>export type &lt;typename&gt;</code>；</li><li>TypeScript 也允许 <strong>默认导出、命名导出</strong>，用法和 JavaScript 类似；<ul><li><strong>但是导入类型别名时，需要加 <code>type</code> 关键字前缀</strong>；</li><li>导入接口、类时，和 JavaScript 普通对象的导入方法相同；</li></ul></li></ul><h3 id="4-1-3-CommonJS-模块支持"><a href="#4-1-3-CommonJS-模块支持" class="headerlink" title="4.1.3 CommonJS 模块支持"></a>4.1.3 CommonJS 模块支持</h3><p>众所周知，NodeJS 有专门的模块格式，与 ECMAScript 原生脚本不兼容。但是 TypeScript 兼容了 CommonJS 模块的导入：</p><ul><li><code>import &lt;name&gt; = require(&quot;&lt;moduleName&gt;&quot;);</code></li><li><code>export = &lt;exportObj&gt;</code>；</li></ul><h3 id="4-1-4-编译时模块定位-Module-Resolution"><a href="#4-1-4-编译时模块定位-Module-Resolution" class="headerlink" title="4.1.4 编译时模块定位 (Module Resolution)"></a>4.1.4 编译时模块定位 (Module Resolution)</h3><p>几乎所有要编译的语言，其源文件的编译都要考虑一个问题：如何组织模块间相互位置关系、如何找模块 / 库的位置。</p><p>C++ 中，要么你把源文件全部放在固定目录中，然后用相对路径手动引用。<strong>缺点是一改文件位置就要重写，非常麻烦</strong>；另一种方法是 使用 CMake/Makefile 之类的项目管理工具指定编译操作的过程。</p><p>在 TypeScript 中，也有两种方法。</p><h4 id="引用时手动指定模块路径"><a href="#引用时手动指定模块路径" class="headerlink" title="引用时手动指定模块路径"></a>引用时手动指定模块路径</h4><p>我们在引用模块时可能会这么写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TypeA</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;    <span class="comment">// 省略后缀名，则可查找 *.ts / *.d.ts / *.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;/mod&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br></pre></td></tr></table></figure><p>前两种利用相对路径指定模块位置的方法是 <strong>相对模块表示法</strong>；</p><p>后两种不带有路径信息地指定模块地方法是 <strong>非相对模块表示法</strong>。</p><p>那么 TypeScript 如何查找以上手动指定的模块？由于 NodeJS 引入的 CommonJS 模块，因此有两种查找方式：一种称为 Classic 方法，另一种称为 Node 方法。可以使用编译参数 <code>moduleResolution</code>，指定使用哪一种方法。</p><p>对于 Classic 方法（原生 JavaScript、TypeScript 默认的方法），步骤就非常简单：</p><ul><li><p>对于相对模块表示法，<strong>按照当前模块的位置为基准路径计算相对路径</strong>；</p><blockquote><p>例如 <code>import &#123; t &#125; from &quot;../t&quot;</code> 就从当前脚本，找上个目录里的 <code>t.ts</code>；</p></blockquote></li><li><p>对于非相对模块表示法，<strong>会以当前模块位置为起点，层层向上查找目录</strong>；</p></li></ul><p>对于 Node 方法就有些复杂：</p><ul><li>对于相对模块表示法，例如 <code>let x = require(&quot;./b&quot;)</code>，会进行以下查找步骤：<ol><li>找当前目录的 <code>b.ts</code>、<code>b.tsx</code>、<code>b.d.ts</code>；</li><li>找当前目录的子目录是否有 <code>package.json</code>，这个文件中有无 <code>types</code> 字段，如果有则递归查找；</li><li>找当前目录的 名为 <code>b</code> 的子目录是否包括 <code>index.ts/.tsx/.d.ts</code>；</li></ol></li><li>对于非相对模块表示法，例如 <code>let x = require(&quot;b&quot;)</code>，会进行以下查找步骤：<ol><li>子目录 <code>node_modules</code> 是否包含 <code>b.ts/.tsx/.d.ts</code>；</li><li>子目录 <code>node_modules</code> 中是否存在 <code>package.json</code>，是否有 <code>types</code> 字段，如果有则递归查找；</li><li>子目录 <code>node_modules</code> 中是否存在子目录 <code>@types</code>，如有，则查找其中的 <code>b.d.ts</code>；</li><li>子目录 <code>node_modules</code> 中是否存在子目录 <code>b</code>，其中是否包括  <code>index.ts/.tsx/.d.ts</code>；</li><li>进入上层目录，充分上述步骤，直至找到。</li></ol></li></ul><h4 id="tsconfig-json-配置模块路径"><a href="#tsconfig-json-配置模块路径" class="headerlink" title="tsconfig.json 配置模块路径"></a><code>tsconfig.json</code> 配置模块路径</h4><p>TypeScript 允许开发者在<code>tsconfig.json</code>文件里面，手动指定脚本模块的路径，这样做在一些大型的、依赖关系复杂的项目中就比较方便。</p><p>有如下配置字段可以设置编译器的查找过程：</p><ul><li><p><code>compilerOptions.baseUrl</code>：指定脚本模块的基准目录（<u>该项目的所有源文件的基准位置都被设置在此</u>）。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>表示将 <code>tsconfig.json</code> 所在的目录为基准目录；</p></li><li><p><code>compilerOptions.paths</code>：<strong>指定<u>非相对路径表示法的模块与实际路径的映射</u></strong>。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;jquery&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;node_modules/jquery/dist/jquery&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>上例的 <code>jquery</code> 属性的值是一个数组，可以指定多个路径。如果第一个脚本路径不存在，那么就加载第二个路径，以此类推。</p></li><li><p><code>compilerOptions.rootDirs</code>：<strong>指定无论查找什么模块，必须要额外查找的其他目录</strong>。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rootDirs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/zh&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/de&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/#&#123;locale&#125;&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>此外，如果你发现自己指定了一些路径，编译器就是找不到。那么你可以使用 <code>--traceResolution</code> 编译器选项，让编译器在命令行中打印搜索的路径，相当于一种调试。</p><h2 id="4-2-命名空间"><a href="#4-2-命名空间" class="headerlink" title="4.2 命名空间"></a>4.2 命名空间</h2><p>评价是和 C++ 的 <code>namespace</code> 很类似。使用也很像：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  <span class="title function_">isString</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Utils</span>.<span class="title function_">isString</span>(<span class="string">&quot;no&quot;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>哪怕在一个文件中，也必须 <code>export</code> 才能被外部使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="title class_">Utility</span>.<span class="title function_">log</span>(<span class="string">&quot;Call me&quot;</span>);</span><br><span class="line"><span class="title class_">Utility</span>.<span class="title function_">error</span>(<span class="string">&quot;maybe!&quot;</span>);</span><br></pre></td></tr></table></figure><p>命名空间本身能被 <code>export</code>、也允许合并（行为类似 interface）；</p><h1 id="Chapter-5-TypeScript-装饰器"><a href="#Chapter-5-TypeScript-装饰器" class="headerlink" title="Chapter 5. TypeScript 装饰器"></a>Chapter 5. TypeScript 装饰器</h1><blockquote><p>TypeScript 曾有旧式语法，这里不再作介绍。本章只介绍 TypeScript 5.0 以后的新式装饰器。</p><p>如果你想使用旧式语法，请向编译器传递 <code>--experimentalDecorators</code> 参数。</p></blockquote><h2 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h2><p>TypeScript 的装饰器的定义 和 Python 的装饰器的定义一致，和 Java 的装饰器类似。或者说，“装饰器” 的概念是跨语言的、抽象概念。主要内容是：</p><ul><li>前缀是 <code>@</code>，后面必须是一种特殊表达式。这个表达式要求：<strong>要么就是个函数名，要么表达式执行后返回一个函数</strong>；</li><li>这个通过后面表达式所得到的函数称为<u><strong>装饰器函数</strong></u>。装饰器函数可以接受所修饰对象的一些相关值作为参数，<strong>并且要么不返回值（装饰过程），要么返回新对象用来替换原来的目标对象（装饰对象）</strong>。</li></ul><p>装饰器的作用是，<u><strong>通过类似 “外部注入” 的方式，改变被装饰对象的行为</strong></u>。</p><p>比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样使用类 <code>A</code> 的时候，其行为就会被装饰器 <code>Injectable</code> 所改变。</p><h2 id="5-2-源码定义"><a href="#5-2-源码定义" class="headerlink" title="5.2 源码定义"></a>5.2 源码定义</h2><p>我们从概念中可知，要了解 TypeScript 装饰器怎么用、机制是什么，最主要看装饰器函数。它在 TypeScript 中的定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Decorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="built_in">string</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer?(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      get?(): <span class="built_in">unknown</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">      set?(value: <span class="built_in">unknown</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span> | <span class="title class_">ReplacementValue</span>;</span><br></pre></td></tr></table></figure><p>可以看到，<code>Decorator</code> 是一个函数类型，它接收两个参数：</p><ul><li><p><code>value</code>：<strong>所装饰的对象</strong>，在使用 <code>@Decorator</code> 时，相当于语法糖，<strong>自动将修饰对象传递到此参数</strong>；</p></li><li><p><code>context</code>：上下文对象，看起来有很多内容，实际上是为了适应多种装饰器的类别而定义的（很多可选参数，只需要记住几种常用的装饰器类别就行）；</p><blockquote><p>在 TypeScript 中，定义了一个原生接口 <code>ClassXXXDecoratorContext</code>，描述的就是 <code>typeof Decorator.context</code>；</p></blockquote><ul><li><code>kind</code>：装饰器类别，<strong>只有 6 种，分别对应了 6 种装饰器</strong>：<code>&quot;class&quot;</code>（类装饰器）、<code>&quot;method&quot;</code>（方法装饰器）、<code>&quot;getter&quot;</code>（读装饰器）、<code>&quot;setter&quot;</code>（写装饰器）、<code>&quot;field&quot;</code>（属性装饰器）、<code>&quot;accessor&quot;</code>（访问装饰器）；</li><li><code>name</code>：所装饰对象的名称（例如类名、函数名、属性名等等）；</li><li><code>addInitializer()</code>：<strong>添加被修饰对象初始化后的逻辑</strong>；</li><li><code>private</code>：<strong>所装饰对象是不是一个类的私有成员</strong>；</li><li><code>static</code>：<strong>所装饰对象是不是一个类的静态成员</strong>；</li><li><code>access</code>：<strong>包含所修饰对象的访问器 <code>get</code> 和 <code>set</code></strong>；</li></ul></li></ul><h3 id="5-2-1-类装饰器"><a href="#5-2-1-类装饰器" class="headerlink" title="5.2.1 类装饰器"></a>5.2.1 类装饰器</h3><p>类装饰器是 <code>context.kind</code> 字段为 <code>&quot;class&quot;</code> 的装饰器，<strong>用来装饰 TypeScript 类</strong>。</p><p><u><strong>它只需定义装饰器 <code>context</code> 可选成员的 <code>addInitializer()</code></strong></u>，用在类上就是 <strong>类完全定义后、构造函数前执行的 <code>initializer</code> 函数</strong>。</p><p>如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;class&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>常见的使用场景有：</p><ol><li><p>向类中添加一个外部方法；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&quot;class&quot;</span>) &#123;</span><br><span class="line">        value.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Greeter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">u.<span class="title function_">greet</span>();    <span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure><p><strong>作用原理是，向传入其中的类调用 <code>prototype</code> 获取类的原型，添加方法 <code>greet</code></strong>；</p></li><li><p>替换被修饰类的构造函数（例如添加一些 side effects）/ 直接替换被修饰的类；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params">value: <span class="built_in">any</span>, context: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> wrapper = <span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    instanceCount++;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">value</span>(...args);</span><br><span class="line">    instance.<span class="property">count</span> = instanceCount;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">MyClass</span>;</span><br><span class="line"></span><br><span class="line">  wrapper.<span class="property"><span class="keyword">prototype</span></span> = value.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// A</span></span><br><span class="line">  <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@countInstances</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">inst1 <span class="keyword">instanceof</span> <span class="title class_">MyClass</span>; <span class="comment">// true</span></span><br><span class="line">inst1.<span class="property">count</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>解释一下，因为 JavaScript 和 TypeScript 中的类型 <code>class</code>，只要<strong>是个构造函数就能用 <code>class</code> 声明</strong>。借助这个特性，我们能更换被修饰类的构造函数。</p><p>在装饰器内定义一个闭包（新的构造函数，<code>new</code> 调用了原来构造函数），最后将函数的 <code>prototype</code> 属性统一，再返回就是新的构造函数了。</p><p>这个时候，返回的构造函数就替换了原来的构造函数（也就是替换了类）。按这种思想，<strong>如果你不想用 <code>prototype</code> 这种原生 JavaScript 的内容，你还可以直接返回一个临时子类，来实现同样效果</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params">value: <span class="built_in">any</span>, context: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> value &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(...args);</span><br><span class="line">      instanceCount++;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = instanceCount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更改被修饰类的创建行为（修改 <code>new</code> 的行为）；</p><p>我们注意到，JavaScript 的构造函数中，有 <code>new</code> 对象可供使用，<code>new.target</code> 表示使用 <code>new</code> 调用这个构造函数的目标对象。我们可以借此控制 <code>new</code> 的行为，例如禁止 <code>new</code> 新建实例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionCallable</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value <span class="keyword">as</span> <span class="built_in">any</span>, &#123;kind&#125; <span class="keyword">as</span> <span class="built_in">any</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&#x27;class&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;This function can’t be new-invoked&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">value</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@functionCallable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> robin = <span class="title class_">Person</span>(<span class="string">&#x27;Robin&#x27;</span>);</span><br><span class="line">robin.<span class="property">name</span> <span class="comment">// &#x27;Robin&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>在类的定义后、类实例初始化前追加行为；</p><p>这里就需要使用到装饰器 <code>addInitializer</code>，<strong>这个函数将在 类的定义结束后（不是实例的定义结束后！） 执行</strong>，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addInitializeWrapper</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params">value: <span class="built_in">any</span>, context: ClassDecoratorContext</span>) &#123;</span><br><span class="line">        context.<span class="title function_">addInitializer</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addInitializeWrapper</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="keyword">var</span> t2 = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br></pre></td></tr></table></figure><p>会在 <code>Test</code> 定义结束后打印一次 <code>Hello</code>；</p></li></ol><h3 id="5-2-2-方法装饰器"><a href="#5-2-2-方法装饰器" class="headerlink" title="5.2.2 方法装饰器"></a>5.2.2 方法装饰器</h3><p>方法装饰器是 <code>context.kind</code> 字段为 <code>&quot;method&quot;</code> 的装饰器，用来装饰 TypeScript 类中的方法。</p><p>需要指定 <code>static</code>（该方法是否在类中为静态方法）、<code>private</code>（该方法是否在类中为私有方法）、<code>access.get</code>（该方法的读访问器）、<code>addInitializer</code>（该方法定义后的初始化逻辑），如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassMethodDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;method&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>常见使用场景有：</p><ol><li><p>直接替换被修饰的方法；</p><p>这种使用方法很简单，就是装饰器函数返回一个新的函数/方法就行，这就算替换了原来的方法，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceWithHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">n: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@replaceWithHello</span></span><br><span class="line">    <span class="title function_">echoName</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给被修饰的方法添加额外逻辑（例如打印日志、延时执行、计时、绑定 <code>this</code> 环境等等）；</p><p>这里就举这 3 个例子。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给被装饰方法添加日志</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addLog</span>(<span class="params">originMethod: <span class="built_in">Function</span>, context: ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> methodName = <span class="title class_">String</span>(context.<span class="property">name</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DEBUG] Entering method: <span class="subst">$&#123;methodName&#125;</span>`</span>);</span><br><span class="line">        <span class="comment">// 在原有作用域 this 下执行</span></span><br><span class="line">        <span class="keyword">const</span> result = originMethod.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DEBUG] Exiting method: <span class="subst">$&#123;methodName&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给被装饰方法延迟执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">millisecond: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 无论在哪里，只要 typescript 检测到第一个参数是 this，就会自动将当前环境 this 填充进去，不在 JavaScript 中展现出来。</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, value: <span class="built_in">Function</span>, context: ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&#x27;method&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 和 call 一样，在指定作用域下执行</span></span><br><span class="line">                    value.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">                &#125;, millisecond);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给被装饰方法自动绑定 this 环境，可以解决 “实例方法被赋给其他变量后语义改变 / 报错” 的问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">boundThis</span>(<span class="params">value: <span class="built_in">Function</span>, context: ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> methodName = context.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">private</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`不能绑定私有方法 <span class="subst">$&#123;methodName <span class="keyword">as</span> <span class="built_in">string</span>&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context.<span class="title function_">addInitializer</span>(<span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[methodName] = <span class="variable language_">this</span>[methodName].<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-2-3-属性装饰器"><a href="#5-2-3-属性装饰器" class="headerlink" title="5.2.3 属性装饰器"></a>5.2.3 属性装饰器</h3><p>属性装饰器是 <code>context.kind</code> 字段为 <code>&quot;field&quot;</code> 的装饰器，用来装饰定义在类中的属性。</p><p>它需要指定 <code>static</code>、<code>private</code>、<code>addInitializer</code>、<code>access.get</code> 和 <code>access.set</code>（比方法装饰器多了写访问器）；</p><p>另外它还有一个与其他装饰器不同点是，它要么不返回值，要么返回一个函数，该函数会自动执行，用来对所装饰属性进行初始化。该函数的参数是所装饰属性的初始值，该函数的返回值是该属性的最终值。</p><p>所以，这下你能明白属性装饰器的作用了吗？在初始化该属性时会触发一次属性装饰器。定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassFieldDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;field&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span>; set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="function">(<span class="params">initialValue: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">unknown</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>我们还注意到，<code>value</code> 是 <code>undefined</code> 类型，这意味着 <strong>属性装饰器不会自动将属性传给内部（因为没有必要，考虑赋给该属性的值 <code>initialValue</code> 即可）</strong>。</p><p>常见的使用场景和类的访问器类似，不再赘述，只是介绍一个样例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logged</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; kind, name &#125; = context;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&quot;field&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">initialValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DEBUG] initializing <span class="subst">$&#123;name&#125;</span> with value <span class="subst">$&#123;initialValue&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> initialValue;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="meta">@logged</span> name = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line"><span class="comment">// &quot;[DEBUG] initializing name with value green&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-4-getter-装饰器、setter-装饰器"><a href="#5-2-4-getter-装饰器、setter-装饰器" class="headerlink" title="5.2.4 getter 装饰器、setter 装饰器"></a>5.2.4 getter 装饰器、setter 装饰器</h3><p>它们是 <code>context.kind</code> 字段为 <code>&quot;getter&quot;/&quot;setter&quot;</code> 的装饰器，是<strong>专门用来装饰类访问器</strong>的装饰器。</p><p>描述如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassGetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;getter&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ClassSetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;setter&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>这两个装饰器要么不返回值，要么返回一个函数，取代原来的取值器或存值器。</p><p>为什么要对访问器进行装饰？比如懒加载的特性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@lazy</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Time Consuming Result&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lazy</span>(<span class="params">value: <span class="built_in">any</span>, &#123; kind, name &#125;: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&quot;getter&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = value.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, name, &#123;</span><br><span class="line">        <span class="attr">value</span>: result,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">inst.<span class="property">value</span>;</span><br><span class="line"><span class="comment">// Calculating...</span></span><br><span class="line"><span class="comment">// &#x27;Time Consuming Result&#x27;</span></span><br><span class="line">inst.<span class="property">value</span>;</span><br><span class="line"><span class="comment">// &#x27;Time Consuming Result&#x27;</span></span><br></pre></td></tr></table></figure><hr><p>还有一个 <code>accessor</code> 装饰器不常用，在这里不再赘述，有兴趣请查看官方文档。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;Written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt; MDN Doc &amp;amp;&amp;amp; TypeScript Doc&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Web" scheme="https://sjtuxhw.top/tags/Web/"/>
    
    <category term="JavaScript" scheme="https://sjtuxhw.top/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="https://sjtuxhw.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>React框架速通</title>
    <link href="https://sjtuxhw.top/2024/02/27/React%E6%A1%86%E6%9E%B6%E9%80%9F%E9%80%9A/"/>
    <id>https://sjtuxhw.top/2024/02/27/React%E6%A1%86%E6%9E%B6%E9%80%9F%E9%80%9A/</id>
    <published>2024-02-27T07:30:41.000Z</published>
    <updated>2024-02-27T07:34:37.303Z</updated>
    
    <content type="html"><![CDATA[<p><i>Written by SJTU-XHW</i></p><p><i>Reference: </i> MDN Doc &amp;&amp; React Doc</p><p><i>本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h1 id="Chapter-0-5-分钟速通-React-框架"><a href="#Chapter-0-5-分钟速通-React-框架" class="headerlink" title="Chapter 0. 5 分钟速通 React 框架"></a>Chapter 0. 5 分钟速通 React 框架</h1><blockquote><p>如果你只有 5 分钟时间，则只需阅读这一章；否则<strong>请从 Chapter 1 开始</strong>。</p><p>建议有一定的原生 JavaScript 基础，至少包括：<strong>JS 基本类型、内置引用类型、函数表达式的各种操作，简单 DOM 操作，JavaScript 事件，JavaScript 异步（Promise）</strong>。</p></blockquote><h2 id="0-1-基本概念"><a href="#0-1-基本概念" class="headerlink" title="0.1 基本概念"></a>0.1 基本概念</h2><ul><li><p>React 应用程序是由 <strong>组件</strong> 组成的。</p><blockquote><p>一个组件是 UI 的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。</p></blockquote></li><li><p>React 组件是<strong>返回标签的 JavaScript 函数</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function MyButton() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;button&gt;I&#x27;m a button&lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>React 组件的使用方法就是直接使用 “React 特殊标签”，React 组件的标签必须以大写字母开头，而 HTML 标签则必须是小写字母：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default function MyApp() &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Welcome to my app&lt;/h1&gt;</span><br><span class="line">        &lt;MyButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="0-2-JSX-使用规范"><a href="#0-2-JSX-使用规范" class="headerlink" title="0.2 JSX 使用规范"></a>0.2 JSX 使用规范</h2><ul><li><p>大多数 React 项目会使用 JSX，主要是它很方便；</p></li><li><p>JSX 比 HTML 更加严格。你必须闭合标签（尤其是单标签），如 <code>&lt;br /&gt;</code>，而不能写 <code>&lt;br&gt;</code>；</p></li><li><p>React 组件不允许返回多个 JSX 标签。如果需要，必须将它们包裹到一个共享的父级中，比如 <code>&lt;div&gt;...&lt;/div&gt;</code> 或使用空的 <code>&lt;&gt;...&lt;/&gt;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function AboutPage() &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">        &lt;h1&gt;About&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;Hello there.&lt;br/&gt;How do you do?&lt;/p&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>为组件自定义样式：和 HTML 一样，在标签里写 <code>className</code>，再使用 CSS / JavaScript 选择更改；</p></li><li><p>使用 JavaScript 变量：<code>&#123;variableName&#125;</code>；</p><blockquote><p>可以在其中写 JavaScript 语法、JSON 对象；</p></blockquote></li></ul><h2 id="0-3-与-JavaScript-组合起来"><a href="#0-3-与-JavaScript-组合起来" class="headerlink" title="0.3 与 JavaScript 组合起来"></a>0.3 与 JavaScript 组合起来</h2><p>举几个例子来进一步了解如何使用：</p><ul><li><p>根据条件选择渲染组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 三目表达式 */</span><br><span class="line">return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;login ? (</span><br><span class="line">            &lt;AdminPanel/&gt;</span><br><span class="line">        ) : (</span><br><span class="line">            &lt;LoginForm/&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>快速渲染列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const listItem = pList.map((item) =&gt; &#123;</span><br><span class="line">    &lt;li key=&#123;item.id&#125;&gt;&#123;item.title&#125;&lt;/li&gt;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return (&lt;ul&gt;&#123;listItem&#125;&lt;/ul&gt;);</span><br></pre></td></tr></table></figure></li><li><p><strong>在 react 中使用事件处理函数</strong>：</p><ul><li><p>方法 1：内联事件处理函数（纯 JavaScript 不建议）；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function MyButton() &#123;</span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    alert(&#x27;You clicked me!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法 2：手动绑定事件处理函数（react 中不方便使用）；</p></li></ul></li><li><p>记忆组件：在 React 中，一般<strong>存储组件状态信息</strong>的方法是引入 React 内置的 Hook（后面介绍），这里以 <code>useState</code> 为例；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function MyButton() &#123;</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line">    /* 得到有记忆性的 count 数据 和 改变该数据的 setCount 函数 */</span><br><span class="line">    function handleClick() &#123;</span><br><span class="line">        setCount(count + 1);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return (</span><br><span class="line">        &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">              Clicked &#123;count&#125; times</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function MyApp() &#123;</span><br><span class="line">    // 在每个组件内部定义的 `count` 只对当前组件有效；</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;MyButton/&gt;</span><br><span class="line">            &lt;MyButton/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Hook</code> 在 react 内置库中是 <strong>以 <code>use</code> 开头的函数</strong>；它比普通函数更为严格，<strong>只能在组件（或其他 Hook）的 顶层</strong> 调用 Hook；</p><p>⚠⚠<strong>特别地，如果你想要组件间共享某个 hook 的值，可以将 hook 定义在组件共同的环境中。</strong>⚠⚠</p></li><li><p>React 为组件自定义属性（具体表现为 HTML 上传入的属性）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 组件传入的参数使用 &#123;&#125; 括起 */</span><br><span class="line">function MyButton(&#123; count, onClick &#125;) &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;</span><br><span class="line">            Clicked &#123;count&#125; times</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Chapter-1-React-描述-UI"><a href="#Chapter-1-React-描述-UI" class="headerlink" title="Chapter 1. React 描述 UI"></a>Chapter 1. React 描述 UI</h1><h2 id="1-1-React-组件"><a href="#1-1-React-组件" class="headerlink" title="1.1 React 组件"></a>1.1 React 组件</h2><ul><li><p>React 应用程序是由 <strong>组件</strong> 组成的。</p><blockquote><p>一个组件是 UI 的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。</p></blockquote></li><li><p>React 组件是<strong>返回标签的 JavaScript 函数</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function MyButton() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;button&gt;I&#x27;m a button&lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>React 组件的使用方法就是直接使用 “React 特殊标签”，React 组件的标签必须以大写字母开头，而 HTML 标签则必须是小写字母：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default function MyApp() &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Welcome to my app&lt;/h1&gt;</span><br><span class="line">        &lt;MyButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>export default</code> 指定了文件中的主要组件。而这种 “React 特殊标签” 被称为 <code>JSX</code>；</p><blockquote><p>JavaScript 中，<code>export</code> 关键字用于从模块中导出实时绑定的函数、对象或原始值，以便其他程序可以通过 <code>import</code> 语句使用它们。</p><p>导出有两种方式：<strong>命名导出（一个模块中可以有任意个）、默认导出（每个模块仅一个）</strong>；</p><p>命名导出可以导出 var, let, const, function, class；不过另一个模块导入时 <strong>必须同名，或者使用重命名命名导出</strong>；</p><p>默认导出在 <code>export</code> 后加 <code>default</code> 关键字，这样 <code>import XX from &quot;&lt;this script&gt;&quot;</code> 中的 <code>XX</code> 可以随意取名；</p></blockquote></li></ul><p>注意要点：</p><ul><li><p>不应该在组件中<u><strong>定义</strong></u>组件（但是可以嵌套使用）：性能降低、引发 Bug；</p></li><li><p>合理地将组件拆分为不同文件，利用 “默认导出”、“命名导出” 等方法进行组件的导入导出，提高代码的可读性和可维护性；</p></li></ul><h2 id="1-2-JSX-的逻辑-和-规则"><a href="#1-2-JSX-的逻辑-和-规则" class="headerlink" title="1.2 JSX 的逻辑 和 规则"></a>1.2 JSX 的逻辑 和 规则</h2><p>为什么要有 JSX ？有些人说它把 HTML 和 JavaScript 混在了一起。我们在之前 Chapter 0 中看到，就事件处理器而言，原本 JavaScript 因为和 HTML 分离而不建议使用内联事件处理器，到了 JSX 中就建议使用了，这就是组件定义的位置的变化。</p><p>因为随着 Web 的交互性越来越强，逻辑越来越决定页面中的内容。JavaScript 开始负责 HTML 的内容，这也是为什么 <strong>在 React 中，渲染逻辑和标签共同存在于同一个地方——组件。</strong></p><blockquote><p>要注意的是，JSX 和 React 相互独立，前者是语法扩展，后者是 JavaScript 的库。</p></blockquote><p>JSX 用在 JavaScript 中，比 HTML 语言更为严格，具体有下面的要求：</p><ol><li><p><strong>只能返回一个根元素</strong>。如果想要在一个组件中包含多个元素，<strong>需要用一个父标签把它们包裹起来</strong>；</p></li><li><p>标签必须闭合，单标签必须尾缀 <code>/</code> 以示结束；</p></li><li><p>标签属性必须以驼峰命名法命名（HTML 原生属性中含有 <code>a-b</code> 的在 JSX 以 <code>aB</code> 代替）；</p><ul><li><p><strong>JSX 中，考虑到 JavaScript 有关键字 <code>class</code>，因此 JSX 中的 <code>class</code> 属性名使用 <code>className</code> 代替</strong>；</p></li><li><p>JSX 中，如果传入内联样式 <code>style</code> 属性，那么其中的键值也应该使用驼峰命名法，因为它仍然是 JSX；</p><blockquote><p>例如在 HTML 中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;test-type&quot;</span>, <span class="attr">style</span>=<span class="string">&quot;&#123;background-color: black&#125;;&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 JSX 中应该写成：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul className=<span class="string">&quot;test-type&quot;</span>, style=&#123;&#123;<span class="attr">backgroundColor</span>: <span class="string">&#x27;black&#x27;</span>&#125;&#125;&gt;&lt;/ul&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul></li></ol><h2 id="1-3-JSX-中使用-JavaScript"><a href="#1-3-JSX-中使用-JavaScript" class="headerlink" title="1.3 JSX 中使用 JavaScript"></a>1.3 JSX 中使用 JavaScript</h2><p><strong>一言以蔽之：JSX 的 <code>&#123;&#125;</code> 中可以运行任何 JavaScript 合法表达式</strong>。</p><p>那么在 JSX 中只能什么时候用呢？</p><ul><li><p>用作 JSX 标签内的<strong>文本</strong>：<code>&lt;h1&gt;&#123;name&#125;&#39;s To Do List&lt;/h1&gt;</code> 是有效的；</p><blockquote><p>但是 <code>&lt;&#123;tag&#125;&gt;Gregorio Y. Zara&#39;s To Do List&lt;/&#123;tag&#125;&gt;</code> 无效；</p></blockquote></li><li><p>用作紧跟在 <code>=</code> 符号后的 <strong>属性</strong>：<code>src=&#123;avatar&#125;</code> 会读取 <code>avatar</code> 变量；</p><blockquote><p>但是 <code>src=&quot;&#123;avatar&#125;&quot;</code> 只会传一个字符串 <code>&#123;avatar&#125;</code>；</p></blockquote></li></ul><h2 id="1-4-React-自定义组件传入属性"><a href="#1-4-React-自定义组件传入属性" class="headerlink" title="1.4 React 自定义组件传入属性"></a>1.4 React 自定义组件传入属性</h2><p>React 通过允许自定义组件传入的属性，实现了 “父组件向子组件传递数据” 的需求。</p><p>你可能会想，既然 React 组件就是一个返回标签的 JavaScript 函数嘛，那不直接给函数加几个参数就行？</p><p>可惜事与愿违，你还要在参数外面包一层 <code>&#123;&#125;</code>。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Avatar(&#123; person, size &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img</span><br><span class="line">      className=&quot;avatar&quot;</span><br><span class="line">      src=&#123;getImageUrl(person)&#125;</span><br><span class="line">      alt=&#123;person.name&#125;</span><br><span class="line">      width=&#123;size&#125;</span><br><span class="line">      height=&#123;size&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是为什么？因为在 HTML 中，这些都是定义在元素内的属性。在经过 React 库的包装之后，相当于 “对象解包” 的过程（类比 Python 的 <code>arg</code> 形参要加 <code>*</code> 的原因）。</p><p>你也可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Avatar(prop) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img</span><br><span class="line">      className=&quot;avatar&quot;</span><br><span class="line">      src=&#123;getImageUrl(prop.person)&#125;</span><br><span class="line">      alt=&#123;prop.person.name&#125;</span><br><span class="line">      width=&#123;prop.size&#125;</span><br><span class="line">      height=&#123;prop.size&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个语法很自由，允许指定默认值：</p><p><code>function Avatar(&#123; person, size = 100&#125;) &#123; ... &#125;</code></p></blockquote><p>⚠⚠<strong>有种特殊情况，当组件的形参是 <code>children</code> 时，就是该组件内部的子组件</strong>。⚠⚠</p><p>这说明了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Widget1&gt;</span><br><span class="line">    &lt;Widget2/&gt;</span><br><span class="line">&lt;/Widget1&gt;</span><br></pre></td></tr></table></figure><p><code>Widget1.children</code> 就是 <code>Widget2</code>；</p><hr><p>还有一个点需要注意：<strong>不能在组件内更改传入的 <code>prop</code> 属性！！</strong> 为什么？</p><p>我们知道，通过传入 <code>prop</code> 可以给子组件以数据。但是，<code>prop</code> 永远是不可变数据类型，下一次渲染时如果父组件传递的数据改变，那么传入的 <code>prop</code> 将是个新的对象，旧的对象将在合适时机被 JavaScript 引擎回收。</p><h2 id="1-5-条件渲染"><a href="#1-5-条件渲染" class="headerlink" title="1.5 条件渲染"></a>1.5 条件渲染</h2><p>很简单，在组件定义函数中加入条件判断，根据条件返回对应的元素即可。</p><p>同时，我们可以充分利用 JavaScript 的<strong>三目运算符、逻辑运算符</strong>的特点来简化代码。</p><p>有一点需要注意，<strong>允许返回 <code>null / false</code>，这相当于告诉渲染器此处什么都不要渲染</strong>。</p><h2 id="1-6-从数据渲染列表"><a href="#1-6-从数据渲染列表" class="headerlink" title="1.6 从数据渲染列表"></a>1.6 从数据渲染列表</h2><p>注意几件事情：</p><ul><li><p>生成列表时，应该为每个项准备全局唯一的 Key，因为这些 key 会告诉 React，每个组件对应着数组里的哪一项，所以 React 可以把它们匹配起来。这在数组项进行移动（例如排序）、插入或删除等操作时非常重要。一个合适的 <code>key</code> 可以帮助 React 推断发生了什么，从而得以正确地更新 DOM 树。</p></li><li><p>用作 key 的值应该在数据中提前就准备好，<strong>并且和数据绑定不作变化</strong>，而不是在运行时才随手生成；</p></li></ul><p><strong>这里的 “列表” 是广义上的列表，只要你利用了 <code>map</code>、手动构建数组等方法生成了一个重复的表状结构</strong>。</p><h2 id="1-7-React-组件渲染函数的幂等性"><a href="#1-7-React-组件渲染函数的幂等性" class="headerlink" title="1.7 React 组件渲染函数的幂等性"></a>1.7 React 组件渲染函数的幂等性</h2><p>按照 React 规范，定义组件的渲染函数（<strong>不是事件处理函数！</strong>）对于相同的输入（即属性），表现应该始终相同。即 React 组件需要有对外的幂等性。</p><p>这意味着每个 React 组件渲染函数只应该完成自己 JSX 的计算，并且不应该更改在组件外的变量 / 对象，尤其是数组（例如定义在组件外的变量、传入组件的 <code>props</code>、<code>state</code>、<code>context</code> 等等）；</p><p>这一点与我们在 JavaScript 中遇到的情况就很不一样了。比如：</p><p>假设页面上有一个组件 <code>&lt;h1&gt;</code>，希望它在午夜 0 时到清晨 6 时的时间内将 <code>class</code> 属性设置为 <code>night</code>，其余时间设置为 <code>day</code>；那么 JavaScript 实现的思路就很简单：</p><ul><li>定义处理函数，通过 <code>querySelector</code> 获取元素 DOM 对象；</li><li><p>计算时间，在对应时间内按要求设置 <code>class</code> 属性内容；</p></li><li><p>最后使用 <code>setInterval</code> 设置渲染；</p></li></ul><p>但是在 React 中，如果使用 <code>document</code> 更改了外部元素，这就是违反规范的行为。正确的做法是 <strong>计算然后利用结果返回指定组件</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function Cock(&#123; time &#125;) &#123; /* 外部传入时间 */</span><br><span class="line">    var hour = time.getHours();</span><br><span class="line">    var cln = (hour &gt;= 0 &amp;&amp; hour &lt;= 6 ? &#x27;night&#x27; : &#x27;day&#x27;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;h1 className=&#123;cln&#125;&gt;</span><br><span class="line">            &#123;time.toLocaleString()&#125;</span><br><span class="line">        &lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter-2-React-交互与事件"><a href="#Chapter-2-React-交互与事件" class="headerlink" title="Chapter 2. React 交互与事件"></a>Chapter 2. React 交互与事件</h1><h2 id="2-1-React-中的事件处理函数"><a href="#2-1-React-中的事件处理函数" class="headerlink" title="2.1 React 中的事件处理函数"></a>2.1 React 中的事件处理函数</h2><p>在原生 JavaScript 中，我们使用 <strong>事件处理函数</strong> 来管理用户与界面元素的事件。通常的做法是，先找到需要处理的元素，使用 <code>addEventListener</code> 添加事先定义的事件处理器，这样就能起到监听事件并在适当时机调用回调函数的作用。</p><p>而在 React 中，根据规范应该使用闭包定义 + 内联事件处理器的方法。</p><p>例如为一个按钮设置点击事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default function MyButton() &#123;</span><br><span class="line">    function handleClick() &#123;</span><br><span class="line">        alert(&quot;Clicked!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (</span><br><span class="line">        &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，在原生 JavaScript 中，我们了解到了 “事件传播”，在 React 中，事件传播完全与原生 JavaScript 相同，<strong>包括阻止事件传播 <code>event.stopPropagation()</code>、阻止默认事件处理函数 <code>event.preventDefault()</code></strong> 都与 JavaScript 一致。</p><p>我们一般想要阻止事件向父组件传递，就需要修改事件处理函数，“先阻止事件传播，再调用目标事件处理函数”。</p><p>还有重要的一点，<strong>事件处理函数可以不是幂等的</strong>，因为组件可能需要有个应对用户操作的状态机，因此它可以更改一些其他变量。</p><p>⚠⚠<strong>注意：如果要用 <code>event</code>，使用前一定要记住给函数声明一个参数！</strong>⚠⚠</p><h2 id="2-2-React-中的状态机：useState"><a href="#2-2-React-中的状态机：useState" class="headerlink" title="2.2 React 中的状态机：useState"></a>2.2 React 中的状态机：<code>useState</code></h2><p>通常情况下，如果我们只是单独使用原生的事件处理函数，那么可能并不能满足我们的需求。即 “事件处理函数 和 渲染函数 到目前为止都是幂等的”。我们想要 Web 程序跟随用户的操作进行一系列的变化。</p><p>有人也许会说，那么在事件处理函数中修改外部的变量，让外部变量保存一些状态不就行了？就像原生 JavaScript 一样。</p><p>很遗憾，这样不行，这主要是因为 React 的渲染机制造成的。原生 JavaScript 的页面渲染大部分都交给 HTML，自己则按照事件和对象驱动地修改一部分内容，并立即渲染。但是在 React 中，HTML 和 JavaScript 的工作全部交由 JSX，这会引发几个问题：</p><ul><li>组件函数内的局部变量<strong>无法在多次渲染中持久保存。</strong> 当 React 再次渲染这个组件时，它会从头开始渲染，不会考虑之前对局部变量的任何更改；</li><li><strong>更改局部变量不会触发渲染。</strong> React 没有意识到它需要使用新数据再次渲染组件；</li></ul><blockquote><p>提醒：你不应该将变量定义到组件函数外面。因为它们不会被导出。</p></blockquote><p>所以，真正想要实现最初的功能，必须完成两件事：</p><ol><li>把操作中产生的状态数据保存起来，不被渲染过程影响；</li><li>在修改这些状态数据后，触发重新渲染的机制；</li></ol><p>在 React 框架内，就有这样定义好的对象 <code>useState</code>，它是一种 Hook，提供了：</p><ol><li>state 变量保存状态数据；</li><li>state setter 函数更新 state 变量的同时<strong>触发 React 再次渲染组件</strong>；</li></ol><blockquote><p>这里介绍一下 React 的 Hook 机制。在 React 中，任何以 <code>use</code> 开头的函数都被称为 Hook。</p><p>Hook <u><strong>是一种特殊的函数，只在 React 渲染时有效</strong></u>。</p></blockquote><p>它的使用方法超级简单，就是<u><strong>在组件渲染函数最开头</strong></u>调用一次 <code>useState(&lt;initVal&gt;)</code>，返回一个包含 <code>state</code> 变量（以 <code>initVal</code> 为初值）、<code>state setter</code> 函数的数组；</p><p>使用多少状态变量，就调用多少次 <code>useState()</code>。</p><p><u><strong>因此，React 中几乎一切需要更新、记忆状态的的过程，都可以交由 <code>useState</code> 完成</strong></u>。</p><p>⚠⚠<strong>最最重要的是，如果 <code>useState</code> 在某个组件内被定义，那么这个属性对于该组件其他所有实例、其他所有组件（包括父组件、子组件）都是<u>互不影响、相互独立</u>的，这为一些复杂的状态设计提供了可能</strong>。⚠⚠</p><h2 id="2-3-React-的渲染机制"><a href="#2-3-React-的渲染机制" class="headerlink" title="2.3 React 的渲染机制"></a>2.3 React 的渲染机制</h2><h3 id="2-3-1-渲染流程"><a href="#2-3-1-渲染流程" class="headerlink" title="2.3.1 渲染流程"></a>2.3.1 渲染流程</h3><p>到现在为止，我们有必要接触一些关于 React 渲染的更加详细的知识。</p><p>渲染的步骤很简单：</p><ol><li>用户或者 Hook 调用一些函数 <strong>触发</strong> 一次渲染过程；</li><li>React 库渲染组件；</li><li>React 库将更改提交给 DOM；</li></ol><p>我们作为用户只知道有 2 种情况会触发渲染，一是在 React 应用启动时。如果你使用 <code>create-react-app</code> 来创建项目的话，你能在 <code>App.js</code> 中看到类似这样的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createRoot &#125; from &#x27;react-dom/client&#x27;;</span><br><span class="line"></span><br><span class="line">const root = createRoot(document.getElementById(&#x27;root&#x27;));</span><br><span class="line">root.render(&lt;App /&gt;);</span><br></pre></td></tr></table></figure><blockquote><p>第一句 <code>createRoot</code> 相当于使用原生 JavaScript 在页面上查找并创建一个根结点对象；</p><p>第二句就使用 <code>render()</code> 将指定组件在根结点上渲染。</p></blockquote><p>而另一种情况就是使用了 Hook 的 setter 函数更新了组件状态，这个做法在 React 库内部会<strong>在恰当的时机</strong>触发一次重新渲染的流程。</p><hr><p><strong>进行一次渲染所做的工作可能有所不同</strong>。</p><p>因为对于初次渲染而言，这个过程是递归的，从调用渲染根组件，在渲染函数（也就是我们定义的组件函数）内返回了子组件，那么接下来继续渲染子组件，直到没有更多的组件需要渲染为止。渲染每个组件的每个元素标签时，React 都会为它们创建一个 DOM 结点。</p><p>初次渲染完成后，React 会将创建好的 DOM 结点利用 DOM API <code>appendChild()</code> 将结点放在 DOM 树上，交给浏览器做 “浏览器渲染”，为了避免混淆，将 “浏览器渲染” 称为 <strong>“绘制”</strong>。</p><p>而在重渲染中，React 会判断哪些属性从上次渲染以来没有更改，对没有更改的部分不会进行任何操作（增量渲染）。并且 React <u>不会为</u>已经存在的、修改了属性的的结点重新创建 DOM 结点。</p><p>重渲染完成后，React 仅将改动的结点进行设置，<strong>不会影响没有修改的结点</strong>。最终还是将 DOM 交由浏览器绘制。</p><p><strong>这也是为什么之前提到 “渲染函数必须是幂等的，唯一能使渲染函数改变输出的，只有 外部 或 事件处理器 更改了渲染函数的输入参数”</strong>，因为如果不这么做，渲染的行为将无法预测；</p><h3 id="2-3-2-useState-与渲染的关系"><a href="#2-3-2-useState-与渲染的关系" class="headerlink" title="2.3.2 useState 与渲染的关系"></a>2.3.2 <code>useState</code> 与渲染的关系</h3><p>了解了上一节的知识，你可能已经认为对 React 渲染的机制掌握透彻了。但是请看下面的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Counter() &#123;</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;number&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">      &#125;&#125;&gt;+3&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能认为每次点击按钮，数字会 + 3，对吗？很遗憾，其实数字在每次点击后始终 + 1。这个行为与 <code>useState</code> 触发重渲染的方式有关。</p><p><strong>我们在前一节只知道 <code>useState</code> 这类 Hook 会内部触发重渲染，但是这是怎么触发，我们也要知道，否则就会出现上面的错误</strong>。</p><p>像 <code>useState</code> 这类 Hook 一般出现在各种事件处理器中，它们执行的机制 <strong>不是立即更新，而是标记更新</strong>。准确地说，它们本身不会调用重新渲染的函数，更像是 Cache 的 Set dirty，提醒 React 在结束事件处理函数之后进行为这个组件进行重渲染。</p><p><u><strong>也就是说，setter 并不会直接更改 state（本次保持不变），而是告诉 React 下次渲染时将 state 改成什么</strong></u>。</p><blockquote><p>为什么 React 要这么设计？引用官方文档的一句话：</p><p>这让你可以更新多个 state 变量——甚至来自多个组件的 state 变量——而不会触发太多的重渲染。但这也意味着只有在你的事件处理函数及其中任何代码执行完成 <strong>之后</strong>，UI 才会更新。这种特性也就是 <strong>批处理</strong>，它会使你的 React 应用运行得更快。它还会帮你避免处理只更新了一部分 state 变量的令人困惑的“半成品”渲染。</p><p>就像餐厅里帮你点菜的服务员。服务员不会在你说第一道菜的时候就跑到厨房。相反，他们会让你把菜点完，让你修改菜品，甚至会帮桌上的其他人点菜。</p></blockquote><p>这样就能解释上面的行为：<code>setNumber(number + 1)</code> 只是<strong>重复地</strong>告诉 React 下次渲染时，该组件的 <code>number</code> 状态为 <strong>当前的 <code>number</code> + 1</strong>，等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 设 0 为 number 本次的值</span><br><span class="line">setNumber(0 + 1);</span><br><span class="line">setNumber(0 + 1);</span><br><span class="line">setNumber(0 + 1);</span><br></pre></td></tr></table></figure><p><u><strong>更让人惊奇的是，访问 <code>number</code> 得到的绝不是它的引用，而总是它的值</strong></u>！在 JavaScript 这个遍地是引用的语言中，这就相当于是相当少见的 “<strong>值捕获</strong>”（类比 C++11 的匿名函数表达式中有值、引用两种方式捕获变量）！</p><p>看下面的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Counter() &#123;</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;number&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setNumber(number + 5);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          alert(number);</span><br><span class="line">        &#125;, 3000);</span><br><span class="line">      &#125;&#125;&gt;+5&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们让 <code>number</code> 等待 5 秒后再传给 <code>alert</code>，你会发现输出的 <code>number</code> 就是在重渲染前的值。</p><p>了解了这些你可能会问，这种做法有好有坏。好处是在<strong>执行渲染函数时无需担心 <code>state</code> 突然被更改</strong>，但坏处是，我们在一次渲染中没法立即读取改变后的 <code>state</code>，这应该怎么办？下一节就是解决方案。</p><h3 id="2-3-3-useState-更新队列"><a href="#2-3-3-useState-更新队列" class="headerlink" title="2.3.3 useState 更新队列"></a>2.3.3 <code>useState</code> 更新队列</h3><p>正如前面介绍的，在下一次渲染开始前，你无法实现多次更改状态的需求，因为 state setter 只是提醒下一次渲染要改变的内容。但 React 也给开发者提供了一种 “批处理队列” 的方法，明确让 React 逐步设置一些状态。</p><p>我们对 2.3.2 中一开始 + 3 的示例进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Counter() &#123;</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;number&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setNumber(n =&gt; n + 1);</span><br><span class="line">        setNumber(n =&gt; n + 1);</span><br><span class="line">        setNumber(n =&gt; n + 1);</span><br><span class="line">      &#125;&#125;&gt;+3&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 React 就能够按照我们想要的动作进行 + 3 的操作了。</p><p>我们注意到这次传入 <code>setNumber</code> 的是一个函数（<code>(n) =&gt; &#123; return n + 1; &#125;</code>），这就相当于<strong>向 React 状态修改队列中加入了一个执行函数</strong>，在 React 下一次渲染时，会依次运行队列中的函数，以指定的方式修改状态。</p><p>到这里，我们可以从另一角度理解 <code>setNumber(number + 1)</code> 的含义了，它其实等效于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setNumber(x =&gt; number + 1)</span><br></pre></td></tr></table></figure><p>由于 <code>x</code> 参数与结果无关，当然最后也就不会累加计算啦。</p><p>以此类推，下面的行为也就不难理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 每次 + 6 */</span><br><span class="line">&lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">  setNumber(number + 5);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">&#125;&#125;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">/* 变为 42 后不会改变 */</span><br><span class="line">&lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">  setNumber(number + 5);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">  setNumber(42);</span><br><span class="line">&#125;&#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-useState-与-JavaScript-原生异步结合"><a href="#2-3-4-useState-与-JavaScript-原生异步结合" class="headerlink" title="2.3.4 useState 与 JavaScript 原生异步结合"></a>2.3.4 <code>useState</code> 与 JavaScript 原生异步结合</h3><p>众所周知，原生 JavaScript 的异步大多依靠 Promise 实现。那么，如果把异步操作与 <code>useState</code> 结合，又有哪些需要注意的地方呢？</p><p>首先明确异步操作对 <code>useState</code> 没啥影响，并不妨碍正常使用，<strong>只是需要明白它的含义</strong>。</p><p>下面是个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function RequestTracker() &#123;</span><br><span class="line">  const [pending, setPending] = useState(0);</span><br><span class="line">  const [completed, setCompleted] = useState(0);</span><br><span class="line"></span><br><span class="line">  async function handleClick() &#123;</span><br><span class="line">    setPending(pending + 1);</span><br><span class="line">    await delay(3000);</span><br><span class="line">    setPending(pending - 1);</span><br><span class="line">    setCompleted(completed + 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h3&gt;</span><br><span class="line">        等待：&#123;pending&#125;</span><br><span class="line">      &lt;/h3&gt;</span><br><span class="line">      &lt;h3&gt;</span><br><span class="line">        完成：&#123;completed&#125;</span><br><span class="line">      &lt;/h3&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        购买</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function delay(ms) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想在事件处理函数中改变状态的同时加上一些异步等待的行为。</p><p>这样做是可行的，你可以认为异步的等待能在状态设置的时机被触发。如上例，在两次 <code>setter</code> 操作之间加一个异步 <code>await</code> 依然是能够等待的。</p><p>结论是，<strong>尽管 <code>setter</code> 只是标记改变，但能完全按照代码执行顺序，依次改变状态。</strong></p><h3 id="2-3-5-useState-存储可变数据类型"><a href="#2-3-5-useState-存储可变数据类型" class="headerlink" title="2.3.5 useState 存储可变数据类型"></a>2.3.5 <code>useState</code> 存储可变数据类型</h3><p>继续考虑 <code>useState</code> 的使用细节。我们之前接触到的、用于表征状态的量都是基本类型。如果状态是 <strong>引用类型（JavaScript 对象）</strong>，情况有没有变化呢？</p><p>答案是有的。因为 JavaScript 原生引用类型都是 <strong>可变数据类型</strong>，和基本类型这种不可变数据类型相比有些尤其需要注意的点。</p><p>最重要的原因是，如果开发者将可变数据类型作为状态存储，那么在修改状态时，<strong>如果仅仅修改其中的属性，那么内存地址是不会发生变化的，<u>换言之，React 无法发现这个变量被修改了</u>，那么也就无法发挥 Hook 重渲染的作用</strong>。</p><p>所以注意的问题很简单：<u><strong>想要将可变类型（如对象）作为状态，那么在修改状态时应该直接传入新的对象，而不是修改原来对象的属性。</strong></u></p><p>这里看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">export default function MovingDot() &#123;</span><br><span class="line">  const [position, setPosition] = useState(&#123;</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div</span><br><span class="line">      onPointerMove=&#123;e =&gt; &#123;</span><br><span class="line">        setPosition(&#123;</span><br><span class="line">          x: e.clientX,</span><br><span class="line">          y: e.clientY</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      style=&#123;&#123;</span><br><span class="line">        position: &#x27;relative&#x27;,</span><br><span class="line">        width: &#x27;100vw&#x27;,</span><br><span class="line">        height: &#x27;100vh&#x27;,</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">      &lt;div style=&#123;&#123;</span><br><span class="line">        position: &#x27;absolute&#x27;,</span><br><span class="line">        backgroundColor: &#x27;red&#x27;,</span><br><span class="line">        borderRadius: &#x27;50%&#x27;,</span><br><span class="line">        transform: `translate($&#123;position.x&#125;px, $&#123;position.y&#125;px)`,</span><br><span class="line">        left: -10,</span><br><span class="line">        top: -10,</span><br><span class="line">        width: 20,</span><br><span class="line">        height: 20,</span><br><span class="line">      &#125;&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面提到 “创建新对象” 的要点外，我们还了解到了 JSX 中另一个可以内联事件处理器的属性：<code>onPointerMove</code>，这个属性对应的事件处理器在用户鼠标移过该元素时就会被触发，<strong>重要的参数有 <code>event.clientX</code>、<code>event.clientY</code></strong>。</p><hr><p>另外，还有几个使用技巧，每次创建新的对象可能有点麻烦，尤其是这个对象属性很多，而我们只想改变一个属性的时候。我们可以使用 <strong>对象展开语法</strong>，类似 Python 的数组解包。比如，<code>person</code> 有 3 个属性，而我们只需要改 <code>firstName</code>，老方法写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setPerson(&#123;</span><br><span class="line">  firstName: e.target.value, // 从 input 中获取新的 first name</span><br><span class="line">  lastName: person.lastName,</span><br><span class="line">  email: person.email</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>新方法就可以写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setPerson(&#123;</span><br><span class="line">    ...person,    // 复制上一个 person 中的所有字段</span><br><span class="line">    firstName: e.target.value // 覆盖 firstName 字段</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>很遗憾的是，这种解包的方式也是引用，所以如果你解包的内容中含有可变数据类型，那么直接这么做也不行。</strong></p><p>例如对于多个的对象，你只能把它们拆开，<u>直到不含有可变数据类型为止</u>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var tmpArt = &#123;</span><br><span class="line">    ...person.artwork,</span><br><span class="line">    city: &#x27;New Delhi&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">setPerson(&#123;</span><br><span class="line">    ...person</span><br><span class="line">    artwork: tmpArt</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>知识补充</strong></p><p>我们对目前遇到的能够内联事件处理器的属性进行总结，主要有下面几个：</p><ul><li><code>onClick</code>；</li><li><code>onFocus</code>；</li><li><code>onPointerMove</code>；</li><li><code>onPointerDown</code>；</li><li><code>onPointerUp</code>；</li><li><code>onChange</code>（特定元素才有，例如 <code>&lt;select&gt;</code>）；</li></ul></blockquote><hr><p>上面的例子所介绍的可变类型大多是 object 对象，如果是数组，那么方法更多一点。因为原生 JavaScript 操作数组的方法本身就多一点。要注意的点是相同的，一定要传入新的对象。</p><p>在使用数组方法时，要注意 <code>map</code>、<code>filter</code>、<code>concat</code>、<code>slice</code> 这类函数都会创建新的数组对象，而 <code>splice</code>、<code>push/pop</code>、<code>shift/unshift</code>、<code>sort</code>、<code>reverse</code> 则只会修改原先的对象。<strong>要善于使用这些函数！能让你处理数组更方便！</strong></p><p><u>也要注意数组元素中含有可变数据类型，那就要单独处理</u>。</p><p>数组还有一点与普通对象有差别的：<strong>它们可能有顺序。在创建新数组时不应该改变元素顺序！！</strong></p><p>我们尝试一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const initialProducts = [&#123;</span><br><span class="line">  id: 0,</span><br><span class="line">  name: &#x27;Baklava&#x27;,</span><br><span class="line">  count: 1,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  name: &#x27;Cheese&#x27;,</span><br><span class="line">  count: 5,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  id: 2,</span><br><span class="line">  name: &#x27;Spaghetti&#x27;,</span><br><span class="line">  count: 2,</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">export default function ShoppingCart() &#123;</span><br><span class="line">  const [</span><br><span class="line">    products,</span><br><span class="line">    setProducts</span><br><span class="line">  ] = useState(initialProducts)</span><br><span class="line"></span><br><span class="line">  function handleIncreaseClick(productId) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;products.map(product =&gt; (</span><br><span class="line">        &lt;li key=&#123;product.id&#125;&gt;</span><br><span class="line">          &#123;product.name&#125;</span><br><span class="line">          &#123;&#x27; &#x27;&#125;</span><br><span class="line">          (&lt;b&gt;&#123;product.count&#125;&lt;/b&gt;)</span><br><span class="line">          &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">            handleIncreaseClick(product.id);</span><br><span class="line">          &#125;&#125;&gt;</span><br><span class="line">            +</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实现 <code>handleIncreaseClick</code>，使得对应 <code>product.id</code> 的按钮一点击，该 product 的 <code>count</code> 数据就 +1 ？</p><p>其实最简单的方法是用 <code>Array.map</code>，而且它恰好能创建一个新数组对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function handleIncreaseClick(productId) &#123;</span><br><span class="line">    var newProdList = products.map((elem)=&gt;&#123;</span><br><span class="line">        if (elem.id === productId) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                ...elem,</span><br><span class="line">                count: elem.count + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else return item;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter-3-React-状态管理"><a href="#Chapter-3-React-状态管理" class="headerlink" title="Chapter 3. React 状态管理"></a>Chapter 3. React 状态管理</h1><p>本章旨在介绍一种更好的组织 React 组件的 state 的思路，让项目写起来更加规范、容易维护。</p><h2 id="3-1-声明式-UI-与-命令式-UI"><a href="#3-1-声明式-UI-与-命令式-UI" class="headerlink" title="3.1 声明式 UI 与 命令式 UI"></a>3.1 声明式 UI 与 命令式 UI</h2><p>命令式 UI 的编程方法通常非常繁琐，你必须去根据要发生的事情写一些明确的命令去操作 UI。</p><p>就像你坐在车里的某个人旁边，然后一步一步地告诉他该去哪。他并不知道你想去哪，只想跟着命令行动。（并且如果你发出了错误的命令，那么你就会到达错误的地方）正因为你必须从加载动画到按钮地“命令”每个元素，所以这种告诉计算机<strong>如何</strong>去更新 UI 的编程方式被称为<strong>命令式 UI 编程</strong>。</p><p>原生 JavaScript + HTML，以及 C++ 的 Qt 框架，采用都是命令式 UI 编程。Qt 为了规避命令式 UI 编程的麻烦，将部分工作转移给 Qt Designer + <code>uic</code>（用户界面编译器）来做。</p><p>JavaScript 的框架 React 则采用了 <strong>声明式 UI 编程</strong>，也就是说，我们不必直接去操作 UI —— 不必直接启用、关闭、显示或隐藏组件。相反，我们只需要 <strong>声明你想要显示的内容，</strong> React 就会<u>通过计算</u>得出该如何去更新 UI。</p><p>就像上了一辆出租车并且告诉司机你想去哪，而不是事无巨细地告诉他该如何走。将你带到目的地是司机的工作，他们甚至可能知道一些你没有想过并且不知道的捷径（即更高效的渲染方式，例如之前的增量渲染技术）。</p><p>在 声明式 UI 编程中，我们不用直接修改 UI 组件，而是采用以下的几个步骤：</p><ol><li><p><strong>定位</strong>你的组件中不同的视图状态（<strong>设计界面状态机</strong>）；</p></li><li><p><strong>确定</strong>是什么触发了这些 state 的改变；</p><p>根据前两个步骤，你应该能够绘制出组件的状态转换图，类似这个，这是个表单的状态转换图：</p><p><img src="/home/xhw/Desktop/web/imgs/state-machine-form.png" height="300px"></p></li><li><p><strong>定义使用</strong>内存中的 state（<code>useState</code>）；</p><p>根据状态图，我们应该设计尽量少的 state，众所周知，程序越复杂越不方便维护；</p></li><li><p><strong>删除</strong>任何不必要的 state 变量；</p><p><strong>这一步是有技巧的，还是以一个表单为例</strong>：</p><ul><li><strong>这个 state 是否会导致矛盾</strong>？例如，<code>isTyping</code> 与 <code>isSubmitting</code> 的状态不能同时为 <code>true</code>。矛盾的产生通常说明了这个 state 没有足够的约束条件；</li><li><strong>相同的信息是否已经在另一个 state 变量中存在</strong>？另一个矛盾：<code>isEmpty</code> 和 <code>isTyping</code> 不能同时为 <code>true</code>。通过使它们成为独立的 state 变量，可能会导致它们不同步并导致 bug；</li><li><strong>你是否可以通过另一个 state 变量的相反值得到相同的信息</strong>？<code>isError</code> 是多余的，因为你可以检查 <code>error !== null</code>。</li></ul></li><li><p><strong>连接</strong>事件处理函数去设置 state；</p></li></ol><h2 id="3-2-State-设计的最佳实践"><a href="#3-2-State-设计的最佳实践" class="headerlink" title="3.2 State 设计的最佳实践"></a>3.2 State 设计的最佳实践</h2><p>前人总结过如下的经验，采集自官方文档 + 笔者自己总结：</p><ul><li><p><strong>合并关联的 state</strong>。如果你总是同时更新两个或更多的 state 变量，请考虑将它们合并为一个单独的 state 变量。</p><blockquote><p>例如位置信息，x 和 y 是建议绑定在一个对象中，因为它们通常同时变化；</p></blockquote></li><li><p><strong>避免互相矛盾 / 冗余的 state</strong>。当 state 结构中存在多个相互矛盾 / “不一致” / 可以互相推理出信息的 state 时，你就可能为此会留下隐患（例如不及时同步、错误地维护）。应尽量避免这种情况；</p></li><li><p><strong>避免深度嵌套的 state</strong>。深度分层的 state 更新起来不是很方便，而且降低代码可读性。如果可能的话，最好以扁平化方式构建 state；</p></li><li><p><u><strong>避免与其他 State 共享引用对象</strong></u>：⚠⚠<strong>这点请一定要注意！！！是笔者自己加的。笔者曾犯过这个错，调试半天都没找出来</strong>。⚠⚠如果你共享了，那么在更新一个 State 的时候，会不经意间影响到另一个 State 的呈现，使程序出现意外的行为。</p><blockquote><p>替代方案是，共享基本类型（不可变数据类型）；</p></blockquote></li></ul><h2 id="3-3-组件间共享-State"><a href="#3-3-组件间共享-State" class="headerlink" title="3.3 组件间共享 State"></a>3.3 组件间共享 State</h2><p>非常简单，就一句话：<strong>把 state 放入父组件，然后用参数传给子组件，即可完成共享</strong>。</p><h2 id="3-4-State-的保留与重置"><a href="#3-4-State-的保留与重置" class="headerlink" title="3.4 State 的保留与重置"></a>3.4 State 的保留与重置</h2><p>为什么要讨论 State 的保留和重置？考虑一个问题。假如你移除了一个组件，之后又添加上去，State 能否保留？如果没法保留，是否有一些手段能保留它的值？</p><h3 id="3-4-1-保留"><a href="#3-4-1-保留" class="headerlink" title="3.4.1 保留"></a>3.4.1 保留</h3><p>首先，React 组件的 State 与组件在渲染树的位置有关。这句话说明了几点：</p><ol><li><p><strong>即便两个组件是同一个对象的引用，只要它们在渲染树上的位置不同，State 就相互独立</strong>。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function App() &#123;</span><br><span class="line">  const counter = &lt;Counter /&gt;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;counter&#125;</span><br><span class="line">      &#123;counter&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const [score, setScore] = useState(0);</span><br><span class="line">  const [hover, setHover] = useState(false);</span><br><span class="line"></span><br><span class="line">  let className = &#x27;counter&#x27;;</span><br><span class="line">  if (hover) &#123;</span><br><span class="line">    className += &#x27; hover&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div</span><br><span class="line">      className=&#123;className&#125;</span><br><span class="line">      onPointerEnter=&#123;() =&gt; setHover(true)&#125;</span><br><span class="line">      onPointerLeave=&#123;() =&gt; setHover(false)&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;h1&gt;&#123;score&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setScore(score + 1)&#125;&gt;</span><br><span class="line">        +1</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个 counter 指向同一个对象，但是它们在 DOM 树上被渲染成两个结点，因此它们的 State 是不会共享的。</p></li><li><p>被移除的组件，state 会被立即删除。所以哪怕在渲染树的相同位置，state 也无法保存；</p><blockquote><p>什么是 “被移除”？</p><p>就是组件在某次返回的 JSX 中，某元素完全消失，该元素对应的组件就被移除了。</p><p>下次即便生成在同一位置，组件也是新渲染的（<strong>不是重渲染</strong>）。</p><p>像这种就不叫删除，叫属性的改变：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;isFancy ? (</span><br><span class="line">    &lt;Counter isFancy=&#123;true&#125; /&gt; </span><br><span class="line">) : (</span><br><span class="line">    &lt;Counter isFancy=&#123;false&#125; /&gt; </span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>选择渲染也不会使其他组件被移除。因为其他的组件的 DOM 树没有变动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;(showHint) ? &lt;p&gt;&lt;i&gt;提示：你最喜欢的城市？&lt;/i&gt;&lt;/p&gt; : null&#125;</span><br><span class="line"> &lt;Form /&gt;</span><br><span class="line"> &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">   setShowHint(!showHint);</span><br><span class="line"> &#125;&#125;&gt;&#123;(showHint) ? &quot;隐藏提示&quot; : &quot;显示提示&quot;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这种就叫删除，因为换成了新的组件，React 会进行首次渲染：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;isPaused ? (</span><br><span class="line">    &lt;p&gt;待会见！&lt;/p&gt; </span><br><span class="line">) : (</span><br><span class="line">    &lt;Counter /&gt; </span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>注意，如果某组件的父元素改变了，由于 DOM 会重新生成，对 React 来说，也是首次绘制，这也算删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;isFancy ? (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;Counter isFancy=&#123;true&#125; /&gt; </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">) : (</span><br><span class="line">&lt;section&gt;</span><br><span class="line">&lt;Counter isFancy=&#123;false&#125; /&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><p>以上两点就告诉我们如何保存 State：<strong>如果你想在重新渲染时保留 state，几次渲染中的树形结构就应该相互“匹配”</strong>，属性的变化则不会影响 state。</p><p>到这里就能解释早在 1.1 中的约定：<strong>组件不可嵌套定义</strong>。因为如果嵌套定义，例如下面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function MyComponent &#123;</span><br><span class="line">    const [counter, setCounter] = useState(0);</span><br><span class="line">    </span><br><span class="line">    function MyTextField() &#123;</span><br><span class="line">        const [text, setText] = useState(&#x27;&#x27;);</span><br><span class="line">        </span><br><span class="line">        return (</span><br><span class="line">            &lt;input</span><br><span class="line">                value=&#123;text&#125;</span><br><span class="line">                onChange=&#123;e=&gt;setText(e.target.value)&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;MyTextField/&gt;</span><br><span class="line">            &lt;button onCLick=&#123;()=&gt;&#123;</span><br><span class="line">                setCounter(counter + 1)</span><br><span class="line">            &#125;&#125;&gt;Clicked &#123;counter&#125; times&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么每次渲染时，<code>MyTextField</code> 函数<strong>本身的内存地址每次都不一样</strong>，那么相当于每次渲染 <code>MyTextField</code> 组件都会被移除，从头开始渲染，这就直接导致 state <strong>丢失</strong>。</p><h3 id="3-4-2-重置"><a href="#3-4-2-重置" class="headerlink" title="3.4.2 重置"></a>3.4.2 重置</h3><p>上面讨论 state 的保留的情况。考虑实际应用时的另一种情况：<br>假设有一个组件收集用户输入。但是你需要实现 “切换用户” 的功能。在不销毁组件的情况下，组件的 state 会被保存。那么我们如何在 DOM 树的同一位置上重置组件的 state？</p><p>有两种思路：<strong>要么把组件渲染在不同位置，要么使用 <code>key</code> 在指定组件身份，确保切换 <code>key</code> 时 React 会移除并重新生成组件</strong>。</p><ol><li><p>不同位置渲染：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;isPlayerA &amp;&amp;</span><br><span class="line">    &lt;Counter person=&quot;Taylor&quot; /&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#123;!isPlayerA &amp;&amp;</span><br><span class="line">    &lt;Counter person=&quot;Sarah&quot; /&gt;</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">    setIsPlayerA(!isPlayerA);</span><br><span class="line">&#125;&#125;&gt;</span><br></pre></td></tr></table></figure><p>如上，注意和 3.4.1 的例子的区别。我们在多个用户的情况可以通过列表组织。</p></li><li><p>使用 <code>key</code> 重置 state：我们不仅在列表中使用 <code>key</code> 来帮助 React 更好地管理 entries，在普通的组件 / 元素中也能使用，React 会根据 <code>key</code> 来区分组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;isPlayerA ? (</span><br><span class="line">  &lt;Counter key=&quot;Taylor&quot; person=&quot;Taylor&quot; /&gt;</span><br><span class="line">) : (</span><br><span class="line">  &lt;Counter key=&quot;Sarah&quot; person=&quot;Sarah&quot; /&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p><strong>值得注意的是，<code>key</code> 不是全局唯一的。它只能指定在同一父组件间的区别</strong>。</p></li></ol><hr><p>到这里，state 的保存和重置机制的利用，我们已经很清楚了。但是如果我们就想<strong>在一个组件被移除后，仍然保留它的 state，直到它下次被创建呢</strong>？</p><p>还有几种思路：</p><ol><li>利用 CSS 隐藏不需要的组件，这样它实际上不会被移除；</li><li>使用不会被移除的父组件来保存信息；</li><li>使用 原生 JavaScript 中定义的 <code>localStorage</code>，即使用 cookie 来保存。这样即使关闭了页面也能恢复。</li></ol><h2 id="3-5-Reducer-统一状态管理"><a href="#3-5-Reducer-统一状态管理" class="headerlink" title="3.5 Reducer 统一状态管理"></a>3.5 Reducer 统一状态管理</h2><p>本节将遇到 <strong>第二个 React Hook</strong>，它的作用非常重要：<strong>统一管理 React 事件处理器</strong>。</p><p>要知道，在 React 中使用闭包 + 内联事件处理器，这样的定义在事件处理器的数量少的时候非常方便书写。但是如果事件处理器的数量过多，那么代码可读性和可维护性将大大降低。这主要是因为 JSX 将页面布局和事件处理逻辑放在一起了。</p><p>而 React 库提供了一个新的 Hook，它允许你<strong>将事件处理器从 UI 声明中抽离出来，使得项目的事件处理系统<u>更容易调试、更可读、更有可维护性</u></strong>。</p><p>它就是 <code>useReducer</code>。Reducer 是处理状态的另一种方式，它相当于将我们的 <strong>事件处理函数 和 状态 打包了起来</strong>。</p><h3 id="3-5-1-useReducer-的基本使用"><a href="#3-5-1-useReducer-的基本使用" class="headerlink" title="3.5.1 useReducer 的基本使用"></a>3.5.1 <code>useReducer</code> 的基本使用</h3><p>使用 reducers 管理状态与直接设置状态略有不同。它不是通过设置状态来告诉 React “要做什么”，而是通过事件处理程序 dispatch 一个 “action” 来指明 “用户刚刚做了什么”，而状态更新逻辑则保存在<strong>其他地方</strong>，实现了状态管理逻辑和 UI 的抽离。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useReduce &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// `yourReducer` 是等会需要定义的总的事件管理的函数（你可以自己命名），所有事件处理函数 dispatch 都会到这里</span><br><span class="line">// `initialState` 是 `state`（你也可以自己命名）的初值</span><br><span class="line">const [state, dispatch] = useReducer(yourReducer, initialState);</span><br></pre></td></tr></table></figure><p>事件处理函数只需要调用 <code>dispatch</code>，传入 <code>action</code> 对象，告诉之后的 <code>yourReducer</code> 发生了什么。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispath(</span><br><span class="line">    // action 对象（普通的 JS Object），可以自己定义，但要保证你在 yourReducer 能知道发生了什么</span><br><span class="line">    &#123;</span><br><span class="line">        /* 描述发生事件的类别 */</span><br><span class="line">        type: &#x27;what_happened&#x27;,</span><br><span class="line">        /* 其他字段描述改变的信息 */</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>另一边的事件管理函数 <code>yourReducer</code> 则处理调用 <code>dispatch</code> 的动作，要求声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function yourReducer(state, action) =&gt; newState</span><br></pre></td></tr></table></figure><p>该函数会被 <code>dispatch</code> 触发（内部触发），React 库自动添加第一个参数 <code>state</code> 即当前组件的当前状态，<code>action</code> 等同于之前传入 <code>dispatch</code> 的对象。</p><p>React 会将组件的 state 设置为状态管理函数 <code>yourReducer</code> 的返回值 <code>newState</code>；</p><p>这样，我们可以把 <code>yourReducer</code> 定义在 UI 组件以外的文件中，提升代码可读性和可维护性。</p><h3 id="3-5-2-Reducer-设计规范"><a href="#3-5-2-Reducer-设计规范" class="headerlink" title="3.5.2 Reducer 设计规范"></a>3.5.2 Reducer 设计规范</h3><ul><li><p>值得注意的是，<strong>Reducer 和 渲染函数一样，都在<u>渲染时运行</u>（包括你 dispatch 的 actions 也会等待到下一次渲染时进行）</strong>，因此在 <strong>异步方面和 <code>useState</code> 不一样 —— reducers 内部不允许使用异步操作、定时器等</strong>；</p><blockquote><p><code>alert</code> 等函数也不能使用。因为严格模式下，React 会重复执行 2 次渲染函数，确保渲染函数具有幂等性。在 reducers 内部写 <code>alert</code> 极有可能会被调用 2 次。</p></blockquote></li><li><p>和 <code>useState</code> 一致的是，允许修改状态，并且应该使用新的可变数据类型，或者不可变数据类型；</p></li><li><p>每个 action 只应该对应一个用户交互动作，方便代码调试；</p></li></ul><blockquote><p>JavaScript JSON 对象操作小技巧：</p><p>当 JSON 中的键恰好是某个变量中的值，那么可以使用 <code>[var]</code> 计算出值，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">messages</span>: &#123;</span><br><span class="line">  ...state.<span class="property">messages</span>,</span><br><span class="line">  [state.<span class="property">selectedId</span>]: action.<span class="property">message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-6-Context-自定义参数传播"><a href="#3-6-Context-自定义参数传播" class="headerlink" title="3.6 Context: 自定义参数传播"></a>3.6 Context: 自定义参数传播</h2><p>在某些场景下，例如为深层的组件传递参数，如果采用 1.4 的普通 <code>props</code> 的参数传递，那么实际操作起来会非常麻烦，并且不易维护。</p><p>我们可以使用新的 Hook <code>useContext</code> 来实现数据在组件树上的传递。</p><h3 id="3-6-1-useContext-基本使用"><a href="#3-6-1-useContext-基本使用" class="headerlink" title="3.6.1 useContext 基本使用"></a>3.6.1 <code>useContext</code> 基本使用</h3><p>使用主要分成 3 步：</p><ol><li><p>使用如下方法创建 context 上下文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createContext &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export const LevelContext = createContext(&lt;defaultValue&gt;);</span><br></pre></td></tr></table></figure></li><li><p>读取 context 值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useContext &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; LevelContext &#125; from &#x27;./XXX.js&#x27;;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">export default function Widget() &#123;</span><br><span class="line">    const level = useContext(LevelContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过现在只能读到默认值，我能否由父组件向子组件传递一定的 context 值？</p></li><li><p>父控件提供 context 值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;LevelContext.Provider value=&#123;level&#125;&gt;</span><br><span class="line">&lt;/LevelContext.Provider&gt;</span><br></pre></td></tr></table></figure><p><strong>这告诉 React：“如果在该组件中的任何子组件请求 <code>LevelContext</code>，给他们这个 <code>level</code>。”组件会使用 UI 树中在它上层最近的那个 <code>&lt;LevelContext.Provider&gt;</code> 传递过来的值。</strong></p></li></ol><h3 id="3-6-2-Context-的使用场景"><a href="#3-6-2-Context-的使用场景" class="headerlink" title="3.6.2 Context 的使用场景"></a>3.6.2 Context 的使用场景</h3><ul><li><strong>主题：</strong> 如果你的应用允许用户更改其外观（例如暗夜模式），你可以在应用顶层放一个 context provider，并在需要调整其外观的组件中使用该 context。</li><li><strong>当前账户：</strong> 许多组件可能需要知道当前登录的用户信息。将它放到 context  中可以方便地在树中的任何位置读取它。某些应用还允许你同时操作多个账户（例如，以不同用户的身份发表评论）。在这些情况下，将 UI  的一部分包裹到具有不同账户数据的 provider 中会很方便。</li><li><strong>路由：</strong> 大多数路由解决方案在其内部使用 context 来保存当前路由。这就是每个链接“知道”它是否处于活动状态的方式。如果你创建自己的路由库，你可能也会这么做。</li><li><strong>状态管理：</strong> 随着你的应用的增长，最终在靠近应用顶部的位置可能会有很多 state。许多遥远的下层组件可能想要修改它们。通常将 reducer 与 context 搭配使用来管理复杂的状态并将其传递给深层的组件来避免过多的麻烦。</li></ul><p>对于最后一条，也是最难的一条，我们将单独描述。</p><p>Context 不仅可以存放不可变数据类型，还能放 <strong>state + dispatch</strong>，这样能够实现组件树下的各个子组件都可以直接读取 states 和 dispatch，无需担心引用问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;Written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt; MDN Doc &amp;amp;&amp;amp; React Doc&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Web" scheme="https://sjtuxhw.top/tags/Web/"/>
    
    <category term="JavaScript" scheme="https://sjtuxhw.top/tags/JavaScript/"/>
    
    <category term="React" scheme="https://sjtuxhw.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript入门笔记-(2)</title>
    <link href="https://sjtuxhw.top/2024/02/25/JavaScript%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/"/>
    <id>https://sjtuxhw.top/2024/02/25/JavaScript%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/</id>
    <published>2024-02-25T03:25:22.000Z</published>
    <updated>2024-02-27T07:33:19.299Z</updated>
    
    <content type="html"><![CDATA[<p><i>Written by SJTU-XHW</i></p><p><i>Reference: </i>《Professional JavaScript for Web Developers》 3rd Edition</p><p><i>本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h2 id="Chapter-7-简单使用-DOM"><a href="#Chapter-7-简单使用-DOM" class="headerlink" title="Chapter 7. 简单使用 DOM"></a>Chapter 7. 简单使用 DOM</h2><p>假设你学习了初级数据结构，那么把 HTML 页面想象成一个以元素为结点的一般树。JavaScript DOM 操作就是操作这个文档树，达到改变前端页面的目的。</p><p>在浏览器运行的 JavaScript 引擎中，全局运行环境中会自动设置一个变量 <code>document</code>（DOM 对象），操作它就是在动态操作 HTML 页面。</p><h3 id="7-1-基本操作"><a href="#7-1-基本操作" class="headerlink" title="7.1 基本操作"></a>7.1 基本操作</h3><blockquote><p>假设你学习了 CSS 的基础用法。</p></blockquote><ul><li><p><code>document.querySelector(&lt;selectorStr&gt;)</code>：JavaScript DOM 中的重要方法，document 对象的 按选择器查找 HTML 中的元素（CSS 中有效的所有选择器，除了伪类选择器都行）；</p><blockquote><p>如果有多个符合选择器的对象，那么只会返回一个。想要返回全部，请使用 <code>querySelectorAll() -&gt; NodeList (or Array)</code>；</p><p>注：还有一些老方法 <code>getElementById</code>、<code>getElementByTagName</code> 不建议使用，因为太多太繁了，有这个方法足够了。</p></blockquote></li><li><p><code>&lt;Node&gt;.textContent</code>：很多元素，例如 <code>div</code>、<code>button</code>、<code>p</code>、<code>a</code> 等等，可以通过对 DOM 结点设置这个属性来达到更改文本的目的。前提是这个元素能够显示文本；</p></li><li><p><code>&lt;Node&gt;.href</code>：很多含有 <code>href</code> 属性的元素可以用这种方法更改链接，类似地，<code>src</code> 等属性也可以如此更改；</p></li><li><p><code>&lt;Node&gt;.classList</code>：获取结点的 <code>class</code> 属性列表，相当于 <code>&lt;Node&gt;.className.split(&quot; &quot;)</code> 再转为 <code>DOMTokenList</code>；</p><blockquote><p>对于 <code>DOMTokenList</code>，与 JavaScript 原生数组不一样，它有自己的属性、方法：</p><ul><li><code>DOMTokenList.length</code>（<strong>只读</strong>）；</li><li><code>DOMTokenList.item(idx)</code>；</li><li><code>DOMTokenList.contains(token)</code>；</li><li><code>DOMTokenList.add(token[, token2, ...])</code>；</li><li><code>DOMTokenList.remove(...)</code>；</li><li><code>DOMTokenList.toggle(token)</code>：<strong>修改属性非常方便的选择！！</strong>，若 <code>token</code> 存在其中，则删除并返回 false；若不存在，则添加并返回 true；</li><li><code>DOMTokenList.forEach(&lt;callback&gt;)</code>；</li></ul></blockquote></li><li><p>网页刷新：<code>document.location.reload()</code>；</p></li></ul><h3 id="7-2-创建新结点"><a href="#7-2-创建新结点" class="headerlink" title="7.2 创建新结点"></a>7.2 创建新结点</h3><p>一般分三步走：</p><ol><li>创建结点 DOM 对象：<code>document.createElement(&lt;element-type&gt;)</code>；</li><li>设置结点对象属性：<code>&lt;Node&gt;.attr = ...</code>；</li><li>向指定结点对象追加新的对象：<code>&lt;Node&gt;.appendChild(&lt;Node&gt;)</code>；</li></ol><h3 id="7-3-移动、删除结点"><a href="#7-3-移动、删除结点" class="headerlink" title="7.3 移动、删除结点"></a>7.3 移动、删除结点</h3><p>注意一个问题：<strong>DOM 对象引用与 HTML 元素一一对应</strong>。因此除非你使用 <code>&lt;Node&gt;.cloneNode()</code>，否则，之前新建的结点对象如果再一次 <code>appendChild</code>，那么它会移动到父结点的底部，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sect = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;section&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> para = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">para.<span class="property">textContent</span> = <span class="string">&quot;We hope you enjoyed the ride.&quot;</span>;</span><br><span class="line">sect.<span class="title function_">appendChild</span>(para);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间添加了一些结点</span></span><br><span class="line"></span><br><span class="line">sect.<span class="title function_">appendChild</span>(para); <span class="comment">// para 会被移动到 sect 的底部，而非出现副本</span></span><br></pre></td></tr></table></figure><p>删除结点就使用：<code>&lt;parentNode&gt;.removeChild(&lt;Node&gt;)</code>，如果不知道父元素，那么可以借助 <code>parentNode</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Node</span>&gt;.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(&lt;<span class="title class_">Node</span>&gt;);</span><br></pre></td></tr></table></figure><h3 id="7-4-改变结点样式"><a href="#7-4-改变结点样式" class="headerlink" title="7.4 改变结点样式"></a>7.4 改变结点样式</h3><p>JavaScript 可以通过修改 DOM 对象的属性来修改其 CSS 样式。</p><p>有两种方法可以实现：</p><ul><li><p><code>&lt;Node&gt;.style</code> 属性本身是个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">para.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&quot;white&quot;</span>;</span><br><span class="line">para.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;black&quot;</span>;</span><br><span class="line">para.<span class="property">style</span>.<span class="property">padding</span> = <span class="string">&quot;10px&quot;</span>;</span><br><span class="line">para.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&quot;250px&quot;</span>;</span><br><span class="line">para.<span class="property">style</span>.<span class="property">textAlign</span> = <span class="string">&quot;center&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;Node&gt;.setAttribute(&lt;attrName&gt;, &lt;attrValue&gt;)</code>；</p><blockquote><p>对应有 <code>getAttribute</code>；它们不止能改 CSS 样式（<code>style</code> 属性），其他属性也能改；</p></blockquote></li></ul><p><strong>个人建议使用后一种，因为不需要额外记忆内置变量名</strong>。</p><h2 id="Chapter-8-事件"><a href="#Chapter-8-事件" class="headerlink" title="Chapter 8. 事件"></a>Chapter 8. 事件</h2><p>事件是 JavaScript 能够响应用户行为的重要手段之一。</p><p>事件可能有以下几种：</p><ul><li>用户选择、点击或将光标悬停在某一元素上。</li><li>用户在键盘中按下某个按键。</li><li>用户调整浏览器窗口的大小或者关闭浏览器窗口。</li><li>网页结束加载。</li><li>表单提交。</li><li>视频播放、暂停或结束。</li><li>发生错误。</li></ul><p>为了对一个事件做出反应，就要在 JavaScript 中附加一个<strong>事件处理器</strong>。它通常是自己创建的、<strong>已注册的</strong>一个函数。具体使用方法举个例子：</p><h3 id="8-1-注册、移除事件处理器"><a href="#8-1-注册、移除事件处理器" class="headerlink" title="8.1 注册、移除事件处理器"></a>8.1 注册、移除事件处理器</h3><p>假设 HTML 上有个按钮：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;sbtn groupt&quot;</span>&gt;</span></span><br><span class="line">    Click Me</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button.sBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">random</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &amp; (num + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* JavaScript 中注册事件处理器的方法。下次如果该对象有动作，则立即调用这个函数。 */</span></span><br><span class="line"><span class="comment">/* 事件类型：click，回调函数：匿名 */</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> randCtl = <span class="string">`rgb(<span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>)`</span>;</span><br><span class="line">    <span class="comment">/* document 对象 body 元素 -&gt; style 属性 -&gt; backgroundColor */</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = randCtl;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>知识补充</strong>: JavaScript 模板字符串（反引号引起的字符串）</p><ul><li><p>相当于 shell 中的单引号字符串、python 的 <code>f</code> 格式化字符串。</p></li><li><p>可以向其中嵌入变量（<code>$&#123;js_variable&#125;</code>）而无需加法运算符；</p></li></ul></blockquote><p>于是我们认识了注册事件处理器的函数：<code>&lt;DOMObj&gt;.addEventListener(&lt;event-type&gt;, &lt;func&gt;)</code>；</p><p>除了上面提到的 <code>click</code> 事件，<code>button</code> 元素常用的还有：</p><ul><li><code>&quot;mouseover&quot; / &quot;mouseout&quot;</code>（即 hover in / hover out）；</li><li><code>&quot;focus&quot; / &quot;blur&quot;</code>（即按钮聚焦、失焦，常见用 tab 的情况）；</li><li><code>&quot;dblclick&quot;</code>（即双击）；</li><li><code>&quot;submit&quot;</code>（对表单中的按钮而言，触发了 <code>&quot;click&quot;</code> 就接连触发了 <code>&quot;submit&quot;</code>）；</li></ul><p>其实 <code>&quot;click&quot;</code> 事件几乎对其他所有元素都可用；</p><p>还有一些事件只有特定元素有，例如 <code>&quot;play&quot;</code> 事件只有 <code>&lt;video&gt;</code>、<code>&lt;audio&gt;</code> 元素有；</p><hr><p>相对地，我们可以移除指定的事件处理器：<code>removeEventListener(&lt;event-type&gt;, &lt;func&gt;)</code>；</p><p>这就像 Qt 的信号-槽机制中的 <code>connect</code> 和 <code>disconnect</code>，就连 “一对多”、“多对一”、“一对一” 等原则也与 Qt 一致，不再赘述。</p><p>⚠⚠ <strong>友情提醒</strong> ⚠⚠</p><p>不要使用内联事件处理器（写在 HTML 中的事件处理器），它们已经被 deprecated 了，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;It was deprecated!&#x27;);&quot;</span>&gt;</span></span><br><span class="line">  click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-2-事件对象"><a href="#8-2-事件对象" class="headerlink" title="8.2 事件对象"></a>8.2 事件对象</h3><p>JavaScript 解释器在回调某个事件处理器时，会自动向参数列表中传入 <code>event / evt / e</code>（三个都行，开发时为了可读性请选择一个），</p><p>事件对象有个常用属性：</p><ul><li><code>event.target</code>：相当于 Qt 中信号-槽机制的 <code>event.sender</code>，返回发送方对象；</li><li><code>event.key</code>：相当于 Qt <code>QKeyEvent::key()</code>，就是触发键击信号的键；</li></ul><blockquote><p>对常见的 DOM 元素，例如 <code>div</code>、<code>p</code>，可以设置 <code>&lt;DOMObj&gt;.textContent</code> 改变文本值；</p></blockquote><p>那么我们使用事件对象有什么用？</p><p>和 Qt 一样，答案是自定义默认的事件处理。有些默认的事件处理器（例如表单按钮的 <code>&quot;submit&quot;</code> 动作），开发者不好取消，我们可以通过事件对象的方法 <code>event.preventDefault()</code> 来阻止默认动作、进行自定义：</p><p>例如对这个表单，我们想让用户必须填写 <code>First name</code> 和 <code>Last name</code>，缺一不可，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;fname&quot;</span>&gt;</span>First name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;fname&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;lname&quot;</span>&gt;</span>Last name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;lname&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们就能这样阻止表单的默认提交动作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;form&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fname = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> lname = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;lname&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> para = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"></span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断字符串为空也可以用 String.length（但要确保不是 null） */</span></span><br><span class="line">  <span class="keyword">if</span> (fname.<span class="property">value</span> === <span class="string">&quot;&quot;</span> || lname.<span class="property">value</span> === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    para.<span class="property">textContent</span> = <span class="string">&quot;You need to fill in both names!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="8-3-事件传递"><a href="#8-3-事件传递" class="headerlink" title="8.3 事件传递"></a>8.3 事件传递</h3><p>我们类比 Qt 的信号-槽机制，在 Qt 中，一个事件 / 信号被捕获后，进入事件 / 信号处理函数，我们以 <code>bool eventFilter(QEvent* event, QObject* obj)</code> 为例，如果该函数返回 <code>true</code>，表示事件处理结束，事件不会再向父控件传递，反之则会。</p><p>在 JavaScript 中，<strong>事件传递行为和 Qt 相近</strong>，只是<strong>收到并处理后，开发者无法自定义事件的传递行为，一定会继续向父元素传递</strong>。</p><p>在一些情况下，由于父子元素需要控制事件比较复杂，如果不控制事件的传递，很有可能引发一些问题，例如我们想做个页面包含一个视频，最初它为隐藏状态；还有一个标记为“显示视频”的按钮。我们希望有如下交互：</p><ul><li>当用户单击“显示视频”按钮时，显示包含视频的盒子，但不要开始播放视频。</li><li>当用户在视频上单击时，开始播放视频。</li><li>当用户单击盒子内视频以外的任何区域时，隐藏盒子。</li></ul><p>如果这么写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">    显示视频</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span>    <span class="comment">&lt;!-- 使用 CSS 的 class 属性标记隐藏内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">&quot;XXX.webm&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            您的浏览器不支持 webm 格式视频！</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;video&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DOM 对象的另一个重要属性 classList */</span></span><br><span class="line"><span class="comment">/* 可以得到对应的 HTML 元素的 class 属性列表（空格间隔），返回对象是 Array */</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> box.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;hidden&quot;</span>));</span><br><span class="line"><span class="comment">/* video 元素的 BOM 方法： play() */</span></span><br><span class="line">video.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> video.<span class="title function_">play</span>());</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> box.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;hidden&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p><strong>知识补充 1</strong>: JavaScript DOM 对象 <code>classList</code> 属性；</p><p><strong>知识补充 2</strong>: JavaScript <code>video / audio</code> 元素对应的 BOM 方法 <code>play()</code>；</p></blockquote><p>我们点击显示视频是没问题的，但是有个问题是，当我们点击视频开始播放的时候，容器会被隐藏！这是因为 <code>video</code> 空间在 <code>div</code> 内部，点击操作会传递到 <code>div</code> 中，相当于同时触发了两个事件处理器。</p><p>所以 JavaScript 中的解决方案是 <code>event.stopPropagation()</code>，在事件处理器中，可以停止事件自动地向父元素传播。</p><p>上面的 JavaScript 改成这样就能实现目的了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;video&quot;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> box.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;hidden&quot;</span>));</span><br><span class="line"></span><br><span class="line">video.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  video.<span class="title function_">play</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> box.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;hidden&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>⚠⚠注意：<code>event.target</code> 在事件传递中保持不变，始终代表最内层的元素（事件传递的第一个收到的元素、事件捕获的最后一个捕获到的元素）⚠⚠</strong></p><h3 id="8-4-JavaScript-中的-“事件捕获”"><a href="#8-4-JavaScript-中的-“事件捕获”" class="headerlink" title="8.4 JavaScript 中的 “事件捕获”"></a>8.4 JavaScript 中的 “事件捕获”</h3><p>JavaScript 中，除了事件传递，还有一种术语叫 “事件捕获”，它和事件传递 <strong>唯一区别</strong> 是，“事件捕获” 的事件传递方向是从父元素到子元素，与一般事件传递方向正好相反。</p><p>你只有在 <code>addEventListener</code> 注册事件处理器时加上第三参数 <code>&#123; capture: true &#125;</code> 才会启用。</p><blockquote><p>你问为什么有这两种传递方式？唉，早期厂商的浏览器互不兼容（Netscape 只使用事件捕捉，而 Internet Explorer 只使用事件冒泡）。</p><p>现在的 W3C 指定标准后，将这两种方式都保留下来了，不过默认都是普通的事件传递。</p></blockquote><p><strong>因此这里强烈建议，在编写代码时，尽量使用一种传递方式，增强可读性和可维护性</strong>。</p><h2 id="Chapter-9-JavaScript-异步"><a href="#Chapter-9-JavaScript-异步" class="headerlink" title="Chapter 9. JavaScript 异步"></a>Chapter 9. JavaScript 异步</h2><p>网页端程序的响应速度极其重要，因此网页端应用采用异步的重要性不言而喻。</p><h3 id="9-1-认识旧式异步实现：基于事件处理器-和-回调函数"><a href="#9-1-认识旧式异步实现：基于事件处理器-和-回调函数" class="headerlink" title="9.1 认识旧式异步实现：基于事件处理器 和 回调函数"></a>9.1 认识旧式异步实现：基于事件处理器 和 回调函数</h3><p>上一章我们已经接触到了 JavaScript 异步编程的一种形式：事件处理器。它不会立即被调用，而是在事件发生时才被调用。只要我们把事件换成某个对象的状态变化，那么就变成了异步程序。</p><p>于是 <strong>早期的异步 API 就是采用这种方式</strong>：通过给 <code>XMLHttpRequest</code> 对象附加事件监听器来让程序在请求进展和最终完成时获得通知。</p><blockquote><p><code>XMLHttpRequest</code> 有 <code>loadend</code> 事件；</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;xhr&quot;</span>&gt;</span>click to send request<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;reload&quot;</span>&gt;</span>reload<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">readonly</span> <span class="attr">class</span>=<span class="string">&quot;event-log&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.event-log&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#xhr&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  log.<span class="property">textContent</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">addEventListener</span>(<span class="string">&quot;loadend&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    log.<span class="property">textContent</span> = <span class="string">`<span class="subst">$&#123;log.textContent&#125;</span> finished! Status Code:<span class="subst">$&#123;xhr.status&#125;</span>`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  xhr.<span class="title function_">open</span>(</span><br><span class="line">    <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json&quot;</span>,</span><br><span class="line">  );</span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line">  log.<span class="property">textContent</span> = <span class="string">`<span class="subst">$&#123;log.textContent&#125;</span> request was sent\n`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#reload&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  log.<span class="property">textContent</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span>.<span class="title function_">reload</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还有一种异步实现的方式：回调函数。它是一个<u>被传递到另一个函数中的、会在适当的时候被调用的</u>函数。</p><p>我们看到之前很多参数名 <code>&lt;callback&gt;</code> 都是回调函数。</p><p>那么为什么这种方法被舍弃了呢？考虑这样的场景：<strong>假设有 N 个独立的步骤，需要异步执行，它们必须按照一定的执行次序执行。那么当使用回调函数的方式实现的时候，它们就会深度嵌套。</strong>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doStep1</span>(<span class="params">init, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// DO SOMETHING</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStep2</span>(<span class="params">init, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// DO SOMETHING</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStep3</span>(<span class="params">init, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// DO SOMETHING</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doOperation</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">doStep1</span>(params, <span class="function">(<span class="params">result1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">doStep2</span>(result1, <span class="function">(<span class="params">result2</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">doStep3</span>(result2, <span class="function">(<span class="params">result3</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Result: <span class="subst">$&#123;result3&#125;</span>`</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doOperation</span>();</span><br></pre></td></tr></table></figure><p>这样不仅不美观，而且极大影响代码可读性、可维护性（尤其是 JavaScript 语言本身就难以调试）；</p><p>所以，大多数现代的异步 API 都不使用上述的方法。现在的 JavaScript 异步编程的基础是 Promise；</p><h3 id="9-2-新式异步：JavaScript-Promise"><a href="#9-2-新式异步：JavaScript-Promise" class="headerlink" title="9.2 新式异步：JavaScript Promise"></a>9.2 新式异步：JavaScript Promise</h3><p>JavaScript 的 Promise 对象是 <strong>一个由异步函数返回的、可以向我们指示当前操作所处的状态的</strong> 对象。</p><p>JavaScript 中有很多异步 API 都是基于 Promise 的，它们在被调用后会进行一些操作并立即返回 Promise 对象。开发者可以通过将处理函数附加到返回的 Promise 对象上实现回调。</p><h4 id="9-2-1-API-fetch"><a href="#9-2-1-API-fetch" class="headerlink" title="9.2.1 API fetch()"></a>9.2.1 API <code>fetch()</code></h4><p><code>[global.]fetch()</code> 方法就是一个基于 Promise 的、替代 <code>XMLHttpRequest</code> 的 API，我们直接看一个使用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fetchPromise);</span><br><span class="line"></span><br><span class="line">fetchPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Respond received: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Request sent...&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的程序分成几个步骤：</p><ol><li>使用 <code>fetch</code>（默认）向指定网页发送 GET 请求，返回 Promise 对象存放在 <code>fetchPromise</code> 中；</li><li>输出 Promise 对象，能看到 <code>Promise &#123; &lt;state&gt;: &quot;pending&quot; &#125;</code>，说明 Promise 对象有属性 <code>state</code> 来查看异步任务是否完成；</li><li>使用 <strong><code>Promise.then(&lt;callback&gt;)</code></strong> 向 Promise 对象加入回调函数，<code>callback</code> 函数传入参数就是之前使用 <code>fetch</code> API 规定的返回内容（<code>Response</code> 对象）；</li></ol><blockquote><p>总结：<code>fetch(&lt;url&gt;, &lt;options&gt;) -&gt; Promise -&gt;&gt; Response</code>；</p></blockquote><h4 id="9-2-1-Ex-知识补充：Response-对象"><a href="#9-2-1-Ex-知识补充：Response-对象" class="headerlink" title="9.2.1-Ex 知识补充：Response 对象"></a>9.2.1-Ex 知识补充：Response 对象</h4><p>常见实例属性（几乎都是只读，想要自定义请从构造函数传入）：<code>body</code>、<code>headers</code>、<code>status</code>、<code>url</code>（响应的 URL）、<code>redirected</code>（可以在 <code>fetch</code> 第二参数中禁止重定向：<code>&#123;redirect: &quot;error&quot;&#125;</code>）等；</p><p>常见的<strong>实例方法</strong>：</p><ul><li><code>Response.blob() -&gt; Promise -&gt;&gt; stream</code>：<strong>这是个异步 API，可以读取响应体中的二进制数据</strong>；</li><li><code>Response.clone()</code>：完全复制 Response 对象，唯一区别是内存地址和引用不同；</li><li><code>Response.formData() -&gt; Promise -&gt;&gt; FormData</code>：<strong>以表单数据的方式读取响应体，最终返回 <code>FormData</code> 对象</strong>（和之前的 <code>Array</code>、<code>DOMTokenList</code> 又不一样，自己查 API）；</li><li><code>Response.json() -&gt; Promise -&gt;&gt; JSON</code>：<strong>以 JSON 数据的方式读取响应体，最终返回原生 <code>JSON</code> 对象</strong>；</li><li><code>Response.text() -&gt; Promise -&gt;&gt; USVString</code>：<strong>以字符串的方式读取响应体，最终返回类似 <code>String</code> 的对象，总是 UTF-8</strong>；</li></ul><h4 id="9-2-2-链式-Promise"><a href="#9-2-2-链式-Promise" class="headerlink" title="9.2.2 链式 Promise"></a>9.2.2 链式 Promise</h4><p>Promise 更加优雅的原因是，它的 <code>then</code> 实例方法也会返回 Promise 对象，不过这个对象指示 <code>then</code> 回调函数执行的情况。这样，我们就可以链式地使用 Promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fetchPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> jsonPromise = response.<span class="title function_">json</span>();</span><br><span class="line">  jsonPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但我们在上一节中，回调实现遇到 “深层嵌套” 的问题，Promise 好像没有解决？它只不过换成了 <code>then</code> 的嵌套？</p><p>实际上不是这样，我们可以借助返回 Promise 的机制多返回几次，把上面的代码改写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fetchPromise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="9-2-3-Promise-异常处理"><a href="#9-2-3-Promise-异常处理" class="headerlink" title="9.2.3 Promise 异常处理"></a>9.2.3 Promise 异常处理</h4><p>众所周知，网络就是不稳定的，不可避免会出现一些问题。Promise 作为异步的基石，必然要进行异常处理。</p><p>以 <code>fetch()</code> 为例，它本身可能因为各种原因出现错误（如没有网络连接、或 URL 本身存在问题），而我们也需要自己在特定的业务逻辑中主动抛出错误。</p><p>对此，<code>Promise.catch(&lt;callback&gt;)</code> 就能解决问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fetchPromise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP Request error: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Failed to fetch product list: <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>⚠⚠<strong>请注意，只要异步操作中接收到了服务器的响应（不管是什么，例如服务器返回的 404），除非开发者自己抛出错误，否则 Promise 认为 fulfilled</strong>⚠⚠</p><h4 id="9-2-4-Promise-state"><a href="#9-2-4-Promise-state" class="headerlink" title="9.2.4 Promise state"></a>9.2.4 Promise state</h4><p>之前我们在 9.2.1 中看到 Promise 对象有个属性 <code>state</code> 指示异步任务的完成情况。</p><p>它有 3 种状态：</p><ul><li>pending：挂起等待，异步任务进行中；</li><li>fulfilled：异步任务成功完成，此时会执行 <code>then</code> 传入的回调函数；</li><li>rejected：异步任务执行失败，此时会执行 <code>catch</code> 传入的回调函数，如果没有就向上抛出错误；</li></ul><p>fulfilled 和 rejected 统称 settled；</p><h4 id="9-2-5-合并-Promise"><a href="#9-2-5-合并-Promise" class="headerlink" title="9.2.5 合并 Promise"></a>9.2.5 合并 Promise</h4><p>除了上面提到的链式使用 Promise，可能还会遇到一些情况，需要合并使用多个 Promise。</p><ul><li><code>Promise.all(Array[Promise]) -&gt; Promise -&gt;&gt; Array[...]</code> ，等待所有的 Promise 全部 settled，并且只有全部的 Promise 都 fulfilled，这个 Promise 才会 fulfilled，否则 rejected；</li><li><code>Promise.any(Array[Promise]) -&gt; Promise -&gt;&gt; ...</code>，等待<strong>任意一个 Promise settled</strong>，该 Promise 最终状态取决于这个等到的 Promise；</li></ul><h4 id="9-2-6-显式等待-Promise"><a href="#9-2-6-显式等待-Promise" class="headerlink" title="9.2.6 显式等待 Promise"></a>9.2.6 显式等待 Promise</h4><p>如果在一些业务逻辑中必须使用同步编程（例如没有最终返回值就进行不下去），那么就可以对 Promise 进行等待处理。对 Promise 的等待必须放在 <strong>异步函数（用关键字 <code>async</code> 修饰，箭头函数也是这样）</strong> 中，在返回 Promise 的 API 前加上 <code>await</code> 关键字，这样程序能够等待在这里并且返回最终对象；同时错误也会成为普通的 JavaScript 异常向上抛出。</p><p>⚠⚠<strong>请注意，异步函数只能返回 Promise 对象。</strong>⚠⚠</p><p>为什么必须要在异步函数中？因为异步函数有等待，也允许开发者在外面等待 / 继续使用 Promise 处理这个异步函数。</p><p><code>await</code> 和 Promise 链一样，强制异步操作串行完成（一般应用在 “前一个步骤是后一个步骤的参数“ 的情况）。如果不需要串行，<code>Promise.all</code> 可以有更好的性能。</p><h4 id="9-2-7-自定义基于-Promise-的异步-API"><a href="#9-2-7-自定义基于-Promise-的异步-API" class="headerlink" title="9.2.7 自定义基于 Promise 的异步 API"></a>9.2.7 自定义基于 Promise 的异步 API</h4><p>这里需要了解 Promise 的构造函数 <code>Promise(&lt;executor&gt;)</code>，<code>executor</code> 的需求参数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">resolve, reject</span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure><p><code>resolve</code>、<code>reject</code> 都是函数，<strong>分别对应传入 <code>then</code>、<code>catch</code> 中的函数</strong>。</p><p>当一个新的 Promise 对象被创建（<code>new</code>）后，它立即执行 <code>executor</code> 中的内容（通常是耗时任务）。</p><p>如果 <code>executor</code> 内调用了 <code>resolve</code>（也就是 <code>then</code> 传入的函数），那么 Promise 对象自动进入 fulfilled 状态；反之如果调用了 <code>reject</code> 或者<strong>抛出错误（自动调用 <code>reject</code>）</strong>，就相当于调用了 catch 传入的函数，或向上抛出了错误。</p><h4 id="9-2-8-异步的补充：JavaScript-多线程"><a href="#9-2-8-异步的补充：JavaScript-多线程" class="headerlink" title="9.2.8 异步的补充：JavaScript 多线程"></a>9.2.8 异步的补充：JavaScript 多线程</h4><p>这里只是介绍一下，JavaScript 中存在 <code>workers</code> 机制，例如 <code>dedicated workers</code>，创建线程，但不能访问 DOM 等等。有需要的话自行查询文档。</p><h2 id="Chapter-10-JavaScript-简单保存会话状态"><a href="#Chapter-10-JavaScript-简单保存会话状态" class="headerlink" title="Chapter 10. JavaScript 简单保存会话状态"></a>Chapter 10. JavaScript 简单保存会话状态</h2><p>基本上有 2 种简单的方法：<code>localStorage</code>、<code>sessionStorage</code>。</p><p>二者唯一的区别是，<strong>前者是 cookie，可以在用户关闭页面后，仍然保留数据，直到下一次打开就能还原数据；后者是 session，数据只保留到用户关闭此会话（即浏览器的标签页）</strong>。</p><p>使用方法是一样的：</p><ul><li>定义对象：直接赋值。<code>myStorage = [window.]localStorage;</code></li><li><strong>异常：<code>SecurityError</code>，用户拒绝使用 cookie / session</strong>；</li><li>设置键值：<code>localStorage.setItem(&quot;&lt;key&gt;&quot;, &quot;&lt;value&gt;&quot;);</code></li><li>获取键值：<code>localStorage.getItem(&quot;&lt;key&gt;&quot;, &quot;&lt;value&gt;&quot;);</code></li><li>移除键值：<code>localStorage.removeItem(&quot;&lt;key&gt;&quot;);</code></li><li>清空：<code>locaStorage.clear();</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;Written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt;《Professional JavaScript for Web Developers》 3rd Edition&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Web" scheme="https://sjtuxhw.top/tags/Web/"/>
    
    <category term="JavaScript" scheme="https://sjtuxhw.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript入门笔记</title>
    <link href="https://sjtuxhw.top/2024/02/20/JavaScript%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://sjtuxhw.top/2024/02/20/JavaScript%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-20T13:17:09.000Z</published>
    <updated>2024-02-27T07:18:14.945Z</updated>
    
    <content type="html"><![CDATA[<p><i>Written by SJTU-XHW</i></p><p><i>Reference: </i>《Professional JavaScript for Web Developers》 3rd Edition</p><p><i>本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h2 id="Chapter-0-JavaScript-起源"><a href="#Chapter-0-JavaScript-起源" class="headerlink" title="Chapter 0. JavaScript 起源"></a>Chapter 0. JavaScript 起源</h2><h3 id="0-1-历史"><a href="#0-1-历史" class="headerlink" title="0.1 历史"></a>0.1 历史</h3><ul><li><p>Web 流行早期（上世纪末），Internet 用户上网速度 28.8 KB/s，但网页的大小和复杂性却不断增加。为完成简单的表单验证而频繁地与服务器交换数据只会加重用户的负担。于是，为了<strong>开发一种客户端语言，仅用来处理表单的简单验证工作</strong>，Netscape 公司在其发布的应用 Netscape Navigator 2 上加入一种脚本语言 <code>LiveScript</code>，认为是 JavaScript 的前身<strong>之一</strong>；</p></li><li><p>1995 年 2 月，Netscape 与 Sun 合作，为了搭上媒体热炒 Java 的顺风车，临时把 <code>LiveScript</code> 改名为 <code>JavaScript</code>，这就是 JavaScript 1.0；</p></li><li><p>其后不久，微软在自家作品 IE 3 中加入 <code>JScript</code>（是 JavaScript 的另一种实现） ，标志着 JavaScript 作为一门语言，其开发向前迈进了一大步。</p><blockquote><p>同时也有个严重问题：此时世界上有了两个不同的 JavaScript 版本：Netscape Navigator 中的 <code>JavaScript</code>、Internet Explorer 中的 <code>JScript</code>。与 C 及其他编程语言不同，当时还没有标准规定 JavaScript 的语法和特性。</p></blockquote></li><li><p>1997 年，欧洲计算机制造商协会（ECMA）制定了新脚本语言标准，称为 <code>ECMA-262</code>，即 <code>ECMAScript</code>。此后，各个浏览器开发厂商以此标准作为各自 JavaScript 实现的基础，衍生出一系列的版本和生态。</p><blockquote><p>注：此后因为各种复杂的历史原因，JavaScript 和 JScript 相当久之后才渐渐兼容 ECMAScript；</p></blockquote></li><li><p>此后 Mozilla 公司继承了 Netscape 的项目，继续开发 JavaScript 和 Netscape/Mozilla 浏览器；而如今，含 IE 内核的浏览器仍使用的是 JScript，不过现在它们都 ECMAScript 兼容了。</p></li></ul><h3 id="0-2-JavaScript-实现"><a href="#0-2-JavaScript-实现" class="headerlink" title="0.2 JavaScript 实现"></a>0.2 JavaScript 实现</h3><p>虽然 JavaScript 和 ECMAScript 通常都被人们用来表达相同的含义，但 JavaScript 的含义却比 ECMA-262 中规定的要多得多（<strong>JavaScript 的 3 个主要组成部分</strong>）：</p><p><img src="imgs/js_struct.png" height="150px"></p><h4 id="0-2-1-ECMAScript：JavaScript-的标准和核心"><a href="#0-2-1-ECMAScript：JavaScript-的标准和核心" class="headerlink" title="0.2.1 ECMAScript：JavaScript 的标准和核心"></a>0.2.1 ECMAScript：JavaScript 的标准和核心</h4><ul><li><strong>与浏览器没有依赖关系，不包含输入输出定义</strong>；</li><li>规定内容包括：<strong>语法、类型、语句、关键字、保留字、操作符、对象</strong>；</li><li>提供此语言解释器的环境称为 <strong>宿主环境</strong>；</li><li><strong>ECMAScript 兼容</strong>：指满足以下几点的宿主环境：<ul><li>支持 ECMA-262 描述的所有“类型、值、对象、属性、函数以及程序句法和语义”；</li><li>支持 Unicode 字符标准；</li><li>添加 ECMA-262 没有描述的“更多类型、值、对象、属性和函数”；</li><li>支持 ECMA-262 没有定义的“程序和正则表达式语法”（也就是说，<strong>可以修改和扩展内置的正则表达式语法</strong>）；</li></ul></li></ul><h4 id="0-2-2-DOM：文档对象模型"><a href="#0-2-2-DOM：文档对象模型" class="headerlink" title="0.2.2 DOM：文档对象模型"></a>0.2.2 DOM：文档对象模型</h4><ul><li><p><strong>DOM 是一种针对 XML 但经过扩展用于 HTML 的 <u>API（应用程序编程接口）</u>，并不只是针对 JavaScript，很多其他语言也实现了</strong>；</p><blockquote><p>知识补充：XML 格式</p><p>一种和 HTML 类似的<strong>多层节点文档结构</strong>，结构中每个组分都是某种类型的节点，这些节点又包含不同类型数据。</p></blockquote></li><li><p><strong>ECMAScript 的扩展实现之一</strong>，依赖于 HTML / XML 页面；</p></li><li><p>功能：核心规定的是<strong>如何映射基于 XML 的文档结构，以便简化对文档中任意部分的访问和操作</strong>；</p><blockquote><p>DOM 的这个功能比较抽象，具体来说就是将：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在编程层面抽象为：</p><p><img src="imgs/dom_example1.png" height="240px"></p><p>提供了一些方便的接口函数，让开发人员可以轻松自如地删除、添加、替换或修改任何节点。</p></blockquote></li><li><p>DOM 级别：DOM API 的标准历史版本；</p><ul><li><p>DOM 1 级：由 <strong>DOM Core</strong> 和 <strong>DOM HTML</strong> 两个模块 API 构成。前者<strong>规定如何映射基于 XML 的文档结构（操作函数声明）</strong>，后者<strong>添加了针对 HTML 的对象和方法</strong>；</p></li><li><p>DOM 2 级：在 DOM 1 级基础上<strong>扩充了鼠标 及 GUI Events、Ranges、Iteration（迭代 DOM 文档的方法）等模块，增加对 CSS 的操作接口支持</strong>；</p><blockquote><ol><li>DOM Views，DOM 视图接口；</li><li>DOM Events，事件处理接口；</li><li>DOM Style，基于 CSS <strong>为指定元素应用样式</strong>的接口；</li><li>DOM Traversal and Range：遍历和操作文档树的接口；</li></ol></blockquote></li><li><p>DOM 3 级：在 DOM 2 基础上，<strong>引入了以统一方式加载和保存文档的方法（DOM Save &amp; Load）</strong>、<strong>新增了验证文档的方法（DOM Validator）</strong>、扩展了 DOM Core（支持 XML 1.0 规范，涉及 XML Infoset、XPath 和 XML Base）；</p></li></ul></li><li><p>其他 DOM 标准 API：</p><ul><li>SVG（可伸缩矢量图）；</li><li>MathML（数学标记语言）；</li><li>SMIL（同步多媒体集成语言）；</li></ul></li></ul><h4 id="0-2-3-BOM：浏览器对象模型"><a href="#0-2-3-BOM：浏览器对象模型" class="headerlink" title="0.2.3 BOM：浏览器对象模型"></a>0.2.3 BOM：浏览器对象模型</h4><ul><li><p>定义：一组支持访问和操作浏览器窗口的 API；</p></li><li><p><strong>ECMAScript 的扩展实现之一</strong>，依赖于浏览器；</p><blockquote><p>早期漏洞出现频繁，兼容性不强，因为没有相关标准。</p><p>HTML 5 出现后，BOM 的框架才列入正式规范；但目前各个浏览器实现方式几乎都不同；</p></blockquote></li><li><p>功能：</p><ul><li>弹出新浏览器窗口的功能；</li><li>移动、缩放和关闭浏览器窗口的功能；</li><li>提供浏览器详细信息的 navigator 对象；</li><li>提供浏览器所加载页面的详细信息的 location 对象；</li><li>提供用户显示器分辨率详细信息的 screen 对象；</li><li>对 cookies 的支持；</li><li>像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象；</li></ul></li></ul><h4 id="0-3-总结"><a href="#0-3-总结" class="headerlink" title="0.3 总结"></a>0.3 总结</h4><p>JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成：</p><ul><li>ECMAScript，由 ECMA-262 定义，提供核心语言功能；</li><li>文档对象模型（DOM），提供访问和操作 XML 文档 和 HTML 页面内容的方法和接口；</li><li>浏览器对象模型（BOM），提供与浏览器交互的方法和接口。</li></ul><p>JavaScript 的这三个组成部分，在当前五个主要浏览器（IE、Firefox、Chrome、Safari 和 Opera）中 都得到了不同程度的支持。</p><p>其中，所有浏览器对 ECMAScript 第 3 版的支持大体上都还不错，而对 ECMAScript 5 的支持程度越来越高，但对 DOM 的支持则彼此相差比较多。对已经正式纳入 HTML5 标准的 BOM 来说，尽管各浏览器都实现了某些众所周知的共同特性，但其他特性还是会因浏览器而异。</p><blockquote><p>接下来开始加速，请做好准备。</p></blockquote><h2 id="Chapter-1-在-HTML-中使用-JavaScript"><a href="#Chapter-1-在-HTML-中使用-JavaScript" class="headerlink" title="Chapter 1. 在 HTML 中使用 JavaScript"></a>Chapter 1. 在 HTML 中使用 JavaScript</h2><h3 id="1-1-lt-script-gt-元素"><a href="#1-1-lt-script-gt-元素" class="headerlink" title="1.1 &lt;script&gt; 元素"></a>1.1 <code>&lt;script&gt;</code> 元素</h3><p>使用 <code>&lt;script&gt;</code> 元素将 javascript 加入 HTML：最早由 Netscape 实现，后来作为 HTML 4.01 的规范；</p><p><code>&lt;script&gt;</code> 元素的属性：</p><ul><li><code>async</code>：可选，表示<strong>立即下载这个脚本，但是异步（不妨碍其他内容加载和运行）</strong>，仅对外部脚本有效，内嵌无效；</li><li><code>defer</code>：可选，表示<strong>当前脚本可以延迟到文档完全解析、显示后再执行</strong>，仅对外部脚本有效；</li><li><code>src</code>：可选，表示<strong>这个脚本是外部脚本，并指定位置</strong>；</li></ul><p>还有两种可以不掌握：</p><ul><li><code>type</code>：可选，脚本语言类型，一般没啥用，默认值就是 <code>text/javascript</code>；</li><li><code>charset</code>：可选，指定字符集（由于大多数浏览器会忽略这个属性，所以很少有人用）；</li></ul><blockquote><p><code>&lt;script&gt;</code> 元素的位置：</p><p>过去经典做法是将所有脚本标签放在 HTML 的 <code>&lt;head&gt;</code> 元素中，这意味着需要等所有脚本加载完毕才会开始解析页面，这对 JS 代码很多的页面而言，延迟明显；</p><p>现代的 Web 应用将 JS 放在 <code>&lt;body&gt;</code> 元素最后的部分，在用户看来提升了页面加载速度；</p></blockquote><h3 id="1-2-内联脚本-和-外部脚本"><a href="#1-2-内联脚本-和-外部脚本" class="headerlink" title="1.2 内联脚本 和 外部脚本"></a>1.2 内联脚本 和 外部脚本</h3><p>内联的方法很简单，只有一种可能的写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>内联 js 脚本需要注意几点</strong>：</p><ul><li><p>内联 js 脚本会在  HTML 中<strong>顺序解释（同步）</strong>，即不执行完不向下解释 HTML；</p></li><li><p>不允许在内联脚本中<strong>以任何形式出现 <code>&lt;/script&gt;</code>，除非有转义符</strong>，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sayScript</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;&lt;\/script&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>外部 js 脚本必须有 <code>src</code> 属性，<code>defer</code> 和 <code>async</code> 可选；</p><p>注意，外部 js 脚本也会在 HTML 中顺序解释，<strong>但 <code>defer</code> 和 <code>async</code> 可能改变这个行为</strong>；</p><p>在 HTML 中嵌入 JavaScript 代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含 JavaScript 代码。不过，并不存在必须使用外部文件的硬性规定，但支持使用外部文件的人多会强调如下优点：</p><ul><li>可维护性：遍及不同 HTML 页面的 JavaScript 会造成维护问题。但把所有 JavaScript 文件都放在 一个文件夹中，维护起来就轻松多了。而且开发人员因此也能够在不触及 HTML 标记的情况下， 集中精力编辑 JavaScript 代码；</li><li>可缓存性：浏览器能够根据具体的设置缓存链接的所有外部 JavaScript 文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度；</li><li>适应性：通过外部文件来包含 JavaScript 无须使用 XHTML 或注释 hack。HTML 和 XHTML 包含外部文件的语法是相同的；</li></ul><h3 id="1-3-lt-noscript-gt-元素"><a href="#1-3-lt-noscript-gt-元素" class="headerlink" title="1.3 &lt;noscript&gt; 元素"></a>1.3 <code>&lt;noscript&gt;</code> 元素</h3><p>在不支持 Javascript 的浏览器 / 浏览器禁用 Javascript 的情况下，<strong>才会</strong>显示 <code>&lt;noscript&gt;</code> 中的元素。</p><h2 id="Chapter-2-Javascipt-基本语法"><a href="#Chapter-2-Javascipt-基本语法" class="headerlink" title="Chapter 2. Javascipt 基本语法"></a>Chapter 2. Javascipt 基本语法</h2><blockquote><p>本章的语法标准以 ECMA-262 实现的 ECMAScript 为基础。</p></blockquote><h3 id="2-1-细节"><a href="#2-1-细节" class="headerlink" title="2.1 细节"></a>2.1 细节</h3><ul><li><p><strong>区分大小写</strong>；</p></li><li><p><strong>变量标识符命名规范</strong>：与 C / C++ 等一般语言不同的是，ECMAScript 允许美元符号（<code>$</code>）存在于变量名的任何位置，包括开头。其他都与普通语言相同，例如不用关键字、不用数字开头、建议驼峰命名等；</p><blockquote><p><script type="math/tex">abc`、`a$b`、`ab</script> 都是合法的变量标识符；</p></blockquote></li><li><p>注释：同 C / C++；</p></li><li><p><strong>严格模式</strong>：在<strong>脚本全文开头（作用于全文）</strong> / <strong>某函数体中（作用于该函数）</strong>使用 <code>&quot;use strict&quot;;</code>，代表编译指示（pragma），启用 Javascript 的严格模式；</p><blockquote><p>本质上为 Javascript 定义了一种不同的解释和执行模型，对 ECMAScript 3 中的 UB 也能得到处理，但是对某些不安全的行为会抛出错误，执行结果也可能与普通模式不同。这个区别会在以后的讨论时及时指出。</p></blockquote></li><li><p>语句建议<strong>使用分号结尾</strong>（虽然没有分号解释器一般也可以识别，但还是规范点好），语句块的模式和 C / C++ 都一样，以花括号表示语句块；</p></li></ul><h3 id="2-2-关键字和保留字"><a href="#2-2-关键字和保留字" class="headerlink" title="2.2 关键字和保留字"></a>2.2 关键字和保留字</h3><p><img src="imgs/keywords.png" width="500px"></p><p><img src="imgs/reserved.png" width="500px"></p><p>此外，ECMAScript 5 中新增 <code>let</code> 和 <code>yield</code> 为保留字；</p><p><strong>在严格模式下，不允许使用 <code>eval</code> 和 <code>arguments</code> 作为标识符或属性名</strong>；</p><h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h3><p>ECMAScript 定义的变量是<strong>松散类型</strong>，即<strong>变量只是一个占位符，本身可以用来保存任何类型</strong>。</p><ul><li><p>变量声明：使用 <code>var</code> 关键字；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br></pre></td></tr></table></figure><p>像这样<strong>未初始化的值会保存一个特殊的值：<code>undefined</code></strong>（之后讨论这是什么）；</p></li><li><p>变量定义（声明 + 初始化）；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">// 允许多个定义，与 C / C++ 类似</span></span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">&quot;world&quot;</span>,</span><br><span class="line">    age = <span class="number">100</span>,</span><br><span class="line">    cdn = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>变量的定义或声明不建议忽略 <code>var</code>，因为在严格模式下会抛出错误</strong>；</p><h3 id="2-5-数据类型"><a href="#2-5-数据类型" class="headerlink" title="2.5 数据类型"></a>2.5 数据类型</h3><p>ECMAScript 中的基本数据类型有 5 种：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>；另外有一种<strong>复杂数据类型：<code>Object</code>，本质上由一组无序键值对构成，相当于小型的 “类” 的概念</strong>；</p><p>因为 ECMAScript 的类型动态性，就没有必要定义其他数据类型了。</p><h4 id="2-5-1-typeof-保留字：数据类型检查"><a href="#2-5-1-typeof-保留字：数据类型检查" class="headerlink" title="2.5.1 typeof 保留字：数据类型检查"></a>2.5.1 <code>typeof</code> 保留字：数据类型检查</h4><p>使用 <code>typeof &lt;anything&gt;</code> （也允许用括号括起来）可以返回这几种字符串：<code>&quot;undefined&quot;</code>、<code>&quot;boolean&quot;</code>、<code>&quot;string&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;object&quot;</code>、<code>&quot;function&quot;</code>；</p><ul><li>注 1：<code>Null</code> 类型实际上是一个<strong>空的 <code>Object</code> 引用</strong>，因此 <code>typeof null</code> 返回 <code>&quot;object&quot;</code>；</li><li>注 2：函数实际上也是一类 <code>Object</code>，但有一些特殊的属性，因此 ECMAScript 有必要在 <code>typeof</code> 输出中单独区分开；</li></ul><h4 id="2-5-2-Undefined-类型"><a href="#2-5-2-Undefined-类型" class="headerlink" title="2.5.2 Undefined 类型"></a>2.5.2 Undefined 类型</h4><p>此类型<strong>只有一个值</strong>：<code>undefined</code>，常常在访问未初始化变量时出现。可以用等号操作符（<code>==</code>）判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br><span class="line"><span class="title function_">alert</span>(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>也可自行给定 <code>undefined</code> 值（不过没必要）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="literal">undefined</span>;</span><br><span class="line"><span class="title function_">alert</span>(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>未定义 / 声明的变量</strong> 和 <strong>声明了却 undefined 的变量</strong> 不一样。前者直接使用是错误的，这和大多数语言一样。</p><p>但是，对未声明的变量可以用 <code>typeof</code>，并且返回的也是 <code>&quot;undefined&quot;</code>，尽管它们不能使用；<strong>因此尽量初始化是个好习惯，这样我们就能知道哪些值是没声明的，而不是没初始化</strong>。</p><h4 id="2-5-3-Null-类型"><a href="#2-5-3-Null-类型" class="headerlink" title="2.5.3 Null 类型"></a>2.5.3 Null 类型</h4><p>此类型<strong>也只有一个值</strong>：<code>null</code>，表示空的对象的引用；</p><p><strong>建议总是为 将来要存储 <code>object</code> 的变量赋予该值，一方面体现了 <code>null</code> 的意义，另一方面有助于区分 <code>null</code> 和 <code>undefined</code></strong>。</p><p>很奇怪的是，我们没法用相等运算符区分 <code>null</code> 和 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="literal">null</span> == <span class="literal">undefined</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是，这不妨碍我们在操作一个变量前检查它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;    <span class="comment">// 同时拦截 null 和 undefined</span></span><br><span class="line">    <span class="comment">// 对 obj 对象操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-4-Boolean-类型"><a href="#2-5-4-Boolean-类型" class="headerlink" title="2.5.4 Boolean 类型"></a>2.5.4 Boolean 类型</h4><p>此类型<strong>只有两个值</strong>：<code>true</code>（真值）、<code>false</code>（假值）；</p><p>其他任何类型都可以通过<strong>类型转换函数（<code>Boolean()</code>）</strong>或者<strong>条件语句自动类型转换</strong>转为 Boolean 值：</p><ul><li>会转换为 <strong>假值</strong> 的值：String 类型<strong>空字符串</strong>、Number 类型 <strong>0 和 <code>NaN</code></strong>、Object 类型 <strong><code>null</code></strong>、Undefined 类型 <strong><code>undefined</code></strong>；</li><li>其余所有值都会转为 <strong>真值</strong>（包括后面提到的 <code>Infinity</code> 等等）；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Boolean</span>(message));    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (msg) &#123;    <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-5-Number-类型"><a href="#2-5-5-Number-类型" class="headerlink" title="2.5.5 Number 类型"></a>2.5.5 Number 类型</h4><h5 id="数值运算-和-数值范围"><a href="#数值运算-和-数值范围" class="headerlink" title="数值运算 和 数值范围"></a>数值运算 和 数值范围</h5><p>声明相当于 C/C++ 中的整型 + 浮点数；使用方法（如 8 进制、10 进制、16 进制表示方法、浮点数科学计数法等）、注意事项（不用浮点数作比较等等）与 C/C++ 也相同；</p><p>数值范围：<code>Number.MIN_VALUE(5e-324) ~ Number.MAX_VALUE(1.8e+308)</code>，超出范围的值会被转为特殊的正数 <code>Infinity</code> 或负数 <code>-Infinity</code>（均无法继续运算）；</p><p>一般计算很难出现正负无穷的情况，真正进行大数计算时，可以用 <code>isFinite()</code> 检查；</p><h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><p>此外，还有一个 <code>NaN</code>（Not a Number），是个特殊数值，用来表示<strong>一个本该返回数值的操作数未返回的情况（这样省去抛出错误的情况）</strong>；</p><p><code>NaN</code> 也不能使用相等运算符比较：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="title class_">NaN</span> == <span class="title class_">NaN</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>ECMAScript 提供了专门的判断函数 <code>isNaN()</code>，<strong>工作原理是对传入参数转为 <code>Number</code> 类型运算，如果不能运算，那么返回 <code>true</code></strong>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="number">10</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="literal">true</span>));    <span class="comment">// 可转为数值 1，false</span></span><br></pre></td></tr></table></figure><p><strong>不可思议的是，<code>isNaN()</code> 可以作用于对象 <code>Object</code>，先调用 <code>valueOf()</code> 方法确定返回值是否能转换，然后调用 <code>toString()</code> 再看结果是否能转换</strong>；</p><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><ul><li><code>Number()</code>：将任何数据类型转为数值；</li><li><code>parseInt(String)/parseFloat(String)</code>：将字符串转为相应数值；</li></ul><p>无法转换的返回 <code>NaN</code>，这就解释了 <code>isNaN()</code> 的工作原理；</p><p><strong>但是 <code>null</code> 可以转换为 0</strong>；</p><h4 id="2-5-6-String-类型"><a href="#2-5-6-String-类型" class="headerlink" title="2.5.6 String 类型"></a>2.5.6 String 类型</h4><h5 id="字符串直接量"><a href="#字符串直接量" class="headerlink" title="字符串直接量"></a>字符串直接量</h5><p>可以使用单引号或双引号完成，和 PHP 不同，这两种引号没区别；</p><h5 id="常用属性-方法"><a href="#常用属性-方法" class="headerlink" title="常用属性 / 方法"></a>常用属性 / 方法</h5><p>对一个 String 类型，它具有以下几种常用属性：</p><ul><li><code>length</code>；</li></ul><p>和以下的常用方法：</p><ul><li><p>加法拼接运算；</p><blockquote><p>注意，对于运算过程有个处理机制，例如下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;</span><br></pre></td></tr></table></figure><p>首先创建一个能容纳 10 个字符的新字符串，</p><p>然后在这个字符串中填充”Java”和”Script”，</p><p>最后一步是销毁原来的字符串”Java”和字符串”Script”（二者其后的引用数为 0）；</p></blockquote></li><li><p><code>at</code>、<code>indexOf</code>、<code>substr</code>、<code>endsWith</code>…… 等其他一切和 Java String 很接近的函数；</p></li></ul><h5 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h5><p>除了 <code>Null</code> 和 <code>Undefined</code> 类（它们直接返回），其他所有类型都有 <code>toString()</code>；</p><p>此外，可以通过 <code>+</code> 运算符隐式转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ageStr = <span class="string">&quot;&quot;</span> + <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h4 id="2-5-7-Object-类型"><a href="#2-5-7-Object-类型" class="headerlink" title="2.5.7 Object 类型"></a>2.5.7 Object 类型</h4><h5 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h5><p>和 Java 语言一样，使用 <code>new</code> 关键字申请创建新对象，但是回收无需开发者操心：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>同样和 <code>java.lang.Object</code> 一样的是，<code>Object</code> 也是所有 object 的父类，它也有如下的抽象方法：</p><ul><li><p>constructor：构造函数，前面的 <code>Object()</code> 就是 <code>Object</code> 类的构造函数；</p></li><li><p><code>hasOwnProperty(propertyName: String)</code>：检验当前对象中是否存在自定义的属性名；</p><blockquote><p>类似 Python <code>hasattr</code>；</p></blockquote></li><li><p><code>isPrototypeOf(object: Object)</code>：检验当前 object 对象是否是传入的 <code>object</code> 的<strong>原型（Prototype）</strong>；</p></li><li><p><code>propertyIsEnumerable(propertyName: String)</code>：检验当前 object 对象的属性是否能使用 <code>for-in</code> 循环进行迭代遍历；</p></li><li><p><code>toLocaleString/toString()</code>：转字符串；</p></li><li><p><code>valueOf()</code>：默认返回自身；</p></li></ul><p><strong>值得注意的是， ECMAScript 中没有定义如 BOM、DOM 中的对象，因为它们是 宿主对象，所以某些宿主对象可能不继承于 <code>Object</code></strong>；</p><p><strong>属性键值对添加方法</strong></p><p>直接使用作用域运算符（<code>.</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">test</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p><strong>属性键值对删除方法</strong></p><p>使用关键字 <code>delete</code>：<strong>对于几乎所有对象、简单类型都能这么做，解释器立即删除为该变量分配的空间，相当于回到未声明前</strong>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">test</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">age</span>;    <span class="comment">// obj.age -&gt; undefined</span></span><br></pre></td></tr></table></figure><h3 id="2-6-操作符"><a href="#2-6-操作符" class="headerlink" title="2.6 操作符"></a>2.6 操作符</h3><p>自增、自减、一元加减、位运算、普通四则运算、取模、复合赋值运算符、三目运算符几乎全部与 C/C++ 相同；</p><p>有几个点需要注意：</p><ul><li><p><strong>逻辑操作和 C/C++ 不一样，返回的值不一定是 Boolean：只要有一个 operand 不是 Boolean 类型，那么返回的就是真值的数据类型</strong>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">0</span> || <span class="number">123</span>;    <span class="comment">// test == 123</span></span><br></pre></td></tr></table></figure></li><li><p><code>Infinity</code> 与普通数的四则运算关系、<code>+0</code> 和 <code>-0</code> 的运算关系，与 C++ 浮点数相同；</p></li><li><p><strong>数据加法运算 和 字符串拼接运算</strong> 在某些情况需要开发者手动明确语义，防止发生意想不到的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">5</span> + <span class="string">&quot;5&quot;</span>;    <span class="comment">// 字符串拼接，test == &quot;55&quot;</span></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="number">5</span> + <span class="built_in">parseInt</span>(<span class="string">&quot;5&quot;</span>, <span class="number">8</span>);    <span class="comment">// Number 运算，test == 10</span></span><br></pre></td></tr></table></figure></li><li><p><strong>比较运算符在应用在两个 operand 都是 String 的方面，会将 String 的每一位字符拿出 ASCII / Unicode 进行比较</strong>；如果有一个是 Number 类型，解释器都会尝试将另一个转为 Number，转换不成就变成 NaN，而 <strong>NaN 参与比较运算永远是 false</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="string">&quot;23&quot;</span> &lt; <span class="number">3</span>;        <span class="comment">// false, 23 &gt; 3</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&quot;23&quot;</span> &lt; <span class="string">&quot;3&quot;</span>;    <span class="comment">// true, u&#x27;2&#x27; &lt; u&#x27;3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res1 = <span class="title class_">NaN</span> &lt; <span class="number">3</span>;        <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> res2 = <span class="title class_">NaN</span> &gt;= <span class="number">3</span>;     <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>⚠ <strong>在比较运算时，如果一个是 number 另一个是 string，则统一换为 number；而在加法运算时，如果一个是 number 另一个是 string，则统一换为 string</strong>（都不论前后顺序）；</p></li><li><p>逗号操作符：<strong>和 C / C++ 一样，用于声明多个变量。但是 ECMAScript 还能用于赋值，但只返回表达式最后一项</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>);    <span class="comment">// num == 0</span></span><br></pre></td></tr></table></figure></li></ul><p>ECMAScript 中还引入了几种不同的运算符：</p><ul><li><strong>在比较运算符中，除了相等运算符（<code>==</code>），还有全等运算符（<code>===</code>）</strong>；这是因为相等运算符比较<strong>会发生自动类型转换，例如 <code>&quot;5&quot; == 5</code> 是 true</strong>，而全等运算符不会转换数据类型。所以必要时，<strong>建议使用全等运算符</strong>；</li><li><strong>ECMAScript 中存在无符号右移 <code>&gt;&gt;&gt;</code> 和无符号右移赋值 <code>&gt;&gt;&gt;=</code></strong>；</li></ul><h3 id="2-7-语句"><a href="#2-7-语句" class="headerlink" title="2.7 语句"></a>2.7 语句</h3><p><code>if-else</code> 语句、<code>while</code> 语句、<code>do-while</code> 语句、<code>for</code> 语句、标签语句、<code>break/continue</code> 语句、<code>switch</code> 语句使用与 C/C++ 相同，但是！</p><p>ECMAScript 中<strong>不存在块级作用域</strong>，这意味着代码块中定义的，在外面也能访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(i);    <span class="comment">// i -&gt; 100</span></span><br></pre></td></tr></table></figure><p>ECMAScript 还具有：</p><ul><li><p><code>for-in</code> 语句：<strong>精准的迭代语句，可以用于枚举 object 的属性（回忆一下，没有顺序）</strong>，<code>for (property in expression) statement;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;    <span class="comment">// BOM window 对象</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(prop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，使用前需要检查 <code>object</code> 不能为 <code>null/undefined</code>，否则在某些浏览器上会报错</strong>；</p></li><li><p><code>with</code> 语句（大型项目不建议使用，因为性能极差，并且可读性差，<strong>并且在严格模式下不允许使用，会视为错误</strong>）：简化多次编写同一个对象的工作；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (location) &#123;</span><br><span class="line">    qs = search.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>qs</code> 会先当作普通局部变量查找，再当作 <code>location</code> 的属性查找；如果找不到再报错；</p></li></ul><h3 id="2-8-函数"><a href="#2-8-函数" class="headerlink" title="2.8 函数"></a>2.8 函数</h3><p>定义语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">arg0, arg1, ..., argN</span>) &#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ECMAScript 中有几个值得注意的点：</p><ul><li><p>和强类型语言不一样，ECMAScript 不关心函数返回值类型、参数类型；</p></li><li><p>和其他众多语言<strong>不一样</strong>，ECMAScript 甚至不关心形参列表究竟是什么，意味着你即便这么定义函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以这样调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="string">&quot;world&quot;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>因为在函数内部维护了 <code>arguments</code> 保留字，它相当于数组（但不是 <code>Array</code> 的实例，类型是 <code>Object</code>），<strong>可以用方括号访问 entry，也可以访问 <code>.length</code> 来看究竟传入了多少参数</strong>，<strong>并且生存周期仅在函数中，超过周期即销毁为 <code>undefined</code></strong>；</p><p>所以形参表存在的唯一作用是方便函数调用传入参数。<strong>这样，尽管 ECMAScript 没有重载的概念、没有函数签名的概念，但事实上也不需要了</strong>（ECMAScript 尝试定义重名函数，只会保留最后一次出现的定义）。</p><p><strong>值得注意的是，通常在函数内修改 <code>arguments</code> 是不规范的行为，在严格模式下会抛出错误</strong>；</p></li></ul><h2 id="Chapter-3-内存问题-与-变量作用域"><a href="#Chapter-3-内存问题-与-变量作用域" class="headerlink" title="Chapter 3. 内存问题 与 变量作用域"></a>Chapter 3. 内存问题 与 变量作用域</h2><h3 id="3-1-变量类型-与-内存"><a href="#3-1-变量类型-与-内存" class="headerlink" title="3.1 变量类型 与 内存"></a>3.1 变量类型 与 内存</h3><p>在 ECMAScript 中，有 2 种变量类型：</p><p><strong>基本类型（前面提到的 5 种基本数据类型）</strong>和 <strong>引用类型</strong>；</p><p>而当解释器执行某个赋值语句时，<strong>必须确定</strong>当前变量是基本类型还是引用类型。这是为什么？</p><p><strong>主要是因为 JavaScript 中，这两种类型的变量在内存中的形态不同。</strong></p><ul><li>对于基本类型的变量（ECMAScript 中包含字符串），其值存放于<strong>解释器运行时环境中</strong>（可以理解为放在<strong>栈内存</strong>上）；</li><li>对于引用类型的变量，创建总需要 <code>new</code> 关键字在<strong>堆内存</strong>中开辟空间。由于 JavaScript 不允许使用地址 / 指针，因此引用类型变量在复制 / 赋值等操作时总是针对引用（相当于 C 中自动完成 <code>*objPtr</code>）、在设置属性操作时总是针对对象（相当于 C 中自动完成 <code>objPtr-&gt;attr</code>）；</li></ul><p>看两个例子就能彻底明白：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = num1;</span><br></pre></td></tr></table></figure><p><img src="imgs/basicCopy.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br></pre></td></tr></table></figure><p><img src="imgs/refCopy.png"></p><p>那么检查一个变量名存放的究竟是基本数据类型还是引用类型，可以使用 <code>typeof</code> 关键字；</p><p>对于返回值为 <code>object / function</code> 的变量而言，它们一定是引用类型变量，其他则是基本类型；</p><p>此外，对于 JavaScript 中的继承关系，有关键字 <code>instanceof</code> 识别：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>);    <span class="comment">/* 内置 Array 类是 Object 的子类 */</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips. 此内容第一次读可以跳过。</p><p>对于正则表达式，不同的 JavaScript 解释器执行 <code>typeof</code> 的结果不同，这是实现标准不同的原因。对于 ECMA-262 标准规定，任何在内部实现 <code>[[Call]]</code> 方法的对象都应该在应用 <code>typeof</code> 操作符时返回 <code>&quot;function&quot;</code>，Safari（&gt; 5）及 Chrome（&gt; 7）满足这条规定，但 IE 和 Firefox 则会返回 <code>&quot;object&quot;</code>； </p></blockquote><h3 id="3-2-动态属性-与-内存"><a href="#3-2-动态属性-与-内存" class="headerlink" title="3.2 动态属性 与 内存"></a>3.2 动态属性 与 内存</h3><p>了解了基本类型 和 引用类型变量在内存中的排布，那么还有一个问题。<strong>既然像 <code>Object</code> 一类的引用类型是在堆内存中的，那么为他们设置属性的时候，它们的属性应该放在哪里？</strong></p><p>其实也是放在堆中的。毕竟它们的属性也是动态的，运行时随时可以添加和删除。</p><p>所以我们看看以下的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">b</span> = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">obj.<span class="property">f</span> = <span class="variable language_">console</span>.<span class="property">log</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = obj;</span><br></pre></td></tr></table></figure><p>等价于 C 的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span>* b;</span><br><span class="line">    <span class="type">void</span> (*f)(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">&#125; *obj, *obj2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    obj = (Object*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Object));</span><br><span class="line">    obj-&gt;a = <span class="number">1</span>;</span><br><span class="line">    obj-&gt;b = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    obj-&gt;b[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>, obj-&gt;b[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>, obj-&gt;b[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>, obj-&gt;b[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    obj-&gt;f = <span class="built_in">printf</span>;</span><br><span class="line">    </span><br><span class="line">    obj2 = obj1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于 C++ 的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    std::string b;</span><br><span class="line">    <span class="built_in">void</span> (*f)(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object &amp;obj = *(<span class="keyword">new</span> Object);</span><br><span class="line">    obj.a = <span class="number">1</span>;</span><br><span class="line">    obj.b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    obj.c = printf;</span><br><span class="line">    </span><br><span class="line">    Object &amp;obj2 = obj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>还有一个问题，基本类型变量能否设置属性呢？直觉上肯定是会报错的。实际上，<strong>不会报错</strong>，但解释器只是<strong>忽略</strong>了此语句。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">name.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">age</span>);    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>所以我们只能对引用类型变量设置动态属性。</p><h3 id="3-3-函数参数传递-与-内存"><a href="#3-3-函数参数传递-与-内存" class="headerlink" title="3.3 函数参数传递 与 内存"></a>3.3 函数参数传递 与 内存</h3><p>在学习 JavaScript 函数时，我们曾经了解到 <code>arguments</code> 内置变量。而参数传递的过程，就是：</p><ul><li>向 <code>arguments</code> 中赋予 <code>0 ~ N</code> 键对应的值；</li><li>向自定义的形式参数赋予对应的值（如果有的话）；</li></ul><p>这些赋值后的变量都是函数局部变量，如果实际参数是一个<strong>基本类型的变量</strong>，那么直接<strong>值传递</strong>；如果实际参数是一个引用类型的变量，那么进行<strong>引用传递</strong>（类似 C++ 中参数自动完成 <code>Type &amp;param</code>）；</p><h3 id="3-4-执行环境-与-变量作用域"><a href="#3-4-执行环境-与-变量作用域" class="headerlink" title="3.4 执行环境 与 变量作用域"></a>3.4 执行环境 与 变量作用域</h3><p>JavaScript 中一个相当重要的概念就是 <strong>执行环境（execution context）</strong>，和 C 中的作用域的思想相近，但不相同。JavaScript 执行环境有以下特征：</p><ul><li><p>执行环境定义了<strong>变量或函数有权访问的其他数据</strong>，<strong>决定了它们各自的行为</strong>；</p></li><li><p>每个执行环境都有一个与之关联的<strong>变量对象（variable object）</strong>，环境中定义的<strong>所有变量和函数</strong>都保存在这个对象中；</p><blockquote><p>类似 Python 的对于一个包的 <code>__dict__</code> 属性；</p><p>与 Python 不同的是，<strong>开发者没法访问这个变量对象，只有解释器才能使用它</strong>；</p></blockquote></li><li><p>JavaScript 最外围的执行环境被称为<strong>全局执行环境</strong>（可以有多个）。不过，根据 ECMAScript 实现所在的宿主环境不同，<strong>表示执行环境的对象</strong>也不一样；</p><blockquote><p><strong>什么是 “表示执行环境的对象”？</strong></p><p>JavaScript 中将保持上下文变量、函数的任务统统交给了对象（<code>Object</code>）。因此将当前执行环境的变量、函数保存的对象就称为 “表示执行环境的对象”；</p><p>例如，如果宿主环境是 web 浏览器（即浏览器提供解释器），那么全局执行环境就是 <code>window</code> 对象（将在后面介绍）；<strong>因此所有的全局变量、函数都作为 <code>window</code> 对象的属性和方法创建</strong>；</p></blockquote></li><li><p>JavaScript 中每个函数都有自己的执行环境。这就类似 C 中的栈帧，区分<strong>局部变量（存放于当前执行环境中的变量）、全局变量（存放于全局执行环境中的变量）</strong>；</p></li><li><p>JavaScript 在此基础上定义了 <strong>作用域链（scope chain）</strong>的概念，定义为用于<strong>保证对执行环境有权访问的所有变量和函数的有序访问</strong>。可以将它理解为 JavaScript 解释器搜索标识符的字典；</p><blockquote><p>每当程序进入一个新执行环境中，解释器会创建一个新的变量对象（前面的规则），而这个对象就位于作用域链的最前端。<strong>因此作用域链的前端，始终都是当前执行的代码所在环境的变量对象</strong>。以函数环境为例，<code>arguments</code> 对象就是最开始的变量对象。</p><p><strong>作用域链越向后，变量对象越靠环境外层。因此全局执行环境的变量对象始终都是作用域链中的最后一个对象。</strong></p><p><strong>这样的链形结构，以及排布顺序，决定了局部变量、全局变量的优先级（和 C 一样）</strong>。</p></blockquote></li><li><p>除了函数，<code>with</code> 语句、<code>try-catch</code> 语句均拥有一个独立的执行环境（或者说一个独立的变量对象），这点和 C 的作用域也相同；</p></li><li>⚠ 和其他语言有差别的是，<strong>JavaScript 没有块级作用域</strong>。也就是说，<strong>除了函数、<code>with</code>、<code>try-catch</code> 块以外的、由花括号封闭的代码块，没有独立的执行环境（或者说独立的变量对象）</strong>，这点和 C 的作用域不同！</li></ul><h3 id="3-5-垃圾回收机制（GC）"><a href="#3-5-垃圾回收机制（GC）" class="headerlink" title="3.5 垃圾回收机制（GC）"></a>3.5 垃圾回收机制（GC）</h3><p>和 Python、Java 一样，JavaScript 具有自动垃圾回收机制，无需像 C / C++ 一样手动回收分配的空间。</p><p><strong>几乎所有自动 GC 都遵循一个理念：按照某个策略<u>预定的时间</u>（定时策略），释放<u>不再继续使用的</u>（标记策略）<u>引用类型变量</u>所占用的空间</strong>；</p><p>所以，这个 GC 机制中有两个需要决定的策略，我们介绍一下常见的策略类型（以下回收的变量都指的是<strong>引用类型</strong>，不再赘述）。</p><h4 id="3-5-1-标记策略"><a href="#3-5-1-标记策略" class="headerlink" title="3.5.1 标记策略"></a>3.5.1 标记策略</h4><p>JavaScript 中有两种常用的标记策略，分别是：<strong>标记清除（mark-and-sweep）、引用计数（reference counting）</strong>；</p><p>所谓标记清除就是：</p><ul><li>当变量在该环境内的时候，标记的是 <strong>进入环境</strong>；</li><li>当变量离开定义它的环境后，标记的是 <strong>离开环境</strong>；</li><li>当定时策略指定的检查时间到的时候，<strong>仅释放所有离开环境的变量的空间</strong>；</li></ul><p>所谓引用计数就是：</p><ul><li>跟踪记录每个变量被引用的次数。当该引用被赋予一个变量名后，该空间的数据引用计数 + 1；反之，如果该变量名改赋其他值，或被显式 delete 时，引用计数 - 1；</li><li>当定时策略指定的检查时间到的时候，<strong>仅释放所有引用计数为 0 的变量的空间</strong>；</li></ul><p>但是，引用计数策略有个严重问题：<strong>循环引用</strong>。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testCirRef</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    obj1.<span class="property">attr1</span> = obj2;</span><br><span class="line">    obj2.<span class="property">attr2</span> = obj1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果采用引用技术方法作为标记策略，那么退出函数体后，<code>obj1</code> 、<code>obj2</code> 的引用计数永不为 0；而且最有趣的问题是，JavaScript 的 DOM、BOM 的对象是使用 C++ 的 COM（Component Object Model，组件对象模型）实现的，它的回收是内置采用引用计数策略的。<strong>这就意味着使用 DOM / BOM 对象时，不可避免地可能产生循环引用</strong>。例如下面使用 DOM 的代码（后面介绍）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;some_element&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">myObject.<span class="property">element</span> = element;</span><br><span class="line">element.<span class="property">someObject</span> = myObject;</span><br></pre></td></tr></table></figure><p>所以书写时要注意循环引用的情况并且在不需要使用的时候及时解开 DOM 对象 和 JavaScript 原生 Object 之间的连接（想象成要像 C 一样手动释放）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.<span class="property">element</span> = <span class="literal">null</span>;</span><br><span class="line">element.<span class="property">someObject</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注：发生循环引用不仅仅有以上的可能，更多可能以后遇到再讨论。</p></blockquote><hr><p>综上原因所述，<strong>标记清除 是 JavaScript 中最常用的 GC 标记策略</strong>（主流浏览器引擎也都是）；</p><p>而引用计数则存在于 COM 实现的对象中（例如 BOM、DOM 对象），在使用时注意检查循环引用的情况，并且及时手动解引用。</p><h4 id="3-5-2-定时策略"><a href="#3-5-2-定时策略" class="headerlink" title="3.5.2 定时策略"></a>3.5.2 定时策略</h4><p>定时策略非常好想，大家肯定都会想到：<strong>周期性回收</strong>就行；但如何确定回收周期非常讲究。</p><p>IE6 浏览器实现的 JavaScript 解释器曾经有个非常严重的性能问题，这就是定时策略没有设计好。他们是这么为 IE6 JavaScript 设计的：</p><blockquote><p>256 个变量、4096 和对象（包括元素），或者 64 KB 的字符串，达到上述任意一个临界值，GC 会被自动触发。</p></blockquote><p>这么设计有什么问题呢？考虑一个问题，假设一个大型 JavaScript 程序的运行时必须使用多于 256 个变量（或者其他超过临界值的条件），那么<strong>垃圾回收例程会被一直持续触发，严重影响性能</strong>。</p><p>后来，自 IE7 及以后的版本，微软将 IE JavaScript 引擎的 GC Routine 改成了：</p><blockquote><ul><li>各项<strong>初始</strong>临界值和以前一致；</li><li>如果垃圾收集例程回收的内存分配量低于15%，则变量、literal 和（或）array 元素的临界值就会<strong>加倍</strong>；</li><li>如果例程回收了85%的内存分配量，则将各种临界值<strong>重置回默认值</strong>；</li></ul></blockquote><p>这样的定时回收策略大大优化了 GC 机制性能。如今不同的 JavaScript 引擎有着不同的实现方式，但思路都大同小异。</p><h4 id="3-5-3-拓展：开发者如何节省内存"><a href="#3-5-3-拓展：开发者如何节省内存" class="headerlink" title="3.5.3 拓展：开发者如何节省内存"></a>3.5.3 拓展：开发者如何节省内存</h4><p>我们知道，抛开借助 COM 对象的循环引用问题，JavaScript 作为一个自动 GC 的语言，是无需开发者关心内存问题的。</p><p>但是，有一点和我们开发 C/C++ 桌面程序有些不一样的地方：<strong>开发者需要有意地节省可用内存</strong>。</p><p>因为，<strong>浏览器的可用内存数量通常要比分配给桌面应用程序的少</strong>。这样做的目的主要是出于安全方面的考虑，目的是防止运行JavaScript 的网页耗尽全部系统内存而导致系统崩溃。</p><p>因此，<strong>确保占用最少的内存可以让页面获得更好的性能</strong>。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。<strong>一旦数据不再有用，最好通过将其值设置为 <code>null</code> 来释放其引用</strong>——这个做法叫做<strong>解除引用（dereferencing）</strong>；</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAction</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> localAction = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    localAction.<span class="property">name</span> = name;</span><br><span class="line">    <span class="keyword">return</span> localAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalAction = <span class="title function_">createAction</span>(<span class="string">&quot;Open Action&quot;</span>);</span><br><span class="line"><span class="comment">/* Do something... */</span></span><br><span class="line"><span class="comment">/* At the end of the block: */</span></span><br><span class="line">globalAction = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>提示：这样做虽然不会立即回收该内存，但能够起到尽早回收的作用，在一定程度上节省了运行时内存。</p></blockquote><h2 id="Chapter-4-内置的引用类型"><a href="#Chapter-4-内置的引用类型" class="headerlink" title="Chapter 4. 内置的引用类型"></a>Chapter 4. 内置的引用类型</h2><p>我们知道，JavaScript 的引用类型，或者说所有原生（naive）类型的父类都是 <code>Object</code>。你可能会想到 Python 中的 <code>Object</code> 终极父类，但实际上，这种说法<strong>不准确</strong>。</p><p>因为 JavaScript 不具备传统的面向对象语言所支持的类和接口等基本结构，通俗来说，<strong>它不支持定义类</strong>，所以不存在 “类” 的说法（<strong>它的超集语言 <code>TypeScript</code> 支持，也很有用</strong>）。</p><p>但矛盾的是，JavaScript 又是个面向对象的语言，所以<strong>你只能使用内置的基本类型、引用类型，并将它们实例化使用</strong>，所以又称<strong>对象定义</strong>。</p><p>像我们之前使用到的引用类型 <code>Object</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>就是在堆中创建了 <code>Object</code> 引用类型的新的<strong>实例</strong>。<code>Object()</code> 就是 <code>Object</code> 引用类型的构造函数。</p><p>到这里，我们可以这么理解 JavaScript 的引用类型：JavaScript 先集成了几个内置的引用类型，然后将它们都写成 C 中的 <code>final</code> 类，不允许定义新类或者继承，只能使用它们。</p><p><strong>所以，JavaScript 内置的引用类型有哪些呢？一共有 7 个方面。</strong></p><h3 id="4-1-Object-引用类型"><a href="#4-1-Object-引用类型" class="headerlink" title="4.1 Object 引用类型"></a>4.1 Object 引用类型</h3><h4 id="4-1-1-实例创建"><a href="#4-1-1-实例创建" class="headerlink" title="4.1.1 实例创建"></a>4.1.1 实例创建</h4><p>有两种创建 <code>Object</code> 引用类型的方法，一种是 <code>new</code> 构造函数创建，另一种是<strong>对象直接量</strong>创建。</p><p>前者的机制我们之前已经解释了无数遍。后者就像 C / C++ 中定义常量一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，如果你愿意的话，其键名加上引号也是<strong>等效</strong>的。</p><p>⚠ <strong>使用对象直接量创建对象时，不会执行对象的构造函数。</strong></p><p>不仅如此，<strong>在传递属性较多、复用次数较少的 <code>Object</code> 对象作函数参数时</strong>，对象直接量更加高效、代码可读性更强：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">testFunc</span>(&#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-1-2-实例访问"><a href="#4-1-2-实例访问" class="headerlink" title="4.1.2 实例访问"></a>4.1.2 实例访问</h4><p><code>Object</code> 引用类型的实例访问也有两种方法，一种是很熟悉的 <strong>点访问法（<code>obj.attr</code>）</strong>，另一种是 <strong>方括号访问法</strong>（<code>obj[&quot;attr&quot;]</code>），但是，除非不得已（例如<strong>属性名中含有空格，无法使用点访问法</strong>），都应该使用点访问法。</p><h3 id="4-2-Array-引用类型"><a href="#4-2-Array-引用类型" class="headerlink" title="4.2 Array 引用类型"></a>4.2 Array 引用类型</h3><p>除了 <code>Object</code>，ECMAScript 最常用的类型估计就是 <code>Array</code> 引用类型。它具有以下特性：</p><ul><li>数组<strong>每一项可以保存任意类型</strong>（强类型语言根本看不到）；</li><li>数组始终有序（自动排序）；</li><li>数组大小自动动态调整。当然，也允许创建时指定初始大小；</li></ul><h4 id="4-2-1-实例创建"><a href="#4-2-1-实例创建" class="headerlink" title="4.2.1 实例创建"></a>4.2.1 实例创建</h4><ul><li><p>默认构造函数：<code>var a = new Array();</code></p></li><li><p>指定初始大小（<code>length</code>）的构造函数：<code>var a = new Array(20);</code></p></li><li><p>指定数组项的构造函数：<code>var a = new Array(&quot;Alex&quot;, &quot;Ben&quot;, &quot;Cindy&quot;);</code></p><blockquote><p>于是我们发现<strong>没法直接</strong>指定只包含一个数字的数组；</p></blockquote></li><li><p><strong>数组 literal</strong>：<code>var a = [&quot;Alex&quot;, &quot;Ben&quot;, &quot;Cindy&quot;];</code></p><blockquote><p>空数组的话 <code>var a = [];</code></p></blockquote></li></ul><h4 id="4-2-2-实例访问"><a href="#4-2-2-实例访问" class="headerlink" title="4.2.2 实例访问"></a>4.2.2 实例访问</h4><p>和 C++ 等其他语言一样。直接 <code>arr[N]</code>；</p><p><strong>数组越界访问不会报错，返回 <code>undefined</code></strong>；</p><p>但 JavaScript 数组有个非常奇妙的特性：<strong><code>length</code> 属性可以修改</strong>。这意味着，直接通过修改 <code>length</code> 就能改变数组大小，进而完成新增、移除末尾项的功能。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alist = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;coconut&quot;</span>];</span><br><span class="line">alist.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(alist[<span class="number">2</span>]);    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>如果越界赋予值，那么相当于增长数组</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alist = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>];</span><br><span class="line">alist[alist.<span class="property">length</span>] = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">alist[alist.<span class="property">length</span>] = <span class="string">&quot;d&quot;</span>;</span><br><span class="line">alist[alist.<span class="property">length</span> + <span class="number">1</span>] = <span class="string">&quot;e&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(alist);    <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, undefined, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 数组最长 4,294,967,295 个项，更大的范围会抛出错误</strong>。</p><h4 id="4-2-3-实例方法"><a href="#4-2-3-实例方法" class="headerlink" title="4.2.3 实例方法"></a>4.2.3 实例方法</h4><ul><li><p>检查变量是否为数组引用类型：<code>Array.isArray()</code>；</p><blockquote><p>为什么要有这个方法？<code>instanceof Array</code> 不行吗？</p><p>答案是<strong>不行</strong>。考虑一种情况，最终 JavaScript 是要放在网页上的，网页上可能存在很多的框架，那么就会有多个全局执行环境，进而<strong>存在多个不同版本的 <code>Array</code> 构造函数</strong>。</p><p>但由于 JavaScript 没有重载，所以在一个环境下只有一种构造函数，因此<strong>当你从一个框架向另一个框架传入数组时，两个框架的原生数组定义不同，因此无法使用 <code>instanceof</code> 判断</strong>。</p></blockquote></li><li><p>类型转换方法（继承自 <code>Object</code>）：</p><ul><li><code>Array.toString()</code>：返回由调用数组每个元素的 <code>toString()</code> 返回的字符串组成、由<u>逗号</u>分割的字符串；</li><li><code>Array.valueOf()</code>：<strong>返回自身的<u>引用</u></strong>；</li><li><code>Array.toLocaleString()</code>：返回由调用数组每个值的 <code>toLocaleString()</code> 返回的字符串组成、由<u>逗号</u>分割的字符串；</li><li><code>Array.join(delim)</code>：和 <code>toString()</code> 功能相近，只是可以自定义分隔符 <code>delim</code>；</li></ul><blockquote><p>注：以上转字符串的方法的返回值，如果元素是 <code>null</code>、<code>undefined</code>，则其位置上是空字符串。</p></blockquote></li><li><p><strong>容器方法</strong>：</p><ul><li><p><code>push()</code>、<code>pop()</code>：<code>FIFO</code> 栈方法；</p></li><li><p><code>push()</code>（作为 <code>enQueue</code>）、<code>shift()</code>（<code>deQueue</code>）：<code>LIFO</code> 队列方法；</p><blockquote><p>还提供了 <code>unshift()</code> 方法，作为 <code>shift()</code> 的逆方法（类似 <code>prepend</code>）；</p></blockquote></li></ul></li><li><p>查找方法：</p><ul><li><p><code>find([func]/[elem])</code>：<strong>查找返回的是元素的引用 / 找不到返回 <code>undefined</code></strong>；</p></li><li><p><code>indexOf(elem[, start])</code>：第二参数可定制<strong>从 <code>start</code> 开始寻找</strong>，找不到返回 -1；</p></li><li><p><code>lastIndexOf(elem[, start])</code>；</p></li></ul></li><li><p>排序：<code>sort([func])</code>、<code>reverse()</code>；</p><blockquote><p>其中 <code>sort()</code> 方法默认<strong>升序</strong>，排序依据是<strong>每个元素的 <code>toString</code> 返回值</strong>。</p><p>由于字符串在比较数字方面等等的不利性，因此允许传入自定义比较函数。自定义比较函数要求：</p><ul><li>函数只会被这样调用：<code>intVar = func(element1, element2)</code>，所以要求处理两个参数、返回整型；</li><li><code>element1</code> 如果需要排在 <code>element2</code> 的<strong>前面</strong>，那么返回<strong>负数</strong>；如果要在后面，返回<strong>正数</strong>；如果二者排序依据相同，返回 0；</li></ul><p>例如这个函数是按照<strong>数值比较</strong>的<strong>降序</strong>比较函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">comp</span>(<span class="params">v1, v2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> v2 - v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为对于 Number，这个函数显然没问题。对于其他类型，减法运算会调用 <code>valueOf()</code> 函数。所以它能对 <code>valueOf()</code> 返回 Number 类型的参数进行排序。</p></blockquote></li><li><p>操作方法：</p><ul><li><p><code>Array.concat(other)</code>：拼接数组，<code>other</code> 可以是其他任何可迭代的类型，并且个数随意，包括基本类型；重要的是，<strong>返回的数组是新的对象——意味着不加参数就是 deep copy</strong>；</p></li><li><p><code>Array.slice(start, [stop])</code>：数组切片，不包括 <code>stop</code>（不传第二参数则默认 <code>Array.length</code>）；</p><blockquote><p>参数允许为负数，其含义与 Python 的相同，都是倒计数。</p></blockquote></li><li><p><code>Array.splice(start, length[, replaced])</code>：<strong>数组选块替换</strong>；</p><ul><li>删除选中元素：<code>Array.splice(i, j)</code> 表示删除索引从 <code>i</code> 开始的 <code>j</code> 个元素；</li><li>在指定位置插入元素：<code>Array.splice(i, 0, alist)</code> 表示从第 <code>i</code> 索引插入一个或多个可迭代对象 <code>alist</code>；</li><li>删除选中元素，同时在删除位置插入指定元素：<code>Array.splice(i, j, alist)</code> 表示从第 <code>i</code> 索引开始删除 <code>j</code> 个元素，并在该位置插入一个或多个可迭代对象 <code>alist</code>；</li></ul></li></ul><blockquote><p><strong>值得注意的是，操作方法 <code>concat</code>、<code>slice</code> 都会创建数组新的对象，而 <code>splice</code> 则会在原数组上修改。这意味着，如果你想做 deep copy，请不要使用 <code>splice</code></strong>；</p></blockquote></li><li><p><strong>迭代方法</strong>：</p><blockquote><p><strong>所有迭代方法其中一个参数都是 <code>mapFunc</code>，其要求的签名是：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapFunc</span>(<span class="params">curElement, curIdx, selfArr</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><code>Array.forEach(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。没有返回值；</li><li><code>Array.map(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。返回由 <code>mapFunc</code> 返回值组成的数组；</li><li><code>Array.filter(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。返回由 <code>mapFunc</code> 返回 <code>true</code> 的项组成的数组；</li><li><code>Array.every(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。如果该方法对数组每一项都返回 <code>true</code>，那么返回 <code>true</code>；</li><li><code>Array.some(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。</li></ul></li><li><p>归并方法（好像用的不多）：遍历数组的所有项，然后构建一个最终返回的值；</p><blockquote><p><strong>所有归并方法其中一个参数都是 <code>mapFunc</code>，其要求的签名是：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapFunc</span>(<span class="params">prev, cur, curIdx, selfArr</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><code>Array.reduce(mapFunc)</code>：从数组的左边向右边遍历，从数组第二项开始执行 <code>mapFunc</code>，返回值传给下一个元素调用 <code>mapFunc</code> 的第一参数，最后返回最终运算值；</p><blockquote><p>对空数组使用会报错；对长度为 1 的数组总是返回该元素的值；</p></blockquote></li><li><p><code>Array.reduceRight(mapFunc)</code>：与 <code>Array.reduce</code> 作用相同，不过从右向左遍历；</p></li></ul></li></ul><h3 id="4-3-Date-引用类型"><a href="#4-3-Date-引用类型" class="headerlink" title="4.3 Date 引用类型"></a>4.3 Date 引用类型</h3><p>首先熟悉 Java 的同学有福了，因为 ECMAScript 的 <code>Date</code> 类型基于早期 <code>java.util.Date</code> 类型构建，使用方法基本相同。</p><h4 id="4-3-1-实例创建"><a href="#4-3-1-实例创建" class="headerlink" title="4.3.1 实例创建"></a>4.3.1 实例创建</h4><p>默认构造函数即可：<code>var now = new Date();</code></p><p>默认构造函数创建的新对象<strong>自动获得当前日期和时间</strong>；</p><ul><li><p>另外可以传入<u>与 <code>UTC</code> 时间相距的毫秒数</u>来构造时间：<code>new Date(int)</code>；</p></li><li><p>也可以向构造函数传入一个字符串，效果和运行 <code>new Date(Date.parse(str))</code> 一样（下面介绍）；</p></li></ul><h4 id="4-3-2-日期解析"><a href="#4-3-2-日期解析" class="headerlink" title="4.3.2 日期解析"></a>4.3.2 日期解析</h4><p><strong>静态方法 <code>Date.parse(rawString)</code></strong> 接受一个<strong>特定日期格式</strong>的字符串，返回该日期<u>与 <code>UTC</code> 时间相距的毫秒数</u>：</p><ul><li><code>mm/dd/yyyy</code>（e.g., <code>6/13/2004</code>）；</li><li><code>English-Month day,year</code>（e.g., <code>January 12, 2023</code>）；</li><li><code>English-Week English-Month day year HH:mm:ss Timezone</code>（e.g., <code>Wed Jan 24 2024 00:00:00 GMT-0700</code>）;</li><li><strong>ISO-8601</strong> 标准拓展格式：<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>（e.g., <code>2024-01-25T14:54:00</code>）</li></ul><p>⚠ 如果字符串不是以上格式（即无法转为日期），则返回 <code>NaN</code>；</p><p>⚠ 如果字符串满足格式，但<strong>不是有效日期</strong>，那么不同解释器有不同行为。有的解释器转为当前日期，有的转为 “最近” 的正确日期；</p><blockquote><p>此外，还有更加方便的 <strong>静态方法 <code>Date.UTC([params])</code></strong>，功能与 <code>Date.parse</code> 相近；</p><p>从第一参数向后，是数值的：年、月、日、时（24）、分、秒，默认均为 0；</p></blockquote><p>此外还有静态方法 <code>Date.now()</code>，和默认构造函数的作用相近。</p><hr><p>为了日期信息提取的方便，ECMAScript 定义了一堆<strong>实例方法</strong>，它们的格式如下：</p><p><code>[set/get][UTC][Time/FullYear/Month/Date/Day/Hours/Minutes/Seconds/Milliseconds]</code></p><p>例如：<code>d.setUTCHours()</code>、<code>d.getDay()</code> 等等。其中 <code>getTime()</code> 和 <code>valueOf()</code> 返回的值一致。</p><blockquote><p><strong>额外记一个函数：<code>getTimezoneOffset()</code>，表示本地时间与 <code>UTC</code> 时间时区的时差分钟数</strong>。</p></blockquote><h4 id="4-3-3-日期格式化"><a href="#4-3-3-日期格式化" class="headerlink" title="4.3.3 日期格式化"></a>4.3.3 日期格式化</h4><ul><li><p>字符串转换函数（继承于 <code>Object</code>）：<code>toString()</code>、<code>toLocaleString()</code>。<u>事实上，这两个函数一般仅作为调试使用</u>；</p></li><li><p>运算类型转换（继承自 <code>Object</code>）：<code>valueOf() -&gt; int</code>，返回距 <code>UTC</code> 毫秒数。<strong>非常有用！可以直接用比较运算符比较日期</strong>； </p></li><li><p><code>Date.toDateString()</code>：转 <code>datetime</code>（e.g., <code>Wen Jan 24 2024</code>）；</p></li><li><p><code>Date.toTimeString()</code>：转 <code>time</code>（e.g., <code>15:29:20 GMT+0800 (China Standard Time)</code>）</p></li><li><p><code>Date.toLocaleDateString</code>、<code>Date.toLocaleTimeString()</code>：上面两种函数锁定当前时区的版本。</p><blockquote><p>前者输出形如 <code>1/24/2024</code>，后者输出形如 <code>3:29:20 PM</code>；</p></blockquote></li><li><p><code>Date.toUTCString()</code>：完整 <code>UTC</code> 格式字符串（e.g., <code>Wed, 24 Jan 2024 07:29:20 GMT</code>）；</p></li></ul><h3 id="4-4-RegExp-引用类型"><a href="#4-4-RegExp-引用类型" class="headerlink" title="4.4 RegExp 引用类型"></a>4.4 RegExp 引用类型</h3><p>这是一个比较强大的引用类型，尽管 ECMAScript 实现的正则表达式没有 <code>Perl</code> 语言的高级（<strong>例如 unicode 支持、并集和交集类、单行、注释、条件匹配等等</strong>），但也能解决绝大多数问题。</p><h4 id="4-4-1-实例创建"><a href="#4-4-1-实例创建" class="headerlink" title="4.4.1 实例创建"></a>4.4.1 实例创建</h4><p>ECMAScript 中，不需要使用引号即可创建正则表达式（直接量 literal）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expr = <span class="regexp">/&lt;pattern&gt;/</span>&lt;flags&gt;;</span><br></pre></td></tr></table></figure><p>也可以从字符串创建（如果是放在字符串里，那么转义符自身也要转义了😢，例如 <code>\d</code> -&gt; <code>&quot;\\d&quot;</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expr = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;&lt;pattern&gt;&quot;</span>, <span class="string">&quot;flags&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>pattern</code> 就是我们最常用的正则表达式模式字符串。</p><p><u>但是以前（ECMAScript 5 之前），正则表达式直接量和 <code>new</code> 初始化的内存机制略有不同。</u></p><p>这是因为，<strong><u>正则表达式直接量</u>相当于 C++ 中的字符串常量，也相当于 Java 中位于字符串池中的常量字符串</strong>，每次引用这个常量都是一个内存地址中的对象；而 <code>new</code> 出来的对象就是真实独立存在堆内存中的对象了。</p><p><u>而在 ECMAScript 5 之后，正则表达式 literal 也必须和直接使用构造函数一样创建新的实例。</u></p><p><code>flags</code> 包含以下几种（仅列举几种常用的，不常用的 JavaScript 也不一定支持）：</p><ul><li><p><code>g</code>：global，表示全局模式，<strong>不会在找到第一个匹配项时停止</strong>（默认会停止，即<u>下次查找从头开始</u>）；</p></li><li><p><code>i</code>：case insensitive，大小写不敏感；</p></li><li><p><code>m</code>：multiline，多行匹配，<code>^</code>、<code>$</code> 会选中一行的开头和结尾，而不再是整个字符串的开头和结尾；</p><blockquote><p>例如字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helloJava</span><br><span class="line">123</span><br><span class="line">HelloPython12</span><br><span class="line">456</span><br></pre></td></tr></table></figure><p>如果使用 <code>/^\d+$/g</code> 则只会匹配到 <code>123</code>，而使用 <code>/^\d+$/gm</code> 则会匹配到 <code>123</code> 和 <code>456</code>；</p></blockquote></li><li><p><code>s</code>：即 <code>.</code> 限定符加入包含换行符 <code>\n</code>，具体表现为使用 <code>.</code> 代表的内容可以不在同一行；</p></li></ul><h4 id="4-4-2-常用实例属性"><a href="#4-4-2-常用实例属性" class="headerlink" title="4.4.2 常用实例属性"></a>4.4.2 常用实例属性</h4><ul><li><p><code>RegExp.global</code>：Boolean，是否设置了 <code>g</code> flag；</p></li><li><p><code>RegExp.ignoreCase</code>：Boolean，是否设置 <code>i</code> flag；</p></li><li><p><code>RegExp.multiline</code>：Boolean，是否设置 <code>m</code> flag；</p></li><li><p><code>RegExp.lastIndex</code>：Number，表示当前正则对象<u><strong>下一次匹配</strong></u>的位置；</p><blockquote><p>注：有这个属性的原因是，在使用 global 模式时，正则对象查找 pattern 会在第一次匹配到的时候不会停止，所以需要为下次匹配继续保留这个状态。</p></blockquote></li><li><p><code>RegExp.source</code>：String，表示当前正则表达式的 <strong><code>pattern</code> 字符串表示</strong>；</p></li></ul><h4 id="4-4-3-常用实例方法"><a href="#4-4-3-常用实例方法" class="headerlink" title="4.4.3 常用实例方法"></a>4.4.3 常用实例方法</h4><p><strong>Ⅰ. 正则式引用类型 匹配方法：<code>exec</code></strong></p><p><code>RegExp.exec(String) -&gt; Extended Array</code></p><p><code>RegExp</code> 的重要方法，也是指示正则匹配的方法。由于 JavaScript 不强调类型，所以返回的信息不像其他语言用类型包装（例如 Qt/C++ 中的 <code>QRegularExpressionMatch</code>、Python 中的 <code>re.Match</code>），只是使用一个数组来存放信息。<u><strong>不过这个数组多了 <code>index</code>、<code>input</code> 两个属性</strong>，并且其他数组项（键 <code>k ∈ [0, N)</code>）存放的是第 k 组</u>；</p><p>需要注意以下几点：</p><ul><li><p><strong>和其他所有正则框架一样，第 0 组是匹配到的字符串的全文</strong>；</p></li><li><p>返回值数组的 <code>index</code> 属性表示 <strong>当前匹配到的字符串在原字符串中的起始位置</strong>；</p></li><li><p>返回值数组的 <code>input</code> 属性表示输入的字符串；</p></li><li><p>即便设置 <code>g</code> flag，调用 <code>exec</code> 仍然每次仅返回一个匹配结果。不过由于设置了 <code>g</code> flag，每次调用 <code>exec</code> 时，<code>index</code> 就被赋予 <code>lastIndex</code> 的值向后查找；</p></li><li><strong>由于 <code>lastIndex</code> 存放在 <code>RegExp</code> 对象中，所以即使 <code>exec</code> 的传入参数换成另一个字符串，匹配仍然会从上一次 <code>lastIndex</code> 处开始，在编程时需要注意</strong>；</li><li>当 <code>exec</code> 向后查找结束（global），或者没有匹配的部分时，返回 <code>null</code>；</li></ul><p>举个例子，想要匹配文字间 Latex 语法，找到所有 $$$$ 隔开的数学行公式，那么使用如下正则式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 确切地说，应该使用 (?&lt;!\$)\$\$(?!\$)(.+?)(?&lt;!\$)\$\$(?!\$)， */</span></span><br><span class="line"><span class="comment">/* 因为 \1 无法指代断言。不过这里只是随便演示一下 */</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?&lt;!\$)(\$\$)(?!\$)(.+?)\1/gm</span>;</span><br></pre></td></tr></table></figure><p>如果这是要查找的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;$jfj4$$3$0$$\nd34of$$deo$$&quot;</span>;</span><br></pre></td></tr></table></figure><p>那么输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; reg.<span class="title function_">exec</span>(str);    <span class="comment">// 第一次查找</span></span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;$$3$0$$&#x27;</span>,        <span class="comment">// array[0] =&gt; 第 0 组，匹配到的全文</span></span><br><span class="line">  <span class="string">&#x27;$$&#x27;</span>,                <span class="comment">// array[1] =&gt; 第一组，也就是 (\$\$) 选中的组</span></span><br><span class="line">  <span class="string">&#x27;3$0&#x27;</span>,            <span class="comment">// array[2] =&gt; 第二组，也就是 (.+?) 选中的组</span></span><br><span class="line">  <span class="attr">index</span>: <span class="number">5</span>,            <span class="comment">// array.index =&gt; 第 0 组的开始位置索引</span></span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;$jfj4$$3$0$$\nd34of$$deo$$&#x27;</span>,</span><br><span class="line">  <span class="attr">groups</span>: <span class="literal">undefined</span></span><br><span class="line">]</span><br><span class="line">&gt; reg.<span class="title function_">exec</span>(str);    <span class="comment">// 第二次查找，从上一次的 lastIndex (=12) 开始</span></span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;$$deo$$&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;$$&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;deo&#x27;</span>,</span><br><span class="line">  <span class="attr">index</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;$jfj4$$3$0$$\nd34of$$deo$$&#x27;</span>,</span><br><span class="line">  <span class="attr">groups</span>: <span class="literal">undefined</span></span><br><span class="line">]</span><br><span class="line">&gt; reg.<span class="title function_">exec</span>(str);    <span class="comment">// 第三次查找，从上一次的 lastIndex (=25) 开始</span></span><br><span class="line"><span class="literal">null</span>                <span class="comment">// 无法找到更多的匹配内容，返回 null，并且将 lastIndex 设为 0</span></span><br></pre></td></tr></table></figure><p><strong>Ⅱ. 正则式引用类型 检查方法：<code>test</code></strong></p><p><code>RegExp.test(String) -&gt; Boolean</code></p><p>从 <code>lastIndex</code> 开始检查下一个是否存在匹配的字符串，会改变 <code>lastIndex</code>（等同于 <code>Boolean(RegExp.exec)</code>）；</p><p><strong>Ⅳ. 正则式引用类型 类型转换方法：<code>toString / toLocaleString</code></strong> 直接返回<strong>构造直接量（pattern + flag）</strong>；</p><p><strong>Ⅴ. 正则式引用类型 构造函数属性</strong></p><p>JavaScript 中的 “构造函数属性” 类似于 <strong>C++ 中的静态数据成员</strong>，也类似于 <strong>Python 中的类属性</strong>；这些属性同时影响整个类的实例。</p><blockquote><p>⚠ 警告：Opera 浏览器的 JS 引擎没有实现大部分这些属性；</p></blockquote><ul><li><code>input</code>：所有正则实例中，最近一次传入的字符串；</li><li><code>lastMatch</code>：所有正则实例中，最近一次匹配的属性；</li><li><code>lastParen</code>：所有正则实例中，最近一次匹配的捕获分组；</li><li><code>leftContext / rightContext</code>：<code>lastParen</code> 之前 / 之后的文本；</li><li><code>multiline</code>：<strong>是否所有正则实例都是多行模式</strong>；</li></ul><h3 id="4-5-Function-引用类型"><a href="#4-5-Function-引用类型" class="headerlink" title="4.5 Function 引用类型"></a>4.5 Function 引用类型</h3><h4 id="4-5-1-Function-引用类型的实质"><a href="#4-5-1-Function-引用类型的实质" class="headerlink" title="4.5.1 Function 引用类型的实质"></a>4.5.1 Function 引用类型的实质</h4><p>我们已经知道，JavaScript 函数就是一种特殊的对象（Object），因此每个函数都是 <code>Function</code> 类型的实例，并且具有一些共有的属性和方法。</p><p>例如以下两种定义方式<strong>几乎相同</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* method 1 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* method 2: Function 类的构造函数 function() */</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么说 “几乎”？因为它们的<strong>唯一区别</strong>在于解释器是否进行<strong>函数声明提升（function declaration hoisting）</strong>的过程。</p><blockquote><p>在 C 里面我们知道，如果你在 <code>*.c</code> 中定义了函数，那么不能在函数名出现前使用它，除非在此前声明。</p><p>而在 JavaScript 中不存在手动声明的说法，是由解释器识别并将函数定义提升至源代码的最前面。如果使用第二种方法定义函数，那么解释器不会对这个赋值操作进行函数声明提升。因此下面两种操作<strong>只有第一种不会报错</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* method 1 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* method 2: wrong */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>我们还需要了解的重要一点，<strong>函数是对象，函数名是指针</strong>。所以在 JavaScript 中，开发者唯一能接触到的指针只有函数指针（即函数名）。</p><p>而存放函数指针的变量和其他变量并没有什么不同，也能随意赋值（<strong>包括函数传参</strong>），这就能解释为什么 JavaScript 中没有重载。</p><h4 id="4-5-2-Function-引用类型的常用内部属性"><a href="#4-5-2-Function-引用类型的常用内部属性" class="headerlink" title="4.5.2 Function 引用类型的常用内部属性"></a>4.5.2 Function 引用类型的常用内部属性</h4><blockquote><p>内部对象属性是 JavaScript 引擎自行构建的；</p></blockquote><ul><li><p><code>Function.arguments.callee</code>：使用场景，解耦合的递归函数（为什么需要解耦合？因为 JavaScript 的函数可以随意赋给另一个变量，它和 C++ 的函数指针一样，运行时指向同一内存地址）；</p></li><li><p><code>Function.caller</code>：当前函数的当前调用方，如果上次在全局作用域中调用，则为 <code>null</code>；</p></li><li><p><code>Function.this</code>：<strong>与 OOP 无关，是函数执行的<u>环境对象</u></strong>（表示作用域的对象，也是 <code>Object</code>）；</p><blockquote><p>例如网页全局作用域中调用函数时，<code>this</code> 就是 <code>window</code> 对象；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">//&quot;red&quot;</span></span><br><span class="line">o.<span class="property">sayColor</span> = sayColor;</span><br><span class="line"><span class="comment">/* 环境作用域中最近有啥，this 就选择啥 */</span></span><br><span class="line">o.<span class="title function_">sayColor</span>(); <span class="comment">//&quot;blue&quot;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>Function.length</code>：函数<strong>希望</strong>接收的参数个数；</p></li><li><p><code>Function.prototype</code>（<strong>不可枚举，不可被 <code>for-in</code> 找到</strong>）：讨论原型时详细介绍；4</p><blockquote><p>对 JavaScript 的<strong>所有引用类型</strong>而言，<strong>是保存引用类型所有实例方法的对象</strong>；</p></blockquote></li><li><p><code>Function.apply(&lt;envObj&gt;, [paramArr]) / Function.call(&lt;envObj&gt;, [param1, param2, ...])</code>：<strong>指定函数作用域对象来调用函数</strong>；</p></li><li><code>Function.bind(&lt;envObj&gt;) -&gt; Function</code>：<strong>无视当前环境，创建新的函数实例，并将其环境对象指定为 <code>&lt;envObj&gt;</code></strong>（相当于在 <code>&lt;envObj&gt;</code> 中定义了该函数）；</li></ul><h3 id="4-6-基本包装类型"><a href="#4-6-基本包装类型" class="headerlink" title="4.6 基本包装类型"></a>4.6 基本包装类型</h3><p>和 Java 类似，为了方便基本类型的操作，JavaScript 定义了<strong>内置基本类型的引用类型</strong>，共有 3 种：<code>Boolean</code>、<code>Number</code>、<code>String</code>；</p><p>它们不需要被显式创建，而是在我们使用基本类型时，如果对它们调用方法，解释器自动为我们进行如下步骤：</p><ol><li><p>创建该基本类型的实例；</p></li><li><p>调用该实例的指定方法；</p></li><li><p>销毁该实例；</p></li></ol><p>这能解释 2 个问题：</p><ul><li><p>为什么基本类型可以存在方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>因为等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>为什么为基本类型赋予属性时会立即消失：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">s1.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(s1.<span class="property">color</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p><strong>因为上一次创建的 <code>String</code> 对象已经被销毁了</strong>；</p></li></ul><p>下面是内置基本包装类型的常用方法（除了普通 <code>Object</code> 也有的）：</p><ul><li><p><code>Number.toFixed(Number)</code>；</p></li><li><p><code>Number.toExponential(Number)</code>；</p></li><li><p><code>Number.toPrecision()</code>：以上两种最方便的切换模式；</p></li><li><p><code>String.charAt() / charCodeAt()</code>；</p></li><li><p><code>String[&lt;idx&gt;]</code>；</p></li><li><p><code>String.concat(&lt;String&gt;)</code>：最好还是用 <code>+</code>；</p></li><li><p><code>String.slice(&lt;start&gt;, [stop]) / String.substr(&lt;start&gt;, [length]) / String.substring(&lt;start&gt;, [stop])</code>：字符串切片 ；</p><ul><li>注意，只有 <code>substr()</code> 第二参数指定的是长度；</li><li>当输入存在负值时，<code>slice</code> 与 python 的 <code>slice</code> 完全一致，start 和 stop 都是反向索引；</li><li>当输入存在负值时，<code>substr</code> 第一参数（start）与之前一致，而第二参数因为是长度，所以如果是负值则转为 0；</li><li>当输入存在负值时，<code>substring</code> <strong>不接受一切负参数</strong>，将负参数转为 0；</li></ul></li><li><p><code>String.indexOf(&lt;substr&gt;, [start]) / String.lastIndexOf(...)</code>：字符子串查找；</p></li><li><p><code>String.trim()</code>：删除字符串前后的所有空白字符，并创建实例副本；</p></li><li><p><code>String.to[Locale][Lower/Upper]Case()</code>：字符串大小写转换；</p></li><li><p><code>String.match(&lt;RegExp&gt;) -&gt; match array</code>：等同于 <code>RegExp.exec(&lt;String&gt;)</code>；</p></li><li><p><code>String.search(&lt;RegExp&gt;) -&gt; Number</code>： 查找第一次出现 pattern 的位置索引，若不存在则返回 -1；</p></li><li><p><code>String.split(&lt;char&gt; | &lt;RegExp&gt;)</code>：⚠⚠ <u>谨慎在此式使用正则表达式，因为在捕获组为空的时候，不同浏览器下行为不一致</u>；⚠⚠</p></li><li><p><code>String.replace(&lt;RegExp&gt;, &lt;newStr&gt;)</code>：字符串替换；</p><p>注意，这里的 <code>newStr</code> 有些特点，例如它允许特殊的字符串标识：</p><ol><li><code>$&amp;</code>：等同于 <code>RegExp.lastMatch</code>；</li><li><code>$&#39;</code>：等同于 <code>RegExp.leftContext</code>（反引号就是 <code>RegExp.rightContext</code>）；</li><li><code>$n/nn</code>：第 n 捕获组字符串（nn 表示两位数），如果没有该组，则表示空字符串；</li><li>$$$$：表示 <code>$</code> 字符本身；</li></ol></li><li><p><code>String.replace(&lt;RegExp&gt;, &lt;rFunc&gt;)</code>：自定义替换规则；</p><p>这里的 <code>rFunc</code> 要求传入参数的形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@brief</span> Inner replace function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>[in] match Matched string (group[0]).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>[in] pos The index of matched string in original string.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>[in] originalText Original string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rFunc</span>(<span class="params">match, pos, originalText</span>);</span><br></pre></td></tr></table></figure><p>举个例子，如果需要将 HTML 中所有特殊字符替换为转义字符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">htmlEscape</span>(<span class="params">text</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> text.<span class="title function_">replace</span>(</span><br><span class="line">        <span class="regexp">/[&lt;&gt;&quot;&amp;]/g</span>,</span><br><span class="line">        <span class="keyword">function</span>(<span class="params">match, pos, origin</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&amp;lt;&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;&gt;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&amp;gt;&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;&amp;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&amp;amp;&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;\&quot;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&amp;quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>String.localeCompare(&lt;str&gt;)</code>：比较两个字符串。顺序比较字符串中每个字符，排在字母表后面的会返回 1，前面会返回 -1。两字符串相同会返回 0；</p></li><li><p><code>String.fromCharCode(&lt;int params&gt;)</code>：从 unicode 构建字符串；</p></li></ul><p><u><strong>在此强烈不建议手动实例化基本包装类型，因为它们可能使 <code>instanceof</code>、<code>typeof</code> 等关键字失去作用</strong></u>。</p><h3 id="4-7-单体内置对象"><a href="#4-7-单体内置对象" class="headerlink" title="4.7 单体内置对象"></a>4.7 单体内置对象</h3><p>由 ECMAScript 实现提供的、<strong>不依赖于宿主环境的对象</strong>，这些对象在 ECMAScript 程序执行之前就已经存在了。</p><p>我们已经接触到的对象有：<code>Object</code>、<code>Array</code>、<code>String</code> 等等（没有真正的类型）；</p><p>这里介绍两个额外的单体内置对象：<code>Global</code>、<code>Math</code>；</p><h4 id="4-7-1-Global"><a href="#4-7-1-Global" class="headerlink" title="4.7.1 Global"></a>4.7.1 Global</h4><p>这个对象你在 JavaScript 中永远无法自己创建。不过可以找到它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种表达式在 JavaScript 中被称为函数表达式，后面介绍</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">global</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="variable language_">this</span>;&#125;();</span><br></pre></td></tr></table></figure><p>而且<strong>不论当前执行环境在哪里，不论你使用 <code>apply()</code>、<code>call()</code> 访问这个函数，其中的 <code>this</code> 都是 <code>Global</code> 对象</strong>；</p><p>而且，JavaScript 中实际上<strong>不存在全局变量和全局函数</strong>，它们<strong>都是 <code>Global</code> 对象的属性和方法</strong>。例如之前遇到的 <code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>、<code>parseFloat()</code>；</p><p><u>无论是 <code>Global</code> 属性还是方法，都不能对其进行赋值操作！</u></p><p><strong><code>Global</code> 方法</strong></p><p>此外，<code>Global</code> 中还有两类方法。一种是 URI 编解码。</p><ul><li><p>URI 编码方法：<code>encodeURI(&lt;str&gt;)</code>、<code>encodeURIComponent(&lt;str&gt;)</code> </p><blockquote><p>有效的 URI 中不能包含某些字符，例如空格；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">&quot;http://www.wrox.com/illegal value.htm#start&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;http://www.wrox.com/illegal%20value.htm#start&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">encodeURI</span>(uri));</span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure></blockquote></li><li><p>URI 解码方法：<code>decodeURI(&lt;str&gt;)</code>、<code>decodeURIComponent(&lt;str&gt;)</code></p></li></ul><p>以上方法可以将 URI 进行编码，以便发送给浏览器处理；</p><p>另一种是 <code>eval()</code> 方法，它<strong>提供了一个完整的 ECMAScipt 解释器</strong>，将参数中的字符串作为 JavaScript 代码直接执行；</p><p>不过有几个需要注意的点：</p><ul><li><code>eval()</code> 中创建的任何变量和函数都不会被提升（包括函数声明提升）；</li><li><code>eval()</code> 存在代码注入的安全问题；</li><li><strong>非严格模式下，<code>eval()</code> 函数内外共享变量和函数作用域</strong>，相当于在原位添加了字符串中的代码；</li></ul><p><strong><code>Global</code> 属性</strong></p><p>之前的 <code>undefined</code>、<code>NaN</code>、<code>Infinity</code> 等都是 <code>Global</code> 对象属性。就连<strong>所有原生引用类型的构造函数也都是 <code>Global</code> 对象的属性（不是方法）</strong>。此外，常见的错误对象（在错误处理一章介绍）也是 <code>Global</code> 对象。</p><p><img src="imgs/global.png"></p><h4 id="4-7-2-window-对象"><a href="#4-7-2-window-对象" class="headerlink" title="4.7.2 window 对象"></a>4.7.2 <code>window</code> 对象</h4><p>在 Web 浏览器的 ECMAScript 引擎中，会自动设置一个全局对象 <code>window</code>，它会自动包含所有 <code>Global</code> 对象的属性和方法（将 <code>Global</code> 对象作为 <code>window</code> 对象的一部分），<u><strong>并且是实时的</strong></u>。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayColor</span>(); <span class="comment">//&quot;red&quot;</span></span><br></pre></td></tr></table></figure><p><code>window</code> 对象在 ECMAScript BOM / DOM 中用的较多。</p><h4 id="4-7-3-Math-对象"><a href="#4-7-3-Math-对象" class="headerlink" title="4.7.3 Math 对象"></a>4.7.3 <code>Math</code> 对象</h4><p><strong><code>Math</code> 对象属性</strong></p><p>大多是常用的常量：<code>Math.E</code>、<code>Math.LN10</code>、<code>Math.LN2</code>、<code>Math.LOG2E</code>、<code>Math.LOG10E</code>、<code>Math.PI</code>、<code>Math.SQRT1_2</code>、<code>Math.SQRT2</code>……</p><p><strong><code>Math</code> 对象方法</strong></p><p>常见数学方法：<code>min(&lt;params&gt;)</code>（<strong>不接受数组，如果需要，请用前面提到的 <code>apply</code></strong>）、<code>max()</code>、<code>ceil()</code>、<code>floor()</code>、<code>round()</code>、<code>random()</code>（取值 <code>[0, 1]</code>）、<code>abs()</code>、<code>exp()</code>、<code>log()</code>、<code>pow(&lt;num&gt;, &lt;power&gt;)</code>、<code>sqrt()</code>、<code>acos()</code>、<code>cos()</code>……</p><h2 id="Chapter-5-OOP-in-JavaScript"><a href="#Chapter-5-OOP-in-JavaScript" class="headerlink" title="Chapter 5. OOP in JavaScript"></a>Chapter 5. OOP in JavaScript</h2><p>在 ECMAScript 中，对于对象的定义是：</p><p><u><strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong></u>。</p><p>对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把 ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。</p><blockquote><p>简而言之，JavaScript 中的对象就是一个类似散列表的结构。</p></blockquote><h3 id="5-1-对象的实际定义"><a href="#5-1-对象的实际定义" class="headerlink" title="5.1 对象的实际定义"></a>5.1 对象的实际定义</h3><p>之前几章中介绍的对象定义方法是无需声明，<u>加点或方括号</u>直接添加属性及方法，如下（构造函数创建）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">person.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line">person.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">person[<span class="string">&quot;G P A&quot;</span>] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">person.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还可以用这种方式（对象直接量创建）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果将所有的 key 全部换为标准的字符串形式，那么就是大名鼎鼎的 JSON（JavaScript Object Notation，JS 对象表示）；</p><p>其实，基本引用类型 <code>Object</code> 的属性都定义了解释器内部特性（attribute），它们：</p><ul><li>给 JavaScript 解释器使用，<strong>JavaScript 代码无法直接访问</strong>；</li><li>描述了 JavaScript 对象的属性的各种特征；</li></ul><blockquote><p>为了规范，将对象属性的 attribute 放在双方括号中表示。</p></blockquote><p>ECMAScript 对象的属性分为 2 种：<u><strong>数据属性、访问器属性</strong></u>。</p><h4 id="5-1-1-数据属性的-attribute"><a href="#5-1-1-数据属性的-attribute" class="headerlink" title="5.1.1 数据属性的 attribute"></a>5.1.1 数据属性的 attribute</h4><p><u>ECMAScript 的所有直接定义的对象属性都是 数据属性</u>。</p><ul><li><code>[[Configurable]]</code>：能否<u>通过 delete 删除属性</u>从而重新定义属性，能否<u>修改属性的特性</u>，或者能否把属性修<u>改为访问器属性</u>（默认为 <code>true</code>）；</li><li><p><code>[[Enumerable]]</code>：能否通过 <code>for-in</code> 循环返回属性。例如前面提到的 <code>Function.prototype</code>就是  <code>false</code>；</p></li><li><p><code>[[Writable]]</code>：表示能否修改属性的值；</p></li><li><code>[[Value]]</code>：<u>该属性的数据值存放处</u>，即读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置；</li></ul><p>可以通过 <code>Object.defineProperty(&lt;targetObj&gt;, &lt;propName&gt;, &lt;descriptor&gt;)</code> 修改。其中描述符对象 <code>descriptor</code> 必须具有属性 <code>configurable</code>、<code>enumerable</code>、<code>writable</code>、<code>value</code> 其中至少一个（默认全为 <code>false</code>），例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5-1-2-访问器属性的-attribute"><a href="#5-1-2-访问器属性的-attribute" class="headerlink" title="5.1.2 访问器属性的 attribute"></a>5.1.2 访问器属性的 attribute</h4><p>访问器属性针对 ECMAScript 对象的 <strong>属性自定义访问方法</strong>，自身不包含数据。常见作用是 <strong>动态获取属性、自定义属性访问权限和访问规则</strong>。</p><p><strong>完全可以理解为 Python 中的 <code>@getter</code>、<code>@setter</code></strong> 定义的实例属性；</p><ul><li><code>[[Configurable]]</code>：表示能否<u>通过 delete 删除属性</u>从而重新定义属性，能否<u>修改属性的特性</u>，或者能否把属性<u>修改为数据属性</u>（默认为 <code>true</code>）；</li><li><code>[[Enumerable]]</code>：表示能否通过 <code>for-in</code> 循环返回属性；</li><li><code>[[Get]]</code>：函数，读取属性时调用，返回值即为该属性值；</li><li><code>[[Set]]</code>：函数，写入属性时调用，它的行为会代替写入行为；</li></ul><p><strong>访问器属性不能被直接定义（普通定义属性的方法都是数据属性），只能使用 <code>Object.defineProperty()</code> 修改，类比数据属性的修改方法</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="attr">_year</span>: <span class="number">2004</span>,</span><br><span class="line">    <span class="attr">edition</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_year</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newValue</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_year</span> = newValue;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.<span class="property">year</span> = <span class="number">2005</span>;</span><br><span class="line"><span class="title function_">alert</span>(book.<span class="property">edition</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>如果在设置访问器属性时，未指定 <code>set</code>，那么意味着写入该属性时什么都不会做，对于 <code>get</code> 同理。</p><h4 id="5-1-3-设置属性的-attribute"><a href="#5-1-3-设置属性的-attribute" class="headerlink" title="5.1.3 设置属性的 attribute"></a>5.1.3 设置属性的 attribute</h4><p>除了上面介绍的 <code>Object.defineProperty()</code>，还可以同时对多个对象属性设置 attribute：</p><p><code>Object.defineProperties(&lt;targetObj&gt;, &lt;propObj&gt;)</code>；</p><p>其中，<code>propObj</code> 对象的格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    &lt;propertyName1&gt;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        &lt;attributeName11&gt;<span class="punctuation">:</span> &lt;entry11&gt;<span class="punctuation">,</span></span><br><span class="line">        &lt;attributeName12&gt;<span class="punctuation">:</span> &lt;entry12&gt;</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    &lt;propertyName2&gt;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        &lt;attributeName21&gt;<span class="punctuation">:</span> &lt;entry21&gt;<span class="punctuation">,</span></span><br><span class="line">        &lt;attributeName22&gt;<span class="punctuation">:</span> &lt;entry22&gt;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="5-1-4-读取属性的-attribute"><a href="#5-1-4-读取属性的-attribute" class="headerlink" title="5.1.4 读取属性的 attribute"></a>5.1.4 读取属性的 attribute</h4><p><code>Object.getOwnPropertyDescriptor(&lt;targetObj&gt;, &lt;propName&gt;)</code> 可以获得该属性的描述符，与设置相对应故不再赘述。</p><h3 id="5-2-创建对象的高级方法"><a href="#5-2-创建对象的高级方法" class="headerlink" title="5.2 创建对象的高级方法"></a>5.2 创建对象的高级方法</h3><p>我们发现，由于 JavaScript 没有真正的类型，只有对象。所以当我们想创建接口相同的对象时，<strong>如果使用上面的构造函数，或者对象直接量创建，那么免不了需要重复定义对象</strong>。这显然是不可取的。</p><p>于是，一代代人采用不同方法来创建对象，以提升代码复用性 和 可维护性。下面是设计迭代的过程。</p><h4 id="5-2-1-工厂模式"><a href="#5-2-1-工厂模式" class="headerlink" title="5.2.1 工厂模式"></a>5.2.1 工厂模式</h4><p><u><strong>通过抽象 “具体对象的创建过程” 为一个函数，来完成对象的构建</strong></u>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    o.<span class="property">name</span> = name;</span><br><span class="line">    o.<span class="property">age</span> = age;</span><br><span class="line">    o.<span class="property">job</span> = job;</span><br><span class="line">    o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>⚠⚠ <strong>缺陷</strong>：<strong>无法识别这个接口相同的对象</strong>。⚠⚠</p><p>为了解决这个问题，设计出了 “构造函数模式” 来创建同接口的对象。</p><h4 id="5-2-2-构造函数模式-与-this-关键字"><a href="#5-2-2-构造函数模式-与-this-关键字" class="headerlink" title="5.2.2 构造函数模式 与 this 关键字"></a>5.2.2 构造函数模式 与 this 关键字</h4><p>首先我们要梳理一个问题——什么是 JavaScript 中的 <code>this</code> 关键字。它的含义相当混乱。我们在前面的时候已经用到过 <code>this</code> 关键字，但是它实际上：</p><ul><li><p>在方法中，this 表示该方法所属的对象；</p></li><li><p>如果单独使用，this 表示全局对象；</p></li><li><p>在函数中，this 表示全局对象（严格模式下为 <code>undefined</code>）；</p></li></ul><blockquote><p>其实还有 <strong>事件</strong>，在 “事件” 中，<code>this</code> 也不相同，不过这里不作介绍，用到再说。</p></blockquote><p>进一步来看 JavaScript 中的 <code>new</code> 关键字的作用。</p><p>首先 <code>new</code> 关键字的操作对象是 <code>Function</code>，并<u>将该函数作为构造函数</u>。</p><p>这是 <code>var obj = new Func()</code> 执行的具体步骤：</p><ol><li><p>创建一个新对象（为对象开辟内存空间），以 <code>o</code> 指代；</p></li><li><p>将 <code>Func</code> 作用域对象绑定为 <code>o</code>，所以 <code>Func</code> 内的 <code>this</code> 由原本的全局对象指向 <code>o</code>；</p></li><li><p>执行 <code>Func</code> 函数体；</p></li><li><p>为对象 <code>o</code> 添加普通属性 <code>constructor</code>，指向 <code>Func</code>；</p><blockquote><p>这样我们可以通过两种方法确定这种对象的接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">constructor</span> == <span class="title class_">Func</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Func</span>);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>自动返回对象 <code>o</code>；</p></li></ol><p>经过这样定义的 <code>this</code> 和 <code>new</code> 关键字就能完成类似 C++ 中构造函数的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样也能解释为什么自定义的对象也继承于 <code>Object</code>。</p><p>同时，这种函数也能作为普通函数使用，因为它的函数体本质上修改的是函数内的 <code>this</code> 对象。我们可以：</p><ul><li><p>直接调用它：这样修改的 <code>this</code> 就是全局对象，相当于给全局对象加了特定属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器引擎中</span></span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); <span class="comment">// 添加到 window</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Greg&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>call() / apply()</code> 指定作用域对象来调用：这就相当于对特定的对象执行了构造函数，同时还能解决工厂模式的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(o, <span class="string">&quot;Kristen&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Nurse&quot;</span>);</span><br><span class="line">o.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Kristen&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>⚠⚠ <strong>缺陷</strong>：<strong>“构造”函数中，写函数定义作为属性，会导致每次构造一个对象，都产生一个新的对应的函数对象</strong>。这会导致不同的作用域链和标识符解析。⚠⚠</p><p>这是因为，函数也是 <code>Object</code> 的一种，函数直接量定义也会在堆内存中创建一个新的函数对象，然后引用。</p><p>有人说，这好办，把所有函数定义都拿到 “构造” 函数以外不就行了？</p><p>但是如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。</p><p>因此另一种 JavaScript 的对象构造模式就出现了。</p><h4 id="5-2-3-原型"><a href="#5-2-3-原型" class="headerlink" title="5.2.3 原型"></a>5.2.3 原型</h4><p>解决 “构造” 函数封装性问题的方法很简单：<strong>再套一层作用域对象，不影响全局作用域对象不就行了</strong>！</p><p>ECMAScript 实际也是这么解决的。我们在 4.5.2 中提到，<code>Function</code> 引用类型有一个属性 <code>prototype</code>，这个就是为了解决对象的构造函数封装问题。</p><p><code>Function.prototype</code> 就是一个引用<strong>指向一个新的对象（在这个函数创建时被创建）</strong>，这个新对象的用途就是 <u><strong>保存特定类型的所有实例共享的属性和方法</strong></u>。</p><p>也就是说，你可以使用某个函数的 <code>prototype</code> 作为存放一类接口相同的对象模板属性的对象（模板对象）。</p><p>于是，我们定义构造函数 <code>Func</code> 时就创建一个新对象（为对象开辟内存空间），暂且叫做 <code>o1</code>，创建的引用指向新对象，<strong>这个引用就叫 <code>prototype</code></strong>；</p><p>而我们使用 <code>new</code> 关键字的过程（<code>var obj = new Func();</code>）就变为：</p><ol><li>创建一个空的 JavaScript 对象，叫做 <code>o2</code>；</li><li>为对象 <code>o2</code> 添加内部属性 <code>[[prototype]]</code>，或者 <code>__proto__</code>，指向 <code>o1</code>（即 <code>Func.prototype</code>所指），对开发者不可见；</li><li>将当前 <code>Func</code> 作用域对象绑定为 <code>o2</code>，所以 <code>Func</code> 内的 <code>this</code> 由原本的全局对象指向 <code>o2</code>；</li><li>执行 <code>Func</code> 函数体；</li><li>为对象 <code>o2</code> 添加普通属性 <code>constructor</code>，指向 <code>Func</code>；</li><li>返回对象 <code>o2</code>；</li></ol><p>这样：</p><ul><li><u><strong><code>prototype</code> 对象中的属性被所有构建出的对象所共享（通过 <code>[[prototype]]</code> 所共享，包括其中所有方法、属性）</strong></u>。相当于 Python 里的 类方法、类属性；</li><li>根据第 4 步，<strong>我们可以在构造函数 <code>Func</code> 中使用 <code>this</code> 修改属性</strong>，这就相当于<strong>仅对当前对象修改属性和方法</strong>，相当于 Python 里的实例方法、实例属性（当然也可以在构造函数外修改）；</li></ul><p><u><strong>还有一个重要的特性，就是 查找对象自己的属性 可以 “fallback” 到原型对象上去查找</strong></u>。</p><p>比如下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instanceProp1</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instanceProp2</span> = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person2.<span class="property">name</span> = <span class="string">&quot;Sam&quot;</span>;    <span class="comment">// 相当于 “实例属性”</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// fallback to Person.prototype.name (&quot;Nicholas&quot;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>);    <span class="comment">// &quot;Sam&quot;</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 解释器如果无法找到对象的某个属性，那么它会通过 <code>[[prototype]]</code> 到它的原型中继续找。</strong></p><hr><p>还有一个问题，之前定义的 <code>__proto__</code> 不是指向共享的原型（其属性就像 Python 里的 类方法、类属性）吗？但它对开发者不可见，那么我该如何使用它？使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(&lt;obj&gt;) -&gt; <span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><p>这样直接能得到原型对象的引用，然后使用其中的属性就行。</p><p>此外，我们还可以分辨创建对象的接口类型（比 <code>constructor</code> 属性的比较更可靠）：使用 <code>Func.prototype.isPrototypeOf(&lt;obj&gt;)</code> 来判断 <code>obj</code> 是否由 <code>Func</code> 的原型构建出来。举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(p)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>还要记住一件事：由于 <code>Func.prototype</code> 被对象共享，所以<strong>请不要轻易替换原型对象，除非你知道你在做什么，否则会出现原型指代不一致的问题</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象后替换了原型对象，</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    name : <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    age : <span class="number">29</span>,</span><br><span class="line">    job : <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    sayName : <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原来的 friend 的 [[prototype]] 还指向旧的原型，</span></span><br><span class="line"><span class="comment">// 而旧的原型没有定义 sayName</span></span><br><span class="line">friend.<span class="title function_">sayName</span>(); <span class="comment">//error</span></span><br></pre></td></tr></table></figure><h4 id="5-2-3-EX-原生对象的原型"><a href="#5-2-3-EX-原生对象的原型" class="headerlink" title="5.2.3 - EX 原生对象的原型"></a>5.2.3 - EX 原生对象的原型</h4><p>原生对象也有原型，思路与这里一致，只需记住一点：</p><p>⚠⚠ ！！！<u><strong>强烈不建议修改原生对象原型</strong></u>！！！⚠⚠</p><h2 id="Chapter-6-函数表达式"><a href="#Chapter-6-函数表达式" class="headerlink" title="Chapter 6. 函数表达式"></a>Chapter 6. 函数表达式</h2><h3 id="6-0-函数表达式的复习-amp-箭头表达式"><a href="#6-0-函数表达式的复习-amp-箭头表达式" class="headerlink" title="6.0 函数表达式的复习 &amp; 箭头表达式"></a>6.0 函数表达式的复习 &amp; 箭头表达式</h3><p>JavaScript 中非常重要的特性，就是函数表达式。<strong>它是定义函数的一种手段</strong>。</p><p>在 2.8 和 4.5 中，我们了解到函数的两种定义方法，一种是直接声明，另一种就是函数表达式（可以创建匿名函数）。</p><p>而且前者会发生函数声明提升，后者不会。</p><p>根据这个特性，有些函数声明无法做到的逻辑，函数表达式却可以，例如根据条件选择函数指针：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Yo!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="keyword">var</span> sayHi;</span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    sayHi = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sayHi = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Yo!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了函数表达式，JavaScript 还支持 <strong>箭头表达式</strong>，但是它一定是匿名的，一般建议只把它作为使用一次的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;paramList&gt;) =&gt; &#123; &lt;funcBody&gt; &#125;</span><br></pre></td></tr></table></figure><p>有意思的是，箭头表达式支持异步（<code>async</code>）；</p><p>有一个 ⚠⚠<strong>危险</strong>⚠⚠：<strong>箭头表达式不能想函数表达式一样作为方法、构造函数等</strong>，这是因为箭头表达式内部<strong>不会定义 <code>this</code>，也没有 <code>arguments</code></strong>；</p><p>此外，函数表达式还有一些高级应用。</p><h3 id="6-1-应用Ⅰ：严格模式下的递归"><a href="#6-1-应用Ⅰ：严格模式下的递归" class="headerlink" title="6.1 应用Ⅰ：严格模式下的递归"></a>6.1 应用Ⅰ：严格模式下的递归</h3><p>为了防止递归函数赋给其他函数变量后可能无法使用的问题，递归函数内一般不写死自己的函数名，而是使用 <code>Function.arguments.callee</code> 的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在严格模式下，无法使用这个属性。我们可以把这个函数定义为函数表达式来巧妙避开这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">num</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num * <span class="title function_">f</span>(num-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="6-2-应用Ⅱ：闭包"><a href="#6-2-应用Ⅱ：闭包" class="headerlink" title="6.2 应用Ⅱ：闭包"></a>6.2 应用Ⅱ：闭包</h3><p>闭包和匿名函数很像，但它们是不同的概念。</p><p>闭包的定义是：<strong>有权访问另一个函数作用域中的变量的函数</strong>。</p><p>创建闭包的常用方法就是 <strong>函数内部定义函数</strong>。这样内部的函数就能访问外部函数的数据，这样内部函数就是闭包了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1, object2</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过有 2 点需要注意：</p><ol><li><p>闭包中，如果访问了外层函数的变量，那么在执行前该变量的值一直不会替换，而是原封不动地保存引用，例如这个例子的每个函数都返回 10：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createFunctions</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法是再加一个匿名函数，使得最内层的闭包无法访问到最外部变化的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createFunctions</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>和上面一个问题一样，这次是 <code>this</code> 对象。如果在对象中定义闭包，那么闭包是无法访问到对象作用域的<code>this</code>（只会找到全局作用域对象），所以需要手动在外部函数指定 <code>this</code> 对象的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">    getNameFunc : <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">// 这会获得 全局作用域中的 name 属性，而非 object.name</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;My Object&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attr">getNameFunc</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> that.<span class="property">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-3-应用Ⅲ：模仿块级作用域"><a href="#6-3-应用Ⅲ：模仿块级作用域" class="headerlink" title="6.3 应用Ⅲ：模仿块级作用域"></a>6.3 应用Ⅲ：模仿块级作用域</h3><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure><p>因为函数这样就能避免 <code>for</code> 语句中的计数变量 <code>i</code> 泄漏到全局中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;Written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt;《Professional JavaScript for Web Developers》 3rd Edition&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Web" scheme="https://sjtuxhw.top/tags/Web/"/>
    
    <category term="JavaScript" scheme="https://sjtuxhw.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浅析 TTY Subsystem</title>
    <link href="https://sjtuxhw.top/2024/01/15/%E6%B5%85%E6%9E%90-TTY-Subsystem/"/>
    <id>https://sjtuxhw.top/2024/01/15/%E6%B5%85%E6%9E%90-TTY-Subsystem/</id>
    <published>2024-01-14T23:12:02.000Z</published>
    <updated>2024-01-15T12:25:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>References: 参考文献见文章末尾。</i></p><p><i>本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h2 id="为什么讨论-TTY"><a href="#为什么讨论-TTY" class="headerlink" title="为什么讨论 TTY"></a>为什么讨论 TTY</h2><p>在 Linux 系统中，TTY 是一个相当有名的子系统。当你输入 <code>ls -l /dev</code> 的时候，你能看到许许多多以 <code>tty</code> 为前缀的字符设备，这就是对 TTY 子系统在文件上的抽象。</p><p>虽然我们无论是命令行还是 GUI 使用 Linux 的时候，TTY 似乎对我们无感，但是，当我因为一个小问题在互联网上查了很多关于 TTY 资料，却仍然很难找到一个完整的知识资料的时候，我发现这个 TTY 子系统的重要性被很多人忽视了。在整理了相关资料后，我愿意相信，搞清楚 Linux 的 TTY 子系统，属实是入门 Linux 系统的必由之路。</p><p><strong>尤其是，如果你想要写一些更接近 Linux 底层的、I/O interactive 方面的应用程序，那么 <code>TTY</code> 的知识就显得更加重要。</strong></p><p>前段时间，我在写 CSAPP 的 shell lab，工作量不大所以很快就完成了。但是文档里有句话让我不解，“这个 tiny shell <strong>不需要支持</strong>运行类似 <code>vim</code> 和 <code>tmux</code> 的程序，它们会对你的终端进行一些修改”。出于 “你不让我做，我偏要做” 的心态，我迅速拿着已经完工的 <code>tsh</code> 运行 <code>vim</code>，结果，<strong><code>vim</code> 被第 22 号信号挂起了</strong>。我尝试用内置指令 <code>fg</code> 将任务调向前台，也无济于事：</p><p><img src="imgs/fail.png"></p><p>很自然地，我查看了一下 22 号信号，发现是一个我未曾谋面的信号：<code>SIGTTOU</code>。很快啊，英文文档 “啪” 的一下就来了，我没有闪，只看见字里行间密密麻麻地挤满一个单词：<code>TTY</code>。</p><p>Google 了很多文章之后我才发现，我们一直使用的<strong>命令行（CLI）</strong>都建立在一个无形的机制之上，这个机制接收并且传递我们在终端软件窗口的字符指令，建立起用户和操作系统的 “调度 和 沟通” 的桥梁。这，我以前一直是没有关注的。</p><p>于是我明白，想要了解这之中究竟发生了什么、想要解决这个问题，就有必要了解一下 Linux TTY 了。</p><blockquote><p>对历史不感兴趣的同学请跳过下面一节。</p></blockquote><h2 id="TTY-的成长之路"><a href="#TTY-的成长之路" class="headerlink" title="TTY 的成长之路"></a>TTY 的成长之路</h2><p>实际上，TTY 在 OS 中的迭代和发展史谈不上 “elegant”，甚至可以用 “蜿蜒曲折” 来形容。</p><p>在 1869 年，一种机器叫做 “<strong>股票行情自动收录器</strong>”（stock ticker）在当时金融系统不断发展的资本主义世界诞生了。它的样貌可以描述一下——一个电驱动的机械装置，包含一台机械打字机（typewriter）、一捆的电线，还有一长串用以打孔的纸带组成，它工作时的样貌如下图<sup><a href="#fn_1" id="reffn_1">1</a></sup>：</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="imgs/tick1.png" width="300px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="imgs/tick2.png" width="300px" align=center></div></div></div></div><p>它的使用和早期的计算机一样（不过更早），都需要有一个操作员在一旁输入指令、处理输出纸带，<strong>最终可以达成 “远距离实时广播股票价格” 的任务</strong>，是不是有点像影视剧里的电报？</p><p>不过这个机器很快就演变为一个更快、基于 ASCII 编码的机械结构。知道它的名字的人可能会多一点：<strong>teletype</strong>（电传打字机，简称 TTY）。那么 teletype 在当时时如何完成给通信的另一方传输消息的功能的呢？答案是，连接上当时最大的 “网络”——<strong>Telex</strong>，专门用来在各个资本家之间传输商业电报。</p><p>你可能会好奇，这个时候的计算机是什么情况？很遗憾，这个时候计算机还超级大、超级原始，似乎和 teletype 没啥交集。但是没过几年，当计算机的设计和架构发展到，已经可以支持执行多任务（multitask）的时候，一个重要的能力，却也是等待解决的问题就来了：<strong>计算机可以与用户进行实时交互了</strong>。这意味着，之前 “将打孔写程序的纸带传入机器” 的<strong>旧批处理模型（old batch processing model）</strong>就可以被人机交互所代替，从而大大减小操作员运行计算机的工作量<sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p><p>那么，如何实现与机器的直接交互？（传纸带肯定不够高效的🤡 于是大佬们将视线转向当时市场中一个随处可见的机器——teletype 电传打字机。他们打算用 teletype 连接上计算机，这样只需要打打字向计算机发指令就可以达到交互和执行命令的效果。</p><p>有个难题是，当时市面上的 teletype 没有一个 “行业标准”，每个厂家生产的机器都略有不同。在计算机科学的视角来看，这好办，封装嘛，设计一个统一的 <strong>从 teletype 输入到 计算机的软件层适配接口</strong>（硬件层好说，就串口电信号而已，主要是软件驱动）就行，下次无论 teletype 生产厂家设计什么样的机型，只要计算机的系统支持这个接口规范，那不拿来就能用？</p><p>在当时的 Unix 世界中（当时 Unix 已经出现），一种方法是让 OS Kernel 来实现这层接口，处理所有有关于 teletype 输入的底层细节，例如字长（word length）、串口波特率（baud rate）、流控制（flow control）、校验（parity，学过数电的同学会比较清楚这里面的机制）、基础的行 buffer 编辑能力等等。</p><p>在 20 世纪 70 年代晚期，基于 teletype 和 OS 处理接口的一类新型输入终端出现了（例如 VT-100），它们在 teletype 的基础上包装了屏幕，支持闪烁的命令行光标、有色彩的输出信息等等，被人们称为 <strong>video terminals</strong>。</p><p>不过，到了今天，我们可以发现所有实体的 teletypes、video terminals 都已经 “灭绝” 了，你只能在一些博物馆，或者硬件发烧友的收藏中寻得它们的踪迹。</p><p>由于历史习惯的原因，当今你能看到所有的 Unix 类系统中还有 “TTY”，不过它们都是对以往的 video terminals 在软件上的模拟而已。正如一位外国网友所说：</p><blockquote><p>The legacy from the old cast-iron beasts is still lurking beneath the surface<sup><a href="#fn_3" id="reffn_3">3</a></sup>.</p><p>这头钢铁巨兽（teletypes）的意志仍蛰伏在如今的 OS 的外表之下<sup><a href="#fn_3" id="reffn_3">3</a></sup>。</p></blockquote><h2 id="用户视角下的-TTY-old-versions"><a href="#用户视角下的-TTY-old-versions" class="headerlink" title="用户视角下的 TTY: old versions"></a>用户视角下的 TTY: old versions</h2><p>想要了解现代 Linux 系统中的 TTY 机制，我们还需要将时间拨回很早以前——人们使用实体 teletype 输入的时候。我们将 teletype 这个输入计算机指令以实现人机交互的设备称之为 <strong>终端（terminal）</strong>。当时的软硬件结构是这样的：</p><p><img src="imgs/case1.png"></p><p>teletype 是用一捆捆电线连接到计算机的一个叫 <strong>UART</strong>（Universal Asynchronous Receiver and Transmitter，通用异步收发器）的硬件设备上的。</p><p>对应地，内核里就写了一个驱动 UART driver，用来管理从物理 terminal 设备上发来的电信号 bytes，处理一些细节例如前一节提到的 bytes 校验、流控制。</p><p>一开始，UART driver 是直接将初步处理好的 bytes 流直接传给一些正在运行的进程，但是显然这种方法需要弥补几个缺陷：</p><p><strong>1. 行编辑能力（Line Editing）</strong></p><p>正常人在敲键盘（当时是敲打字机）的时候，无法避免的可能会打错。所以，肯定得有 backspace 退格的功能对吧？这个功能当然可以交给接收信号的进程自己来处理，但是计算机科学讲究不能混淆抽象层级，而且这也不符合 Unix 的设计哲学——运行在其上的程序应该越简单越好（只关心自己的业务逻辑）。</p><p>所以为了方便考虑，当时的人们直接把这个功能也放到了操作系统内核里了。这时，操作系统就需要提供一个编辑内容的缓冲区（editing buffer），并且支持一些基本的编辑指令（退格、擦除单词、清空一行等），这些软件功能模块被叫做 <strong>line discipline</strong>（好家伙，这是在内核里写了一个行编辑器），它的地位如本节开头的图所示。</p><p>不过，不同的上层应用程序对于它们接收的输入流肯定有各种各样的自定义的要求，因此 line discipline 除了提供正常的行编辑功能（cooked or canonical mode），还提供 <strong>raw mode</strong>（对输入流不做处理）。因此这些 advanced application（例如本身就是编辑器软件、邮件客户端、shells，以及自己调用 <code>curses</code> 和 <code>readline</code> 的程序）常常将系统的 line discipline 设置为 raw mode，然后自己执行对流的控制。</p><p>正如上面所说，OS Kernel 提供了多种不同的 line disciplines，不过<strong>一次只有一个 line discipline attach 到指定的串口设备上</strong>（对于旧时设备，如上图，串口设备是 UART driver）。默认的 line discipline 会提供基本的行编辑功能，叫做 <code>N_TTY</code>（<code>driver/char/n_tty.c</code>），还有另外种类的 line disciplines 控制例如鼠标串口等。</p><p><strong>2. 会话管理（Session Management）</strong></p><p>还有一个很重要的一点是，对于一个用户而言可能他（她）需要同时运行多个程序，然后一次与它们之中的一个程序交互。总的来说，用户需要：</p><ul><li><p>如果一个应用程序陷入死循环，那么用户可能会需要向其发信号（kill / suspend……）；</p></li><li><p>一个后台程序如果需要向终端（terminal）写数据，那么它们需要被 <strong>suspend 直至前台进程处理结束，或者前台程序已经为其准备好了写终端的环境</strong>。</p><blockquote><ol><li><p>为什么需要 suspend？不然所有后台程序都能随意更改终端，那不乱套了！其实，再想想，你在后台运行一个 <code>echo &quot;Hello&quot;</code> 好像也不会挂起？这个问题与之前的不相悖，我们后面讨论；</p></li><li><p>这个 suspend 的机制就是借助了 OS Kernel 发送的 <code>SIGTTOU</code> 机制，后面详细说。</p></li></ol></blockquote></li><li><p>用户向当前 terminal 输入，肯定只能发送给当前的 “前台”（foreground）进程。</p></li></ul><p>常见的 OS 都会 implement 一个 TTY driver（<code>drivers/char/tty_io.c</code>）来实现上述需要（具体地位前本章开头的图片）。TTY driver 也是个软件，但和一般的 “进程” 不一样：它是个 “passive object”，这意味着它像一个库，只有一些数据域（data fields）和一些方法（methods），等待其他进程的主动调用 / 内核中断 handler 调用。</p><p>于是，人们通常将 <strong>UART driver</strong>（常用来直接读取串口设备、进行简单 parity 和 flow control）、<strong>line discipline 实例</strong>（用来作为 editing buffer，处理简单的行编辑命令）、<strong>TTY driver</strong>（多个进程间读取 terminal 的会话管理）三元组（triplet）称为一个 <strong>TTY device（TTY 设备）</strong>。</p><p>因此，Unix 操作系统对上层的应用程序抽象的 terminal 就是 <code>TTY</code> 设备文件，存放于 <code>/dev</code>。</p><blockquote><p>顺便提一句，Unix 系统想要对 TTY 设备文件写入的用户需要是这个 TTY 设备文件的拥有者（owner）。我们经常使用 <code>shell</code> 的 login mode 登陆服务器时，内部会执行 <code>login</code> 程序，其工作之一便是以 <code>root</code> 权限将 shell 接下来需要使用的 <code>/dev/ttyN</code> 的拥有者换为登陆用户，以便登录用户能够读写 terminal；</p></blockquote><h2 id="用户视角下的-TTY-modern-versions"><a href="#用户视角下的-TTY-modern-versions" class="headerlink" title="用户视角下的 TTY: modern versions"></a>用户视角下的 TTY: modern versions</h2><p>我们了解了以前计算机是如何将 teletype 连接到计算机上并与之交互的，现在我们再将视野转移到现代计算机（desktop system，一般是图形化的）。</p><p>还是讨论现代 Unix 系统，这个时候输入输出模型可以抽象为如下图形：</p><p><img src="imgs/case2.png"></p><p>此时 TTY driver 和 line discipline 的 作用和以往版本的作用几乎相近，但是现在已经不存在 teletype 了，取而代之的是 键盘 和 显示屏，因此就没有 UART 和实体 terminal 什么事了。</p><p>取而代之的，是一个在 <strong>terminal emulator 中模拟的 video terminal</strong>（可以理解为<strong>一个包括了字符帧缓存（frame buffer of characters）和图形属性）的复杂状态机</strong>）。</p><p>它的作用是接收来自键盘驱动的预处理信号，将其传给对应得 line discipline，并将输出数据渲染到 VGA 显示器上。</p><p>等等！不太对，我们一直讨论的是 terminal emulator，因此有下面 2 种问题：</p><ul><li>目前这台计算机还只能简单字符输入和显示，相当于只实现了命令行子系统（console subsystem）；</li><li>emulator 位于<strong>内核中</strong>，不够灵活（rigid），在抽象层级上说，为了可维护性和可扩展性，应该将其挪到用户态空间中（userland）；</li></ul><p>事实上，为了解决上面的问题，TTY device 的设计更加抽象了：</p><p><img src="imgs/case3.png"></p><p>我们发现，line discipline、TTY driver 的结构都不需要变嘛，因为它们还需要提供基本的行缓冲、会话管理的功能。因此，人们在内核中设计出了 <strong>pseudo terminal（<code>pty</code>，伪终端）</strong>，用于对接支持 <code>xterm</code>（Unix 中一种默认的终端模拟器）的桌面程序。</p><blockquote><p>注意，如果你在一个 <code>xterm</code> 桌面进程中调用了 <code>screen</code>、<code>tmux</code> 等程序，那么就是 pseudo terminal 套 pseudo terminal 的复杂结构，这里不讨论。</p></blockquote><h2 id="TTY-与-进程"><a href="#TTY-与-进程" class="headerlink" title="TTY 与 进程"></a>TTY 与 进程</h2><p>了解了 <code>TTY</code> 的发展和构成，那么 process 是如何和 PTY 对接的呢？为了讨论这个问题，我们需要复习一些进程、shell job control 的知识。</p><h3 id="补充-1：Unix-Processes"><a href="#补充-1：Unix-Processes" class="headerlink" title="补充 1：Unix Processes"></a>补充 1：Unix Processes</h3><p>大部分学过 CSAPP 的同学可能对进程已经有了初步了解，尤其是在考完了 ICS 之后对其理解更为深刻…… 不过 CSAPP 关于进程的知识并不是操作系统的全部，我们下面补充一点。</p><p>一个 Linux Process 通常有 <strong>5 种状态</strong>：</p><p><img src="imgs/process.png"></p><ul><li><p><code>R</code>：Running / Runnable（On OS run queue），此状态的进程正在 CPU 上运行，或者做好被 CPU 调度的一切准备；</p></li><li><p><code>D</code>：Uninterruptible sleep（waiting for some events），此状态的进程因为某些指令正在等待某些事件，大部分原因是 <strong>I/O 事件</strong>，通常不会被 CPU 调度；</p><blockquote><p>例如，程序执行到 <code>read</code> 等系统调用时，等待 I/O 设备触发 CPU 中断引脚；</p></blockquote></li><li><p><code>S</code>：Interruptible sleep（waiting for some events or signals），此状态的进程因为某些指令正在等待某些事件，或者等待某类信号，通常不会被 CPU 调度；</p><blockquote><p>例如，程序执行到 <code>pause</code>、<code>sleep</code> 等系统调用时，挂起等待信号 / 系统计时器中断；</p></blockquote></li><li><p><code>T</code>：Stopped，外部造成的暂停执行，只有 2 种可能：<strong>shell 的 job control signal，或者 debugger 断点</strong>；</p></li><li><p><code>Z</code>：Zombie，已经终止的子进程，但是父进程存在，并且没有回收它；</p></li></ul><p>进程组的知识不再赘述，与大家在 CSAPP 中接触到的一样。</p><h3 id="补充-2：Shell-Job-Control"><a href="#补充-2：Shell-Job-Control" class="headerlink" title="补充 2：Shell Job Control"></a>补充 2：Shell Job Control</h3><p>在 CSAPP 的 shell lab 中，我们进一步深化了对课本中 shell 的理解。通常情况下，一个 shell 承担了一个重要的工作：对用户的程序管理为 <strong>前台、后台</strong> 两种形式，方便用户指定和操作。这种管理方法就称为 <strong>job control</strong>。</p><p>正如 CSAPP 一书中对 job control 的说明，shell 的进程管理应该呈现如下的模式：</p><p><img src="imgs/process_group.png" height="300px"></p><p>当用户通过 shell 登陆，或者仅启动 shell 时，shell 作为系统中的一个进程，会单独设置自己的进程组（自己进程组号改为与自身进程号一致，防止与父进程联系，导致收到父进程的信号）；</p><p>此后，通过 shell 创建的所有进程（执行的所有程序）都会在 <code>execve</code> 前设置单独的进程组号，方便 shell 统一管理。前台、后台进程的子进程一般都在自己的进程组里。其中前台进程只有一个，后台进程有多个。</p><p>但是！CSAPP 中没有说明的一点是，<strong>前台进程是如何与用户输入建立联系的？更准确地说，前台进程如何准确 attach 到当前的 pseudo terminal 上的？</strong></p><h3 id="补充-3：Shell-Sessions（重要）"><a href="#补充-3：Shell-Sessions（重要）" class="headerlink" title="补充 3：Shell Sessions（重要）"></a>补充 3：Shell Sessions（重要）</h3><p>实际上，Linux 上除了进程、进程组，还有一个重要的机制 <strong>会话（Session，其实 Windows 上也有）</strong>。对应的，每个进程也有一个 session ID（<code>sid</code>），其机制如下：</p><ul><li><p>一个 <code>session</code> 一般包含了多个进程，不过其中有且仅有一个进程是特殊的，被称为 <strong>session leader</strong>，它一般是创建这个 session 的进程；</p><blockquote><p>注：Session Leader 可以在进程信息中看到。</p><p>大家不妨运行 <code>ps aux</code> 查看一下当前进程的状况，比如：</p><p><img src="imgs/ps.jpg" height="300px"></p><p>中间红框的一列描述的就是各个进程的状态。其中可能出现的 <code>D</code>、<code>R</code>、<code>S</code>、<code>T</code>、<code>Z</code> 称为 <strong>标识符</strong>，就是之前介绍的含义。还有一类标识符 <code>I</code> 表示 Idle Kernel Thread（空闲的内核线程）<sup><a href="#fn_4" id="reffn_4">4</a></sup>；</p><p>不过除此以外还有一些修饰符，例如：</p><ul><li><code>&lt;</code> 表示该进程的优先级较高（一般是 <code>root</code> 用户指定）；</li><li><code>N</code> 表示该进程优先级较低（一般是普通用户创建，并且主动 Sleep 的时间很长）；</li><li><code>s</code>（小写）<strong>表示该进程为 session leader</strong>；</li><li><code>l</code> 表示该进程中的程序是多线程的；</li><li><code>+</code> <strong>表示该进程在 shell 指定的前台进程组（foreground process group）中</strong>；</li></ul></blockquote></li><li><p>每个新创建的进程的 <code>sid</code> 与父进程相同（<strong>与父进程共用一个 session</strong>）；</p></li><li><p>一个 pseudo terminal 只能与一个 session 建立联系；与当前 <code>pty</code> 建立联系的 session 中，只有 session leader 有权控制 <code>pty</code> 和 session 的联系；</p><blockquote><p>这里的 “联系” 需要开发者（例如 shell 开发者）<strong>显式提醒 <code>TTY driver</code> foreground process group 的 group id</strong> 才能完成。<strong>使用系统调用 <code>tcsetpgrp</code></strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set the specific process group as the foreground process group. */</span></span><br><span class="line"><span class="comment">/* `fd` must be the controlling terminal of the calling process,</span></span><br><span class="line"><span class="comment"> * and still be associated with its session. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcsetpgrp</span><span class="params">(<span class="type">int</span> fd, <span class="type">pid_t</span> pgrp)</span>;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>如果 <strong>后台进程组的程序想要读 <code>stdin</code> 或写 <code>stdout</code></strong>（指向当前 session 对应的 <code>pty</code>），那么 OS Kernel 会向该进程发送 <code>SIGTTIN / SIGTTOU</code> 信号（default action 是终止进程），要求该后台进程等待；</p><blockquote><p>某些情况下，即便是后台进程组也可以直接向当前 session 写，例如在终端上执行命令： <code>echo Hello &amp;</code>，则会直接打印内容。</p><p>这与终端的设定有关。首先 OS 和 <code>TTY device</code> 的设计者们意识到以下的用户需求：</p><ol><li>用户<strong>不希望</strong>后台进程读取当前 terminal 的输入；</li><li>用户<strong>可能允许</strong>后台进程向当前 terminal 输出；</li><li>用户<strong>可能不希望</strong>后台进程更改当前 terminal 的设置（包括串口比特率、line discipline、输出策略等等）；</li></ol><p>因此针对以上需求，设计者们设定：</p><ol><li><strong>OS 不允许后台进程从当前 <code>pty</code> 读入，kernel 一定会对调用读入操作的进程发送 <code>SIGTTIN</code> 信号</strong>；</li><li><strong>OS 默认允许后台进程向当前 <code>pty</code> 输出。允许用户修改这一行为</strong>；</li><li><strong>OS 默认不允许后台进程修改当前 <code>pty</code> 设置，kernel 一定会对该进程发送 <code>SIGTTOU</code> 信号</strong>；</li></ol><p>另外补充一句，用户可以通过 <code>stty</code> 指令来查看、修改当前终端设置。例如：</p><ul><li><code>stty [-a/--all]</code>：打印当前终端设置；</li><li><code>stty tostop/-tostop</code>：设置<strong>不允许 / 允许后台进程向当前 <code>pty</code> 输出</strong>，默认允许；</li></ul></blockquote></li></ul><p>到这里，我们终于能够解释文章一开始的问题了——为什么 <code>tsh</code> 中运行 <code>vim</code>，<code>vim</code> 会收到 <code>SIGTTOU</code> 了。这是因为 <strong>CSAPP 的 shell lab 对 “前台进程” 的处理方式有问题，它没有真正将要在前台执行的进程加入前台进程组</strong>。</p><h3 id="Conclusion-TTY-amp-Process-with-SIGNALs"><a href="#Conclusion-TTY-amp-Process-with-SIGNALs" class="headerlink" title="Conclusion: TTY &amp; Process with SIGNALs"></a>Conclusion: TTY &amp; Process with SIGNALs</h3><p>现在，所有必须的知识已经集齐了，我们来看看 <code>TTY</code> 与进程交互的总体机制。</p><p>之前提到过 Unix 中的一切 I/O 设备都被抽象为 Unix files，这也包括 TTY device。与其他文件一样，一个进程想要进行读写前必须进行一些初始化操作，这个初始化就要求进程与内核间通信，所以<strong>信号</strong>是不可避免的。</p><blockquote><p>Tips. 在 <code>ioctl</code> C 库中含有许多与 <code>TTY</code> 设备读写相关的操作。</p></blockquote><p>我们以涉及修改 <code>pty</code> 设置的一串动作来举个例子。</p><p><strong>step 1.</strong> 假设你在一个 login shell 中执行 <code>vim</code>，那么：</p><p>当前 shell 为 <code>vim</code> 创建一个进程（<code>fork &amp; execve</code>）和进程组（<code>setgid</code>），通知 <code>TTY device</code> 将该进程标记为前台进程组（<code>tcsetpgrp</code>）；</p><p>所以你会看到如下图，启动 <code>vim</code> 后，<code>vim</code> 进程所在组成为 foreground process group（进程状态 <code>S+</code>）；而 shell（这里是 <code>zsh</code>）进程则由 <code>Ss+</code> 转为 <code>Ss</code>（不再是前台进程，但仍是 session leader），并且它们都位于同一个 session 中（指向同一个 <code>pts</code>，即 <code>pts/1</code>）：</p><p><img src="imgs/vim.png" height="350px"></p><p><strong>step 2.</strong> 假设你在 <code>vim</code> 运行时按下 <code>Ctrl + Z</code> 将 <code>vim</code> 转向后台挂起，那么：</p><p>触发 Asynchronous Exception（ECF），<code>vim</code> 作为前台进程组直接收到 OS Kernel 发送的 <code>SIGTSTP</code> 信号。在 <code>vim</code> 的 <code>SIGTSTP</code> signal handler 中，<code>vim</code> 做挂起前的准备工作（例如通过向 <code>TTY device</code> 输出特定序列，将光标移动到上次位置、恢复打开前的命令行内容等等）。最后 <code>vim</code> 向自己进程组发送 <code>SIGSTOP</code>，正式将自己的进程组挂起到后台；</p><p>此时，<code>vim</code> 父进程（之前的 shell）收到 <code>SIGCHLD</code> 信号，shell 进入对应的 handler 进行处理（例如打印 <code>[1]+ Stopped</code> 信息给用户等工作），并且将自己的进程设置为前台进程组（<code>tcsetpgrp</code>）；</p><blockquote><p><strong>这个时候，如果你试图以后台形式运行 <code>vim</code>（例如 <code>bg</code>），那么 <code>vim</code> 会收到 kernel 的 <code>SIGTTOU</code> 信号，继续挂起</strong>（因为 <code>vim</code> 会更改终端设置，例如 line discipline 等等）；</p></blockquote><p><strong>step 3.</strong> 假设此时你使用 <code>fg</code> 将 <code>vim</code> 转到前台继续执行，那么：</p><p>shell 会恢复上一次的 <code>pty</code> 设置、通知 <code>TTY device</code> 当前的前台进程为 <code>vim</code> 所在进程、向 <code>vim</code> 进程发送 <code>SIGCONT</code> 继续。于是 <code>vim</code> 恢复运行、重绘界面；</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>当然，<code>TTY device</code> 在与进程交互时，还有更多可用的操作和行为，例如 flow control、blocking I/O，以及文中没有详细介绍的 <code>pty</code> 终端设置，等等。感兴趣的童鞋可以查阅 Linux 的官方文档、本文所引用的参考资料，或者是 man 文档。更多问题或勘误欢迎交流 ~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>:<a href="https://en.wikipedia.org/wiki/Ticker_tape">Ticker tape - Wikipedia</a><br><sup><a href="#fn_2" id="reffn_2">2</a></sup>: <a href="https://en.wikipedia.org/wiki/Batch_processing">Batch processing - Wikipedia</a><br><sup><a href="#fn_3" id="reffn_3">3</a></sup>: <a href="https://www.linusakesson.net/programming/tty/">The TTY demystified (linusakesson.net)</a></p><p><sup><a href="#fn_4" id="reffn_4">4</a></sup>:<a href="https://stackoverflow.com/questions/14315923/why-does-linux-kernel-need-idle-thread">smp - Why does linux kernel need idle thread? - Stack Overflow</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;References: 参考文献见文章末尾。&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
    <category term="Linux" scheme="https://sjtuxhw.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>放假！吐槽！</title>
    <link href="https://sjtuxhw.top/2024/01/13/%E6%94%BE%E5%81%87%EF%BC%81%E5%90%90%E6%A7%BD%EF%BC%81/"/>
    <id>https://sjtuxhw.top/2024/01/13/%E6%94%BE%E5%81%87%EF%BC%81%E5%90%90%E6%A7%BD%EF%BC%81/</id>
    <published>2024-01-13T06:33:01.000Z</published>
    <updated>2024-01-15T13:38:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hooray"><a href="#Hooray" class="headerlink" title="Hooray !"></a>Hooray !</h2><p>家人们，经历了大半个月的期末周，终于来到假期了！我又活过来了😭 上个学期的时间安排实在是不太充裕，我想我得调整下节奏了🤔</p><h2 id="ツッコミ"><a href="#ツッコミ" class="headerlink" title="ツッコミ"></a>ツッコミ</h2><p>吐槽一下，在准备考试的时候，我和同学们为了分数反复写一些固定的题型，尤其是物理题。不是说我们不应该做物理题，而是这样的做法时间利用的效率真的不高。</p><p>之前看到过一篇文章说的感觉挺有道理的。我们常常听一些教育专家说，现在的学生要全面培养学科交叉能力，我无比赞同这句话，毕竟学科交叉既能开阔我们的专业视野，了解到很多其他方面的学识，又能提升我们的综合素质和学术能力，这是毋庸置疑的。</p><p>另一方面，我认为这个学科交叉是需要说明限度和范围的，而不是学科课表的 “自由组合”。以工科类专业举例，很多人会想，工科嘛，那不得来一整套大学物理，一直学到量子力学，加一点 “金课”，再加五花八门的大学物理实验；末了，再添一点理论力学、甚至大学化学，entitled “学科交叉素养的培养”。</p><p>这个本意是好的，但：每当我看到有些工科同学（惭愧地说，包括笔者）拿着学长学姐留下的 “报告模板”，花一大把时间在大物实验报告上，然后上交后再忘得一干二净，<strong>从此再也不会接触到它</strong>；每当我看到工科同学为了应对课时日益增加的大学物理、应对挖空心思出难题怪题只为<strong>正态成绩分布</strong>的教员们，拼命做题、掌握甚至背诵解题技巧的时候，我的心中总是有种奇怪的滋味。</p><p>也许我们没法改变，那么就要去适应游戏规则。尽管别人告诉你，“哎，大学物理实验能培养你的动手实践能力和写报告的水平，和你的主课一样重要”，你也一定要拎清楚主次，将 “dirty work” 和正常工作 “区别对待”。</p><p>打个不恰当的比方，有人说 “扫一下午大街” 和 “背诵一个下午英语单词” 一样重要，前者锻炼了你的劳动素养，后者增长了你的学术水平，咱不是要全面发展嘛。听起来好像做这两件事各有好处，难以取舍。实际上我们用常识想一想，作为一个学生，肯定很少有人会选择前者来消磨下午的时光。</p><p><strong>因为这并不是这两件事本身的价值孰优孰劣的问题，这是二者谁能为现在的我们提供更大的效益的个体问题。</strong></p><p>“今当远离，临表涕零，不知所言” 🤭。</p><hr><p>吐槽归吐槽，生活还是要继续。最后，终于可以自由地做自己的事情，停更许久的博客也终于可以继续更新了……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hooray&quot;&gt;&lt;a href=&quot;#Hooray&quot; class=&quot;headerlink&quot; title=&quot;Hooray !&quot;&gt;&lt;/a&gt;Hooray !&lt;/h2&gt;&lt;p&gt;家人们，经历了大半个月的期末周，终于来到假期了！我又活过来了😭 上个学期的时间安排实在是不太充裕，</summary>
      
    
    
    
    <category term="Chat" scheme="https://sjtuxhw.top/categories/Chat/"/>
    
    
    <category term="tease" scheme="https://sjtuxhw.top/tags/tease/"/>
    
    <category term="holiday" scheme="https://sjtuxhw.top/tags/holiday/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Notes: Scheduler &amp; Arch</title>
    <link href="https://sjtuxhw.top/2023/11/11/CSAPP-Notes-Scheduler-Arch/"/>
    <id>https://sjtuxhw.top/2023/11/11/CSAPP-Notes-Scheduler-Arch/</id>
    <published>2023-11-11T01:18:11.000Z</published>
    <updated>2024-05-16T11:02:30.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-8-Scheduler-in-OS"><a href="#Chapter-8-Scheduler-in-OS" class="headerlink" title="Chapter 8. Scheduler in OS"></a>Chapter 8. Scheduler in OS</h1><p>为操作系统的调度环境作出假设：</p><ol><li>Each job runs for the same amount of time</li><li>All jobs arrive at the same time</li><li>Once started, each job runs to completion</li><li>All jobs only use the CPU <ul><li>i.e., they perform no I/O</li></ul></li><li>The run-time of each job is known</li></ol><p><u>引入调度优劣衡量指标：周转时间</u>，<strong>$T_{turnaround}=T_{completion}-T_{arrival}$</strong>；</p><h2 id="Strategy-1-FIFO（FCFS，First-Come-First-Served）"><a href="#Strategy-1-FIFO（FCFS，First-Come-First-Served）" class="headerlink" title="Strategy 1: FIFO（FCFS，First Come First Served）"></a>Strategy 1: FIFO（FCFS，First Come First Served）</h2><ul><li>Implementation: queue；</li><li>消除假设 1：若短时任务排在长时任务之后，则平均周转时间效果很差；</li></ul><h2 id="Strategy-2-SJF（Shortest-Job-First）"><a href="#Strategy-2-SJF（Shortest-Job-First）" class="headerlink" title="Strategy 2 : SJF（Shortest Job First）"></a>Strategy 2 : SJF（Shortest Job First）</h2><ul><li>内容：对于<strong>同时到达的</strong>任务，优先选择总时长小的任务。</li><li>作用：（应对假设 1 的消除）缓解了<strong>短时任务排在长时任务之后所造成的较差的平均周转时间</strong>；</li><li>消除假设 2：不同任务到达的时间不一样。如果短时任务出现在长时任务开始后的很短的时间内，那么平均周转时间也很差（<strong>一般没有竞争抢占机制，具体请看题目要求</strong>）；</li></ul><h2 id="Strategy-3-STCF（Shortest-Time-to-Completion-First）"><a href="#Strategy-3-STCF（Shortest-Time-to-Completion-First）" class="headerlink" title="Strategy 3 : STCF（Shortest Time-to-Completion First）"></a>Strategy 3 : STCF（Shortest Time-to-Completion First）</h2><ul><li>内容和作用：（应对假设 2 的消除）竞争抢占机制（<strong>preemptive</strong>），晚到达的短时任务如果<strong>执行剩余时间</strong>短于长时任务的剩余时间，则进行抢占切换；</li><li><u><strong>添加一个衡量标准</strong>：Response Time（反应时间）</u>；<ul><li>the time from when the job arrives in a system to the first time it is scheduled;</li><li><strong>$T_{resp}=T_{firstturn}-T_{arrival}$</strong>;</li></ul></li><li>STCF 在 Response Time 中，如果恰好各个任务消耗的时间相近，它们无法抢占，但是抢占时间会很大；</li></ul><h2 id="Strategy-4-Round-Robin（时间片轮转）"><a href="#Strategy-4-Round-Robin（时间片轮转）" class="headerlink" title="Strategy 4 : Round Robin（时间片轮转）"></a>Strategy 4 : Round Robin（时间片轮转）</h2><ul><li>作用：（提升 Response Time）设计<strong>时间片（Time slice）</strong>，每个任务最多只能执行一段时间的代码，超时则切换到其他进程，使用上面的切换策略；</li><li>注意点：合理设计时间片长度（10ms），防止频繁的切换操作占用大量资源（switching cost）；</li><li>与 SJF 策略比较：有利有弊；</li><li>消除假设 4：任务可能存在 I/O 操作，耗时操作导致该进程很多时间片空闲；</li></ul><h2 id="Strategy-5-Overlap-when-performing-I-O-operation"><a href="#Strategy-5-Overlap-when-performing-I-O-operation" class="headerlink" title="Strategy 5 : Overlap when performing I/O operation"></a>Strategy 5 : Overlap when performing I/O operation</h2><ul><li>内容：当发生 I/O 操作时，应用必然调用系统调用，操作系统可以将此任务 block 进入 stopped 状态，并进行 context switch；</li><li>作用：在进行 I/O 操作时发生 switch，充分利用 I/O 操作的空隙，进行有效的 overlap；</li><li>消除假设 5：任务的运转时间未知，相当于无法比较任务是短时任务还是长时任务（例如交互式任务）；</li></ul><h2 id="Strategy-6-Multi-Level-Feedback-Queue-Scheduler（MLFQ）"><a href="#Strategy-6-Multi-Level-Feedback-Queue-Scheduler（MLFQ）" class="headerlink" title="Strategy 6 : Multi-Level Feedback Queue Scheduler（MLFQ）"></a>Strategy 6 : Multi-Level Feedback Queue Scheduler（MLFQ）</h2><ul><li><p>作用：1. <strong>优化未知任务时长（without a priority knowledge of job length）情况下的周转时间</strong>；2. <strong>最小化响应时间（在用户交互式应用中很重要）</strong>；</p></li><li><p>如何在<strong>没有先验知识</strong>的情况下，做出最合适的任务调度？</p><ol><li><p><strong>Learning from history</strong>：从系统运行程序的特性中做出猜测（类似分支预测器）；</p><ul><li>the multi-level feedback queue;</li></ul></li><li><p><strong>优先级预测队列</strong>策略：</p><p>Rule 1：任务队列使用<strong>多个队列，每个队列的优先级不同，同样队列中的任务优先级相同</strong>，<strong>优先级高的队列中的任务请求资源时，先于优先级低的任务</strong>；</p><p>Rule 2：如果两个任务处于同一优先级，则二者使用 <strong>Round Robin</strong> 策略；</p><blockquote><p>接下来需要考虑优先级的设置和改变问题。</p><p>考虑到 workload 同时含有 <strong>交互式任务</strong>（interactive jobs，CPU 使用时间一般很短，例如用户交互）和 <strong>CPU 密集型任务</strong>（CPU-bound，CPU 使用时间一般很长，例如矩阵计算，一般对 response time 要求不高）；</p></blockquote><p>Rule 3：当一个任务进入系统任务队列时，<strong>最先总是放到最高优先级</strong>；</p><p>Rule 4a：如果一个任务耗尽了一个周期中的所有时间片，那么 CPU 可以认为这个任务<strong>更有可能</strong>是个 CPU-bound job，那么<strong>先降低一个优先级，直到最低优先级</strong>；</p><p>Rule 4b：如果一个任务没有耗尽一个周期的时间片就释放 CPU 资源，那么 CPU 可以认为这个任务<strong>更有可能</strong>是一个 interactive job，那么<strong>保持在当前优先级</strong>；</p></li></ol></li><li><p>缺陷：</p><ol><li><strong>Starvation</strong>：如果有非常多的 interactive jobs 同时运行在最高优先级，那么<strong>很有可能导致最低优先级的 CPU-bound jobs 始终无法得到 CPU 资源</strong>；</li><li><strong>Gaming scheduler attack</strong>：一些恶意程序可能利用这个策略，设计占用大部分时间片内容，但在结束前释放 CPU 资源，这样会一直保持最高优先级，并且妨碍其他程序运行；</li><li><strong>Programs may change its behavior overtime</strong>：一些任务可能在 interactive 与 CPU-bound 的特性间相互转换；</li></ol></li><li><p>改进</p><ul><li><p>Rule 5（<strong>Priority Boost</strong>）：当某个时间周期 <strong>S</strong> 后，将所有任务都移动到<strong>最高优先级</strong>；</p><blockquote><p>好处 1：解决缺陷 1，消除 starvation 现象，保证每个进程都会被调度到；</p><p>好处 2：解决缺陷 3，方便 MLFQ 重新评定各个进程的 priority（保证 interactive / CPU-bound 相互转换的程序被分配到合适的优先级）；</p></blockquote></li><li><p><strong>Refined</strong> Rule 4（<strong>Better Accounting</strong>）：任务在<strong>当前优先级中的全部运行时间累积计算</strong>，以累积的时间长短作为是否降低优先级的评判标准；</p><blockquote><p>好处：解决缺陷 2，故意保留一个时间片剩余时间的程序，如果总 CPU 用时很长，也会被降低优先级；</p></blockquote></li></ul></li><li><p>具体实现：MLFQ 具体的参数是怎样的？怎么落实它的参数？</p><ul><li>MLFQ 应该有几个队列（几个优先级）？</li><li>时间片长短的设计：每个优先级的任务的时间片长度应该多长？</li><li>进行 Priority Boost 的频率应该如何？（既能保证不过度更新浪费资源，又能保证减小 starvation 和 changes in behavior 导致运行效率减慢的可能？）</li></ul></li><li><p>Tuning 与 微调</p><p>针对以上 tuning MLFQ 使其最大化系统性能的过程<strong>没有一个固定的最优解</strong>。大多数情况需要进行调参、凭借经验取定。</p><p>不过有一些通识的点，满足这些点的参数设计一定能够更好提升 MLFQ 的性能：</p><ul><li><p>对于<strong>高优先级的</strong>任务，分配给其的时间片时间应该更<strong>短</strong>些为佳；</p><p>它们通常较少地使用 CPU 资源，可能是 interactive 类型地任务，切换得更频繁；</p></li><li><p>对于<strong>低优先级的</strong>任务，分配给其的时间片时间应该更<strong>长</strong>些为佳；</p><p>它们通常是 CPU-bound 类型任务，分配更长的时间片能够更好地完成任务；</p></li></ul></li></ul><h1 id="Chapter-9-Y86-64-A-self-defined-ISA"><a href="#Chapter-9-Y86-64-A-self-defined-ISA" class="headerlink" title="Chapter 9. Y86-64: A self-defined ISA"></a>Chapter 9. Y86-64: A self-defined ISA</h1><blockquote><p>Y86-64 是由 CMU 教授设计，SJTU 老师改进的一种教学用指令集架构，实际生产中没有处理器使用此架构。</p><p>学习它的目的是 <strong>更好地了解 CPU 与 ISA 间的关系和实现思路，剥离开复杂的细节，从抽象角度帮助我们理解 CPU 与 ISA、软件之间的交融</strong>。</p><p>最后，为我们自己设计模拟器（simulator）、汇编器（assembler）、计算机处理器（CPU）打下基础。</p></blockquote><h2 id="9-1-Y86-64-Processor-State"><a href="#9-1-Y86-64-Processor-State" class="headerlink" title="9.1 Y86-64 Processor State"></a>9.1 Y86-64 Processor State</h2><p>我们定义 Y86-64 架构下，用于保存处理器状态（或者说程序执行状态）的由以下部件构成：</p><ul><li><p>15 只寄存器（Registers），每个大小 64 bits（除了不存在 <code>%r15</code>，其他与 x86-64 相同）；</p><blockquote><p>每个寄存器有独立且唯一的 4-bit ID：</p><p><img src="imgs2/y86-regs.png" height="125px"></p><p><code>0xF</code> 代表不使用寄存器（None），在 Y86-64 中有特殊用途。</p></blockquote></li><li><p>程序计数器（Program Counter，PC），64-bit size；</p></li><li><p>Conditional Codes，共 3 个，每个 1-bit（比 x86-64 少 CarryFlag 等 5 个 CC）；</p><ul><li><code>OF</code>: Overflow Flag，当且仅当上一次运算出现溢出时设置该位；</li><li><code>ZF</code>: Zero Flag，当且仅当上一次运算结果为 0 时设置该位；</li><li><code>SF</code>：Negative（Signed）Flag，当且仅当上一次运算结果为负数时设置该位；</li></ul></li><li><p>Status Code：记录程序运行状态的寄存器，存放一些有含义的数；</p><ul><li><code>AOK</code>: the program is executing normally (<strong>Continue</strong>).</li><li><code>HLT</code>: the processor has executed a halt instruction (<strong>Normal exit</strong>).</li><li><code>ADR</code>: the processor attempted to access <strong>an invalid memory address</strong> (<strong>Segmentation Fault</strong>).</li><li><code>INS</code>: <strong>an invalid instruction</strong> code has been encountered (<strong>IoT</strong>).</li></ul></li><li><p>Memory：程序内存。简单定义为使用 Byte 索引的存储数组。<strong>使用小端序（little-endian）存储</strong>；</p></li></ul><h2 id="9-2-Y86-64-Instructions"><a href="#9-2-Y86-64-Instructions" class="headerlink" title="9.2 Y86-64 Instructions"></a>9.2 Y86-64 Instructions</h2><p>Y86-64 下定义了 12 类处理器指令：</p><p><img src="imgs2/y86-inst.png"></p><p>Tips 1. Generic Form &amp; Encoded Representation</p><p>Tips 2. Instruction Code (first 4 bits) &amp; Function Code (second 4 bits)</p><h3 id="9-2-1-程序终止指令类-halt：0x00"><a href="#9-2-1-程序终止指令类-halt：0x00" class="headerlink" title="9.2.1 程序终止指令类 halt：0x00"></a>9.2.1 程序终止指令类 <code>halt</code>：<code>0x00</code></h3><h3 id="9-2-2-空指令类-nop：0x10"><a href="#9-2-2-空指令类-nop：0x10" class="headerlink" title="9.2.2 空指令类 nop：0x10"></a>9.2.2 空指令类 <code>nop</code>：<code>0x10</code></h3><h3 id="9-2-3-寄存器移动指令类"><a href="#9-2-3-寄存器移动指令类" class="headerlink" title="9.2.3 寄存器移动指令类"></a>9.2.3 寄存器移动指令类</h3><p><code>rrmovq rA, rB</code>：<code>0x20 0x&lt;rA&gt;&lt;rB&gt;</code>（看作无条件的 conditional move）</p><p><code>cmov&lt;XX&gt; rA, rB</code>：<code>0x2&lt;X&gt; 0x&lt;rA&gt;&lt;rB&gt;</code></p><h3 id="9-2-4-直接量-寄存器移动指令类"><a href="#9-2-4-直接量-寄存器移动指令类" class="headerlink" title="9.2.4 直接量-寄存器移动指令类"></a>9.2.4 直接量-寄存器移动指令类</h3><p><code>irmovq V, rB</code>：<code>0x30 0xF&lt;rB&gt; &lt;V&gt;</code>（2+8 bytes）</p><h3 id="9-2-5-寄存器-内存移动指令类"><a href="#9-2-5-寄存器-内存移动指令类" class="headerlink" title="9.2.5 寄存器-内存移动指令类"></a>9.2.5 寄存器-内存移动指令类</h3><p><code>rmmovq rA, D(rB)</code>：<code>0x40 0x&lt;rA&gt;&lt;rB&gt; &lt;D&gt;</code>（2+8 bytes）</p><h3 id="9-2-6-内存-寄存器移动指令类"><a href="#9-2-6-内存-寄存器移动指令类" class="headerlink" title="9.2.6 内存-寄存器移动指令类"></a>9.2.6 内存-寄存器移动指令类</h3><p><code>mrmovq D(rB), rA</code>：<code>0x50 0x&lt;rA&gt;&lt;rB&gt; &lt;D&gt;</code>（2+8 bytes）</p><p>⚠⚠ <u><strong>在 encoded representation 中，用于存储内存基地址的寄存器（在 9.2.5 和 9.2.6 中都用 <code>rB</code> 表示）ID 必须在目标寄存器 ID 之后！ </strong></u> ⚠⚠</p><h3 id="9-2-7-运算指令类"><a href="#9-2-7-运算指令类" class="headerlink" title="9.2.7 运算指令类"></a>9.2.7 运算指令类</h3><p><code>&lt;OP&gt;q rA, rB</code>：<code>0x6&lt;X&gt; 0x&lt;rA&gt;&lt;rB&gt;</code></p><h3 id="9-2-8-跳转指令类"><a href="#9-2-8-跳转指令类" class="headerlink" title="9.2.8 跳转指令类"></a>9.2.8 跳转指令类</h3><p><code>j&lt;XX&gt; Dst</code>：<code>0x7&lt;X&gt; &lt;Dst&gt;</code>（1+8 bytes）</p><p><u><strong>不支持直接跳转的 PC-relative 表示法</strong></u>，下同。</p><h3 id="9-2-9-调用指令类"><a href="#9-2-9-调用指令类" class="headerlink" title="9.2.9 调用指令类"></a>9.2.9 调用指令类</h3><p><code>call Dst</code>：<code>0x80 &lt;Dst&gt;</code> (1+8 bytes)</p><h3 id="9-2-10-返回指令类-ret：0x90"><a href="#9-2-10-返回指令类-ret：0x90" class="headerlink" title="9.2.10 返回指令类 ret：0x90"></a>9.2.10 返回指令类 <code>ret</code>：<code>0x90</code></h3><h3 id="9-2-11-寄存器进栈指令类"><a href="#9-2-11-寄存器进栈指令类" class="headerlink" title="9.2.11 寄存器进栈指令类"></a>9.2.11 寄存器进栈指令类</h3><p><code>pushq rA</code>：<code>0xA0 0x&lt;rA&gt;F</code></p><p>（在 9.3 中详细介绍）</p><h3 id="9-2-12-寄存器出栈指令类"><a href="#9-2-12-寄存器出栈指令类" class="headerlink" title="9.2.12 寄存器出栈指令类"></a>9.2.12 寄存器出栈指令类</h3><p><code>popq rA</code>：<code>0xB0 0x&lt;rA&gt;F</code></p><p>我们根据上面的定义总结出几点有价值的信息：</p><ul><li><p>Y86-64 指令集是比 x86-64 更精简的变长指令集，但每类指令内的长度固定。</p><blockquote><p>因此，机器在读指令的第一个 byte 后，就能根据指令种类确定当前指令的长度。</p></blockquote></li><li><p>条件移动指令存在于寄存器移动指令类，因为它们都是在寄存器间移动数据，<strong>它们共享前 4-bit Instruction Code</strong>；</p></li><li><p><strong>只有运算指令类可以隐式改变 Conditional Codes</strong>、运算指令也<strong>只能操作寄存器，直接量都不行</strong>；</p></li></ul><h2 id="9-3-Y86-64-Program-Stack"><a href="#9-3-Y86-64-Program-Stack" class="headerlink" title="9.3 Y86-64 Program Stack"></a>9.3 Y86-64 Program Stack</h2><p>Y86-64 架构下的程序栈与 x86-64 相近，遵循相似的 ABI：</p><ul><li>栈地址<strong>从高地址向低地址增长</strong>；</li><li>栈在 Y86-64 中也用于处理 Procedure Call 等工作；</li><li><code>%rsp</code> 寄存器仍然用作保存当前栈顶地址；</li></ul><p>此外，在 Y86-64 中的两种对栈操作的指令：</p><ul><li><code>pushq rA</code>（<code>0xA0 0x&lt;rA&gt;F</code>）:<ol><li>先减小 <code>%rsp</code>（8）；</li><li>再将 <code>rA</code> 中的数据存放到 <code>%rsp</code> 所指的位置；</li><li><strong>例外：如果 <code>pushq %rsp</code>，那么将先存放旧的 <code>%rsp</code>，再减小 <code>%rsp</code></strong>；</li></ol></li><li><code>popq rA</code>（<code>0xB0 0x&lt;rA&gt;F</code>）：<ol><li>先从 <code>%rsp</code> 指向的地址读取数据到 <code>rA</code>；</li><li>再增加 <code>%rsp</code>（8）；</li><li>例外：<strong>如果 <code>popq %rsp</code>，那么先增加 <code>%rsp</code>，再读取原来位置的数据</strong>；</li></ol></li></ul><p>⚠⚠ <u><strong>注意，无论是 <code>pushq</code> 还是 <code>popq</code>（读出还是写入）寄存器，寄存器都在 Encoded Representation 的 Function Code 的前 4-bit 内容</strong></u> ⚠⚠</p><blockquote><p>总之注意三个地方的指令的编写位置：</p><ol><li>在寄存器 - 内存间转移的 Load-Store 指令的 <code>rA</code> 和 <code>rB</code> 位置；</li><li>操作栈指令的 <code>rA</code> 与 <code>F</code> 的位置始终是寄存器位于 Function Code first 4-bit；</li><li>在直接量 - 寄存器转移的指令中，Function Code 却遵循 <code>F&lt;rA&gt;</code> 的规律；</li></ol></blockquote><h2 id="9-4-半章小结"><a href="#9-4-半章小结" class="headerlink" title="9.4 半章小结"></a>9.4 半章小结</h2><p><img src="imgs2/y86-isa1.png"></p><p><img src="imgs2/y86-isa2.png"></p><p><img src="imgs2/y86-inst-struct.png"></p><p><img src="imgs2/y86-reg-id.png"></p><p><img src="imgs2/y86-status-code.png"></p><h2 id="9-5-CPU-Design-CISC-vs-RISC"><a href="#9-5-CPU-Design-CISC-vs-RISC" class="headerlink" title="9.5 CPU Design: CISC vs RISC"></a>9.5 CPU Design: CISC vs RISC</h2><div class="table-container"><table><thead><tr><th>TYPE</th><th>CISC</th><th>Early RISC</th></tr></thead><tbody><tr><td>指令数</td><td>极多</td><td>&lt;100$^1$</td></tr><tr><td>指令耗时</td><td>差距较大</td><td>都很少$^2$</td></tr><tr><td>指令长度</td><td>可变长$^3$</td><td>定长</td></tr><tr><td>指令表示</td><td>一种运算有多种指令</td><td>仅表示运算最小完备集</td></tr><tr><td>load &amp; store</td><td>算术、逻辑运算允许内存-寄存器间</td><td>算术、逻辑运算仅允许寄存器间</td></tr><tr><td>机器级细节</td><td>hidden</td><td>exposed$^4$</td></tr><tr><td>条件判断</td><td>Conditional Codes</td><td>Test Instruction + Normal Registers</td></tr><tr><td>procedure call</td><td>少量使用 registers，集中在栈上传递$^5$</td><td>大多数交给 registers</td></tr></tbody></table></div><p>$^1$ : 很少的指令数会导致编译得到的汇编码增多；</p><p>$^2$ : RISC 指令数少、指令执行时长普遍很短，所以它们的执行时长接近，很适合 pipeline 的设计；</p><p>$^3$ : x86-64 一条指令长度在 1 ~ 15 bytes 间；</p><p>$^4$ : 将硬件层面的细节暴露给上面的软件层开发者有利有弊。由于 RISC 的精简指令简化了编译器的工作，编译器得以投入到更深层的优化上来。另一方面暴露硬件细节也会损失一定的兼容性；</p><p>$^5$ : 主要是 CISC 考虑了兼容性。因为早期的机器寄存器数量不多，使用内存栈传递参数是个明智的选择；</p><hr><p>根据上面的线索，我们能总结出 Early RISC 相对于 CISC 的优劣势：</p><ul><li>优势在于能够高效结合 Pipeline 技术、编译器开发更简单、更容易学习和通过它理解指令集架构等等；</li><li>劣势在于同一高级语言编译得到的更多汇编指令、暴露机器级细节破坏了 ISA 的封装性和程序兼容性等等；</li></ul><p>如今，新指令集没法明确地分出它属于哪一种，它们会借鉴两者的特点和原则；</p><p>例如这里的 Y86-64：</p><ul><li>既采用了 CISC 原则: Conditional Codes、变长指令；</li><li>又采用了 RISC 原则: Load/Store Arch、通过寄存器完成 Procedure Call；</li></ul><h2 id="9-5-CPU-Design-Logic-Design-amp-HCL"><a href="#9-5-CPU-Design-Logic-Design-amp-HCL" class="headerlink" title="9.5 CPU Design: Logic Design &amp; HCL"></a>9.5 CPU Design: Logic Design &amp; HCL</h2><p>复习：数字电子电路基础 - 组合时序逻辑电路。例如：</p><ul><li>多路相等比较器；</li><li>多路选择器（<code>Multiplexor</code>）；</li></ul><h3 id="Hardware-Control-Language-Syntax"><a href="#Hardware-Control-Language-Syntax" class="headerlink" title="Hardware Control Language Syntax"></a>Hardware Control Language Syntax</h3><ul><li><p>支持普通逻辑运算符；</p></li><li><p>选择器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Out = [</span><br><span class="line">    s: A;</span><br><span class="line">    1: B:// Default</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h3 id="Arithmetic-Logic-Unit-Design"><a href="#Arithmetic-Logic-Unit-Design" class="headerlink" title="Arithmetic Logic Unit Design"></a>Arithmetic Logic Unit Design</h3><ul><li>Input: X (8 bytes)、Y（8 bytes）；</li><li>Conditional Codes：<code>ZF / OF / SF</code>；</li><li>Output: Z（8 bytes）；</li></ul><h3 id="Register-Storage-Design"><a href="#Register-Storage-Design" class="headerlink" title="Register(Storage) Design"></a>Register(Storage) Design</h3><ul><li><p>Latch &amp; Flip-flop</p><blockquote><p>这里只需要知道：某种锁存器在 clock 上升沿写入输入的信号、仅输出写入的信号；</p></blockquote></li><li><p>Register File</p><p><img src="imgs2/register-design.png" height="200px"></p><p>特征：两个读端口（因为指令存在双寄存器操作），一个写端口，时钟引脚控制读写时机；<code>srcA/srcB</code> 表示读取的 register ID（4-bit），<code>valA/valB</code> 表示对应的 register 中的值；写端口 <code>dstW</code> 表示要写入的 register ID，而 <code>valW</code> 表示要写入的值；</p></li><li><p>Memory</p><p><img src="imgs2/memory-design.png" height="200px"></p><p>特征：读写端口各一个（因为不允许从内存到内存的操作），<code>error</code> 端口提示非法地址等错误，<code>read</code>、<code>write</code> 端口决定当前是读还是写（不会同时出现），时钟引脚控制读写周期；</p></li></ul><h2 id="9-6-CPU-Design-SEQ-General"><a href="#9-6-CPU-Design-SEQ-General" class="headerlink" title="9.6 CPU Design: SEQ General"></a>9.6 CPU Design: SEQ General</h2><p>本节我们在前几节电路基础、Y86-64 ISA 理论基础上构建 Y86-64 微架构，实现串行（sequential）处理器。</p><blockquote><p><code>icode</code> 不在 0 ～ B 间说明非法指令；</p><p><code>ifun</code> 也要检查，不在指令列表中的也需要报错；</p><p>但 <code>icode:ifunc</code> 以后的内容 “编码错误” 不是非法指令，因为 CPU 能够识别，应该属于软件层面的错误。</p></blockquote><h3 id="9-6-1-General-Principle"><a href="#9-6-1-General-Principle" class="headerlink" title="9.6.1 General Principle"></a>9.6.1 General Principle</h3><p>首先要知道，一个汇编指令需要很多步电路操作，所以我们设计时应该遵循如下原则：</p><ol><li>采用 Multi-stages Design，<strong>即分几步来完成一个汇编指令，思想类似函数包装</strong><span id="principle1">；</span></li><li>为了更好地利用硬件，不应该为每个指令设计一个电路，而是考虑<strong>如何让所有指令共用一套电路</strong><span id="principle2">。</span></li></ol><h3 id="9-6-2-Basic-Framework"><a href="#9-6-2-Basic-Framework" class="headerlink" title="9.6.2 Basic Framework"></a>9.6.2 Basic Framework</h3><blockquote><p>本节是上完课后总结的内容，叙述顺序进行了综合。</p></blockquote><p>根据前人的经验，Y86-64 串行处理器设计的 stage 应该分为这几个：</p><ul><li><p>Fetch：<strong>从指令内存中读取指令</strong>；</p><blockquote><p>该步允许使用的 <strong>微架构内容</strong> 如下：</p><p>值（<code>var</code>）：</p><ul><li><strong><code>PC</code></strong>：当前 PC 的值；</li><li><strong><code>icode:ifun</code></strong>：组合读入的 Instruction Code &amp; Function Code；</li><li><strong><code>rA:rB</code></strong>：组合读入的 <strong>寄存器 ID 值存放变量</strong>；</li><li><strong><code>valC</code></strong>：约定俗成认为是常数存放变量，存放 Displacement、Destination、Immediate；</li><li><strong><code>valP</code></strong>：约定俗成认为是<strong>下一个完整指令</strong>的地址，一般所有指令都要操作这个变量；</li></ul><p>表达式（<code>exp</code>）：</p><ul><li><strong>$var\leftarrow M_x[PC+\delta]$：表示将 $PC+\delta$ 地址的内存中 $x$ bytes 的指令数据取到值 $var$ 中</strong>；例如 $rA:rB\leftarrow M_1[PC+1]$；</li><li>$var\leftarrow PC+\delta$：表示将 $PC+\delta$ 的值（也就是地址）赋给值 $var$；</li></ul></blockquote></li><li><p>Decode：<strong>将寄存器值读到变量值中</strong>；</p><blockquote><p>该步允许使用的 微架构内容 如下：</p><p>值（<code>var</code>）：</p><ul><li><strong><code>rA</code>、<code>rB</code></strong>：上步取得的寄存器 ID；</li><li><strong><code>valA</code>、<code>valB</code></strong>：<strong>新的用于存放寄存器内值的 <code>var</code></strong>；</li><li><strong><code>%rsp</code></strong>：该步允许直接使用 <code>%rsp</code> 指代该寄存器内的值；</li></ul><p>表达式（<code>exp</code>）：</p><ul><li><strong><code>valA/varB &lt;- R[rA/rB/%rsp]</code>：从指定寄存器中取值到某个变量中</strong>；</li></ul></blockquote></li><li><p>Execute：<strong>进行计算地址 / 值的操作</strong>；</p><blockquote><p>该步允许使用的 微架构内容 如下：</p><p>值（<code>var</code>）：</p><ul><li><strong><code>valE</code></strong>：约定俗成存放 <strong>ALU 计算结果的 <code>var</code></strong>;</li><li><strong><code>CC</code></strong>：Condition Code；</li><li><strong><code>Cnd</code></strong>：<strong>存放本次 Condition Flag（条件是否成立信息）的 <code>var</code></strong>；</li><li><strong><code>ifun</code></strong>：此处用于判断 Function Code 的条件语义，例如确定 <code>CC</code>、确定运算符；</li></ul><p>表达式（<code>exp</code>）：</p><ul><li><strong><code>valE &lt;- valB/0 + valA/valC/8/-8</code></strong>：将运算结果写到 <code>valE</code> 中，<strong>至于为什么左边是 <code>valB/0</code>，右边是 <code>valA/valC/8/-8</code>，主要是考虑所有指令后，为了最大程度上复用电路的主意；</strong></li><li><strong><code>valE &lt;- valB ifun valA</code></strong>：表示按 <code>ifun</code> 选择，将 <code>valB</code>、<code>valA</code> 运算后赋给 <code>valE</code>（显然这个表达式是专门为了 <code>opq</code> 指令的）；</li><li><strong><code>Set CC</code></strong>：根据运算结果设置 Condition Codes，在 Y86-64 中，只有 <code>opq</code> 可以使用；</li><li><strong><code>Cnd &lt;- Cond(CC, ifun)</code></strong>：表示按 <code>ifun</code> 预期条件、<code>CC</code> 当前条件，将是否应该进行的 Condition Flag 赋给 <code>Cnd</code>；</li></ul></blockquote></li><li><p>Memory：<strong>向内存中读 / 写数据</strong>；</p><blockquote><p>该步允许使用的 微架构内容 如下：</p><p>值（<code>var</code>）：</p><ul><li><strong><code>valM</code></strong>：约定俗成用于<strong>存放从内存中取出的值</strong>；</li><li><strong><code>valA / valE / valP</code></strong>：根据代码逻辑可能会用到的 <code>var</code>（也是考虑所有指令后，为了最大程度上复用电路的主意）；</li></ul><p>表达式（<code>exp</code>）：</p><ul><li><strong>$varM \leftarrow M_x[var]$</strong>：表示以 $var$ 的值为地址，从 Memory 中取 $x$ bytes 数据放入 <code>varM</code> 中；</li><li><strong>$M_x[var_2]\leftarrow var_1$</strong>：表示将 $var_1$ 中的数据放入到 以 $var_2$ 为地址、长度为 $x$ bytes 的内存中；</li></ul></blockquote></li><li><p>Write Back：<strong>向寄存器写入数据</strong>；</p><blockquote><p> 该步允许使用的 微架构内容 如下：</p><p> 值（<code>var</code>）：</p><ul><li><strong><code>varE / varM</code></strong>：根据代码逻辑可能会用到的 <code>var</code>（也是考虑所有指令后，为了最大程度上复用电路的主意）；</li><li><strong><code>rA / rB</code></strong>：本步想要写入寄存器，必须要用到寄存器 ID 值；</li><li><strong><code>Cnd</code></strong>：可能会根据 Condition Flag 进行不同动作（例如 <code>cmovXX</code> 类指令）；</li><li><p><strong><code>%rsp</code></strong>：本步允许直接使用此符号指代该寄存器；</p><p>表达式（<code>exp</code>）：</p></li><li><p><strong><code>R[rA/rB/%rsp] &lt;- valE/valM</code></strong>：将指定位置的值赋给指定的寄存器；</p></li><li><p><strong><code>Cnd ? exp : -</code></strong>：根据 Condition Flag 决定是否执行 本步允许的表达式 <code>exp</code>；</p></li></ul></blockquote></li><li><p>PC Update：<strong>更新 PC</strong>；</p><blockquote><p>该步允许使用的 微架构内容 如下：</p><p>值（<code>var</code>）：</p><ul><li><strong><code>valP / valC / valM</code></strong>：根据代码逻辑可能会用到的 <code>var</code>（也是考虑所有指令后，为了最大程度上复用电路的主意）；</li><li><strong><code>PC</code></strong>：本步的目的就是改变它；</li><li><strong><code>Cnd</code></strong>：可能会用 Condition Flag 决定赋给 <code>PC</code> 的内容（例如 <code>jXX</code> 类指令）；</li></ul><p>表达式（<code>exp</code>）：</p><ul><li><strong><code>PC &lt;- var</code></strong>：将各种本步允许的 <code>var</code> 传给 <code>PC</code>；</li><li><strong><code>PC &lt;- Cnd ? valC : valP</code></strong>：根据 Condition Flag 决定将何种 <code>var</code> 赋给 <code>PC</code>；</li></ul></blockquote></li></ul><h3 id="9-6-3-Describe-Assembly-with-Framework"><a href="#9-6-3-Describe-Assembly-with-Framework" class="headerlink" title="9.6.3 Describe Assembly with Framework"></a>9.6.3 Describe Assembly with Framework</h3><p>有了上面的知识，我们可以把各个指令对应的微架构过程描述出来了。</p><p><code>rrmovq rA, rB</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- 0 + valA    // Save line in Write Back (We shouldn&#x27;t add &quot;valB &lt;- R[rA]&quot;)</span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[rB] &lt;- valE    // No valA in Write Back</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>cmovXX rA, rB</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- 0 + valA    // Save line in Write Back (We can&#x27;t add &quot;valB &lt;- R[rA]&quot;)</span><br><span class="line">Cnd &lt;- Cond(CC, ifun)</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">Cnd ? R[rB] &lt;- valE : -    // No valA in Write Back</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>irmovq V, rB</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valC &lt;- M8[PC + 2]</span><br><span class="line">valP &lt;- PC + 10</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">NONE</span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- 0 + valC    // Save line in Write Back</span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[rB] &lt;- valE    // No valC in Write Back</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>rmmovq rA, D(rB)</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valC &lt;- M8[PC + 2]</span><br><span class="line">valP &lt;- PC + 10</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line">valB &lt;- R[rB]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + valC</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">M8[valE] &lt;- valA</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>mrmovq D(rB), rA</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valC &lt;- M8[PC + 2]</span><br><span class="line">valP &lt;- PC + 10</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valB &lt;- R[rB]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + valC</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">valM &lt;- M8[valE]</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[rA] &lt;- valM</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>opq rA, rB</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line">valB &lt;- R[rB]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB ifun valA</span><br><span class="line">Set CC</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[rB] &lt;- valE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>jXX Dest</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">valC &lt;- M8[PC + 1]</span><br><span class="line">valP &lt;- PC + 9</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">Cnd &lt;- Cond(CC, ifun)</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"># Write Back</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">Cnd ? PC &lt;- valC : valP</span><br></pre></td></tr></table></figure><p><code>call Dest</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">valC &lt;- M8[PC + 1]</span><br><span class="line">valP &lt;- PC + 9</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valB &lt;- R[%rsp]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + -8</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">M8[valE] &lt;- valP</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[%rsp] &lt;- valE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valC</span><br></pre></td></tr></table></figure><p><code>ret</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[%rsp]  // Save line in Memory</span><br><span class="line">valB &lt;- R[%rsp]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + 8</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">valM &lt;- M8[valA]    // No valB in Memory</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[%rsp] &lt;- valE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valM</span><br></pre></td></tr></table></figure><p><code>pushq rA</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line">valB &lt;- R[%rsp]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + -8</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">M8[valE] &lt;- valA</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[%rsp] &lt;- valE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>popq rA</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[%rsp]    // save line in Memory</span><br><span class="line">valB &lt;- R[%rsp]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + 8</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">valM &lt;- M8[valA]    // No valB in Memory</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[%rsp] &lt;- valE</span><br><span class="line">R[rA] &lt;- valM</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><hr><p>其中有几个要点需要着重掌握：</p><ul><li><p>Memory 中化简了 <code>valB</code>，Write Back 中化简了 <code>valA</code> 和 <code>valC</code>；</p></li><li><p><code>popq</code> 的 Write Back Stage 要保证 <code>R[rA] &lt;- valM</code> 在 <code>R[%rsp] &lt;- valE</code> 之后执行并覆盖；</p></li><li><p>电路的结果是充满管线之间的，<strong>但是只有时钟上升延才会被写入</strong>；</p><blockquote><p>这能解释为什么在 <code>opq rA, rB</code> 的 Execute Stage 中，前一步的运算不会影响到 <code>Set CC</code>：<strong>一个汇编指令执行在一个时钟周期内，一定不会相互影响</strong>。</p></blockquote></li></ul><p>再总结一下以上各个 Stage 实际用到的值情况：</p><p><img src="imgs2/used-var.png" height="350px"></p><h3 id="9-6-4-Advantages-amp-Disadvantages"><a href="#9-6-4-Advantages-amp-Disadvantages" class="headerlink" title="9.6.4 Advantages &amp; Disadvantages"></a>9.6.4 Advantages &amp; Disadvantages</h3><ul><li>简单，容易实现；</li><li>指令无法设计复杂，否则耽误其他指令时间（快指令 等 慢指令）；</li><li>电路 propagate 需要时间，导致时钟周期无法很快，进而注定了 SEQ 处理器的速度不会很快（前 stage 等 后 stage）；</li></ul><h2 id="9-7-Principles-of-Pipeline"><a href="#9-7-Principles-of-Pipeline" class="headerlink" title="9.7 Principles of Pipeline"></a>9.7 Principles of Pipeline</h2><p>Some Ideas:</p><ul><li>Multi-Stage Design：和串行处理器的思路一样，分多个独立的 Stage 完成一个 Process；</li><li>Move objects through stages <strong>in sequence</strong>；</li><li>At any given times, <strong>multiple objects being processed</strong>；</li></ul><p>我们定义：</p><ul><li><p>从头至尾执行一条指令所需的时间（不讨论 capacity），称为这条指令的 <strong>延迟（latency）</strong>；</p></li><li><p>单位时间内完成指令的数量（讨论了 capacity），称这个流水线的 <strong>吞吐量（throughput）</strong>，通常的计算方法是 1 / 时钟周期长度 / 承载量（这里 “时钟周期长度” 会受到流水线分级方法的影响）；</p><blockquote><p>吞吐量常用单位是 <code>GIPS</code>（每秒千兆条），可以用每 1 ns 内执行的指令数量进行计算。</p></blockquote></li></ul><h3 id="9-7-1-Time-Analysis-SEQ"><a href="#9-7-1-Time-Analysis-SEQ" class="headerlink" title="9.7.1 Time Analysis: SEQ"></a>9.7.1 Time Analysis: SEQ</h3><p>从之前的串行处理器开始讨论，一条指令执行的耗时情况如下：</p><p><img src="imgs2/comb-version.png"></p><ul><li>组合逻辑电路在输入后，等到电路稳定需要 300 ps（记作 “<strong>Computation Delay</strong>”）；</li><li>时钟上升沿到达后，需要 20 ps 才能确保写入 registers（记作 “<strong>Save Delay</strong>”）；</li></ul><p><strong>因此这种情况下，每个时钟周期至少 320 ps</strong>；</p><h3 id="9-7-2-Time-Analysis-N-Way-Pipelined"><a href="#9-7-2-Time-Analysis-N-Way-Pipelined" class="headerlink" title="9.7.2 Time Analysis: N-Way-Pipelined"></a>9.7.2 Time Analysis: N-Way-Pipelined</h3><p>我们考虑如下流水线的思想，将组合逻辑电路拆成多个 stage，以便使用流水线：</p><p><img src="imgs2/pipeline-idea.png" height="300px"></p><p>如果将组合逻辑电路按照流水线的 ideas，变为 <strong>3-Way Pipelined</strong>：</p><p><img src="imgs2/3-way-pipeline-version.png"></p><ul><li><p>将组合逻辑电路拆分为 3 个独立的 stage（每个 stage 平均 latency 100 ps）；</p></li><li><p>虽然 latency <strong>略微增长</strong>（由于寄存器状态切换的时间开销）：360 ps，但 Throughput 提升了；</p></li><li><p><strong>因为根据流水线思想，在一个 operation 穿过一个 stage 后，其他部分就空闲下来，并且状态已经进入中间状态 registers，因此下一条指令可以立即进入</strong>；</p><p><img src="imgs2/3-way-pipeline-state.png" height="400px"></p></li></ul><h4 id="Limitation-1-Nonuniform-Delays"><a href="#Limitation-1-Nonuniform-Delays" class="headerlink" title="Limitation 1: Nonuniform Delays"></a>Limitation 1: Nonuniform Delays</h4><p><strong>但是，我们没有考虑一个重要问题：逻辑电路划分为 stage 后，每个 stage 的 Delay 时长不一致（Nonuniform Delays）。</strong></p><p>这个时候，有些耗时短的 stage 就要等待耗时长的 stage，例如：</p><p><img src="imgs2/ununiform-delay.png"></p><p>这样我们考虑几个问题：</p><p>根据组合逻辑电路的设计，有些部分是无法继续切分的，这就告诉我们无法无限向下切分 stage。假设有一种设计如下，各个部分不能继续切分：</p><p><img src="imgs2/pipeline-example.png"></p><p>那么，考虑不同 stage 数量下的 CPU 情况：</p><ul><li>当 stage 数量为 2 时，最好的划分方法是 <code>A B C | D E F</code>，这个时候总 <code>latency = 190 * 2 ps = 380 ps</code>，<code>throughput = 1 / 190 * 1000 GIPS = 5.26 GIPS</code>；</li><li>当 stage 数量为 3 时，最好的划分方法是 <code>A B | C D | E F</code>，这个时候总 <code>latency = 130 * 3 ps = 390 ps</code>，<code>throughput = 1 / 130 * 1000 GIPS = 7.69 GIPS</code>；</li><li>当 stage 数量为 4 时，最好的划分方法是 <code>A | B C | D | E F</code>，这个时候总 <code>latency = 110 * 4 ps = 440 ps</code>，<code>throughput = 1 / 110 * 1000 GIPS = 9.09 GIPS</code>；</li><li>当 stage 数量为 5 时，最好的划分方法是 <code>A | B | C | D | E F</code>，这个时候总 <code>latency = 100 * 5 ps = 500 ps</code>，<code>throughput = 1 / 100 * 1000 GIPS = 10 GIPS</code>；</li><li>当 stage 数量大于 5 时，<code>throughput</code> 不可能比 5 个 stage 更好了，因为最大不可分割的单元已经达到 80 ps 了，意味着再增加 stage，不仅不会提升 throughput，还会延长 latency；</li></ul><p>于是我们能得到结论：</p><ul><li>最大的 throughput 不一定是在最大的 Stage 切分数取得，<strong>而是取决于 <u>最大的、不可分割的部分耗时 + 寄存器状态写入的 latency</u></strong>；</li></ul><h4 id="Limitation-2-Register-Overhead"><a href="#Limitation-2-Register-Overhead" class="headerlink" title="Limitation 2: Register Overhead"></a>Limitation 2: Register Overhead</h4><p>另外，当我们将过程切分成更多的 stage 后，loading registers 所占的时长比例愈发的大，这是我们所不希望的。</p><h4 id="Limitation-3-Data-Dependency-amp-Data-Hazard"><a href="#Limitation-3-Data-Dependency-amp-Data-Hazard" class="headerlink" title="Limitation 3: Data Dependency &amp; Data Hazard"></a>Limitation 3: Data Dependency &amp; Data Hazard</h4><p>既然使用流水线，就不可避免要考虑前后 stage 的依赖问题，例如 <strong>前一条指令的结果是后一条指令的运算数（数据依赖）、前一条指令决定后一条指令的执行位置（控制依赖）</strong>。</p><p>对于数据依赖而言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">irmovq $50, %rax</span><br><span class="line">addq %rax, %rbx</span><br><span class="line">mrmovq 100(%rbx), %rdx</span><br></pre></td></tr></table></figure><p>因此，这三条指令在流水线上的时间顺序必须是这样的，才能保证运算结果的正确性：</p><p><img src="imgs2/data-dep.png"></p><p>但是，这样又没法使用流水线，因此可以采用 <strong>中间插入其他指令</strong> 的方式缓解这种问题，具体会在实现的时候进一步讨论：</p><p><img src="imgs2/data-dep-sol.png"></p><h4 id="Limitation-4-Control-Dependency"><a href="#Limitation-4-Control-Dependency" class="headerlink" title="Limitation 4: Control Dependency"></a>Limitation 4: Control Dependency</h4><p>同样，对于控制依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">    subq %rdx, %rbx</span><br><span class="line">    jne targ</span><br><span class="line">    irmovq $10, %rdx</span><br><span class="line">    jmp loop</span><br><span class="line">targ:</span><br><span class="line">    halt</span><br></pre></td></tr></table></figure><p>于是，我们分析了实现流水线的优势、可能遇到的问题。接下来我们会在实现的介绍中，依次解决上面的几个顾虑。</p><h2 id="9-8-Pipeline-Implementation"><a href="#9-8-Pipeline-Implementation" class="headerlink" title="9.8 Pipeline Implementation"></a>9.8 Pipeline Implementation</h2><p>首先同样，根据前人的经验，我们作出如下强调：</p><ul><li><p>SEQ+ Implementations：<strong>将 <code>PC Update</code> Stage 的工作移动到 Fetch Stage（根据上一条指令的寄存器结果得到当前指令的 PC）</strong>，而 PC 不再存在一个真实寄存器中，因为只需要根据上一条指令的寄存器状态就能计算 next PC（变成了组合逻辑电路）。<strong>至此形成经典 5 级流水线的逻辑电路基础</strong>；</p><blockquote><p>New Fetch:</p><ul><li>Select current PC;</li><li>Read instruction;</li><li>Compute incremented PC.</li></ul></blockquote></li><li><p>Naïve PIPE Implementation：先忽略 Control / Data Hazard，只用 <code>nop</code> 解决；</p></li><li><p>Pipeline Feedback</p></li></ul><h3 id="9-8-1-Hardware"><a href="#9-8-1-Hardware" class="headerlink" title="9.8.1 Hardware"></a>9.8.1 Hardware</h3><p><img src="imgs2/5-stage-pipeline-impl.png" height="800px"></p><p>有几点值得注意；</p><ul><li><p>和 SEQ Implementation 不一样，每个 stage 间多了要保存的<strong>状态寄存器</strong>；</p></li><li><p>小写字母前缀表示当前 stage 阶段由控制逻辑块生成的数据，大写字母前缀表示流水线寄存器的一个字段（从上个 stage 接受的数据）；</p><p>例如：<code>D_stat</code> 表示 Decode Stage 接受上个阶段的状态输入值，<code>m_valA</code> 表示 Memory Stage 计算出的 <code>valA</code> 值；</p></li><li><p>Fetch 部分增加了 <strong>用于猜测下一条指令的寄存器 <code>predPC</code></strong>；</p></li><li><p>Decode 部分增加了 <code>Select A</code> 部件，原因是：</p><ul><li>现象：只有 call 指令会在 memory 阶段用到 <code>valP</code>，只有 jump 指令会在 execute 阶段用到 <code>valP</code>（准确说是“携带”）。这两种指令都不需要用到寄存器 A；<strong>还有一点是我们已经将 PC Update 转移到 Fetch 中，在 Fetch 阶段本身就有 Predict PC 部件。这样 <code>valP</code> 在其他场合也不需要传播到 Fetch 阶段之外的场合去</strong>；</li><li>作用：减少控制信号和寄存器的数目。即可以将这两个控制信号合并。</li></ul></li></ul><p>那么这个 implementation 是如何解决 Data / Control Hazard 的？</p><h3 id="9-8-2-Resolve-Data-Hazard-Data-Forwarding-amp-Stalling"><a href="#9-8-2-Resolve-Data-Hazard-Data-Forwarding-amp-Stalling" class="headerlink" title="9.8.2 Resolve Data Hazard: Data Forwarding &amp; Stalling"></a>9.8.2 Resolve Data Hazard: Data Forwarding &amp; Stalling</h3><p>首先对于 Data Hazard，主要的问题是：<strong>Read-after-write</strong>（write 在 read 后面则不会出现问题）。</p><p>可能引发这个问题的指令有：<code>opq</code>、<code>ir/rr/mr/rm movq</code>、<code>popq</code>。</p><p>例如对这样几条汇编而言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># demo-h0.ys</span><br><span class="line">0x000:irmovq $10,%rdx</span><br><span class="line">0x00a:irmovq $3,%rax</span><br><span class="line">0x014:addq %rdx,%rax</span><br><span class="line">0x016:halt</span><br></pre></td></tr></table></figure><p>直接考虑 5 个 stage 流水线形式进入会出现问题，如下左图：</p><p><img src="imgs2/data-hazard-example.png" width="350px"><img src="imgs2/data-hazard-nop.png" width="350px"></p><p>因为在第 3 条指令在 Decode 阶段会读取紧邻的前两条指令计算结果，而前两条指令此时正处于 Memory 和 Execute 阶段，都没有到 Write Back 阶段，这时存在 read-after-write dependency，读取数据一定是错误的。</p><p><strong>第一种尝试方法是之前提到的 插入 <code>nop</code></strong>（Naïve Design）；</p><p>一般如果 Fetch 读入一个改变下一个指令所用寄存器的指令，那么等到该指令更改寄存器位于 Write Back Stage，前后相差 3 个 stage，因此<strong>在有 Data Hazard 的两指令间插入 3 个 <code>nop</code></strong>就能解决问题，如上右图。</p><blockquote><p>考虑一下，如果只插入 2 个 <code>nop</code>，那么第三条指令只能读到 <code>%rdx</code> 中正确的值，因为第二条指令还在 Write Back 阶段没有结束；</p><p>如果只插入一个 <code>nop</code>，那么两个寄存器正确的值都读不到！</p></blockquote><p>虽然这种解决方法非常简单，可以由编译器、硬件处理器，甚至开发者来解决。但是弊端是 <strong>这会严重拖慢流水线速度</strong>。因此我们得想办法尽可能让底层硬件解决这个问题。</p><hr><p><strong>第二种尝试方法是 stalling（拖延住）</strong>；</p><p>这种方法是在 CPU 执行指令时实时进行的，具体以例子说明。假设有个程序在 Y86-64 编译器上编译后长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># demo-h2.ys</span><br><span class="line">0x000:irmovq $10,%rdx</span><br><span class="line">0x00a:irmovq $3,%rax</span><br><span class="line">0x014:nop    # 先考虑简单的情况，假设这中间有两条完全无关、不会出现 data dependency 的指令，</span><br><span class="line">0x015:nop    # 我们假装它们就是 nop 来讨论</span><br><span class="line">    # Bubble</span><br><span class="line">0x016:addq %rdx,%rax</span><br><span class="line">0x018:halt</span><br></pre></td></tr></table></figure><p>我们根据上一种方法的分析可知，现在 <code>0x016</code> 位置上的指令仍然无法读到正确的 <code>%rax</code>，还需要再等一个 clock 才行。这个时候，我们在 <code>0x015</code> 和 <code>0x016</code> 之间插入一个 “Bubble”。</p><p><strong>这个 Bubble 不会在汇编代码中出现，而是 CPU 进行了以下操作</strong>：</p><ol><li>向 <code>0x016</code> 指令（依赖未取得的指令）所在的 Stage（Decode）输入状态寄存器发送 Stalling 信号，<strong>暂停一个 clock 不允许被修改</strong>；</li><li>在向 <code>0x016</code> 指令之前的所有 stage（这里只有 Fetch）的输入状态寄存器发送 Stalling 信号（<strong>防止后来的指令 “撞到” stalling 寄存器上消失</strong>）；</li><li>由于 <code>0x016</code> 指令只是状态寄存器定住了，不正确的信号仍然会向前传递，因此 CPU 还要 <strong>将前进到 Execute Stage、但没来得及修改 CC 和 后继状态寄存器的错误指令的 <code>icode</code> 修改为 <code>1</code>，表示 <code>nop</code>，使它彻底失去作用</strong>；</li></ol><p>这种 “将其他指令的 <code>icode</code> 改为 <code>1</code> 使其成为 <code>nop</code>” 的动作所产生的不在汇编码上的 <code>nop</code> 就叫 bubble。</p><p>这样从 <code>0x015</code> 后的所有指令都会暂停一个 clock，等待 <code>0x00a</code> 指令写入寄存器。</p><p>这种方法只是将插入 <code>nop</code> 的工作移交给了硬件，没有解决速度上的问题。</p><hr><p><strong>第三种尝试方法是 data forwarding</strong>（利用 feedback paths 将后面的结果给到前面的 decode stage）；</p><p>就是说，我们让最终结果未出现前，让正确 / 可能正确的值先通过传输线传递给读的 decode 阶段；这个方法能实现，主要是因为 <strong>能读到信号要早于写入信号</strong>（前者在一个 Clock 开始的一段时间后就可读到，而后者则需要这个 Clock 结束）。</p><p>例如：</p><ul><li><code>irmovq</code> 在 Fetch 阶段就一定可以得到正确的值，后面的任意 stage 都能找到值；</li><li><code>opq</code> 在 Execute 阶段后期一定可以得到正确的值，后面的任意 stage 都能找到值；</li><li><code>ret</code> 在 Memory 阶段结束一定可以得到正确的值；</li></ul><blockquote><p>但是 Feedback Paths 不会出现在 Fetch 阶段，因为太早了，后面的指令没进入 Decode 阶段前很难使用这个结果。</p></blockquote><p>一般用 feedback paths 去解决 data hazard，主要作用在 Decode 阶段，因为这个阶段才可能会用到没有写入的寄存器值。</p><p>再考虑简单的情况，假设 <code>0x00a</code> 和 <code>0x016</code> 之间有两条无关的指令，就假设为 <code>nop</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># demo-h2.ys</span><br><span class="line">0x000:irmovq $10,%rdx</span><br><span class="line">0x00a:irmovq $3,%rax</span><br><span class="line">0x014:nop</span><br><span class="line">0x015:nop</span><br><span class="line">0x016:addq %rdx,%rax</span><br><span class="line">0x018:halt</span><br></pre></td></tr></table></figure><p>这个时候 <code>%rdx</code> 能正确读到，如果我们把 Write Back 阶段的 <code>W_valE</code>（<code>0x00a</code> 的 Write Back Stage 状态寄存器值）通过 feedback path 将信息告诉 Decode Stage 呢？比如在这种情况下，我们把 <code>W_valE</code> 接给 <code>valB</code>，就能够读到正确的值了。</p><p><img src="imgs2/data-hazard-2nop-forward.png" width="280px"><img src="imgs2/data-hazard-1nop-forward.png" width="240px"><img src="imgs2/data-hazard-forward.png" width="280px"></p><p>那我们乘胜追击，假设中间只空 1 个 <code>nop</code> 呢？这个时候产生 <code>%rax</code> 的值还在 Memory 阶段！没事，因为 <code>irmovq</code> 的结果在 Fetch 阶段就知道了嘛，我们把 <code>M_valE</code> 的值给它；</p><p>然后另一个寄存器也无法获取正确的值，就类似上个情况的 “从 Write Back 阶段 <code>W_valE</code> 到 <code>valA</code>“ 接线就行。如上中图所示。</p><p>太好了，更极限一点的话，<code>irmovq</code> 写和 <code>opq</code> 读指令不隔 <code>nop</code>，是否也能用 data forward 解决？</p><p>同样是可以的：在上一条指令处于 Execute Stage 时，我们直接将运算结果 <code>e_valE</code> 给 <code>valB</code>。来的及吗？之前都是给状态寄存器（在 Clock 开始前就等待在外），这次给结果值（Clock 开始后一段时间才能稳定），<strong>是来得及的。因为 <u>Deocde 阶段可以等，直到这个 Clock 快结束才得到都是没问题的</u>。</strong>如上右图。</p><blockquote><p>更进一步考虑，假如上面的指令不是 <code>addq %rdx,%rax</code>，而是 <code>addq %rax, %rbx</code>（前两条指令也对应变），那么寄存器情况是不是一样能这么做？</p></blockquote><p>于是我们发现，只要多加几个 feedback paths，就能解决以 <code>irmovq</code> / <code>opq</code> 为首的 RAW-Dependency 问题，不需要插入 Bubble 或者 <code>nop</code>。我们将这个成功经验拓展到其他指令上，再总结一下：</p><p>首先我们可以从这些位置提前得到寄存器的结果（Forwarding Sources）：</p><ul><li><p>Execute Stage 的计算结果 <code>valE</code>（<code>e_valE</code>）；</p><blockquote><p><strong>不能比这个早，因为上面我们讨论 <code>irmovq</code> 只是一种情况，有些指令例如 <code>opq</code> 必须等到 Execute 结束才能拿到正确的值</strong>。</p></blockquote></li><li><p>Memory Stage 的状态寄存器 <code>valE</code>、<code>valM</code>（<code>M_valE</code>、<code>M_valM</code>）；</p></li><li><p>Write Back Stage 的状态寄存器 <code>valE</code>、<code>valM</code>（<code>W_valE</code>、<code>W_valM</code>）；</p></li></ul><p>其次，我们需要判断是否应该接受 forwarding data，即分情况选择 <code>valA</code>、<code>valB</code> 的来源。<strong>哪些情况应该和平常一样直接使用寄存器的值，哪些时候又应该选择 Forwarding Sources</strong>。</p><p>为了分情况选择，我们向电路里加入了两个逻辑电路用于选择不同情况下 <code>valA</code> 和 <code>valB</code> 的取值，纠正 data hazard 问题：</p><p><img src="imgs2/data-forward-impl.png" height="800px"></p><p>这种 data forwarding 方法看似解决了问题，并且无需使用 bubble 和 <code>nop</code>，但是它还是没有考虑完全。</p><p>我们上面讨论的情况 “以 <code>irmovq</code> 写、<code>opq</code> 读为首的 RAW-Dependency” 有个前提是，<u><strong>直接相邻的两个存在 data dependency 的指令，所使用的有依赖的数据产生阶段不能晚于 Execute Stage</strong></u>，因为直接相邻说明只间隔了一个 stage。</p><p>那么可能构成 data dependency 的指令中（<code>opq</code>、<code>ir/rr/mr/rm movq</code>、<code>popq</code>），有一类是没法在 Execute Stage结束前拿到结果：<strong>从 memory 中取值的 <code>mrmovq</code>、<code>popq</code></strong>。它们必定要等到 Memory Stage 结束才能取到值！</p><p>我们将 “在取 Memory 后，立即使用此值” 的行为称作 “Load / Use Hazard”，这种情况使用 Data Forward 是无法纠正寄存器的读错误。<strong>我们必须要借助前面介绍的 Bubble 让这种连续 Load / Use 分开一个 Cycle</strong>。</p><hr><p>于是，Y86-64 针对 Data Hazard 的解决方法总结如下：</p><ul><li>对于一般的连续两条指令（分开的就更好办）数据依赖，我们可以直接使用 Data Forwarding 设计的 Feedback Paths，选择正确的值就能纠正；</li><li>对于 Load / Use Hazard（连续的从内存读、使用），我们需要在使用 Data Forwarding 的同时，<strong>向 Execute 阶段插入一个 Bubble（同时要将 Decode 和 Fetch stall 住一个 Clock 防止指令损失），以将 Load 和 Use 指令分开一个 Cycle</strong>；这两种方式结合的方法就叫 load interlock（加载互锁）。</li></ul><h3 id="9-8-3-Resolve-Control-Hazard-Part-Ⅰ-Predicting-the-PC"><a href="#9-8-3-Resolve-Control-Hazard-Part-Ⅰ-Predicting-the-PC" class="headerlink" title="9.8.3 Resolve Control Hazard Part Ⅰ: Predicting the PC"></a>9.8.3 Resolve Control Hazard Part Ⅰ: Predicting the PC</h3><p>其次，针对 Control Hazard 的解决方案也是 <strong>Feedback Paths</strong>。根据指令的特点，有几种数据能决定 next PC：</p><ul><li>Next Instruction for most cases（<code>valP</code>，一定可以预测正确）；</li><li>Call destination（<code>valC</code>，一定可以预测正确）；</li><li>Branch information，由有条件的 <code>jmp</code> 指令触发，<strong>可能预测正确</strong>；</li><li>Return point，由 <code>ret</code> 指令触发，地址位于内存，<strong>几乎一定不可预测</strong>；</li></ul><p><strong>所以可以根据这些寄存器中的值进行预先推测，猜测可能下一步可能的指令地址</strong>。</p><blockquote><p>由于上一条指令在 Fetch 之后就要读下一条指令了，所以猜测的可靠性不能保证。</p><p>如果猜测错误，就需要<strong>恢复到猜测前的状态</strong>（如何实现？后面提及）。</p></blockquote><p>对应这几种数据的特点和成功率，我们相应的有<strong>猜测策略</strong>：</p><ul><li><p>对于前两种情况而言，我们直接选择 Fetch 阶段得到的或者计算出的 <code>valC / valP</code>，一定不会出错；</p></li><li><p>对于 Conditional Jumps，<strong>我们总是猜测可能是寄存器 <code>valC</code> 中的地址（即赌本次跳转条件一定成立）</strong>。</p><blockquote><p>为什么？原因有 2 条：</p><ol><li>因为大量数据统计在 60% 的情况下的条件是成立的（Unconditional 和 Conditional Jump 只是 <code>ifun</code> 的区别；还有 <code>while</code>、<code>for</code> 循环翻译成的 <code>jmp</code> 跳转的概率更大）；</li><li>携带 <code>valP</code> 和 <code>valC</code> 的电路设计的复杂程度不一样。人们发现选择 <code>valC</code> 时电路更简单；</li></ol><p><strong>也可以通过一些数据分析的手段来精确这个过程</strong>；</p></blockquote><p>另外，我们还需要知道这次猜测是否正确，如果猜测错误还需要进行恢复。我们可以将 <code>M_Cnd</code>（Memory stage 计算得出的 Cnd flag）、<code>M_valA</code>（Memory 阶段<strong>存储的 <code>valP</code></strong>，因为有 Select A 所以放在这里）两个值通过 Feedback Paths 回接给 Select PC，让它判断是否该相信 <code>predPC</code>；</p></li><li><p>对于 Return 而言，几乎一定无法预测，那么就彻底不预测，也就是不使用 Predict PC，和其他情况一样默认 <code>valP</code>；</p><p>最终的纠错阶段就是真正的返回地址被取出的时候（Write Back state registers）；</p></li></ul><p>现在，我们根据猜测策略，将各种情况下 Next PC 的猜测值全部汇总到 Select PC 原件，让这个逻辑电路根据情况判断正确的下一条指令是什么，如下图。</p><p><img src="imgs2/pred-PC.png" height="300px"></p><h3 id="9-8-4-Resolve-Control-Hazard-Part-Ⅱ-Fix-Wrong-Predictions"><a href="#9-8-4-Resolve-Control-Hazard-Part-Ⅱ-Fix-Wrong-Predictions" class="headerlink" title="9.8.4 Resolve Control Hazard Part Ⅱ: Fix Wrong Predictions"></a>9.8.4 Resolve Control Hazard Part Ⅱ: Fix Wrong Predictions</h3><p>但是有个问题，我们按照上一节的猜测策略暂时得到了<u>可能的</u>下一条指令的执行位置，我们又如何在得到结果后发现、修复错误的猜测结果呢？</p><p><code>ret</code> 指令的结果数据在 Memory 结束、Write Back 状态寄存器才能知道，<code>jmp</code> 类指令的结果数据也要在 Execute 结束、Memory 状态寄存器才能知道。这两种指令紧邻的下一条指令在 Fetch 时（哪怕有 Data Forward）也没法得知结果，怎么办？</p><p>根据猜测策略，<code>jmp</code> 直接先猜测按照 <code>valC</code> 跳转，但是检查 <code>M_Cnd</code> 时，<code>jmp</code> 已经向前前进了 2 个 Stage 了（Fetch Finish -&gt; Execute Finish），如果 <code>M_Cnd</code> 指示符合跳转条件，那么继续执行没有问题，但是如果出错，应该怎么办？<strong>我们发现检查 <code>M_Cnd</code> 的时候，中间两个指令分别在 Decode 起点、Execute 起点，还有下一条指令刚要进入 Fetch 阶段 —— 即便 <code>jmp</code> 错误，当前也并没有产生影响（如更改 CC、写入下一个 stage 的状态寄存器）。</strong>因此很好解决：</p><p><code>jmp</code> 如果发现 <code>M_Cnd</code> 指示不应该跳转，说明预测错误，立即进行以下措施：</p><ol><li>由于 <code>jmp</code> 以后的错误指令只有两条（位于 Decode 和 Execute 开始阶段），并且没产生影响，只需要在时钟上升沿时将它们的 <code>icode</code> 改为 <code>1</code>（<code>nop</code>），就能解决错误执行的问题；</li><li>同样是上升沿阶段，将 <code>M_Cnd</code> 给到 Fetch 阶段，这个时候 Fetch 阶段就能读到正确的下一条指令；</li></ol><p><strong>所以就算 <code>jmp</code> 预测错误，有了上面的措施，也就浪费 2 个 Cycles 而已，不会造成执行语义错误</strong>！</p><p>再来看 <code>ret</code> 的跳转错误如何修复。</p><p>根据策略，<code>ret</code> 不会做猜测（一般行为遵从 Predict PC 拿到的 <code>valP</code>），直接接着这条指令向下读。但是 <code>ret</code> 和 <code>jmp</code> 不一样，不能按照原来 feedback paths 解决，因为 <code>ret</code> 拿到结果 <code>W_valM</code> <strong>要到 Memory Stage 结束，而这个时候 <code>ret</code> 向前前进了 3 个 Stage，紧跟 <code>ret</code> 的指令 Execute 已经执行结束 —— 也就是说，错误的指令改变了 CC 和后续状态寄存器，这是不允许的！</strong></p><blockquote><p>你可能会问，我们能不能早一点拿到 <code>valM</code>，比如 <code>m_valM</code>？不行，因为 <code>m_valM</code> 产生在 Clock 很后面的阶段（尤其是从内存读），Clock 时钟来不及。</p></blockquote><p>因此，我们只能采取 <strong>填充 3 个 Bubbles</strong> 的方法，避免出现错误：</p><ul><li><p>当 CPU 检测到 <code>ret</code> 指令结束 Fetch、进入 Decode Stage 时，<strong>立即向 Fetch Stage 发送 Stalling 信号，不允许 Fetch Stage 的状态寄存器被写入</strong>；</p><blockquote><p>为什么处理 <code>ret</code> 需要把 Fetch Stage Stall 住？因为任由 fetch stage 向下取的话，可能取到非法指令，改变了状态（stat）信息，给后面增添判断的麻烦，所以索性 stall 住。</p></blockquote></li><li><p>将输出到 Decode Stage 的 <code>icode</code> 改为 <code>nop</code> 的；</p></li><li><p>重复以上两个措施共 3 个 Cycles，直至 <code>ret</code> 结束 Memory Stage；</p></li></ul><p>这样，当 <code>ret</code> 结束 Memory Stage 时，时钟上升延会推动正确的返回地址数据到 Write Back Stage 的状态寄存器 <code>W_valM</code> 中，此时利用 Select PC，在 Fetch 阶段就能读到正确的下一条指令的地址了。</p><p>所以，无论如何，<code>ret</code> 后面总是要被 CPU 追加 3 个 bubble 的空隙。</p><p>综上，根据我们的<u><strong>猜测策略 和 修复措施</strong></u>，Select PC 的工作逻辑应该是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int f_PC = [</span><br><span class="line">#mispredicted branch. Fetch at incremented PC</span><br><span class="line">      M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;</span><br><span class="line">#completion of RET instruciton</span><br><span class="line">      W_icode == IRET : W_valM;</span><br><span class="line">#default: Use predicted value of PC</span><br><span class="line">      1: F_predPC</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li>当我们发现之前一条指令是 <code>jmp</code> 类，并且条件有效时，选 <code>M_valA</code>（即原封不动的 <code>valP</code> 值）；</li><li>当我们发现之前一条指令是 <code>ret</code> 时，意味着 Memory 结束、发送给 Write Back 的状态寄存器才是正确的地址（<code>W_valM</code>）；</li><li>其他的情况选择 <code>F_predPC</code>（也就是 Fetch 阶段自己算好的 <code>valP</code>）。</li></ul><hr><p>最后，总结一下 Y86-64 是如何解决 Control Hazard 的问题的：</p><ul><li>对于一般指令（不含 <code>jmp</code>、<code>call</code>、<code>ret</code>），只要让 Select PC 默认读 <code>valP</code>（在 Fetch 阶段就计算好的）就行，此后也无需检查、不存在 Wasted Cycles，因为下一条指令的位置一定是正确的；</li><li>对于 <code>call</code> 指令，只要将 Select PC 默认读 <code>valC</code>（在 Fetch 阶段就读到的）就行，此后也无需检查、不存在 Wasted Cycles，因为下一条指令的位置一定是正确的；</li><li>对于 <code>jmp</code> 指令，读到时默认跳转 <code>valC</code>，继续执行，但在 2 个 Cycles 后检查 <code>M_Cnd</code>，正确就什么都不做，不正确就将中间两条错误指令改为 <code>nop</code>，Fetch 阶段自动会读入正确地址。这种情况总共浪费 2 个 Cycles；</li><li>对于 <code>ret</code> 指令，读到时不作猜测，默认 <code>valP</code>，但是当 <code>ret</code> 进入 Decode Stage 时，Stalling Fetch Stage，并且将传给 Decode 的指令的 <code>icode</code> 改为 <code>nop</code> 的，持续 3 个 Cycles。这样 Fetch 就能通过 <code>W_valM</code> 读到正确的下一条地址。这种情况一定浪费 3 个 Cycles；</li></ul><h3 id="9-8-5-Exception-Handling-in-Pipeline"><a href="#9-8-5-Exception-Handling-in-Pipeline" class="headerlink" title="9.8.5 Exception Handling in Pipeline"></a>9.8.5 Exception Handling in Pipeline</h3><p>在之前的章节，我们介绍了 x86-64 的 Exception Control Flow，它是 OS 与硬件配合改变执行流的动作。</p><p>如果在 SEQ 设计中，我们只需更改 PC 寄存器即可。但是在 Pipeline 设计中，我们需要清理一些寄存器的值、某些 stage 的状态寄存器，才能转到指定的 ECF 地址。主要的步骤如下：</p><ol><li>打断当前程序执行流；</li><li>根据出现的事件，填入 Exception Table Base Register，找到 Exception Table 对应的 Exception Handler 地址，跳入新的执行流；</li><li>（可能）回到原来的执行流；</li></ol><p>我们这里先只考虑 <strong>同步异常（Synchronous Exceptions）</strong>。</p><p>那么可能导致同步异常的硬件层面原因有：</p><ul><li><code>halt</code> 指令；</li><li>指令请求错误的指令地址 / 数据地址；</li><li>非法指令；</li></ul><p>为了处理问题，我们还要讨论错误可能发现的位置：</p><ul><li>能在 Fetch Stage 检测的 Exceptions：<ul><li><code>jmp $-1</code>：<code>jmp</code> 非法地址；</li><li><code>.byte 0xFF</code>：非法指令；</li><li><code>halt</code>：程序终止；</li></ul></li><li>能在 Memory Stage 检测的 Exceptions：<ul><li><code>rmmovq %rax, 0x10000000000(%rax)</code>：非法内存地址；</li></ul></li></ul><p>但是，pipeline 的设计导致一些奇怪的情况：</p><p><strong>Situation 1. 异常检测顺序倒置</strong>：代码的执行流中两个错误，但是后一条错误发现时间（Fetch Stage）在前一条错误发现时间（Memory Stage）之前。导致后一条指令会先报错；</p><p><strong>Situation 2. 不应该触发的异常</strong>：异常的代码不在程序执行流内（例如 halt 以后不全是 0，有没擦干净的乱码；或者 <code>jmp</code> 的另一个不会执行的分支），但是 CPU 仍然可能读入并报错；</p><p>你可能会想，我们要模仿 SEQ，<strong>先检测到错误没事，只要我们在这条指令完全结束后（该指令到 Write Back Stage 结束）再报出错误，就能避免上面两种情况的发生</strong>。但这样做可能引发另一类问题：</p><p><strong>Situation 3. 异常指令的 Side Effect</strong>：错误指令和正常指令一起在流水线中向上传播，可能会导致 CC 被错误地修改（例如<strong>在错误指令后面的指令不应该被执行，但是它仍然更改了 CC</strong>，这会影响 Dump 的数据）；</p><p>综合以上的情况，我们总结出了解决方案：</p><ul><li><p>类比 Program Status，<strong>在每个 stage 的状态（除了 fetch）寄存器中加入 <code>stat</code> 寄存器，表示当前指令的执行情况。<code>AOK</code> 表示指令正常，<code>ADR</code> 表示指令访问错误地址，<code>HTL</code> 表示 <code>halt</code> 终止指令（方便阻止 <code>halt</code> 以后的指令的执行），<code>INS</code> 表示非法指令</strong>；</p></li><li><p>Fetch Stage 或 Memory Stage 如果能检测出错误，那么就设置到下一个阶段的 <code>stat</code> 寄存器；其余阶段（<code>Decode</code>、<code>Execute</code>）直接传递 <code>stat</code> 寄存器；</p><p>即：当异常出现时，仅仅设置状态寄存器（stat），其他正常；</p></li><li><p>如果异常到达 Memory 阶段，则为了防止错误指令影响状态寄存器或 CC，进行以下措施：</p><ol><li><p>对于非法指令，接下来向 Memory 阶段插 bubbles：即对于非法的内存操作，不允许写入内存；</p></li><li><p>立即关闭之后的 Execute 阶段写入 CC；</p></li></ol></li><li><p>如果异常到达 Write Back 阶段，则将该阶段 stall 住，抛出错误（只有在 Write-Back 阶段被触发，保证异常触发的顺序）。</p><blockquote><p>检查 <code>W_stall</code> 的条件，只需要检查 <code>W_stat</code> 就行，不需要管 <code>m_stat</code>；</p></blockquote></li><li><p>最后打断当前执行流：</p><ol><li>将 next PC 值 / 触发异常的指令 PC 压入栈中（通常和 exception <code>stat</code> 一起传递）；</li><li>使用事先固定在 ISA 中的 Exception Handler Address 跳转到 handler 中执行。</li></ol></li></ul><h3 id="9-8-5-Final-Implementation"><a href="#9-8-5-Final-Implementation" class="headerlink" title="9.8.5 Final Implementation"></a>9.8.5 Final Implementation</h3><p>我们将前几节的 Pipeline 设计的思想和注意要点结合起来，考虑设计一个 Y86-64 pipeline 处理器的最终版本。</p><h3 id="9-8-6-Performance-Analysis-Metrics"><a href="#9-8-6-Performance-Analysis-Metrics" class="headerlink" title="9.8.6 Performance Analysis: Metrics"></a>9.8.6 Performance Analysis: Metrics</h3><ul><li><p>Clock Rate</p></li><li><p>CPI (Cycles per instruction): On average, how many clock cycles does each instruction require?</p><script type="math/tex; mode=display">CPI=\dfrac{C}{I}=\dfrac{I+B}{I}=1+\dfrac{B}{I}</script><p>其中 $C$ 表示时钟 cycle 数，$I$ 为在 $C$ 个时钟 cycles 下执行的指令数，$B$ 为在 $C$ 个时钟 cycles 下插入的 bubble 数（$C=B+I$）；如果 $LP$、$MP$、$RP$ 分别代表 Load/Use Hazard、Misprediction Hazard、Return Hazard <strong>平均一条指令中出现的次数</strong>，那么：</p><script type="math/tex; mode=display">\dfrac{B}{I}=LP+MP+RP</script></li></ul><p>比如我们利用 Metrics 的指引进行优化：Speculation Execution in Fetch Logic；</p><p>考虑 PIPE CPU 的关键路径：</p><p><img src="imgs2/pipe-criticalpath.png" height="150px"></p><p>我们发现 increment 阶段是关键路径上较大的部分，它要等待 regids、valC 结果，然后执行 64-bits 的加法运算（最多 +10），所以我们可以先将前 60 bits 的数据 +1（同时保留不加、+1 的数据），然后另一部分仅仅是 4 bits 数的相加，这样可以节省串行进位加法所耗费的时间，如下图所示：</p><p><img src="imgs2/pc-improve.png" height="300px"></p><p>这样指令总体的速度都会快上一些。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-8-Scheduler-in-OS&quot;&gt;&lt;a href=&quot;#Chapter-8-Scheduler-in-OS&quot; class=&quot;headerlink&quot; title=&quot;Chapter 8. Scheduler in OS&quot;&gt;&lt;/a&gt;Chapter 8.</summary>
      
    
    
    
    <category term="review" scheme="https://sjtuxhw.top/categories/review/"/>
    
    
    <category term="GNU" scheme="https://sjtuxhw.top/tags/GNU/"/>
    
    <category term="CSAPP" scheme="https://sjtuxhw.top/tags/CSAPP/"/>
    
    <category term="ICS" scheme="https://sjtuxhw.top/tags/ICS/"/>
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>《只有我不在的城市》番评</title>
    <link href="https://sjtuxhw.top/2023/10/01/%E3%80%8A%E5%8F%AA%E6%9C%89%E6%88%91%E4%B8%8D%E5%9C%A8%E7%9A%84%E5%9F%8E%E5%B8%82%E3%80%8B%E7%95%AA%E8%AF%84/"/>
    <id>https://sjtuxhw.top/2023/10/01/%E3%80%8A%E5%8F%AA%E6%9C%89%E6%88%91%E4%B8%8D%E5%9C%A8%E7%9A%84%E5%9F%8E%E5%B8%82%E3%80%8B%E7%95%AA%E8%AF%84/</id>
    <published>2023-10-01T02:20:47.000Z</published>
    <updated>2023-10-25T12:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: </i> 维基百科词条、<a href="https://movie.douban.com/subject/26427106/">只有我不在的街道 (豆瓣)</a></p><p><strong>声明：本文仅代表个人主观观点，侵删。</strong></p><p><strong>【重要】本文除去剧透警戒线下部分，其他内容不含具体故事情节。</strong></p><hr><p>在我看过的一百多来部的番剧中，有的能真正扣住我心弦，这大抵是少数；现在看来大多却是 “食之无味，弃之可惜”。初中时期的我曾经浅浅尝试过一部，但是由于开头比较惊悚的画面，还有网友打上的 NTR 标签，让我一直敬而远之、束之高阁。这部番的名字是《只有我不在的城市》(僕だけがいない街) 。</p><p>距离我第一次接触它已经过了好几年的时间，我也不是当年看番只看 HE 类型的观众了。于是我鼓起勇气，在这个国庆重温了这个多年前的老动画。</p><p>本以为我每天在睡前看一小会很快就能结束，可是万万没想到，我最终却熬了大夜将其一口气补完了。没错，在我个人看来，这部番绝对算得上是能排上名的一个相当优秀的作品。下面我将从我自己的视角来讲述这个作品带给我的小小震撼。</p><h3 id="优秀的理由"><a href="#优秀的理由" class="headerlink" title="优秀的理由"></a>优秀的理由</h3><blockquote><p>注：本节几乎没有剧透内容。</p></blockquote><p>这个作品是由同名漫画动画化而来，本人先观看了动画作品，而后再了解的漫画，所以这里的评价主要是围绕着<strong>动画的表现</strong>。</p><p>在我心目中，一个番剧想要做到不淹没在其他同质化的番剧之中、“泯然众人”，达到优秀的层面，有这几点要求：<strong>世界观的架构（设定）</strong>或真实或新颖，<strong>故事逻辑</strong>清晰合理，<strong>故事情节</strong>或流畅或跌宕，<strong>人物刻画</strong>不千篇一律。</p><p>《只有我不在的城市》在这些方面看来就已经超过了许多 “流水线生产” 的番：</p><ul><li>设定上男主（悟）生活在普通城市，有 “重放” 的能力。这一点虽然和<a href="https://zh.moegirl.org.cn/%E5%91%BD%E8%BF%90%E7%9F%B3%E4%B9%8B%E9%97%A8%E7%B3%BB%E5%88%97"><strong>石头门</strong></a>的设定有些相似，但不至于落入俗套；并且在情节的加持下，真正观看的时候反而是一个比较吸引人的点；</li><li>故事的情节发展遵循唯一主线，紧密跟随男主视角；叙事节奏相当紧凑，但不慌乱，整体给人一种 “看完一集就忍不住继续下一集” 的想法；</li><li>故事对发生的事件和人物的描绘非常讲究主次和详略，对关键人物和群体的性格表现的比较丰满和立体，不会出现特意为某些角色补戏份、添加降智行为，或者套上标签和刻板印象的情况。</li><li>这部作品无论是动画还是漫画，其画风都比较戳我，颜值尚佳。</li></ul><blockquote><p>遗憾的是，最近这段时间我能找到的番剧中，达到甚至超越上面特征的可谓凤毛麟角。</p></blockquote><p>最后，还是在我<strong>个人</strong>看来，这部作品并没有让我避之不及的 NTR 元素，纯爱战士也能够无伤通关，所以别因为这一点而停下你观赏的脚步。至于原因我会在后面分析，这毕竟是比较主观的方面，一千个人眼中有一千个哈姆雷特嘛。</p><p>🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧 ⚠⚠⚠ <strong>剧透警告</strong> ⚠⚠⚠ 🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧</p><h3 id="故事的主线梳理"><a href="#故事的主线梳理" class="headerlink" title="故事的主线梳理"></a>故事的主线梳理</h3><p>这里简短地回顾一下在动画中的叙事内容。</p><p>首先 29 岁的男主 <strong>藤沼悟</strong> 出生于 1977 年 3 月 2 日，刚登场时看起来发表过一些漫画作品，在披萨店 <code>Oasi Pizza</code> 打工。他的 “重放” 能力能够倒退时间（自身无法控制），回到事件（<strong>通常是坏事件</strong>）未发生的时候。</p><p><img src="imgs/z_1.jpg" height="300px"></p><p>2006 年，<strong>悟</strong> 在某次在打工中途借助了能力救下了一位小学生，恰巧被披萨店的同事 <strong>片桐爱梨</strong> 看见。虽然受到了轻伤，但他的母亲 <strong>藤沼佐知子</strong> 因为担心他，而决定暂时搬过来照顾他。一日，打工回来的他目睹母亲死亡的现场，却被当作凶手通缉。情急之下 <strong>悟</strong> 无意间触发了 “重放” 而回到了 1988 年，也就是自己就读于市立美琴小学的时期。这是 <strong>悟</strong> 从最开始的时间线跳跃到第二条时间线。</p><p>为了解决发生在上个时间线上的小学生连续诱拐事件，同时想办法避免母亲的死亡（据主角推测，是因为目前猜出当年的真正凶手，才惨遭毒手），<strong>悟</strong> 想尽办法与 <strong>雛月加代</strong>（连环案中第一个遇害的学生）处好关系，却在生日（主角推算的案发时间）过后的第二天失踪——这仅仅将她的遇害时间延迟到了 3 月 3 日。到此，主角的所做的努力以失败告终。</p><p><img src="imgs/z_2.jpg" height="300px"></p><p>在 <strong>悟</strong> 结束 “重放”，回到第二个时间线的 2006 年时，他仍然是警方通缉的对象。在与警察的周旋中，<strong>片桐爱梨</strong> 坚信 <strong>悟</strong> 不是弑母凶手，帮助 <strong>悟</strong> 躲避警察追捕。也正因如此，她被真正的犯人纵火困于居住地而昏迷，最后被 <strong>悟</strong> 和 <strong>高桥店长</strong> 救出。在 <strong>爱梨</strong> 住院期间，为了避开警方监视，她拜托母亲伪装，自己逃出意愿与 <strong>悟</strong> 会面，提供了真凶可能是 <strong>西园学</strong>（原名 八代学，1988 年是 悟 的小学班主任）的线索。紧接着 <strong>悟</strong> 继续 “重放”，回到 3 月 2 日 <strong>加代</strong> 未遇害的第三条时间线。</p><p><strong>悟</strong> 在第三条时间线上成功阻止了 3 人被害，但真凶，就是当时的 <strong>八代学</strong>，设圈套利用被孤立的 <strong>柳原美里</strong> 骗 <strong>悟</strong> 并使其溺水成为植物人的状态。15 年后在医院苏醒，在取回记忆后，识破 <strong>西园学</strong>（以前的 八代学）的诡计，并用计让 <strong>西园学</strong> 坦白罪行。</p><p><img src="imgs/z_3.jpg" height="300px"></p><p>故事的最后，<strong>西园学</strong> 被逮捕，而 <strong>悟</strong> 成为了人气漫画家，在桥下躲雪与 <strong>爱梨</strong> 相遇，全剧终。</p><h3 id="番剧内容补充"><a href="#番剧内容补充" class="headerlink" title="番剧内容补充"></a>番剧内容补充</h3><p>事实上，这个动画刷完后，我还有一些地方不是很理解，或者说突兀，例如 八代学 的作案动机等。根据网友的解答，这和动画版删改的细节有关。</p><p>漫画中曾提到，八代学 的哥哥是一个三观扭曲的罪犯，在他的影响下，八代学 小时候就将朋友赠送的数只仓鼠尽数处决。不仅如此，漫画中还交代了他还是个非常缜密的罪犯，他只会找几个特质的人进行处决：“孤立”、“无助”、“不关心他人”、“孩童”，这些人在他的眼中仿佛是 <strong>攀于蛛丝上的犍陀多</strong>（用典 “蜘蛛之丝”）。他想要看到他所处决的对象对于生命执著的样子，而他能从中取得 “快乐”。而且他每处决一人之前，都会先做好缜密的计画，包含了如何取得被害人信任，以及怎样消除能追到他的证据，甚至是如何把这些罪行推到无关的人身上。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="imgs/3_1.jpg" width="350px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="imgs/3_2.jpg" width="350px" align=center></div></div></div></div><p>至于为什么 八代学 在 悟 破坏了他的计划后的 15 年内都没有犯罪，这在漫画中有所暗示，其实不是如此。他设计抹除了他入赘的议员女儿的男朋友，之后入赘到这个议员家里面改姓 “西园”，之后又设计做了岳父，取得了他的人脉后当上议员。接下来靠著议员的身份一直在观察 悟，希望他能够苏醒后亲手处决他。</p><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>这部带给我的不仅仅是绮丽的画风、引人入胜的紧凑剧情以外，我更喜欢的是作者笔下的人情世故。</p><p>悟 坐在 八代学 的车上说，“我想要弥补人心中的空缺”。在成长过程中，我们可能或多或少遇到这样那样的缺失——应该说却没说出口的话，应该保护却没有保护好的人，应该挺身而出却逃避的事……悟 心中的心结之一就是没能在那天夜晚叫上 加代 回家，这样很可能她就不会遇害了。</p><p><img src="imgs/0_k.jpg" height="300px"></p><p>通过 “重放” 回到以前的 悟，卸下以往不关心他人的面具，29 岁的灵魂也勇于说出 “成为正义的伙伴” 的豪言壮语，勇敢地保护同伴，让追求正义地精神感染了身边地同伴，以实际行动弥补过去地遗憾和后悔。虽然最后 悟 在第三条时间线上牺牲了自己 18 年的青春，换来的是伙伴们的安然无恙，算是呼应了作品的标题 “只有我不在的城市”。</p><p>作者通过这种方式，向我们传递了 “悟以往之不谏，知来者之可追” 的人生态度。尽管我们多多少少心怀遗憾，心想 “如果当时这么做就好了”，但也希望我们像假面超人一样的坚韧不拔。我们无法回到过去，但我们拥有未来。愿我们不被胆怯束缚，敢闯敢拼，不留遗憾。</p><p>悟 的母亲 佐知子 也是一个让我印象深刻的人物。尽管警察没有采用 悟 的证言，她在看到 悟 坚定的眼神和解释后，选择相信 悟，并且在第一时间线的 18 年中都一直联系媒体同事追查真凶，即使案件已过追诉时效。</p><p><img src="imgs/0_s.jpg" height="300px"></p><p>在三时间线的最后，悟 在成为植物人的 15 年间，母亲 佐知子 在商店打工照顾 悟，日复一日，她也坚信自己的儿子有一天终将会醒来。动画中，制作组给到的无声的镜头，例如母亲望向柜面上浓重的黑眼圈，独自坐在在公园长椅上，注视着前方熙攘的人群。很难想象，这 15 年里究竟是什么支撑着母亲、又是什么给予母亲继续的希望。想到这里，一种酸楚的感觉仿佛涌上心头。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="imgs/0_1.jpg" width="350px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="imgs/0_2.jpg" width="350px" align=center></div></div></div></div><p>在作者和制作组的笔下，佐知子 这位观察力敏锐、行动力强、坚强善良和极富舐犊之情的母亲形象跃然纸上。</p><p>作品的最后，加代 没有成为 悟 的妻子，这固然是一个遗憾，但这又未尝不是这个作品情节和设计的新颖之处呢？在漫画的外传中，加代 无比感激 悟 为她所做的一切，每天都去 悟 所在的医院协助 佐知子 帮 悟 进行肌肉按摩，一直与他谈学校的故事。直到上了国中以后，悟 更换了病房，善意的 佐知子 给 加代写了封信，一方面是感谢 加代 能给 佐知子 希望，另一方面则是希望加代能把握 “现在”，找到属于自己的另一半。</p><p>这样的设计的情节却更加真实，不落窠臼，也是让我眼前一亮的优点。就像网友所说，“悟选择奋不顾身地去拯救加代，不是出于对加代的爱慕，而是童年时对正义超人的憧憬，和由于过去无法挽救加代而一直深埋潜意识的挥之不去的愧疚”。所以说，<strong>战胜恶龙的勇者需要的或许不是那位被拯救的公主</strong>。这也是这部作品脱离千篇一律的 “包饺子” 结局的一个重要特征。</p><p><img src="imgs/0_0.jpg" height="300px"></p><blockquote><p>从这个角度来看，这个作品（叠甲：<strong>在我个人看来</strong>）是没有 NTR 的成分的，至少我的第一印象如此。并不是所有的结局都是理想直至虚无缥缈的 “大团圆”。</p></blockquote><p>另外插一嘴，动画制作组真的细节，在 11 集的 OP 中移除了 悟 的身影，暗示着 悟 成功更改了时间线，这是只有 悟 不存在的城市。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="imgs/1_1.jpg" width="350px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="imgs/1_2.jpg" width="350px" align=center></div></div></div></div><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="imgs/2_1.jpg" width="350px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="imgs/2_2.jpg" width="350px" align=center></div></div></div></div><hr><p>最后，喜欢这部动画的观众可以找到对应的漫画（44 话 + 外传）进行进一步阅读，相信会有不一样的感受😉</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt; 维基百科词条、&lt;a href=&quot;https://movie.douban.com/subject/26427106/&quot;&gt;只有我不在的街道 (豆瓣)&lt;/a&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Chat" scheme="https://sjtuxhw.top/categories/Chat/"/>
    
    
    <category term="Anime" scheme="https://sjtuxhw.top/tags/Anime/"/>
    
    <category term="Appreciation" scheme="https://sjtuxhw.top/tags/Appreciation/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Notes Basic</title>
    <link href="https://sjtuxhw.top/2023/09/17/CSAPP-Notes-Basic/"/>
    <id>https://sjtuxhw.top/2023/09/17/CSAPP-Notes-Basic/</id>
    <published>2023-09-17T11:47:15.000Z</published>
    <updated>2024-05-16T10:55:12.711Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: </i> <a href="http://www.cs.cmu.edu/~213/schedule.html">CMU - 213</a>, <i>Computer Systems A Programmer’s Perspective 3rd Edition</i> by Randal Bryant, David O’Hallaron</p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p><i>内容很长，写起来很慢</i> 😳</p><hr><span id="more"></span><h1 id="Chapter-0-Intro"><a href="#Chapter-0-Intro" class="headerlink" title="Chapter 0. Intro"></a>Chapter 0. Intro</h1><h2 id="0-1-Ints-are-not-Integers-Floats-are-not-Reals"><a href="#0-1-Ints-are-not-Integers-Floats-are-not-Reals" class="headerlink" title="0.1 Ints are not Integers, Floats are not Reals"></a>0.1 Ints are not Integers, Floats are not Reals</h2><ul><li>$x^2\ge 0$：int（32-bit）may overflow；</li><li>$a+(b+c)=(a+b)+c$：floats may discard some “unsignificant” digits；</li></ul><h2 id="0-2-Learn-Assembly-but-never-write-it"><a href="#0-2-Learn-Assembly-but-never-write-it" class="headerlink" title="0.2 Learn Assembly but never write it"></a>0.2 Learn Assembly but never write it</h2><h2 id="0-3-Memory-Matters-Unbounded"><a href="#0-3-Memory-Matters-Unbounded" class="headerlink" title="0.3 Memory Matters: Unbounded"></a>0.3 Memory Matters: Unbounded</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125; <span class="type">struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">struct_t</span> t;</span><br><span class="line">    t.d = <span class="number">3.14</span>;</span><br><span class="line">    t.a[i] = <span class="number">109390032</span>;</span><br><span class="line">    <span class="keyword">return</span> t.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// func(0)/func(1) -&gt; 3.14</span></span><br><span class="line"><span class="comment">// func(2)    -&gt; 3.13...</span></span><br><span class="line"><span class="comment">// func(6)    -&gt; segment fault</span></span><br></pre></td></tr></table></figure><ul><li>C/C++ don’t provide <strong>any</strong> memory protection（out of bounds/invalid pointer/abuse of malloc-free）: can lead to nasty bugs.</li></ul><h2 id="0-4-There’s-more-to-performance-than-asymtotic-complexity"><a href="#0-4-There’s-more-to-performance-than-asymtotic-complexity" class="headerlink" title="0.4 There’s more to performance than asymtotic complexity"></a>0.4 There’s more to performance than asymtotic complexity</h2><p>(有比渐进复杂度更能够优化性能的做法)</p><ul><li>渐进复杂度中没有体现的“常数”也很重要；</li><li>应该在多方面优化性能：算法、数据结构表示、代码过程、循环等；</li><li><strong>Understand system to optimize performance</strong>;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyij</span><span class="params">(<span class="type">int</span> src[<span class="number">2048</span>][<span class="number">2048</span>], dst[<span class="number">2048</span>][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2048</span>; ++j)</span><br><span class="line">            dst[i][j] = src[i][j];        <span class="comment">// Row first.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyji</span><span class="params">(<span class="type">int</span> src[<span class="number">2048</span>][<span class="number">2048</span>], dst[<span class="number">2048</span>][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2048</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; ++i)</span><br><span class="line">            dst[i][j] = src[i][j];        <span class="comment">// Column first.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In a particular machine it was about close to 20 times difference in performance! (4.3ms vs 81.8ms) </span></span><br><span class="line"><span class="comment">// Memory hierachy: Cache memory</span></span><br></pre></td></tr></table></figure><h2 id="0-5-Computers-do-more-than-execute-programs"><a href="#0-5-Computers-do-more-than-execute-programs" class="headerlink" title="0.5 Computers do more than execute programs"></a>0.5 Computers do more than execute programs</h2><ul><li>They need to get data in &amp; out: I/O system;</li><li>They communicate with each other over network;</li></ul><h1 id="Chapter-1-Bits-Bytes-and-Integers"><a href="#Chapter-1-Bits-Bytes-and-Integers" class="headerlink" title="Chapter 1. Bits, Bytes and Integers"></a>Chapter 1. Bits, Bytes and Integers</h1><h2 id="1-1-Everythings-is-bits"><a href="#1-1-Everythings-is-bits" class="headerlink" title="1.1 Everythings is bits"></a>1.1 Everythings is bits</h2><blockquote><p>本部分知识零碎，应该在数电 + 初级数据结构中接触。</p></blockquote><ul><li>Each bit is 0 or 1;</li><li>By encoding/interpreting sets of bits in various ways;</li><li>Why bits? - Electronic Implemetation.<ul><li><strong>Easy to store</strong> with bistable elements.</li><li><strong>Reliably transmitted</strong> on noisy and inaccurate wires.</li></ul></li><li><strong>Base 2 Number Representation</strong></li><li><p>1 Byte = 8 bits；</p><ul><li>Binary: $00000000_2$ to $11111111_2$；</li><li>Decimal: $0_{10}$ to $255_{10}$；</li><li>Hexadecimal: $00_{16}$ to $FF_{16}$；<ul><li>掌握快速 16 进制转 2 进制：$1010=A,\space1100=C,\space1111=F$，B/D/E 在其中；</li></ul></li></ul></li><li><p>Data Representation in C language</p><table>    <tr>        <td>C Data Type</td>        <td>Typical 32-bit</td>        <td>Typical 64-bit</td>        <td>x86-64</td>    </tr>    <tr>        <td>char</td>        <td>1</td>        <td>1</td>        <td>1</td>    </tr>    <tr>        <td>short</td>        <td>2</td>        <td>2</td>        <td>2</td>    </tr>    <tr>        <td>int</td>        <td>4</td>        <td>4</td>        <td>4</td>    </tr>    <tr>        <td>long</td>        <td>4</td>        <td>8</td>        <td>8</td>    </tr>    <tr>        <td>float</td>        <td>4</td>        <td>4</td>        <td>4</td>    </tr>    <tr>        <td>double</td>        <td>8</td>        <td>8</td>        <td>8</td>    </tr>    <tr>        <td>long double</td>        <td>N/A</td>        <td>N/A</td>        <td>10 / 16</td>    </tr>    <tr>        <td>pointer</td>        <td>4</td>        <td>8</td>        <td>8</td>    </tr></table><ul><li><strong>注：单位 bytes，CSAPP 关注 x86-64 架构</strong>；</li><li><strong>注2：Intel x86-64 处理器的 <code>long double</code> 定为 10 bytes，但数据增量是 16 bytes，意味着会浪费 6 bytes 的存储空间</strong>；</li><li><strong>注3：pointer 值就是虚拟空间的地址，上面也正说明了 32 位和 64 位的名字的来源：这些虚拟内存的地址是 32 bits / 64 bits 长度的值</strong>；我们常说的 32 位机器、64 位机器就是指对应地址值的长度是 32/64 bits；</li></ul></li></ul><h2 id="1-2-Boolean-Algebra"><a href="#1-2-Boolean-Algebra" class="headerlink" title="1.2 Boolean Algebra"></a>1.2 Boolean Algebra</h2><ul><li><p>Developed by George boole in 19C, “True”: 1, “False”: 0;</p></li><li><p>Operations: And(<strong>\&amp;</strong>) / Or(<strong>|</strong>) / Not(<strong>~</strong>) / Exclusive-or(<strong>Xor, ^</strong>);</p><ul><li>Exercise: Operate on Bit Vectors;</li></ul></li><li><p><strong>Example: Representing &amp; Manipulating Sets</strong></p><ul><li><p>Representation: <strong>Width <code>w</code> bit vector can represent subsets of <code>&#123;0,...,w-1&#125;</code></strong>;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp; &lt;=&gt; Intersection</span><br><span class="line">| &lt;=&gt; Union</span><br><span class="line">^ &lt;=&gt; Symmetric Difference</span><br><span class="line">~ &lt;=&gt; Complement</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Shift Operations</p><ul><li>left shift、right shift；</li><li>logic shift：Fill with “0”；</li><li>arithmetic shift：if (negetive) Fill with “1”，else Fill with “0”；</li><li><strong>Undefined Behavior</strong>: shift amount <strong>&lt; 0</strong> or shift amount <strong>≥ word size</strong>；</li></ul></li></ul><h2 id="1-3-原码-true-form-、反码-1’s-complement-、补码-2’s-complement"><a href="#1-3-原码-true-form-、反码-1’s-complement-、补码-2’s-complement" class="headerlink" title="1.3 原码(true form)、反码(1’s complement)、补码(2’s complement)"></a>1.3 原码(true form)、反码(1’s complement)、补码(2’s complement)</h2><ul><li><p>补码速译：<strong>最高位权重变为负值</strong>；</p></li><li><p>Unsigned range：$0\sim 2^w-1$；</p><p>Two’s complement range：$-2^{w-1}\sim2^{w-1}-1$；</p></li><li><p><strong>模 8 运算：保留补码后三位</strong>；</p></li><li><p>Exercise 1: <strong>Mapping between signed &amp; unsigned</strong></p><p>（将同一个数码看作不同的数，例如 11111111 可以表示 unsigned 的 255，也可以表示 signed -1，这两者相同的数码被称为 “<strong>相同的位模式（bit pattern）</strong>”）</p><blockquote><p>这对计算机很重要，因为它原本不知道是 signed 还是 unsigned；</p></blockquote></li><li><p>Exercise 2: <strong>Casting Surprises</strong>（模糊的常数给定，什么时候类型转换？怎么转换？）</p><ul><li><p>什么时候：C++ 书中说，在赋值、比较时进行<strong>隐式类型转换（implicit casting）</strong>，还可以进行强制类型转换；</p></li><li><p>怎么转换：</p><ol><li><p>占用空间小的类型向大的类型转换：<strong>同时有 unsigned int 和 int，则向 unsigned int 转换</strong>（隐式类型转换）；</p><p>⚠ <strong>隐式类型转换转换唯一需要注意的点：“原来是什么，后来还是什么”。例如，<code>int</code> 向 <code>unsigned long</code>、<code>unsigned</code> 向 <code>long</code>是否会 signed / zero extension，取决于原来的数是否有正负。</strong></p></li><li><p>Bit pattern（位模式）保持不变；</p></li></ol></li><li><p>编程的麻烦：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// situation 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="built_in">func</span>(a[i]);</span><br><span class="line"><span class="comment">// situation 2</span></span><br><span class="line"><span class="comment">// 提示：sizeof 的返回值会被编译器认为是 size_t (unsigned long)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i - <span class="built_in">sizeof</span>(<span class="type">char</span>) &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="built_in">func</span>(a[i]);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Exercise 3: <strong>Sign Extension</strong>（在不改变值的情况下，将 w-bit 数变为 w+k-bit (k∈Z) 数）</p><ul><li><p><strong>Expanding Conclusion: Make k copies of MSB in signed, but fill “0” in unsigned.</strong></p><blockquote><p>想想为什么。</p></blockquote></li><li><p><strong>Truncating Conclusion: mod $2^w$ in unsigned,  很像 mod $2^w$ 但不是 in signed (negative or positive)</strong>;</p></li></ul></li></ul><h2 id="1-4-Operations"><a href="#1-4-Operations" class="headerlink" title="1.4 Operations"></a>1.4 Operations</h2><ul><li><p>Unsigned Addition: $sum=UAdd_w(u,v)=u+v\mod2^w$（为什么成立？<strong>Truncating Conclusion</strong>）；</p><ul><li>一种溢出，这种溢出是模运算可以描述的；</li></ul><blockquote><p>e.g., $(unsigned)13+5=1101_2+0101_2\Rightarrow0010_2$ (<strong>Truncated</strong>)</p></blockquote></li><li><p>Two’s complement Addition: $sum=TAdd_w(u,v)=UAdd_w(u,v)$（<strong>equal in bit pattern</strong>, <strong>Truncating Conclusion</strong>）;</p><ul><li>两种溢出：负溢出（$sum\le-2^{w-1}$ 时）和 正溢出（$sum\ge w^{w-1}$ 时）;</li></ul></li><li><p>Unsigned Multiplication: $multi=UMult_w(u,v)=u\cdot v\mod2^w$（与加法同理）;</p></li><li><p>Signed Multiplication Multiplication: $multi=TMulti_w(u,v)=UMulti_w(u,v)$（与加法同理）;</p></li></ul><blockquote><p>这意味着计算机的乘法、加法可以共用硬件；</p></blockquote><ul><li><p>Shift &amp; Power-of-2 Multiply / Divide: 原因可以看作改变权重；</p><ul><li><p>Unsigned: no problem；</p></li><li><p>Signed: <strong>Use arithmetic shift. Add a bias（偏移量 1）to bit pattern and then right shift</strong></p><blockquote><ol><li><p>为什么用 <strong>算数移位</strong>？因为 <strong>Expanding Conclusion</strong>；至于什么移位，C++ 标准没有明确说，但绝大多数机器都会算术移位；</p></li><li><p>为什么要偏移量？使结果向大数舍入；</p></li></ol></blockquote></li></ul></li><li><p>Negative（取相反数，当然只有 signed 做得到）：<strong>flip all the bits and then add 1</strong>（“~” 取反 + 1）</p></li><li><p>在介绍完移位运算后，回忆 1.3 中的 “编程麻烦”，能不能不用 unsigned，通通用 signed （全用补码表示）不就不会出现这些 casting suprises 了吗？确实，C++ 中尽量别用 unsigned，容易出问题；</p><blockquote><p>Java 就是这么做的。取消了 unsigned 的类型，<strong>并且禁止了某些隐式类型转换</strong>。但因为某些其他的需求，Java 不得不引入算数移位（&gt;&gt;&gt; 和 &lt;&lt;&lt;），就是 C++ 中处理 signed divide 的运算符;</p></blockquote><p><strong>但 unsigned 也有用处</strong>：</p><ul><li>取模运算：利用 unsigned 加法溢出特性；</li><li>使用 bits 来代表集合（1.2）；</li></ul></li></ul><h2 id="1-5-Miscellaneous"><a href="#1-5-Miscellaneous" class="headerlink" title="1.5 Miscellaneous"></a>1.5 Miscellaneous</h2><ul><li><p><strong>2 的幂次数大小估算</strong>：因为 $2^{10}\approx10^3$，这意味着每 3 位十进制数和 10 位二进制数相当，所以 $2^{20}\approx10^6$；</p></li><li><p>segmentation fault 的产生：64-bits pointer 让程序认为真的有 $2^{64}$ bit 的内存空间，但实际上并不是。所以当程序访问到操作系统未给它分配的内存时，会抛出 segmentation fault；</p></li><li><p><strong>字长究竟是多大</strong>：不确定。一般是由一种语言中指针表示的范围、存储器上最大存储块大小决定。例如 64 位机器就是擅长 64-bits 计算、指针大小 64-bits 的机器；<strong>因此一个程序的位数是由硬件和编译器共同决定的</strong>；</p><blockquote><p>所以 64 位机器可以运行 32 位程序（向后兼容）；</p><p>考虑内存对齐，32-bits 下字长相当于 4 bytes，64-bits 下字长相当于 8 bytes；</p></blockquote></li><li><p>Byte Ordering</p><ul><li><p>Big Endian（大端序）：<strong>现在常出现的地方就是 Internet，即当发送 32-bits 数据包时</strong></p><ul><li>Least significant byte has highest address（前面的 bits 排在地址靠前的位置，符合人类习惯）；</li></ul></li><li><p>Little Endian（小端序）：<strong>目前支持主流操作系统的处理器都能用小端序</strong></p><ul><li>Least significant byte has lowest address（前面的 bits 排在地址靠后的位置）</li></ul></li><li><p>Representing of integers</p><ul><li><p>Example of <code>01234567</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address: 0x100 0x101 0x102 0x103</span><br><span class="line">big       :  0123  4567</span><br><span class="line">little :  67    45  2301</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Representing of pointers</p></li><li><p>Representing of strings: Every machine is <strong>the same</strong>; (ended by ‘\\0’);</p></li></ul></li></ul><h2 id="1-6-Puzzles"><a href="#1-6-Puzzles" class="headerlink" title="1.6 Puzzles"></a>1.6 Puzzles</h2><p>Initialization:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">foo</span>();</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">bar</span>();</span><br><span class="line"><span class="type">unsigned</span> ux = x;</span><br><span class="line"><span class="type">unsigned</span> uy = y;</span><br></pre></td></tr></table></figure><ul><li><p>$x\lt0\Rightarrow(x*2\lt0)$ ? </p><blockquote><p>False, $x=TMin$ (negative overflow) ?</p></blockquote></li><li><p>$ux\ge0$ ?</p><blockquote><p>True;</p></blockquote></li><li><p>$x\space\And\space7==7\Rightarrow(x&lt;&lt;30)\lt0$ ?</p><blockquote><p>True, $(x&lt;&lt;30)==-2^{31}+2^{30}\lt0$;</p></blockquote></li><li><p>$ux\gt-1$ ?</p><blockquote><p>Always False, implicit casting：$(unsigned)(-1)=(\sum\limits_{k=0}^{31}2^k)_{10}\Longrightarrow\forall x((unsigned)x\le(unsigned)(-1))$;</p></blockquote></li><li><p>$x\gt y\Rightarrow-x\lt-y$ ?</p><blockquote><p>False, $y==TMin\Rightarrow-y==TMin$.</p><p>So: $\forall x(y==TMin\rightarrow -x\ge-y)$</p></blockquote></li><li><p>$x*x\ge0$ ?</p><blockquote><p>False. Positive overflow.</p></blockquote></li><li><p>$x\gt0\space\And\And\space y\gt0\Rightarrow x+y\gt0$ ?</p><blockquote><p>False. Positive overflow.</p></blockquote></li><li><p>$x\ge0\Rightarrow-x\le0$ ?</p><blockquote><p>True.</p></blockquote></li><li><p>$x\le0\Rightarrow-x\ge0$ ?</p><blockquote><p>False, $x==TMin\Rightarrow-x==TMin$.</p></blockquote></li><li><p>$(x|-x)&gt;&gt;31==-1$ ?</p><blockquote><p>False. $x==0$ ?</p></blockquote></li></ul><h1 id="Chapter-2-Floating-Point"><a href="#Chapter-2-Floating-Point" class="headerlink" title="Chapter 2. Floating Point"></a>Chapter 2. Floating Point</h1><h2 id="2-1-Fractional-Binary-Numbers"><a href="#2-1-Fractional-Binary-Numbers" class="headerlink" title="2.1 Fractional Binary Numbers"></a>2.1 Fractional Binary Numbers</h2><ul><li><p>Limitations: Can only exactly represent numbers of the form $x/2^k$; Other rational number have repeating bit representations.</p></li><li><p>IEEE Floating Point</p><ul><li><p>Numerical form: $(-1)^s\cdot M\cdot2^E$;</p><blockquote><ul><li>Sign bit $s$ determines whether number is positive or negative;</li><li>Significand（尾数，Mantissa） M normally a fractional value in $[1.0,2.0)$;</li><li>Exponent E weights value by power of 2;</li></ul></blockquote></li><li><p>Single precision: 32-bits</p><p>$s$: 1-bit; $exp$: 8-bits; $frac$: 23-bits;（$s$、$exp$、$frac$ 代表对应的数据域而已，下略）</p></li><li><p>Double precision: 64-bits</p><p>$s$: 1-bit; $exp$: 11-bits; $frac$: 52-bits;</p></li><li><p><strong>Normalized values</strong>:</p><ul><li><p>$exp$ 不全为 0，也不全为 1；</p></li><li><p>$exp$ coded as a biased value: $E=Exp-Bias$;</p><p>$Exp$: <strong>unsigned</strong> value of exp field.</p><p>$Bias=2^{k-1}-1$, where <strong>$k$ is number of exponent bits</strong>（当前 $exp$ 字段的 bit 长度，非常巧妙）</p><blockquote><p>为什么这么设定 Bias？</p><p>Single precision’s bias: 127（Exp: 1…254, E: -126…127）</p><p>Double precision’s bias: 1023（Exp: 1…2046, E: -1022…1023）</p></blockquote><p><strong>考虑为什么 $E$ 要这么表达？因为这么做比较起来非常方便</strong>（$Exp$ 0000… 最小，1111…最大）；</p></li><li><p>Significand $M$ coded with implied leading 1: $M = (1.xxxx…x)_2$</p><p>$xxxx…x$: bits of $frac$ field（0000…0最小，此时 M = 1；1111…1最大，此时 $M=2-\varepsilon$）</p><blockquote><p><strong>由于前导 1，normalized value 只能表示绝对值 $[2^{1-Bias},(2-2^{-bitsOfFrac})\cdot2^{2\cdot Bias})$ 范围的 floating point</strong>；</p></blockquote></li><li><p>理解：像科学计数法，$2^E$ 相当于十进制中的 $10^E$，用于移位，前面的 $M$ 规定具体数值；</p></li></ul></li><li><p><strong>Denormalized values</strong>:</p><ul><li><p>$exp$ 全为 0；</p></li><li><p>$exp$ coded as: $E=1-Bias$;（<strong>可以理解为此时 $exp$ 字段全 0 本身没意义，它们的个数来表示 $Bias$ 进而表示 $E$</strong>）</p></li><li><p>Significand $M$ coded with implied leading 0: $M=(0.xxx…x)_2$;</p><p>$xxx…x$: bits of $frac$ field;</p><blockquote><p>注意，这里会发现可以表示 “+0” 和 “-0”；⚠ 在比较大小和判断的时候要当心！</p><p><strong>denormalized value 只能表示绝对值 $[0,2^{1-Bias})$ 范围的 floating point</strong>；</p></blockquote></li></ul></li><li><p><strong>Special values</strong>:</p><ul><li>$exp$ 全为 1；</li><li>这种编码<strong>只有两种情况</strong>：<ol><li>$frac$ 域全为 0：代表 $\infty$;</li><li>$frac$ 域不全为 0：代表 $NaN$（not a number），例如 $\sqrt{-1}$、$\infty-\infty$、$\infty\times0$ 等；</li></ol></li></ul></li></ul><blockquote><p>这样规定就会发现，浮点数<strong>恰好可以溢出到 $\pm\infty$</strong>，而且错误数恰为 $NaN$；</p><p>Visualization： <img src="imgs/float_visualization.png"></p><p>想要理解上面规定的原因还可以用少量的数位来模拟，<strong>你会发现之前的设定非常巧妙</strong>：</p><p>（这里以 $s$: 1-bit，$exp$: 4-bits，$frac$: 3-bits 为例）</p><p><img src="imgs/float_range.png" height="350"></p></blockquote></li><li><p>Special Properties of IEEE Encoding</p><ul><li>FP（Floating Point）zero same as Integer zero（<strong>All bits = 0</strong>）；</li><li>Can <strong>almost（except NaN）</strong> use <strong>unsigned integer comparison</strong>；<ul><li>Must first compare sign bits；</li><li>Must consider <strong>-0 = +0</strong>；</li><li>What should comparison with NaN yield？</li><li><strong>Otherwise OK ($+\infty$ 和 $-\infty$ 都能与数比较)</strong>；</li></ul></li></ul></li><li><p>Exercise: <strong>write float pointing in bit-level representation</strong>;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> F = <span class="number">15213.0</span>;</span><br></pre></td></tr></table></figure><ul><li>$15213_{10}=11101101101101_2=1.1101101101101_2\times2^{13}$</li><li>$M=1.1101101101101_2$, $frac=11011011011010000000000_2$</li><li>$E=13$, $Bias=127$, $Exp=E+Bias=140_{10}=10001100_2$;</li><li>$Normalized\space value=01000110011011011011010000000000$</li></ul></li></ul><h2 id="2-2-The-Operations-for-Floating-Point"><a href="#2-2-The-Operations-for-Floating-Point" class="headerlink" title="2.2 The Operations for Floating Point"></a>2.2 The Operations for Floating Point</h2><ul><li><p>Basic idea</p><ol><li>First compute exact result;</li><li>Make it fit into desired precision<ul><li>possibly overflow if exponent too large;</li><li>possibly <strong>round</strong> to fit into $frac$;</li></ul></li></ol></li><li><p>Rounding for base 10 numbers</p><ul><li><p>Towards zero（向 0 舍入）；</p></li><li><p>Round down（向下舍入）；</p></li><li><p>Round up（向上舍入）；</p></li><li><p>Nearest Even（default）</p><blockquote><p>即 <strong>四舍六入五成双</strong>，见概率统计；</p><p>超过一半都是 “六” 的情况，少于一半都是 “四” 的情况，正好一半看最后保留位的奇偶；</p></blockquote></li></ul></li><li><p>Rounding Binary number: Nearest Even 与 普通十进制数思路相同；</p><blockquote><p>举例：Round to nearest 1/4（2 bits right of binary point）：</p><p>$10.00011_2\Rightarrow 10.00_2$，$10.00110_2\Rightarrow10.01_2$，</p><p>$10.11100_2\Rightarrow11.00_2$，$10.10100_2\Rightarrow10.10_2$；</p></blockquote></li><li><p>FP Multiplication: $multi=(-1)^s\cdot M\cdot2^E=(-1)^{s_1}\cdot M_1\cdot 2^{E_1}\cdot(-1)^{s_2}\cdot M_2\cdot2^{E_2}$</p><ul><li>Sign $s=s_1\space^\wedge\space s_2$;</li><li>Significand $M=M_1\times M_2$;</li><li>Exponent $E=E_1+E_2$;</li><li><strong>Fixing</strong><ol><li>If $M\ge2$，shift $M$ right, increment $E$; (<strong>That’s why  $M\lt 2$</strong>) </li><li>If $E$ out of range ($Exp$ out of range), overflow;</li><li>Round $M$ to fit $frac$ precision;</li></ol></li></ul></li><li><p>FP Addition: $sum=(-1)^s\cdot M\cdot2^E=(-1)^{s_1}\cdot M_1\cdot2^{E_1}+(-1)^{s_2}\cdot M_2\cdot2^{E_2}$. (assume $E_1\gt E_2$)</p><ul><li>Sign $s$, Significand $M$: <strong>Result of signed align &amp; add</strong>;</li><li>Exponent $E$: <strong>the same as $E_1$, which means $E_2$ will be ignored if $E_1\gt\gt E_2$</strong>;</li><li><strong>Fixing</strong><ol><li>If $M\ge2$, shift $M$ right, increment $E$;</li><li>If $M\lt1$, shift $M$ left $k$ positions, decrement $E$ by $k$; (<strong>The difference between multiplication</strong>)</li><li>If $E$ out of range, overflow;</li><li>Round $M$ to fit $frac$ precision;</li></ol></li></ul></li><li><p><strong>Mathematical Properties of FP addition / multiplication</strong>:</p><ul><li>具备交换律 (commutative)，不具备结合性 (associative)：舍入的不准确性和溢出、大数和小数之和会丢失小数、大数和大数乘积会变为 $\infty$；</li><li>Every element has additive inverse (相反数) <strong>except for infinites \&amp; NaNs</strong>；</li><li>几乎具备单调性 (Monotonicity): $a\ge b\Rightarrow a+x\ge b+c$ <strong>except for infinites \&amp; NaNs</strong>;</li></ul><blockquote><p><strong>总而言之，在考试时，忘记这些问题不大，想要快速判断是否满足某个定律，只需找特殊：$\infty$、$NaN$、overflow、0，这四者是大多数特例的来源</strong>；</p></blockquote></li></ul><h2 id="2-3-Floating-Point-in-C"><a href="#2-3-Floating-Point-in-C" class="headerlink" title="2.3 Floating Point in C"></a>2.3 Floating Point in C</h2><ul><li><p><code>float</code>（single precision），<code>double</code>（double precision）；</p></li><li><p>Conversions / Casting:</p><ul><li><p><strong><code>int</code>、<code>double</code>、<code>float</code> 间的转换会改变 bit representation</strong>；</p><blockquote><p>回忆 signed 和 unsigned 间的转换，不改变 bit pattern，只是改变某些位置的解释方式；</p></blockquote></li><li><p>implicit casting 发生在占用小空间的类型（int）向占用大空间类型（double）转换，也可显式声明；</p><ul><li><code>int -&gt; double</code>: <strong>准确转换。因为 <code>int</code> 大小小于 53-bits</strong>；</li><li><code>int -&gt; float</code>: <strong>Will rounding according to rounding mode</strong>；</li></ul></li><li><p>显式类型转换 <code>double/float -&gt; int</code></p><ul><li>Truncates (截断) fractional part;</li><li>Like rounding toward 0 (<strong>可以看作向 0 舍入</strong>);</li><li>Not defined when out of range / NaN: <strong>Generally sets to <code>TMin</code></strong>;</li></ul></li></ul></li></ul><h2 id="2-4-Puzzles"><a href="#2-4-Puzzles" class="headerlink" title="2.4 Puzzles"></a>2.4 Puzzles</h2><p>initialization:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = ...;</span><br><span class="line"><span class="type">float</span> f = ...;</span><br><span class="line"><span class="type">double</span> d = ...;</span><br><span class="line"><span class="comment">// Assume neither d nor f is NaN;</span></span><br></pre></td></tr></table></figure><ul><li><p>$x==(int)(float)x$ ?</p><blockquote><p>False; (int)x -&gt; (float)x (rounded)</p></blockquote></li><li><p>$x==(int)(double)x$ ?</p><blockquote><p>True;</p></blockquote></li><li><p>$f==(float)(double)f$ ?</p><blockquote><p>True;</p></blockquote></li><li><p>$d==(double)(float)d$ ?</p><blockquote><p>False; (double)d -&gt; (float)d (rounded)</p></blockquote></li><li><p>$f==-(-f)$ ?</p><blockquote><p><strong>True. Even $f==\pm\infty$ is true.</strong></p></blockquote></li><li><p>$2/3==2/3.0$ ?</p><blockquote><p>False; $(int)2/3=0$, $(double)2/3.0=0.666…67$;</p></blockquote></li><li><p>$d\lt0.0\Rightarrow(d*2\lt0.0)$ ?</p><blockquote><p><strong>True; Even $d*2==-\infty$ is true.</strong></p></blockquote></li><li><p>$d\gt f\Rightarrow-f\gt-d$ ?</p><blockquote><p>False; $d==+\infty$ or $f==-\infty$ ?</p></blockquote></li><li><p>$d*d\ge0.0$ ?</p><blockquote><p><strong>True. Even $d==\pm\infty\Rightarrow d*d==+\infty$ is true.</strong></p></blockquote></li><li><p>$(d+f)-d==f$ ?</p><blockquote><p>False; $d&gt;&gt;f\Rightarrow(d+f)\approx d$;</p></blockquote></li></ul><blockquote><p>C1 &amp; C2 结束，请完成 Data Lab！</p></blockquote><h1 id="Chapter-3-Machine-Level-Programming-Ⅰ-Basics"><a href="#Chapter-3-Machine-Level-Programming-Ⅰ-Basics" class="headerlink" title="Chapter 3. Machine-Level Programming Ⅰ- Basics"></a>Chapter 3. Machine-Level Programming Ⅰ- Basics</h1><blockquote><p>和前面说的一样，本章不会教学一段段写汇编，只要求看懂 GCC 输出的汇编代码即完成任务；</p><p><strong>本章涉及的机器语言运行在 Intel x86-64 机器上</strong>；</p></blockquote><ul><li><p>两种机器代码</p><ul><li>计算机实际运行的目标代码（一串字节编码处理器执行的指令，难以阅读）；</li><li>汇编代码：过去用于直接对机器进行编程，现在是编译器输出的目标。</li></ul><blockquote><p>以后说 “机器代码”，有时指第一种（目标代码），有时指第二种（文本格式的汇编代码），它们两者概念几乎相同，可替换。不过为了防止混淆以后对第二种会说 “汇编代码”。</p></blockquote></li></ul><h2 id="3-1-History-of-Intel-processors-and-architectures"><a href="#3-1-History-of-Intel-processors-and-architectures" class="headerlink" title="3.1 History of Intel processors and architectures"></a>3.1 History of Intel processors and architectures</h2><ul><li><p>什么是 Intel 的 x86-64？</p><blockquote><p>x86 是指 Intel 自己的 x86 processors，因为 Intel 这个系列的第一张处理器芯片的代号是 8086（产于 1978）。</p><p>随着时间推移，这个系列的芯片不断添加特性、升级演进；Intel 自己跳过了 81 系列，推出过 8286、8386系列等，都是以 86 结尾，所以被称为 x86。</p><p>后面的 64 表示这是 64-bits 的机器；</p></blockquote></li><li><p>什么是 <code>CISC</code> 和 <code>RISC</code>？</p><ul><li>Reduced Instruction Set Computer（<code>RISC</code>，精简指令集计算机）：一类装备改良的机器指令集的计算机，思想较新；</li><li>Complex Instruction Set Computer（<code>CISC</code>，复杂指令集计算机）：在 <code>RISC</code> 出现后，<code>RISC</code> 开发者把之前的使用旧指令集的计算机统称为 <code>CISC</code>，所以这个概念出现在本体之后，带有贬义；</li></ul><blockquote><p>Intel 采用的是 <code>CISC</code>，CSAPP 中介绍的这方面的知识还是不全面，想要进一步了解 <code>CISC</code> 需要自己阅读 <code>CISC</code> 手册；</p></blockquote></li><li><p>Intel 芯片的进化</p><ul><li><p>8086: 1978, 5-10 MHz;</p><blockquote><p>First 16-bit Intel processor.</p><p>1 MB Address space.</p></blockquote></li><li><p>386: 1985, 16-33 MHz</p><blockquote><p>First 32-bit Intel processor, referred to as IA32（Intel Architecture 32），占据了极大市场份额；<strong>现在不教它了，因为有更新的 x86-64</strong>;</p><p>Added “flat addressing”，capable of running <strong>UNIX</strong>；</p></blockquote></li><li><p>Pentium 4E（奔腾 4E）: 2004, 2800-3800 MHz</p><blockquote><p>First 64-bit Intel x86 processor, referred to as x86-64;</p><p><strong>收到了产品反馈：性能功耗问题，发热严重，不能无限制增加处理器时钟频率</strong>，开始着手多核处理器（一个芯片上放多个独立处理器）；</p></blockquote></li><li><p>Core 2: 2006, 1060-3500 MHz</p><blockquote><p>First multi-core Intel processor;</p></blockquote></li><li><p>Core i7: 2008, 1700-3900 MHz</p><blockquote><p>Four cores processor;（至今性能也不错）</p></blockquote></li></ul></li><li><p>什么是缓存？<strong>大致定义是 a temporary memory used to hold the most recently accessed data</strong>;</p></li><li><p>2015 年的 Intel 芯片架构</p><p><img src="imgs/chip_in_2015.png" height="400"></p><ul><li><code>DDR</code> 接口是连接到主存储器（DRAM，Dynamic Random Access Memory）的通道；</li><li><code>PCI</code> 接口是与外围设备（peripheral devices）的连接通道；</li><li><code>SATA</code> 接口是与不同类型硬盘的连接通道；</li><li><code>Ethernet</code> 接口是网络接口；</li></ul><blockquote><p>结论：集成到单个芯片上的不仅仅是处理器本身，还有很多逻辑单元所组合起的有机整体；</p></blockquote></li><li><p>Intel 的竞争对手：AMD（Advanced Micro Devices）</p><ul><li>总是跟在 Intel 后面发展，同级别的芯片稍微有点慢，但便宜的多；</li></ul></li><li>什么是 ARM？<ul><li>除了 Intel 公司的 x86 类型的处理器，当前常用的、比较主流的另一类处理器是 ARM（Acron RISC Machine），CSAPP 不会深入涉及；</li><li>创造这种处理器及其对应指令集（RISC）的原公司已经破产，但指令集写的很棒，能自定义，功耗比同水准的 x86 处理器更低。</li><li>所以后继者建立了一个公司，但这个公司不销售处理器，只向众多公司销售 ARM 的设计许可权。因此，ARM 处理器是很多芯片厂商（尤其 Intel）生产的芯片的<strong>一部分</strong>，因为 ARM 的优势而被用在方方面面；</li></ul></li></ul><h2 id="3-2-C-Assembly-Machine-code"><a href="#3-2-C-Assembly-Machine-code" class="headerlink" title="3.2 C, Assembly, Machine code"></a>3.2 C, Assembly, Machine code</h2><blockquote><p>本节只是概述一下整个 C、汇编语言、机器语言的<strong>产生过程</strong> 和 <strong>宏观样貌</strong>。</p><p>具体对汇编代码的学习内容在下一节。</p></blockquote><h2 id="3-2-1-Definitions"><a href="#3-2-1-Definitions" class="headerlink" title="3.2.1 Definitions"></a>3.2.1 Definitions</h2><ul><li><strong>Architecture (also ISA: Instruction Set Architecture)</strong>: The <strong>parts</strong> of a processor design that  one needs to understand or write assembly/machine code.<ul><li>架构是处理器设计的一部分。开发硬件的人员在考虑设计机器和对应机器语言的时候，想到了将 “指令集架构” 这层抽象出来。<strong>例如针对某个寄存器，特定的指令集等</strong>，相当于驱动硬件的接口，将<strong>微架构</strong>和机器码隔离开。这样，硬件设计者只需要关心微架构，上层的设计者需要关注机器语言以及更抽象的语言就行。</li><li>开发人员需要了解，以此来编写对应的汇编码、机器语言，以至对应平台的编译器；</li><li>examples:<ul><li>Intel: x86, IA32, Itanium, x86-64;</li><li>ARM: (Name is itself) Used in almost all mobile phones.</li></ul></li></ul></li><li><strong>Microarchitecture: Implementation of the architecture.</strong><ul><li>例如：缓存大小设计、内核频率设计。CSAPP 中也涉及的很少；</li></ul></li><li>Code Form<ul><li>Machine Code: The byte-level programs that a processor executes;</li><li>Assembly Code: A text representation of machine code.</li></ul></li></ul><h2 id="3-2-2-Assembly-Machine-Code-View"><a href="#3-2-2-Assembly-Machine-Code-View" class="headerlink" title="3.2.2 Assembly/Machine Code View"></a>3.2.2 Assembly/Machine Code View</h2><ul><li><p>Programmer-Visible State（在机器语言中需要开发者了解、操作的一些量，含有与真实硬件相关的细节）：</p><ul><li><p>PC (Program Counter, 程序计数器)</p><ol><li>Get the address of next instruction;</li><li>Called “RIP” (in x86-64);</li></ol></li><li><p>Register file: <strong>Heavily used program data</strong>（汇编程序中绝大多数数据存放的位置）;</p></li><li><p>Condition Codes（状态代码，存放于<strong>状态寄存器</strong>）</p><ol><li>存储绝大多数当前最近的算数/逻辑运算的状态信息；</li><li>数据用来判断状态分支；</li></ol></li><li><p>Memory</p><ol><li>由地址组织的 byte 数组，<strong>实际上是用一种不同方式（这个实现的方式以后的章节会详细介绍）实现的虚构对象，完成操作系统和硬件间的协作，因此称为虚拟内存（Virtual Memory）</strong>，所以这使得虽然内存（硬件上实际的内存又称为<strong>物理内存，Physical Memory</strong>）在硬件上可能是零碎的，但汇编开发者看起来的却是一大块可以按地址成块使用的。每个程序都有自己独立的字节数组来访问数据。</li><li>存放代码、用户信息；</li><li>使用堆栈数据结构来支持步骤；</li></ol><blockquote><p>这里解释一下经常提到的<strong>缓存（Cache）</strong>，缓存是指一个动作，就是将最近访问的数据存储到<strong>高速缓存器</strong>（I/O 远快于普通寄存器和外存储器，但造价高，所以容量小）中。下一次访问<strong>相同</strong>数据时，会直接进入高速缓存器中，速度会更快。</p><p>但是<strong>“缓存”</strong>这个动作对汇编开发者而言<strong>也是不可见（invisible）的</strong>，这是写在硬件中的动作（前面说的 microarchitecture），即使在汇编层面也没有专门的指令，无法操作。</p></blockquote></li></ul></li><li><p>C 代码如何转变为 <code>Object Code</code></p><ul><li>在 GNU Tutor 中曾经介绍过从源文件到目标文件的过程；</li><li><strong>C 源文件（*.c, text）</strong> <u>编译器（compiler, C 一般用 gcc）</u>编译为 <strong>ASM 源文件（*.s, text）</strong>，再交给<u>汇编器（assembler，一般用 gcc/as）</u> 汇编为 <strong>目标文件（*.o, binary）</strong>，最后交给<u>链接器（linker，一般用 gcc/ld）</u> 链接用到的第三方静态库，最终变为可执行文件；</li><li>剩余还有一部分是动态链接库，要么自己写并且编译，放置在指定位置，要么用的是系统环境中的库，在程序运行时动态加载。</li></ul></li><li><p>举例说明：下面以一个简单的 C 程序为例，演示其汇编代码及含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: sum.c</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">plus</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sumstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = plus(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">long</span> y = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">long</span> z;</span><br><span class="line">    sumstore(x, y, &amp;z);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld + %ld --&gt; %ld\n&quot;</span>, x, y, z);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在运行 <code>gcc -Og -S sum.c</code>。</p><ul><li><code>-Og</code> 参数是较新的参数，与 <code>-On</code>（n=0，1，2，3） 优化不一样，为开发人员提供了易读的中间汇编码；另外，如果不加 <code>-O</code> 参数，就什么都不优化，那么代码同样难以阅读；</li><li><code>-S</code> 参数意味着 <code>gcc</code> 套件将仅运行到产生汇编代码（<code>*.s</code>）就停止；</li></ul><p>找到代表 <code>sumstore</code> 函数的 asm 代码，以函数名 + 冒号开头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sumstore:</span><br><span class="line">    pushq%rbx</span><br><span class="line">    .seh_pushreg%rbx</span><br><span class="line">    subq$32, %rsp</span><br><span class="line">    .seh_stackalloc32</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    movq%r8, %rbx</span><br><span class="line">    callplus</span><br><span class="line">    movl%eax, (%rbx)</span><br><span class="line">    addq$32, %rsp</span><br><span class="line">    popq%rbx</span><br><span class="line">    ret</span><br><span class="line">    .seh_endproc</span><br><span class="line">    .def__main;.scl2;.type32;.endef</span><br><span class="line">    .section .rdata,&quot;dr&quot;</span><br></pre></td></tr></table></figure><p>这里注意开头含有 <code>.</code> 的操作<strong>实际不是原先代码的部分，它们与一些其他信息有关</strong>。例如为调试器提供行号的、为链接器提供信息表示全局函数的等等。一开始可以不用太过于在意这些，为了演示方便，这里直接删掉说明，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sumstore:</span><br><span class="line">    pushq%rbx; %rbx 表示访问名为 rbx 的寄存器，pushd 表示数据压入memory栈</span><br><span class="line">    subq$32, %rsp</span><br><span class="line">    movq%r8, %rbx</span><br><span class="line">    callplus; 调用函数名为 plus 的函数</span><br><span class="line">    movl%eax, (%rbx); 移动值</span><br><span class="line">    addq$32, %rsp</span><br><span class="line">    popq%rbx; 将栈中值弹出到 名为 rbx 的寄存器中</span><br><span class="line">    ret; 当前函数结束，返回</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-3-Assembly-Characteristics-Data-Types"><a href="#3-2-3-Assembly-Characteristics-Data-Types" class="headerlink" title="3.2.3 Assembly Characteristics: Data Types"></a>3.2.3 Assembly Characteristics: Data Types</h2><ul><li>“Integer” data of 1,2,4, or 8 bytes（不同的整型数据类型，不区分符号）<ul><li>Data types / Address（untyped pointers）</li></ul></li><li>Floating point data of 4,8, or 10 bytes（浮点数处理方式不同，使用不同的寄存器组，之后详细提）</li><li><strong>在汇编层面不存在聚合结构（aggregate types）</strong>，例如数组、结构体，因为它们是在编译器层面人工设计的，本质上就是连续的一段内存，以后也会实现；</li></ul><h2 id="3-2-4-Assembly-Characteristics-Operations"><a href="#3-2-4-Assembly-Characteristics-Operations" class="headerlink" title="3.2.4 Assembly Characteristics: Operations"></a>3.2.4 Assembly Characteristics: Operations</h2><ul><li>Perform arithmetic function on register or memory data（<strong>算术运算</strong>在存储器上的数据）</li><li>Transfer data between memory and register（在内存和寄存器间<strong>转移数据</strong>）<ul><li>load data from memory to register</li><li>store register data into memory</li></ul></li><li>Transfer control（汇编代码<strong>流程控制</strong>）<ul><li>Unconditional jumps to/from procedures</li><li>Conditional branches</li></ul></li></ul><h2 id="3-2-5-Assembling-amp-Disassembling-Object-Code-At-first-glance"><a href="#3-2-5-Assembling-amp-Disassembling-Object-Code-At-first-glance" class="headerlink" title="3.2.5 Assembling &amp; Disassembling Object Code: At first glance"></a>3.2.5 Assembling &amp; Disassembling Object Code: At first glance</h2><p><strong>先来看 C code 到 汇编语言/机器语言的过程</strong>。</p><p>当汇编代码被 assembler（汇编器）汇编为目标代码时，这时所能看到的就只有二进制序列了。接下来还以之前的 <code>sum.c</code> 中的 <code>sumstore</code> 函数为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x0400595:    # 表示本函数段从 0x0400595 处开始</span><br><span class="line">    0x53# 每一条指令长为 1/3/5 bytes，整段函数的长度为 14 bytes</span><br><span class="line">    0x48</span><br><span class="line">    0x89</span><br><span class="line">    0xd3</span><br><span class="line">    0xe8</span><br><span class="line">    0xf2</span><br><span class="line">    0xff</span><br><span class="line">    0xff</span><br><span class="line">    0xff</span><br><span class="line">    0x48</span><br><span class="line">    0x89</span><br><span class="line">    0x03</span><br><span class="line">    0x5b</span><br><span class="line">    0xc3</span><br></pre></td></tr></table></figure><p>这里每条指令只做一件事。以 <code>sumstore</code> 函数中的一个语句为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*dest = t;    <span class="comment">/* Store value t where designated by dest. */</span></span><br><span class="line">            <span class="comment">/* 这里加信号的含义是取 dest 所指向的地址 */</span></span><br></pre></td></tr></table></figure><p>对应这条汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq %rax, (%rbx)</span><br></pre></td></tr></table></figure><p>对应这条目标代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x40059e:    48 89 03</span><br></pre></td></tr></table></figure><p>这里 <code>t</code> 或某些 local variables 会存储于寄存器中（例如上面表示它在寄存器 <code>%rax</code> 中），而 <code>dest</code> 指针值自己也被存储于寄存器中（上面表示 <code>dest</code> 自身的值存于 <code>%rbx</code> 中）；</p><p>这里的 <code>(%rbx)</code> 表示 <code>Memory[%rbx]</code>，即 <code>%rbx</code> 值所代表的地址在 <code>Memory</code> 中的位置；</p><p><code>mov A, B</code> 指令就是将值从 A 处移动到 B 处。上面的汇编语句连起来就是：<strong>将存放于 <code>%rax</code> 中的值移动到 <code>%rbx</code> 所代表 Memory 地址的位置上</strong>；</p><p>根据汇编器翻译，这条指令只用了 3 bytes 来编码：<code>48 89 03</code>；</p><hr><p><strong>再来看机器语言到汇编语言的反汇编过程（disassembling）</strong>。</p><p>反汇编的实现和汇编一样，后者是将文本版本（汇编代码）转换为字节码（机器代码）的形式表示，前者将字节码对应解释成易读的文本即可。</p><p>如果当前没有源文件，甚至没有汇编代码，那么可以由<strong>反汇编器（disassembler）</strong>来将目标代码（*.o）<strong>或者</strong>可执行程序（已链接库的目标代码）转换成汇编代码（*.s）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d <span class="built_in">sum</span> &gt; sum.d <span class="comment"># 反编译之前的 sum 程序，-d 将可执行部分反汇编显示到 stdout</span></span><br></pre></td></tr></table></figure><p>值得注意的是，在汇编代码的层次下，<strong>无法</strong>再向上还原到源文件（*.c），因为其中的函数/变量名、都在汇编过程丢失了，只剩下一些寄存器的名称和 Memory 地址。</p><p>上面使用 <code>objdump</code> 可以得到真正意义上的汇编代码（从机器代码转换而来），此外还有一种方法：使用 <code>gdb</code>。</p><p>如果使用 <code>gdb</code> 打开目标可执行文件，运行 <code>disassemble &lt;funcName&gt;</code> 就可以对可执行文件中对应的函数区域进行反汇编。但只显示这些指令的地址 + 翻译指令，不显示字节级的编码。</p><h2 id="3-3-Assembly-Basics"><a href="#3-3-Assembly-Basics" class="headerlink" title="3.3 Assembly Basics"></a>3.3 Assembly Basics</h2><h2 id="3-3-1-The-names-for-integer-registers"><a href="#3-3-1-The-names-for-integer-registers" class="headerlink" title="3.3.1 The names for integer registers"></a>3.3.1 The names for integer registers</h2><p>下面列举 x86-64 architecture 的 <strong>整数型寄存器（Integer Register）</strong>。</p><p><img src="imgs/registers_in_x86_64.png" height="400px"></p><p>如图，这些寄存器共有 16 个，名字大致分为 2 类，一类是字母表示的（ax/bx/…），另一类是数字表示的（8/9/…）。</p><p>目前一个 x86-64 架构的 integer register 总大小有 64-bit。鉴于对以前 32-bit 机器和程序的向前兼容（backwards compatibility），汇编语言允许使用一个寄存器的<strong>不同部分</strong>，怎么用取决于指令。</p><p>对于字母类名称的寄存器（如上图左），如果使用<strong>前缀 <code>%r</code></strong>（例如 <code>%rax</code>），那么这个整型寄存器将保存 <strong>64-bit</strong> 大小的整型数据（即使用全部空间）；如果使用<strong>前缀 <code>%e</code></strong>（例如 <code>%eax</code>），那么这个整型寄存器将保存 <strong>32-bit</strong> 大小的整型数据（即从低位开始使用 32 bits，又称为 <strong>low-order 32-bit</strong>）。</p><p>对于数字类名称的寄存器（如上图右），前缀必须是 <code>%r</code>。如果不加后缀，表示保存 <strong>64-bit</strong> 大小的整型；如果使用<strong>后缀 <code>d</code></strong>，那么将保存 <strong>32-bit</strong> 大小的整型。</p><p>在这些寄存器中，可以使用指令存取数据，<strong>而且这些是机器级编程，和具体机器的型号密切相关，每步即必须清楚指出从哪个寄存器到哪个寄存器</strong>。</p><p>在 x86-64 架构下，最常见的是 64-bit register 的使用，其次是 low-order 8-bit 的使用（用在条件控制中，这个会在下一章介绍）。因此，除非提及，下面默认的 register 全部是以 <code>%r</code> 为前缀的 16 个寄存器。</p><hr><p>下面补充一些历史信息，帮助理解这些寄存器奇怪的（quirky）名字：</p><p>在早期 IA32 架构下 32-bit 处理器只用到了 8 个寄存器，它们的名字分别是：</p><p><code>%eax</code>、<code>%ecx</code>、<code>%edx</code>、<code>%ebx</code>、<code>%esi</code>、<code>%edi</code>、<code>%esp</code>、<code>%ebp</code>（都是 <code>%e</code> 前缀,意味着存 32-bit 整型）</p><p>此位，这些寄存器还能引用 <strong>low-order 16-bits</strong>（它们是最开始出现的 16-bit 寄存器，没有 <code>e/r</code> 前缀，引用的名称为 <code>%ax</code>、<code>%cx</code>、<code>%bx</code>……），甚至是 <strong>low-order 8-bits 和 high-order 8-bits</strong>（分别是 <code>%al</code> 和 <code>%ah</code> 等，如下图）。这里不讲述这些旧版本机器的低位寄存器位置的操作指令，不过在下一章会提到操作 <strong>low-order 8-bits</strong> 的操作指令，因为会涉及汇编条件控制。</p><p><img src="imgs/IA32_registers.png" height="350px"></p><p>很早以前，各个寄存器的名字有特定含义，代表它们的目的。例如 <code>a</code> 代表 accumulate，<code>c</code> 代表 counter，<code>d</code> 代表 data，<code>b</code> 代表 base，<code>si</code> 代表 source index，<code>di</code> 代表 destination index，<code>sp</code> 代表 stack pointer，<code>bp</code> 代表 base pointer。</p><p>现在这些寄存器就是普通的存取数据的结构，名字也就没有特定的含义了——<strong>除了名字是 <code>sp</code> 的寄存器</strong>。它在目前的 x86-64 架构中也有一个非常具体的目的，就是上面说的，stack pointer，<strong>栈指针</strong>。</p><p>至于后面数字表示的寄存器，<strong>是后来从 IA32 架构升级到 64 位（x86-64）时，芯片可以在一个时钟周期处理 64-bit 的数据了，旧的寄存器设计不够用了，所以新添加上去的，因为没有特定用途，就以数字进行命名</strong>。</p><p>⚠ 说是没什么“特殊用途”，但还是有约定俗成的使用方法的！</p><p>例如，这些寄存器分为 “<strong>Callee-Saved Register</strong>” 和 “<strong>Caller-Saved Register</strong>”。</p><p>其中，Callee-Saved Register 是由<strong>被调用方保管使用的</strong>寄存器，数据内容只会在被调方的函数内有效、有意义。属于这类的寄存器有：<code>%rbx</code>、<code>%r12-14</code>、<code>%rbp</code> 和 <code>%rsp</code>，后两者是有特殊含义的，前面的寄存器是供被调方存储临时数据（Temporaries）；</p><p>Caller-Saved Register 是<strong>调用方保管使用的</strong>寄存器，它的作用大多数是沟通调用方和被调方的数据信息。例如 <code>%rax</code> 一般存放返回值，<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rcx</code>、<code>%r8</code>、<code>%r9</code> 依此存放调用函数的第 1 ~ 第 6 参数；<code>%r10</code>、<code>%r11</code> 供存储调用方临时数据。</p><p>在下面的部分中，你会一遍遍加深对这个说法的印象的。上面的内容在第五章会进一步提及。</p><p>至于为什么要有 Callee-Saved 和 Caller-Saved Register，这也会在 5.4 中详细说明。</p><hr><h2 id="3-3-2-Move-Operands-and-usage"><a href="#3-3-2-Move-Operands-and-usage" class="headerlink" title="3.3.2 Move, Operands, and usage"></a>3.3.2 Move, Operands, and usage</h2><p>接下来介绍整型寄存器在汇编代码中的使用。</p><h3 id="Moving-Data-Command-movq-lt-SrcR-gt-lt-DstR-gt"><a href="#Moving-Data-Command-movq-lt-SrcR-gt-lt-DstR-gt" class="headerlink" title="Moving Data Command: movq &lt;SrcR&gt;, &lt;DstR&gt;"></a>Moving Data Command: <code>movq &lt;SrcR&gt;, &lt;DstR&gt;</code></h3><blockquote><p>为什么命令名中有 “q” ？因为在 Intel 公司设定中，q 代表 quad，是 4 个字，而在 8086 系列中，1 个字被约定为 16 bits（2 bytes），所以 <strong><code>movq</code> 指令操作的必须是 64 bits 的寄存器</strong>；</p><p>⚠ <strong>另外请格外注意，Intel 和 Microsoft 使用的 x86-64 架构的汇编语言的这些参数和 Linux 使用的 x86-64 架构的参数顺序不一样！CSAPP 教授的指令语法按照 Linux 来，请不要弄错！不要在 Windows 环境下尝试这些指令！</strong></p></blockquote><h3 id="Operands"><a href="#Operands" class="headerlink" title="Operands"></a>Operands</h3><ul><li><p>Immediate（数据直接量，例如常量整型）: <strong>定义和 C 语言一样，但是需要加上前缀 <code>$</code></strong>;</p><blockquote><p>例如：<code>$0x400</code>、<code>$-523</code> 等等；</p></blockquote></li><li><p>Register Name: 16 个中任意一个整型寄存器的名称。</p><blockquote><p><strong>注意：保留作其他用途的寄存器也不应该被手动使用。前面说了，例如在 x86-64 架构中，<code>%rsp</code> 保留做特殊用途</strong>，因为栈中保存其他重要的状态信息，只能由机器内部进行修改。</p></blockquote></li><li><p>Memory: <strong>8 consecutive bytes</strong> of memory <strong>at address</strong> given by registers.</p></li><li><p><strong>汇编代码简单访问 Memory 的方法</strong>：</p><ul><li><p>法 1: Normal <code>(%&lt;registerName&gt;)</code></p><p>即保存在寄存器中的、8 bytes 连续的地址数据对应的 memory 位置。</p><p><strong>也就是说，当把寄存器名称放在括号里时，就是表示把寄存器中数据看作 memory 地址（无论是什么），并用这个地址来引用对应的内存位置</strong>。</p><p>例如：<code>(%rax)</code> 就是代表取存放在 <code>%rax</code> 寄存器中的数据对应 memory 位置的引用；</p><p><u>请牢牢记住</u>，这种在括号内找地址的形式被称为 <strong>Simple Memory Addressing Modes</strong>（简单内存寻址模式），表示这个模式下，寄存器被看作指针，括号相当于取地址并找到 memory 对应的引用。</p></li></ul></li></ul><ul><li><p>法 2: Displacement <code>&lt;D&gt;(%&lt;registerName&gt;)</code></p><p>即保存在寄存器中的、8 bytes 连续的地址对应 memory 的某个位置，以这个位置为基准，向后偏移 <code>D</code> 个 bytes 所对应的内存位置的引用。</p><p>例如：<code>8(%rbp)</code> 就是代表取存放在 <code>%rbp</code> 寄存器中的数据向后偏移 <code>D</code> 个 bytes 的位置对应 memory 的引用；</p></li></ul><ul><li><p><strong>法 3: Most General Form <code>D(&lt;Rbase&gt;, &lt;Rindex&gt;, &lt;Scale&gt;)</code></strong></p><p>等价于 <code>Memory[Reg[Rb] + S * Reg[Ri] + D]</code>，指使用寄存器 <code>Rb</code> 中的数据为基，加上 <code>S</code> 倍率的寄存器 <code>Ri</code> 中的数据（<strong>因此 <code>S</code> 只取 1，2，4，8 这几个之一</strong>），最后总体偏移 <code>D</code> bytes；</p><p><strong>注意，<code>Ri</code> 不建议为寄存器 <code>%rsp</code></strong>;</p><p><strong>法 3 就是原始意义上的数组自然引用的方式</strong>；</p><p>可以思考为什么 <code>S</code> 只取 1、2、4、8 中的一个。原因很简单，这和它存在的意义有关。我们想在引用数组时，<strong>一定希望根据数据类型来缩放索引值</strong>，例如 <code>int</code> 需要缩放 4 倍（4 bytes），<code>long</code> 需要缩放 8 倍；小于这些数，则会导致数据错误，大于这些数据会导致空间浪费。</p></li></ul><ul><li><p>Rules：以上有些 operand 的组合是不允许的。例如：</p><ul><li>直接量作为 destination，没有意义；</li><li>为了方便硬件设计，不允许直接从一个内存位置复制到另一个内存位置，必须 2 步：从内存存入指定寄存器，再由指定寄存器存入另一块内存（<strong>内存到内存必须经过寄存器</strong>）；</li></ul></li><li><p>Examples：</p><ul><li><p>例如 <code>movq $0x4,%rax</code> 可能对应的就是 <code>tmp = 0x4;</code></p></li><li><p>例如 <code>movq $-147,(%rax)</code>可能对应 <code>*p = -147;</code></p></li><li><p>例如 <code>movq %raw,%rdx</code> 可能对应 <code>tmp2 = tmp1;</code></p></li><li><p>例如 <code>movq $rax,(%rdx)</code> 可能对应 <code>*p = tmp;</code></p></li><li><p>例如 <code>movq (%rax),%rdx</code> 可能对应 <code>tmp = *p;</code></p></li><li><p>例如假设下面这段程序可能的汇编代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t0 = *xp;</span><br><span class="line">    <span class="type">long</span> t1 = *yp;</span><br><span class="line">    *xp = t1;</span><br><span class="line">    *yp = t0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">swap:</span><br><span class="line">    movq(%rdi), %rax</span><br><span class="line">    movq(%rsi), %rdx</span><br><span class="line">    movq%rdx, (%rdi)</span><br><span class="line">    movq%rax, (%rsi)</span><br><span class="line">    ret; 回到之前调用 swap 函数的位置，结束当前函数执行</span><br></pre></td></tr></table></figure><p><strong>在上面这个函数体中，<code>%rdi</code> 是保存第一个参数的寄存器，<code>%rsi</code> 是第二个参数寄存器，最多用 6 个</strong>，这是在执行此函数前就设置好的。剩下寄存器的选择是由编译器自己决定的，每次编译都可能不太一样；</p></li></ul></li><li><p>Exercises: Address Computation Examples（根据信息填写下表）</p><p>已知寄存器 <code>%rdx</code> 存放数据 0xf000，寄存器 <code>%rcx</code> 存放数据 0x0100。</p><table>    <tr style="text-align: center;">        <th>Expression</th>        <th>Address Computation</th>        <th>Address</th>    </tr>    <tr>        <td>0x8(%rdx)</td>        <td></td>        <td></td>    </tr>    <tr>        <td>(%rdx,%rcx)</td>        <td></td>        <td></td>    </tr>    <tr>        <td>(%rdx,%rcx,4)</td>        <td></td>        <td></td>    </tr>    <tr>        <td>0x80(,%rdx,2)</td>        <td></td>        <td></td>    </tr></table><p>第一行，就是普通 displacement，<code>0xF000 + 0x8 = 0xF008</code>;</p><p>第二行，省略的 general displacement，<code>0xF000 + 0x0100 = 0xF100</code>;</p><p>第三行，省略的 general displacement，<code>0xF000 + 4 * 0x0100 = 0xF400</code>;</p><p>第四行，省略的 general displacement，<code>0 + 2 * 0xF000 + 0x80 = 0x1E080</code>;</p></li></ul><h2 id="3-3-3-Arithmetic-amp-logical-operations"><a href="#3-3-3-Arithmetic-amp-logical-operations" class="headerlink" title="3.3.3 Arithmetic &amp; logical operations"></a>3.3.3 Arithmetic &amp; logical operations</h2><h3 id="Address-Computation-Instruction-leaq-lt-Src-gt-lt-Dst-gt"><a href="#Address-Computation-Instruction-leaq-lt-Src-gt-lt-Dst-gt" class="headerlink" title="Address Computation Instruction: leaq &lt;Src&gt;, &lt;Dst&gt;"></a>Address Computation Instruction: <code>leaq &lt;Src&gt;, &lt;Dst&gt;</code></h3><blockquote><p>指令含义：load effective address（加载有效地址）；</p><p>指令目标（很抽象，等会慢慢解释）：<strong>相当于 C 的 <code>&amp;</code>（ampersand）符号来计算地址</strong>，基于想要计算的地址的一些内容（一般是指定内存引用）。<strong>同时也作为一种非常方便的算术运算方式</strong>。</p><p>指令的大致过程：通俗来说就是<strong>传入的内存引用 <code>Src</code>，<code>leaq</code> 会找到这个引用的地址值，并把这个地址传给 <code>Dst</code></strong>，最后 <code>Dst</code> 的值是 <code>Src</code> 引用的地址，相当于 <code>Dst</code> 变成了指针，指向了 <code>Src</code>；</p><p><code>Dst</code> 参数<strong>必须是寄存器名称</strong>，不能是直接量、内存引用；</p><p><code>Src</code> 参数<strong>必须是内存引用</strong>，<strong>允许使用之前的 Simple Memory Addressing Mode</strong>，不能是直接量、寄存器名称；</p></blockquote><p>下面举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">m12</span><span class="params">(<span class="type">long</span> x)</span> &#123; <span class="keyword">return</span> x * <span class="number">12</span>; &#125;</span><br></pre></td></tr></table></figure><p>上面的函数对应的汇编代码可以是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m21:</span><br><span class="line">    leaq (%rdi,%rdi,2), %rax</span><br><span class="line">    salq $2, $rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>首先解释 <code>(%rdi,%rdi,2)</code>，这是上面要求记住的 <strong>Simple Memory Addressing Mode</strong>，它代表，把 <code>%rdi</code>（即这里存放函数第一参数 <code>x</code> 的寄存器）中的内容看成地址，进行一个 general displacement：<code>%rdi 的值 + 2 * %rdi 的值</code>，这里<strong>巧妙地完成了找到 3 倍的 <code>%rdi</code> 的值，把它作为索引，其对应的 memory 地址引用</strong>（注：这个地址很可能<strong>不能</strong>被程序使用，这里只是借助它进行算术计算）；</p><p>然后 <code>leaq</code> 将第一参数（3 倍 <code>%rdi</code> 值索引所对应 memory 的引用位置）<strong>对应的地址</strong>赋给了 <code>%rax</code> 寄存器。<strong>到此为止，<code>%rax</code> 中成功获得了 <code>%rdi</code> 中的 3 倍值，中间的方法虽然用到了指针的概念，但本质不是指针操作，是算数操作</strong>（慢慢领悟吧）。</p><p>最后使用的 <code>salq</code> 指令很简单，就是底层的移位指令（在后面介绍），将 <code>%rax</code> 的二进制值向左移动 2 位，相当于 × 4，总的来说 <code>%rax</code> 的值就相当于原来 <code>%rdi</code> 的值 × 12，完成了 × 12 的操作。</p><blockquote><p>有同学可能会问，为什么不全都给 <code>leaq</code> 来计算 × 12 呢？其实移位在效率上会更快一些。一般 C/C++ 程序在乘常数操作时，会被编译器优化，分解出 $2^k$ 的因子，一部分用 <code>leaq</code> 计算，另一部分用 <code>salq</code> 移位。</p></blockquote><h3 id="Some-Arithmetic-Operations"><a href="#Some-Arithmetic-Operations" class="headerlink" title="Some Arithmetic Operations"></a>Some Arithmetic Operations</h3><ul><li><code>addq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst + Src</code></li><li><code>subq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst - Src</code></li><li><code>imulq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst * Src</code></li><li><code>salq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &lt;&lt; Src</code></li><li><code>sarq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &gt;&gt; Src</code>（<strong>算术右移，arithmetic right shift</strong>）</li><li><p><code>shrq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &gt;&gt; Src</code>（<strong>逻辑右移，logical right shift</strong>）</p></li><li><p><code>xorq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst ^ Src</code></p></li><li><code>andq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &amp; Src</code></li><li><code>orq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst | Src</code></li></ul><p><strong>切记，别搞错 operands 的顺序！<code>Src</code> 在前，<code>Dst</code> 在后</strong>；</p><ul><li><code>incq &lt;Dst&gt;</code>：相当于 <code>Dst = Dst + 1</code></li><li><code>decq &lt;Dst&gt;</code>：相当于 <code>Dst = Dst - 1</code></li><li><code>negq &lt;Dst&gt;</code>：相当于 <code>Dst = -Dst</code></li><li><code>notq &lt;Dst&gt;</code>：相当于 <code>Dst = ~Dst</code>（注意是<strong>按位否</strong>）</li></ul><p><strong>还有一部分针对 128 bits 的计算</strong>，先放在这，不急着背，慢慢消化即可：</p><ul><li><p><code>imulq &lt;S&gt;</code>：<strong>默认 <code>%rax</code> 中存放另一个 operand</strong>，<strong>将 <code>S * R[%rax]</code> 的值存放到 <code>R[%rdx]:R[%rax]</code></strong>（high-order 64-bits 由 <code>%rdx</code> 承担，low-order 64-bits 由 <code>%rax</code> 承担）中，<strong>针对 signed 数</strong>；</p><blockquote><p>在 64 位架构下，你会发现 <code>R[%rdx]:R[%rax]</code> 的拼接方法表示 128-bits 数是约定俗成的行为。</p></blockquote></li><li><p><code>mulq &lt;S&gt;</code>：作用与 <code>imulq &lt;S&gt;</code> 相同，不过是对 unsigned 操作；</p></li><li><p><code>idivq &lt;S&gt;</code>：<strong>默认被除数（128-bits）存放在 <code>R[%rdx]:R[%rax]</code>，并与 <code>S</code>（64-bits）进行除法，除数存放在 <code>%rax</code>，余数存放在 <code>%rdx</code></strong>。<strong>针对 signed 数</strong>；</p></li><li><p><code>divq &lt;S&gt;</code>：作用与 <code>idivq &lt;S&gt;</code> 相同，不过是对 unsigned 操作；</p></li><li><p><code>cqto</code>：少见的没有参数的指令。<strong>作用是把 64-bits（quad word，默认存放在 <code>%rax</code>）转为 128-bits（octal word，默认存放在 <code>R[%rdx]:R[%rax]</code>），<u>signed extension</u></strong>；</p></li></ul><p>更多指令请参阅 x86-64 指令手册。</p><hr><p>下面是个 <strong>example</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">arith</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t1 = x + y;</span><br><span class="line">    <span class="type">long</span> t2 = z + t1;</span><br><span class="line">    <span class="type">long</span> t3 = x + <span class="number">4</span>;</span><br><span class="line">    <span class="type">long</span> t4 = y * <span class="number">48</span>;</span><br><span class="line">    <span class="type">long</span> t5 = t3 + t4;</span><br><span class="line">    <span class="type">long</span> rval = t2 * t5;</span><br><span class="line">    <span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arith:</span><br><span class="line">    leaq(%rdi,%rsi), %rax</span><br><span class="line">    addq%rdx, %rax</span><br><span class="line">    leaq(%rsi,%rsi,2), %rdx</span><br><span class="line">    salq$4, %rdx</span><br><span class="line">    leaq4(%rdi,%rdx), %rcx</span><br><span class="line">    imulq%rcx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这里 <code>%rdi</code> 存放了函数第一参数 x，<code>%rsi</code> 存放了函数第二参数 <code>y</code>，<code>%rdx</code> 存放了函数第三参数 <code>z</code>；</p><p>第一步，可以理解为将 <code>%rdi</code> 和 <code>%rsi</code> 值看作地址，找到 <code>%rdi 值 + %rsi 值</code> 对应的 memory 引用，并利用 <code>leaq</code> 将引用代表的地址赋给 <code>%rax</code>，使得 <code>%rax</code> 获得了 <code>%rdi</code> 和 <code>%rsi</code> 值之和的值，<strong>之所以不用 <code>addq</code>，是因为 <code>addq</code>  会把结果加到 <code>Dst</code> 上，但这里显然不想修改任何寄存器中的值，只是想把值给到新的寄存器</strong>（此步对应 <code>long t1 = x + y;</code>，相当于这里 <code>%rax</code> 存的是 <code>t1</code>）；</p><p>第二步，把 <code>%rdx</code> 的值（x）加到 <code>%rax</code> 上，这时的 <code>%rax</code> 存的是 <code>t2</code>（<code>t1</code> 以后不会用了，所以编译器抛弃了，直接用 <code>addq</code> 操作 <code>%rax</code>，这么做可以提升效率，对应 <code>long t2 = z + t1;</code>）；</p><p>第三步、第四步，前面说了好几遍，这里说简单一点，就是把 <code>%rdx</code> （原先存 <code>z</code> 的寄存器，抛弃 <code>z</code> 也是因为之后不用 <code>z</code> 变量了，编译器进行了优化）赋以 3 倍的 <code>%rsi</code> 值，并且把 <code>%rdx</code> 的值乘以 $2^4=16$，总的来说，<code>%rdx</code> 被赋以 48 倍的 <code>%rsi</code>（y）的值，对应 <code>long t4 = y * 48;</code>，这时 <code>%rdx</code> 存放的就是 <code>t4</code> 了；</p><p>第五步，简单说就是 <code>%rcx</code> 被赋以 <code>%rdi 的值（x） + %rdx 的值（t4） + 4</code>，可以看到，这里编译器想尽一切办法，把 <code>long t3 = x + 4;</code> 和 <code>long t5 = t3 + t4;</code> 这步合起来了，整整省下来了一个 <code>t3</code> 的操作，可谓优化到极致。所以，<code>%rcx</code> 存的是 <code>t5</code>；</p><p>最后一步，编译器实在想不到更好的优化方法，只能勉为其难地调用了唯一一次 <code>imulq</code>，把 <code>%rcx</code> 的值（<code>t5</code>）乘到 <code>%rax</code> 上，对应 <code>long rval = t2 * t5;</code>，函数结束，最后存放 <code>rval</code> 的寄存器是 <code>%rax</code>。</p><hr><h1 id="Chapter-4-Machine-Level-Programming-Ⅱ-Control"><a href="#Chapter-4-Machine-Level-Programming-Ⅱ-Control" class="headerlink" title="Chapter 4. Machine Level Programming Ⅱ - Control"></a>Chapter 4. Machine Level Programming Ⅱ - Control</h1><h2 id="4-1-Introduction-to-Condition-Codes"><a href="#4-1-Introduction-to-Condition-Codes" class="headerlink" title="4.1 Introduction to Condition Codes"></a>4.1 Introduction to Condition Codes</h2><h2 id="4-1-1-Processor-State-of-x86-64-partial"><a href="#4-1-1-Processor-State-of-x86-64-partial" class="headerlink" title="4.1.1 Processor State of x86-64, partial"></a>4.1.1 Processor State of x86-64, partial</h2><p>前面介绍过，x86-64 架构具有 16 个寄存器，其中 8 个沿用旧 x86 架构的名称，另外 8 个从 8 ~ 15 命名。可以总结一下，从这些寄存器 / flags 可以看出处理器当前的状态：</p><ul><li><p>Temporary data：除去 <code>%rsp</code> 的所有 15 个寄存器都是处理器运算时存储临时数据的位置；</p></li><li><p>Location of runtime stack：<code>%rsp</code>;（在以后的章节会涉及运行时栈）</p></li><li><p><strong>Location of current code control point</strong>：<code>%rip</code></p><blockquote><p>之前没有见过的寄存器，instruction point，和 <code>%rsp</code> 一样有特殊用途，<strong>可以将它看成程序计数器</strong>。</p><p><strong>它包含了当前正在执行指令的地址</strong>，也不能手动修改，一般是通过获取它的值来进行一些操作；</p><p><strong>它一般由 <code>call</code> 指令 和 <code>ret</code> 指令等修改</strong>；</p></blockquote></li><li><p>Status of recent tests: <strong>Condition Code</strong></p><ul><li>一共 8 种， 现在只说四种，其他的用到再说：<code>CF</code>、<code>ZF</code>、<code>SF</code>、<code>OF</code>;</li><li>它们都是 1-bit flag，不是被直接手动设置，而是根据其他指令操作后的结果进行设置（<strong>implicit setting</strong>）；</li><li>是汇编条件操作的基础；</li></ul></li></ul><h2 id="4-1-2-The-meanings-for-Condition-Codes"><a href="#4-1-2-The-meanings-for-Condition-Codes" class="headerlink" title="4.1.2 The meanings for Condition Codes"></a>4.1.2 The meanings for Condition Codes</h2><ul><li>Single bit register: 这种寄存器不是之前介绍的整型寄存器，它仅存储 1-bit 数据，专门用于存放 condition codes，它们的名称就是对应的 flag 的名称。先介绍其中 4 种的含义：<ul><li><code>CF</code>: Carry Flag (for unsigned, 将两个 unsigned 相加，MSB 的进位)；</li><li><code>SF</code>: Sign Flag (for signed, 当 signed 运算结果的 MSB = 1，说明结果是负值，此位会被置 1);</li><li><code>ZF</code>: Zero Flag (上一个计算结果为 0 时，此位会被置 1。依靠算术指令内部实现);</li><li><code>OF</code>: Overflow Flag (signed 运算溢出的位。<strong>因此可以将 <code>CF</code> 理解为“unsigned 运算溢出的位</strong>”);</li></ul></li><li><strong>注意：之前说的 <code>leaq</code> 不会设置这些 flags</strong>；但之前介绍的算术运算指令会。</li><li><strong>注意2：也有专门利用计算结果值来设置 flags 的指令：<code>compare 和 test</code></strong> (explicit setting)</li></ul><h2 id="4-1-3-Condition-Codes-Explicit-Setting"><a href="#4-1-3-Condition-Codes-Explicit-Setting" class="headerlink" title="4.1.3 Condition Codes: Explicit Setting"></a>4.1.3 Condition Codes: Explicit Setting</h2><h3 id="Compare-cmpq-lt-Src2-Src1-gt"><a href="#Compare-cmpq-lt-Src2-Src1-gt" class="headerlink" title="Compare: cmpq &lt;Src2, Src1&gt;"></a>Compare: <code>cmpq &lt;Src2, Src1&gt;</code></h3><ul><li>作用：几乎和 <code>subq</code> 一样，但不修改结果值，因为它计算 <code>Src1 - Src2</code> 并且不会对 <code>Src1/2</code> 进行任何操作，但会由此设置上面 4 个介绍到的 condition codes；</li><li>内部如何设置 condition codes：主要依据 <code>Src1 - Src2</code> 减法操作。<ul><li><code>CF</code> set if carry out from MSB (used for unsigned comparisons);</li><li><code>ZF</code> set if <code>Src1 == Src2</code>（即 <code>Src1 - Src2</code> 运算结果是否为 0）;</li><li><code>SF</code> set if <code>(Src1 - Src2) &lt; 0</code>（即 <code>Src1 - Src2</code> 运算结果的 sign 位是否为 1）;</li><li><code>OF</code> set if <code>(Src1 - Src2)</code> in two’s complement (signed) overflow（即 <code>(Src1 &lt; 0 &amp;&amp; Src2 &gt; 0 &amp;&amp; (Src1 - Src2) &gt; 0) || (Src1 &gt; 0 &amp;&amp; Src2 &lt; 0 &amp;&amp; (Src1 - Src2) &lt; 0)</code>，用的就是判断 signed 溢出的条件：两个同号 signed 相加为异号，说明正/负溢出）;</li></ul></li></ul><h3 id="Test-testq-lt-Src2-Src1-gt"><a href="#Test-testq-lt-Src2-Src1-gt" class="headerlink" title="Test: testq &lt;Src2, Src1&gt;"></a>Test: <code>testq &lt;Src2, Src1&gt;</code></h3><ul><li>作用：几乎和 <code>andq</code> 一样，但不修改结果值，只计算 <code>Src1 &amp; Src2</code>，并由此设置 condition codes；</li><li>内部如何设置 condition codes：<ul><li><code>ZF</code> set when <code>Src1 &amp; Src2 == 0</code>;</li><li><code>SF</code> set when <code>Src1 &amp; Src2 &lt; 0</code>;</li><li>因为按位且不会导致任何的进位，所以不设置 <code>CF/OF</code>;</li></ul></li><li>和上面的 Compare 相比，Test 指令可以进行一个参数的判断，例如 <code>testq %rax, %rax</code>，也把一个参数写成 mask，例如 <code>testq $0x22, %rax</code>;</li></ul><h2 id="4-1-4-Condition-Codes-Reading"><a href="#4-1-4-Condition-Codes-Reading" class="headerlink" title="4.1.4 Condition Codes: Reading"></a>4.1.4 Condition Codes: Reading</h2><p>前面说完如何设置，现在称述一下如何读取使用。这里一般不允许直接访问 flags 对应的寄存器，而是用一系列的 <code>SetX</code> instructions 来读取并操作。</p><p><code>SetX</code> Instructions 的作用就是<strong>按照当前的 condition codes，来将指定的单个寄存器的单个 byte 设置为 1 或 0</strong>；</p><p><code>SetX</code> Instructions 具体的类型如下：</p><table>    <tr style="text-align: center;">        <th>SetX</th>        <th>Condition</th>        <th>Description</th>    </tr>    <tr>        <td>sete</td>        <td>ZF</td>        <td>Equal/Zero</td>    </tr>    <tr>        <td>setne</td>        <td>~ZF</td>        <td>Not Equal/Not Zero</td>    </tr>    <tr>        <td>sets</td>        <td>SF</td>        <td>Negative</td>    </tr>    <tr>        <td>setns</td>        <td>~SF</td>        <td>Nonegative</td>    </tr>    <tr>        <td>setg</td>        <td>~(SF^OF)&amp;~ZF</td>        <td>Greater (signed)</td>    </tr>    <tr>        <td>setge</td>        <td>~(SF^OF)</td>        <td>Greater or Equal (signed)</td>    </tr>    <tr>        <td>setl</td>        <td>(SF^OF)</td>        <td>Less (signed)</td>    </tr>    <tr>        <td>setle</td>        <td>(SF^OF) | ZF</td>        <td>Less or Equal (signed)</td>    </tr>    <tr>        <td>seta</td>        <td>~CF &amp; ~ZF</td>        <td>Above (unsigned)</td>    </tr>    <tr>        <td>setb</td>        <td>CF</td>        <td>Below (unsigned)</td>    </tr></table><blockquote><p><code>SetX</code> Instructions 都有唯一参数（<strong>语法 <code>setX &lt;Dst&gt;</code></strong>），要求是单个寄存器的 low-order 8-bit 的引用名称，这是由这条指令的作用决定的。</p></blockquote><p>看上面的表，就解释一个。以 <code>setl</code> 为例，因为大多数时候我们使用 <code>cmpq</code> 对 condition codes 进行设置，所以当 <code>SF</code> 为 1 时，很可能是 <code>Src1 - Src2 &lt; 0</code> 的情况。但是需要排除 <code>Src1 - Src2</code> 正溢出的情况——正溢出也可能导致结果为负，因此是 <code>SF ^ OF</code>；</p><p>最后还有一个问题。<code>setX</code> 是为单个寄存器的<strong>单个 low-order 8-bit 设置 0/1</strong>，但之前<strong>在 3.3.1 中明确说过</strong>，我们在 x86-64 架构下一般都讨论 64-bit register 的使用，而那些访问寄存器的 low-order 32-bit（例如 <code>%eax</code>）、low-order 16-bit 的方法用的比较少（在 32 位架构下会多一点）。</p><p>而这里，为了条件控制，我们必须访问 64-bit register 的 low-order 8-bit 的位置，这些位置可以由以下名称给出：</p><ul><li>字母类型命名的 register，不使用前缀 <code>r</code>，而使用后缀 <code>l</code> 就能代表对应的 low-order 8-bit 位置；例如：<code>%rax</code> 的 low-order 1-bit 位置是 <code>%al</code>、<code>%rbx</code> 是 <code>%bl</code>、<code>%rcx</code> 是 <code>%cl</code>、<code>%rdx</code>是 <code>%dl</code>、<code>%rsi</code> 是 <code>%sil</code>、<code>%rdi</code> 是 <code>%dil</code>、<code>%rsp</code> 是 <code>%spl</code>、<code>%rbp</code> 是 <code>%bpl</code>；</li><li>数字类型命名的 register，使用后缀 <code>b</code> 就代表对应的 low-order 8-bit 位置；例如 <code>%r8b</code>、<code>%r15b</code> 等；</li></ul><p>这样操作 64-bit integer register 的 low-order 8-bit，不会影响到其他位的信息；</p><hr><p>下面是 <strong>example</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gt</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br></pre></td></tr></table></figure><p>其对应的汇编代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gt:</span><br><span class="line">    cmpq%rsi, %rdi</span><br><span class="line">    setg%al</span><br><span class="line">    movzbl%al, %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>已知 <code>%rdi</code> 存放了函数的第一参数 x 的值，<code>%rsi</code> 存放了函数第二参数 y 的值，函数返回的结果就放在 <code>%rax</code> 中。下面逐步分析：</p><p>第一步使用了 <code>cmpq</code> 将 <code>%rdi 值 - %rsi 值</code>（即 <code>x - y</code>）计算，并为 4 个 condition codes 进行修改；</p><p>第二步，<code>setg</code> 对 <code>%al</code> 操作，这是 <code>%rax</code>  的 low-order 8-bit 的位置，表明如果 <code>~(SF ^ OF) &amp; ~ZF</code> 成立，即 <code>x &gt; y</code> 成立，那么为 <code>%rax</code> 的 low-order 8-bit 位置置为 1，否则置为 0；<strong>显然，这里的 <code>%rax</code> 还需要把前面 7 bytes 全部置为 0，才能成为我要返回的值（(int)0/1）</strong>，我们应该怎么做呢？</p><p>第三步用到了新的指令 <code>movzbl</code>（<strong>move with zero extension byte to long</strong>）</p><blockquote><p>语法：<code>movzbl &lt;Src&gt;, &lt;Dst&gt;</code>;</p><p>作用：把一个 <code>Src</code> 数据引用大小的 <strong>0 数据</strong> 扩展到 <code>Dst</code> 中（会改变 <code>Dst</code>，但不会改变 <code>Src</code>）;</p></blockquote><p>那么好，问题又来了，为什么我们明明要把 <code>%rax</code> 剩下的所有 7 bytes 全部置 0，但是汇编中写的却是对 <code>%eax</code>（之前提到的，register 的 low-order 32-bit 位置）置 0，剩下的 high-order 32-bit 不管了吗？</p><p>⚠ 实际上，这是 x86-64 架构内部令人迷惑的特性。当一个 64-bit register 从 low-order 只被修改 32-bit 数据时，<strong>会自动将剩下的 high-order 32-bit 全部置 0</strong>。（但是如果只是修改 low-order 16-bit、low-order 8-bit 时，却<strong>不会</strong>为前面的部分置 0）</p><p>到此为止，<code>%rax</code> 中的数据应该长这样：<code>0x000000000000000?</code>（最后一位取决于 <code>setg</code> 到底 set 了什么），这就是我们需要返回的 <code>x &gt; y</code> 表达式的值，所以函数结束。</p><hr><h2 id="4-2-Conditional-Branches"><a href="#4-2-Conditional-Branches" class="headerlink" title="4.2 Conditional Branches"></a>4.2 Conditional Branches</h2><p>前一节的例子描述了如何依靠 condition codes 来修改某个寄存器的 low-order 8-bit 的值，这是实现条件分支的基础。</p><p>这一节将利用 condition code 来组织条件分支，本质上也是 reading condition codes；</p><h2 id="4-2-1-JX-Instructions-【Old】"><a href="#4-2-1-JX-Instructions-【Old】" class="headerlink" title="4.2.1 JX Instructions 【Old】"></a>4.2.1 JX Instructions 【Old】</h2><ul><li><p>语法：<code>jX &lt;LABEL&gt;</code>，这里的 <code>&lt;LABEL&gt;</code> 是汇编程序中的一个<strong>段落标签</strong>，在具体例子中会展示。</p><blockquote><p>还有一种语法，会在 4.4 中介绍。</p></blockquote></li><li><p>作用：有条件（根据 condition codes）/ 无条件跳转到指定部分的汇编代码继续执行；</p></li><li><p>具体类型（和 <code>SetX</code> Instructions 使用名称类似）：</p><table>    <tr style="text-align: center;">        <th>jX</th>        <th>Condition</th>        <th>Description</th>    </tr>    <tr>        <td>jmp</td>        <td>1</td>        <td>Unconditional</td>    </tr>    <tr>        <td>je</td>        <td>ZF</td>        <td>Equal/Zero</td>    </tr>    <tr>        <td>jne</td>        <td>~ZF</td>        <td>Not Equal/Not Zero</td>    </tr>    <tr>        <td>js</td>        <td>SF</td>        <td>Negative</td>    </tr>    <tr>        <td>jns</td>        <td>~SF</td>        <td>Nonegative</td>    </tr>    <tr>        <td>jg</td>        <td>~(SF^OF)&amp;~ZF</td>        <td>Greater (signed)</td>    </tr>    <tr>        <td>jge</td>        <td>~(SF^OF)</td>        <td>Greater or Equal (signed)</td>    </tr>    <tr>        <td>jl</td>        <td>(SF^OF)</td>        <td>Less (signed)</td>    </tr>    <tr>        <td>jle</td>        <td>(SF^OF) | ZF</td>        <td>Less or Equal (signed)</td>    </tr>    <tr>        <td>ja</td>        <td>~CF &amp; ~ZF</td>        <td>Above (unsigned)</td>    </tr>    <tr>        <td>jb</td>        <td>CF</td>        <td>Below (unsigned)</td>    </tr></table></li><li><p>Example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">absdiff</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) result = x - y;</span><br><span class="line">    <span class="keyword">else</span> result = y - x;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">    cmpq%rsi, %rdi</span><br><span class="line">    jle.L4</span><br><span class="line">    movq%rdi, %rax</span><br><span class="line">    subq%rsi, %rax</span><br><span class="line">    ret</span><br><span class="line">.L4:</span><br><span class="line">    movq%rsi, %rax</span><br><span class="line">    subq%rdi, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>已知 <code>%rdi</code> 保存的是函数第一参数 x，<code>%rsi</code> 保存的是函数第二参数 y，<code>%rax</code> 保存函数返回值。</p><blockquote><p>再次说一下，<strong>汇编函数返回前只需要把返回值放在特定的寄存器中就行</strong>，只要调用方清除你放在哪就行。比如这里放在 <code>%rax</code>，那么函数结束后，调用方会去 <code>%rax</code> 访问结果。</p></blockquote><p>第一步 <code>cmpq</code> 根据 <code>%rdi 值 - %rsi 值</code> 来设置 condition codes；</p><p>第二步的 <code>jle</code> 对应的条件是 <code>(SF ^ OF) | ZF</code>，结合上一步也就是 <code>x ≤ y</code> 时，跳至 <code>.L4</code> 标签标记的位置继续执行。</p><p>这里 <code>.L4</code> 是一个标签，<code>.</code> 开头表示它是<strong>内部的</strong>操作或标签，只会出现在汇编代码中，不会出现在目标代码（机器代码）中，所以不会被当作独立的函数。</p><blockquote><p>有同学会说，不是说汇编代码就是机器代码的文本表示吗？为啥还有差别？</p><p>其实是这样的，汇编代码相对于机器代码，在转换为易读的文本同时，会把一些<strong>指令地址</strong>设置成内部标签。在汇编转机器代码时，会再计算代入回去。不然你读 <code>jle 0x0F0E2310</code> 肯定没有 <code>jle .L4</code> 好读。</p></blockquote><p>后两步的含义已经比较简单了，不再赘述。</p><p>上面的内容<strong>类似 C/C++ 中的 goto 语句，不建议在 C/C++ 中使用</strong>；</p></li></ul><h2 id="4-2-2-General-Conditional-Expression-Translation-amp-Conditional-Moves"><a href="#4-2-2-General-Conditional-Expression-Translation-amp-Conditional-Moves" class="headerlink" title="4.2.2 General Conditional Expression Translation &amp; Conditional Moves"></a>4.2.2 General Conditional Expression Translation &amp; Conditional Moves</h2><blockquote><p>本小节介绍了 “条件移动” 这种编译器优化的方式，告诉我们在有些情况下，编译器将条件控制一味地翻译成 <code>JX</code> Instructions 不见得是最好的；同时也指明了不应该使用 “条件移动” 优化的情形。</p></blockquote><p>上面介绍的 <code>JX</code> Instructions 真的适合编译器使用吗？效率是最高的吗？如果仔细看上一节标题会发现有一个 “【Old】” 的标志，这说明现在不经常用到它了。如果效率不佳，那么有哪些方法可以考虑呢？为什么呢？</p><p>如果编译器将 C++ 代码翻译为上面的 <code>JX</code> Instructions，那么这种翻译被称为 <strong>General Conditional Expression Translation</strong>，这也是最自然的方法：如果满足某个条件就跳转到哪里执行，否则如何如何。</p><p>还有一种方法被称为 <strong>条件移动（Conditional Moves）</strong>，是将 C/C++ 代码中的条件分支（if-else）的 “then” 分支和 “else” 分支<strong>全部执行</strong>，最后按照条件再决定将谁移动到结果寄存器中。</p><p>伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result    = the value of Then_Expr</span><br><span class="line">eval    = the value of Else_Expr</span><br><span class="line">cond    = !(the value of Test)</span><br><span class="line">if (cond) result = eval</span><br><span class="line"></span><br><span class="line">return result</span><br></pre></td></tr></table></figure><p>有人说，这把 then 子句和 else 子句都运行了，平均的时间复杂度上不是会比之前的 General Condition Expression 更浪费时间吗？其实不然，这里的知识和后面章节的 “流水线” 有关。</p><p>因为现代处理器采用 “流水线（pipeline）” 的运行方式，在到达一行代码时会关联甚至运行下面几行的代码。现代处理器大概可以同时处理 20 行左右的指令深度（主要取决于事先读入的指令条数）。当运行到含有分支的部分时，处理器会采取 “<strong>分支预测技术</strong>”，根据上下文猜测会运行到哪个分支，并将猜测的分支事先读入流水线。</p><p>如果猜对，那么执行非常迅速，直接读取流水线上的信息，并离开这个分支；但是如果猜错，那么将停止执行当前流水线上的代码，并重新读入另一段分支。这是个耗时操作，较差情况下会花费 40 个时钟周期（40 步普通指令执行时间）。</p><p>因此，<strong>在某些情况下</strong>，使用 Conditional Moves 的条件判断方法可能会比 General Conditional Expression 更高效。</p><p><strong>正因如此，大多数编译器在<u>某些情况下</u>都选择 Conditional Moves，而不是上面的 <code>JX</code> 指令（代表 General Condition Expression），所以你几乎看不到 4.2.1 中的汇编代码。</strong>如果实在想看到，那么在用 gcc 编译时，给定参数 <code>-fno-if-conversion</code>，这样不允许编译器使用条件移动。</p><hr><p>所以在 4.2.1 中大多数情况下的汇编代码应该长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">    movq%rdi, %rax</span><br><span class="line">    subq%rsi, %rax</span><br><span class="line">    movq%rsi, %rdx</span><br><span class="line">    subq%rdi, %rdx</span><br><span class="line">    cmpq%rsi, %rdi</span><br><span class="line">    cmovle%rdx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>再稍微解释一下，第一步是将 <code>%rdi</code> 的值（即函数第一参数 x）赋给 <code>%rax</code>；</p><p>从第二步开始就是条件移动的方法了：第二步先把 <code>%rax</code> 的值（x）减去 <code>%rsi</code>（y），相当于先做了 then 分支的内容；</p><p>第三步是将 <code>%rsi</code> 的值（y）移动到 <code>%rdx</code> 中，并再第四步把 <code>%rdx</code> 的值减去 <code>%rdi</code>（x），相当于完成了 else 分支的内容；</p><p>到目前为止，<code>%rax</code> 中存放 <code>x - y</code> 的值，<code>%rdx</code> 中存放 <code>y - x</code> 的值；</p><p>第五步才是按照 x、y 的值来设置 condition codes；</p><p>最后一步是一个<strong>新指令：<code>cmovle</code></strong>;</p><ul><li>语法：<code>cmovle &lt;Src&gt;, &lt;Dst&gt;</code>；</li><li>作用：条件移动，按照当前 condition codes 的状态进行移动。其中 <code>cmov</code> 就是 conditional moves，<code>le</code> 就是之前的 <code>X</code> 情况（小于等于情况），所以猜测还有 <code>cmovl</code>、<code>cmovge</code>、<code>cmovg</code>……</li></ul><hr><p>但是，上面说 <strong>Conditional Moves 更快是在“某些情况下”</strong>，那么什么是 “另外的情况”？</p><p>现在介绍在什么时候，汇编的翻译不应该用 Conditional Moves：</p><p><strong>Situation 1: Expensive Computations</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = Test(x) ? Hard1(x) : Hard2(x);</span><br></pre></td></tr></table></figure><p>这种 then 子句和 else 子句都非常难以计算的时候，不应该用条件移动。因为重新读入流水线的时间很可能会少于把两个子句都计算一遍的时间；</p><p><strong>Situation 2: Risky Computations</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = p ? *p : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>上面的判断语句必须先判断再进行执行，否则会出现程序错误，尤其是在指针的判断上；</p><p><strong>Situation 3: Computations with side effects</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = x &gt; <span class="number">0</span> ? x*=<span class="number">7</span> : x+=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>上面的 then 和 else 子句一旦执行，会破坏程序的原义，造成意想不到的后果。</p><h2 id="4-3-Loops"><a href="#4-3-Loops" class="headerlink" title="4.3 Loops"></a>4.3 Loops</h2><h2 id="4-3-1-Do-While-Loop"><a href="#4-3-1-Do-While-Loop" class="headerlink" title="4.3.1 Do-While Loop"></a>4.3.1 Do-While Loop</h2><p>对于一个计算 x 代表的二进制代码中的 1 的个数的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pcount_do</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result += x &amp; <span class="number">0x1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的汇编代码非常简单，<strong>就可以用 General Conditional Expression 的方法，结合 <code>JX</code> Instructions 实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pcount_do:</span><br><span class="line">    movl$0, %eax</span><br><span class="line">.L2:</span><br><span class="line">    movq%rdi, %rdx</span><br><span class="line">    andl$1, %edx</span><br><span class="line">    addq%rdx, %rax</span><br><span class="line">    shrq%rdi</span><br><span class="line">    jne.L2</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure><p>对应的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    preparations</span><br><span class="line">loop:</span><br><span class="line">    Body</span><br><span class="line">    if (Test)</span><br><span class="line">        goto loop</span><br></pre></td></tr></table></figure><p>这里注意一下，<code>movl</code> 和 <code>andl</code> 都不算新的指令——之前说过 <code>q</code> 的含义代表操作数的位数，quad 指 4 字（4 × 16 bits），<code>l</code> 就指 2 字，2 × 16 bits；</p><h2 id="4-3-2-General-While-Loop-Translation-1-“Jump-to-Middle”-Translation"><a href="#4-3-2-General-While-Loop-Translation-1-“Jump-to-Middle”-Translation" class="headerlink" title="4.3.2 General While Loop Translation #1 - “Jump to Middle” Translation"></a>4.3.2 General While Loop Translation #1 - “Jump to Middle” Translation</h2><p>从 do-while 到 while 只需要更改一下测试条件的顺序就行。例如上一节的代码改成 while 循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pcount_do</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        result += x &amp; <span class="number">0x1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么对应的汇编伪代码<strong>可以是</strong>（一般在编译器优化等级 <code>-Og</code> 时出现）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    goto test;// 先测试</span><br><span class="line">loop:</span><br><span class="line">    Body</span><br><span class="line">test:</span><br><span class="line">    if (Test)</span><br><span class="line">        goto loop;// 通过再进循环体</span><br><span class="line">done:</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure><h2 id="4-3-3-General-While-Loop-Translation-2-“Do-while”-Conversion"><a href="#4-3-3-General-While-Loop-Translation-2-“Do-while”-Conversion" class="headerlink" title="4.3.3 General While Loop Translation #2 - “Do-while” Conversion"></a>4.3.3 General While Loop Translation #2 - “Do-while” Conversion</h2><p>如果把编译器的优化等级调至 <code>-O1</code>，那么编译器在处理 while 循环时不会采用上面的 ”Jump to Middle“ 的翻译策略，而是采用 <strong>转换为 do-while 循环</strong> 的策略，这样会更加高效。</p><p>这相当于把 C/C++ 代码中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test) &#123;</span><br><span class="line">    Body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换成了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Test)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Body</span><br><span class="line">&#125; <span class="keyword">while</span> (Test);</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>具体的汇编伪代码会变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    if (!Test)// 仅进入前判断一下，接下来就变成 do-while</span><br><span class="line">        goto done;</span><br><span class="line">loop:</span><br><span class="line">    Body</span><br><span class="line">    if (Test)</span><br><span class="line">        goto loop;</span><br><span class="line">done:</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure><p>从这个优化上可以看出，其实 do-while 循环会比 while 循环更高效，但现在的编译器比较智能，只要优化等级不低，这个方面会帮你优化掉的。</p><h2 id="4-3-4-For-Loop"><a href="#4-3-4-For-Loop" class="headerlink" title="4.3.4 For Loop"></a>4.3.4 For Loop</h2><p>for loop 的汇编实现没那么简单，我们可能需要向 while 或 do-while 上看齐。比如对如下 for 循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Init; Test; Update) &#123;</span><br><span class="line">    Body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器可以转换成 while 循环，如果使用了 <code>-O1</code> 优化，会优化到 do-while：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Init;</span><br><span class="line"><span class="keyword">while</span> (Test) &#123;</span><br><span class="line">    Body</span><br><span class="line">    Update;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"></span><br><span class="line">Init;</span><br><span class="line"><span class="keyword">if</span> (!Test) &#123;    <span class="comment">// do-while 前的测试块（Initial Test）</span></span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Body</span><br><span class="line">    Update;</span><br><span class="line">&#125; <span class="keyword">while</span> (Test);</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>很多时候，<code>-O1</code> 下的编译器甚至可以识别 <code>Init</code> 块 和 do-while 前的测试块的关联，并且合理舍弃前置的测试块。</p><h2 id="4-4-Switch-Statements"><a href="#4-4-Switch-Statements" class="headerlink" title="4.4 Switch Statements"></a>4.4 Switch Statements</h2><p>将 C/C++ 的 switch 语句翻译为汇编是相当有难度的。首先应该弄清楚 switch 语句在 C/C++ 中的一系列特性：</p><ul><li><p>Match integer values；</p></li><li><p>Fall through cases：当 case 中不存在 break 时，会一直向下运行；</p></li><li>Merge cases：当一个 case 中没有任何内容时，相当于并入下一个 case（上一点的特例）；</li><li>Default case：对于没有匹配的 cases，会进入最后的 default case（如果有的话）；</li></ul><p>当然，现代的编译器对于 switch 语句的翻译绝不是一系列的 if-else 语句的翻译，而是利用了一个数据结构：<strong>跳表（Jump Table Structure）</strong>；</p><p>如下图，switch-case 语句就像一串代码块，每个 case 就是一个块。编译时，switch-case 块会整体一起编译（如下图 Jump Targets），转为汇编指令后，每个块的汇编指令所对应的<strong>地址</strong>会被存储在一个跳表中（如下图 Jump Table）。这样在根据条件调用相应代码块时，只需要 goto 跳表中的对应地址（ray indexing）就能完成任务，无需一个个比对条件。</p><p><img src="imgs/jump_table.png" height="300px"></p><p>那么，汇编代码是如何在跳表中找到合适的地址的呢？举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_eg</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        w = y * z;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        w = y / z;</span><br><span class="line">        <span class="comment">/* Fall Through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        w += z;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        w -= z;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        w = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子对应的汇编代码可以是（一部分代码）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch_eg:</span><br><span class="line">    movq%rdx, %rcx</span><br><span class="line">    cmpq$6, %rdi</span><br><span class="line">    ja.L8</span><br><span class="line">    jmp*.L4(,%rdi,8)</span><br></pre></td></tr></table></figure><p>逐步解释：</p><p>第一步将 <code>%rdx</code>（第三参数 z）赋值到 <code>%rcx</code> 寄存器中；</p><p>第二步就将 <code>%rdi</code>（第一参数 x）与常数 6 进行做差比较（为什么是 6？因为在源码中 6 是最大的 case），以此修改 condition codes；</p><p>第三步 <code>ja</code> 表示只要 <code>%rdi</code>（x）的值（<strong>看作 unsigned</strong>）在 6 之上，那么就跳至 <code>.L8</code>（看来是 default 片段），否则第四步会无条件跳至某个位置；</p><blockquote><p>这里编译器处理的非常巧妙：使用 <code>ja</code>（unsigned above）而不是 <code>jg</code>（signed greater），这样同时把 <code>x &gt; 6</code> 和 <code>x &lt; 0</code> 的情况都算入 <code>ja</code> 的条件中，进一步提高了效率；</p></blockquote><p>这里还需要解释一下，之前没有提到的 <code>JX</code> Instructions 的使用语法。除了 <code>jX &lt;LABEL&gt;</code> 直接跳转至对应标签（direct jump），另一种方法是<strong>间接跳转（indirect jump）：<code>jX &lt;effectiveAddress&gt;</code></strong>；</p><p>参数是有效地址，可以是寄存器名称，也可以是右值，例如这个例子中 <code>jmp *.L4(,%rdi,8)</code>，后面的部分 <code>.L4(,%rdi,8)</code> 应该很熟悉了：因为标签会被汇编器翻译为代码段的地址，所以它就是 <code>.L4地址 + 8 * x</code>（<code>%rdi</code> 的值是 x），并把这个值看作 memory 的地址。前面的 <code>*</code> 星号就是直接取地址上内容的意思（和 C/C++ 的相同），可以理解为 <code>leaq</code> 相反的过程；<strong>这个 memory 地址中的值就是跳表中的一个代码段的地址</strong>，所以取出来的也是地址；</p><p>第四步跳转的位置如何，我们需要看看剩下来的汇编代码（跳表部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            ; read only data</span><br><span class="line">.section    .rodata; 这行和下一行是为了构造跳表的基本结构</span><br><span class="line">    .align8; 伪对齐指令，指明下面的变量必须从下一个能被 8 整除的地址开始</span><br><span class="line">.L4:                ; 代码块按照 x 的值的顺序进行排列</span><br><span class="line">    .quad.L8; x = 0 的情况</span><br><span class="line">    .quad.L3; x = 1</span><br><span class="line">    .quad.L5; x = 2</span><br><span class="line">    .quad.L9; x = 3</span><br><span class="line">    .quad.L8; x = 4</span><br><span class="line">    .quad.L7; x = 5</span><br><span class="line">    .quad.L7; x = 6</span><br></pre></td></tr></table></figure><p>如上所示，跳表的结构是由汇编代码指定的，如何填这个表是<strong>汇编器的工作</strong>，不是编译器的工作；</p><p>在编译器生成的汇编代码中，<code>.quad</code> 只是个声明，标记表示这里是一个 4 字（4 × 16 bits）的数据，以后汇编器需要填上后面指定标签指令段的地址；</p><p>我们可以发现，<code>x &lt; 0</code> 和 <code>x &gt; 6</code> 的情况在之前的代码中被 <code>ja</code> 处理，跳至 <code>.L8</code>（default 代码段），剩余在 switch 中整数缺省的情况（<code>x = 4</code> 和 <code>x = 0</code>）也会自动转至 <code>.L8</code>;</p><p>主干看完了，继续看之前提到的各个代码段的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.L3:                    ; 对应 x = 1 的情况的代码段</span><br><span class="line">    movq%rsi, %rax</span><br><span class="line">    imulq%rdx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>接下来，编译器的行为就很迷惑了。大家是否还记得，之前在源码的第一行有 <code>long w = 1;</code> 的初始化操作？但编译器不做，因为在很多 case 下并没有用到这个值，所以赋值被推迟了，直到有一个 case—— <code>x = 3</code>，它的代码段是 <code>w += z;</code> 需要用到之前的值，这个时候编译器才开始赋值 1，这么做只是为了提高效率……如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.L5:                    ; 对应 x = 2 的代码段</span><br><span class="line">    movq%rsi, %rax</span><br><span class="line">    cqto</span><br><span class="line">    idivq%rcx; %rcx 中存放 z，这里是 y/z</span><br><span class="line">    jmp.L6</span><br><span class="line">.L9:                    ; 对应 x = 3 的代码段之前的 x = 1 的赋值操作，也是x = 3入口</span><br><span class="line">    movl$1, %eax</span><br><span class="line">.L6:                    ; 对应 x = 3 的代码段主体</span><br><span class="line">    addq%rcx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>其中 <code>cqto</code> 是 Convert Quadword to Octoword，意为 64-bit 扩展至 128-bit，没有参数，作用是将 <code>%rax</code> 中的 MSB 复制到整个 <code>%rdx</code> 寄存器中（这么做的原因是 <strong>Expanding Conclusion</strong>），一般紧接着 <code>idivq &lt;dividerR&gt;</code>，将 <code>rdx:rax</code> 中的 128-bit 数作为被除数，<code>divderR</code> 作为除数，进行 signed 除法，商存在 <code>%rax</code>，余数存在 <code>%rdx</code>；</p><p>继续：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.L7:                    ; x = 5</span><br><span class="line">    movl$1, %eax</span><br><span class="line">    subq%rdx, %rax</span><br><span class="line">    ret</span><br><span class="line">.L8:                    ; x = 6</span><br><span class="line">    movl$2, %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>明白了跳表的原理，这下明白了为啥 C/C++ 要求 switch 的量必须是可以转换为整型的常量了吧？</p><p>无论如何，编译器都会找出你写的所有 case 的最大值、最小值，在此之外的情况会在进入跳表前进行跳转至 default 块；在最值之间的，会出现在跳表中（也就是说 case 的最大值、最小值决定了跳表的大小）；但是在范围中有缺省的情况的，也会补充在跳表中，跳转到 default 块。</p><blockquote><p>小机灵可能会问，诶，如果这些 case <strong>全是负数咋整</strong>？或者<strong>最小值很大咋整</strong>？还能不能建立跳表、用索引了？因为咱之前的 <code>jmp *.L4(,%rdi,8)</code> 不就直接把 x 做跳表索引了吗？</p><p>实际编译器会确保最小值不会低于 0，也不会太大。为此，编译器可能会加上<strong>偏置值（bias）</strong>让 case 变成小的正数。</p><p>还有小机灵可能会问，如果一个 case 是 0， 另一个是 10000，难到在这之中的全部要建表吗？也就是说，如果 case 的<strong>间隔很稀疏、很大</strong>怎么办？</p><p>这个时候编译器会把这些 switch-case 转换成 if-else 语句，再建立 if-else 树，由于稀疏的数据，所以这个树大概率是平衡树，让比对的时间复杂度保持在 $O(log_2(n))$；</p></blockquote><p>综合上面的讨论，无论如何 switch-case 所依赖的跳表的时间复杂度会在 $O(1)\sim O(log_2(n))$ 之间，总是比 if-else 的线性时间复杂度要好。</p><h2 id="4-5-Summary-for-Chapter-4"><a href="#4-5-Summary-for-Chapter-4" class="headerlink" title="4.5 Summary for Chapter 4"></a>4.5 Summary for Chapter 4</h2><p>这章的知识点比较多，在这里总结一下 Chapter 4 的主要内容。</p><p>在一开始，我们先复习了之前的寄存器及其代表的处理器的状态，再初步了解了汇编中的重要 flags: condition codes（目前只认识了 4 个：<code>CF/OF/SF/ZF</code>），它们可以看作一个个 1-bit 数据，不能被手动更改，但可以通过特定的方式进行访问。</p><p>例如 <code>cmpq</code> 和 <code>testq</code> 能根据计算结果修改 flags，<code>setX</code> Instructions 能根据当前 flags 设置特定的 8-bit 位。我们还了解了几个特殊的指令，例如 <code>movzbl</code>；了解了 x86-64 的 low-order 32-bit 填充特性。</p><p>我们不满足于借助 condition codes 仅仅填充几个 bits，我们进一步学习了根据 condition codes 进行流程控制的方法。</p><p>首先是比较低效的 <code>JX</code> Instructions，它代表着 General Conditional Expression，利用汇编<strong>条件跳转</strong>初步实现条件分支；进一步从流水线层面，我们认识到 <strong>Conditional Moves</strong> 可能是更好、更快的选择，但一定要搞清 3 个禁忌条件。我们还认识了 <code>cmovle</code> 等一系列<strong>条件移动的指令</strong>，让过程更加方便。</p><p>在循环控制方面，我们掌握了 do-while 结构的翻译方法，通过 <code>JX</code> 指令轻松解决；针对 while 循环时，我们想到两种方法：“Jump to Middle” 把判断条件放 loop 的中间，开始循环前跳进去；还有一种是转换为 do-while 的 “set guardian” 方法，效率更高。对于 for 循环，我们也可以容易地将其转换为 while 循环，进一步优化为 do-while，通过合理舍弃 “guardian” 进一步加快运行效率。</p><p>在比较繁琐的 switch-case 语句的翻译上，聪明的人们为它引入了<strong>跳表</strong>的数据结构，利用 <code>jX</code> 的间接跳转在 $O(1)\sim O(log_2(n))$ 的复杂度下完成了分支，远胜 if-else 结构的线性复杂度。</p><p>不过上面的几乎所有内容都是在汇编层面<strong>实现了一些小的 “tricks”</strong> 来帮助提升运行效率，这只是在将代码流程控制的翻译这个 procedure 上加一点东西，或者是<strong>改变流程的方法</strong>。这都是底层指令逐步堆砌实现更高级指令的实例。</p><p>下一章节我们将系统学习汇编运行的整个 procedure，知识点将更为复杂，做好准备！</p><h1 id="Chapter-5-Machine-Level-Programming-Ⅲ-Procedure"><a href="#Chapter-5-Machine-Level-Programming-Ⅲ-Procedure" class="headerlink" title="Chapter 5. Machine Level Programming Ⅲ - Procedure"></a>Chapter 5. Machine Level Programming Ⅲ - Procedure</h1><blockquote><p>本章所指的 Procedure 既可以是 function，method，也可以是 normal procedure；</p></blockquote><p>知识补充：什么是 ABI ？</p><p>虽然 CSAPP 讲述的是基于 x86 硬件及其运行方式，但更重要的是我们采用了一套被普遍承认的约定—— ABI（Application Binary Interface），这是个<strong>机器程序级别的接口</strong>。这个接口在第一台 x86 机器被制造出来的时候就出现了，尤其是为 Linux 制定的。它规定了，所有二进制程序、操作系统各个组件、编译器都要对于管理机器上的资源有共同的理解，并且遵守使用规则。</p><p><strong>例如之前说的，约定俗成哪些寄存器用来传递函数参数、哪些寄存器用来传递返回值，哪些是 “Caller-Saved Register”，哪些又是 “Callee-Saved Register”</strong>，这些都是 ABI 规定的；</p><p>到目前，Windows 和 OSX 等操作系统也有自己的 ABI；</p><h2 id="5-1-Mechanisms-in-Procedures"><a href="#5-1-Mechanisms-in-Procedures" class="headerlink" title="5.1 Mechanisms in Procedures"></a>5.1 Mechanisms in Procedures</h2><blockquote><p>过程机理的概览，下几节会一一回答这些问题；</p></blockquote><ul><li>Passing control<ul><li>To beginning of procedure code（运行过程如何进入一个函数？）</li><li>Back to return point（函数运行结束如何跳转到之前调用位置的下一行？）</li></ul></li><li>Passing data<ul><li>Procedure argument（如何向被调方传递参数？）</li><li>Return value（被调方如何返回数据给调用方？）</li></ul></li><li>Memory management<ul><li>Allocate during procedure execution（某过程开始执行时，内存如何分配以供过程使用？）</li><li>Deallocate upon return（某过程结束后，内存如何销毁？）</li></ul></li><li>Mechanisms all implemented with machine instructions（以上机理如何在机器代码中实现？）</li><li>x86-64 implementation of a procedure uses only those mechanisms required（示例）</li></ul><h2 id="5-2-x86-64-Stack"><a href="#5-2-x86-64-Stack" class="headerlink" title="5.2 x86-64 Stack"></a>5.2 x86-64 Stack</h2><blockquote><p>在此之前，先介绍 x86-64 architecture 的内存栈的机制；</p></blockquote><p>程序总是使用栈来<strong>管理过程中调用和返回状态</strong>，这主要是利用了栈 LIFO 的性质，这和调用-返回的思想很相似。因此它可以被用于：<strong>传递潜在信息、控制信息，分配 local 数据</strong>；</p><p>x86 的程序栈也存在于内存中，<strong>栈底位于 high numbered address（高位地址）</strong>，而栈顶位于 low numbered address；</p><p>前面说的 <strong><code>%rsp</code> 寄存器</strong>就是位于栈顶来管理这个过程的。<code>%rsp</code> 寄存器存储的是<strong>栈顶的地址</strong>，当有数据需要进栈时，<strong>通过递减栈指针来完成进栈操作</strong>；</p><p>之前还说过，<code>%rsp</code> 不应该被手动更改，那么有哪些方法能够使用这个栈呢？</p><p>第一个是 <code>pushq</code> 指令。</p><ul><li><p>语法：<code>pushq &lt;Src&gt;</code>;</p></li><li><p>作用：先从 <code>Src</code> 中取得操作数，再将 <code>%rsp</code> 值减 8（quadword，即 4 × 16 bits，64 bits，8 bytes），最后将从 <code>Src</code> 处获得的操作数写入到 <code>%rsp</code> 对应的 memory 地址中；</p><blockquote><p>⚠ 需要注意的点：<strong>这个栈是先移动指针再往里面写的</strong>；</p></blockquote></li><li><p><code>Src</code> 可以是直接量、寄存器名称、内存引用；</p></li></ul><p>与之对应的是 <code>popq</code> 指令。</p><ul><li><p>语法：<code>popq &lt;Dst&gt;</code>;</p></li><li><p>作用：先将 <code>%rsp</code> 值所代表的 memory 地址中的值读进，再将 <code>%rsp</code> 的值加 8，最后将读到的值写入 <code>Dst</code>;</p><blockquote><p>⚠ 需要注意的点：<strong>这个 <code>Dst</code> 只能是寄存器</strong>，因为前面说了，不允许从内存到内存，也不允许存入直接量；</p></blockquote></li></ul><h2 id="5-3-Calling-Conventions"><a href="#5-3-Calling-Conventions" class="headerlink" title="5.3 Calling Conventions"></a>5.3 Calling Conventions</h2><h2 id="5-3-1-Passing-Control"><a href="#5-3-1-Passing-Control" class="headerlink" title="5.3.1 Passing Control"></a>5.3.1 Passing Control</h2><p>以一个例子说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = mult2(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">    <span class="type">long</span> s = a * b;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是上面的源码经过汇编得到的结果（稍微删除了一些无关紧要的部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">    push%rbx</span><br><span class="line">    mov%rdx, %rbx</span><br><span class="line">    callq400550 &lt;mult2&gt;</span><br><span class="line">    mov%rax, (%rbx)</span><br><span class="line">    pop%rbx</span><br><span class="line">    retq</span><br><span class="line"></span><br><span class="line">mult2:</span><br><span class="line">    mov%rdi, %rax</span><br><span class="line">    imul%rsi, %rax</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure><p>这里注意一下 <strong>Passing Control</strong> 是怎么完成的：</p><ul><li><p>使用了程序栈来支持 procedure 的数据；</p></li><li><p>使用 <code>call &lt;LABEL&gt;</code> 指令来完成：</p><ol><li>把 <strong>return address</strong>（调用结束，返回时的位置）加入到栈中；</li><li>跳至 <code>LABEL</code> 执行；</li></ol></li><li><p>使用 <code>ret</code> 指令来完成：</p><ol><li>将栈中的地址弹出读取；</li><li>跳转到读取的地址；</li></ol><blockquote><p>有的时候会看到 <code>rep; ret</code> 的指令行，不用管，它和 <code>ret</code> 作用一样；</p></blockquote></li></ul><p>因此，Passing Control 的过程主要由两个特殊寄存器、一个栈支持；运行的动态如下（地址信息是虚拟的）：</p><p><img src="imgs/procedure_control_1.png" height="200px"><img src="imgs/procedure_control_2.png" height="200px"><img src="imgs/procedure_control_3.png" height="200px"><img src="imgs/procedure_control_4.png" height="200px"></p><h2 id="5-3-2-Passing-Data"><a href="#5-3-2-Passing-Data" class="headerlink" title="5.3.2 Passing Data"></a>5.3.2 Passing Data</h2><p>其实在此之前的前几章，我们已经看到了，汇编程序使用约定俗称的寄存器（“Caller-Saved Resgiter”）来完成函数参数、返回值的传递：</p><ul><li><p><code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rcx</code>、<code>%r8</code>、<code>%r9</code> 这都是 Caller-Saved Register，约定<strong>从前到后</strong>（顺序可以记下来）用来存放函数的六个参数，供被调用方使用；</p><blockquote><p>这里是 integer registers，如果参数不是整型 / 指针，那么会用<strong>浮点数寄存器</strong>来存放，以后说。</p><p>注：在 IA-32 时期，甚至所有参数都放在栈里，这会大大降低程序运行速度的。</p></blockquote></li><li><p>如果函数多于 6 个参数那么从第 7 个参数开始，将按顺序存放在栈里，仅需要才会分配栈（<strong>这个栈也用 <code>%rsp</code> 访问，一般每 8 bytes 一个参数，但是位于另一个栈帧，和调用方的栈帧互不干扰。具体情况见下一节</strong>）</p></li><li><p><code>%rax</code> 也是 Caller-Saved Register，约定是用于存放函数的返回值，供调用方读取；</p></li></ul><h2 id="5-3-3-Managing-Local-Data"><a href="#5-3-3-Managing-Local-Data" class="headerlink" title="5.3.3 Managing Local Data"></a>5.3.3 Managing Local Data</h2><p>早在 5.2 中就介绍了 x86 栈的作用之一就是<strong>分配 local 数据</strong>。那么调用和返回的功能之一就是可以对函数进行嵌套调用。</p><p>此外，我们将栈上<strong>用于特定 call 的每个内存块称为栈帧（stack frame）</strong>，它是特定 procedure、特定 instance 的栈帧。单线程程序共用一个栈，因此通过栈帧来管理各个函数的 Local data；</p><p>栈帧的结构如何？是如何管理的？其中究竟放了些什么？</p><ul><li><p>Structure：大家在 C++ 程序设计课程上应该接触过 “变量作用域”，这个时候应该强调了不同函数的局部变量会存在它的栈帧中。所以可以想象，栈帧就是一段一段堆叠在 stack 上的片段，每个未返回的函数独享一个栈帧；</p><p><img src="imgs/stack_structure.png" height="300px"></p><p><strong>并且 <code>%rsp</code> 就在之前说的栈顶，还有一个普通寄存器 <code>%rbp</code> 可以用来存放两个栈帧交界的位置（只有在一些特殊情况下编译器才会使用它，平时会当作普通寄存器使用）</strong>；</p><p>所以大多数情况下，没有 <code>%rbp</code> 指示，汇编程序员甚至不知道下一层栈帧在哪里，<strong>这只能靠代码自身管理（大部分情况下编译器知道需要分配多少栈帧、销毁多少栈帧），并且正确释放栈帧（本节的一个例子会演示代码如何自身管理栈帧）</strong>；</p><blockquote><p>编译器不知道应该分配多少栈帧的特殊情况：<strong>分配可变大小的数组 / 内存缓冲区</strong> 等情况，这时编译器会无奈选择使用 <code>%rbp</code> 管理；</p></blockquote><p>也正因如此，递归所需的所有基础结构都由栈的原则所保证；</p><p>对于 <strong>x86-64 Linux</strong> 这一特定机器 + 操作系统而言，栈帧的<strong>详细结构</strong>应该是这样的：</p><p><img src="imgs/stack_structure_detail.png" height="350px"></p><ul><li><p>之前在 <strong>Passing Control</strong> 中提到 <code>call</code> 指令压入的返回地址存在 Caller Frame 的最上层，下面压着 <strong>Caller 传给 Callee 的参数</strong>（Arguments 7+，<strong>即最顶层地址较小的位置上是 argument 7，向栈底（地址增大的方向）增大</strong>）；</p></li><li><p>在两个栈帧之间有空间为可选的旧 <code>%rbp</code>（上一层栈帧的 <code>%rdp</code>）空间，当前的 <code>%rbp</code> 就指向这里（如果有的话）；</p></li><li><p>在当前 Callee Frame 中，最底层是 <strong>Callee-Saved Register</strong>（保存 Temporaries）和内存中的<strong>局部变量</strong>；向上就是在 <strong>Pass Data</strong> 中提到的<strong>多于 6 个的传入参数</strong>存放的位置。</p></li><li><p><strong>之前说的 “代码自身管理的方式” 就是在函数返回前将 <code>%rsp</code> 回到一开始的地方（上一层栈帧）</strong>；</p></li></ul></li><li><p>Management：为正在执行、没有返回的函数保留一个栈帧</p><ul><li>Space allocated <strong>when enter procedure</strong><ul><li>“Set-up” code</li><li>Include push by <code>call</code> instruction</li></ul></li><li>Deallocated <strong>when return</strong><ul><li>“Finish” code</li><li>Include pop by <code>ret</code> instruction</li></ul></li></ul></li><li><p>Contents</p><ul><li>Return information</li><li>Local storage（only if necessary）</li><li>Temporary space（only if necessary）</li></ul></li></ul><hr><p>为了演示这一部分，下面列举一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">incr</span><span class="params">(<span class="type">long</span> *p, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = *p;</span><br><span class="line">    <span class="type">long</span> y = x + val;</span><br><span class="line">    *p = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">call_incr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> v1 = <span class="number">15213</span>;</span><br><span class="line">    <span class="type">long</span> v2 = incr(&amp;v1, <span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">incr:</span><br><span class="line">    movq(%rdi), %rax</span><br><span class="line">    addq%rax, %rsi</span><br><span class="line">    movq%rsi, (%rdi)</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">call_incr:</span><br><span class="line">    subq$16, %rsp</span><br><span class="line">    movq$15213, 8(%rsp)</span><br><span class="line">    movl$3000, %esi</span><br><span class="line">    leaq8(%rsp), %rdi</span><br><span class="line">    callincr</span><br><span class="line">    addq8(%rsp), %rax</span><br><span class="line">    addq$16, %rsp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>其实函数 <code>incr</code> 的汇编代码很简单，重点不在这，而是调用它的函数 <code>call_incr</code> 以及过程中的处理情况。我们将一步步分析其中的情况。</p><p>首先，当上层的 caller 刚刚调用 <code>call call_incr</code> 指令、还没有为 <code>call_incr</code> 分配栈帧时，栈中的情况如下图所示：</p><p><img src="imgs/procedure_example_1.png" height="150px"></p><p>此时栈顶仍然是上层 caller 的 <code>call</code> 指令刚压入的 return address；随后机器读取 <code>%rip</code> 中保存的 <code>call_incr</code> 的地址开始执行 <code>call_incr</code> 函数；</p><p>现在请注意上面的 <code>call_incr</code> 汇编代码。</p><p>第一步是将 <code>%rsp</code> 的值减去 16，这意味着一口气在栈中分配了 16 bytes 空间，作为 <code>call_incr</code> 的栈帧（此时 <code>%rsp</code> 理所当然在最上层）；</p><blockquote><p>程序一般在栈上分配的空间会比实际需求多一点，这是因为有一些内部的约定，要求保持内存对齐，例如汇编中典型的 <code>.align</code> 伪指令。这个分配的值是由编译器计算得出的。</p></blockquote><p>第二步向 <code>%rsp + 8</code> 的 memory 地址写入常数 15213，这就相当于向栈顶的下面 8 bytes 的位置写入该常数；现在栈中的情况如下图所示：</p><p><img src="imgs/procedure_example_2.png" height="150px"></p><p>以上的第 1~2 步对应着源码的 <code>long v1 = 15213;</code> 这一步。</p><p>第三步将 <code>%rsi</code>（<code>%esi</code>）写入 32-bit 的 3000 整型（还记得之前说的特性吗？高 32-bit 会自动被置 0），因为 <code>%rsi</code> 将来会作为调用函数的第二参数；</p><p>第四步还记得吗？找到 <code>%rsp + 8</code> 作为地址对应的 memory 引用（这里就是之前栈中存放常数 15213 的位置）<strong>的地址</strong>（也就是存放 15213 的地址）赋给 <code>%rdi</code>，这就相当于 <code>&amp;v1</code> 给了调用函数的第一参数；</p><p>上面的第 3~4 步对应源码中的 <code>long v2 = incr(&amp;v1, 3000);</code> 的 <strong>Passing Data 部分</strong>；</p><p>而在过程中大家发现，代码是不是自身就管理了 <code>%rsp</code> 的位置和栈的分配？</p><p>在完成函数调用的 Passing Data 部分，我们继续进行 <code>long v2 = incr(&amp;v1, 3000);</code> 这一步的 <strong>Passing Control 部分</strong>：</p><p>接下来汇编调用了 <code>call incr</code>，干了 3 件事：<code>%rsp</code> 减 8，存储 return address（这里的是 <code>call incr</code> 下一行指令的地址），并且向 <code>%rip</code> 写入 <code>incr</code> 的起始地址。</p><p>于是程序进入了 <code>incr</code> 函数，这比较简单，其中的内存分配、变量设置就不说了。直接跳到 <code>incr</code> 函数的 <code>ret</code> 指令，此时经过内部的代码控制，<code>%rsp</code> 应该回到了之前 <code>call_incr</code> 函数栈帧的顶部（存放 return address 的位置）。于是 <code>ret</code> 也做了 3 件事：将 return address 取出来，<code>%rsp</code> 加 8，并向 <code>%rip</code> 写入刚刚取得的地址——也就是 <code>call_incr</code> 函数中 <code>call incr</code> 指令的下一行。</p><p>此时，栈的情况如下图所示（18213 是因为 <code>incr</code> 函数修改了 <code>long *p</code> 参数，还有，别搞混了，这个图里的 return address 是调用 <code>call_incr</code> 的上层 caller 的栈帧中的东西）：</p><p><img src="imgs/procedure_example_3.png" height="150px"></p><p>程序进入 <code>call_incr</code> 汇编的最后两步：把 <code>%rax</code>（<code>incr</code> 函数返回值，也就是 <code>v2</code>）加上 <code>%rsp + 8</code> 地址上的内容（18213，也就是新的 <code>v1</code>）作为函数返回值，<strong>并且把 <code>%rsp</code> 加上 16，释放了之前分配给 <code>call_incr</code> 函数的栈帧</strong>（所以你看看，编译器是不是知道之前分配了多少栈帧空间？是不是不需要 <code>%rbp</code> 的指示？）。函数到此结束，栈中的情况如下：</p><p><img src="imgs/procedure_example_4.png" height="100px"></p><p>最后的一句 <code>ret</code> 会读取上层 caller 放的 return address，将 <code>%rsp</code> 减 8，并且将 <code>%rip</code> 写入 return address，下一步程序将回到调用 <code>call_incr</code> 的上层 caller 的函数体中。栈的情况如下：</p><p><img src="imgs/procedure_example_5.png" height="100px"></p><hr><h2 id="5-4-Register-Saving-Conventions"><a href="#5-4-Register-Saving-Conventions" class="headerlink" title="5.4 Register Saving Conventions"></a>5.4 Register Saving Conventions</h2><p>之前无论是 5.3.2 讲述传递数据的方法，还是介绍 ABI 的约定，又或是早在 3.3.1 中介绍寄存器的使用，我们无数次提及 register 约定俗成的用法。为了加深印象、补充更多内容，我们这里再梳理一遍。</p><p>传递数据的时候，调用方（caller）和被调用方（callee）共同使用这所有的 16 个寄存器。那么，怎么保证 “在 caller 中保存特定数据的某些寄存器，在调用 callee 之后，callee 没有改变这些寄存器，并且还能看作原来的值，继续使用” 呢？</p><p>这就是约定 Callee-Saved 和 Caller-Saved Register 的作用了。它们的定义是：</p><ul><li><p>Caller-Saved: Caller saves temporaries values in its frame before the call <strong>but can be modified by procedures</strong>;</p></li><li><p>Callee-Saved: Callee saves temporaries values in its frame before using <strong>and restore them before returning to caller</strong>;</p><p><strong>（所以如果程序在某个 procedure 中使用了 <code>%rbp</code> 作为普通寄存器，那么能够保证这个函数 return 前 <code>%rbp</code> 会恢复到上一层的值，不会影响把 <code>%rbp</code> 当作 base pointer 使用的函数）</strong></p></li></ul><blockquote><p>回忆一下它们分别有哪些？</p></blockquote><p>所以，如果 caller 真的想要寄存器中的某些值不会被 callee 修改，在调用函数后仍然能使用，那么就应该把值放在 callee-saved register 当中。</p><p>此外，ABI 还规定了，callee 在返回前，需要把 callee-saved register 中的值恢复到原来的样子。</p><p>此外，一个介于特殊和普通之间的寄存器需要强调一下——<code>%rbp</code>，由于它有时作为分隔栈帧的 base pointer，所以如果有 callee 想要看作普通寄存器来使用它，那么需要在 return 前恢复到原来的状态。</p><blockquote><p>考虑一个问题，为什么 caller-saved register 一般没有要求 restore？</p><p>因为首先， caller-saved register 中保存函数参数的寄存器就是为了给 callee 读取的，所以调用前 caller 会设置这些寄存器的值，没有必要保持数据；另外如果 caller 真的想在调用之后使用这些值，那么可以<strong>把它的值放在自己的 callee-saved register 中，进而，因为 caller 自己也会是 callee，所以在 caller return 前也要恢复这个 callee-saved register</strong>（main 函数除外）；</p></blockquote><hr><p>那么这些约定在一般的代码中是如何体现的呢？下面以之前的 <code>incr</code> 函数为例子，我们加入一个 <code>call_incr2</code> 函数来展示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incr 函数见 5.3.3 的例子</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">call_incr2</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> v1 = <span class="number">15213</span>;</span><br><span class="line">    <span class="type">long</span> v2 = incr(&amp;v1, <span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> x + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">call_incr2:</span><br><span class="line">    pushq%rbx</span><br><span class="line">    subq$16, %rsp</span><br><span class="line">    movq%rdi, %rbx</span><br><span class="line">    movq$15213, 8(%rsp)</span><br><span class="line">    movl$3000, %esi</span><br><span class="line">    leaq8(%rsp), %rdi</span><br><span class="line">    callincr</span><br><span class="line">    addq%rbx, %rax</span><br><span class="line">    addq$16, %rsp</span><br><span class="line">    popq%rbx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>在上层 caller 进入 <code>call_incr2</code> 的第一件事就是把 <code>%rbx</code> 的值放到 <code>call_incr2</code> 的栈帧中。这是为什么？</p><p>原来，这个 <code>call_incr2</code> 函数有一个参数 <code>long x</code>，一开始存在 <code>%rdi</code> 中。但是，<code>call_incr2</code> 想要调用 <code>incr</code> 函数，后者要求两个参数，意味着 callee 会用到 <code>%rdi</code> 或更改。而在 <code>call_incr2</code> 的最后，<code>return x + v2;</code> 说明了等会还要用到现在 <code>%rdi</code> 中的值 x。所以，<code>call_incr2</code> 为了能够继续使用 x 这个值，需要将 x 存到 callee-saved register 中，<strong>因为调用 <code>incr</code> 之后，无论如何 <code>incr</code> 会将 callee-saved register 恢复到原来的数据的！</strong> 而在此之前，为了能够将这里使用的 callee-saved register 在返回前恢复到上一层调用前的状态，需要将原来的数据存在栈中。</p><blockquote><p>所以现在的情况是，</p><p>① caller 为了保留 caller-saved register（<code>%rdi</code>）的数据（因为要设置新的值给下一层 callee 来 passing data）所以要把 <code>%rdi</code> 数据放到 callee-saved register 中，这样调用后不变 ；</p><p>② 想要改变 callee-saved register，就需要保存之前的值，以保证上一层调用方在其中的值不变，而这个 callee-saved register 原先的值就放到了当前 caller 的栈帧中。</p><p><strong>考虑一个问题，为什么当前函数不把想要保存的数据直接保存在栈中，而是保存在 callee-saved register 中，完事还要为这个 callee-saved register 原先的值保存在自己的栈帧中？</strong></p><p>这是因为，直接保存在栈里不方便。如果有多个需要保存的数据，而且都放在栈里，那么读取方式、读取效率（可能会读很多次）都不佳；而且就没有必要设置 callee-saved register 了。</p><p>相反，如果保存在 callee-saved register 中，那么 caller 被调用后一开始统一保存上一层的 callee-saved register 的值，caller 返回前统一恢复上一层的 callee-saved register 的值，中间 caller 还能自由使用这些 callee-saved register，多次使用速度快，并且不用担心调用下一层函数会影响其中的值，岂不美哉！</p></blockquote><p>因此，在 <code>call_incr2</code> 调用 <code>incr</code> 之前，栈的情况如下图所示：</p><p><img src="imgs/procedure_example2_1.png" height="150px"></p><hr><p>总结：<strong>什么时候栈上会出现 Saved-Register 数据？答：当 caller 需要修改 callee-saved register 来保存某些值的时候，caller 会把数据保存到它的栈帧上。</strong>仅此一种情况。</p><h2 id="5-5-Illustration-of-Recursion"><a href="#5-5-Illustration-of-Recursion" class="headerlink" title="5.5 Illustration of Recursion"></a>5.5 Illustration of Recursion</h2><blockquote><p>本节将详细阐释 “递归” 这个技术在汇编层面的样貌。你会发现，因为有了之前所有的 mechanisms 的支持，C 编译器编译递归函数会和普通函数一样简单。</p></blockquote><p>以一个例子开始，这个 <code>pcount_r</code> 函数就是之前 “计算二进制数中有几个 1”（例子在 4.3）的递归版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Recursive popcount */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">pcount_r</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (x &amp; <span class="number">1</span>) + pcount_r(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个 trick，就是参数是 unsigned long 类型，这是为了让 <code>x &gt;&gt; 1</code> 运算是<strong>逻辑右移</strong>，千万不能用 signed 的类型，因为 <code>x &gt;&gt; 1</code> 是算数右移，所以对于负数而言永远不会停下；</p><p>下面是对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pcount_r:</span><br><span class="line">    movl$0, %eax</span><br><span class="line">    testq%rdi, %rdi</span><br><span class="line">    je.L6</span><br><span class="line">    pushq%rbx</span><br><span class="line">    movq%rdi, %rbx</span><br><span class="line">    andl$1, %ebx</span><br><span class="line">    shrq%rdi</span><br><span class="line">    callpcount_r</span><br><span class="line">    addq%rbx, %rax</span><br><span class="line">    popq%rbx</span><br><span class="line">.L6:</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure><p>你会发现递归版本的源码编译出的汇编代码可能稍微比之前迭代循环版本（loop）的汇编代码更长，这是因为递归版本需要额外管理栈的情况。</p><p>学完了前面几章节，你会发现这些代码就比较好懂了：</p><p>第一步将 <code>%rax</code>（<code>%eax</code>）置零，因为等会可能要 return 0；然后第二步按照 <code>x == 0</code> 的是真是假的答案来设置 condition codes，交由第三步判断并跳转。这是之前的 General Conditional Expression 的翻译方法；</p><p>接下来，将 <code>%rbx</code> 这个 callee-saved register 原来的值备份到当前栈帧中，是因为之后要用这个寄存器保存参数 x；果不其然，下一步就是把 <code>%rdi</code>（x）的值复制到 <code>%rbx</code> 中。</p><p>接下来用到 x 的地方，除了传给下一层 callee 的第一参数，就只有 <code>x &amp; 1</code> 了，所以直接在 <code>%rbx</code> 上与 1 按位且。下一步也直接在 <code>%rdi</code> 上逻辑右移 1 个单位，这就是传给下一层 callee 的第一参数（<code>x &gt;&gt; 1</code>）;</p><p>准备好 passing data 后，进行 passing control，调用 <code>call pcount_r</code> 进行跳转递归。</p><p>如果递归结束，那么紧接着就是把 <code>(x &amp; 1)</code>（即 <code>%rbx</code> 中的值）加到 callee 的结果（<code>%rax</code>）中，得到本函数的结果。最后别忘了在返回前从当前栈帧中恢复 callee-saved register <code>%rbx</code>，函数结束。</p><p>举完这个例子你会发现，这就是前几章所提到所有技巧的综合，它们使用了同一个约定——参数怎么传、可以用哪些寄存器、寄存器怎么用（还有是否要恢复）、如何参与计算等等。这个约定防止了不同函数在调用时相互摧毁寄存器中重要的值的异常情况。总之按照上面的方法使用寄存器，可以让生活更美好！</p><blockquote><p>补充一句，有些函数不依赖栈的结构来完成上述的机制，它们会采用堆或者其他数据结构来完成（例如 SML）。</p></blockquote><p>说了这么多，只有自己上手实践、自己亲自编译、调试这些代码，才能体会到各个部分、tricks、mechanisms 组合起来发挥的作用。</p><h2 id="5-5-Summary-for-Chapter-5"><a href="#5-5-Summary-for-Chapter-5" class="headerlink" title="5.5 Summary for Chapter 5"></a>5.5 Summary for Chapter 5</h2><p>本章的内容也是相当之多。为了进一步加深对于汇编 procedure 的认识，我们现在总结一下本章接触到的内容。</p><p>在本章开头，我们了解一种规范（接口）被称为 ABI，主要围绕 Linux ABI 展开介绍。ABI 规定了所有二进制程序、操作系统各个组件、编译器对于管理机器上的资源的使用规则，例如寄存器使用的场合和管理方法等等，这在之前的章节中也或多或少的提到过。</p><p>想要了解程序运行的总体 procedure，就不得不回答 3 个问题：<strong>程序是如何切换运行控制权的</strong>，<strong>程序如何传递数据的</strong>，还有<strong>程序如何在运行中管理 Memory 内存的</strong>；</p><p>为了搞清以上的问题，我们先了解了 x86 架构下的系统栈的简单结构。因为 C/C++ 是依赖于栈来管理程序上下文的语言，并且根据栈 LIFO 的原则，可以被用于：<strong>传递潜在信息、控制信息，分配 local 数据</strong>。正因如此，栈可以胜任<strong>管理过程中调用和返回状态</strong>的任务，也能隔离各个 procedure 示例之间的数据，为递归提供了坚实高效的结构基础。</p><p>x86 的栈需要注意的点有 3 个：</p><ul><li>栈就是在<strong>内存中的</strong>一段连续的数据结构，栈顶位于 low numbered address，栈底位于 high numbered address（头脑里有张图）；</li><li>栈顶指针由 <strong><code>%rsp</code></strong> 保存，一般不能手动修改，指向最上层被使用的空间，这意味着<strong>要先减小指针，再放入数据</strong>（或先取出数据，再增大指针）；</li><li>想要管理栈中的数据，依靠 <code>pushq</code> 和 <code>popq</code> 这两条指令，这两条指令的参数要求也有重大区别，可以思考一下为什么；</li></ul><p>随后考虑<strong>程序控制权切换的问题</strong>（Passing Control），具体表现就是<strong>调用时 caller 如何跳转到 callee、如何从 callee 返回到 caller</strong>。通过分析，passing control 由 3 个方面实现：</p><ul><li>系统<strong>栈</strong>提供数据结构存储层面的支持；</li><li>指令 <code>call &lt;LABLE&gt;</code> 通过：<strong>向栈中添加 return address</strong>、<strong>改变 <code>%rip</code> 的值来跳转至 callee</strong> 这两大工作来完成 caller 至 callee 的跳转；</li><li>指令 <code>ret</code> 通过：<strong>从栈中取出 return address</strong>、<strong>改变 <code>%rip</code> 的值来跳回 caller</strong> 这两大工作完成 callee 重新返回 caller 的控制流程。</li></ul><p>第二个点就是<strong>程序数据传输问题</strong>（Passing Data），在单线程程序中具体表现为 <strong>caller 如何向 callee 传递参数</strong>、<strong>callee 如何给 caller 返回值</strong>。在前几章的铺垫下，我们进一步记住了各个整型寄存器在 procedure 及其切换时的约定行为，例如 Caller-Saved / Callee-Saved、传入的函数参数由哪个寄存器  / 给出、函数的返回值由哪个寄存器传输。</p><p>前两个问题相对好解决，不过对于 <strong>程序如何在运行中管理 Memory 内存</strong> 这一部分而言，具体表现在进入 procedure 前如何为其分配空间、结束 procedure 前如何释放空间，需要较为详细地了解 x86 栈和<strong>栈帧</strong>的基本结构。对于 x86-64 Linux 而言，一个程序栈在<strong>当前函数实例</strong>中的栈帧从栈底到栈顶应该分别是：</p><ul><li>old <code>%rbp</code>（上一层 base pointer，如果本层也使用 <code>%rbp</code> 做 base pointer 的话，就指向此位置）；</li><li>上层 callee-saved register 备份值（Saved-Register）、local variables（函数局部变量）；</li><li>本函数作为 callee 时传入的超过 6 个的参数存放位置（依次，如果有的话）；</li><li>return address（如果本层函数是 caller，并且正好运行到 <code>call</code> 指令结束时）；</li></ul><p>每个函数结束后能否完全释放栈帧并回到原位、调用其他函数时能否准确分配足够的空间，则<strong>依赖代码的自身管理</strong>。</p><p>搞清了总体 procedure 的样貌，我们进一步讨论了各个寄存器的细节层面的管理约定。包括以下问题：</p><ul><li>Caller-Saved Register 和 Callee-Saved Register 各自有哪些种类和定义；</li><li>什么时候使用 Caller/Callee-Saved Register，在使用前后应该做哪些处理工作；</li><li>为什么要使用 Caller/Callee-Saved Register，栈中的 “Save-Register” 数据是怎么回事。</li></ul><p>到了本章结束，我们已经能从大致轮廓上认识一个程序运行的 procedure，仅限于整数、长整数、指针的数据传递的工作。</p><p>更多的细节，例如之前提到的<strong>浮点数如何传递、保存（浮点寄存器的行为）</strong>，<strong>聚合数据结构在汇编层面如何实现</strong>，等问题，会在下一章进行介绍。</p><h1 id="Chapter-6-Machine-Level-Programming-Ⅳ-Data"><a href="#Chapter-6-Machine-Level-Programming-Ⅳ-Data" class="headerlink" title="Chapter 6. Machine Level Programming Ⅳ - Data"></a>Chapter 6. Machine Level Programming Ⅳ - Data</h1><p>之前我们所见到的程序都是操纵正数 / 长整数 / 指针，它们都是<strong>标量整型数据</strong>。本章将讨论浮点寄存器的情形和聚合数据结构在汇编代码中的实现。</p><h2 id="6-1-Arrays-in-Assembly"><a href="#6-1-Arrays-in-Assembly" class="headerlink" title="6.1 Arrays in Assembly"></a>6.1 Arrays in Assembly</h2><h2 id="6-1-1-Array-Access-Normal-Array"><a href="#6-1-1-Array-Access-Normal-Array" class="headerlink" title="6.1.1 Array Access: Normal Array"></a>6.1.1 Array Access: Normal Array</h2><p>众所周知，数组在 C/C++ 中声明的语法为 <code>T A[L];</code>，表示 Array of data type <code>T</code> and length <code>L</code>；</p><p>这说明了 2 件事：</p><ol><li>数组应该在内存中分配的方式：<strong>Contiguously allocated region of <code>L * sizeof(T)</code> bytes in memory</strong>;</li><li>identifier <code>A</code> 可以被用作<strong>指向数组开头位置的指针（类型 <code>T*</code>）</strong>；</li></ol><blockquote><p>下面的方法都是合理的，请试着分析表达式的含义（<code>val</code> 的类型是 <code>int*</code>）：</p><p><code>val[4]</code>、<code>val</code>、<code>val + 1</code>、<code>&amp;val[2]</code>、<code>*(val + 1)</code>、<code>*val + 1</code>;</p><p>提示：对于指针类型 <code>T*</code> 的增、减运算而言，单位 1 会是 <strong><code>sizeof(T)</code></strong>，也就是说，对这个指针增加 1，那么指针的值实际增加 <code>sizeof(T)</code>；</p><p><strong>补充 C/C++ 基础-1</strong>：指针和数组变量的区别之一是，改变数组变量 <code>val</code> 不是正确的，因为 <code>val</code> 是指针常量；</p></blockquote><hr><p>现在看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZLEN 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> zip_dig[ZLEN];</span><br><span class="line"></span><br><span class="line">zip_dig cmu = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">zip_dig mit = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">zip_dig ucb = &#123; <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>一些编程建议：① 不要将常数随便写死在程序的各个角落，这被称为 magic number，不但不利于阅读，也不利于维护；② 对于 C/C++ 中复杂的数据类型的定义，建议使用 <code>typedef</code> 关键字，这样可以提升可读性；</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_digit</span><span class="params">(zip_dig z, <span class="type">int</span> digit)</span> &#123; <span class="keyword">return</span> z[digit]; &#125;</span><br></pre></td></tr></table></figure><p>上面这个函数的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_digit:</span><br><span class="line">    movl(%rdi, %rsi, 4), %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>由于数组标识符也是指针，因此传入的方式和之前的相同。上面的指令含义是找到地址为 <code>%rdi + 4 * %rsi</code> 的 memory 引用，并将这里的值赋给 <code>%rax</code> 的 low-order 32-bit（<code>%eax</code>）;</p><p>4  就是编译器自己加上的对于 <code>int</code> 类型大小的缩放因子。</p><p>再来一段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zincr</span><span class="params">(zig_dig z)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ZLEN; i++)</span><br><span class="line">        z[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zincr:</span><br><span class="line">    movl$0, %eax</span><br><span class="line">    jmp.L3</span><br><span class="line">.L4</span><br><span class="line">    addl$1, (%rdi, %rax, 4)</span><br><span class="line">    addq$1, %rax</span><br><span class="line">.L3</span><br><span class="line">    cmpq$4, %rax</span><br><span class="line">    jbe.L4</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure><p>这里汇编代码对 for 循环的处理是转化为 while 循环并采用 “jump to middle” translation；</p><p>首先初始化部分将 <code>%rax</code> 置零作为存放 i 的寄存器，接着跳至 <code>.L3</code> 判断部分；</p><p><code>.L3</code> 判断部分将 <code>%rax</code>（i）和 4 比较，只有 unsigned <code>i ≤ 4</code>（<code>CF | ZF</code>）时才进入 <code>.L4</code> 循环；</p><p>在 <code>.L4</code> 循环中，先将地址为 <code>%rdi + 4 * %rax</code> 的 memory 引用处的数据加 1，并且将 <code>%rax</code> 中的数据加 1（<code>i++</code>）；</p><hr><blockquote><p><strong>补充 C/C++ 基础-2</strong>：为了掌握 C/C++ 数组的核心思想，你必须能够理解以下的声明的含义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A1[<span class="number">3</span>];        <span class="comment">// 一个长度为 3 的整型数组</span></span><br><span class="line"><span class="type">int</span> *A2[<span class="number">3</span>];        <span class="comment">// 一个长度为 3 的整型指针 构成的数组</span></span><br><span class="line"><span class="type">int</span> (*A3)[<span class="number">3</span>];    <span class="comment">// 一个指向 长度为 3 的整型数组 的指针</span></span><br></pre></td></tr></table></figure><p><strong>提示：C/C++ 阅读类型声明的关键是从内向外读，这条道理不仅适用于上面的 <code>int (*A3)[3]</code>，还适用于函数指针等复杂类型的阅读</strong>。例如 <code>int**(*)(int*, int)</code> 是指向参数表为 <code>(int*, int)</code>、返回值类型为 <code>int**</code> 的函数的指针。</p><p><strong>补充 C/C++ 基础-3</strong>：数组变量和指针的区别之一是，在声明数组时程序不仅会为数组标识符这个指针来分配空间，而且会为数组中的所有元素分配空间；但指针只会为自身分配空间。这就导致<strong>二者调用 <code>sizeof</code> 的大小是不同的</strong>；例如 <code>sizeof(A3) == 8</code>，<code>sizeof(*A3) == 12</code>，<code>sizeof(**A3) == 4</code>;</p><p>⚠ 另外，如果想判断什么类型的指针取 <code>*</code> 后会导致野指针 / 空指针引用错误，应该想想<strong>在一开始声明的时候，程序有没有为其自动分配空间</strong>。例如上面的例子，如果使用 <code>*A3</code> 则可能出现空指针引用错误，但 <code>*A2</code> 就不会。</p></blockquote><p>为什么要 “补充 C/C++ 基础 1~3” ？<strong>因为只有清楚了解程序的源码表示的含义，才能去关注、正确认识编译后的代码</strong>。</p><h2 id="6-1-2-Array-Access-Two-Dimension-Array"><a href="#6-1-2-Array-Access-Two-Dimension-Array" class="headerlink" title="6.1.2 Array Access: Two Dimension Array"></a>6.1.2 Array Access: Two Dimension Array</h2><blockquote><p>⚠ 本节讨论的 array 规模全部是 <code>constexpr</code>（编译前确定）；</p></blockquote><p>这个时候我们再看二维数组的真实含义。</p><p>⚠ <strong>注意：由上面的讨论可知，一共有 2 类二维数组，尽管源码的使用上是一样的，但汇编层面完全不同！！！</strong></p><ul><li><p>Nested Array</p><ul><li><p>在 C/C++ 中，一种二维数组的声明语法为 <code>T A[R][C];</code>，其实是 <code>T[C] A[R];</code> 的另一种写法，表示 <strong><code>A</code> 是一个包含 <code>R</code> 个元素的数组，其元素是包含 <code>C</code> 个元素的数组</strong>。</p></li><li><p>这种数组被称为 <strong>Nested array</strong>，特点是二维数组中<strong>所有元素的空间在声明时都被自动分配了，更重要的是，它们是连续的</strong>。</p></li><li><p>另一个需要关注的点是，<strong>Nested array 是 “Row-Major” 的，即行优先，第一个索引应该指定行，并且分配空间、存储时，连续的部分也是行，又称 Row Vectors</strong>。</p></li><li><p>Nested Array 的每个行向量 <code>A[i]</code> 开始的地址是 <strong><code>A + i * C * sizeof(T)</code></strong>，每个元素 <code>A[i][j]</code> 的地址是 <strong><code>A + (i * C + j) * sizeof(T)</code></strong>（由 <code>A + i * C * sizeof(T) + j * sizeof(T)</code> 化简得来）;</p></li></ul></li></ul><p><img src="imgs/nested_array.png" height="200px"></p><ul><li>Multi-Level Array<ul><li>另一种二维数组的声明方式是 <code>T* A[R];</code>，随后在初始化中（在栈中）/ new 上（在堆中）数组的各个元素。</li><li>这种数组称为 <strong>Multi-level array</strong>，在声明时，<strong>仅为每个一级元素（<code>int*</code>）进行了空间分配</strong>。</li><li><strong>事实上，这种声明的数组每一行的存储位置可以不是连在一起的，甚至每一行的元素可以不同</strong>！因此每个元素的地址计算应该<strong>取决于 <code>A</code> 中每个元素的值</strong>！没法通过标识符 <code>A</code> 直接取得。</li></ul></li></ul><p><img src="imgs/multi_level_array.png" height="200px"></p><hr><p>我们继续利用之前 <code>zip_dig</code> 的例子，我们分别声明两种类型的二维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PCOUNT 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UCOUNT 3</span></span><br><span class="line"></span><br><span class="line">zip_dig pgh[PCOUNT] = &#123;                    <span class="comment">// Nested array</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> *univ[UCOUNT] = &#123; mit, cmu, ucb &#125;;    <span class="comment">// Multi-level array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里分别是使用它们的两个函数</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">get_pgh_zip</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="keyword">return</span> pgh[index]; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_univ_digit</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> digit)</span> &#123; <span class="keyword">return</span> univ[index][digit]; &#125;</span><br></pre></td></tr></table></figure><p>这时对应函数的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">get_pgh_zip:</span><br><span class="line">    leaq(%rdi,%rdi,4), %rax</span><br><span class="line">    leaqpgh(,%rax,4), %rax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">get_univ_digit:</span><br><span class="line">    salq$2, %rsi</span><br><span class="line">    addquniv(,%rdi,8), %rsi</span><br><span class="line">    movl(%rsi), %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>注意到，这里使用的 <code>pgh</code>、 <code>univ</code> 是全局变量，不存储在栈中，意味着在汇编代码中<strong>可以直接使用变量名称来表示全局变量</strong>。有些时候，编译器输出的汇编代码对于全局变量的处理中也会<strong>直接使用地址</strong>。</p><p>注意！这时候两个数组的索引方式就有差别了。</p><p>对于使用 Nested array 的函数 <code>get_pgh_zip</code> 而言，第一步是相当于进行算术计算 <code>%rax = 5 * %rdi</code>，第二步还是相当于算术计算 <code>%rax = pgh + 4 * %rax</code>。这两步的真实含义是：<code>%rax = pgh + sizeof(int) * 5 * index</code>，这里的 5 就是之前提到的<strong>每列列宽</strong>；</p><p>它可以表示：<code>&amp;Memory[pgh + 5 * sizeof(int) * index]</code>，取得其中的指针；</p><p>对于使用 Multi-level array 的函数 <code>get_univ_digit</code> 而言，<strong>事情完全不一样！</strong></p><p>第一步将 <code>%rsi</code> 的值（<code>digit</code>）乘以 4，没什么好说的；</p><p>第二步注意，这里不是 <code>leaq</code> 而是 <code>addq</code>，说明这里先取得 <code>univ + 8 * %rdi</code> 中的值，并把它看作地址，找到 memory 中该地址对应的引用值。最后把 <code>%rsi</code> 加上引用值;</p><p>这两步<strong>没法写出真实含义的表达式，因为涉及 memory 取值。但可以表示为</strong>：</p><p><code>Memory[Memory[univ + sizeof(int*) * index] + sizeof(int) * digit]</code>;</p><p>最后 <code>get_univ_digit</code> 才把计算好的地址使用 Simple Memory Addressing Mode 取出值，并赋给 <code>%rax</code>（<code>%eax</code>）;</p><hr><p>对比上面两种二维数组的汇编操作，这说明了不同的结构决定了不同的计算方法。前者只需要对<strong>数组标识符</strong>和<strong>索引</strong>进行算术计算，就能得到地址；而后者必须先由<strong>数组标识符</strong>和<strong>行参数</strong>找到一级元素内容，然后用<strong>一级元素内容</strong>和<strong>列索引</strong>才能定位具体的元素位置。</p><h2 id="6-1-3-Array-Access-M-×-N-Matrix"><a href="#6-1-3-Array-Access-M-×-N-Matrix" class="headerlink" title="6.1.3 Array Access: M × N Matrix"></a>6.1.3 Array Access: M × N Matrix</h2><ul><li>对于恒定（constexpr）规模、声明时已分配内存的矩阵而言，就是上一节说的 Nested array；</li><li>对于作为参数传入的 Nested array（未知规模，但空间连续），则必须进行乘法计算（开销较大）结合其他算术计算得出位置；</li></ul><p>总而言之，访问数组的思路就是之前说的 Multi-level array 和 Nested array 两类。其他情况可以同理思考。</p><h2 id="6-2-Structures-in-Assembly"><a href="#6-2-Structures-in-Assembly" class="headerlink" title="6.2 Structures in Assembly"></a>6.2 Structures in Assembly</h2><h2 id="6-2-1-Structure-Representation"><a href="#6-2-1-Structure-Representation" class="headerlink" title="6.2.1 Structure Representation"></a>6.2.1 Structure Representation</h2><p>关于结构体的存储和表示，有下面的 3 条简单规则：</p><ul><li><p>结构体本身在内存中的表示是<strong>连续的</strong>，并且 “big enough to hold all of the fields”；</p></li><li><p>结构体中各个字段在内存中的排布顺序<strong>严格</strong>按照源码中的<strong>声明顺序</strong>；</p></li><li><p><strong>编译器来决定所有字段存储的空间和字节偏移、对齐情况</strong>（相对结构体地址的位置）；</p><blockquote><p>整个过程对汇编层面透明，汇编代码是看不出来这里定义了一个结构体的，只能看到一系列变量排列在内存上；</p></blockquote></li></ul><h2 id="6-2-2-Structure-Access-Generate-Pointer-to-Structure-Member"><a href="#6-2-2-Structure-Access-Generate-Pointer-to-Structure-Member" class="headerlink" title="6.2.2 Structure Access: Generate Pointer to Structure Member"></a>6.2.2 Structure Access: Generate Pointer to Structure Member</h2><p>其实通过 structure representation 就能略知如何用指针找各个字段了。这里以一个例子说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rec</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">get_ap</span><span class="params">(<span class="keyword">struct</span> rec *r, <span class="type">size_t</span> idx)</span> &#123; <span class="keyword">return</span> &amp;r-&gt;a[idx]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_val</span><span class="params">(<span class="keyword">struct</span> rec *r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (r) &#123;</span><br><span class="line">        <span class="type">int</span> i = r-&gt;i;</span><br><span class="line">        r-&gt;a[i] = val;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get_ap</code> 函数对应的汇编代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_ap:</span><br><span class="line">    leaq(%rdi,%rsi,4), %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这里的操作表明了 <code>%rax = %rdi + 4 * %rsi</code>，即 <code>%rax = r + sizeof(int) * idx</code>。这说明了 <code>struct rec</code> 中的第一个成员就位于 <code>rec</code> 空间的开头，并按正常的整型数组进行排列。</p><p>但是对于另外一个函数 <code>set_val</code> 而言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set_val:</span><br><span class="line">.L11:</span><br><span class="line">    movslq16(%rdi), %rax</span><br><span class="line">    movl%esi, (%rdi,%rax,4)</span><br><span class="line">    movq24(%rdi), %rdi</span><br><span class="line">    testq%rdi, %rdi</span><br><span class="line">    jne.L11</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>第一步可以认为 <code>movslq</code> 就是 <strong>取 <code>Src</code> 的 32-bit 数据，符号扩展为 64-bit 数据后放入 <code>Dst</code></strong>，作用是将地址为 <code>%rdi + 16</code>（即 <code>r + 4 * sizeof(int)</code>）的 memory 引用的值覆盖到 <code>%rax</code> 上去。完成了源码的 <code>int i = r-&gt;i;</code> 这一步；</p><p>从这里可以看出，编译器将 <code>int a[4]</code>、<code>int i</code> 和 <code>struct rec* next</code> 这三个成员排在一起，<strong>是没有间隔的，如下图。但某些场合下编译器指定可能会出现间隔</strong>，这是是为了<strong>内存对齐的原因，下面马上会讨论结构体的内存对齐</strong>。</p><p><img src="imgs/struct_example.png" height="150px"></p><p>第二步 <code>movl</code> 将 <code>%esi</code>（<code>%rsi</code> 的 low-order 32-bit）的值赋给地址为 <code>%rdi + 4 * %rax</code>（即 <code>r + sizeof(int) * i</code>）的 memory 引用，完成了 <code>r-&gt;a[i] = val;</code> 这步；</p><p>第三部让 <code>%rdi</code> 的值变为 “地址为 <code>%rdi + 24</code> 的 memory 引用的值”，相当于 <code>r = r-&gt;next;</code></p><p>剩下的部分就是完成 while 循环的判断任务。</p><p><strong>上面的例子中，还有一个重要的问题没有阐释——结构体的内存对齐问题</strong>。</p><p>那么为什么要对结构体进行内存对齐？又是如何进行内存对齐的？再来看另外一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure><p>对于这个结构体而言，如果每个成员紧紧挨在一起，那么在内存中的排布是这样的：</p><p><img src="imgs/struct_example2_unaligned.png" height="60px"></p><p>但实际上编译器会在其中插入一些空数据块，让内存排布变成这样：</p><p><img src="imgs/struct_example2_aligned.png" height="125px"></p><p>这就是因为，x86-64（和其他很多架构的机器）规定了结构体内存对齐的规则。为什么要有这样的规则？这其实是 <strong>硬件效率问题</strong>。</p><p>对于当今大多数机器的内存系统而言，实际从硬件内存中一次读取的数据量大约 64 bytes，本身称为一个读取的<strong>数据块</strong>，大小取决于机器硬件中的各种宽度。所以，如果因为没有对齐的地址，而导致读取时特定的数据跨越了两个数据块的边界，那么很可能会导致操作系统需要采取一些额外的步骤来处理这种情况，从而大大降低处理效率。</p><p>除了上面的这种原因，还有种原因是，如果这些未对齐的结构体组成了数组，那么想要<strong>索引</strong>这些数组的计算将会非常复杂，<strong>使用起来也非常不方便</strong>。</p><p>鉴于以上原因，很多架构都采用了这种内存对齐的思路。其实内存对齐除了在结构体这里，我们之前在 “跳表” 的汇编代码（4.4）中也看到了内存对齐的指令（<code>.align</code>）；</p><blockquote><p>如果某种编译器编译程序时，没有安排内存对齐，那么在 x86-64 的架构上运行是没有问题的，因为微架构中有解决这个问题的方法（重新读入），速度可能会慢一点；但有些架构完全不能运行，会抛出内存错误的异常。</p></blockquote><p>那么如何对齐能够解决上面的问题？x86-64 架构提出了以下<strong>内存对齐的原则</strong>：</p><ol><li><p><strong>Primitive data type requires K bytes, so its address must be multiple of K</strong>;</p><p>如果原始数据类型的大小是 K bytes，那么它（所对应成员）的起始地址必须能被 K 整除。</p><blockquote><p><strong>现在提出一个 “对齐整除数” 的定义：一个数据结构位于结构体 / 联合体中时，地址需要为一个数 K 的整数倍，这个 K 就是该数据结构的 “对齐整除数”</strong>；</p><p>因此，最直接的结论是：primitive data（基础数据类型）的对齐整除数是其自身的大小（切记，由于概率原因，非基础数据类型的对齐整除数通常都不是自身大小，所以一定不能想当然）。</p><p>primitive data 包括：<strong>所有 size 的整型（short / int 等）、所有 size 的浮点型、char、bool（C 中没有）</strong>；</p><p>数组、结构体都不是 primitive data，所以它们的对齐整除数满足：</p><p>如果结构体中存在<strong>数组</strong>，则<strong>本身不存在对齐要求，因此它的对齐整除数一定是单个元素的对齐整除数</strong>，因为数组各元素大小相同，并且不存在 padding 的情况，直接将各个元素无缝堆砌；</p><p>如果结构体中存在<strong>结构体 / 联合体</strong>成员，那么该成员的<u>对齐整除数</u>以<strong>其中最大的原始数据类型的</strong>为准；</p></blockquote></li><li><p><strong>Overall structure length must be multiple of $\max\limits_{i}{K_i}$, where $\max\limits_{i}{K_i}$ is the largest alignment requirement in this structure</strong> (otherwise “external padding”).</p><p>结构体 / 联合体总体的大小必须是其<strong>所有成员中最大的对齐整除数</strong>的整数倍。（满足上一条后，编译器可以通过在结构体尾部追加空数据块来实现）</p></li></ol><p>例如：</p><ul><li>对于 1 byte 的数据类型（如 <code>char</code>），这种类型成员在内存上的排布没有限制，哪里有空往哪搬；</li><li>对于 2 bytes 的数据类型（如 <code>short</code>），这种类型成员要求起始地址必须能被 2 整除（即 LSB of address must be $0_2$）；</li><li>对于 4 bytes 的数据类型（如 <code>int, float</code>），要求起始地址必须能被 4 整除（即 lowest 2 bits of address must be $00_2$）；</li><li>对于 8 bytes 的数据类型（如 <code>double, long, x86-64下各种 pointer</code>），要求起始地址必须能够被 8 整除（即 lowest 3 bits of address must be $000_2$）；</li><li>对于 16 bytes 的数据类型（如 <code>x86-64 gcc/Linux下的 long double</code>），要求起始地址必须能被 16 整除（即 lowest 4 bits of address must be $0000_2$）；</li></ul><p>再例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure><p>这个结构体的内存对齐方式如下：</p><p><img src="imgs/struct_example2_aligned_tail.png" height="125px"></p><p>因为其中含有 <code>double</code> 数据类型，所以总体大小必须是 8 的整数倍；又因为整体长度不是 8 的整数倍（<code>p + 17</code>），所以尾部补充空数据块到 <code>p + 24</code>;</p><h2 id="6-2-3-Accessing-Arrays-of-Structure"><a href="#6-2-3-Accessing-Arrays-of-Structure" class="headerlink" title="6.2.3 Accessing Arrays of Structure"></a>6.2.3 Accessing Arrays of Structure</h2><p>更进一步地，如果有一个结构体数组，并且结构体是被正确定义的，那么编译器就能很容易地确定各个结构体的大小、成员位置和数组的大小，从而在其他使用到的场合为其正确地分配空间、索引成员；</p><p>来看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> i;</span><br><span class="line">    <span class="type">float</span> v;</span><br><span class="line">    <span class="type">short</span> j;</span><br><span class="line">&#125; a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>如果你使用 <code>sizeof(S3)</code> 的话，你会发现值是 12，说明编译器生成的空数据块的大小也计算在内。具体的结构如下图所示，在 <code>i</code> 和 <code>v</code> 成员间、结构体尾部都有分配空数据块：</p><p><img src="imgs/struct_example3.png" height="125px"></p><p>还有使用它的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="title function_">get_j</span><span class="params">(<span class="type">int</span> idx)</span> &#123; <span class="keyword">return</span> a[idx].j; &#125;</span><br></pre></td></tr></table></figure><p>对照 <code>S3</code> 结构体的内存分布图，你就会发现这个函数的汇编代码也没有那么难以理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get_j:</span><br><span class="line">    leaq(%rdi,%rdi,2), %rax</span><br><span class="line">    movzwla+8(,%rax,4), %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>我们来解释上面例子的汇编行为：</p><p>第一步是相当于算术运算 <code>%rax = 3 * %rdi</code>;</p><p>第二步是 <code>%rax = a + 8 + 4 * %rax</code>，实质上是 <code>%rax = a + 8 + 4 * 3 * idx</code>，对照上面的内存分布情况可以理解，<code>a + 8</code> 就指向 <code>a[0].j</code>，而后面加 <code>4 * 3 * idx</code> 则是因为每个结构体占位 <code>4 * 3 bytes = 12 bytes</code> 的空间，这样就对应着 <code>a[idx].j</code> 的位置了。</p><blockquote><p><strong>这里的总结一下遇到的乱七八糟的 <code>movXXX</code> 指令</strong>。</p><p><code>movzbl</code> 和 <code>movsbl</code> 的作用相近，都是<strong>将 8-bit 扩展到 32-bit</strong>。但前者是 <strong>zero extension</strong> 零扩展（根据 <strong>extension conclusion</strong>，针对 unsigned 的扩展），而后者是 <strong>sign extension</strong> 符号扩展（针对 signed 的扩展）；</p><p><code>movzwl</code> 和 <code>movswl</code> 很像，前者是 16-bit（1 word）<strong>零扩展移动</strong>至 32-bit，后者是 16-bit <strong>符号扩展移动</strong>至 32-bit（long）；</p><p><code>movslq</code> 同理。</p><p>⚠ <strong>值得注意的是，<code>movzlq</code> 指令不存在，因为它的字面作用和 <code>movl</code> 相同，想想为什么</strong>。</p><p><strong>如果你会看指令名称的含义的话，上面的内容就无需记忆了</strong>：在 <code>mov&lt;A&gt;&lt;B&gt;&lt;C&gt; &lt;Src&gt;, &lt;Dst&gt;</code> 中，</p><p>A 表示扩展种类，可以是 <code>z</code>（zero extension）、<code>s</code>（sign extension）；</p><p>B 表示扩展源（<code>Src</code>）的大小，可以是 <code>b</code>（1 byte，8 bits），<code>w</code>（word，1 字，16 bits）、<code>l</code>（2 字，32 bits）、<code>q</code>（quadword，4 字，64 bits）；</p><p>C 表示扩展目标（<code>Dst</code>）的大小，可以取的值和 B 相同，但两者不能同时取一个值。</p><p>除此以外就是普通的 <code>mov&lt;X&gt;</code>（没有扩展功能）和条件移动 <code>cmov&lt;cond&gt;</code> 指令了。 </p></blockquote><h2 id="6-2-4-Saving-Space"><a href="#6-2-4-Saving-Space" class="headerlink" title="6.2.4 Saving Space"></a>6.2.4 Saving Space</h2><p>现在，我们了解了结构体的基本排布和表示，也知道了结构体内存对齐的规则。有些同学可能会发现，诶，因为结构体各成员在内存中的排布顺序严格按照源码声明的顺序，那么<strong>结构体中各个成员排布的不同，是不是会导致结构体最终所占的大小不同？</strong></p><p>答案是肯定的，所以，有必要讨论一下 “按什么方式声明结构体，能够让指定结构体的空间占用最小” 这个问题。下面是结论：</p><ul><li><p><strong>将占用空间较大的数据类型声明在前面</strong>。</p><blockquote><p>这种贪心算法是有效的。因为所有数据类型的大小只有 1、2、4、8、16 bytes，全是 2 的整数次幂，在数学上来说能够严格证明。</p></blockquote></li></ul><p>下面的例子中，<code>S4</code> 和 <code>S5</code> 相比，<code>S5</code> 更节省空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125; *p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S5</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure><h2 id="6-3-Floating-Point-in-Assembly"><a href="#6-3-Floating-Point-in-Assembly" class="headerlink" title="6.3 Floating Point in Assembly"></a>6.3 Floating Point in Assembly</h2><h2 id="6-3-1-History-amp-Background-for-Representing-FP"><a href="#6-3-1-History-amp-Background-for-Representing-FP" class="headerlink" title="6.3.1 History &amp; Background for Representing FP"></a>6.3.1 History &amp; Background for Representing FP</h2><p>在 x86 架构中，floating point 的表示有着比较深的历史。</p><p><strong>x87 FP</strong></p><p>很早之前，Intel 的 8087 芯片和 IEEE 浮点数标准一起诞生，安装在 8086 处理器上，是第一个能够完全处理 IEEE 浮点数运算的集成单元。但是编程模型从现在看来比较糟糕，所以 CSAPP 第三版就把这方面的内容完全移除了（expunged）；</p><p><strong>MMX FP</strong></p><p>1997 年 Intel 公司推出了多媒体扩展指令集 MMX，它包括57条多媒体指令。MMX 指令主要用于增强 CPU 对多媒体信息的处理能力，提高 CPU 处理 3D 图形、视频和音频信息的能力。</p><p><strong>SSE FP</strong></p><p>随着人们日益增长的精神文化的需要，例如核显渲染的浮点数运算需求增长，人们迫切需要并行计算的手段，于是一个全新的思路就出现了——<strong>SIMD（Single Instruction Multiple Data），单指令多数据</strong>，和整型寄存器不一样，我们在浮点数寄存器上多放几个数同时计算，那么运算速度不就上去了？</p><p>紧接着，一套新的指令拓展集 SSE（Streaming SIMD Extension）被设计出来，兼容 MMX 指令，配合一套浮点寄存器，来完成标量浮点数，或者单指令多数据的浮点数的计算。</p><p><strong>AVX FP</strong></p><p>在2010 年 AVX 将之前浮点运算数据的宽度从 128 bits 的扩展到 256-bits。同时新的 CPU 架构下数据传输速度也获得了提升。AVX 指令集在 SIMD 计算性能增强的同时也沿用了的 MMX/SSE 指令集。不过和 MMX/SSE 的不同点在于，增强的 AVX 指令在指令的格式上也发生了很大的变化。x86 (IA-32/Intel 64) 架构的基础上增加了prefix，所以实现了新的命令，也使更加复杂的指令得以实现，从而提升了 x86 CPU的性能。</p><blockquote><p>AVX 并不是 x86 CPU 的扩展指令集，可以实现更高的效率，同时和 CPU 硬件兼容性也更好，在 SSE 指令的基础上 AVX 也使 SSE 指令接口更加易用；</p></blockquote><h2 id="6-3-2-Programming-with-SSE3"><a href="#6-3-2-Programming-with-SSE3" class="headerlink" title="6.3.2 Programming with SSE3"></a>6.3.2 Programming with SSE3</h2><p>在 SSE 第 3 版中，指明了 x86 架构有 <strong>16 个 floating point registers</strong>（和之前的 16 个 integer registers 完全不同），每个 floating point register 空间大小 <strong>16 bytes</strong>（大概是 integer register 的两倍大）；</p><p>它们又叫 <code>XMM</code> Register（名称的历史渊源比较多，此处省略，感兴趣看 CSAPP 原书 P294），所以这些寄存器的名称：<code>%xmm0 ~ %xmm15</code>;</p><p>其中，按照<strong>指令使用的不同</strong>，每个 <code>XMM</code> Register 都可以存储：</p><ul><li>16 个 1 byte 整型（<code>char</code>）；</li><li>或 8 个 2 bytes 整型（<code>short</code>）；</li><li>或 4 个 4 bytes 整型（<code>int</code>）；</li><li>或 4 个 单精度浮点数（<code>float</code>）；</li><li>或 2 个双精度浮点数（<code>double</code>）；</li><li>或 1 个 单精度浮点数（<code>float</code>，没存满，有剩余空间）；</li><li>或 1 个 双精度浮点数（<code>double</code>，没存满，有剩余空间）；</li></ul><p><img src="imgs/xmm_registers.png" height="400px"></p><p>这意味着浮点数寄存器<strong>既可以处理整型，又可以处理浮点数类型</strong>；<strong>既可以处理一个数的运算，又可以多个数并行运算</strong>。</p><p>这种一次计算单个数的指令被称为 <strong>Scalar Operations（标量运算）</strong>，一次并行计算多个数的指令被称为 <strong>SIMD Operations（单指令多数据运算）</strong>。</p><p>具体的命令长什么样子的呢？还是经典的 <strong>名称+后缀</strong> 命名方法，所以如果你能读懂命名方法，那就不用记忆太多的指令了。</p><p>对于浮点数运算而言，主要有 4 种指令：<code>addss</code>、<code>addps</code>、<code>addsd</code>、<code>addpd</code>；</p><p>会读的同学已经懂了，就是 <code>&lt;OP_NAME&gt;&lt;OP_TYPE&gt;&lt;DATA_TYPE&gt;</code> 的组合嘛！</p><ul><li><p><code>OP_NAME</code> 就是运算的名称，这里是 <code>add</code> 加法运算（显然还有 <code>mov</code> 移动、<code>sub</code> 减法等等）；</p></li><li><p><code>OP_TYPE</code> 是运算类型，上面提到的 <code>s</code> 代表 Scalar 标量运算（一次算一个数），<code>p</code> 代表 Packed 多数据运算（一次算一组数）；</p><blockquote><p>特别地，如果强调是对齐的数据，那么 <code>OP_TYPE</code> 还有前缀 <code>a</code> 代表 aligned，例如：<code>movapd</code>;</p></blockquote></li><li><p><code>DATA_TYPE</code> 是运算的数据类型，<code>s</code> 代表 Single precision floating point，<code>d</code> 代码 Double precision floating point；</p></li></ul><p>所以举个例子，<code>addpd</code> 就是双精度浮点数的 SIMD 加法运算指令嘛！</p><p>运算的参数和之前的整型寄存器运算一样，<code>&lt;Src&gt;, &lt;Dst&gt;</code>;</p><p>运算的内存表示就是如图：</p><p><img src="imgs/sse_fp_addition.png" height="400px"></p><p>除此以外，FP 还有 <strong>2 点</strong>需要注意：</p><ol><li><p>FP Registers 的 Saving Conventions：</p><ul><li><p><code>%xmm0 ~ %xmm15</code> 就是依次传递参数的 register，参数多于 15 个浮点数类型，则和多出 6 个的整型参数一样，会放到栈帧中去；</p></li><li><p><code>%xmm0</code> 也是约定<strong>返回浮点数值</strong>的存放位置；</p></li><li><p><strong>所有的 <code>XMM</code> Register 都是 Caller-Saved Register</strong>，没有 Callee-Saved Register；</p></li></ul></li><li><p>FP 的还有众多的命令等待认识，不过最重要的还是之前提到的<strong>记忆指令的命名方法</strong>，理解了命名方法就能更少地记忆指令；</p><ul><li><p>FP 数据比较指令：<code>ucomiss</code>（Unordered Compare Scalar Single Precision Floating Point）、<code>ucomisd</code>（Unordered Compare Scalar Double Precision Floating Point）；</p><blockquote><p>和 <code>cmpq</code> 大致相似，会设置 condition codes，包括 <code>CF/ZF/SF</code>；</p></blockquote></li><li><p>FP 常数使用：这里 <code>$</code> 符号<strong>只能</strong>接整型常量，所以如果要使用浮点数常量，需要 <code>xorpd %xmm0 %xmm0</code> 等类似指令运算出 / 从内存中读入才能使用。</p></li></ul></li></ol><p>事实上，之前我们一直担心的 “<strong>浮点数如何通过寄存器传递参数</strong>” 等问题，只要有了命令就非常简单，操作方法几乎和 integer registers 一样。下面是一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">fadd</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">dadd</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">dincr</span><span class="params">(<span class="type">int</span>* p, <span class="type">double</span> v)</span> &#123;</span><br><span class="line">    <span class="type">double</span> x = *p;</span><br><span class="line">    *p = x + v;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fadd:</span><br><span class="line">    addss%xmm1, %xmm0</span><br><span class="line">    ret</span><br><span class="line">dadd:</span><br><span class="line">    addsd%xmm1, %xmm0</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">dincr:</span><br><span class="line">    movapd%xmm0, %xmm1</span><br><span class="line">    movsd(%rdi), %xmm0</span><br><span class="line">    addsd%xmm0, %xmm1</span><br><span class="line">    movsd%xmm1, (%rdi)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>函数 <code>fadd</code> 和 <code>dadd</code> 没有什么好说的，主要看 <code>dincr</code>：</p><p>第一步 <code>movapd</code> 见名知意，Move Aligned Packed Double Precision Floating Point，成组移动双精度浮点数，参数类型和其他的 <code>mov</code> 指令相同；</p><p>这里的 <code>%xmm0</code> 里装的是<strong>函数第二参数 <code>double v</code></strong>（第一参数是指针整型，所以放在 <code>%rdi</code>），移动到了未使用到的 <code>%xmm1</code> 寄存器中；</p><p>第二步 <code>movsd</code>，Move Scalar Double Precision Floating Point，移动标量双精度浮点数，将地址为 <code>%rdi</code> 的 memory 引用值（也就是 <code>p</code> 指向的内存 double 数据）赋给 <code>%xmm0</code>（x），并且最终将作为返回值返回；</p><p>第三步就是标量将 <code>%xmm0</code> 的数据（x）加到 <code>%xmm1</code> 的值（v）上，完成了 <code>*p = x + v;</code></p><p>第四步就将计算结果 <code>%xmm1</code> 的值（t）标量移动到地址为 <code>%rdi</code> 的 memory 引用区域中（p 所指向的区域），完成 <code>*p = t;</code></p><h2 id="6-3-3-AVX-Instructions"><a href="#6-3-3-AVX-Instructions" class="headerlink" title="6.3.3 AVX Instructions"></a>6.3.3 AVX Instructions</h2><p>AVX 新增的指令可以说是非常地多，使用方法、命名规范和之前所有的命令不同的是，加了前缀 “v”（vector，矢量运算），其他都相近。</p><p>AVX 指令用于驱动更新的 浮点数寄存器，例如 <code>%ymm</code> 系列。</p><ul><li><p><code>mov</code> 类命令：<code>vmovss/vmovsd/vmovps/vmovpd/vmovass/...</code>;</p><blockquote><p>命名规范见前面的叙述；</p></blockquote></li><li><p><code>cvt</code> （convert）类命令，一般实现浮点和整型之间的转换：</p><ul><li><p><code>vcvttss2si/vcvttsd2si/vcvttss2si/vcvttss2siq/vcvttsd2siq</code>;</p></li><li><p><code>vcvtsi2ss/vcvtsi2sd/vcvtsi2ssq/vcvtsi2sdq</code>;</p><blockquote><p>有点长，但是命名规范清楚：</p><p><code>vcvt</code> 是 <code>cvt</code> 类命令的前缀；</p><p>中间有 <code>t</code> 表示 truncation，进行截断（<strong>出现在浮点向整型的转换中</strong>）；</p><p>后缀 <code>XX2YY</code> 是 从 <code>XX</code> 类型转换到 <code>YY</code> 类型的意思，<code>XX/YY</code> 可取的值有：<code>ss/sd/ssq/sdq/si(integer, 32-bit)/siq(integer, 64-bit)</code>;</p></blockquote></li></ul></li><li><p>arithmetic 类命令：<code>vaddss/vsubss/vmulss/vdivss/vmaxss/vminss/vxorps/xandps/sqrtss/...</code></p><blockquote><p>新的指令名：<code>sqrt</code>，之前 integer registers 的指令所没有的；</p></blockquote></li><li><p>比较类命令（和 SSE3 相同）：<code>ucomiss/ucomisd</code>;</p></li></ul><h2 id="6-4-Summary-for-Chapter-6"><a href="#6-4-Summary-for-Chapter-6" class="headerlink" title="6.4 Summary for Chapter 6"></a>6.4 Summary for Chapter 6</h2><p>本章的内容密度也相当之大，有必要总结回顾一下本章所学的全部内容。</p><p>本章的一开始我们复习了 C/C++ 中指针和数组的准确定义，从分析<strong>二者的使用方式</strong>和 <strong>2 种区别（常量性、空间分配的自主性）</strong>方面入手，从较深的角度考虑了 <strong>数组标识符的含义和多种声明方式</strong>，以及这些声明方式如何阅读、如何理解。这样我们就能准确地回答：不同标识符的 <code>sizeof</code> 判断问题、空指针/野指针的出现问题，也有助于我们理解在汇编中数组的呈现方式。</p><p>在了解数组在 C/C++ 中的地位后，我们先讨论了普通一维数组的<strong>内存分布</strong>和<strong>访问方式</strong>。</p><p>无论是存在于程序栈帧中的一维数组（<code>T[]</code> 声明法），还是存在于堆中的一维数组（<code>T*</code> 声明法），它们的排布都是位于<strong>连续的</strong>、 <strong><code>L * sizeof(T)</code> 大小的</strong>内存空间中，数组标识符可以看作指向开头位置的指针常量。因此，对于一维数组的汇编访问就是看作<strong>一串连续的同类型数据排布</strong>，按照 Simple Memory Address Mode 进行索引即可。</p><p>而后我们从恒定的（<code>constexpr</code>，编译前确定）数组规模出发，进一步学习二维数组的情况。</p><p>由于 C/C++ 的语言特性，二维数组的两种声明方式（Nested array <code>T[][]</code> 和 Multi-level array <code>T*[]</code>），<strong>尽管二者的使用方法几乎一致</strong>，但所对应的<strong>内存排布方式 和 汇编操作性质完全不同</strong>。</p><p>前者在声明时，所有元素的空间都会被自动分配至栈中，并且以 “Row major” 的方式<strong>连续排布</strong>；而后者则仅有一级元素（<code>T*</code>）被自动分配空间，并且指向的每一行数组之间的存储位置<strong>可以不连续</strong>。</p><p>内存结构上的差异就决定了这两种数组在汇编代码访问方式的不一致。访问 Nested Array 的某个元素时，只需要对<strong>数组标识符</strong>和<strong>索引</strong>进行算术计算（<code>&amp;A[i][j] == A + i * C * sizeof(T) + j * sizeof(T)</code>）就能得到相应地址；而访问 Multi-Level Array 时却必须先由<strong>数组标识符</strong>和<strong>行参数</strong>找到一级元素内容，然后用<strong>一级元素内容</strong>和<strong>列索引</strong>才能定位具体的元素位置。</p><p>讨论完固定规模二维数组的内存排布和访问方式后，我们将眼光拓展到可变规模的 Nested Array（即 M × N Matrix）上。按照所掌握的知识，我们也可以从普通固定规模的两种二维数组出发，类比出访问这种可变规模二维数组的汇编实现。</p><p>聚合结构除了数组，还有一个重要的部分——结构体，也是 C++ 中类的前身。</p><p>结构体在内存中的表示遵循简单的 3 条原则：<strong>连续排布</strong>、<strong>严格按声明顺序</strong>、<strong>编译器决定字段内存对齐</strong>。</p><p>在观察几个例子后，我们发现在有些情况下，结构体的每个程序紧密排布，访问方式与数组相近；但有些情况编译器会在成员间插入空白数据段（也计入数据结构的总大小）。于是我们分析了<strong>结构体内存对齐</strong>的两点<strong>现实原因</strong>和两点<strong>对齐的原则</strong>（“起始地址整除原则”、“最大倍数原则”）；我们根据这些原则能够正确认识结构体在内存中的组织情况，并以此对程序进行存储方面（<strong>如何声明结构体成员，以获得最小的占用空间</strong>）和性能方面的改进。</p><p>对于结构体所组成的数组，则可以看成完整的结构体所为一个基本元素所组成的数组，一级索引方式与普通数组相同，二级索引方式和单一结构体相同，在汇编层面<strong>共同构成结构体数组针对单个元素、单个成员的索引表达式</strong>。</p><p>虽然聚合结构对于汇编层面来说完全透明，但以上建立的规则和约定让底层的一个个指令共同实现了聚合结构的高级功能。</p><p>除了阐明聚合结构在汇编层面的实现之外，我们还整理了非常多的 <code>mov</code> 指令。从中我们归纳出了<strong>指令命名的规则</strong>，这个规则适用于其他几乎所有指令，可以帮助我们<strong>少记忆指令</strong>、<strong>在遇到没有见过的指令时能够推测出其大致作用</strong>。</p><p>最后，我们提及了浮点数指令的历史，及其在内存中的整体存储、汇编层面的使用。</p><p>在 SSE3 指令拓展集中，16 个 <code>XMM</code> Register 既可以存储标量数据，又可以存储成组的数据；既可以存放各种数据类型的整型数据，又可以存放各种数据类型的浮点型数据。在此基础上，我们接触到了两类运算方法（Scalar Op 和 SIMD Op）及其对应的指令，使用方法和整型的情况相近。</p><p>此外，关于 FP Register 的 Saving Conventions、比较指令和常数的使用，进一步加深了我们对浮点数的汇编操作的理解。</p><p>另外介绍的 AVX Instructions 有助于帮助我们理解某些浮点数操作的汇编代码的含义。</p><h1 id="Chapter-7-Machine-Level-Programming-Ⅴ-Advanced"><a href="#Chapter-7-Machine-Level-Programming-Ⅴ-Advanced" class="headerlink" title="Chapter 7. Machine Level Programming Ⅴ - Advanced"></a>Chapter 7. Machine Level Programming Ⅴ - Advanced</h1><h2 id="7-1-Memory-Layout-in-x86-64"><a href="#7-1-Memory-Layout-in-x86-64" class="headerlink" title="7.1 Memory Layout in x86-64"></a>7.1 Memory Layout in x86-64</h2><p>内存（虚拟内存）本质上就是一个很大的字节数组。而之前观察 memory 的角度要么是从汇编 Simple Memory Address Mode 的访问角度，要么是从 x86-64 的程序栈的角度来看内存的。本节将从<strong>更为宏观、更为完整</strong>的角度介绍 <strong>x86-64 Linux 的完整内存布局</strong>。</p><p>首先，从 64 位系统的特征上来说，x86-64 系统上的程序所能访问的内存空间应该是 $2^{64}$ bits（大约 $16\times10^{18}$ bits），但由于当前存储技术的种种限制，当前的硬件限制我们只能使用最高 47 位的地址（大约 $128\times10^{12}$ bits，128 TB）。</p><p>在这个限制下，我们看一看系统提供给程序的运行内存的结构：</p><p><img src="imgs/memory.png" height="400px"></p><ul><li><p>最底层的 128 MB 是栈区（<code>0x0000 7FFF FFFF 0000</code>，即 $2^{47}-4096$ 至 <code>0x0000 7FFF F800 0000</code>），实际 x86-64 栈的<strong>实际最大大小</strong>在 8 MB 左右，向低地址增长。栈的结构参考 5.2 和 5.3。</p><blockquote><ol><li>一般操作系统为了保护栈数据不被攻击，一般在栈的前后放置随机数据区域；如果没有这些保护数据，那么栈就放在内存最底层（<code>0x0000 7FFF FFFF 0000</code> 的位置）.</li><li>如果运行中的程序<strong>试图访问超过这里 8 MB 限制范围的地址</strong>，或者<strong>访问的地址还没有通过 virtual memory allocator 的分配</strong>时，系统会抛出 segmentation fault，并强制结束程序；</li></ol></blockquote></li><li><p>在从最下面看起，位置 <code>0x40 0000</code> 开始向高地址位置，有一段 text 区（找不到这个名字的来源），是程序存放运行机器代码的位置（信息从可执行文件读入）。<strong>我们将在 “链接” 一章详细讨论这个部分的具体内容</strong>。数据只读（Read Only）；</p></li><li><p>再下面一段是 Data 区，<strong>是用来存放程序开始时就分配的数据</strong>。存放的内容包括：</p><ul><li>静态分配的数据；</li><li>程序中的全局变量、静态值、字符串常量；</li><li>……</li></ul></li><li><p>再下面一段是堆。堆和栈的分配方式<strong>完全不同</strong>，堆空间在运行时按代码<strong>动态分配</strong>（dynamically allocated，一般由 malloc()、calloc()、new 等方法创建，free()、delete 等方法销毁），最有趣的是，堆的分配位置和生长方向不固定；下面将由例子来说明；</p></li><li><p>堆下面有一段空间的位置是外部库（Shared Libraries），存储的是类似 malloc()、printf() 的库函数。它们一开始是<strong>作为动态链接库存储于磁盘上</strong>，在程序加载时，它们也载入内存的这个位置，供程序使用，称为<strong>动态加载</strong>。<strong>我们将在 “动态链接” 这一部分详细讨论具体内容</strong>。</p></li></ul><p>我们运行下面的程序进行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> big_array[<span class="number">8388608L</span>];        <span class="comment">/* 1&lt;&lt;24, 16 MB */</span></span><br><span class="line"><span class="type">char</span> huge_array[<span class="number">1073741824L</span>];    <span class="comment">/* 1&lt;&lt;31, 2 GB */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">useless</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *phuge1, *psmall2, *phuge3, *psmall4;</span><br><span class="line">    <span class="type">int</span> local = <span class="number">0</span>;</span><br><span class="line">    phuge1 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">28</span>);    <span class="comment">/* 256 MB */</span></span><br><span class="line">    psmall2 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">8</span>);    <span class="comment">/* 256 B */</span></span><br><span class="line">    phuge3 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">32</span>);    <span class="comment">/* 4 GB */</span></span><br><span class="line">    psmall4 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">8</span>);    <span class="comment">/* 256 B */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 GDB 调试可以发现，在 Linux 内存中，<code>big_array</code>、<code>huge_array</code> 和 <code>global</code> 这三个全局变量分布在大致 <code>0x600000</code> 的低地址的位置，位于 <strong>Data 区</strong>；局部变量 <code>local</code> 在地址 <code>0x7FFE 0000 0000</code> 的大致位置，位于<strong>内存栈区</strong>；对于函数 <code>main()</code> 和 <code>useless()</code> 而言，它们的地址在 <code>0x400000</code> 附近，位于 <strong>Text 区</strong>；</p><p>而对于 <code>phuge1</code>、<code>psmall2</code>、<code>phuge3</code>、<code>psmall4</code> 来说略有特殊。它们是使用 <code>malloc</code> 分配在堆里的，但是它们的位置差别较大：<strong>占用空间很大的 <code>phuge1</code> 和 <code>phuge3</code> 位于更靠近栈区的堆中，而占用空间较小的 <code>psmall2</code> 和 <code>psmall4</code> 则位于更靠近 Data 区的堆中</strong>。大致情况如下图：</p><p><img src="imgs/memory_pos.png" height="350px"></p><p>奇怪的是，<code>malloc</code> 大数据量的堆在上方和 shared libraries 紧贴，向低地址增长；而普通数据的堆在 Data 区的下方向高地址增长。可以预见，当两块 heap 碰头的时候，<code>malloc</code> 会返回空指针。</p><p>这个规律目前还没有解释，等到以后的章节慢慢了解。</p><h2 id="7-2-Buffer-Overflow"><a href="#7-2-Buffer-Overflow" class="headerlink" title="7.2 Buffer Overflow"></a>7.2 Buffer Overflow</h2><p>在 Chapter 0-0.3 的越界实验中，我们就讨论过内存缓冲区溢出的问题。当时造成的后果是结构体中的其他成员的数据被修改。本节会详细解释内存缓冲区溢出的各个方面的影响和应当措施。</p><h2 id="7-2-1-The-Vulnerability"><a href="#7-2-1-The-Vulnerability" class="headerlink" title="7.2.1 The Vulnerability"></a>7.2.1 The Vulnerability</h2><p>继续以 0.3 中的实验代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125; <span class="type">struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">struct_t</span> s;    <span class="comment">/* volatile 关键字表示易变量，警告编译器不进行任何优化 */</span></span><br><span class="line">    s.d = <span class="number">3.14</span>;</span><br><span class="line">    s.a[i] = <span class="number">1073741824</span>;    <span class="comment">/* Possibly out of bounds */</span></span><br><span class="line">    <span class="keyword">return</span> s.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>i</code> 参数取值大于 1 时会污染 <code>s.d</code> 的值，当 <code>i</code> 参数大于 6 时，可能会出现 segmentation fault；</p><p>但内存缓冲区溢出的问题不仅仅是内部开发者编写错误这一个小问题。相反，这是一个<strong>大问题</strong>。</p><ul><li>Buffer overflow 的出现：when <strong>exceeding</strong> the memory <strong>size</strong> allocated for <strong>an array</strong>;</li><li>Buffer overflow 为什么是大问题：它是<strong>头号的技术层面上的安全漏洞</strong>（#1 technical cause of security vulnerabilities）；</li><li>Buffer overflow 产生的原因列举：<ul><li>Unchecked lengths on string inputs（外部因素：<strong>不对输入字符串的长度和内容进行合法性检查</strong>）；</li><li>Illegal indexing / referring / modifying memory（内部因素：<strong>不对访问 memory 的参数进行检查</strong>）；</li></ul></li></ul><p>下面举一个实际点的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get string from stdin */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = getchar();        <span class="comment">/* get a single char from stdin */</span></span><br><span class="line">    <span class="type">char</span> *p = dest;            <span class="comment">/* the pointer p points to the same addr as dest */</span></span><br><span class="line">    <span class="keyword">while</span> (c != EOF &amp;&amp; c != <span class="string">&#x27;\n&#x27;</span>) &#123;    <span class="comment">/* reading stdin until new line or EOF */</span></span><br><span class="line">        *p++ = c;            <span class="comment">/* add the value of p directly. (A problem ?) */</span></span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;                <span class="comment">/* the dest char must ends with &#x27;\0&#x27; */</span></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Echo Line */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>];            <span class="comment">/* Way too small */</span></span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">call_echo</span><span class="params">()</span> &#123; echo(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a string: &quot;</span>);</span><br><span class="line">    call_echo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>gets</code> 函数不管 <code>dest</code> 的实际被分配的大小，直接进行输入，很可能在内存中出现 Buffer Overflow。于是总结出导致 Buffer Overflow 的罪魁祸首之一：<strong>存储字符串，却不检查边界情况的库函数</strong>；C 库里有很多这样不检查边界的库函数：<code>scanf</code>、<code>fscanf</code>、<code>sscanf</code>（等 <code>scanf</code> 家族，尤其是使用 <code>%s</code> 格式化参量）、<code>strcpy</code>、<code>strcat</code>（等字符串移动家族）……</p><p>现在看看运行这个程序会出现什么问题（如果自己想试试的话，记得<strong>关闭 gcc 栈保护 <code>-fno-stack-protector</code></strong>）：</p><ul><li>如果输入短一点的字符串（长度小于 24 个），那么程序很可能会正常运行；</li><li>如果输入很长的字符串，那么程序会报告 segmentation fault；</li></ul><p>那么，都是缓冲区溢出，为什么短一点的看起来不会出问题呢？这时候就需要从汇编代码解释了。我们生成上面的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">    sub$0x18, %rsp</span><br><span class="line">    mov%rsp, %rdi</span><br><span class="line">    callq400680 &lt;gets&gt;</span><br><span class="line">    mov%rsp, %rdi</span><br><span class="line">    callq400520 &lt;puts@plt&gt;</span><br><span class="line">    add$0x18, %rsp</span><br><span class="line">    retq</span><br><span class="line">call_echo:</span><br><span class="line">    sub$0x8, %rsp</span><br><span class="line">    mov$0x0, %eax</span><br><span class="line">    callq4006cf &lt;echo&gt;</span><br><span class="line">    add$0x8, %rsp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure><p>首先观察，一开始系统为 <code>echo</code> 函数的栈帧分配了 24 bytes（<code>0x18</code>）的空间，<strong>因此，如果输入的输出加入超过了所有的栈空间，进入没有被分配的 memory 时，就会报告 segmentation fault</strong>。</p><p>所以，（<strong>当没有使用 <code>gcc</code> 栈保护机制时</strong>）安全问题通常就出现在 “溢出内容超过了原来分配的位置，但是没有超过栈的总体空间” 这种情况下。这时系统不会抛出 segmentation fault，<strong>栈中数据只能任由输入者篡改</strong>。</p><p>再来看看内存对应的情况：</p><p><img src="imgs/buffer_overflow_example1.png" height="260px"><img src="imgs/buffer_overflow_example1_2.png" height="260px"><img src="imgs/buffer_overflow_example1_3.png" height="260px"></p><p>如上左图，当 <code>char buf[4]</code> 声明后，在程序初始化时，编译器为<code>echo</code> 预留了 24 bytes 的空间；<code>echo</code> 栈帧的最顶层存放的是局部变量 <code>buf</code> 数组对应的空间大小是 4 bytes，一切都很正常。</p><p>如上中图，我们不妨假设 <code>call_echo</code> 在 return address 里存放的地址是 <code>0x4006C3</code>（<code>echo</code> 运行结束后应该返回的地址）；如果输入字符串内容超过了 <code>buf</code> 能承受的 3 bytes，则会出现 buffer overflow，如图，数据覆盖了 <code>buf</code> 下方的 20 bytes 其他区域的数据，但因为这个例子中，恰好那个区域没有存放其他数据，所以表面上程序没问题；</p><blockquote><p>如果那 20 bytes 空间放了其他数据，那么会被篡改；</p></blockquote><p>但，如果输入长度更长，那么字符串序列会溢出的更长，如上右图所示，污染了 Return address 的话，问题就出现了。当 echo 想要结束时，会因为 Return address 被修改而转移到一个不知道什么的地方，很可能导致 segmentation fault；<strong>更严重的，如果恰好跳转到一个奇怪的函数中，并且还能运行、没报错，那么坏了，程序不会按预期的方式继续运行，这样的 bug 非常隐晦</strong>；</p><h2 id="7-2-2-Stack-Smashing-Attacks"><a href="#7-2-2-Stack-Smashing-Attacks" class="headerlink" title="7.2.2 Stack Smashing Attacks"></a>7.2.2 Stack Smashing Attacks</h2><p>在上面说到的情况下，如果攻击者想要函数在输入后，跳转到不应该执行的、但是程序里面有的函数中，会让程序出现一些意料之外的行为。</p><blockquote><p>例如登录场景：攻击者想要输入一串内容，让软件跳转到登陆成功的函数中;</p></blockquote><p>这种攻击被称为<strong>缓冲区溢出攻击（stack smashing attack）</strong>，这种攻击就是利用了技术人员不注意输入检查，而导致的缓冲区溢出的问题。</p><p>实现这种攻击的原理比较简单，就是<strong>输入无意义的填充字符（padding）让输入的内容 buffer overflow，并且在末尾设置一个想要跳转到的函数的地址，并且只需让末尾的地址恰好覆盖 return address</strong> 就行。</p><p>如下图所示，正常的流程是 <code>P()</code> 调用 <code>Q()</code>，<code>P</code> 函数在 return address 中写的是 <code>A</code>，也就是 <code>P</code> 函数中调用 <code>Q</code> 的下一行；但由于 <code>Q()</code> 中的 <code>gets(buf)</code> 有溢出风险，在攻击者输入 <code>padding</code> 字符 + <code>S</code> 地址组合的字符串后，<code>gets</code> 函数将缓冲区数据覆盖了，如下图右，return address 被改成了 <code>S</code> 的地址。这样在 <code>Q()</code> 执行结束后，会跳转到 <code>S()</code> 函数中，而不是原来的 <code>P()</code> 中：</p><p><img src="imgs/stack_smashing_attack.png" height="300px"></p><p>做法很简单，但是编译时要关闭 <code>gcc</code> 的栈保护机制（<code>-fno-stack-protector</code>）。现在大多数 C/C++ 编译器都有这项功能，利用栈随机化、“金丝雀” 检查等技术，打乱栈空间的实际排布、利用栈两端的 “金丝雀” 侦测栈溢出，发现就立即终止程序，让攻击难以进行。<strong>（后面会详细讨论）</strong></p><ol><li>找到有导致缓冲区溢出风险的函数（像之前提到的 <code>scanf</code> 家族、<code>str</code> 家族），并且技术人员没有为这些函数的输入进行检查；</li><li>反汇编找到想要跳转的函数（也就是上面的 <code>S</code>）的地址；</li><li>反汇编找到汇编代码中编译器为 <code>Q</code> 函数分配的栈帧大小，计算出 <code>pad</code> 填充字符的大小，使得 <code>S</code> 地址恰好覆盖 return address；</li><li>将 padding 数据 + <code>S</code> 的地址（<strong>注意大小端序的问题</strong>）转换为字符串，运行程序并输入即可。</li></ol><h2 id="7-2-3-Code-Injection-Attacks"><a href="#7-2-3-Code-Injection-Attacks" class="headerlink" title="7.2.3 Code Injection Attacks"></a>7.2.3 Code Injection Attacks</h2><p>也是在上面说到的情况下，如果有攻击者刻意如此设置，让缓冲区溢出到 return address，并且恰好让 return address 指向攻击者事先设计好的 exploit code 中，那么程序就会执行攻击者设计的函数，从而给计算机造成威胁。</p><p>这种攻击被称为 <strong>代码注入攻击</strong>，思路和上面的 stack smashing attack 如出一辙，只不过攻击者不满足于执行软件内的其他函数了，他要执行的是自己嵌入的函数，危害可能更大。</p><p>实现攻击的原理就是，<strong>攻击者输入编码有 exploit code + padding string + pointer to exploit code 的内容</strong>，让读入程序执行结束后跳转到攻击者刚刚输入的 exploit code 中执行，如下图所示：</p><p><img src="imgs/code_injection_attack.png" height="300"></p><blockquote><p>更聪明的攻击者会在运行完 exploit code 后修复溢出的缓冲区，并且跳转到原来的函数，伪装成没有被攻击的假象。</p><p>知识拓展：计算机病毒和计算机蠕虫的区别</p><ul><li>蠕虫：可以通过某种隐蔽的方式，进行自我复制、独立地在机器上运行预期代码；</li><li>病毒：可以通过某种隐蔽的方式，进行自我复制，攻击一个程序，并改变这个程序的行为，但自己不能独立存在。</li></ul></blockquote><h2 id="7-2-4-The-Protection-in-personal-respective"><a href="#7-2-4-The-Protection-in-personal-respective" class="headerlink" title="7.2.4 The Protection: in personal respective"></a>7.2.4 The Protection: in personal respective</h2><p><strong>Avoid overflow vulnerabilities when writing a program</strong></p><blockquote><p>例如之前的 <code>gets</code> 函数有风险，可以换成 <code>fget</code> 指定读入缓冲区的大小；</p><p><code>strcpy</code> 换成 <code>strncpy</code>、<code>scanf</code> 使用时不轻易用 <code>%s</code> 格式，而使用 <code>%ns</code>，或者直接用 <code>fgets</code>;</p></blockquote><p><strong>Avoid overflow vulnerabilities in system-level</strong></p><ul><li><p>栈随机化（stack randomization），是更宏观策略 ASLR (Address Space Layout Randomization, 地址空间布局随机化) 的一部分，<code>gcc</code> 编译器选项：<code>-fPIE</code>；</p><blockquote><p>这样的话，每次运行程序，栈和堆上变量的位置偏移 offset 会随机产生，攻击者就没法找到准确的攻击代码的插入位置了；<code>gcc</code> 编译器禁用：<code>-fno-PIE</code>;</p></blockquote></li><li><p>Non-executable code segments：在栈中规定禁止执行代码，只有在 Text 区 / Shared Libraries 区才能执行；</p><blockquote><p>以前人们在内存中每一个 chunk 前放置 3 个 flags，类似 Unix 上的 可读、可写、可执行三个权限，对于栈区的空间中 flags 应该是可读、可写、不可执行；<code>gcc</code> 编译器取消禁令：<code>-z execstack</code>;</p></blockquote></li><li><p>Stack Canaries（栈 “金丝雀”），在栈中的 buffer 两端设置特殊的随机值（称为 “金丝雀”，早期人们下矿就用金丝雀的生死来判断矿井中瓦斯是否超标），在写入 buffer 的函数退出前检查这些值。如果这些值被改变了，那么说明 buffer overflow，可能会出问题，就立即终止接下来程序的执行；<strong>现在这个技术已经在 <code>gcc</code> 中成为默认的编译选项：<code>-fstack-protector</code></strong>;</p></li></ul><blockquote><p>这里简单从汇编层面分析一下 “金丝雀” 是如何实现的。</p><p>还是以上面的 <code>echo</code> 函数为例，这时我们编译就删除 <code>-fno-stack-protector</code> 这个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">    sub$0x18, %rsp</span><br><span class="line">    mov%fs:0x28, %rax</span><br><span class="line">    mov%rax, 0x8(%rsp)</span><br><span class="line">    xor%eax, %eax</span><br><span class="line">    mov%rsp, %rdi</span><br><span class="line">    callq4006e0 &lt;gets&gt;</span><br><span class="line">    mov%rsp, rdi</span><br><span class="line">    callq400570 &lt;puts@plt&gt;</span><br><span class="line">    mov0x8(%rsp), %rax</span><br><span class="line">    xor%fs:0x28, %rax</span><br><span class="line">    je400768 &lt;echo+0x39&gt;</span><br><span class="line">    callq400580 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">    add$0x18, %rsp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure><p>我们一步步分析：</p><p>第一步给 <code>echo</code> 栈帧分配了 24 bytes 的空间，非常简单；</p><p>第二步用到了一个没见过的东西 <code>%fs:0x28</code>，实际上 <code>%fs</code> 是一个<strong>为原始 8086 芯片设计的一个寄存器</strong>，由于向下兼容，所以它现在还能<strong>以某种方式</strong>使用，但是基本很少用，甚至已经找不到它的文档了……只需要知道 <code>%fs:0x28</code> 是内存的某个隐匿部位，相当于随机数 “金丝雀”，我们将这个数放到 <code>%rax</code>，第三步再将这个值放到 <code>%rsp</code> 所指向的下面 8 bytes 的位置——这就意味着 <code>buf</code> 只要溢出 8 bytes 就会被察觉；</p><blockquote><p>⚠ <code>%fs</code> <strong>不是</strong>真正可用的寄存器，它是 segment register（段寄存器）in protected mode，其中的值是指向某个有效位置的指针。所以只能用如此方式（<code>%fs:0x28</code>）取出值，它（<code>%fs:0x28</code>）实际上是内存中某个位置的引用，<strong>并且每次运行，这个值都会改变</strong>。</p><p>这也回答了为什么不能直接将 <code>%fs:0x28</code> 的值 <code>mov</code> 到内存中。</p><p>——以上摘自 <a href="https://stackoverflow.com/questions/10325713/why-does-this-memory-address-fs0x28-fs0x28-have-a-random-value">StackOverflow</a>;</p></blockquote><p>第四步将 <code>%rax</code> 清空为 0，然后执行普通的 <code>echo</code> 操作，省略；</p><p>直到倒数第 5 步（第 10 行），系统将 “金丝雀” 取出到 <code>%rax</code> 并和原值 <code>%fs:0x28</code> 比较，如果不等就是缓冲区溢出，立即调用 <code>__stack_chk_fail</code> 报错终止执行；</p></blockquote><h2 id="7-2-5-【New】Return-Oriented-Programming-Attacks"><a href="#7-2-5-【New】Return-Oriented-Programming-Attacks" class="headerlink" title="7.2.5 【New】Return-Oriented Programming Attacks"></a>7.2.5 【New】Return-Oriented Programming Attacks</h2><p>在上面的许多防护措施出来后，给攻击者带来很多难题：</p><ul><li>栈随机化使得他们很难预测缓冲区的位置；</li><li>栈区无法执行代码，使得他们插入代码也没用；</li></ul><p>于是攻击者有了一些替代性的措施，<strong>能够突破上面的两个障碍（栈随机化 + 禁止栈中执行代码）</strong>：</p><ul><li>利用已存在的代码，例如标准库中的代码。因为它们不在栈区和堆区，位置不会轻易变动；</li><li>利用 x86 架构中 <code>ret</code> 指令的特殊行为，来执行代码；</li></ul><p>下面介绍这种攻击的原理。</p><p>这种攻击利用的部件称之为 <strong>gadget</strong>，通常是各个函数的<strong>包含 <code>ret</code> 指令的最后几行或者一段</strong>，如下：</p><p><img src="imgs/gadget_1.png" height="225px"><img src="imgs/gadget_2.png" height="225px"></p><p>这些毫无关系的函数的汇编代码最后几行甚至几个片段总会包含一些指令，例如将某个寄存器的值加多少、将某个寄存器的值移动到哪。它们紧接着 <code>ret</code> 指令（对应汇编码 <code>0xC3</code>）。这就意味这我们可以<strong>收集这些 gadget 的地址，按照我们的需求依此排列这些 gadget，通过输入将这些地址溢出到栈里，让栈充当程序计数器的角色，反复执行 <code>gadget1</code> -&gt; <code>ret</code> -&gt; 执行 <code>gadget2</code> -&gt; <code>ret</code> -&gt; …，越过了上面两个限制，将所有 gadget 连在一起，最终让程序段达到我们的目的</strong>，如下图：</p><p><img src="imgs/ROP_execution.png" height="300px"></p><p><strong>可以说是顶级的 “断章取义”！</strong></p><p>不过有两个缺点：</p><ul><li>这种攻击仍然不能突破 “金丝雀” 的防护，因为这毕竟是栈溢出；</li><li>各个 gadget 需要大量地查找，比较费精力。有些人会在标准库中积累一些 gadget；</li></ul><h2 id="7-3-Union-in-Memory"><a href="#7-3-Union-in-Memory" class="headerlink" title="7.3 Union in Memory"></a>7.3 Union in Memory</h2><p>C 中有一个特殊的数据结构：<code>Union</code>，声明方式与 <code>struct</code> 几乎一样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125; *up;</span><br></pre></td></tr></table></figure><p>但用法完全不一样。<strong><code>Union</code> 的所有域共用一块最大的域大小的内存</strong>，这就导致在改动一个域的数据时，其他域的值也会改变；所以 <strong><code>Union</code> 一次只能使用一个域，或者用在通过别名引用不同的内存的场合</strong>。<code>Union</code> 用的地方少，但在单片机、掩码的领域用的比较多。</p><p>对于<strong>联合体的内存对齐</strong>，和之前说的结构体类似，遵循以下几点限制：</p><ul><li>自身的对齐整除数 K（定义见 6.2.2）是所有域的对齐整除数的<strong>最小公倍数</strong>；</li><li>自身的长度（padding 后）既能单独放下每个域，又满足长度 K 对齐；</li></ul><p>看个经典的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">dm</span> &#123;</span></span><br><span class="line">        <span class="type">long</span> i;</span><br><span class="line">        <span class="type">char</span> j[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">    &#125; n;</span><br><span class="line">    <span class="type">double</span> p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>dm</code> 作为结构体 <code>data</code> 的成员，其对齐整除数等于其中域的对齐整除数的最小公倍数，也就是 <code>long i</code> 的 8 bytes，所以 $K(dm)=8$，确定了起始地址的条件，还要确定 <code>dm</code> 的长度。其长度首先能单独方向所有域，所以 $sizeof(dm)\ge10$，但是 K 是 8，所以为了满足第二条件，长度应该取<strong>大于 10 的 K 的倍数</strong>，也就是 16；</p><p>因此 <code>data</code> 的内存排布如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|  m  | dm indent (+4) |  dm  | dm padding (+6) |  p  |</span><br><span class="line">0     4                8      18                24    32  (bytes)</span><br></pre></td></tr></table></figure><p>因此 <code>sizeof(dm) = 16</code>，<code>sizeof(data) = 32</code>；</p><p>还有就是之前的 Data Lab 中用于 <strong>bit-level representation 的 float 和真实的 float 之间相互转换</strong>，不会改变 bit pattern，也能用到 <code>Union</code>（当然不是解题答案，因为不允许）；</p><p><strong>使用 <code>Union</code> 也要特别注意端序的问题</strong>！！！</p><h2 id="7-3-1-Union-Allocation"><a href="#7-3-1-Union-Allocation" class="headerlink" title="7.3.1 Union Allocation"></a>7.3.1 Union Allocation</h2><p>对联合体（<code>Union</code>）而言，内存分配比较简单，只需要判断所有域中占用空间最大的那一个来分配就行。例如上面的例子就是 8 bytes；</p><h2 id="7-3-2-Summary-of-Compound-Types-in-C"><a href="#7-3-2-Summary-of-Compound-Types-in-C" class="headerlink" title="7.3.2 Summary of Compound Types in C"></a>7.3.2 Summary of Compound Types in C</h2><ul><li>Arrays<ul><li>Contiguous allocation of memory（1-D &amp; Nested Array）；</li><li>Aligned to satisfy every element’s alignment requirement；</li><li>Pointer to first element；</li><li>No bounds checking；</li></ul></li><li>Structures<ul><li>Allocate bytes in order declared；</li><li>Pad in middle and at end to satisfy alignment；</li></ul></li><li>Unions<ul><li>Overlay declarations；</li><li>Way to circumvent type system；</li></ul></li></ul><h2 id="7-4-Summary-of-Chapter-7"><a href="#7-4-Summary-of-Chapter-7" class="headerlink" title="7.4 Summary of Chapter 7"></a>7.4 Summary of Chapter 7</h2><p>本章的内容相较于之前两章较少，但是也很重要。</p><p>本章开始我们就从<strong>更全面的</strong>角度来观察 <strong>x86-64 Linux 的完整内存布局</strong>，我们落脚于实际，考虑到实际能够使用的内存不过 128 T 左右，建立了一个 <code>0x0000 7FFF FFFF F000 ~ 0x40 0000</code> 的内存图谱。</p><p>在这个图谱中，自高地址至低地址分布栈区（stack）、外部库区（shared libraries）、堆区（heap）、数据区（data）、机读代码区（text）；</p><p>这些位置都由 virtual memory allocator 进行管理，如果访问了超出整个内存的范围，或是不在已分配的空间内，系统都会抛出 segmentation fault；</p><p>我们了解到，栈区<strong>位于内存的最高地址处</strong>，内部存放见 5.2 和 5.3，实际大小约 8 MB（x86-64），地址在 $2^{47}-4096$ 至 <code>0x0000 7FFF F800 0000</code> 中，前后可能含有因为 ASLR 或 “金丝雀” 产生的<strong>随机数据</strong>，总共约 128 MB；</p><p>在栈区的上方（这里把较低地址的称为 “上方”）是 Shared Libaries 区，<strong>它存放重要的外部库函数</strong>，是动态加载至内存上的部分。如果堆中有较大的数据，可能部分的堆区会与外部库区毗邻，并且向低地址生长。</p><p>跨过中间大片的未分配的区域向低地址看，就是堆区，<strong>由代码函数手段分配和释放的区域，存放大部分由手动分配的普通变量</strong>，向高地址生长；</p><p>在堆区的上方，是数据区，<strong>存放程序开始就分配的数据</strong>，包括静态数据、全局变量、字符串常量等；</p><p>再向上就是内存的地址最低处，机读代码区，开始于 <code>0x40 0000</code>，具体内容会在 “链接” 一章中讨论。</p><p>以上区域，text / data / shared libraries 区域运行时可读可执行，heap / stack 区域可读可写不可执行。</p><p>介绍完 x86-64 Linux 整体的内存分布，我们进一步讨论了 Buffer overflow 的原理和危害性。</p><p>Buffer overflow 出现的<strong>内部原因</strong>是对数组或其他 memory 不恰当的读写访问，<strong>外部原因</strong>是不对输入字符串进行长度和内容的合法性检验。</p><p>最后 Buffer Overflow 或者触发 segmentation fault 导致程序崩溃，或者恰好进行了不恰当的跳转，让程序行为不可预测、难以调试，或者被不法分子利用后，危害计算机系统的正常使用。</p><p>从一个使用容易内存缓冲区溢出的 <code>gets</code> 的函数 <code>echo</code> 出发，我们讨论了输入不同长度的字符串对缓冲区溢出的影响，进而推出了 <strong>3 种</strong>利用缓冲区溢出特点的攻击行为（Stack Smashing Attacks、Code Injection Attacks、Return-Oriented Programming Attacks）。它们共同点是，都利用了溢出影响 return address 的特性，使得程序跳转到攻击者指定的位置执行；但从具体操作上各有差异。</p><p>之后我们介绍了<strong>两类、四种</strong>针对内存缓冲区溢出攻击的防护办法。两类中的一类是<strong>从开发者自己做起</strong>，尽量避免使用有缓冲区溢出风险的函数；另一类是<strong>从系统层面做起</strong>，主要分为 3 种，分别是<strong>栈随机化</strong>、<strong>栈区禁止执行代码</strong> 和 <strong>栈 “金丝雀”</strong>。这 3 种防护思路能够轻松应对 Stack Smashing Attacks 和 Code Injection Attacks，但只有 栈 “金丝雀” 能够防护 Return-Oriented Attacks。</p><p>我们仔细分析了 栈 “金丝雀” 的汇编层面的实现，更加确信这个至今没有被破解的防护方法的强大。</p><p>本章最后，我们接触到了 <code>Union</code> 联合体在内存中的分配和表示，反复强调使用 <code>Union</code> 时<strong>一定要注意端序的问题</strong>，以免出现字节序方面的编程错误。</p><blockquote><p>第 3 ~ 7 章已结束，请完成 Bomb Lab &amp; Attack Lab！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt; &lt;a href=&quot;http://www.cs.cmu.edu/~213/schedule.html&quot;&gt;CMU - 213&lt;/a&gt;, &lt;i&gt;Computer Systems A Programmer’s Perspective 3rd Edition&lt;/i&gt; by Randal Bryant, David O’Hallaron&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;内容很长，写起来很慢&lt;/i&gt; 😳&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="review" scheme="https://sjtuxhw.top/categories/review/"/>
    
    
    <category term="GNU" scheme="https://sjtuxhw.top/tags/GNU/"/>
    
    <category term="CSAPP" scheme="https://sjtuxhw.top/tags/CSAPP/"/>
    
    <category term="ICS" scheme="https://sjtuxhw.top/tags/ICS/"/>
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>MC-Forge开发笔记（一）</title>
    <link href="https://sjtuxhw.top/2023/09/05/MC-Forge%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://sjtuxhw.top/2023/09/05/MC-Forge%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-09-05T13:04:06.000Z</published>
    <updated>2023-09-19T05:18:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: </i><a href="https://docs.minecraftforge.net/en/1.16.x/">Minecraft Forge Doc 1.16.x</a>、<a href="https://boson.v2mcdev.com/introducation/intro.html">Boson 1.16（导论部分）</a></p><p><i>注意：以 MC 版本 1.16.5 为例</i>（同一大版本 1.16.x 的操作方式变化不大）</p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><hr><span id="more"></span><h2 id="Chapter-0-Forge-导论"><a href="#Chapter-0-Forge-导论" class="headerlink" title="Chapter 0. Forge 导论"></a>Chapter 0. Forge 导论</h2><h3 id="0-1-Forge-历史与定义"><a href="#0-1-Forge-历史与定义" class="headerlink" title="0.1 Forge 历史与定义"></a>0.1 Forge 历史与定义</h3><ul><li><p><code>Minecraft</code> 其中发行版的一个大类是由 <code>Java</code>写的<strong>商业</strong>软件，这意味着：</p><ul><li><code>Minecraft</code> 容易反编译和修改：由于 <code>Java</code> 半解释型语言的特性（但凡换成 C++ 就很可能不会有今天 Mod 丰富的生态了，毕竟 Mojang 当年一直不给官方 API）；</li><li>代码本身是闭源的、被混淆的：这毕竟是一款商业软件。</li></ul></li><li><p>为了给 <code>Minecraft</code> 增添更多的游戏特性，大家千方百计地寻找添加代码的办法。最终 <code>MCP</code>（Mod Coder Pack）项目诞生了，它<strong>规避了没有官方 API 的问题，通过反编译、反混淆直接修改 <code>Minecraft jar</code> 包中的内容</strong>。其发展过程中，人们研究各类的名称的产生如下：</p><ul><li><p><code>notch</code> 名：<code>Minecraft</code> 各种类直接反编译、反混淆之后的名称，通常是无意义的字母数字组合。</p><blockquote><p>例如 <code>j</code> 就是一个典型的 <code>notch</code> 名；</p></blockquote></li><li><p><code>srg</code> 名：与 <code>notch</code> 名一一对应。极大的好处是<strong>在一个版本里是不会变动的</strong>，这意味着类名渐渐可读起来，有相应的前缀后缀来区分。之所以叫做<code>srg名</code>，是为了纪念MCP项目开发的领导者Searge；</p><blockquote><p>例如 <code>notch</code> 名 <code>j</code> 对应 <code>srg</code> 名的 <code>func_70114_g</code>。</p></blockquote></li><li><p><code>mcp</code> 名：这是当年 <code>MCP</code> 项目的 mod 开发者使用的最多的名称。在<code>mcp</code> 名中，<strong>代码已经是可读的了</strong>。和我们正常写java程序中的名称没什么两样，但是也会变动。</p><blockquote><p>例如，<code>notch</code> 名为 <code>j</code> 的函数，其 <code>srg</code> 名为 <code>func_70114_g</code>，其 <code>mcp</code> 名是 <code>getCollisionBox</code>；</p></blockquote></li></ul></li><li><p>随着时间推移和生态的扩展，大家发现这么做很不行，因为直接修改 Jar 文件写 mod 的方式太过于粗暴了，而且 Mod 和 Mod 之间的兼容性可以说基本没有。于是，<code>Forge</code> 项目就诞生了。</p></li><li><p><code>Forge</code> 是通过修改 <code>Minecraft</code> 方式实现的<strong>第三方的 API</strong>，给广大 mod 开发者提供了标准化的接口的指引。而Forge本身也在 <code>Minecraft</code> 1.13 版本到来之后经历了一次重写，引入了大量函数式编程的API。</p><blockquote><p>随着时间的发展，<code>MCP</code> 项目现在已经死亡了，除了 <code>Forge</code> 这套API，<code>Fabric</code> 也风头正盛。</p></blockquote></li><li><p><code>Forge</code> 的工作原理也采用了 <code>MCP</code>  的思路。在为指定版本的 <code>Minecraft</code> 安装完 <code>Forge</code> 之后，游戏的运行过程中，所有的内容都会反编译成 <code>srg</code> 运行，你编译好的 mod 同样也会被混淆成 <code>srg</code>，保证它可以正常运行。</p><blockquote><p>用 <code>srg</code> 名就是因为它每个版本不变。</p></blockquote></li></ul><h3 id="0-2-Minecraft-的架构"><a href="#0-2-Minecraft-的架构" class="headerlink" title="0.2 Minecraft 的架构"></a>0.2 Minecraft 的架构</h3><p>除了了解 <code>Forge</code> 的历史和定义，<code>Minecraft</code> 的架构和运作方式在 Mod 开发中也绝对是必要的。</p><ul><li><p><code>Minecraft</code> 是一种 C/S 架构，整体逻辑如下：</p><ul><li>服务端：负责游戏的逻辑，数据的读写。</li><li>客户端：接受用户的输入输出，根据来自服务端的数据来渲染游戏画面。</li></ul><p><img src="struct.png" height="400px"></p></li><li><p>Tips 1. 这里客户端和服务端的区分<strong>仅是逻辑上的区分</strong>。</p><ul><li>实际上如果你处于单人模式，那么你的电脑上会<strong>同时存在</strong>服务端和客户端，而且他们处于不同的线程（<code>Server thread</code> &amp; <code>Render thread</code>）；</li><li>但是当你连接某个服务器时，你的电脑上只存在客户端，服务端被转移到了远程的一台服务器上。</li></ul></li><li><p>Tips 2. 客户端、服务端<strong>各存在一份数据模型</strong>。不过「客户端数据模型」只是「服务端数据模型」一个副本，虽然它们都有独立的游戏 <code>Tick</code>，也共享很多相同的代码，但是最终逻辑还是以服务端为准。</p></li><li><p>Tips3. 客户端和服务端是存在于不同线程的，所以它们不可避免地需要同步数据。而数据同步都是通过<strong>网络数据包</strong>实现的。</p><blockquote><p>在大部分时候原版已经实现好了数据同步的方法，我们只需要调用已经实现好的方法就行。</p><p>但是在某些情况下，原版没有实现对应的功能，或者不适合使用原版提供的功能，我们就得自己创建和发送网络数据包来完成数据的同步。【可能需要计算机网络基础、<code>Java</code> 网络编程基础】</p></blockquote></li><li><p>在代码中，<strong>区分服务器端和客户端</strong>的方式：<code>World</code> 中有一个 <code>isRemote</code> 字段，开发时判断它就行。</p></li></ul><h3 id="0-3-Minecraft-的运行模式"><a href="#0-3-Minecraft-的运行模式" class="headerlink" title="0.3 Minecraft 的运行模式"></a>0.3 Minecraft 的运行模式</h3><ul><li><strong>离散事件驱动模式</strong>，详见数据结构书籍。这个模式包含了 3 个概念：<ul><li>事件：“当方块被破坏” 这个就是一个事件，“当玩家死亡” 这个也是一个事件，甚至 “当渲染模型时” 这个也是一个事件；</li><li>事件处理器：用来处理 “事件” 的函数。例如可以注册一个事件处理器来处理 “玩家死亡事件”，里面的内容是 “放置一个墓碑”；</li><li>总线：总线是连接 “事件” 和 “事件处理器” 的工具，当 “事件” 发生的时候，“事件” 的信息将会被发送到总线上，然后总线会选择监听了这个 “事件” 的 “事件处理器”，执行这个事件处理器。</li></ul></li><li>在Minecraft中，所写的逻辑基本上都是事件处理。</li><li>在Forge开发里有两条总线，<code>Mod</code> 总线和 <code>Forge</code> 总线，所有和初始化相关的事件都是在 <code>Mod</code> 总线内，其他所有事件都在 <code>Forge</code> 总线内。</li></ul><h3 id="0-4-重要概念准备"><a href="#0-4-重要概念准备" class="headerlink" title="0.4 重要概念准备"></a>0.4 重要概念准备</h3><ul><li><p>注册：如果想往 <code>Minecraft</code> 里添加一些内容，那么你必须做的一件事就是注册。注册是一种机制，告诉游戏本身，有哪东西可以使用。你注册时需要的东西基本上可以分成两个部分：<strong>一个注册名</strong>和<strong>一个实例</strong>；</p></li><li><p>资源地址（<code>ResourceLocation</code>）：<code>Minecraft</code> 管理、定位资源（音频 / 图片）的方式是<strong>采用特殊格式的字符串</strong>。格式为：<code>&lt;domain&gt;:&lt;UNIX-Style relative path&gt;</code>。</p><ul><li>域可以是 <code>minecraft</code>（原版资源），也可以是 mod 的名称。相对路径是相对于 mod 根目录下的 <code>assets</code> 目录而言（如果是原版资源，即域名为 <code>minecraft</code>，那么相对于 <code>.minecraft/assets</code>）;</li><li>例如：<code>minecraft:textures/block/stone.png</code>，<code>mod1:textures/Alex.png</code>；</li></ul></li><li><p>模型和材质：在游戏中 <code>3D</code> 的对象基本上都有它的模型，模型和材质组合在一起规定了一个对象具体的样子。模型相当于是骨头，材质相当于是皮肤。在大部分时候，你的材质都是 png 图片【可能需要平面设计 和 PS 的相关功底】。</p><blockquote><p>注意保证<strong>材质背景是不透明的</strong>，也不要在材质中使用<strong>半透明像素</strong>，会有不可预知的问题。</p></blockquote></li></ul><h3 id="0-5-开发环境"><a href="#0-5-开发环境" class="headerlink" title="0.5 开发环境"></a>0.5 开发环境</h3><blockquote><p><code>Minecraft Forge</code> 是由 <code>Gradle</code> 管理的项目，而 <code>Forge</code> 官方写了一个叫做 <code>ForgeGradle</code>（以后简称FG）的插件来负责整个 mod 开发环境的配置，本节主要介绍这个环境的配置和使用；</p></blockquote><ul><li><p>前提</p><ol><li><code>JDK 8</code>（1.16.x 兼容版本）和 <code>64 bit JVM</code>；请确保您的操作系统已经安装并配置好环境变量 <code>JAVA_HOME</code>、<code>CLASS_PATH</code>；</li><li>官网获得 <code>MDK(Mod Development Kit)</code>：我们这里 1.16.5 选择官网推荐的 <code>forge-36.2.34</code> <a href="https://files.minecraftforge.net/net/minecraftforge/forge/index_1.16.5.html">Downloads for Minecraft Forge for Minecraft 1.16.5</a>；</li><li>Java 开发 IDE，可以选 VSCode / Eclipse / IDEA，本文<strong>以 IDEA 为例</strong>进行。</li></ol></li><li><p>开发准备工作</p><ol><li><p>这里我们将下载的 MDK 解压到一个空目录下；</p><blockquote><p>FG 项目结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">├─ .gitattributes        # Git 用来记录某些文件属性</span><br><span class="line">├─ .gitignore            # Git 用来忽略版本控制的记录文件</span><br><span class="line">├─ build.gradle            # Gradle 构建脚本</span><br><span class="line">├─ changelog.txt        # Forge 项目版本迭代情况</span><br><span class="line">├─ CREDITS.txt            # Forge 项目致谢和 credits</span><br><span class="line">├─ gradle.properties    # Gradle 属性文件，用来定义其他变量和设置</span><br><span class="line">├─ gradlew                # Unix 类系统执行 Gradle wrapper 的 shell</span><br><span class="line">├─ gradlew.bat            # Windows 系统 ~</span><br><span class="line">├─ LICENSE.txt            # Forge 项目证书</span><br><span class="line">├─ README.txt            # 基本安装指导说明书</span><br><span class="line">│</span><br><span class="line">├─ gradle/</span><br><span class="line">│   └─wrapper/            # 这里包含了 Gradle Wrapper，这里使用的是 7.4.2</span><br><span class="line">│        ├─ gradle-wrapper.jar</span><br><span class="line">│        └─ gradle-wrapper.properties</span><br><span class="line">│</span><br><span class="line">├─ run/                # 在构建项目后会出现，相当于 .minecraft</span><br><span class="line">|</span><br><span class="line">└─src/                    # 源文件目录</span><br><span class="line">└─main/                # main 分组的源文件目录</span><br><span class="line">  ├─java/            # main 分组的 java 源文件</span><br><span class="line">  │              # 这里是 java 的 package，将来在这里写 mod</span><br><span class="line">  │</span><br><span class="line">  └─resources/        # main 分组的资源目录</span><br><span class="line">      ├─ pack.mcmeta    # 被 minecraft 用来识别数据和资源包的文件</span><br><span class="line">      │</span><br><span class="line">      └─META-INF/    # Forge 资源 metadata 信息文件存放目录</span><br><span class="line">           └─ mods.toml    # mod 声明的文件</span><br></pre></td></tr></table></figure><p><strong>其中最为重要的几个分别为</strong>：</p><ul><li><code>build.gradle</code>、<code>gradlew.bat</code>、<code>gradlew</code>、<code>gradle/</code> 目录；</li></ul><p>只要有了上面几个的数据，就能创建一个新 <code>mod</code> 项目；</p></blockquote></li><li><p>把上面说的重要的几个文件复制到新目录，以后这里是 mod 项目的根目录了（这么做是为了减少文件干扰，毕竟我们不需要版本控制，对吧）；</p></li><li><p>用 IDEA 打开这个新目录，即可自动下载依赖配件、设置项目；如果中途出现错误，99% 是因为网络错误。请翻*GFW，或者上网找国内源解决；</p></li><li><p>打开后，在 IDEA Terminal 下执行 <code>gradlew genIntellijRuns</code>（如果是 eclipse/vscode，那么后面一个词分别是 <code>genEclipseRuns</code> 和 <code>genVSCodeRuns</code>），它会进一步下载游戏需要的资源，并且设置 <code>Run Configure</code>；</p></li></ol></li><li><p>mod 的 gradle 脚本个性化：刚入门，介绍简单的个性化方式，主要是编辑 <code>build.gradle</code> 的内容。</p><ul><li><p><strong>注意，在不知道含义的情况下，不能编辑其中的 <code>buildscript &#123;&#125;</code> 块。这些代码对于 <code>ForgeGradle</code> 来说是必须的</strong>；</p></li><li><p><strong>更改构建的结果文件名</strong>：编辑 <code>archivesBaseName</code> 的值；</p></li><li><p><strong>更改 <code>maven</code> 构建系统的根目录</strong>：编辑 <code>group</code> 的值；</p></li><li><p><strong>更改 mod 版本信息</strong>：编辑 <code>version</code> 的值；</p></li><li><p><strong>将其中所有 “examplemod” 都替换为自己 mod id（自己定，唯一，只能有小写字母，不能有大写/空格/其他字符，切记！！！）</strong>；</p></li><li><p><strong>设置项目名称映射（mappings）</strong>：在 <code>minecraft&#123;&#125;</code> 块中，第一个就是 <code>mappings</code>，默认官方的 mappings。但是，官方的<strong>没有参数和 <code>javadocs</code> 提示</strong>。如果之后用的不习惯，可以换成以前 <code>MCP</code> 的 mappings（现在已经停止维护）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minecraft &#123;</span><br><span class="line">    <span class="comment">// 这是最后一次 mappings 的更新</span></span><br><span class="line">    mappings channel: <span class="string">&#x27;snapshot&#x27;</span>, version: <span class="string">&#x27;20210309-1.16.5&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>注意：修改完 <code>build.gradle</code> 脚本后需要重新进行前面的步骤进行设置</strong>；</p></blockquote></li><li><p>forge 项目的构建和测试</p><ul><li><p>当 mod 开发结束后，根目录运行 <code>gradlew build</code>，会向 <code>build/libs</code> 中构建 <code>[archivesBaseName]-[version].jar</code>，您可以直接将这个包放在安装了 forge 的 minecraft 游戏的 <code>mod</code> 目录中，即可加载；</p></li><li><p>当然，每写一次就要加入游戏目录的操作不现实。所以测试中，可以使用 <code>Run Configure</code> 来运行测试的 Minecraft 服务器 + 客户端，<strong>这时会加入开发目录（之前说过，<code>src/main/java</code>）的所有 mod jar 包</strong>；</p><blockquote><p>具体命令：启动服务器 <code>gradlew runServer</code>，自动绑定在 <code>localhost</code> 的指定端口；启动客户端 <code>gradlew runClient</code>；</p><p><strong>测试时建议就用上面的测试服务器环境哦~ 别去网络上正式的服务器测试</strong>😂</p></blockquote></li></ul></li></ul><h3 id="0-6-Mod-结构设计"><a href="#0-6-Mod-结构设计" class="headerlink" title="0.6 Mod 结构设计"></a>0.6 Mod 结构设计</h3><ul><li><p>和普通 Java 项目一样，设定好 top level package，然后为 mod 起一个唯一的名字；比如，我的 top level package 名叫做 <code>com.test</code>，然后我起个包名 <code>helloMC</code>，于是叫 <code>com.test.helloMC</code>；</p><blockquote><p>还是补充一下，如果以后做 Java Web，top level package 的名字需要是自己有的域名前缀，例如我有 <code>xxx.org</code>，那么为这个域名开发 Java Web 服务的规范就是 top level package <code>org.xxx</code>；</p></blockquote></li><li><p><code>mods.toml</code> 文件设计：上面说过，这个文件定义了 mod 的元信息（metadata），<strong>可以被 mod 使用者在游戏添加 mod 的界面看到</strong>；</p><ul><li><p>一个信息文件能够描述多个 mod；</p></li><li><p><code>mods.toml</code> 的语言是 <code>TOML</code>（可以理解为和 <code>YAML</code> 差不多的东西，语法不一样），必须要被存放于 <code>src/main/resources/META-INF/</code> 下；</p></li><li><p>一个 <code>mods.toml</code> 最基本的模板如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The name of the mod loader type to load - for regular FML @Mod mods it should be javafml</span></span><br><span class="line">   <span class="attr">modLoader</span>=<span class="string">&quot;javafml&quot;</span></span><br><span class="line">   <span class="comment"># A version range to match for said mod loader - for regular FML @Mod it will be the forge version</span></span><br><span class="line">   <span class="comment"># Forge for 1.16.5 is version 36</span></span><br><span class="line">   <span class="attr">loaderVersion</span>=<span class="string">&quot;[36,)&quot;</span></span><br><span class="line">   <span class="comment"># The license for your mod. This is mandatory and allows for easier comprehension of your redistributive properties.</span></span><br><span class="line">   <span class="comment"># Review your options at https://choosealicense.com/. All rights reserved is the default copyright stance, and is thus the default here.</span></span><br><span class="line">   <span class="attr">license</span>=<span class="string">&quot;All Rights Reserved&quot;</span></span><br><span class="line">   <span class="comment"># A URL to refer people to when problems occur with this mod</span></span><br><span class="line">   <span class="attr">issueTrackerURL</span>=<span class="string">&quot;github.com/MinecraftForge/MinecraftForge/issues&quot;</span></span><br><span class="line">   <span class="comment"># If the mods defined in this file should show as separate resource packs</span></span><br><span class="line">   <span class="attr">showAsResourcePack</span>=<span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">   <span class="section">[[mods]]</span></span><br><span class="line">     <span class="attr">modId</span>=<span class="string">&quot;examplemod&quot;</span></span><br><span class="line">     <span class="attr">version</span>=<span class="string">&quot;1.0.0.0&quot;</span></span><br><span class="line">     <span class="attr">displayName</span>=<span class="string">&quot;Example Mod&quot;</span></span><br><span class="line">     <span class="attr">updateJSONURL</span>=<span class="string">&quot;minecraftforge.net/versions.json&quot;</span></span><br><span class="line">     <span class="attr">displayURL</span>=<span class="string">&quot;minecraftforge.net&quot;</span></span><br><span class="line">     <span class="attr">logoFile</span>=<span class="string">&quot;logo.png&quot;</span></span><br><span class="line">     <span class="attr">credits</span>=<span class="string">&quot;I&#x27;d like to thank my mother and father.&quot;</span></span><br><span class="line">     <span class="attr">authors</span>=<span class="string">&quot;Author&quot;</span></span><br><span class="line">     <span class="attr">description</span>=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">     Lets you craft dirt into diamonds. This is a traditional mod that has existed for eons. It is ancient. The holy Notch created it. Jeb rainbowfied it. Dinnerbone made it upside down. Etc.</span></span><br><span class="line"><span class="string">     &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">     <span class="section">[[dependencies.examplemod]]</span></span><br><span class="line">       <span class="attr">modId</span>=<span class="string">&quot;forge&quot;</span></span><br><span class="line">       <span class="attr">mandatory</span>=<span class="literal">true</span></span><br><span class="line">       <span class="attr">versionRange</span>=<span class="string">&quot;[36,)&quot;</span></span><br><span class="line">       <span class="attr">ordering</span>=<span class="string">&quot;NONE&quot;</span></span><br><span class="line">       <span class="attr">side</span>=<span class="string">&quot;BOTH&quot;</span></span><br><span class="line">    </span><br><span class="line">     <span class="section">[[dependencies.examplemod]]</span></span><br><span class="line">       <span class="attr">modId</span>=<span class="string">&quot;minecraft&quot;</span></span><br><span class="line">       <span class="attr">mandatory</span>=<span class="literal">true</span></span><br><span class="line">       <span class="attr">versionRange</span>=<span class="string">&quot;[1.16.5,1.17)&quot;</span></span><br><span class="line">       <span class="attr">ordering</span>=<span class="string">&quot;NONE&quot;</span></span><br><span class="line">       <span class="attr">side</span>=<span class="string">&quot;BOTH&quot;</span></span><br></pre></td></tr></table></figure><p>以下是必须要填写的信息列表：</p><table>    <tr style="text-align: center;">        <th>Property</th>        <th>Type</th>        <th>Default</th>        <th>Description</th>    </tr>    <tr>        <td>modid</td>        <td>string</td>        <td>mandatory</td>        <td>The modid this file is linked to (also the modid in build.gradle).</td>    </tr>    <tr>        <td>version</td>        <td>string</td>        <td>mandatory</td>        <td>The version of the mod. It should be just numbers separated by dots, ideally conforming to Forge’s Semantic Versioning structure.</td>    </tr>    <tr>        <td>displayName</td>        <td>string</td>        <td>mandatory</td>        <td>The user-friendly name of this mod.</td>    </tr>    <tr>        <td>updateJSONURL</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>The URL to a version JSON.</td>    </tr>    <tr>        <td>displayURL</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>A link to the mod’s homepage.</td>    </tr>    <tr>        <td>logoFile</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>The filename of the mod’s logo. It must be placed in the root resource folder, not in a subfolder.</td>    </tr>    <tr>        <td>credits</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>A string that contains any acknowledgements you want to mention.</td>    </tr>    <tr>        <td>authors</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>The authors of this mod.</td>    </tr>    <tr>        <td>description</td>        <td>string</td>        <td>mandatory</td>        <td>A description of this mod.</td>    </tr>    <tr>        <td>dependencies</td>        <td>[list]</td>        <td>[]</td>        <td>A list of dependencies of this mod.</td>    </tr></table></li></ul></li><li><p><code>@Mod</code> annotation：在编写 mod 中，这个标识是用来提示 <code>Forge Mod Loader</code>，<strong>这个类是一个 Mod entry point</strong>；另外，这个标识的值需要是 <code>modid</code>（在 <code>build.gradle</code> 和 <code>mods.toml</code> 都写过）；</p></li><li><p><strong>一个建议</strong>（不强制）：比起将源文件散落在文件夹中，使用 <code>sub-packages</code> 的结构可读性更强；例如像物体（items）、方块（blocks）、数据实体（tile entities，或者其他 sub-packages）应该放在 <code>common</code> 包，而屏幕（Screens）、渲染器（Renderers）应该放在 <code>client</code> 下；</p><blockquote><p>这里补充一下什么是 <code>tile entities</code>，后面用到详细说。</p><p>Tile Entities就像简化的实体一样，绑定到Block上。 它们用于存储动态数据，执行基于tick的任务以及动态渲染。 </p><p>原本 Minecraft的一些例子是：处理库存（箱子），熔炉上的冶炼逻辑或信标的区域效应。 mod中存在更高级的示例，例如采石场，分拣机，管道和显示器。</p><p>注意：不要滥用！如果使用不当会导致卡顿；</p></blockquote></li><li><p>类名命名规范：<strong>在您创建的类名之后加上它们的父类名（即是什么），可以让读者更能理解这个类在干什么</strong>；</p><blockquote><p>这其实是所有语言、所有场景开发的共同的规范。</p><p>例如，一个自定义物品 <code>PowerRing</code>，它的类继承于 <code>Item</code>，因此最好定为 <code>PowerRingItem</code>;</p><p>再如一个自定义方块 <code>NotDirt</code>，继承于 <code>Block</code>，因此命名为 <code>NotDirtBlock</code>；</p></blockquote></li></ul><h3 id="0-7-Mod-更新系统"><a href="#0-7-Mod-更新系统" class="headerlink" title="0.7 Mod 更新系统"></a>0.7 Mod 更新系统</h3><p>Forge 提供了一个可选的、轻量级的更新检查的框架，在作者提交更新后，使用 mod 的用户会在游戏中 mod 管理的按钮上看到更新，并且会写入 <code>changelogs.txt</code>，但不会自动下载升级；</p><p>为了集成这个功能，只需设置上面 <code>mods.toml</code> 的可选参数 <code>updateJSONURL</code>，这个 URL 可以指向您提供 “update json” 的网站服务器或者 github 上（只要别人能访问到）；</p><p>而这个 “update json” 的格式为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;homepage/download page for your mod&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;&lt;mcversion&gt;&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&lt;modversion&gt;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;changelog for this version&gt;&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="comment">// List all versions of your mod for the given Minecraft version, along with their changelogs</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;promos&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&lt;mcversion&gt;-latest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;modversion&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// Declare the latest &quot;bleeding-edge&quot; version of your mod for the given Minecraft version</span></span><br><span class="line">    <span class="attr">&quot;&lt;mcversion&gt;-recommended&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;modversion&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// Declare the latest &quot;stable&quot; version of your mod for the given Minecraft version</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>值得注意的是：</p><ul><li><code>homepage</code> 的地址在使用者的 mod 需要更新时会显示出来，注意隐私；</li><li>Forge 使用一套内置算法来判断当前版本和 update JSON 的版本哪个更新，大多数情况下应该没问题，如果有疑惑可以查阅 <code>ComparableVersion</code> 类或 <a href="https://semver.org/">Semantic Versioning</a>；</li><li>上面的 <code>changelog</code> 字符串可以使用 <code>\n</code>，也可以给用户提供一个网站让他们在网站上详细看；</li></ul><h3 id="0-8-Mod-进阶调试"><a href="#0-8-Mod-进阶调试" class="headerlink" title="0.8 Mod 进阶调试"></a>0.8 Mod 进阶调试</h3><p>Minecraft 自身提供了一个 Debug Profiler，能够分析出耗时的代码块，这对于 mod 开发者和服务器管理员非常有用；</p><p>开始分析命令：<code>/debug start</code>，结束分析命令：<code>/debug end</code>；</p><ul><li><p>建议最少给 Debug Profiler 的分析留出 1 min 时间，时间越多，分析约准确；</p></li><li><p>要分析的实体（Entities）需要在当前世界中存在，不然分析不到它；</p></li></ul><p>在结束分析后，会自动生成 <code>profile-results-yyyy-mm-dd_hh.mi.ss.txt</code>，</p><p>文件格式：<code>&lt;the depth of the section&gt; | &lt;the name of the section&gt; - &lt;the percentage of time it took in relation to it’s parent&gt;/&lt;how much time it took from the entire tick&gt;</code></p><h3 id="0-9-第一个-Mod：跑通流程"><a href="#0-9-第一个-Mod：跑通流程" class="headerlink" title="0.9 第一个 Mod：跑通流程"></a>0.9 第一个 Mod：跑通流程</h3><p>上面说了很多内容，现在让我们以一个没有内容的测试 mod 来实际跑一遍：</p><p><strong>step 1.</strong> 在 <code>src/main/java</code> 下创建一个包，例如 <code>com.test</code>，创建 Java 类 <code>HelloMC</code>；</p><p><strong>step 2.</strong> 根据 0.6 节中介绍的 modid，<strong>需要用 <code>@Mod(&lt;modid&gt;)</code> 修饰 mod 的 entry point 类</strong>，保持：<strong>@Mod 修饰值、<code>mods.toml</code> 的 <code>modid</code>、<code>build.gradle</code> 的 <code>examplemod</code> 三者一致</strong>。因此，我们需要给 <code>HelloMC</code> 加 <code>@Mod()</code> annotation。为了方便，我们另外创建一个类，专门存储全局变量，就定为 <code>Utils</code>（你也可以不用，看自己的编码习惯）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HelloMC.java</span></span><br><span class="line"><span class="keyword">package</span> com.test.HelloMC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.minecraftforge.fml.common.Mod;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mod(Utils.MOD_ID)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloMC</span> &#123;</span><br><span class="line">    <span class="comment">// 这里先空着，因为没学</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: Utils.java</span></span><br><span class="line"><span class="keyword">package</span> com.test.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MOD_ID</span> <span class="operator">=</span> <span class="string">&quot;mymod&quot;</span>;        <span class="comment">// 自己写 modid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>step 3.</strong> 现在去写 <code>mods.toml</code>，注意填写 <code>mod_id</code>：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面使用的 @Mod 就在这个 modLoader 中，和 loaderVersion 不用改</span></span><br><span class="line">   <span class="attr">modLoader</span>=<span class="string">&quot;javafml&quot;</span></span><br><span class="line">   <span class="attr">loaderVersion</span>=<span class="string">&quot;[36,)&quot;</span></span><br><span class="line">   <span class="comment"># 自己选证书：https://choosealicense.com/.</span></span><br><span class="line">   <span class="attr">license</span>=<span class="string">&quot;All Rights Reserved&quot;</span></span><br><span class="line">   <span class="comment"># 自己定义 issue 提问网站，可选</span></span><br><span class="line">   <span class="attr">issueTrackerURL</span>=<span class="string">&quot;https://github.com/MinecraftForge/MinecraftForge/issues&quot;</span></span><br><span class="line">   <span class="comment"># 暂时用不到，不管它</span></span><br><span class="line">   <span class="attr">showAsResourcePack</span>=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">   <span class="section">[[mods]]</span></span><br><span class="line">     <span class="attr">modId</span>=<span class="string">&quot;yourID&quot;</span></span><br><span class="line">     <span class="attr">version</span>=<span class="string">&quot;1.0.0.0&quot;</span></span><br><span class="line">     <span class="attr">displayName</span>=<span class="string">&quot;Example Mod&quot;</span></span><br><span class="line">     </span><br><span class="line">     <span class="attr">updateJSONURL</span>=<span class="string">&quot;minecraftforge.net/versions.json&quot;</span>    <span class="comment"># 中间这块都是可选的</span></span><br><span class="line">     <span class="attr">displayURL</span>=<span class="string">&quot;minecraftforge.net&quot;</span></span><br><span class="line">     <span class="attr">logoFile</span>=<span class="string">&quot;logo.png&quot;</span></span><br><span class="line">     <span class="attr">credits</span>=<span class="string">&quot;I&#x27;d like to thank my mother and father.&quot;</span></span><br><span class="line">     <span class="attr">authors</span>=<span class="string">&quot;Author&quot;</span></span><br><span class="line">     </span><br><span class="line">     <span class="attr">description</span>=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">     Lets you craft dirt into diamonds. This is a traditional mod that has existed for eons. It is ancient. The holy Notch created it. Jeb rainbowfied it. Dinnerbone made it upside down. Etc.</span></span><br><span class="line"><span class="string">     &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的依赖是必要的，别碰</span></span><br><span class="line">     <span class="section">[[dependencies.yourID]]</span></span><br><span class="line">       <span class="attr">modId</span>=<span class="string">&quot;forge&quot;</span></span><br><span class="line">       <span class="attr">mandatory</span>=<span class="literal">true</span></span><br><span class="line">       <span class="attr">versionRange</span>=<span class="string">&quot;[36,)&quot;</span></span><br><span class="line">       <span class="attr">ordering</span>=<span class="string">&quot;NONE&quot;</span></span><br><span class="line">       <span class="attr">side</span>=<span class="string">&quot;BOTH&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="section">[[dependencies.yourID]]</span></span><br><span class="line">       <span class="attr">modId</span>=<span class="string">&quot;minecraft&quot;</span></span><br><span class="line">       <span class="attr">mandatory</span>=<span class="literal">true</span></span><br><span class="line">       <span class="attr">versionRange</span>=<span class="string">&quot;[1.16.5,1.17)&quot;</span></span><br><span class="line">       <span class="attr">ordering</span>=<span class="string">&quot;NONE&quot;</span></span><br><span class="line">       <span class="attr">side</span>=<span class="string">&quot;BOTH&quot;</span></span><br></pre></td></tr></table></figure><p><strong>step 4.</strong> 再到 <code>build.gradle</code> 中，将所有 <code>examplemod</code> 换成自己的 modid，修改个性化内容，然后构建！</p><p><strong>step 5.</strong> 启动 IDEA 上的任务设置 “RunClient”，进入游戏查看自己的 mod 是否已经显示！</p><h3 id="0-10-事件系统"><a href="#0-10-事件系统" class="headerlink" title="0.10 事件系统"></a>0.10 事件系统</h3><p>早在 0.3 节说明运行模式的时候，我们提到了 <code>Mod</code> 总线和 <code>Forge</code> 总线，这里在开发前必须要说清楚。Forge 自己的事件系统内是独立于 Minecraft 的事件系统的。</p><p>使用 Forge 事件系统的方法有 2 种，先看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEventHandler</span> &#123;</span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pickupEvent</span><span class="params">(EntityItemPickupEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Item picked up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个类 <code>TestEventHandler</code>，里面有个实例方法 <code>pickupEvent()</code>。注意 <code>@SubscribeEvent</code> 标记，<strong>它的作用就是指示下方的方法为事件处理器</strong>，而它监听的事件类型由它的参数决定（<code>EntityItemPickupEvent</code>，实体捡起物品这个事件）。</p><p>但是只是让他声明为事件处理器还不够，还需要在合适的位置将含有事件处理器的类<strong>实例化</strong>，并<strong>注入事件总线中</strong>。是 <code>Forge</code> 总线还是 <code>Mod</code> 总线？</p><ul><li><p><code>Mod</code> 总线：负责游戏的生命周期事件，也就是<strong>初始化过程的事件</strong>；注册方法：<code>FMLJavaModLoadingContext.get().getModEventBus().register(&lt;subscribed_event_obj&gt;)</code>；</p></li><li><p><code>Forge</code> 总线：负责的就是除了生命周期事件外的所有事件；注册方法：<code>MinecraftForge.EVENT_BUS.register(&lt;subscribed_event_obj&gt;)</code>；</p></li></ul><p>显然，上面 “实体捡起物品” 的事件在初始化过程之外，所以加入 <code>Forge</code> 总线：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MinecraftForge.EVENT_BUS.register(<span class="keyword">new</span> <span class="title class_">TestEventHandler</span>());</span><br></pre></td></tr></table></figure><p>显然这样注册的方法比较麻烦，被称为 “实例注册方式”。还有一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mod</span>.EventBusSubscriber(modid = <span class="string">&quot;mymod&quot;</span>, bus = Bus.FORGE, value = Dist.CLIENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStaticClientOnlyEventHandler</span> &#123;</span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">drawLast</span><span class="params">(RenderWorldLastEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管传给注解的参数（都是可选的），我们发现，这个类中的事件处理器是<strong>静态的</strong>（另注：由于是渲染事件，所以仅客户端）。这里，我们就可以在整个类前加上注解 <code>@Mod.EventBusSubscriber([modid, bus, value])</code>，表示将类中的所有事件处理器都加入指定 modid、总线、端中。</p><p>这里补充，如果是 <code>Mod</code> 总线，那么 <code>bus = Bus.MOD</code>，更多信息可以转到 <code>@Mod.EventBusSubscriber()</code> 的源码查看。</p><h2 id="Chapter-1-创建物品"><a href="#Chapter-1-创建物品" class="headerlink" title="Chapter 1. 创建物品"></a>Chapter 1. 创建物品</h2><h3 id="1-1-第一个物品"><a href="#1-1-第一个物品" class="headerlink" title="1.1 第一个物品"></a>1.1 第一个物品</h3><p>本节了解，创建一个物品就 3 步【所有物品都是这样】：</p><ol><li>创建自己的物品类，一般继承于原版的物品的类 <code>Item</code>；</li><li>在合适的位置实例化这个物品；</li><li>将此物品对象注册进游戏；</li></ol><p>我们先以一个原版游戏中没有 “黑曜石锭” 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianIngot</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObsdianIngot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Properties</span>().group(ItemGroup.MATERIALS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就写了一个构造函数，向父类的构造函数传递了一个 <code>Properties</code> 类的对象，而这个 <code>Properties</code> 对象调用了 <code>group()</code>，<strong>表示设置物品所在组为 <code>Materials</code> 组（杂项栏）</strong>。</p><p>传给父类的 <code>Properties</code> 对象的作用是规定了物品的一些属性，比如：是不是食物，或者这个物品在创造模式的哪一个物品栏。这里的 <code>group()</code> 方法就是设置了物品在创造模式的杂项栏。</p><p>如果不调用 <code>group()</code> 方法设置，那么这个物品就不会出现在创造模式物品栏，只能用 <code>/give</code> 获取；</p><p>然后是实例化 + 注册。现在的 <code>Forge</code> 引入了 <code>DeferredRegister</code>的机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DeferredRegister&lt;Item&gt; item_reg = </span><br><span class="line">        DeferredRegister.create(ForgeRegistires.ITEMS, Utils.MOD_ID);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsdianIngot = </span><br><span class="line">        item_reg.register(<span class="string">&quot;obsidian_ingot&quot;</span>, ObsidianIngot::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先使用 <code>DeferredRegister</code> 泛型类的静态方法 <code>create(&lt;ForgeRegistries.TYPE&gt;, &lt;mod_id&gt;)</code> 向 <code>mod_id</code> 的 mod 创建了一个 <code>DeferredRegister&lt;Type&gt;</code>  对象，表示<strong>这是专门注册 <code>Type</code> 类型实体的类</strong>。</p><p>紧接着告诉这个对象要注册 “注册名为 ‘obsdian_ingot’（不能大写）、其对象构造方法为 <code>ObsidianIngot::new</code>” 的一个类的 <code>supplier</code>。</p><p>最后，由于这个 <code>DeferredRegister</code> 泛型类帮助我们注册物品需要依赖<strong>注入事件</strong>。显然注册是一种初始化的事件，所以将 <code>DeferredRegister</code> 对象注入 <code>Mod</code> 总线（我们以 0.9 中的项目为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mod(Utils.MOD_ID)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloMC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloMC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// DeferredRegister 的 register 方法如果参数是总线，就将自己注入总线中</span></span><br><span class="line">        ItemRegistry.item_reg.register(</span><br><span class="line">            <span class="comment">// 这里前面说过，获取 Mod 总线</span></span><br><span class="line">            FMLJavaModLoadingContext.get().getModEventBus()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会发现新的、没有材质的物品出现在创造模式的物品栏中。</p><h3 id="1-2-物品的模型和材质"><a href="#1-2-物品的模型和材质" class="headerlink" title="1.2 物品的模型和材质"></a>1.2 物品的模型和材质</h3><p>一个物品被注册后，还应该指定它的模型和材质。这种指定方式也是固定的，记忆即可。下面以上面的 <code>ObsidianIngot</code> 为例。</p><p>第一步，在 <code>src/main/resources</code> 创建 <code>assets</code> 目录，表示这个 mod 存储资源的位置。并将目录补充为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resources/</span><br><span class="line">├── META-INF/</span><br><span class="line">│   └── mods.toml</span><br><span class="line">├── assets/</span><br><span class="line">│   └── mymod/        # 你的 modid</span><br><span class="line">│       ├── models/</span><br><span class="line">│       │   └── item/    # MC 中要求这个目录名，不能改，表示 item（物品）类型</span><br><span class="line">│       └── textures/</span><br><span class="line">│           └── item/</span><br><span class="line">└── pack.mcmeta</span><br></pre></td></tr></table></figure><p>一定要创建 <code>pack.mcmeta</code>，这相当于为 mod <strong>规定了资源包</strong>。只有这么做，MC 才能发现 <code>assets</code> 中的资源。格式也是 <code>JSON</code>，模板：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">  <span class="attr">&quot;pack&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pack_format&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span>    <span class="comment">// 看官网，pack_format = 10 时支持 MC 1.20 以下的版本</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Resource Pack&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;language&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;LANG_COUNTRY&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Custom Language&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Country/Region name&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bidirectional&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>第二步，在 <code>models/item</code> 的目录中创建 <code>obsidian_ingot.json</code>，文件名需要和之前<strong>物品注册名</strong>相同。</p><p><code>item</code>（物品类）模型的 JSON 文件的模板如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 父模型，即由什么模型加载而来</span></span><br><span class="line">    <span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/generated&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;textures&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">// 指定了最底层的材质（格式在 0.4 中已经叙述）</span></span><br><span class="line">        <span class="attr">&quot;layer0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mymod:item/obsidian_ingot&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>textures/item</code> 的目录中放入自己设计的材质 <code>obsidian_ingot.png</code>（游戏中 1:1，<strong>仅贴图最好不要大于 32×32 像素</strong>），文件名也是物品注册名。</p><p>最后启动游戏就会发现游戏自动读取了模型和材质。</p><p>注：自己制作模型的网站戳 <a href="https://blockbench.net/">这里</a>；</p><h4 id="补充：BlockBench-笔记"><a href="#补充：BlockBench-笔记" class="headerlink" title="补充：BlockBench 笔记"></a>补充：BlockBench 笔记</h4><ul><li>绑骨：按照父级模型生长方向移动、旋转等操作，可以用作设计动画；</li><li>顶点识别；</li><li>隐藏的菜单：x/y/z 轴翻转；</li><li>缩放参数：可以在不改变材质的情况下改变模型大小，允许小数；</li><li>大纲视图的锁定：可以防止误操作；</li><li>背景图的作用大部分是用来拾色的；</li><li>后期添加模型过大，放不下空白材质时，可以为材质调整大小；</li></ul><h3 id="1-3-Item-类和-ItemStack-类"><a href="#1-3-Item-类和-ItemStack-类" class="headerlink" title="1.3 Item 类和 ItemStack 类"></a>1.3 <code>Item</code> 类和 <code>ItemStack</code> 类</h3><p>前面两节叙述了加入普通自定义物品（<code>item</code>）的大致流程。现在深入一下更抽象的层面，考虑这些物品背后的类，以便我们进一步对它们进行自定义。</p><p>首先，很方便理解的是 <code>Item</code> 类，就是规定每种物品属性的类。细心的同学可能会提问，我们之前创建的 <code>ObsidianIngot</code> 这个类在游戏的框中显示的数量呢？一组应该是多少个呢？<code>Item</code> 类都没有定义。</p><p>这是因为，设计者考虑到 <code>item</code> 的有些信息不会因为数量、耐久等参数的改变而改变，例如：</p><ul><li>使用/放置（左键/右键）的行为；</li><li>在客户端上显示的名称及 Tooltip；</li><li>合成配方；</li><li>et cetera；</li></ul><p>这些抽象的属性都在 <code>Item</code> 类中得到定义；而数量、是否有/有多少耐久等信息，就单独提出去打包为一个类，其名曰 <code>ItemStack</code>。游戏中，玩家的物品栏、背包、手持物品等，<strong>都是 <code>ItemStack</code> 的实例</strong>。</p><p>所以，可以将 <code>ItemStack</code> 和 <code>Item</code> 的关系看作<strong>类的聚集</strong>，在对 <code>ItemStack</code> 可以调用 <code>getItem()</code> 实例方法来获得其中含有的 <code>Item</code> 对象。</p><h4 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h4><p>另外有个极其重要的概念——“<strong>享元（Flyweight Pattern）</strong>”，即<strong>一种特定物品只对应一个实例</strong>，而 <code>Item</code> 就是一个享元。这意味着，以 <code>Apple</code> 类为例，你在游戏里见到<strong>所有</strong>苹果都是 <code>Apple</code> 类的唯一实例。正因如此，我们在编写 mod 中，可以直接用 <code>==</code>（即  <code>&lt;ItemStack_obj&gt;.getItem() == &lt;Item_obj&gt;</code>）来判断 <code>Item</code> 种类，不用担心 <code>==</code> 比较的是地址。</p><h4 id="Item-AIR"><a href="#Item-AIR" class="headerlink" title="Item.AIR"></a><code>Item.AIR</code></h4><p>还有一件事，由于 <code>ItemStack</code> 是 <code>non-null</code> 的属性，永远是非空引用，所以 <strong>MC 中 “空的” 栏的 <code>ItemStack</code> 所含的 <code>Item</code> 对象是个特殊对象：<code>Items.AIR</code></strong>。判断 <code>ItemStack</code> 对应的栏目物品是否为空时，应该使用专用的实例函数 <code>isEmpty()</code>，不能直接判断是否为 <code>null</code>。</p><h3 id="1-4-自定义物品组"><a href="#1-4-自定义物品组" class="headerlink" title="1. 4 自定义物品组"></a>1. 4 自定义物品组</h3><p>物品组可以形象地理解为创造模式物品栏的分栏。我们在最开始就提到的类 <code>ItemGroup</code>，所以自定义物品组很简单——就写一个继承于 <code>ItemGroup</code> 类的子类就行。</p><p>这个继承的类只需要写<strong>两个地方</strong>，一个是构造函数，直接使用父类的即可，<strong>第一个参数是物品组的名称 <code>String</code></strong>。（这个组就以 “ObsidianGroup” 为例）</p><p>另一个是重写类里面的 <code>createIcon()</code> 实例方法（实际用途是创建物品栏的图标），要求返回一个 <code>ItemStack</code> 实例（毕竟需要将物品呈现在物品栏中），这个也很简单，用 <code>ItemStack</code> 构造函数构造个实例就行。<strong><code>ItemStack</code> 构造函数的第一参数就是已注册的 <code>Item</code> 实例对象</strong>。</p><blockquote><p>从哪获取已注册的 <code>Item</code> 实例？简单，之前我们注册完物品后，<code>DeferredRegister::register</code> 方法不是返回了一个 <code>RegisterObject&lt;Item&gt;</code>，它就是包裹了注册信息的 <code>Item</code>，直接用 <code>get()</code> 实例方法就能返回已注册的 <code>Item</code> 实例。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianGroup</span> <span class="keyword">extends</span> <span class="title class_">ItemGroup</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObsidianGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;obsidian_group&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemStack <span class="title function_">createIcon</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ItemRegistry.obsidianIngot 对象在 1.1 中定义，忘了回去看</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemStack</span>(ItemRegistry.obsidianIngot.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个简单的物品组类就做好了。但是想要将它显示在游戏里，还要将它在合适的位置实例化。</p><p>我们再定义一个类，专门存放 mod 中实例化的 <code>ItemGroup</code> 的类，就叫 <code>ModGroup</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModGroup</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ItemGroup</span> <span class="variable">og_group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObsidianGroup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在物品类初始化的时候，用 <code>Properties::group()</code> 实例方法将物品加入 <code>og_group</code> 这个实例即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianIngot</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObsidianIngot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Properties</span>().group(ModGroup.itemGroup));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-食物"><a href="#1-5-食物" class="headerlink" title="1.5 食物"></a>1.5 食物</h3><p>食物就是一种特殊的 <code>Item</code>，也继承于 <code>Item</code> 来创建，只是比普通 <code>Item</code> 多几个属性（包括专门的类 <code>Food</code> 作为属性）。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianApple</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="comment">// 定义食物的属性，使用 Food 类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> (</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Food</span>.Builder().saturation(<span class="number">10</span>)</span><br><span class="line">                          .hunger(<span class="number">20</span>)</span><br><span class="line">                          <span class="comment">// 使用接口创建 Supplier&lt;EffectInstance&gt;</span></span><br><span class="line">                          .effect(() -&gt; <span class="keyword">new</span> <span class="title class_">EffectInstance</span>(Effects.POISON, <span class="number">3</span>*<span class="number">20</span>, <span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">                          .build();</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为 Java 基础补充知识：<code>Java</code> <code>Supplier</code>是一个功能接口，代表结果的提供者，<strong>存在于 <code>java.util.function</code> 包</strong>。常用方法是 <code>get()</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用来返回一个<strong>特定</strong>的结果对象。我们可以用 <code>lambda</code> 表达式，例如上面 <code>() -&gt; new EffectInstance(Effects.POISON, 3*20, 1)</code> 创建一个调用返回新 <code>EffectInstance</code> 对象的匿名函数。这个格式得到的左值就是 <code>supplier</code>。</p><p>也可以定义一个完整的匿名函数：<code>() -&gt; &#123; return XXX; &#125;</code></p></blockquote><p>其中，<code>Food::Builder()</code> 静态方法初始化 <code>Food.Builder</code> 类实例，用来在 <code>Food</code> 属性对象生成前设置好参数，支持 <code>saturation()</code>、<code>hunger()</code>、<code>effect()</code> 方法。</p><p>需要说明的是，其中 <code>effect()</code> 方法的<strong>第一参数</strong>是 <code>Supplier&lt;EffectInstance&gt;</code>，<strong>第二参数</strong>是<strong>触发的概率</strong>。<code>EffectInstance</code> 类的初始化方法第一参数是 <strong><code>Effects</code> 类的枚举量</strong>（含有 MC 中几乎所有效果），第二参数是效果持续的游戏 Tick 时间，第三参数是对应的药水等级。</p><blockquote><p>一个游戏刻 <code>Tick</code> 就是主程序循环一次的时间，固定是 <code>0.05 s</code>；上面的 <code>3*20</code> 就是 3 秒。</p></blockquote><p>最后的 <code>Food.Builder::build()</code> 方法将 <code>Food.Builder</code> 及其中的设置构造为 <code>Food</code> 类的实例，可以在初始化物品时对 <code>Properties</code> 对象使用 <code>food()</code> 方法指定（和 <code>group()</code> 一样）。</p><p>接下来的物品注册、模型和材质都与普通 <code>Item</code> 相差无几。</p><h3 id="1-6-近战武器-和-工具"><a href="#1-6-近战武器-和-工具" class="headerlink" title="1.6 近战武器 和 工具"></a>1.6 近战武器 和 工具</h3><p><strong>MC 原版 1.16.5 的近战武器可以认为只有剑</strong>，如果想要自定义近战物品，就可以按剑的类的做法来做（入门不介绍攻击动画的制作，就复用剑的攻击动画）。</p><p><strong>MC 原版 1.16.5 的工具就是耳熟能详几件：稿子、铲子、斧头、锄头</strong>。</p><p>首先，细心的同学可以发现，木头、石头、铁、黄金和钻石种类的武器面板基础数据（除去附魔等加成的效率、耐久、伤害……）是不同的，并且损坏后修复的材料不同。但它们都是 “剑 / 稿 / 斧 / 锄 / 铲” 这个属性，所以这些额外的数据<strong>可以抽象为一个单独的类 / 枚举类型来管理</strong>，在初始化时再传给 “剑 / 稿 / 斧 / 锄 / 铲” 这个类。在 MC 中，它就是<strong>枚举类型 <code>ItemTier</code></strong>，即 “工具等级”（Tiered adj. 阶梯式的、分层的）。</p><p>官方选择了<strong>接口类</strong>来设计 <code>ItemTier</code>，而由于 Java 的枚举类型在能够大量定义常量的同时，允许添加方法，因此我们只需写一个枚举类来 <code>implements</code> 它。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ModItemTier</span> <span class="keyword">implements</span> <span class="title class_">ItemTier</span> &#123;</span><br><span class="line">    <span class="comment">// 规范来说，enum 内部先定义实例</span></span><br><span class="line">    OBSIDIAN(<span class="number">3</span>, <span class="number">2000</span>, <span class="number">10.0F</span>, <span class="number">4.0F</span>, <span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> harvestLevel;        <span class="comment">// 精准采集等级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxUses;            <span class="comment">// 最大耐久值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> efficiency;        <span class="comment">// 效率值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> attackDamage;    <span class="comment">// 伤害</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> enchantability;    <span class="comment">// 附魔能力</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法就是将属性值全部传进去</span></span><br><span class="line">    ModItemTier(<span class="type">int</span> harvestIn, <span class="type">int</span> maxUsesIn, <span class="type">float</span> effIn, <span class="type">float</span> attIn, <span class="type">int</span> enchantabilityIn) &#123;</span><br><span class="line">        <span class="built_in">this</span>.harvestLevel = harvestIn;</span><br><span class="line">        <span class="built_in">this</span>.maxUses = maxUsesIn;</span><br><span class="line">        <span class="built_in">this</span>.efficiency = effIn;</span><br><span class="line">        <span class="built_in">this</span>.attackDamage = attIn;</span><br><span class="line">        <span class="built_in">this</span>.enchantability = enchantabilityIn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面的部分别看它长，就是把 get 方法简单覆盖一下 -------------------|</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHarvestLevel</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.harvestLevel; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxUses</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.maxUses; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getEfficiency</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.efficiency; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getAttackDamage</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.attackDamage; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEnchantability</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.enchantability; &#125;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------------|</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 之前提到的，修复材料需要单独写一下</span></span><br><span class="line">    <span class="comment">// 但具体的合成表还需要以后写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Ingredient <span class="title function_">getRepairMaterial</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Ingredient.fromItems(ItemRegistry.obsidianIngot.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别问为什么要重新写属性并且 <code>override</code>。因为这是个 <code>enum</code> 类型，不存在继承的说法，只能 <code>implements</code>  方法。</p><p>再来看 “剑 / 稿 / 斧 / 锄 / 铲” 类的继承关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Item --&gt; TieredItem (有工具等级的 item) --&gt; SwordItem</span><br><span class="line">                |</span><br><span class="line">                └─--&gt;    ToolItem// 这里是下一节要说的 “工具”，也有工具等级</span><br><span class="line">                            ├─----------&gt; PickaxeItem</span><br><span class="line">                            ├─----------&gt; ShovelItem</span><br><span class="line">                            ├─----------&gt; AxeItem</span><br><span class="line">                            └─----------&gt; HoeItem</span><br></pre></td></tr></table></figure><p>这里简单到爆炸，只需要掌握这些类的初始化方法就行，以剑为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SwordItem</span><span class="params">(ItemTier tier_obj, <span class="type">int</span>, <span class="type">float</span>, Properties prop)</span>;</span><br></pre></td></tr></table></figure><p>像这里以黑曜石剑为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianSword</span> <span class="keyword">extends</span> <span class="title class_">SwordItem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObsidianSword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的 OBSIDIAN 是之前定义 enum ModItemTier 时创建的实例</span></span><br><span class="line">        <span class="comment">// ItemGroup.COMBAT 是战斗物品组，对应创造模式物品栏“铁剑”图标一栏</span></span><br><span class="line">        <span class="built_in">super</span>(ModIterTier.OBSIDIAN, <span class="number">3</span>, -<span class="number">2.4F</span>, <span class="keyword">new</span> <span class="title class_">Properties</span>().group(ItemGroup.COMBAT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SwordItem</code> 构造函数的第一参数 <code>ItemTier</code> 后面的两个参数分别是<strong>攻击伤害、攻击速度</strong>；</p><p>之后的模型、材质、物品注册也是完全和普通 <code>item</code> 相同。</p><p> 稿子、铲子、斧头、锄头也一样。</p><p>注意：以上数据面板理论上只要不溢出都可以自行设置。但如果想要写成好的 Mod，这边建议自己试试平衡性，再调整数值。</p><blockquote><p>你问为什么不介绍 “弓” 这种远程武器？这大概是因为 minecraft java 到处是高耦合度的代码（尤其是弓这个动作复杂的 item），哪怕仅修改拉弓速度都要引入 7~8 个包，故不再这里叙述。实在想要改，建议直接改材质 + 附魔；</p></blockquote><h3 id="1-7-可穿戴装备"><a href="#1-7-可穿戴装备" class="headerlink" title="1.7 可穿戴装备"></a>1.7 可穿戴装备</h3><p>和近战武器/工具类似，可穿戴装备也有 “工具等级” 来管理和装备位置无关的数据，这就是 <code>IArmorMaterial</code> <strong>接口类</strong>，我们模仿 1.6 中的 <code>ModItemTier</code> 用一个枚举类来自定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ObsidianArmorMaterial</span> <span class="keyword">implements</span> <span class="title class_">IArmorMaterial</span> &#123;</span><br><span class="line">    OBSIDIAN(</span><br><span class="line">        <span class="string">&quot;obsidian&quot;</span>, <span class="number">40</span>, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">5</span>&#125;, <span class="number">20</span>, SoundEvents.ITEM_ARMOR_EQUIP_DIAMOND, <span class="number">2.0F</span>, <span class="number">0.0F</span>, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Ingredient.fromItems(ItemRegistry.obsidianIngot.get());</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 下面是 IArmorMaterial 需要拥有的属性：</span></span><br><span class="line">                                                    <span class="comment">// 最大耐久数值数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] MAX_DAMAGE_ARRAY = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">13</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">11</span>&#125;;</span><br><span class="line">    <span class="comment">// 这个名字是给渲染端用的（也就是客户端），也是找材质用的名字。请确保此处、注册名、材质名三者写的是一个名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxDamageFactor;                <span class="comment">// 最大耐久衰减因数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] damageReductionAmountArray;    <span class="comment">// 减伤数组（保护效果）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> enchantability;                <span class="comment">// 附魔能力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SoundEvent soundEvent;            <span class="comment">// 穿着音效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> toughness;                    <span class="comment">// 文档没说，可以自己尝试</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> knockbackResistance;        <span class="comment">// 击退抵抗数值</span></span><br><span class="line">    <span class="comment">// 这个 LazyValue 可以理解为 Forge 包里面内含的一种容器，实现懒加载。泛型参数是懒加载的结果，而它初始化参数是对应泛型的 Supplier</span></span><br><span class="line">    <span class="comment">// 这个属性相当于 ItemTier 中的 getRepairMaterial()</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LazyValue&lt;Ingredient&gt; repairMaterial;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数还是就把之前的属性给它们赋值一遍</span></span><br><span class="line">    ObsidianArmorMaterial(</span><br><span class="line">        String armorName, <span class="type">int</span> maxDamageF, <span class="type">int</span>[]damageReductionArray,</span><br><span class="line">        <span class="type">int</span> enchantAbility, SoundEvent se, <span class="type">float</span> tough, <span class="type">float</span> knockResist,</span><br><span class="line">        Supplier&lt;Ingredient&gt; repairMaterialSupplier</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = armorName; <span class="built_in">this</span>.maxDamageFactor = maxDamageF;</span><br><span class="line">        <span class="built_in">this</span>.damageReductionAmountArray = damageReductionArray;</span><br><span class="line">        <span class="built_in">this</span>.enchantability = enchantAbility;</span><br><span class="line">        <span class="built_in">this</span>.soundEvent = se; <span class="built_in">this</span>.toughness = tough;</span><br><span class="line">        <span class="built_in">this</span>.knockbackResistance = knockResist;</span><br><span class="line">        <span class="built_in">this</span>.repairMaterial = <span class="keyword">new</span> <span class="title class_">LazyValue</span>&lt;&gt;(repairMaterialSupplier);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面实现 IArmorMaterial 接口，只要给出所有的 get 方法就行。注意名字和参数。</span></span><br><span class="line">    <span class="comment">// 注意，getName 因为是为客户端准备的函数，所以加上 annotation @OnlyIn 就行</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDurability</span><span class="params">(EquipmentSlotType slotIn)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MAX_DAMAGE_ARRAY[slotIn.getIndex()] * <span class="built_in">this</span>.maxDamageFactor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDamageReductionAmount</span><span class="params">(EquipmentSlotType slotIn)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.damageReductionAmountArray[slotIn.getIndex()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEnchantability</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.enchantability;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SoundEvent <span class="title function_">getSoundEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.soundEvent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Ingredient <span class="title function_">getRepairMaterial</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.repairMaterial.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnlyIn(Dist.CLIENT)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getToughness</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toughness;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getKnockbackResistance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.knockbackResistance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，和其他 item 一样设置可穿戴装备对应的对象，并且注册。</p><p>但是！一般情况我们无需继承不同的类，只需要创建 <code>ArmorItem</code> 类的不同实例，就能获得不同部位的 item 对象。这多半是因为可穿戴装备是盔甲，都设计成一套，例如注册时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回忆一下，item_reg 是之前在 ItemRegistry 类中定义的 DeferredRegister 类的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsidianHelmet = item_reg.register(<span class="string">&quot;obsidian_helmet&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ArmorItem</span>(ModArmorMaterial.OBSIDIAN, EquipmentSlotType.HEAD, (<span class="keyword">new</span> <span class="title class_">Item</span>.Properties()).group(ModGroup.itemGroup)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsidianChestplate = item_reg.register(<span class="string">&quot;obsidian_chestplate&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ArmorItem</span>(ModArmorMaterial.OBSIDIAN, EquipmentSlotType.CHEST, (<span class="keyword">new</span> <span class="title class_">Item</span>.Properties()).group(ModGroup.itemGroup)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsidianLeggings = item_reg.register(<span class="string">&quot;obsidian_leggings&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ArmorItem</span>(ModArmorMaterial.OBSIDIAN, EquipmentSlotType.LEGS, (<span class="keyword">new</span> <span class="title class_">Item</span>.Properties()).group(ModGroup.itemGroup)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsidianBoots = item_reg.register(<span class="string">&quot;obsidian_boots&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ArmorItem</span>(ModArmorMaterial.OBSIDIAN, EquipmentSlotType.FEET, (<span class="keyword">new</span> <span class="title class_">Item</span>.Properties()).group(ModGroup.itemGroup)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在传给 <code>DeferredRegister&lt;Item&gt;::register()</code> 的第二参数不再是类自带的 <code>new</code> 方法，而是临时写的匿名函数，利用已存在的类 <code>ArmorItem</code> 的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一参数是之前定义的 可穿戴装备的“等级枚举类”</span></span><br><span class="line"><span class="comment">// 第二参数是盔甲的部位，会针对性读取材质的某一区域</span></span><br><span class="line"><span class="comment">// 第三参数是原始的 item 对象的 supplier</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArmorItem</span><span class="params">(IArmorMaterial material, EquipmentSlotType type, Supplier&lt;Item&gt; item)</span>;</span><br></pre></td></tr></table></figure><p>现在最后一件事需要注意，<strong>就是盔甲的材质添加和其他 item 不一样</strong>。</p><p><strong>首先</strong>从前面共用一个类可以看出，这里<strong>盔甲的材质也在一个图中</strong>。说 “一个图” 不是很准确，准确来说是<strong>穿着状态的盔甲全套一组图，物品栏中的盔甲又是另一组图</strong>。所以这里需要两组材质图，分布在不同 “<code>layer</code>” 中。因此，如果想自己创作，还需要专门的软件，例如上面提到的 blockbench；</p><p><strong>其次</strong>，minecraft 自己把盔甲<strong>穿着</strong>的材质写死到 <code>minecraft:/</code> 资源作用域下，这意味着，我们不能在原来的地方加材质图，应该新建一个 <code>minecraft</code> 目录；而同时盔甲在物品栏的贴图也要自己设计，和普通 item 一样加 model json 和 扁平材质：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">resources/</span><br><span class="line">├── META-INF/</span><br><span class="line">│   └── mods.toml</span><br><span class="line">├── assets/</span><br><span class="line">│   ├── mymod/        # 你的 modid，之前材质存放的地方（作用域为 mymod:/）</span><br><span class="line">│   |   ├── models/</span><br><span class="line">│   |   │   └── item/                    # 盔甲物品栏图标模型 json 存放位置</span><br><span class="line">│   |   └── textures/</span><br><span class="line">│   |       └── item/                    # 盔甲物品栏材质图片存放位置</span><br><span class="line">|    |</span><br><span class="line">|    └── minecraft/# 新建的目录，材质作用域是 minecraft:/</span><br><span class="line">|            └── textures/</span><br><span class="line">|                    └── models/</span><br><span class="line">|                            └── armor/# 盔甲穿着材质图片存放位置</span><br><span class="line">|                                    └── ...</span><br><span class="line">|            </span><br><span class="line">└── pack.mcmeta</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，盔甲材质图命名格式：<code>&lt;Ingredient名称ID&gt;_layer_1</code>（穿着贴图）和 <code>&lt;Ingredient名称ID&gt;_layer_2</code>（物品栏贴图）；</p><h3 id="1-8-Item-属性重写"><a href="#1-8-Item-属性重写" class="headerlink" title="1.8 Item 属性重写"></a>1.8 Item 属性重写</h3><p>现在回忆一下，在 <code>minecraft</code> 中拉弓，是不是随着时间延长，弓的贴图会变化？这是怎么做到的呢？<strong>这里利用了模型 JSON 中的 <code>&quot;overrides&quot;</code> 项的设定</strong>，我们来看原版 minecraft 弓的模型 JSON 的一部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">&quot;overrides&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;pulling&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/bow_pulling_0&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;pulling&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;pull&quot;</span><span class="punctuation">:</span> <span class="number">0.65</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/bow_pulling_1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;pulling&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;pull&quot;</span><span class="punctuation">:</span> <span class="number">0.9</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/bow_pulling_2&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>overrides</code> 配置项中，可以看到许多组类似这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pulling&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/bow_pulling_0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>的组，这好理解，<code>predicate</code> 项就是编程语言中的 IF（如果判断），在其中的是<strong>条件对</strong>，如果满足了条件对，那么模型和材质会采用同组中的 <code>model</code> 项对应的材质。</p><p>按照这个原理，我们可以设计一种 “根据堆叠数量变色” 的特殊 item。这种 item 的类的定义和普通 item 一样，但<strong>注册</strong>有所差别：<strong>需要向 <code>MOD</code> 总线中添加 <code>propertyOverrideRegistry</code> 的特殊事件</strong>，用来初始化并在游戏中监听物品变化，及时覆盖材质。</p><p>假设我们注册好的对象叫：<code>RegisterObject&lt;Item&gt; magicIngot</code>，那么需要写这么个类来作为属性覆盖的事件处理器：</p><blockquote><p><strong>这是我们第一次向总线中加入事件，不知道含义的可以回到 0.10 事件系统 这节复习一下</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mod</span>.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD, value = Dist.CLIENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyRegistry</span> &#123;</span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">propertyOverrideRegistry</span><span class="params">(FMLClientSetupEvent event)</span> &#123;</span><br><span class="line">        event.enqueueWork(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                ItemModelProperties.registerProperty(</span><br><span class="line">                    ItemRegistry.magicIngot.get(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ResourceLocation</span>(Utils.MOD_ID, <span class="string">&quot;size&quot;</span>),</span><br><span class="line">                    (itemStack, clientWorld, livingEntity) -&gt; itemStack.getCount()</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 <code>@Mod</code> 和 <code>@SubscribeEvent</code> 就是经典的静态的事件注册方法，在 0.10 中介绍过；</p><p>那么在接收 <code>FMLClientSetupEvent</code> 事件中，方法 <code>propertyOverrideRegistry</code> 做了什么？</p><p>首先了解 <code>FMLClientSetupEvent</code> 是在 Java FML（Forge Model Loader）加载时必然触发的事件，所以这里的意思是<strong>在 Java FML 加载的时候运行 <code>PropertyRegistry#propertyOverrideRegistry</code> 这个方法</strong>，方法体就一行 <code>event.enqueueWork(Supplier&lt;?&gt;)</code>，这个可以理解为运行里面的 <code>enqueueWork</code> 的 supplier，我们唯一要做的就是把 overrides 这个 item 的情况注册一下。看看注册 item overrides 的函数声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ItemModelsProperties.registerProperty(</span><br><span class="line">    RegisterObject&lt;Item&gt;registered_item,</span><br><span class="line">    ResourceLocation        resourceLocation,</span><br><span class="line">    Supplier&lt;?&gt;                supplier<span class="comment">// ? 为 游戏中想要监测的属性类型</span></span><br><span class="line">);                                        <span class="comment">// supplier 就是调用获取数据的匿名函数</span></span><br></pre></td></tr></table></figure><p>注意，从上面的实例代码可以看出，这里的 <code>ResourceLocation</code> 的作用就是将获取的数据绑定到指定的资源名称，方便在接下来的 JSON 文件中使用并 <code>overrides</code>；它的初始化函数第二参数是资源名称，<strong>必须要记住</strong>，它和外面的 JSON 文件 <code>predicate</code> 条件中的键的名称要一致（如果用到的话）；</p><p>上面示例中的 <code>itemStack.getCount()</code> 就是获取 itemStack 的堆叠数量。</p><p>最后来看补充的模型文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/generated&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;textures&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;layer0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/iron_ingot&quot;</span>        <span class="comment">// 这里投机取巧，普通模式就用了铁锭的材质</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span>                                    <span class="comment">// 下面是 overrides 添加的部分</span></span><br><span class="line">    <span class="attr">&quot;overrides&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;&lt;modid&gt;:size&quot;</span><span class="punctuation">:</span>    <span class="number">16</span><span class="comment">// 这里注意，&lt;modid&gt; 替换为自己的 modid</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span>                            <span class="comment">// size 就是要求记住的、之前注册的名称</span></span><br><span class="line">            <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/gold_ingot&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>最后放上相应的 texture 试运行一下，应该能见到预期的效果。</p><h2 id="Chapter-EX-1-Localization-amp-Language"><a href="#Chapter-EX-1-Localization-amp-Language" class="headerlink" title="Chapter EX-1. Localization &amp; Language"></a>Chapter EX-1. Localization &amp; Language</h2><p>这一章不是必要的，主要讲述如何给之前的物品添加名称，并且提供语言支持。前面的章节创建的 item 名称都是内部的类名，开发者也许懂，但使用者可能会不理解。</p><p>这是 minecraft 为了提升可维护性，方便本地化，默认是没有物体名称，item 只有自己的<strong>编号（<code>transitionKey</code>）</strong>，也就是之前看到的和类名/包名/属性名很像的 <code>XXX.XXX.XXX</code>；</p><p>实际命名和语言的本地化则需要开发者自己完成，有两者方法，第一种比较简单，用 JSON 文件组成<strong>从前面的编号到名字的映射工作</strong>；第二种是使用 <code>I18n.format</code> 的方法，以后用到再提。</p><p>前者使用比较容易，首先找到前面说的 item 的编号（在 <code>Item</code> 类内部，大家可以自己到源码中找一找）；下一步，是创建一个 <code>lang</code> 目录，位置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resources/</span><br><span class="line">├── META-INF/</span><br><span class="line">│   └── mods.toml</span><br><span class="line">├── assets/</span><br><span class="line">│   ├── mymod/        # 你的 modid，之前材质存放的地方（作用域为 mymod:/）</span><br><span class="line">│   |   ├── models/</span><br><span class="line">│   |   ├── textures/</span><br><span class="line">|    |└── lang/# 这里是新建的 lang 目录</span><br><span class="line">|    |</span><br><span class="line">|    └── minecraft/</span><br><span class="line">|            </span><br><span class="line">└── pack.mcmeta</span><br></pre></td></tr></table></figure><p>在 <code>lang/</code> 中写一个简体中文的 JSON map，举个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: zh_cn.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;item.XXX.obsidian_ingot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑曜石锭&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;item.XXX.obsidian_apple&quot;</span><span class="punctuation">:</span><span class="string">&quot;黑曜石苹果&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;item.XXX.obsidian_sword&quot;</span><span class="punctuation">:</span><span class="string">&quot;黑曜石剑&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;itemGroup.obsidian_group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑曜石物品栏&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>键是之前说的 item 编号，后面是名字/翻译内容；</p><p>当然如果想让自己的 mod 国际化，还可以写 <code>zh_tw.json</code>、<code>en_us.json</code>，具体还有哪些语言可用，可以参阅 <a href="https://minecraft-zh.gamepedia.com/index.php?title=%E8%AF%AD%E8%A8%80&variant=zh#%E5%8F%AF%E7%94%A8%E8%AF%AD%E8%A8%80">wiki</a>；</p><p>To be continued……</p><p>—-EOF—-</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt;&lt;a href=&quot;https://docs.minecraftforge.net/en/1.16.x/&quot;&gt;Minecraft Forge Doc 1.16.x&lt;/a&gt;、&lt;a href=&quot;https://boson.v2mcdev.com/introducation/intro.html&quot;&gt;Boson 1.16（导论部分）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;注意：以 MC 版本 1.16.5 为例&lt;/i&gt;（同一大版本 1.16.x 的操作方式变化不大）&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Java" scheme="https://sjtuxhw.top/tags/Java/"/>
    
    <category term="Minecraft" scheme="https://sjtuxhw.top/tags/Minecraft/"/>
    
    <category term="Forge" scheme="https://sjtuxhw.top/tags/Forge/"/>
    
  </entry>
  
</feed>
