<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SJTU-XHW&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/775cd43db6a8785d6a482dcf308b3be4</icon>
  <subtitle>It&#39;s better to burn out than to fade away.</subtitle>
  <link href="https://sjtuxhw.top/atom.xml" rel="self"/>
  
  <link href="https://sjtuxhw.top/"/>
  <updated>2024-02-20T13:28:23.886Z</updated>
  <id>https://sjtuxhw.top/</id>
  
  <author>
    <name>SJTU-XHW</name>
    <email>sjtuxhw12345@sjtu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript入门笔记</title>
    <link href="https://sjtuxhw.top/2024/02/20/JavaScript%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://sjtuxhw.top/2024/02/20/JavaScript%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-20T13:17:09.000Z</published>
    <updated>2024-02-20T13:28:23.886Z</updated>
    
    <content type="html"><![CDATA[<p><i>Written by SJTU-XHW</i></p><p><i>Reference: </i>《Professional JavaScript for Web Developers》 3rd Edition</p><p><i>本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h2 id="Chapter-0-JavaScript-起源"><a href="#Chapter-0-JavaScript-起源" class="headerlink" title="Chapter 0. JavaScript 起源"></a>Chapter 0. JavaScript 起源</h2><h3 id="0-1-历史"><a href="#0-1-历史" class="headerlink" title="0.1 历史"></a>0.1 历史</h3><ul><li><p>Web 流行早期（上世纪末），Internet 用户上网速度 28.8 KB/s，但网页的大小和复杂性却不断增加。为完成简单的表单验证而频繁地与服务器交换数据只会加重用户的负担。于是，为了<strong>开发一种客户端语言，仅用来处理表单的简单验证工作</strong>，Netscape 公司在其发布的应用 Netscape Navigator 2 上加入一种脚本语言 <code>LiveScript</code>，认为是 JavaScript 的前身<strong>之一</strong>；</p></li><li><p>1995 年 2 月，Netscape 与 Sun 合作，为了搭上媒体热炒 Java 的顺风车，临时把 <code>LiveScript</code> 改名为 <code>JavaScript</code>，这就是 JavaScript 1.0；</p></li><li><p>其后不久，微软在自家作品 IE 3 中加入 <code>JScript</code>（是 JavaScript 的另一种实现） ，标志着 JavaScript 作为一门语言，其开发向前迈进了一大步。</p><blockquote><p>同时也有个严重问题：此时世界上有了两个不同的 JavaScript 版本：Netscape Navigator 中的 <code>JavaScript</code>、Internet Explorer 中的 <code>JScript</code>。与 C 及其他编程语言不同，当时还没有标准规定 JavaScript 的语法和特性。</p></blockquote></li><li><p>1997 年，欧洲计算机制造商协会（ECMA）制定了新脚本语言标准，称为 <code>ECMA-262</code>，即 <code>ECMAScript</code>。此后，各个浏览器开发厂商以此标准作为各自 JavaScript 实现的基础，衍生出一系列的版本和生态。</p><blockquote><p>注：此后因为各种复杂的历史原因，JavaScript 和 JScript 相当久之后才渐渐兼容 ECMAScript；</p></blockquote></li><li><p>此后 Mozilla 公司继承了 Netscape 的项目，继续开发 JavaScript 和 Netscape/Mozilla 浏览器；而如今，含 IE 内核的浏览器仍使用的是 JScript，不过现在它们都 ECMAScript 兼容了。</p></li></ul><h3 id="0-2-JavaScript-实现"><a href="#0-2-JavaScript-实现" class="headerlink" title="0.2 JavaScript 实现"></a>0.2 JavaScript 实现</h3><p>虽然 JavaScript 和 ECMAScript 通常都被人们用来表达相同的含义，但 JavaScript 的含义却比 ECMA-262 中规定的要多得多（<strong>JavaScript 的 3 个主要组成部分</strong>）：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/js_struct.png" height="150px"></p><h4 id="0-2-1-ECMAScript：JavaScript-的标准和核心"><a href="#0-2-1-ECMAScript：JavaScript-的标准和核心" class="headerlink" title="0.2.1 ECMAScript：JavaScript 的标准和核心"></a>0.2.1 ECMAScript：JavaScript 的标准和核心</h4><ul><li><strong>与浏览器没有依赖关系，不包含输入输出定义</strong>；</li><li>规定内容包括：<strong>语法、类型、语句、关键字、保留字、操作符、对象</strong>；</li><li>提供此语言解释器的环境称为 <strong>宿主环境</strong>；</li><li><strong>ECMAScript 兼容</strong>：指满足以下几点的宿主环境：<ul><li>支持 ECMA-262 描述的所有“类型、值、对象、属性、函数以及程序句法和语义”；</li><li>支持 Unicode 字符标准；</li><li>添加 ECMA-262 没有描述的“更多类型、值、对象、属性和函数”；</li><li>支持 ECMA-262 没有定义的“程序和正则表达式语法”（也就是说，<strong>可以修改和扩展内置的正则表达式语法</strong>）；</li></ul></li></ul><h4 id="0-2-2-DOM：文档对象模型"><a href="#0-2-2-DOM：文档对象模型" class="headerlink" title="0.2.2 DOM：文档对象模型"></a>0.2.2 DOM：文档对象模型</h4><ul><li><p><strong>DOM 是一种针对 XML 但经过扩展用于 HTML 的 <u>API（应用程序编程接口）</u>，并不只是针对 JavaScript，很多其他语言也实现了</strong>；</p><blockquote><p>知识补充：XML 格式</p><p>一种和 HTML 类似的<strong>多层节点文档结构</strong>，结构中每个组分都是某种类型的节点，这些节点又包含不同类型数据。</p></blockquote></li><li><p><strong>ECMAScript 的扩展实现之一</strong>，依赖于 HTML / XML 页面；</p></li><li><p>功能：核心规定的是<strong>如何映射基于 XML 的文档结构，以便简化对文档中任意部分的访问和操作</strong>；</p><blockquote><p>DOM 的这个功能比较抽象，具体来说就是将：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在编程层面抽象为：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/dom_example1.png" height="240px"></p><p>提供了一些方便的接口函数，让开发人员可以轻松自如地删除、添加、替换或修改任何节点。</p></blockquote></li><li><p>DOM 级别：DOM API 的标准历史版本；</p><ul><li><p>DOM 1 级：由 <strong>DOM Core</strong> 和 <strong>DOM HTML</strong> 两个模块 API 构成。前者<strong>规定如何映射基于 XML 的文档结构（操作函数声明）</strong>，后者<strong>添加了针对 HTML 的对象和方法</strong>；</p></li><li><p>DOM 2 级：在 DOM 1 级基础上<strong>扩充了鼠标 及 GUI Events、Ranges、Iteration（迭代 DOM 文档的方法）等模块，增加对 CSS 的操作接口支持</strong>；</p><blockquote><ol><li>DOM Views，DOM 视图接口；</li><li>DOM Events，事件处理接口；</li><li>DOM Style，基于 CSS <strong>为指定元素应用样式</strong>的接口；</li><li>DOM Traversal and Range：遍历和操作文档树的接口；</li></ol></blockquote></li><li><p>DOM 3 级：在 DOM 2 基础上，<strong>引入了以统一方式加载和保存文档的方法（DOM Save &amp; Load）</strong>、<strong>新增了验证文档的方法（DOM Validator）</strong>、扩展了 DOM Core（支持 XML 1.0 规范，涉及 XML Infoset、XPath 和 XML Base）；</p></li></ul></li><li><p>其他 DOM 标准 API：</p><ul><li>SVG（可伸缩矢量图）；</li><li>MathML（数学标记语言）；</li><li>SMIL（同步多媒体集成语言）；</li></ul></li></ul><h4 id="0-2-3-BOM：浏览器对象模型"><a href="#0-2-3-BOM：浏览器对象模型" class="headerlink" title="0.2.3 BOM：浏览器对象模型"></a>0.2.3 BOM：浏览器对象模型</h4><ul><li><p>定义：一组支持访问和操作浏览器窗口的 API；</p></li><li><p><strong>ECMAScript 的扩展实现之一</strong>，依赖于浏览器；</p><blockquote><p>早期漏洞出现频繁，兼容性不强，因为没有相关标准。</p><p>HTML 5 出现后，BOM 的框架才列入正式规范；但目前各个浏览器实现方式几乎都不同；</p></blockquote></li><li><p>功能：</p><ul><li>弹出新浏览器窗口的功能；</li><li>移动、缩放和关闭浏览器窗口的功能；</li><li>提供浏览器详细信息的 navigator 对象；</li><li>提供浏览器所加载页面的详细信息的 location 对象；</li><li>提供用户显示器分辨率详细信息的 screen 对象；</li><li>对 cookies 的支持；</li><li>像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象；</li></ul></li></ul><h4 id="0-3-总结"><a href="#0-3-总结" class="headerlink" title="0.3 总结"></a>0.3 总结</h4><p>JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成：</p><ul><li>ECMAScript，由 ECMA-262 定义，提供核心语言功能；</li><li>文档对象模型（DOM），提供访问和操作 XML 文档 和 HTML 页面内容的方法和接口；</li><li>浏览器对象模型（BOM），提供与浏览器交互的方法和接口。</li></ul><p>JavaScript 的这三个组成部分，在当前五个主要浏览器（IE、Firefox、Chrome、Safari 和 Opera）中 都得到了不同程度的支持。</p><p>其中，所有浏览器对 ECMAScript 第 3 版的支持大体上都还不错，而对 ECMAScript 5 的支持程度越来越高，但对 DOM 的支持则彼此相差比较多。对已经正式纳入 HTML5 标准的 BOM 来说，尽管各浏览器都实现了某些众所周知的共同特性，但其他特性还是会因浏览器而异。</p><blockquote><p>接下来开始加速，请做好准备。</p></blockquote><h2 id="Chapter-1-在-HTML-中使用-JavaScript"><a href="#Chapter-1-在-HTML-中使用-JavaScript" class="headerlink" title="Chapter 1. 在 HTML 中使用 JavaScript"></a>Chapter 1. 在 HTML 中使用 JavaScript</h2><h3 id="1-1-lt-script-gt-元素"><a href="#1-1-lt-script-gt-元素" class="headerlink" title="1.1 &lt;script&gt; 元素"></a>1.1 <code>&lt;script&gt;</code> 元素</h3><p>使用 <code>&lt;script&gt;</code> 元素将 javascript 加入 HTML：最早由 Netscape 实现，后来作为 HTML 4.01 的规范；</p><p><code>&lt;script&gt;</code> 元素的属性：</p><ul><li><code>async</code>：可选，表示<strong>立即下载这个脚本，但是异步（不妨碍其他内容加载和运行）</strong>，仅对外部脚本有效，内嵌无效；</li><li><code>defer</code>：可选，表示<strong>当前脚本可以延迟到文档完全解析、显示后再执行</strong>，仅对外部脚本有效；</li><li><code>src</code>：可选，表示<strong>这个脚本是外部脚本，并指定位置</strong>；</li></ul><p>还有两种可以不掌握：</p><ul><li><code>type</code>：可选，脚本语言类型，一般没啥用，默认值就是 <code>text/javascript</code>；</li><li><code>charset</code>：可选，指定字符集（由于大多数浏览器会忽略这个属性，所以很少有人用）；</li></ul><blockquote><p><code>&lt;script&gt;</code> 元素的位置：</p><p>过去经典做法是将所有脚本标签放在 HTML 的 <code>&lt;head&gt;</code> 元素中，这意味着需要等所有脚本加载完毕才会开始解析页面，这对 JS 代码很多的页面而言，延迟明显；</p><p>现代的 Web 应用将 JS 放在 <code>&lt;body&gt;</code> 元素最后的部分，在用户看来提升了页面加载速度；</p></blockquote><h3 id="1-2-内联脚本-和-外部脚本"><a href="#1-2-内联脚本-和-外部脚本" class="headerlink" title="1.2 内联脚本 和 外部脚本"></a>1.2 内联脚本 和 外部脚本</h3><p>内联的方法很简单，只有一种可能的写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>内联 js 脚本需要注意几点</strong>：</p><ul><li><p>内联 js 脚本会在  HTML 中<strong>顺序解释（同步）</strong>，即不执行完不向下解释 HTML；</p></li><li><p>不允许在内联脚本中<strong>以任何形式出现 <code>&lt;/script&gt;</code>，除非有转义符</strong>，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sayScript</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;&lt;\/script&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>外部 js 脚本必须有 <code>src</code> 属性，<code>defer</code> 和 <code>async</code> 可选；</p><p>注意，外部 js 脚本也会在 HTML 中顺序解释，<strong>但 <code>defer</code> 和 <code>async</code> 可能改变这个行为</strong>；</p><p>在 HTML 中嵌入 JavaScript 代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含 JavaScript 代码。不过，并不存在必须使用外部文件的硬性规定，但支持使用外部文件的人多会强调如下优点：</p><ul><li>可维护性：遍及不同 HTML 页面的 JavaScript 会造成维护问题。但把所有 JavaScript 文件都放在 一个文件夹中，维护起来就轻松多了。而且开发人员因此也能够在不触及 HTML 标记的情况下， 集中精力编辑 JavaScript 代码；</li><li>可缓存性：浏览器能够根据具体的设置缓存链接的所有外部 JavaScript 文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度；</li><li>适应性：通过外部文件来包含 JavaScript 无须使用 XHTML 或注释 hack。HTML 和 XHTML 包含外部文件的语法是相同的；</li></ul><h3 id="1-3-lt-noscript-gt-元素"><a href="#1-3-lt-noscript-gt-元素" class="headerlink" title="1.3 &lt;noscript&gt; 元素"></a>1.3 <code>&lt;noscript&gt;</code> 元素</h3><p>在不支持 Javascript 的浏览器 / 浏览器禁用 Javascript 的情况下，<strong>才会</strong>显示 <code>&lt;noscript&gt;</code> 中的元素。</p><h2 id="Chapter-2-Javascipt-基本语法"><a href="#Chapter-2-Javascipt-基本语法" class="headerlink" title="Chapter 2. Javascipt 基本语法"></a>Chapter 2. Javascipt 基本语法</h2><blockquote><p>本章的语法标准以 ECMA-262 实现的 ECMAScript 为基础。</p></blockquote><h3 id="2-1-细节"><a href="#2-1-细节" class="headerlink" title="2.1 细节"></a>2.1 细节</h3><ul><li><p><strong>区分大小写</strong>；</p></li><li><p><strong>变量标识符命名规范</strong>：与 C / C++ 等一般语言不同的是，ECMAScript 允许美元符号（<code>$</code>）存在于变量名的任何位置，包括开头。其他都与普通语言相同，例如不用关键字、不用数字开头、建议驼峰命名等；</p><blockquote><p><script type="math/tex">abc`、`a$b`、`ab</script> 都是合法的变量标识符；</p></blockquote></li><li><p>注释：同 C / C++；</p></li><li><p><strong>严格模式</strong>：在<strong>脚本全文开头（作用于全文）</strong> / <strong>某函数体中（作用于该函数）</strong>使用 <code>&quot;use strict&quot;;</code>，代表编译指示（pragma），启用 Javascript 的严格模式；</p><blockquote><p>本质上为 Javascript 定义了一种不同的解释和执行模型，对 ECMAScript 3 中的 UB 也能得到处理，但是对某些不安全的行为会抛出错误，执行结果也可能与普通模式不同。这个区别会在以后的讨论时及时指出。</p></blockquote></li><li><p>语句建议<strong>使用分号结尾</strong>（虽然没有分号解释器一般也可以识别，但还是规范点好），语句块的模式和 C / C++ 都一样，以花括号表示语句块；</p></li></ul><h3 id="2-2-关键字和保留字"><a href="#2-2-关键字和保留字" class="headerlink" title="2.2 关键字和保留字"></a>2.2 关键字和保留字</h3><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/keywords.png" width="500px"></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/reserved.png" width="500px"></p><p>此外，ECMAScript 5 中新增 <code>let</code> 和 <code>yield</code> 为保留字；</p><p><strong>在严格模式下，不允许使用 <code>eval</code> 和 <code>arguments</code> 作为标识符或属性名</strong>；</p><h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h3><p>ECMAScript 定义的变量是<strong>松散类型</strong>，即<strong>变量只是一个占位符，本身可以用来保存任何类型</strong>。</p><ul><li><p>变量声明：使用 <code>var</code> 关键字；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br></pre></td></tr></table></figure><p>像这样<strong>未初始化的值会保存一个特殊的值：<code>undefined</code></strong>（之后讨论这是什么）；</p></li><li><p>变量定义（声明 + 初始化）；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">// 允许多个定义，与 C / C++ 类似</span></span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">&quot;world&quot;</span>,</span><br><span class="line">    age = <span class="number">100</span>,</span><br><span class="line">    cdn = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>变量的定义或声明不建议忽略 <code>var</code>，因为在严格模式下会抛出错误</strong>；</p><h3 id="2-5-数据类型"><a href="#2-5-数据类型" class="headerlink" title="2.5 数据类型"></a>2.5 数据类型</h3><p>ECMAScript 中的基本数据类型有 5 种：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>；另外有一种<strong>复杂数据类型：<code>Object</code>，本质上由一组无序键值对构成，相当于小型的 “类” 的概念</strong>；</p><p>因为 ECMAScript 的类型动态性，就没有必要定义其他数据类型了。</p><h4 id="2-5-1-typeof-保留字：数据类型检查"><a href="#2-5-1-typeof-保留字：数据类型检查" class="headerlink" title="2.5.1 typeof 保留字：数据类型检查"></a>2.5.1 <code>typeof</code> 保留字：数据类型检查</h4><p>使用 <code>typeof &lt;anything&gt;</code> （也允许用括号括起来）可以返回这几种字符串：<code>&quot;undefined&quot;</code>、<code>&quot;boolean&quot;</code>、<code>&quot;string&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;object&quot;</code>、<code>&quot;function&quot;</code>；</p><ul><li>注 1：<code>Null</code> 类型实际上是一个<strong>空的 <code>Object</code> 引用</strong>，因此 <code>typeof null</code> 返回 <code>&quot;object&quot;</code>；</li><li>注 2：函数实际上也是一类 <code>Object</code>，但有一些特殊的属性，因此 ECMAScript 有必要在 <code>typeof</code> 输出中单独区分开；</li></ul><h4 id="2-5-2-Undefined-类型"><a href="#2-5-2-Undefined-类型" class="headerlink" title="2.5.2 Undefined 类型"></a>2.5.2 Undefined 类型</h4><p>此类型<strong>只有一个值</strong>：<code>undefined</code>，常常在访问未初始化变量时出现。可以用等号操作符（<code>==</code>）判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br><span class="line"><span class="title function_">alert</span>(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>也可自行给定 <code>undefined</code> 值（不过没必要）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="literal">undefined</span>;</span><br><span class="line"><span class="title function_">alert</span>(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>未定义 / 声明的变量</strong> 和 <strong>声明了却 undefined 的变量</strong> 不一样。前者直接使用是错误的，这和大多数语言一样。</p><p>但是，对未声明的变量可以用 <code>typeof</code>，并且返回的也是 <code>&quot;undefined&quot;</code>，尽管它们不能使用；<strong>因此尽量初始化是个好习惯，这样我们就能知道哪些值是没声明的，而不是没初始化</strong>。</p><h4 id="2-5-3-Null-类型"><a href="#2-5-3-Null-类型" class="headerlink" title="2.5.3 Null 类型"></a>2.5.3 Null 类型</h4><p>此类型<strong>也只有一个值</strong>：<code>null</code>，表示空的对象的引用；</p><p><strong>建议总是为 将来要存储 <code>object</code> 的变量赋予该值，一方面体现了 <code>null</code> 的意义，另一方面有助于区分 <code>null</code> 和 <code>undefined</code></strong>。</p><p>很奇怪的是，我们没法用相等运算符区分 <code>null</code> 和 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="literal">null</span> == <span class="literal">undefined</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是，这不妨碍我们在操作一个变量前检查它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;    <span class="comment">// 同时拦截 null 和 undefined</span></span><br><span class="line">    <span class="comment">// 对 obj 对象操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-4-Boolean-类型"><a href="#2-5-4-Boolean-类型" class="headerlink" title="2.5.4 Boolean 类型"></a>2.5.4 Boolean 类型</h4><p>此类型<strong>只有两个值</strong>：<code>true</code>（真值）、<code>false</code>（假值）；</p><p>其他任何类型都可以通过<strong>类型转换函数（<code>Boolean()</code>）</strong>或者<strong>条件语句自动类型转换</strong>转为 Boolean 值：</p><ul><li>会转换为 <strong>假值</strong> 的值：String 类型<strong>空字符串</strong>、Number 类型 <strong>0 和 <code>NaN</code></strong>、Object 类型 <strong><code>null</code></strong>、Undefined 类型 <strong><code>undefined</code></strong>；</li><li>其余所有值都会转为 <strong>真值</strong>（包括后面提到的 <code>Infinity</code> 等等）；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Boolean</span>(message));    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (msg) &#123;    <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-5-Number-类型"><a href="#2-5-5-Number-类型" class="headerlink" title="2.5.5 Number 类型"></a>2.5.5 Number 类型</h4><h5 id="数值运算-和-数值范围"><a href="#数值运算-和-数值范围" class="headerlink" title="数值运算 和 数值范围"></a>数值运算 和 数值范围</h5><p>声明相当于 C/C++ 中的整型 + 浮点数；使用方法（如 8 进制、10 进制、16 进制表示方法、浮点数科学计数法等）、注意事项（不用浮点数作比较等等）与 C/C++ 也相同；</p><p>数值范围：<code>Number.MIN_VALUE(5e-324) ~ Number.MAX_VALUE(1.8e+308)</code>，超出范围的值会被转为特殊的正数 <code>Infinity</code> 或负数 <code>-Infinity</code>（均无法继续运算）；</p><p>一般计算很难出现正负无穷的情况，真正进行大数计算时，可以用 <code>isFinite()</code> 检查；</p><h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><p>此外，还有一个 <code>NaN</code>（Not a Number），是个特殊数值，用来表示<strong>一个本该返回数值的操作数未返回的情况（这样省去抛出错误的情况）</strong>；</p><p><code>NaN</code> 也不能使用相等运算符比较：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="title class_">NaN</span> == <span class="title class_">NaN</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>ECMAScript 提供了专门的判断函数 <code>isNaN()</code>，<strong>工作原理是对传入参数转为 <code>Number</code> 类型运算，如果不能运算，那么返回 <code>true</code></strong>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="number">10</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="literal">true</span>));    <span class="comment">// 可转为数值 1，false</span></span><br></pre></td></tr></table></figure><p><strong>不可思议的是，<code>isNaN()</code> 可以作用于对象 <code>Object</code>，先调用 <code>valueOf()</code> 方法确定返回值是否能转换，然后调用 <code>toString()</code> 再看结果是否能转换</strong>；</p><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><ul><li><code>Number()</code>：将任何数据类型转为数值；</li><li><code>parseInt(String)/parseFloat(String)</code>：将字符串转为相应数值；</li></ul><p>无法转换的返回 <code>NaN</code>，这就解释了 <code>isNaN()</code> 的工作原理；</p><p><strong>但是 <code>null</code> 可以转换为 0</strong>；</p><h4 id="2-5-6-String-类型"><a href="#2-5-6-String-类型" class="headerlink" title="2.5.6 String 类型"></a>2.5.6 String 类型</h4><h5 id="字符串直接量"><a href="#字符串直接量" class="headerlink" title="字符串直接量"></a>字符串直接量</h5><p>可以使用单引号或双引号完成，和 PHP 不同，这两种引号没区别；</p><h5 id="常用属性-方法"><a href="#常用属性-方法" class="headerlink" title="常用属性 / 方法"></a>常用属性 / 方法</h5><p>对一个 String 类型，它具有以下几种常用属性：</p><ul><li><code>length</code>；</li></ul><p>和以下的常用方法：</p><ul><li><p>加法拼接运算；</p><blockquote><p>注意，对于运算过程有个处理机制，例如下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;</span><br></pre></td></tr></table></figure><p>首先创建一个能容纳 10 个字符的新字符串，</p><p>然后在这个字符串中填充”Java”和”Script”，</p><p>最后一步是销毁原来的字符串”Java”和字符串”Script”（二者其后的引用数为 0）；</p></blockquote></li><li><p><code>at</code>、<code>indexOf</code>、<code>substr</code>、<code>endsWith</code>…… 等其他一切和 Java String 很接近的函数；</p></li></ul><h5 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h5><p>除了 <code>Null</code> 和 <code>Undefined</code> 类（它们直接返回），其他所有类型都有 <code>toString()</code>；</p><p>此外，可以通过 <code>+</code> 运算符隐式转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ageStr = <span class="string">&quot;&quot;</span> + <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h4 id="2-5-7-Object-类型"><a href="#2-5-7-Object-类型" class="headerlink" title="2.5.7 Object 类型"></a>2.5.7 Object 类型</h4><h5 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h5><p>和 Java 语言一样，使用 <code>new</code> 关键字申请创建新对象，但是回收无需开发者操心：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>同样和 <code>java.lang.Object</code> 一样的是，<code>Object</code> 也是所有 object 的父类，它也有如下的抽象方法：</p><ul><li><p>constructor：构造函数，前面的 <code>Object()</code> 就是 <code>Object</code> 类的构造函数；</p></li><li><p><code>hasOwnProperty(propertyName: String)</code>：检验当前对象中是否存在自定义的属性名；</p><blockquote><p>类似 Python <code>hasattr</code>；</p></blockquote></li><li><p><code>isPrototypeOf(object: Object)</code>：检验当前 object 对象是否是传入的 <code>object</code> 的<strong>原型（Prototype）</strong>；</p></li><li><p><code>propertyIsEnumerable(propertyName: String)</code>：检验当前 object 对象的属性是否能使用 <code>for-in</code> 循环进行迭代遍历；</p></li><li><p><code>toLocaleString/toString()</code>：转字符串；</p></li><li><p><code>valueOf()</code>：默认返回自身；</p></li></ul><p><strong>值得注意的是， ECMAScript 中没有定义如 BOM、DOM 中的对象，因为它们是 宿主对象，所以某些宿主对象可能不继承于 <code>Object</code></strong>；</p><p><strong>属性键值对添加方法</strong></p><p>直接使用作用域运算符（<code>.</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">test</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p><strong>属性键值对删除方法</strong></p><p>使用关键字 <code>delete</code>：<strong>对于几乎所有对象、简单类型都能这么做，解释器立即删除为该变量分配的空间，相当于回到未声明前</strong>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">test</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">age</span>;    <span class="comment">// obj.age -&gt; undefined</span></span><br></pre></td></tr></table></figure><h3 id="2-6-操作符"><a href="#2-6-操作符" class="headerlink" title="2.6 操作符"></a>2.6 操作符</h3><p>自增、自减、一元加减、位运算、普通四则运算、取模、复合赋值运算符、三目运算符几乎全部与 C/C++ 相同；</p><p>有几个点需要注意：</p><ul><li><p><strong>逻辑操作和 C/C++ 不一样，返回的值不一定是 Boolean：只要有一个 operand 不是 Boolean 类型，那么返回的就是真值的数据类型</strong>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">0</span> || <span class="number">123</span>;    <span class="comment">// test == 123</span></span><br></pre></td></tr></table></figure></li><li><p><code>Infinity</code> 与普通数的四则运算关系、<code>+0</code> 和 <code>-0</code> 的运算关系，与 C++ 浮点数相同；</p></li><li><p><strong>数据加法运算 和 字符串拼接运算</strong> 在某些情况需要开发者手动明确语义，防止发生意想不到的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">5</span> + <span class="string">&quot;5&quot;</span>;    <span class="comment">// 字符串拼接，test == &quot;55&quot;</span></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="number">5</span> + <span class="built_in">parseInt</span>(<span class="string">&quot;5&quot;</span>, <span class="number">8</span>);    <span class="comment">// Number 运算，test == 10</span></span><br></pre></td></tr></table></figure></li><li><p><strong>比较运算符在应用在两个 operand 都是 String 的方面，会将 String 的每一位字符拿出 ASCII / Unicode 进行比较</strong>；如果有一个是 Number 类型，解释器都会尝试将另一个转为 Number，转换不成就变成 NaN，而 <strong>NaN 参与比较运算永远是 false</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="string">&quot;23&quot;</span> &lt; <span class="number">3</span>;        <span class="comment">// false, 23 &gt; 3</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&quot;23&quot;</span> &lt; <span class="string">&quot;3&quot;</span>;    <span class="comment">// true, u&#x27;2&#x27; &lt; u&#x27;3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res1 = <span class="title class_">NaN</span> &lt; <span class="number">3</span>;        <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> res2 = <span class="title class_">NaN</span> &gt;= <span class="number">3</span>;     <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>⚠ <strong>在比较运算时，如果一个是 number 另一个是 string，则统一换为 number；而在加法运算时，如果一个是 number 另一个是 string，则统一换为 string</strong>（都不论前后顺序）；</p></li><li><p>逗号操作符：<strong>和 C / C++ 一样，用于声明多个变量。但是 ECMAScript 还能用于赋值，但只返回表达式最后一项</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>);    <span class="comment">// num == 0</span></span><br></pre></td></tr></table></figure></li></ul><p>ECMAScript 中还引入了几种不同的运算符：</p><ul><li><strong>在比较运算符中，除了相等运算符（<code>==</code>），还有全等运算符（<code>===</code>）</strong>；这是因为相等运算符比较<strong>会发生自动类型转换，例如 <code>&quot;5&quot; == 5</code> 是 true</strong>，而全等运算符不会转换数据类型。所以必要时，<strong>建议使用全等运算符</strong>；</li><li><strong>ECMAScript 中存在无符号右移 <code>&gt;&gt;&gt;</code> 和无符号右移赋值 <code>&gt;&gt;&gt;=</code></strong>；</li></ul><h3 id="2-7-语句"><a href="#2-7-语句" class="headerlink" title="2.7 语句"></a>2.7 语句</h3><p><code>if-else</code> 语句、<code>while</code> 语句、<code>do-while</code> 语句、<code>for</code> 语句、标签语句、<code>break/continue</code> 语句、<code>switch</code> 语句使用与 C/C++ 相同，但是！</p><p>ECMAScript 中<strong>不存在块级作用域</strong>，这意味着代码块中定义的，在外面也能访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(i);    <span class="comment">// i -&gt; 100</span></span><br></pre></td></tr></table></figure><p>ECMAScript 还具有：</p><ul><li><p><code>for-in</code> 语句：<strong>精准的迭代语句，可以用于枚举 object 的属性（回忆一下，没有顺序）</strong>，<code>for (property in expression) statement;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;    <span class="comment">// BOM window 对象</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(prop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，使用前需要检查 <code>object</code> 不能为 <code>null/undefined</code>，否则在某些浏览器上会报错</strong>；</p></li><li><p><code>with</code> 语句（大型项目不建议使用，因为性能极差，并且可读性差，<strong>并且在严格模式下不允许使用，会视为错误</strong>）：简化多次编写同一个对象的工作；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (location) &#123;</span><br><span class="line">    qs = search.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>qs</code> 会先当作普通局部变量查找，再当作 <code>location</code> 的属性查找；如果找不到再报错；</p></li></ul><h3 id="2-8-函数"><a href="#2-8-函数" class="headerlink" title="2.8 函数"></a>2.8 函数</h3><p>定义语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">arg0, arg1, ..., argN</span>) &#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ECMAScript 中有几个值得注意的点：</p><ul><li><p>和强类型语言不一样，ECMAScript 不关心函数返回值类型、参数类型；</p></li><li><p>和其他众多语言<strong>不一样</strong>，ECMAScript 甚至不关心形参列表究竟是什么，意味着你即便这么定义函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以这样调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="string">&quot;world&quot;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>因为在函数内部维护了 <code>arguments</code> 保留字，它相当于数组（但不是 <code>Array</code> 的实例，类型是 <code>Object</code>），<strong>可以用方括号访问 entry，也可以访问 <code>.length</code> 来看究竟传入了多少参数</strong>，<strong>并且生存周期仅在函数中，超过周期即销毁为 <code>undefined</code></strong>；</p><p>所以形参表存在的唯一作用是方便函数调用传入参数。<strong>这样，尽管 ECMAScript 没有重载的概念、没有函数签名的概念，但事实上也不需要了</strong>（ECMAScript 尝试定义重名函数，只会保留最后一次出现的定义）。</p><p><strong>值得注意的是，通常在函数内修改 <code>arguments</code> 是不规范的行为，在严格模式下会抛出错误</strong>；</p></li></ul><h2 id="Chapter-3-内存问题-与-变量作用域"><a href="#Chapter-3-内存问题-与-变量作用域" class="headerlink" title="Chapter 3. 内存问题 与 变量作用域"></a>Chapter 3. 内存问题 与 变量作用域</h2><h3 id="3-1-变量类型-与-内存"><a href="#3-1-变量类型-与-内存" class="headerlink" title="3.1 变量类型 与 内存"></a>3.1 变量类型 与 内存</h3><p>在 ECMAScript 中，有 2 种变量类型：</p><p><strong>基本类型（前面提到的 5 种基本数据类型）</strong>和 <strong>引用类型</strong>；</p><p>而当解释器执行某个赋值语句时，<strong>必须确定</strong>当前变量是基本类型还是引用类型。这是为什么？</p><p><strong>主要是因为 JavaScript 中，这两种类型的变量在内存中的形态不同。</strong></p><ul><li>对于基本类型的变量（ECMAScript 中包含字符串），其值存放于<strong>解释器运行时环境中</strong>（可以理解为放在<strong>栈内存</strong>上）；</li><li>对于引用类型的变量，创建总需要 <code>new</code> 关键字在<strong>堆内存</strong>中开辟空间。由于 JavaScript 不允许使用地址 / 指针，因此引用类型变量在复制 / 赋值等操作时总是针对引用（相当于 C 中自动完成 <code>*objPtr</code>）、在设置属性操作时总是针对对象（相当于 C 中自动完成 <code>objPtr-&gt;attr</code>）；</li></ul><p>看两个例子就能彻底明白：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = num1;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/basicCopy.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/refCopy.png"></p><p>那么检查一个变量名存放的究竟是基本数据类型还是引用类型，可以使用 <code>typeof</code> 关键字；</p><p>对于返回值为 <code>object / function</code> 的变量而言，它们一定是引用类型变量，其他则是基本类型；</p><p>此外，对于 JavaScript 中的继承关系，有关键字 <code>instanceof</code> 识别：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>);    <span class="comment">/* 内置 Array 类是 Object 的子类 */</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips. 此内容第一次读可以跳过。</p><p>对于正则表达式，不同的 JavaScript 解释器执行 <code>typeof</code> 的结果不同，这是实现标准不同的原因。对于 ECMA-262 标准规定，任何在内部实现 <code>[[Call]]</code> 方法的对象都应该在应用 <code>typeof</code> 操作符时返回 <code>&quot;function&quot;</code>，Safari（&gt; 5）及 Chrome（&gt; 7）满足这条规定，但 IE 和 Firefox 则会返回 <code>&quot;object&quot;</code>； </p></blockquote><h3 id="3-2-动态属性-与-内存"><a href="#3-2-动态属性-与-内存" class="headerlink" title="3.2 动态属性 与 内存"></a>3.2 动态属性 与 内存</h3><p>了解了基本类型 和 引用类型变量在内存中的排布，那么还有一个问题。<strong>既然像 <code>Object</code> 一类的引用类型是在堆内存中的，那么为他们设置属性的时候，它们的属性应该放在哪里？</strong></p><p>其实也是放在堆中的。毕竟它们的属性也是动态的，运行时随时可以添加和删除。</p><p>所以我们看看以下的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">b</span> = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">obj.<span class="property">f</span> = <span class="variable language_">console</span>.<span class="property">log</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = obj;</span><br></pre></td></tr></table></figure><p>等价于 C 的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span>* b;</span><br><span class="line">    <span class="type">void</span> (*f)(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">&#125; *obj, *obj2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    obj = (Object*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Object));</span><br><span class="line">    obj-&gt;a = <span class="number">1</span>;</span><br><span class="line">    obj-&gt;b = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    obj-&gt;b[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>, obj-&gt;b[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>, obj-&gt;b[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>, obj-&gt;b[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    obj-&gt;f = <span class="built_in">printf</span>;</span><br><span class="line">    </span><br><span class="line">    obj2 = obj1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于 C++ 的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    std::string b;</span><br><span class="line">    <span class="built_in">void</span> (*f)(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object &amp;obj = *(<span class="keyword">new</span> Object);</span><br><span class="line">    obj.a = <span class="number">1</span>;</span><br><span class="line">    obj.b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    obj.c = printf;</span><br><span class="line">    </span><br><span class="line">    Object &amp;obj2 = obj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>还有一个问题，基本类型变量能否设置属性呢？直觉上肯定是会报错的。实际上，<strong>不会报错</strong>，但解释器只是<strong>忽略</strong>了此语句。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">name.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">age</span>);    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>所以我们只能对引用类型变量设置动态属性。</p><h3 id="3-3-函数参数传递-与-内存"><a href="#3-3-函数参数传递-与-内存" class="headerlink" title="3.3 函数参数传递 与 内存"></a>3.3 函数参数传递 与 内存</h3><p>在学习 JavaScript 函数时，我们曾经了解到 <code>arguments</code> 内置变量。而参数传递的过程，就是：</p><ul><li>向 <code>arguments</code> 中赋予 <code>0 ~ N</code> 键对应的值；</li><li>向自定义的形式参数赋予对应的值（如果有的话）；</li></ul><p>这些赋值后的变量都是函数局部变量，如果实际参数是一个<strong>基本类型的变量</strong>，那么直接<strong>值传递</strong>；如果实际参数是一个引用类型的变量，那么进行<strong>引用传递</strong>（类似 C++ 中参数自动完成 <code>Type &amp;param</code>）；</p><h3 id="3-4-执行环境-与-变量作用域"><a href="#3-4-执行环境-与-变量作用域" class="headerlink" title="3.4 执行环境 与 变量作用域"></a>3.4 执行环境 与 变量作用域</h3><p>JavaScript 中一个相当重要的概念就是 <strong>执行环境（execution context）</strong>，和 C 中的作用域的思想相近，但不相同。JavaScript 执行环境有以下特征：</p><ul><li><p>执行环境定义了<strong>变量或函数有权访问的其他数据</strong>，<strong>决定了它们各自的行为</strong>；</p></li><li><p>每个执行环境都有一个与之关联的<strong>变量对象（variable object）</strong>，环境中定义的<strong>所有变量和函数</strong>都保存在这个对象中；</p><blockquote><p>类似 Python 的对于一个包的 <code>__dict__</code> 属性；</p><p>与 Python 不同的是，<strong>开发者没法访问这个变量对象，只有解释器才能使用它</strong>；</p></blockquote></li><li><p>JavaScript 最外围的执行环境被称为<strong>全局执行环境</strong>（可以有多个）。不过，根据 ECMAScript 实现所在的宿主环境不同，<strong>表示执行环境的对象</strong>也不一样；</p><blockquote><p><strong>什么是 “表示执行环境的对象”？</strong></p><p>JavaScript 中将保持上下文变量、函数的任务统统交给了对象（<code>Object</code>）。因此将当前执行环境的变量、函数保存的对象就称为 “表示执行环境的对象”；</p><p>例如，如果宿主环境是 web 浏览器（即浏览器提供解释器），那么全局执行环境就是 <code>window</code> 对象（将在后面介绍）；<strong>因此所有的全局变量、函数都作为 <code>window</code> 对象的属性和方法创建</strong>；</p></blockquote></li><li><p>JavaScript 中每个函数都有自己的执行环境。这就类似 C 中的栈帧，区分<strong>局部变量（存放于当前执行环境中的变量）、全局变量（存放于全局执行环境中的变量）</strong>；</p></li><li><p>JavaScript 在此基础上定义了 <strong>作用域链（scope chain）</strong>的概念，定义为用于<strong>保证对执行环境有权访问的所有变量和函数的有序访问</strong>。可以将它理解为 JavaScript 解释器搜索标识符的字典；</p><blockquote><p>每当程序进入一个新执行环境中，解释器会创建一个新的变量对象（前面的规则），而这个对象就位于作用域链的最前端。<strong>因此作用域链的前端，始终都是当前执行的代码所在环境的变量对象</strong>。以函数环境为例，<code>arguments</code> 对象就是最开始的变量对象。</p><p><strong>作用域链越向后，变量对象越靠环境外层。因此全局执行环境的变量对象始终都是作用域链中的最后一个对象。</strong></p><p><strong>这样的链形结构，以及排布顺序，决定了局部变量、全局变量的优先级（和 C 一样）</strong>。</p></blockquote></li><li><p>除了函数，<code>with</code> 语句、<code>try-catch</code> 语句均拥有一个独立的执行环境（或者说一个独立的变量对象），这点和 C 的作用域也相同；</p></li><li>⚠ 和其他语言有差别的是，<strong>JavaScript 没有块级作用域</strong>。也就是说，<strong>除了函数、<code>with</code>、<code>try-catch</code> 块以外的、由花括号封闭的代码块，没有独立的执行环境（或者说独立的变量对象）</strong>，这点和 C 的作用域不同！</li></ul><h3 id="3-5-垃圾回收机制（GC）"><a href="#3-5-垃圾回收机制（GC）" class="headerlink" title="3.5 垃圾回收机制（GC）"></a>3.5 垃圾回收机制（GC）</h3><p>和 Python、Java 一样，JavaScript 具有自动垃圾回收机制，无需像 C / C++ 一样手动回收分配的空间。</p><p><strong>几乎所有自动 GC 都遵循一个理念：按照某个策略<u>预定的时间</u>（定时策略），释放<u>不再继续使用的</u>（标记策略）<u>引用类型变量</u>所占用的空间</strong>；</p><p>所以，这个 GC 机制中有两个需要决定的策略，我们介绍一下常见的策略类型（以下回收的变量都指的是<strong>引用类型</strong>，不再赘述）。</p><h4 id="3-5-1-标记策略"><a href="#3-5-1-标记策略" class="headerlink" title="3.5.1 标记策略"></a>3.5.1 标记策略</h4><p>JavaScript 中有两种常用的标记策略，分别是：<strong>标记清除（mark-and-sweep）、引用计数（reference counting）</strong>；</p><p>所谓标记清除就是：</p><ul><li>当变量在该环境内的时候，标记的是 <strong>进入环境</strong>；</li><li>当变量离开定义它的环境后，标记的是 <strong>离开环境</strong>；</li><li>当定时策略指定的检查时间到的时候，<strong>仅释放所有离开环境的变量的空间</strong>；</li></ul><p>所谓引用计数就是：</p><ul><li>跟踪记录每个变量被引用的次数。当该引用被赋予一个变量名后，该空间的数据引用计数 + 1；反之，如果该变量名改赋其他值，或被显式 delete 时，引用计数 - 1；</li><li>当定时策略指定的检查时间到的时候，<strong>仅释放所有引用计数为 0 的变量的空间</strong>；</li></ul><p>但是，引用计数策略有个严重问题：<strong>循环引用</strong>。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testCirRef</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    obj1.<span class="property">attr1</span> = obj2;</span><br><span class="line">    obj2.<span class="property">attr2</span> = obj1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果采用引用技术方法作为标记策略，那么退出函数体后，<code>obj1</code> 、<code>obj2</code> 的引用计数永不为 0；而且最有趣的问题是，JavaScript 的 DOM、BOM 的对象是使用 C++ 的 COM（Component Object Model，组件对象模型）实现的，它的回收是内置采用引用计数策略的。<strong>这就意味着使用 DOM / BOM 对象时，不可避免地可能产生循环引用</strong>。例如下面使用 DOM 的代码（后面介绍）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;some_element&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">myObject.<span class="property">element</span> = element;</span><br><span class="line">element.<span class="property">someObject</span> = myObject;</span><br></pre></td></tr></table></figure><p>所以书写时要注意循环引用的情况并且在不需要使用的时候及时解开 DOM 对象 和 JavaScript 原生 Object 之间的连接（想象成要像 C 一样手动释放）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.<span class="property">element</span> = <span class="literal">null</span>;</span><br><span class="line">element.<span class="property">someObject</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注：发生循环引用不仅仅有以上的可能，更多可能以后遇到再讨论。</p></blockquote><hr><p>综上原因所述，<strong>标记清除 是 JavaScript 中最常用的 GC 标记策略</strong>（主流浏览器引擎也都是）；</p><p>而引用计数则存在于 COM 实现的对象中（例如 BOM、DOM 对象），在使用时注意检查循环引用的情况，并且及时手动解引用。</p><h4 id="3-5-2-定时策略"><a href="#3-5-2-定时策略" class="headerlink" title="3.5.2 定时策略"></a>3.5.2 定时策略</h4><p>定时策略非常好想，大家肯定都会想到：<strong>周期性回收</strong>就行；但如何确定回收周期非常讲究。</p><p>IE6 浏览器实现的 JavaScript 解释器曾经有个非常严重的性能问题，这就是定时策略没有设计好。他们是这么为 IE6 JavaScript 设计的：</p><blockquote><p>256 个变量、4096 和对象（包括元素），或者 64 KB 的字符串，达到上述任意一个临界值，GC 会被自动触发。</p></blockquote><p>这么设计有什么问题呢？考虑一个问题，假设一个大型 JavaScript 程序的运行时必须使用多于 256 个变量（或者其他超过临界值的条件），那么<strong>垃圾回收例程会被一直持续触发，严重影响性能</strong>。</p><p>后来，自 IE7 及以后的版本，微软将 IE JavaScript 引擎的 GC Routine 改成了：</p><blockquote><ul><li>各项<strong>初始</strong>临界值和以前一致；</li><li>如果垃圾收集例程回收的内存分配量低于15%，则变量、literal 和（或）array 元素的临界值就会<strong>加倍</strong>；</li><li>如果例程回收了85%的内存分配量，则将各种临界值<strong>重置回默认值</strong>；</li></ul></blockquote><p>这样的定时回收策略大大优化了 GC 机制性能。如今不同的 JavaScript 引擎有着不同的实现方式，但思路都大同小异。</p><h4 id="3-5-3-拓展：开发者如何节省内存"><a href="#3-5-3-拓展：开发者如何节省内存" class="headerlink" title="3.5.3 拓展：开发者如何节省内存"></a>3.5.3 拓展：开发者如何节省内存</h4><p>我们知道，抛开借助 COM 对象的循环引用问题，JavaScript 作为一个自动 GC 的语言，是无需开发者关心内存问题的。</p><p>但是，有一点和我们开发 C/C++ 桌面程序有些不一样的地方：<strong>开发者需要有意地节省可用内存</strong>。</p><p>因为，<strong>浏览器的可用内存数量通常要比分配给桌面应用程序的少</strong>。这样做的目的主要是出于安全方面的考虑，目的是防止运行JavaScript 的网页耗尽全部系统内存而导致系统崩溃。</p><p>因此，<strong>确保占用最少的内存可以让页面获得更好的性能</strong>。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。<strong>一旦数据不再有用，最好通过将其值设置为 <code>null</code> 来释放其引用</strong>——这个做法叫做<strong>解除引用（dereferencing）</strong>；</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAction</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> localAction = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    localAction.<span class="property">name</span> = name;</span><br><span class="line">    <span class="keyword">return</span> localAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalAction = <span class="title function_">createAction</span>(<span class="string">&quot;Open Action&quot;</span>);</span><br><span class="line"><span class="comment">/* Do something... */</span></span><br><span class="line"><span class="comment">/* At the end of the block: */</span></span><br><span class="line">globalAction = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>提示：这样做虽然不会立即回收该内存，但能够起到尽早回收的作用，在一定程度上节省了运行时内存。</p></blockquote><h2 id="Chapter-4-内置的引用类型"><a href="#Chapter-4-内置的引用类型" class="headerlink" title="Chapter 4. 内置的引用类型"></a>Chapter 4. 内置的引用类型</h2><p>我们知道，JavaScript 的引用类型，或者说所有原生（naive）类型的父类都是 <code>Object</code>。你可能会想到 Python 中的 <code>Object</code> 终极父类，但实际上，这种说法<strong>不准确</strong>。</p><p>因为 JavaScript 不具备传统的面向对象语言所支持的类和接口等基本结构，通俗来说，<strong>它不支持定义类</strong>，所以不存在 “类” 的说法（<strong>它的超集语言 <code>TypeScript</code> 支持，也很有用</strong>）。</p><p>但矛盾的是，JavaScript 又是个面向对象的语言，所以<strong>你只能使用内置的基本类型、引用类型，并将它们实例化使用</strong>，所以又称<strong>对象定义</strong>。</p><p>像我们之前使用到的引用类型 <code>Object</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>就是在堆中创建了 <code>Object</code> 引用类型的新的<strong>实例</strong>。<code>Object()</code> 就是 <code>Object</code> 引用类型的构造函数。</p><p>到这里，我们可以这么理解 JavaScript 的引用类型：JavaScript 先集成了几个内置的引用类型，然后将它们都写成 C 中的 <code>final</code> 类，不允许定义新类或者继承，只能使用它们。</p><p><strong>所以，JavaScript 内置的引用类型有哪些呢？一共有 7 个方面。</strong></p><h3 id="4-1-Object-引用类型"><a href="#4-1-Object-引用类型" class="headerlink" title="4.1 Object 引用类型"></a>4.1 Object 引用类型</h3><h4 id="4-1-1-实例创建"><a href="#4-1-1-实例创建" class="headerlink" title="4.1.1 实例创建"></a>4.1.1 实例创建</h4><p>有两种创建 <code>Object</code> 引用类型的方法，一种是 <code>new</code> 构造函数创建，另一种是<strong>对象直接量</strong>创建。</p><p>前者的机制我们之前已经解释了无数遍。后者就像 C / C++ 中定义常量一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，如果你愿意的话，其键名加上引号也是<strong>等效</strong>的。</p><p>⚠ <strong>使用对象直接量创建对象时，不会执行对象的构造函数。</strong></p><p>不仅如此，<strong>在传递属性较多、复用次数较少的 <code>Object</code> 对象作函数参数时</strong>，对象直接量更加高效、代码可读性更强：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">testFunc</span>(&#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-1-2-实例访问"><a href="#4-1-2-实例访问" class="headerlink" title="4.1.2 实例访问"></a>4.1.2 实例访问</h4><p><code>Object</code> 引用类型的实例访问也有两种方法，一种是很熟悉的 <strong>点访问法（<code>obj.attr</code>）</strong>，另一种是 <strong>方括号访问法</strong>（<code>obj[&quot;attr&quot;]</code>），但是，除非不得已（例如<strong>属性名中含有空格，无法使用点访问法</strong>），都应该使用点访问法。</p><h3 id="4-2-Array-引用类型"><a href="#4-2-Array-引用类型" class="headerlink" title="4.2 Array 引用类型"></a>4.2 Array 引用类型</h3><p>除了 <code>Object</code>，ECMAScript 最常用的类型估计就是 <code>Array</code> 引用类型。它具有以下特性：</p><ul><li>数组<strong>每一项可以保存任意类型</strong>（强类型语言根本看不到）；</li><li>数组始终有序（自动排序）；</li><li>数组大小自动动态调整。当然，也允许创建时指定初始大小；</li></ul><h4 id="4-2-1-实例创建"><a href="#4-2-1-实例创建" class="headerlink" title="4.2.1 实例创建"></a>4.2.1 实例创建</h4><ul><li><p>默认构造函数：<code>var a = new Array();</code></p></li><li><p>指定初始大小（<code>length</code>）的构造函数：<code>var a = new Array(20);</code></p></li><li><p>指定数组项的构造函数：<code>var a = new Array(&quot;Alex&quot;, &quot;Ben&quot;, &quot;Cindy&quot;);</code></p><blockquote><p>于是我们发现<strong>没法直接</strong>指定只包含一个数字的数组；</p></blockquote></li><li><p><strong>数组 literal</strong>：<code>var a = [&quot;Alex&quot;, &quot;Ben&quot;, &quot;Cindy&quot;];</code></p><blockquote><p>空数组的话 <code>var a = [];</code></p></blockquote></li></ul><h4 id="4-2-2-实例访问"><a href="#4-2-2-实例访问" class="headerlink" title="4.2.2 实例访问"></a>4.2.2 实例访问</h4><p>和 C++ 等其他语言一样。直接 <code>arr[N]</code>；也定义了 Java 风格函数：</p><ul><li><code>indexOf(num[, start])</code>：第二参数可定制<strong>从 <code>start</code> 开始寻找</strong>；</li><li><code>lastIndexOf(num[, start])</code>；</li></ul><p><strong>数组越界访问不会报错，返回 <code>undefined</code></strong>；</p><p>但 JavaScript 数组有个非常奇妙的特性：<strong><code>length</code> 属性可以修改</strong>。这意味着，直接通过修改 <code>length</code> 就能改变数组大小，进而完成新增、移除末尾项的功能。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alist = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;coconut&quot;</span>];</span><br><span class="line">alist.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(alist[<span class="number">2</span>]);    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>如果越界赋予值，那么相当于增长数组</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alist = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>];</span><br><span class="line">alist[alist.<span class="property">length</span>] = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">alist[alist.<span class="property">length</span>] = <span class="string">&quot;d&quot;</span>;</span><br><span class="line">alist[alist.<span class="property">length</span> + <span class="number">1</span>] = <span class="string">&quot;e&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(alist);    <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, undefined, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 数组最长 4,294,967,295 个项，更大的范围会抛出错误</strong>。</p><h4 id="4-2-3-实例方法"><a href="#4-2-3-实例方法" class="headerlink" title="4.2.3 实例方法"></a>4.2.3 实例方法</h4><ul><li><p>检查变量是否为数组引用类型：<code>Array.isArray()</code>；</p><blockquote><p>为什么要有这个方法？<code>instanceof Array</code> 不行吗？</p><p>答案是<strong>不行</strong>。考虑一种情况，最终 JavaScript 是要放在网页上的，网页上可能存在很多的框架，那么就会有多个全局执行环境，进而<strong>存在多个不同版本的 <code>Array</code> 构造函数</strong>。</p><p>但由于 JavaScript 没有重载，所以在一个环境下只有一种构造函数，因此<strong>当你从一个框架向另一个框架传入数组时，两个框架的原生数组定义不同，因此无法使用 <code>instanceof</code> 判断</strong>。</p></blockquote></li><li><p>类型转换方法（继承自 <code>Object</code>）：</p><ul><li><code>Array.toString()</code>：返回由调用数组每个元素的 <code>toString()</code> 返回的字符串组成、由<u>逗号</u>分割的字符串；</li><li><code>Array.valueOf()</code>：<strong>返回自身的<u>引用</u></strong>；</li><li><code>Array.toLocaleString()</code>：返回由调用数组每个值的 <code>toLocaleString()</code> 返回的字符串组成、由<u>逗号</u>分割的字符串；</li><li><code>Array.join(delim)</code>：和 <code>toString()</code> 功能相近，只是可以自定义分隔符 <code>delim</code>；</li></ul><blockquote><p>注：以上转字符串的方法的返回值，如果元素是 <code>null</code>、<code>undefined</code>，则其位置上是空字符串。</p></blockquote></li><li><p><strong>容器方法</strong>：</p><ul><li><p><code>push()</code>、<code>pop()</code>：<code>FIFO</code> 栈方法；</p></li><li><p><code>push()</code>（作为 <code>enQueue</code>）、<code>shift()</code>（<code>deQueue</code>）：<code>LIFO</code> 队列方法；</p><blockquote><p>还提供了 <code>unshift()</code> 方法，作为 <code>shift()</code> 的逆方法（类似 <code>prepend</code>）；</p></blockquote></li></ul></li><li><p>排序：<code>sort([func])</code>、<code>reverse()</code>；</p><blockquote><p>其中 <code>sort()</code> 方法默认<strong>升序</strong>，排序依据是<strong>每个元素的 <code>toString</code> 返回值</strong>。</p><p>由于字符串在比较数字方面等等的不利性，因此允许传入自定义比较函数。自定义比较函数要求：</p><ul><li>函数只会被这样调用：<code>intVar = func(element1, element2)</code>，所以要求处理两个参数、返回整型；</li><li><code>element1</code> 如果需要排在 <code>element2</code> 的<strong>前面</strong>，那么返回<strong>负数</strong>；如果要在后面，返回<strong>正数</strong>；如果二者排序依据相同，返回 0；</li></ul><p>例如这个函数是按照<strong>数值比较</strong>的<strong>降序</strong>比较函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">comp</span>(<span class="params">v1, v2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> v2 - v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为对于 Number，这个函数显然没问题。对于其他类型，减法运算会调用 <code>valueOf()</code> 函数。所以它能对 <code>valueOf()</code> 返回 Number 类型的参数进行排序。</p></blockquote></li><li><p>操作方法：</p><ul><li><p><code>Array.concat(other)</code>：拼接数组，<code>other</code> 可以是其他任何可迭代的类型，并且个数随意，包括基本类型；重要的是，<strong>返回的数组是新的对象——意味着不加参数就是 deep copy</strong>；</p></li><li><p><code>Array.slice(start, [stop])</code>：数组切片，不包括 <code>stop</code>（不传第二参数则默认 <code>Array.length</code>）；</p><blockquote><p>参数允许为负数，其含义与 Python 的相同，都是倒计数。</p></blockquote></li><li><p><code>Array.splice(start, length[, replaced])</code>：<strong>数组选块替换</strong>；</p><ul><li>删除选中元素：<code>Array.splice(i, j)</code> 表示删除索引从 <code>i</code> 开始的 <code>j</code> 个元素；</li><li>在指定位置插入元素：<code>Array.splice(i, 0, alist)</code> 表示从第 <code>i</code> 索引插入一个或多个可迭代对象 <code>alist</code>；</li><li>删除选中元素，同时在删除位置插入指定元素：<code>Array.splice(i, j, alist)</code> 表示从第 <code>i</code> 索引开始删除 <code>j</code> 个元素，并在该位置插入一个或多个可迭代对象 <code>alist</code>；</li></ul></li></ul></li><li><p><strong>迭代方法</strong>：</p><blockquote><p><strong>所有迭代方法其中一个参数都是 <code>mapFunc</code>，其要求的签名是：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapFunc</span>(<span class="params">curElement, curIdx, selfArr</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><code>Array.forEach(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。没有返回值；</li><li><code>Array.map(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。返回由 <code>mapFunc</code> 返回值组成的数组；</li><li><code>Array.filter(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。返回由 <code>mapFunc</code> 返回 <code>true</code> 的项组成的数组；</li><li><code>Array.every(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。如果该方法对数组每一项都返回 <code>true</code>，那么返回 <code>true</code>；</li><li><code>Array.some(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。</li></ul></li><li><p>归并方法（好像用的不多）：遍历数组的所有项，然后构建一个最终返回的值；</p><blockquote><p><strong>所有归并方法其中一个参数都是 <code>mapFunc</code>，其要求的签名是：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapFunc</span>(<span class="params">prev, cur, curIdx, selfArr</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><code>Array.reduce(mapFunc)</code>：从数组的左边向右边遍历，从数组第二项开始执行 <code>mapFunc</code>，返回值传给下一个元素调用 <code>mapFunc</code> 的第一参数，最后返回最终运算值；</p><blockquote><p>对空数组使用会报错；对长度为 1 的数组总是返回该元素的值；</p></blockquote></li><li><p><code>Array.reduceRight(mapFunc)</code>：与 <code>Array.reduce</code> 作用相同，不过从右向左遍历；</p></li></ul></li></ul><h3 id="4-3-Date-引用类型"><a href="#4-3-Date-引用类型" class="headerlink" title="4.3 Date 引用类型"></a>4.3 Date 引用类型</h3><p>首先熟悉 Java 的同学有福了，因为 ECMAScript 的 <code>Date</code> 类型基于早期 <code>java.util.Date</code> 类型构建，使用方法基本相同。</p><h4 id="4-3-1-实例创建"><a href="#4-3-1-实例创建" class="headerlink" title="4.3.1 实例创建"></a>4.3.1 实例创建</h4><p>默认构造函数即可：<code>var now = new Date();</code></p><p>默认构造函数创建的新对象<strong>自动获得当前日期和时间</strong>；</p><ul><li><p>另外可以传入<u>与 <code>UTC</code> 时间相距的毫秒数</u>来构造时间：<code>new Date(int)</code>；</p></li><li><p>也可以向构造函数传入一个字符串，效果和运行 <code>new Date(Date.parse(str))</code> 一样（下面介绍）；</p></li></ul><h4 id="4-3-2-日期解析"><a href="#4-3-2-日期解析" class="headerlink" title="4.3.2 日期解析"></a>4.3.2 日期解析</h4><p><strong>静态方法 <code>Date.parse(rawString)</code></strong> 接受一个<strong>特定日期格式</strong>的字符串，返回该日期<u>与 <code>UTC</code> 时间相距的毫秒数</u>：</p><ul><li><code>mm/dd/yyyy</code>（e.g., <code>6/13/2004</code>）；</li><li><code>English-Month day,year</code>（e.g., <code>January 12, 2023</code>）；</li><li><code>English-Week English-Month day year HH:mm:ss Timezone</code>（e.g., <code>Wed Jan 24 2024 00:00:00 GMT-0700</code>）;</li><li><strong>ISO-8601</strong> 标准拓展格式：<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>（e.g., <code>2024-01-25T14:54:00</code>）</li></ul><p>⚠ 如果字符串不是以上格式（即无法转为日期），则返回 <code>NaN</code>；</p><p>⚠ 如果字符串满足格式，但<strong>不是有效日期</strong>，那么不同解释器有不同行为。有的解释器转为当前日期，有的转为 “最近” 的正确日期；</p><blockquote><p>此外，还有更加方便的 <strong>静态方法 <code>Date.UTC([params])</code></strong>，功能与 <code>Date.parse</code> 相近；</p><p>从第一参数向后，是数值的：年、月、日、时（24）、分、秒，默认均为 0；</p></blockquote><p>此外还有静态方法 <code>Date.now()</code>，和默认构造函数的作用相近。</p><hr><p>为了日期信息提取的方便，ECMAScript 定义了一堆<strong>实例方法</strong>，它们的格式如下：</p><p><code>[set/get][UTC][Time/FullYear/Month/Date/Day/Hours/Minutes/Seconds/Milliseconds]</code></p><p>例如：<code>d.setUTCHours()</code>、<code>d.getDay()</code> 等等。其中 <code>getTime()</code> 和 <code>valueOf()</code> 返回的值一致。</p><blockquote><p><strong>额外记一个函数：<code>getTimezoneOffset()</code>，表示本地时间与 <code>UTC</code> 时间时区的时差分钟数</strong>。</p></blockquote><h4 id="4-3-3-日期格式化"><a href="#4-3-3-日期格式化" class="headerlink" title="4.3.3 日期格式化"></a>4.3.3 日期格式化</h4><ul><li><p>字符串转换函数（继承于 <code>Object</code>）：<code>toString()</code>、<code>toLocaleString()</code>。<u>事实上，这两个函数一般仅作为调试使用</u>；</p></li><li><p>运算类型转换（继承自 <code>Object</code>）：<code>valueOf() -&gt; int</code>，返回距 <code>UTC</code> 毫秒数。<strong>非常有用！可以直接用比较运算符比较日期</strong>； </p></li><li><p><code>Date.toDateString()</code>：转 <code>datetime</code>（e.g., <code>Wen Jan 24 2024</code>）；</p></li><li><p><code>Date.toTimeString()</code>：转 <code>time</code>（e.g., <code>15:29:20 GMT+0800 (China Standard Time)</code>）</p></li><li><p><code>Date.toLocaleDateString</code>、<code>Date.toLocaleTimeString()</code>：上面两种函数锁定当前时区的版本。</p><blockquote><p>前者输出形如 <code>1/24/2024</code>，后者输出形如 <code>3:29:20 PM</code>；</p></blockquote></li><li><p><code>Date.toUTCString()</code>：完整 <code>UTC</code> 格式字符串（e.g., <code>Wed, 24 Jan 2024 07:29:20 GMT</code>）；</p></li></ul><h3 id="4-4-RegExp-引用类型"><a href="#4-4-RegExp-引用类型" class="headerlink" title="4.4 RegExp 引用类型"></a>4.4 RegExp 引用类型</h3><p>这是一个比较强大的引用类型，尽管 ECMAScript 实现的正则表达式没有 <code>Perl</code> 语言的高级（<strong>例如 unicode 支持、并集和交集类、单行、注释、条件匹配等等</strong>），但也能解决绝大多数问题。</p><h4 id="4-4-1-实例创建"><a href="#4-4-1-实例创建" class="headerlink" title="4.4.1 实例创建"></a>4.4.1 实例创建</h4><p>ECMAScript 中，不需要使用引号即可创建正则表达式（直接量 literal）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expr = <span class="regexp">/&lt;pattern&gt;/</span>&lt;flags&gt;;</span><br></pre></td></tr></table></figure><p>也可以从字符串创建（如果是放在字符串里，那么转义符自身也要转义了😢，例如 <code>\d</code> -&gt; <code>&quot;\\d&quot;</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expr = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;&lt;pattern&gt;&quot;</span>, <span class="string">&quot;flags&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>pattern</code> 就是我们最常用的正则表达式模式字符串。</p><p><u>但是以前（ECMAScript 5 之前），正则表达式直接量和 <code>new</code> 初始化的内存机制略有不同。</u></p><p>这是因为，<strong><u>正则表达式直接量</u>相当于 C++ 中的字符串常量，也相当于 Java 中位于字符串池中的常量字符串</strong>，每次引用这个常量都是一个内存地址中的对象；而 <code>new</code> 出来的对象就是真实独立存在堆内存中的对象了。</p><p><u>而在 ECMAScript 5 之后，正则表达式 literal 也必须和直接使用构造函数一样创建新的实例。</u></p><p><code>flags</code> 包含以下几种（仅列举几种常用的，不常用的 JavaScript 也不一定支持）：</p><ul><li><p><code>g</code>：global，表示全局模式，<strong>不会在找到第一个匹配项时停止</strong>（默认会停止，即<u>下次查找从头开始</u>）；</p></li><li><p><code>i</code>：case insensitive，大小写不敏感；</p></li><li><p><code>m</code>：multiline，多行匹配，<code>^</code>、<code>$</code> 会选中一行的开头和结尾，而不再是整个字符串的开头和结尾；</p><blockquote><p>例如字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helloJava</span><br><span class="line">123</span><br><span class="line">HelloPython12</span><br><span class="line">456</span><br></pre></td></tr></table></figure><p>如果使用 <code>/^\d+$/g</code> 则只会匹配到 <code>123</code>，而使用 <code>/^\d+$/gm</code> 则会匹配到 <code>123</code> 和 <code>456</code>；</p></blockquote></li><li><p><code>s</code>：即 <code>.</code> 限定符加入包含换行符 <code>\n</code>，具体表现为使用 <code>.</code> 代表的内容可以不在同一行；</p></li></ul><h4 id="4-4-2-常用实例属性"><a href="#4-4-2-常用实例属性" class="headerlink" title="4.4.2 常用实例属性"></a>4.4.2 常用实例属性</h4><ul><li><p><code>RegExp.global</code>：Boolean，是否设置了 <code>g</code> flag；</p></li><li><p><code>RegExp.ignoreCase</code>：Boolean，是否设置 <code>i</code> flag；</p></li><li><p><code>RegExp.multiline</code>：Boolean，是否设置 <code>m</code> flag；</p></li><li><p><code>RegExp.lastIndex</code>：Number，表示当前正则对象<u><strong>下一次匹配</strong></u>的位置；</p><blockquote><p>注：有这个属性的原因是，在使用 global 模式时，正则对象查找 pattern 会在第一次匹配到的时候不会停止，所以需要为下次匹配继续保留这个状态。</p></blockquote></li><li><p><code>RegExp.source</code>：String，表示当前正则表达式的 <strong><code>pattern</code> 字符串表示</strong>；</p></li></ul><h4 id="4-4-3-常用实例方法"><a href="#4-4-3-常用实例方法" class="headerlink" title="4.4.3 常用实例方法"></a>4.4.3 常用实例方法</h4><p><strong>Ⅰ. 正则式引用类型 匹配方法：<code>exec</code></strong></p><p><code>RegExp.exec(String) -&gt; Extended Array</code></p><p><code>RegExp</code> 的重要方法，也是指示正则匹配的方法。由于 JavaScript 不强调类型，所以返回的信息不像其他语言用类型包装（例如 Qt/C++ 中的 <code>QRegularExpressionMatch</code>、Python 中的 <code>re.Match</code>），只是使用一个数组来存放信息。<u><strong>不过这个数组多了 <code>index</code>、<code>input</code> 两个属性</strong>，并且其他数组项（键 <code>k ∈ [0, N)</code>）存放的是第 k 组</u>；</p><p>需要注意以下几点：</p><ul><li><p><strong>和其他所有正则框架一样，第 0 组是匹配到的字符串的全文</strong>；</p></li><li><p>返回值数组的 <code>index</code> 属性表示 <strong>当前匹配到的字符串在原字符串中的起始位置</strong>；</p></li><li><p>返回值数组的 <code>input</code> 属性表示输入的字符串；</p></li><li><p>即便设置 <code>g</code> flag，调用 <code>exec</code> 仍然每次仅返回一个匹配结果。不过由于设置了 <code>g</code> flag，每次调用 <code>exec</code> 时，<code>index</code> 就被赋予 <code>lastIndex</code> 的值向后查找；</p></li><li><strong>由于 <code>lastIndex</code> 存放在 <code>RegExp</code> 对象中，所以即使 <code>exec</code> 的传入参数换成另一个字符串，匹配仍然会从上一次 <code>lastIndex</code> 处开始，在编程时需要注意</strong>；</li><li>当 <code>exec</code> 向后查找结束（global），或者没有匹配的部分时，返回 <code>null</code>；</li></ul><p>举个例子，想要匹配文字间 Latex 语法，找到所有 $$$$ 隔开的数学行公式，那么使用如下正则式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 确切地说，应该使用 (?&lt;!\$)\$\$(?!\$)(.+?)(?&lt;!\$)\$\$(?!\$)， */</span></span><br><span class="line"><span class="comment">/* 因为 \1 无法指代断言。不过这里只是随便演示一下 */</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?&lt;!\$)(\$\$)(?!\$)(.+?)\1/gm</span>;</span><br></pre></td></tr></table></figure><p>如果这是要查找的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;$jfj4$$3$0$$\nd34of$$deo$$&quot;</span>;</span><br></pre></td></tr></table></figure><p>那么输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; reg.<span class="title function_">exec</span>(str);    <span class="comment">// 第一次查找</span></span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;$$3$0$$&#x27;</span>,        <span class="comment">// array[0] =&gt; 第 0 组，匹配到的全文</span></span><br><span class="line">  <span class="string">&#x27;$$&#x27;</span>,                <span class="comment">// array[1] =&gt; 第一组，也就是 (\$\$) 选中的组</span></span><br><span class="line">  <span class="string">&#x27;3$0&#x27;</span>,            <span class="comment">// array[2] =&gt; 第二组，也就是 (.+?) 选中的组</span></span><br><span class="line">  <span class="attr">index</span>: <span class="number">5</span>,            <span class="comment">// array.index =&gt; 第 0 组的开始位置索引</span></span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;$jfj4$$3$0$$\nd34of$$deo$$&#x27;</span>,</span><br><span class="line">  <span class="attr">groups</span>: <span class="literal">undefined</span></span><br><span class="line">]</span><br><span class="line">&gt; reg.<span class="title function_">exec</span>(str);    <span class="comment">// 第二次查找，从上一次的 lastIndex (=12) 开始</span></span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;$$deo$$&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;$$&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;deo&#x27;</span>,</span><br><span class="line">  <span class="attr">index</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;$jfj4$$3$0$$\nd34of$$deo$$&#x27;</span>,</span><br><span class="line">  <span class="attr">groups</span>: <span class="literal">undefined</span></span><br><span class="line">]</span><br><span class="line">&gt; reg.<span class="title function_">exec</span>(str);    <span class="comment">// 第三次查找，从上一次的 lastIndex (=25) 开始</span></span><br><span class="line"><span class="literal">null</span>                <span class="comment">// 无法找到更多的匹配内容，返回 null，并且将 lastIndex 设为 0</span></span><br></pre></td></tr></table></figure><p><strong>Ⅱ. 正则式引用类型 检查方法：<code>test</code></strong></p><p><code>RegExp.test(String) -&gt; Boolean</code></p><p>从 <code>lastIndex</code> 开始检查下一个是否存在匹配的字符串，会改变 <code>lastIndex</code>（等同于 <code>Boolean(RegExp.exec)</code>）；</p><p><strong>Ⅳ. 正则式引用类型 类型转换方法：<code>toString / toLocaleString</code></strong> 直接返回<strong>构造直接量（pattern + flag）</strong>；</p><p><strong>Ⅴ. 正则式引用类型 构造函数属性</strong></p><p>JavaScript 中的 “构造函数属性” 类似于 <strong>C++ 中的静态数据成员</strong>，也类似于 <strong>Python 中的类属性</strong>；这些属性同时影响整个类的实例。</p><blockquote><p>⚠ 警告：Opera 浏览器的 JS 引擎没有实现大部分这些属性；</p></blockquote><ul><li><code>input</code>：所有正则实例中，最近一次传入的字符串；</li><li><code>lastMatch</code>：所有正则实例中，最近一次匹配的属性；</li><li><code>lastParen</code>：所有正则实例中，最近一次匹配的捕获分组；</li><li><code>leftContext / rightContext</code>：<code>lastParen</code> 之前 / 之后的文本；</li><li><code>multiline</code>：<strong>是否所有正则实例都是多行模式</strong>；</li></ul><h3 id="4-5-Function-引用类型"><a href="#4-5-Function-引用类型" class="headerlink" title="4.5 Function 引用类型"></a>4.5 Function 引用类型</h3><h4 id="4-5-1-Function-引用类型的实质"><a href="#4-5-1-Function-引用类型的实质" class="headerlink" title="4.5.1 Function 引用类型的实质"></a>4.5.1 Function 引用类型的实质</h4><p>我们已经知道，JavaScript 函数就是一种特殊的对象（Object），因此每个函数都是 <code>Function</code> 类型的实例，并且具有一些共有的属性和方法。</p><p>例如以下两种定义方式<strong>几乎相同</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* method 1 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* method 2: Function 类的构造函数 function() */</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么说 “几乎”？因为它们的<strong>唯一区别</strong>在于解释器是否进行<strong>函数声明提升（function declaration hoisting）</strong>的过程。</p><blockquote><p>在 C 里面我们知道，如果你在 <code>*.c</code> 中定义了函数，那么不能在函数名出现前使用它，除非在此前声明。</p><p>而在 JavaScript 中不存在手动声明的说法，是由解释器识别并将函数定义提升至源代码的最前面。如果使用第二种方法定义函数，那么解释器不会对这个赋值操作进行函数声明提升。因此下面两种操作<strong>只有第一种不会报错</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* method 1 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* method 2: wrong */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>我们还需要了解的重要一点，<strong>函数是对象，函数名是指针</strong>。所以在 JavaScript 中，开发者唯一能接触到的指针只有函数指针（即函数名）。</p><p>而存放函数指针的变量和其他变量并没有什么不同，也能随意赋值（<strong>包括函数传参</strong>），这就能解释为什么 JavaScript 中没有重载。</p><h4 id="4-5-2-Function-引用类型的常用内部属性"><a href="#4-5-2-Function-引用类型的常用内部属性" class="headerlink" title="4.5.2 Function 引用类型的常用内部属性"></a>4.5.2 Function 引用类型的常用内部属性</h4><blockquote><p>内部对象属性是 JavaScript 引擎自行构建的；</p></blockquote><ul><li><p><code>Function.arguments.callee</code>：使用场景，解耦合的递归函数（为什么需要解耦合？因为 JavaScript 的函数可以随意赋给另一个变量，它和 C++ 的函数指针一样，运行时指向同一内存地址）；</p></li><li><p><code>Function.caller</code>：当前函数的当前调用方，如果上次在全局作用域中调用，则为 <code>null</code>；</p></li><li><p><code>Function.this</code>：<strong>与 OOP 无关，是函数执行的<u>环境对象</u></strong>（表示作用域的对象，也是 <code>Object</code>）；</p><blockquote><p>例如网页全局作用域中调用函数时，<code>this</code> 就是 <code>window</code> 对象；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">//&quot;red&quot;</span></span><br><span class="line">o.<span class="property">sayColor</span> = sayColor;</span><br><span class="line"><span class="comment">/* 环境作用域中最近有啥，this 就选择啥 */</span></span><br><span class="line">o.<span class="title function_">sayColor</span>(); <span class="comment">//&quot;blue&quot;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>Function.length</code>：函数<strong>希望</strong>接收的参数个数；</p></li><li><p><code>Function.prototype</code>（<strong>不可枚举，不可被 <code>for-in</code> 找到</strong>）：讨论原型时详细介绍；4</p><blockquote><p>对 JavaScript 的<strong>所有引用类型</strong>而言，<strong>是保存引用类型所有实例方法的对象</strong>；</p></blockquote></li><li><p><code>Function.apply(&lt;envObj&gt;, [paramArr]) / Function.call(&lt;envObj&gt;, [param1, param2, ...])</code>：<strong>指定函数作用域对象来调用函数</strong>；</p></li><li><code>Function.bind(&lt;envObj&gt;) -&gt; Function</code>：<strong>无视当前环境，创建新的函数实例，并将其环境对象指定为 <code>&lt;envObj&gt;</code></strong>（相当于在 <code>&lt;envObj&gt;</code> 中定义了该函数）；</li></ul><h3 id="4-6-基本包装类型"><a href="#4-6-基本包装类型" class="headerlink" title="4.6 基本包装类型"></a>4.6 基本包装类型</h3><p>和 Java 类似，为了方便基本类型的操作，JavaScript 定义了<strong>内置基本类型的引用类型</strong>，共有 3 种：<code>Boolean</code>、<code>Number</code>、<code>String</code>；</p><p>它们不需要被显式创建，而是在我们使用基本类型时，如果对它们调用方法，解释器自动为我们进行如下步骤：</p><ol><li><p>创建该基本类型的实例；</p></li><li><p>调用该实例的指定方法；</p></li><li><p>销毁该实例；</p></li></ol><p>这能解释 2 个问题：</p><ul><li><p>为什么基本类型可以存在方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>因为等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>为什么为基本类型赋予属性时会立即消失：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">s1.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(s1.<span class="property">color</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p><strong>因为上一次创建的 <code>String</code> 对象已经被销毁了</strong>；</p></li></ul><p>下面是内置基本包装类型的常用方法（除了普通 <code>Object</code> 也有的）：</p><ul><li><p><code>Number.toFixed(Number)</code>；</p></li><li><p><code>Number.toExponential(Number)</code>；</p></li><li><p><code>Number.toPrecision()</code>：以上两种最方便的切换模式；</p></li><li><p><code>String.charAt() / charCodeAt()</code>；</p></li><li><p><code>String[&lt;idx&gt;]</code>；</p></li><li><p><code>String.concat(&lt;String&gt;)</code>：最好还是用 <code>+</code>；</p></li><li><p><code>String.slice(&lt;start&gt;, [stop]) / String.substr(&lt;start&gt;, [length]) / String.substring(&lt;start&gt;, [stop])</code>：字符串切片 ；</p><ul><li>注意，只有 <code>substr()</code> 第二参数指定的是长度；</li><li>当输入存在负值时，<code>slice</code> 与 python 的 <code>slice</code> 完全一致，start 和 stop 都是反向索引；</li><li>当输入存在负值时，<code>substr</code> 第一参数（start）与之前一致，而第二参数因为是长度，所以如果是负值则转为 0；</li><li>当输入存在负值时，<code>substring</code> <strong>不接受一切负参数</strong>，将负参数转为 0；</li></ul></li><li><p><code>String.indexOf(&lt;substr&gt;, [start]) / String.lastIndexOf(...)</code>：字符子串查找；</p></li><li><p><code>String.trim()</code>：删除字符串前后的所有空白字符，并创建实例副本；</p></li><li><p><code>String.to[Locale][Lower/Upper]Case()</code>：字符串大小写转换；</p></li><li><p><code>String.match(&lt;RegExp&gt;) -&gt; match array</code>：等同于 <code>RegExp.exec(&lt;String&gt;)</code>；</p></li><li><p><code>String.search(&lt;RegExp&gt;) -&gt; Number</code>： 查找第一次出现 pattern 的位置索引，若不存在则返回 -1；</p></li><li><p><code>String.split(&lt;char&gt; | &lt;RegExp&gt;)</code>：⚠⚠ <u>谨慎在此式使用正则表达式，因为在捕获组为空的时候，不同浏览器下行为不一致</u>；⚠⚠</p></li><li><p><code>String.replace(&lt;RegExp&gt;, &lt;newStr&gt;)</code>：字符串替换；</p><p>注意，这里的 <code>newStr</code> 有些特点，例如它允许特殊的字符串标识：</p><ol><li><code>$&amp;</code>：等同于 <code>RegExp.lastMatch</code>；</li><li><code>$&#39;</code>：等同于 <code>RegExp.leftContext</code>（反引号就是 <code>RegExp.rightContext</code>）；</li><li><code>$n/nn</code>：第 n 捕获组字符串（nn 表示两位数），如果没有该组，则表示空字符串；</li><li>$$$$：表示 <code>$</code> 字符本身；</li></ol></li><li><p><code>String.replace(&lt;RegExp&gt;, &lt;rFunc&gt;)</code>：自定义替换规则；</p><p>这里的 <code>rFunc</code> 要求传入参数的形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@brief</span> Inner replace function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>[in] match Matched string (group[0]).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>[in] pos The index of matched string in original string.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>[in] originalText Original string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rFunc</span>(<span class="params">match, pos, originalText</span>);</span><br></pre></td></tr></table></figure><p>举个例子，如果需要将 HTML 中所有特殊字符替换为转义字符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">htmlEscape</span>(<span class="params">text</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> text.<span class="title function_">replace</span>(</span><br><span class="line">        <span class="regexp">/[&lt;&gt;&quot;&amp;]/g</span>,</span><br><span class="line">        <span class="keyword">function</span>(<span class="params">match, pos, origin</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&amp;lt;&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;&gt;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&amp;gt;&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;&amp;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&amp;amp;&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;\&quot;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&amp;quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>String.localeCompare(&lt;str&gt;)</code>：比较两个字符串。顺序比较字符串中每个字符，排在字母表后面的会返回 1，前面会返回 -1。两字符串相同会返回 0；</p></li><li><p><code>String.fromCharCode(&lt;int params&gt;)</code>：从 unicode 构建字符串；</p></li></ul><p><u><strong>在此强烈不建议手动实例化基本包装类型，因为它们可能使 <code>instanceof</code>、<code>typeof</code> 等关键字失去作用</strong></u>。</p><h3 id="4-7-单体内置对象"><a href="#4-7-单体内置对象" class="headerlink" title="4.7 单体内置对象"></a>4.7 单体内置对象</h3><p>由 ECMAScript 实现提供的、<strong>不依赖于宿主环境的对象</strong>，这些对象在 ECMAScript 程序执行之前就已经存在了。</p><p>我们已经接触到的对象有：<code>Object</code>、<code>Array</code>、<code>String</code> 等等（没有真正的类型）；</p><p>这里介绍两个额外的单体内置对象：<code>Global</code>、<code>Math</code>；</p><h4 id="4-7-1-Global"><a href="#4-7-1-Global" class="headerlink" title="4.7.1 Global"></a>4.7.1 Global</h4><p>这个对象你在 JavaScript 中永远无法自己创建。不过可以找到它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种表达式在 JavaScript 中被称为函数表达式，后面介绍</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">global</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="variable language_">this</span>;&#125;();</span><br></pre></td></tr></table></figure><p>而且<strong>不论当前执行环境在哪里，不论你使用 <code>apply()</code>、<code>call()</code> 访问这个函数，其中的 <code>this</code> 都是 <code>Global</code> 对象</strong>；</p><p>而且，JavaScript 中实际上<strong>不存在全局变量和全局函数</strong>，它们<strong>都是 <code>Global</code> 对象的属性和方法</strong>。例如之前遇到的 <code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>、<code>parseFloat()</code>；</p><p><u>无论是 <code>Global</code> 属性还是方法，都不能对其进行赋值操作！</u></p><p><strong><code>Global</code> 方法</strong></p><p>此外，<code>Global</code> 中还有两类方法。一种是 URI 编解码。</p><ul><li><p>URI 编码方法：<code>encodeURI(&lt;str&gt;)</code>、<code>encodeURIComponent(&lt;str&gt;)</code> </p><blockquote><p>有效的 URI 中不能包含某些字符，例如空格；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">&quot;http://www.wrox.com/illegal value.htm#start&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;http://www.wrox.com/illegal%20value.htm#start&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">encodeURI</span>(uri));</span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure></blockquote></li><li><p>URI 解码方法：<code>decodeURI(&lt;str&gt;)</code>、<code>decodeURIComponent(&lt;str&gt;)</code></p></li></ul><p>以上方法可以将 URI 进行编码，以便发送给浏览器处理；</p><p>另一种是 <code>eval()</code> 方法，它<strong>提供了一个完整的 ECMAScipt 解释器</strong>，将参数中的字符串作为 JavaScript 代码直接执行；</p><p>不过有几个需要注意的点：</p><ul><li><code>eval()</code> 中创建的任何变量和函数都不会被提升（包括函数声明提升）；</li><li><code>eval()</code> 存在代码注入的安全问题；</li><li><strong>非严格模式下，<code>eval()</code> 函数内外共享变量和函数作用域</strong>，相当于在原位添加了字符串中的代码；</li></ul><p><strong><code>Global</code> 属性</strong></p><p>之前的 <code>undefined</code>、<code>NaN</code>、<code>Infinity</code> 等都是 <code>Global</code> 对象属性。就连<strong>所有原生引用类型的构造函数也都是 <code>Global</code> 对象的属性（不是方法）</strong>。此外，常见的错误对象（在错误处理一章介绍）也是 <code>Global</code> 对象。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/global.png"></p><h4 id="4-7-2-window-对象"><a href="#4-7-2-window-对象" class="headerlink" title="4.7.2 window 对象"></a>4.7.2 <code>window</code> 对象</h4><p>在 Web 浏览器的 ECMAScript 引擎中，会自动设置一个全局对象 <code>window</code>，它会自动包含所有 <code>Global</code> 对象的属性和方法（将 <code>Global</code> 对象作为 <code>window</code> 对象的一部分），<u><strong>并且是实时的</strong></u>。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayColor</span>(); <span class="comment">//&quot;red&quot;</span></span><br></pre></td></tr></table></figure><p><code>window</code> 对象在 ECMAScript BOM / DOM 中用的较多。</p><h4 id="4-7-3-Math-对象"><a href="#4-7-3-Math-对象" class="headerlink" title="4.7.3 Math 对象"></a>4.7.3 <code>Math</code> 对象</h4><p><strong><code>Math</code> 对象属性</strong></p><p>大多是常用的常量：<code>Math.E</code>、<code>Math.LN10</code>、<code>Math.LN2</code>、<code>Math.LOG2E</code>、<code>Math.LOG10E</code>、<code>Math.PI</code>、<code>Math.SQRT1_2</code>、<code>Math.SQRT2</code>……</p><p><strong><code>Math</code> 对象方法</strong></p><p>常见数学方法：<code>min(&lt;params&gt;)</code>（<strong>不接受数组，如果需要，请用前面提到的 <code>apply</code></strong>）、<code>max()</code>、<code>ceil()</code>、<code>floor()</code>、<code>round()</code>、<code>random()</code>（取值 <code>[0, 1]</code>）、<code>abs()</code>、<code>exp()</code>、<code>log()</code>、<code>pow(&lt;num&gt;, &lt;power&gt;)</code>、<code>sqrt()</code>、<code>acos()</code>、<code>cos()</code>……</p><h2 id="Chapter-5-OOP-in-JavaScript"><a href="#Chapter-5-OOP-in-JavaScript" class="headerlink" title="Chapter 5. OOP in JavaScript"></a>Chapter 5. OOP in JavaScript</h2><p>在 ECMAScript 中，对于对象的定义是：</p><p><u><strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong></u>。</p><p>对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把 ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。</p><blockquote><p>简而言之，JavaScript 中的对象就是一个类似散列表的结构。</p></blockquote><h3 id="5-1-对象的实际定义"><a href="#5-1-对象的实际定义" class="headerlink" title="5.1 对象的实际定义"></a>5.1 对象的实际定义</h3><p>之前几章中介绍的对象定义方法是无需声明，<u>加点或方括号</u>直接添加属性及方法，如下（构造函数创建）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">person.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line">person.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">person[<span class="string">&quot;G P A&quot;</span>] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">person.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还可以用这种方式（对象直接量创建）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果将所有的 key 全部换为标准的字符串形式，那么就是大名鼎鼎的 JSON（JavaScript Object Notation，JS 对象表示）；</p><p>其实，基本引用类型 <code>Object</code> 的属性都定义了解释器内部特性（attribute），它们：</p><ul><li>给 JavaScript 解释器使用，<strong>JavaScript 代码无法直接访问</strong>；</li><li>描述了 JavaScript 对象的属性的各种特征；</li></ul><blockquote><p>为了规范，将对象属性的 attribute 放在双方括号中表示。</p></blockquote><p>ECMAScript 对象的属性分为 2 种：<u><strong>数据属性、访问器属性</strong></u>。</p><h4 id="5-1-1-数据属性的-attribute"><a href="#5-1-1-数据属性的-attribute" class="headerlink" title="5.1.1 数据属性的 attribute"></a>5.1.1 数据属性的 attribute</h4><p><u>ECMAScript 的所有直接定义的对象属性都是 数据属性</u>。</p><ul><li><code>[[Configurable]]</code>：能否<u>通过 delete 删除属性</u>从而重新定义属性，能否<u>修改属性的特性</u>，或者能否把属性修<u>改为访问器属性</u>（默认为 <code>true</code>）；</li><li><p><code>[[Enumerable]]</code>：能否通过 <code>for-in</code> 循环返回属性。例如前面提到的 <code>Function.prototype</code>就是  <code>false</code>；</p></li><li><p><code>[[Writable]]</code>：表示能否修改属性的值；</p></li><li><code>[[Value]]</code>：<u>该属性的数据值存放处</u>，即读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置；</li></ul><p>可以通过 <code>Object.defineProperty(&lt;targetObj&gt;, &lt;propName&gt;, &lt;descriptor&gt;)</code> 修改。其中描述符对象 <code>descriptor</code> 必须具有属性 <code>configurable</code>、<code>enumerable</code>、<code>writable</code>、<code>value</code> 其中至少一个（默认全为 <code>false</code>），例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5-1-2-访问器属性的-attribute"><a href="#5-1-2-访问器属性的-attribute" class="headerlink" title="5.1.2 访问器属性的 attribute"></a>5.1.2 访问器属性的 attribute</h4><p>访问器属性针对 ECMAScript 对象的 <strong>属性自定义访问方法</strong>，自身不包含数据。常见作用是 <strong>动态获取属性、自定义属性访问权限和访问规则</strong>。</p><p><strong>完全可以理解为 Python 中的 <code>@getter</code>、<code>@setter</code></strong> 定义的实例属性；</p><ul><li><code>[[Configurable]]</code>：表示能否<u>通过 delete 删除属性</u>从而重新定义属性，能否<u>修改属性的特性</u>，或者能否把属性<u>修改为数据属性</u>（默认为 <code>true</code>）；</li><li><code>[[Enumerable]]</code>：表示能否通过 <code>for-in</code> 循环返回属性；</li><li><code>[[Get]]</code>：函数，读取属性时调用，返回值即为该属性值；</li><li><code>[[Set]]</code>：函数，写入属性时调用，它的行为会代替写入行为；</li></ul><p><strong>访问器属性不能被直接定义（普通定义属性的方法都是数据属性），只能使用 <code>Object.defineProperty()</code> 修改，类比数据属性的修改方法</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="attr">_year</span>: <span class="number">2004</span>,</span><br><span class="line">    <span class="attr">edition</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_year</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newValue</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_year</span> = newValue;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.<span class="property">year</span> = <span class="number">2005</span>;</span><br><span class="line"><span class="title function_">alert</span>(book.<span class="property">edition</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>如果在设置访问器属性时，未指定 <code>set</code>，那么意味着写入该属性时什么都不会做，对于 <code>get</code> 同理。</p><h4 id="5-1-3-设置属性的-attribute"><a href="#5-1-3-设置属性的-attribute" class="headerlink" title="5.1.3 设置属性的 attribute"></a>5.1.3 设置属性的 attribute</h4><p>除了上面介绍的 <code>Object.defineProperty()</code>，还可以同时对多个对象属性设置 attribute：</p><p><code>Object.defineProperties(&lt;targetObj&gt;, &lt;propObj&gt;)</code>；</p><p>其中，<code>propObj</code> 对象的格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    &lt;propertyName1&gt;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        &lt;attributeName11&gt;<span class="punctuation">:</span> &lt;entry11&gt;<span class="punctuation">,</span></span><br><span class="line">        &lt;attributeName12&gt;<span class="punctuation">:</span> &lt;entry12&gt;</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    &lt;propertyName2&gt;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        &lt;attributeName21&gt;<span class="punctuation">:</span> &lt;entry21&gt;<span class="punctuation">,</span></span><br><span class="line">        &lt;attributeName22&gt;<span class="punctuation">:</span> &lt;entry22&gt;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="5-1-4-读取属性的-attribute"><a href="#5-1-4-读取属性的-attribute" class="headerlink" title="5.1.4 读取属性的 attribute"></a>5.1.4 读取属性的 attribute</h4><p><code>Object.getOwnPropertyDescriptor(&lt;targetObj&gt;, &lt;propName&gt;)</code> 可以获得该属性的描述符，与设置相对应故不再赘述。</p><h3 id="5-2-创建对象的高级方法"><a href="#5-2-创建对象的高级方法" class="headerlink" title="5.2 创建对象的高级方法"></a>5.2 创建对象的高级方法</h3><p>我们发现，由于 JavaScript 没有真正的类型，只有对象。所以当我们想创建接口相同的对象时，<strong>如果使用上面的构造函数，或者对象直接量创建，那么免不了需要重复定义对象</strong>。这显然是不可取的。</p><p>于是，一代代人采用不同方法来创建对象，以提升代码复用性 和 可维护性。下面是设计迭代的过程。</p><h4 id="5-2-1-工厂模式"><a href="#5-2-1-工厂模式" class="headerlink" title="5.2.1 工厂模式"></a>5.2.1 工厂模式</h4><p><u><strong>通过抽象 “具体对象的创建过程” 为一个函数，来完成对象的构建</strong></u>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    o.<span class="property">name</span> = name;</span><br><span class="line">    o.<span class="property">age</span> = age;</span><br><span class="line">    o.<span class="property">job</span> = job;</span><br><span class="line">    o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>⚠⚠ <strong>缺陷</strong>：<strong>无法识别这个接口相同的对象</strong>。⚠⚠</p><p>为了解决这个问题，设计出了 “构造函数模式” 来创建同接口的对象。</p><h4 id="5-2-2-构造函数模式-与-this-关键字"><a href="#5-2-2-构造函数模式-与-this-关键字" class="headerlink" title="5.2.2 构造函数模式 与 this 关键字"></a>5.2.2 构造函数模式 与 this 关键字</h4><p>首先我们要梳理一个问题——什么是 JavaScript 中的 <code>this</code> 关键字。它的含义相当混乱。我们在前面的时候已经用到过 <code>this</code> 关键字，但是它实际上：</p><ul><li><p>在方法中，this 表示该方法所属的对象；</p></li><li><p>如果单独使用，this 表示全局对象；</p></li><li><p>在函数中，this 表示全局对象（严格模式下为 <code>undefined</code>）；</p></li></ul><blockquote><p>其实还有 <strong>事件</strong>，在 “事件” 中，<code>this</code> 也不相同，不过这里不作介绍，用到再说。</p></blockquote><p>进一步来看 JavaScript 中的 <code>new</code> 关键字的作用。</p><p>首先 <code>new</code> 关键字的操作对象是 <code>Function</code>，并<u>将该函数作为构造函数</u>。</p><p>这是 <code>var obj = new Func()</code> 执行的具体步骤：</p><ol><li><p>创建一个新对象（为对象开辟内存空间），以 <code>o</code> 指代；</p></li><li><p>将 <code>Func</code> 作用域对象绑定为 <code>o</code>，所以 <code>Func</code> 内的 <code>this</code> 由原本的全局对象指向 <code>o</code>；</p></li><li><p>执行 <code>Func</code> 函数体；</p></li><li><p>为对象 <code>o</code> 添加普通属性 <code>constructor</code>，指向 <code>Func</code>；</p><blockquote><p>这样我们可以通过两种方法确定这种对象的接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">constructor</span> == <span class="title class_">Func</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Func</span>);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>自动返回对象 <code>o</code>；</p></li></ol><p>经过这样定义的 <code>this</code> 和 <code>new</code> 关键字就能完成类似 C++ 中构造函数的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样也能解释为什么自定义的对象也继承于 <code>Object</code>。</p><p>同时，这种函数也能作为普通函数使用，因为它的函数体本质上修改的是函数内的 <code>this</code> 对象。我们可以：</p><ul><li><p>直接调用它：这样修改的 <code>this</code> 就是全局对象，相当于给全局对象加了特定属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器引擎中</span></span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); <span class="comment">// 添加到 window</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Greg&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>call() / apply()</code> 指定作用域对象来调用：这就相当于对特定的对象执行了构造函数，同时还能解决工厂模式的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(o, <span class="string">&quot;Kristen&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Nurse&quot;</span>);</span><br><span class="line">o.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Kristen&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>⚠⚠ <strong>缺陷</strong>：<strong>“构造”函数中，写函数定义作为属性，会导致每次构造一个对象，都产生一个新的对应的函数对象</strong>。这会导致不同的作用域链和标识符解析。⚠⚠</p><p>这是因为，函数也是 <code>Object</code> 的一种，函数直接量定义也会在堆内存中创建一个新的函数对象，然后引用。</p><p>有人说，这好办，把所有函数定义都拿到 “构造” 函数以外不就行了？</p><p>但是如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。</p><p>因此另一种 JavaScript 的对象构造模式就出现了。</p><h4 id="5-2-3-原型"><a href="#5-2-3-原型" class="headerlink" title="5.2.3 原型"></a>5.2.3 原型</h4><p>解决 “构造” 函数封装性问题的方法很简单：<strong>再套一层作用域对象，不影响全局作用域对象不就行了</strong>！</p><p>ECMAScript 实际也是这么解决的。我们在 4.5.2 中提到，<code>Function</code> 引用类型有一个属性 <code>prototype</code>，这个就是为了解决对象的构造函数封装问题。</p><p><code>Function.prototype</code> 就是一个引用<strong>指向一个新的对象（在这个函数创建时被创建）</strong>，这个新对象的用途就是 <u><strong>保存特定类型的所有实例共享的属性和方法</strong></u>。</p><p>也就是说，你可以使用某个函数的 <code>prototype</code> 作为存放一类接口相同的对象模板属性的对象（模板对象）。</p><p>于是，我们定义构造函数 <code>Func</code> 时就创建一个新对象（为对象开辟内存空间），暂且叫做 <code>o1</code>，创建的引用指向新对象，<strong>这个引用就叫 <code>prototype</code></strong>；</p><p>而我们使用 <code>new</code> 关键字的过程（<code>var obj = new Func();</code>）就变为：</p><ol><li>创建一个空的 JavaScript 对象，叫做 <code>o2</code>；</li><li>为对象 <code>o2</code> 添加内部属性 <code>[[prototype]]</code>，或者 <code>__proto__</code>，指向 <code>o1</code>（即 <code>Func.prototype</code>所指），对开发者不可见；</li><li>将当前 <code>Func</code> 作用域对象绑定为 <code>o2</code>，所以 <code>Func</code> 内的 <code>this</code> 由原本的全局对象指向 <code>o2</code>；</li><li>执行 <code>Func</code> 函数体；</li><li>为对象 <code>o2</code> 添加普通属性 <code>constructor</code>，指向 <code>Func</code>；</li><li>返回对象 <code>o2</code>；</li></ol><p>这样：</p><ul><li><u><strong><code>prototype</code> 对象中的属性被所有构建出的对象所共享（通过 <code>[[prototype]]</code> 所共享，包括其中所有方法、属性）</strong></u>。相当于 Python 里的 类方法、类属性；</li><li>根据第 4 步，<strong>我们可以在构造函数 <code>Func</code> 中使用 <code>this</code> 修改属性</strong>，这就相当于<strong>仅对当前对象修改属性和方法</strong>，相当于 Python 里的实例方法、实例属性（当然也可以在构造函数外修改）；</li></ul><p><u><strong>还有一个重要的特性，就是 查找对象自己的属性 可以 “fallback” 到原型对象上去查找</strong></u>。</p><p>比如下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instanceProp1</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instanceProp2</span> = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person2.<span class="property">name</span> = <span class="string">&quot;Sam&quot;</span>;    <span class="comment">// 相当于 “实例属性”</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// fallback to Person.prototype.name (&quot;Nicholas&quot;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>);    <span class="comment">// &quot;Sam&quot;</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 解释器如果无法找到对象的某个属性，那么它会通过 <code>[[prototype]]</code> 到它的原型中继续找。</strong></p><hr><p>还有一个问题，之前定义的 <code>__proto__</code> 不是指向共享的原型（其属性就像 Python 里的 类方法、类属性）吗？但它对开发者不可见，那么我该如何使用它？使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(&lt;obj&gt;) -&gt; <span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><p>这样直接能得到原型对象的引用，然后使用其中的属性就行。</p><p>此外，我们还可以分辨创建对象的接口类型（比 <code>constructor</code> 属性的比较更可靠）：使用 <code>Func.prototype.isPrototypeOf(&lt;obj&gt;)</code> 来判断 <code>obj</code> 是否由 <code>Func</code> 的原型构建出来。举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(p)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>还要记住一件事：由于 <code>Func.prototype</code> 被对象共享，所以<strong>请不要轻易替换原型对象，除非你知道你在做什么，否则会出现原型指代不一致的问题</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象后替换了原型对象，</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    name : <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    age : <span class="number">29</span>,</span><br><span class="line">    job : <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    sayName : <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原来的 friend 的 [[prototype]] 还指向旧的原型，</span></span><br><span class="line"><span class="comment">// 而旧的原型没有定义 sayName</span></span><br><span class="line">friend.<span class="title function_">sayName</span>(); <span class="comment">//error</span></span><br></pre></td></tr></table></figure><h4 id="5-2-3-EX-原生对象的原型"><a href="#5-2-3-EX-原生对象的原型" class="headerlink" title="5.2.3 - EX 原生对象的原型"></a>5.2.3 - EX 原生对象的原型</h4><p>原生对象也有原型，思路与这里一致，只需记住一点：</p><p>⚠⚠ ！！！<u><strong>强烈不建议修改原生对象原型</strong></u>！！！⚠⚠</p><h2 id="Chapter-6-函数表达式"><a href="#Chapter-6-函数表达式" class="headerlink" title="Chapter 6. 函数表达式"></a>Chapter 6. 函数表达式</h2><p>JavaScript 中非常重要的特性，就是函数表达式。<strong>它是定义函数的一种手段</strong>。</p><p>在 2.8 和 4.5 中，我们了解到函数的两种定义方法，一种是直接声明，另一种就是函数表达式（可以创建匿名函数）。</p><p>而且前者会发生函数声明提升，后者不会。</p><p>根据这个特性，有些函数声明无法做到的逻辑，函数表达式却可以，例如根据条件选择函数指针：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Yo!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="keyword">var</span> sayHi;</span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    sayHi = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sayHi = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Yo!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，函数表达式还有一些高级应用。</p><h3 id="6-1-应用Ⅰ：严格模式下的递归"><a href="#6-1-应用Ⅰ：严格模式下的递归" class="headerlink" title="6.1 应用Ⅰ：严格模式下的递归"></a>6.1 应用Ⅰ：严格模式下的递归</h3><p>为了防止递归函数赋给其他函数变量后可能无法使用的问题，递归函数内一般不写死自己的函数名，而是使用 <code>Function.arguments.callee</code> 的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在严格模式下，无法使用这个属性。我们可以把这个函数定义为函数表达式来巧妙避开这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">num</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num * <span class="title function_">f</span>(num-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="6-2-应用Ⅱ：闭包"><a href="#6-2-应用Ⅱ：闭包" class="headerlink" title="6.2 应用Ⅱ：闭包"></a>6.2 应用Ⅱ：闭包</h3><p>闭包和匿名函数很像，但它们是不同的概念。</p><p>闭包的定义是：<strong>有权访问另一个函数作用域中的变量的函数</strong>。</p><p>创建闭包的常用方法就是 <strong>函数内部定义函数</strong>。这样内部的函数就能访问外部函数的数据，这样内部函数就是闭包了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1, object2</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过有 2 点需要注意：</p><ol><li><p>闭包中，如果访问了外层函数的变量，那么在执行前该变量的值一直不会替换，而是原封不动地保存引用，例如这个例子的每个函数都返回 10：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createFunctions</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法是再加一个匿名函数，使得最内层的闭包无法访问到最外部变化的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createFunctions</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>和上面一个问题一样，这次是 <code>this</code> 对象。如果在对象中定义闭包，那么闭包是无法访问到对象作用域的<code>this</code>（只会找到全局作用域对象），所以需要手动在外部函数指定 <code>this</code> 对象的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">    getNameFunc : <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">// 这会获得 全局作用域中的 name 属性，而非 object.name</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;My Object&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attr">getNameFunc</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> that.<span class="property">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-3-应用Ⅲ：模仿块级作用域"><a href="#6-3-应用Ⅲ：模仿块级作用域" class="headerlink" title="6.3 应用Ⅲ：模仿块级作用域"></a>6.3 应用Ⅲ：模仿块级作用域</h3><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure><p>因为函数这样就能避免 <code>for</code> 语句中的计数变量 <code>i</code> 泄漏到全局中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;Written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt;《Professional JavaScript for Web Developers》 3rd Edition&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Web" scheme="https://sjtuxhw.top/tags/Web/"/>
    
    <category term="JavaScript" scheme="https://sjtuxhw.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浅析 TTY Subsystem</title>
    <link href="https://sjtuxhw.top/2024/01/15/%E6%B5%85%E6%9E%90-TTY-Subsystem/"/>
    <id>https://sjtuxhw.top/2024/01/15/%E6%B5%85%E6%9E%90-TTY-Subsystem/</id>
    <published>2024-01-14T23:12:02.000Z</published>
    <updated>2024-01-15T12:25:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>References: 参考文献见文章末尾。</i></p><p><i>本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h2 id="为什么讨论-TTY"><a href="#为什么讨论-TTY" class="headerlink" title="为什么讨论 TTY"></a>为什么讨论 TTY</h2><p>在 Linux 系统中，TTY 是一个相当有名的子系统。当你输入 <code>ls -l /dev</code> 的时候，你能看到许许多多以 <code>tty</code> 为前缀的字符设备，这就是对 TTY 子系统在文件上的抽象。</p><p>虽然我们无论是命令行还是 GUI 使用 Linux 的时候，TTY 似乎对我们无感，但是，当我因为一个小问题在互联网上查了很多关于 TTY 资料，却仍然很难找到一个完整的知识资料的时候，我发现这个 TTY 子系统的重要性被很多人忽视了。在整理了相关资料后，我愿意相信，搞清楚 Linux 的 TTY 子系统，属实是入门 Linux 系统的必由之路。</p><p><strong>尤其是，如果你想要写一些更接近 Linux 底层的、I/O interactive 方面的应用程序，那么 <code>TTY</code> 的知识就显得更加重要。</strong></p><p>前段时间，我在写 CSAPP 的 shell lab，工作量不大所以很快就完成了。但是文档里有句话让我不解，“这个 tiny shell <strong>不需要支持</strong>运行类似 <code>vim</code> 和 <code>tmux</code> 的程序，它们会对你的终端进行一些修改”。出于 “你不让我做，我偏要做” 的心态，我迅速拿着已经完工的 <code>tsh</code> 运行 <code>vim</code>，结果，<strong><code>vim</code> 被第 22 号信号挂起了</strong>。我尝试用内置指令 <code>fg</code> 将任务调向前台，也无济于事：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/fail.png"></p><p>很自然地，我查看了一下 22 号信号，发现是一个我未曾谋面的信号：<code>SIGTTOU</code>。很快啊，英文文档 “啪” 的一下就来了，我没有闪，只看见字里行间密密麻麻地挤满一个单词：<code>TTY</code>。</p><p>Google 了很多文章之后我才发现，我们一直使用的<strong>命令行（CLI）</strong>都建立在一个无形的机制之上，这个机制接收并且传递我们在终端软件窗口的字符指令，建立起用户和操作系统的 “调度 和 沟通” 的桥梁。这，我以前一直是没有关注的。</p><p>于是我明白，想要了解这之中究竟发生了什么、想要解决这个问题，就有必要了解一下 Linux TTY 了。</p><blockquote><p>对历史不感兴趣的同学请跳过下面一节。</p></blockquote><h2 id="TTY-的成长之路"><a href="#TTY-的成长之路" class="headerlink" title="TTY 的成长之路"></a>TTY 的成长之路</h2><p>实际上，TTY 在 OS 中的迭代和发展史谈不上 “elegant”，甚至可以用 “蜿蜒曲折” 来形容。</p><p>在 1869 年，一种机器叫做 “<strong>股票行情自动收录器</strong>”（stock ticker）在当时金融系统不断发展的资本主义世界诞生了。它的样貌可以描述一下——一个电驱动的机械装置，包含一台机械打字机（typewriter）、一捆的电线，还有一长串用以打孔的纸带组成，它工作时的样貌如下图<sup><a href="#fn_1" id="reffn_1">1</a></sup>：</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/tick1.png" width="300px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/tick2.png" width="300px" align=center></div></div></div></div><p>它的使用和早期的计算机一样（不过更早），都需要有一个操作员在一旁输入指令、处理输出纸带，<strong>最终可以达成 “远距离实时广播股票价格” 的任务</strong>，是不是有点像影视剧里的电报？</p><p>不过这个机器很快就演变为一个更快、基于 ASCII 编码的机械结构。知道它的名字的人可能会多一点：<strong>teletype</strong>（电传打字机，简称 TTY）。那么 teletype 在当时时如何完成给通信的另一方传输消息的功能的呢？答案是，连接上当时最大的 “网络”——<strong>Telex</strong>，专门用来在各个资本家之间传输商业电报。</p><p>你可能会好奇，这个时候的计算机是什么情况？很遗憾，这个时候计算机还超级大、超级原始，似乎和 teletype 没啥交集。但是没过几年，当计算机的设计和架构发展到，已经可以支持执行多任务（multitask）的时候，一个重要的能力，却也是等待解决的问题就来了：<strong>计算机可以与用户进行实时交互了</strong>。这意味着，之前 “将打孔写程序的纸带传入机器” 的<strong>旧批处理模型（old batch processing model）</strong>就可以被人机交互所代替，从而大大减小操作员运行计算机的工作量<sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p><p>那么，如何实现与机器的直接交互？（传纸带肯定不够高效的🤡 于是大佬们将视线转向当时市场中一个随处可见的机器——teletype 电传打字机。他们打算用 teletype 连接上计算机，这样只需要打打字向计算机发指令就可以达到交互和执行命令的效果。</p><p>有个难题是，当时市面上的 teletype 没有一个 “行业标准”，每个厂家生产的机器都略有不同。在计算机科学的视角来看，这好办，封装嘛，设计一个统一的 <strong>从 teletype 输入到 计算机的软件层适配接口</strong>（硬件层好说，就串口电信号而已，主要是软件驱动）就行，下次无论 teletype 生产厂家设计什么样的机型，只要计算机的系统支持这个接口规范，那不拿来就能用？</p><p>在当时的 Unix 世界中（当时 Unix 已经出现），一种方法是让 OS Kernel 来实现这层接口，处理所有有关于 teletype 输入的底层细节，例如字长（word length）、串口波特率（baud rate）、流控制（flow control）、校验（parity，学过数电的同学会比较清楚这里面的机制）、基础的行 buffer 编辑能力等等。</p><p>在 20 世纪 70 年代晚期，基于 teletype 和 OS 处理接口的一类新型输入终端出现了（例如 VT-100），它们在 teletype 的基础上包装了屏幕，支持闪烁的命令行光标、有色彩的输出信息等等，被人们称为 <strong>video terminals</strong>。</p><p>不过，到了今天，我们可以发现所有实体的 teletypes、video terminals 都已经 “灭绝” 了，你只能在一些博物馆，或者硬件发烧友的收藏中寻得它们的踪迹。</p><p>由于历史习惯的原因，当今你能看到所有的 Unix 类系统中还有 “TTY”，不过它们都是对以往的 video terminals 在软件上的模拟而已。正如一位外国网友所说：</p><blockquote><p>The legacy from the old cast-iron beasts is still lurking beneath the surface<sup><a href="#fn_3" id="reffn_3">3</a></sup>.</p><p>这头钢铁巨兽（teletypes）的意志仍蛰伏在如今的 OS 的外表之下<sup><a href="#fn_3" id="reffn_3">3</a></sup>。</p></blockquote><h2 id="用户视角下的-TTY-old-versions"><a href="#用户视角下的-TTY-old-versions" class="headerlink" title="用户视角下的 TTY: old versions"></a>用户视角下的 TTY: old versions</h2><p>想要了解现代 Linux 系统中的 TTY 机制，我们还需要将时间拨回很早以前——人们使用实体 teletype 输入的时候。我们将 teletype 这个输入计算机指令以实现人机交互的设备称之为 <strong>终端（terminal）</strong>。当时的软硬件结构是这样的：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/case1.png"></p><p>teletype 是用一捆捆电线连接到计算机的一个叫 <strong>UART</strong>（Universal Asynchronous Receiver and Transmitter，通用异步收发器）的硬件设备上的。</p><p>对应地，内核里就写了一个驱动 UART driver，用来管理从物理 terminal 设备上发来的电信号 bytes，处理一些细节例如前一节提到的 bytes 校验、流控制。</p><p>一开始，UART driver 是直接将初步处理好的 bytes 流直接传给一些正在运行的进程，但是显然这种方法需要弥补几个缺陷：</p><p><strong>1. 行编辑能力（Line Editing）</strong></p><p>正常人在敲键盘（当时是敲打字机）的时候，无法避免的可能会打错。所以，肯定得有 backspace 退格的功能对吧？这个功能当然可以交给接收信号的进程自己来处理，但是计算机科学讲究不能混淆抽象层级，而且这也不符合 Unix 的设计哲学——运行在其上的程序应该越简单越好（只关心自己的业务逻辑）。</p><p>所以为了方便考虑，当时的人们直接把这个功能也放到了操作系统内核里了。这时，操作系统就需要提供一个编辑内容的缓冲区（editing buffer），并且支持一些基本的编辑指令（退格、擦除单词、清空一行等），这些软件功能模块被叫做 <strong>line discipline</strong>（好家伙，这是在内核里写了一个行编辑器），它的地位如本节开头的图所示。</p><p>不过，不同的上层应用程序对于它们接收的输入流肯定有各种各样的自定义的要求，因此 line discipline 除了提供正常的行编辑功能（cooked or canonical mode），还提供 <strong>raw mode</strong>（对输入流不做处理）。因此这些 advanced application（例如本身就是编辑器软件、邮件客户端、shells，以及自己调用 <code>curses</code> 和 <code>readline</code> 的程序）常常将系统的 line discipline 设置为 raw mode，然后自己执行对流的控制。</p><p>正如上面所说，OS Kernel 提供了多种不同的 line disciplines，不过<strong>一次只有一个 line discipline attach 到指定的串口设备上</strong>（对于旧时设备，如上图，串口设备是 UART driver）。默认的 line discipline 会提供基本的行编辑功能，叫做 <code>N_TTY</code>（<code>driver/char/n_tty.c</code>），还有另外种类的 line disciplines 控制例如鼠标串口等。</p><p><strong>2. 会话管理（Session Management）</strong></p><p>还有一个很重要的一点是，对于一个用户而言可能他（她）需要同时运行多个程序，然后一次与它们之中的一个程序交互。总的来说，用户需要：</p><ul><li><p>如果一个应用程序陷入死循环，那么用户可能会需要向其发信号（kill / suspend……）；</p></li><li><p>一个后台程序如果需要向终端（terminal）写数据，那么它们需要被 <strong>suspend 直至前台进程处理结束，或者前台程序已经为其准备好了写终端的环境</strong>。</p><blockquote><ol><li><p>为什么需要 suspend？不然所有后台程序都能随意更改终端，那不乱套了！其实，再想想，你在后台运行一个 <code>echo &quot;Hello&quot;</code> 好像也不会挂起？这个问题与之前的不相悖，我们后面讨论；</p></li><li><p>这个 suspend 的机制就是借助了 OS Kernel 发送的 <code>SIGTTOU</code> 机制，后面详细说。</p></li></ol></blockquote></li><li><p>用户向当前 terminal 输入，肯定只能发送给当前的 “前台”（foreground）进程。</p></li></ul><p>常见的 OS 都会 implement 一个 TTY driver（<code>drivers/char/tty_io.c</code>）来实现上述需要（具体地位前本章开头的图片）。TTY driver 也是个软件，但和一般的 “进程” 不一样：它是个 “passive object”，这意味着它像一个库，只有一些数据域（data fields）和一些方法（methods），等待其他进程的主动调用 / 内核中断 handler 调用。</p><p>于是，人们通常将 <strong>UART driver</strong>（常用来直接读取串口设备、进行简单 parity 和 flow control）、<strong>line discipline 实例</strong>（用来作为 editing buffer，处理简单的行编辑命令）、<strong>TTY driver</strong>（多个进程间读取 terminal 的会话管理）三元组（triplet）称为一个 <strong>TTY device（TTY 设备）</strong>。</p><p>因此，Unix 操作系统对上层的应用程序抽象的 terminal 就是 <code>TTY</code> 设备文件，存放于 <code>/dev</code>。</p><blockquote><p>顺便提一句，Unix 系统想要对 TTY 设备文件写入的用户需要是这个 TTY 设备文件的拥有者（owner）。我们经常使用 <code>shell</code> 的 login mode 登陆服务器时，内部会执行 <code>login</code> 程序，其工作之一便是以 <code>root</code> 权限将 shell 接下来需要使用的 <code>/dev/ttyN</code> 的拥有者换为登陆用户，以便登录用户能够读写 terminal；</p></blockquote><h2 id="用户视角下的-TTY-modern-versions"><a href="#用户视角下的-TTY-modern-versions" class="headerlink" title="用户视角下的 TTY: modern versions"></a>用户视角下的 TTY: modern versions</h2><p>我们了解了以前计算机是如何将 teletype 连接到计算机上并与之交互的，现在我们再将视野转移到现代计算机（desktop system，一般是图形化的）。</p><p>还是讨论现代 Unix 系统，这个时候输入输出模型可以抽象为如下图形：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/case2.png"></p><p>此时 TTY driver 和 line discipline 的 作用和以往版本的作用几乎相近，但是现在已经不存在 teletype 了，取而代之的是 键盘 和 显示屏，因此就没有 UART 和实体 terminal 什么事了。</p><p>取而代之的，是一个在 <strong>terminal emulator 中模拟的 video terminal</strong>（可以理解为<strong>一个包括了字符帧缓存（frame buffer of characters）和图形属性）的复杂状态机</strong>）。</p><p>它的作用是接收来自键盘驱动的预处理信号，将其传给对应得 line discipline，并将输出数据渲染到 VGA 显示器上。</p><p>等等！不太对，我们一直讨论的是 terminal emulator，因此有下面 2 种问题：</p><ul><li>目前这台计算机还只能简单字符输入和显示，相当于只实现了命令行子系统（console subsystem）；</li><li>emulator 位于<strong>内核中</strong>，不够灵活（rigid），在抽象层级上说，为了可维护性和可扩展性，应该将其挪到用户态空间中（userland）；</li></ul><p>事实上，为了解决上面的问题，TTY device 的设计更加抽象了：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/case3.png"></p><p>我们发现，line discipline、TTY driver 的结构都不需要变嘛，因为它们还需要提供基本的行缓冲、会话管理的功能。因此，人们在内核中设计出了 <strong>pseudo terminal（<code>pty</code>，伪终端）</strong>，用于对接支持 <code>xterm</code>（Unix 中一种默认的终端模拟器）的桌面程序。</p><blockquote><p>注意，如果你在一个 <code>xterm</code> 桌面进程中调用了 <code>screen</code>、<code>tmux</code> 等程序，那么就是 pseudo terminal 套 pseudo terminal 的复杂结构，这里不讨论。</p></blockquote><h2 id="TTY-与-进程"><a href="#TTY-与-进程" class="headerlink" title="TTY 与 进程"></a>TTY 与 进程</h2><p>了解了 <code>TTY</code> 的发展和构成，那么 process 是如何和 PTY 对接的呢？为了讨论这个问题，我们需要复习一些进程、shell job control 的知识。</p><h3 id="补充-1：Unix-Processes"><a href="#补充-1：Unix-Processes" class="headerlink" title="补充 1：Unix Processes"></a>补充 1：Unix Processes</h3><p>大部分学过 CSAPP 的同学可能对进程已经有了初步了解，尤其是在考完了 ICS 之后对其理解更为深刻…… 不过 CSAPP 关于进程的知识并不是操作系统的全部，我们下面补充一点。</p><p>一个 Linux Process 通常有 <strong>5 种状态</strong>：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/process.png"></p><ul><li><p><code>R</code>：Running / Runnable（On OS run queue），此状态的进程正在 CPU 上运行，或者做好被 CPU 调度的一切准备；</p></li><li><p><code>D</code>：Uninterruptible sleep（waiting for some events），此状态的进程因为某些指令正在等待某些事件，大部分原因是 <strong>I/O 事件</strong>，通常不会被 CPU 调度；</p><blockquote><p>例如，程序执行到 <code>read</code> 等系统调用时，等待 I/O 设备触发 CPU 中断引脚；</p></blockquote></li><li><p><code>S</code>：Interruptible sleep（waiting for some events or signals），此状态的进程因为某些指令正在等待某些事件，或者等待某类信号，通常不会被 CPU 调度；</p><blockquote><p>例如，程序执行到 <code>pause</code>、<code>sleep</code> 等系统调用时，挂起等待信号 / 系统计时器中断；</p></blockquote></li><li><p><code>T</code>：Stopped，外部造成的暂停执行，只有 2 种可能：<strong>shell 的 job control signal，或者 debugger 断点</strong>；</p></li><li><p><code>Z</code>：Zombie，已经终止的子进程，但是父进程存在，并且没有回收它；</p></li></ul><p>进程组的知识不再赘述，与大家在 CSAPP 中接触到的一样。</p><h3 id="补充-2：Shell-Job-Control"><a href="#补充-2：Shell-Job-Control" class="headerlink" title="补充 2：Shell Job Control"></a>补充 2：Shell Job Control</h3><p>在 CSAPP 的 shell lab 中，我们进一步深化了对课本中 shell 的理解。通常情况下，一个 shell 承担了一个重要的工作：对用户的程序管理为 <strong>前台、后台</strong> 两种形式，方便用户指定和操作。这种管理方法就称为 <strong>job control</strong>。</p><p>正如 CSAPP 一书中对 job control 的说明，shell 的进程管理应该呈现如下的模式：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/process_group.png" height="300px"></p><p>当用户通过 shell 登陆，或者仅启动 shell 时，shell 作为系统中的一个进程，会单独设置自己的进程组（自己进程组号改为与自身进程号一致，防止与父进程联系，导致收到父进程的信号）；</p><p>此后，通过 shell 创建的所有进程（执行的所有程序）都会在 <code>execve</code> 前设置单独的进程组号，方便 shell 统一管理。前台、后台进程的子进程一般都在自己的进程组里。其中前台进程只有一个，后台进程有多个。</p><p>但是！CSAPP 中没有说明的一点是，<strong>前台进程是如何与用户输入建立联系的？更准确地说，前台进程如何准确 attach 到当前的 pseudo terminal 上的？</strong></p><h3 id="补充-3：Shell-Sessions（重要）"><a href="#补充-3：Shell-Sessions（重要）" class="headerlink" title="补充 3：Shell Sessions（重要）"></a>补充 3：Shell Sessions（重要）</h3><p>实际上，Linux 上除了进程、进程组，还有一个重要的机制 <strong>会话（Session，其实 Windows 上也有）</strong>。对应的，每个进程也有一个 session ID（<code>sid</code>），其机制如下：</p><ul><li><p>一个 <code>session</code> 一般包含了多个进程，不过其中有且仅有一个进程是特殊的，被称为 <strong>session leader</strong>，它一般是创建这个 session 的进程；</p><blockquote><p>注：Session Leader 可以在进程信息中看到。</p><p>大家不妨运行 <code>ps aux</code> 查看一下当前进程的状况，比如：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/ps.jpg" height="300px"></p><p>中间红框的一列描述的就是各个进程的状态。其中可能出现的 <code>D</code>、<code>R</code>、<code>S</code>、<code>T</code>、<code>Z</code> 称为 <strong>标识符</strong>，就是之前介绍的含义。还有一类标识符 <code>I</code> 表示 Idle Kernel Thread（空闲的内核线程）<sup><a href="#fn_4" id="reffn_4">4</a></sup>；</p><p>不过除此以外还有一些修饰符，例如：</p><ul><li><code>&lt;</code> 表示该进程的优先级较高（一般是 <code>root</code> 用户指定）；</li><li><code>N</code> 表示该进程优先级较低（一般是普通用户创建，并且主动 Sleep 的时间很长）；</li><li><code>s</code>（小写）<strong>表示该进程为 session leader</strong>；</li><li><code>l</code> 表示该进程中的程序是多线程的；</li><li><code>+</code> <strong>表示该进程在 shell 指定的前台进程组（foreground process group）中</strong>；</li></ul></blockquote></li><li><p>每个新创建的进程的 <code>sid</code> 与父进程相同（<strong>与父进程共用一个 session</strong>）；</p></li><li><p>一个 pseudo terminal 只能与一个 session 建立联系；与当前 <code>pty</code> 建立联系的 session 中，只有 session leader 有权控制 <code>pty</code> 和 session 的联系；</p><blockquote><p>这里的 “联系” 需要开发者（例如 shell 开发者）<strong>显式提醒 <code>TTY driver</code> foreground process group 的 group id</strong> 才能完成。<strong>使用系统调用 <code>tcsetpgrp</code></strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set the specific process group as the foreground process group. */</span></span><br><span class="line"><span class="comment">/* `fd` must be the controlling terminal of the calling process,</span></span><br><span class="line"><span class="comment"> * and still be associated with its session. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcsetpgrp</span><span class="params">(<span class="type">int</span> fd, <span class="type">pid_t</span> pgrp)</span>;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>如果 <strong>后台进程组的程序想要读 <code>stdin</code> 或写 <code>stdout</code></strong>（指向当前 session 对应的 <code>pty</code>），那么 OS Kernel 会向该进程发送 <code>SIGTTIN / SIGTTOU</code> 信号（default action 是终止进程），要求该后台进程等待；</p><blockquote><p>某些情况下，即便是后台进程组也可以直接向当前 session 写，例如在终端上执行命令： <code>echo Hello &amp;</code>，则会直接打印内容。</p><p>这与终端的设定有关。首先 OS 和 <code>TTY device</code> 的设计者们意识到以下的用户需求：</p><ol><li>用户<strong>不希望</strong>后台进程读取当前 terminal 的输入；</li><li>用户<strong>可能允许</strong>后台进程向当前 terminal 输出；</li><li>用户<strong>可能不希望</strong>后台进程更改当前 terminal 的设置（包括串口比特率、line discipline、输出策略等等）；</li></ol><p>因此针对以上需求，设计者们设定：</p><ol><li><strong>OS 不允许后台进程从当前 <code>pty</code> 读入，kernel 一定会对调用读入操作的进程发送 <code>SIGTTIN</code> 信号</strong>；</li><li><strong>OS 默认允许后台进程向当前 <code>pty</code> 输出。允许用户修改这一行为</strong>；</li><li><strong>OS 默认不允许后台进程修改当前 <code>pty</code> 设置，kernel 一定会对该进程发送 <code>SIGTTOU</code> 信号</strong>；</li></ol><p>另外补充一句，用户可以通过 <code>stty</code> 指令来查看、修改当前终端设置。例如：</p><ul><li><code>stty [-a/--all]</code>：打印当前终端设置；</li><li><code>stty tostop/-tostop</code>：设置<strong>不允许 / 允许后台进程向当前 <code>pty</code> 输出</strong>，默认允许；</li></ul></blockquote></li></ul><p>到这里，我们终于能够解释文章一开始的问题了——为什么 <code>tsh</code> 中运行 <code>vim</code>，<code>vim</code> 会收到 <code>SIGTTOU</code> 了。这是因为 <strong>CSAPP 的 shell lab 对 “前台进程” 的处理方式有问题，它没有真正将要在前台执行的进程加入前台进程组</strong>。</p><h3 id="Conclusion-TTY-amp-Process-with-SIGNALs"><a href="#Conclusion-TTY-amp-Process-with-SIGNALs" class="headerlink" title="Conclusion: TTY &amp; Process with SIGNALs"></a>Conclusion: TTY &amp; Process with SIGNALs</h3><p>现在，所有必须的知识已经集齐了，我们来看看 <code>TTY</code> 与进程交互的总体机制。</p><p>之前提到过 Unix 中的一切 I/O 设备都被抽象为 Unix files，这也包括 TTY device。与其他文件一样，一个进程想要进行读写前必须进行一些初始化操作，这个初始化就要求进程与内核间通信，所以<strong>信号</strong>是不可避免的。</p><blockquote><p>Tips. 在 <code>ioctl</code> C 库中含有许多与 <code>TTY</code> 设备读写相关的操作。</p></blockquote><p>我们以涉及修改 <code>pty</code> 设置的一串动作来举个例子。</p><p><strong>step 1.</strong> 假设你在一个 login shell 中执行 <code>vim</code>，那么：</p><p>当前 shell 为 <code>vim</code> 创建一个进程（<code>fork &amp; execve</code>）和进程组（<code>setgid</code>），通知 <code>TTY device</code> 将该进程标记为前台进程组（<code>tcsetpgrp</code>）；</p><p>所以你会看到如下图，启动 <code>vim</code> 后，<code>vim</code> 进程所在组成为 foreground process group（进程状态 <code>S+</code>）；而 shell（这里是 <code>zsh</code>）进程则由 <code>Ss+</code> 转为 <code>Ss</code>（不再是前台进程，但仍是 session leader），并且它们都位于同一个 session 中（指向同一个 <code>pts</code>，即 <code>pts/1</code>）：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/vim.png" height="350px"></p><p><strong>step 2.</strong> 假设你在 <code>vim</code> 运行时按下 <code>Ctrl + Z</code> 将 <code>vim</code> 转向后台挂起，那么：</p><p>触发 Asynchronous Exception（ECF），<code>vim</code> 作为前台进程组直接收到 OS Kernel 发送的 <code>SIGTSTP</code> 信号。在 <code>vim</code> 的 <code>SIGTSTP</code> signal handler 中，<code>vim</code> 做挂起前的准备工作（例如通过向 <code>TTY device</code> 输出特定序列，将光标移动到上次位置、恢复打开前的命令行内容等等）。最后 <code>vim</code> 向自己进程组发送 <code>SIGSTOP</code>，正式将自己的进程组挂起到后台；</p><p>此时，<code>vim</code> 父进程（之前的 shell）收到 <code>SIGCHLD</code> 信号，shell 进入对应的 handler 进行处理（例如打印 <code>[1]+ Stopped</code> 信息给用户等工作），并且将自己的进程设置为前台进程组（<code>tcsetpgrp</code>）；</p><blockquote><p><strong>这个时候，如果你试图以后台形式运行 <code>vim</code>（例如 <code>bg</code>），那么 <code>vim</code> 会收到 kernel 的 <code>SIGTTOU</code> 信号，继续挂起</strong>（因为 <code>vim</code> 会更改终端设置，例如 line discipline 等等）；</p></blockquote><p><strong>step 3.</strong> 假设此时你使用 <code>fg</code> 将 <code>vim</code> 转到前台继续执行，那么：</p><p>shell 会恢复上一次的 <code>pty</code> 设置、通知 <code>TTY device</code> 当前的前台进程为 <code>vim</code> 所在进程、向 <code>vim</code> 进程发送 <code>SIGCONT</code> 继续。于是 <code>vim</code> 恢复运行、重绘界面；</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>当然，<code>TTY device</code> 在与进程交互时，还有更多可用的操作和行为，例如 flow control、blocking I/O，以及文中没有详细介绍的 <code>pty</code> 终端设置，等等。感兴趣的童鞋可以查阅 Linux 的官方文档、本文所引用的参考资料，或者是 man 文档。更多问题或勘误欢迎交流 ~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>:<a href="https://en.wikipedia.org/wiki/Ticker_tape">Ticker tape - Wikipedia</a><br><sup><a href="#fn_2" id="reffn_2">2</a></sup>: <a href="https://en.wikipedia.org/wiki/Batch_processing">Batch processing - Wikipedia</a><br><sup><a href="#fn_3" id="reffn_3">3</a></sup>: <a href="https://www.linusakesson.net/programming/tty/">The TTY demystified (linusakesson.net)</a></p><p><sup><a href="#fn_4" id="reffn_4">4</a></sup>:<a href="https://stackoverflow.com/questions/14315923/why-does-linux-kernel-need-idle-thread">smp - Why does linux kernel need idle thread? - Stack Overflow</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;References: 参考文献见文章末尾。&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
    <category term="Linux" scheme="https://sjtuxhw.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>放假！吐槽！</title>
    <link href="https://sjtuxhw.top/2024/01/13/%E6%94%BE%E5%81%87%EF%BC%81%E5%90%90%E6%A7%BD%EF%BC%81/"/>
    <id>https://sjtuxhw.top/2024/01/13/%E6%94%BE%E5%81%87%EF%BC%81%E5%90%90%E6%A7%BD%EF%BC%81/</id>
    <published>2024-01-13T06:33:01.000Z</published>
    <updated>2024-01-15T13:38:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hooray"><a href="#Hooray" class="headerlink" title="Hooray !"></a>Hooray !</h2><p>家人们，经历了大半个月的期末周，终于来到假期了！我又活过来了😭 上个学期的时间安排实在是不太充裕，我想我得调整下节奏了🤔</p><h2 id="ツッコミ"><a href="#ツッコミ" class="headerlink" title="ツッコミ"></a>ツッコミ</h2><p>吐槽一下，在准备考试的时候，我和同学们为了分数反复写一些固定的题型，尤其是物理题。不是说我们不应该做物理题，而是这样的做法时间利用的效率真的不高。</p><p>之前看到过一篇文章说的感觉挺有道理的。我们常常听一些教育专家说，现在的学生要全面培养学科交叉能力，我无比赞同这句话，毕竟学科交叉既能开阔我们的专业视野，了解到很多其他方面的学识，又能提升我们的综合素质和学术能力，这是毋庸置疑的。</p><p>另一方面，我认为这个学科交叉是需要说明限度和范围的，而不是学科课表的 “自由组合”。以工科类专业举例，很多人会想，工科嘛，那不得来一整套大学物理，一直学到量子力学，加一点 “金课”，再加五花八门的大学物理实验；末了，再添一点理论力学、甚至大学化学，entitled “学科交叉素养的培养”。</p><p>这个本意是好的，但：每当我看到有些工科同学（惭愧地说，包括笔者）拿着学长学姐留下的 “报告模板”，花一大把时间在大物实验报告上，然后上交后再忘得一干二净，<strong>从此再也不会接触到它</strong>；每当我看到工科同学为了应对课时日益增加的大学物理、应对挖空心思出难题怪题只为<strong>正态成绩分布</strong>的教员们，拼命做题、掌握甚至背诵解题技巧的时候，我的心中总是有种奇怪的滋味。</p><p>也许我们没法改变，那么就要去适应游戏规则。尽管别人告诉你，“哎，大学物理实验能培养你的动手实践能力和写报告的水平，和你的主课一样重要”，你也一定要拎清楚主次，将 “dirty work” 和正常工作 “区别对待”。</p><p>打个不恰当的比方，有人说 “扫一下午大街” 和 “背诵一个下午英语单词” 一样重要，前者锻炼了你的劳动素养，后者增长了你的学术水平，咱不是要全面发展嘛。听起来好像做这两件事各有好处，难以取舍。实际上我们用常识想一想，作为一个学生，肯定很少有人会选择前者来消磨下午的时光。</p><p><strong>因为这并不是这两件事本身的价值孰优孰劣的问题，这是二者谁能为现在的我们提供更大的效益的个体问题。</strong></p><p>“今当远离，临表涕零，不知所言” 🤭。</p><hr><p>吐槽归吐槽，生活还是要继续。最后，终于可以自由地做自己的事情，停更许久的博客也终于可以继续更新了……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hooray&quot;&gt;&lt;a href=&quot;#Hooray&quot; class=&quot;headerlink&quot; title=&quot;Hooray !&quot;&gt;&lt;/a&gt;Hooray !&lt;/h2&gt;&lt;p&gt;家人们，经历了大半个月的期末周，终于来到假期了！我又活过来了😭 上个学期的时间安排实在是不太充裕，</summary>
      
    
    
    
    <category term="Chat" scheme="https://sjtuxhw.top/categories/Chat/"/>
    
    
    <category term="tease" scheme="https://sjtuxhw.top/tags/tease/"/>
    
    <category term="holiday" scheme="https://sjtuxhw.top/tags/holiday/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Notes Part 2</title>
    <link href="https://sjtuxhw.top/2023/11/11/CSAPP-Notes-Part-2/"/>
    <id>https://sjtuxhw.top/2023/11/11/CSAPP-Notes-Part-2/</id>
    <published>2023-11-11T01:18:11.000Z</published>
    <updated>2023-12-10T01:36:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter-8-The-Memory-Hierarchy"><a href="#Chapter-8-The-Memory-Hierarchy" class="headerlink" title="Chapter 8. The Memory Hierarchy"></a>Chapter 8. The Memory Hierarchy</h2><blockquote><p>本章将介绍系统的内存分层架构。</p></blockquote><p>之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。</p><p>正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。</p><h3 id="8-1-Storage-Technologies-amp-Trends"><a href="#8-1-Storage-Technologies-amp-Trends" class="headerlink" title="8.1 Storage Technologies &amp; Trends"></a>8.1 Storage Technologies &amp; Trends</h3><p>在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。</p><h4 id="8-1-1-Random-Access-Memory-RAM"><a href="#8-1-1-Random-Access-Memory-RAM" class="headerlink" title="8.1.1 Random-Access Memory (RAM)"></a>8.1.1 Random-Access Memory (RAM)</h4><p>当前大多数人所熟知的 “内存” 的一部分就是<strong>随机访问存储器（RAM）</strong>，它具有以下的特征：</p><ul><li><p>RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；</p></li><li><p>RAM 常常被打包放在 CPU 芯片中；</p></li><li><p>RAM 中每一个基本的存储单元被称为 <strong>单元胞</strong>（Cell），一个单元胞中存放 1 bit 数据；</p></li><li><p>很多个 RAM 芯片共同工作，组成了计算机的 <strong>主存</strong>（主存储器）。</p></li><li><p>RAM 分为 2 类，它们之间<strong>根据存储单元胞的实现方式来区分</strong>：</p><ul><li>SRAM（Static RAM），静态随机存储器；</li><li>DRAM（Dynamic RAM），动态随机存储器；</li></ul><table>    <tr>        <td></td>        <td>Trans. per bit</td>        <td>Access time</td>        <td>Needs refresh?</td>        <td>Needs EDC?</td>        <td>Cost</td>        <td>Applications</td>    </tr>    <tr>        <td>SRAM</td>        <td>4 or 6</td>        <td>1 ×</td>        <td>No</td>        <td>Maybe</td>        <td>100 ×</td>        <td>Cache Memories</td>    </tr>    <tr>        <td>DRAM</td>        <td>1</td>        <td>10 ×</td>        <td>Yes</td>        <td>Yes</td>        <td>1 ×</td>        <td>Main memories, frame buffers</td>    </tr></table></li></ul><blockquote><p>注：<code>Trans. per bit</code> 表示每 bit 需要多少根晶体管，<code>EDC</code> 指电子数据捕获。</p><p>从上面这张表可以得知，SRAM 比 DRAM 成本高很多，因为 SRAM 的每个储存单元胞都更加复杂。正因如此，SRAM 的访问速度远远快于 DRAM，因此常被用在 Cache Memories（高速缓存器）中（成本也是高速缓存通常大小比较小的原因之一）。</p><p><strong>Needs EDC</strong> 的含义是指，必须用一定的电压作用在存储单元胞的两端，否则一断电就会丢失电荷，数据也会丢失（<strong>又称 Volatile Memories</strong>）。这也是 RAM 需要插电用的原因（当然，如果把它从电源上拔下后迅速扔进液氮中，可以保留其中数据，因为电荷散失速度可以忽略）。</p><p>DRAM 被广泛应用于主存、图形显卡的 <strong>帧缓存（frame buffer）</strong>中。</p></blockquote><h4 id="8-1-2-Nonvolatile-Memories"><a href="#8-1-2-Nonvolatile-Memories" class="headerlink" title="8.1.2 Nonvolatile Memories"></a>8.1.2 Nonvolatile Memories</h4><p><strong>ROMs</strong></p><p>除了 RAM，计算机存储系统中另一类存储器是 <strong>非易失性存储器</strong>，它们在计算机断电后仍然能保存数据。请回忆数电中介绍的几种电子元件：</p><ul><li><strong>ROM</strong>（Read-Only Memory，只读存储器），出厂时就编程完成，通常电路烧在板子上不可更改；</li><li><strong>PROM</strong>（Programmable ROM，可编程只读存储器），只能对电路编程一遍；</li><li><strong>EPROM</strong>（Erasable PROM，可清除可编程只读存储器），可以被特殊作用清除电路信息（UV / X-rays）；</li><li><strong>EEPROM</strong>（Electrically Erasable PROM，电驱动可清除可编程只读存储器），可以使用电路、电子清除其中信息，但只能反复清除重写 100,000 次。</li></ul><blockquote><p>它们的电路结构想必各位脑海中都非常清楚对吧？</p></blockquote><p>其中，大家所熟知的 <strong>闪存（Flash Memory）</strong>，就是许多 EEPROM 元件组成的。</p><blockquote><p>Tips. 计算机存储系统中的<strong>主存</strong>包括了 <strong>ROM 和 RAM</strong>，但闪存作为 ROM 的一种，<strong>也是现代最常用的 ROM</strong>，也可以和机械硬盘一起被用在<strong>外存</strong>中。</p></blockquote><p>这些 ROM 的作用很广泛，主要有以下几个方面：</p><ul><li>普通 ROM <strong>常被用作重要的、不应该被更改的数据的存储</strong>，例如 BIOS（存储计算机系统启动时的指令 + boot 引导程序）、Controllers for disks（硬盘控制器）、Network Cards（网卡）、Graphics accelerator（图形加速器）、Security subsystem（安全子系统）；</li><li>它们（闪存）还会被用在 <strong>固态硬盘</strong>（SSD，Solid State Disk，代替转圈易坏的机械硬盘，用在笔记本电脑、手机、mp3 播放器、平板等设备，系统会把 SSD 看成机械硬盘）中；</li></ul><p><strong>机械硬盘</strong></p><p>除了 ROM 一类的非易失性存储器，还有 <strong>外存</strong>（外部存储器）也是非易失性存储器。我们这里介绍有代表性的机械硬盘：</p><ul><li><p>结构包括传动臂、SCSI 连接口、盘片、盘片轴……</p></li><li><p>硬盘中包含一系列盘片（platter），每个盘片有两个面，每个面上涂有磁性材料，并且存在一圈圈同心圆（concentric rings），被称为 <strong>磁道（tracks）</strong>，每个磁道包含若干 <strong>扇区（sectors）</strong>，扇区之间会有空隙间隔（gaps），<strong>一个扇区通常的大小是 512 bytes</strong>；</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/disk_geometry.png" height="240px"></p><p>盘片轴（spindle）连接一系列盘片，<strong>每个盘片相同位置对齐的磁道称为 Aligned tracks，在垂直方向组成一个圆柱</strong>，这个相同位置的磁道所组成的元素称为 <strong>柱面</strong>，数据按照不同柱面进行存储，同一柱面的数据连续（为啥按柱面存？因为方便机械臂访问）。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/disk_geometry_multi_platter.png" height="240px"></p></li><li><p>传动臂悬浮在盘片上方，隔着一层薄薄的空气。其末端读写头可以感知编码位的磁场变化；</p></li><li><p>机械磁盘内置电子设备，用于控制传动臂的移动等操作，其驱动程序一般存于 ROM 中；</p></li><li><p>机械性质决定了机械硬盘的读写速率慢于 RAM 和 ROM；</p></li><li><p>硬盘承载量取决于 <strong>数据记录密度（recording density，1 inch 磁道段中能存放多少 bit 信息）、磁道密度（track density）、面密度（Areal density，前面二者的乘积）</strong>；</p></li></ul><blockquote><p>⚠ 易错点警告：对于硬盘来说，它的承载量单位 GB 是特殊的：<strong>1 GB = $10^9$ Bytes</strong>，这与之前我们见到的衡量二进制数据大小的单位 GiB（<strong>其简称也叫 GB，1 GiB = $2^{30}$ Bytes</strong>）是不一样的。</p><p>这么说就明白了：<strong>承载量单位应该分开来看</strong>：1 G | B，1 吉 (Giga) = $10^9$；</p><p>而<strong>衡量二进制数据大小的单位是个整体</strong>： 1 | GiB，GiB 本身是 gibibyte（giga-binary byte），是 byte 单位的 $2^{30}$ 倍；</p><p>最常见的是计网的考题：<strong>1 MB/s 在 1 s 内传输的数据量略小于 1 MB</strong>，因为承载量速率单位 1 MB/s 是 $10^6$ Bytes / s，而数据大小 1 MiB 是 $2^{20}=1024^2$ Bytes；</p></blockquote><ul><li><p>在很早以前的机械硬盘中，每个磁道的扇区数目固定，这会导致大量的空间浪费。所以现代的机械磁盘<strong>将许多磁道划分为一个个不相交子集，称为记录区（recording zones）</strong>：</p><ul><li>每个处于同一记录区中的磁道含有相同的扇区数，它取决于最内侧磁道；</li><li>每个记录区中的磁道的扇区数不同，越靠近内圈的记录区中磁道的扇区数越少；</li><li><strong>因此我们使用平均扇区数 / 磁道数来计算承载量</strong>；</li></ul><p>如下图，阴影部分为一个记录区，含有许多扇区数相同的磁道：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/recording_zone.png" height="200px"></p><blockquote><p>题型：计算磁盘承载量</p><p><strong>承载量 = 每个扇区的 byte 数（通常 512 bytes）× 一个磁道中平均扇区数 × 一个盘面中的磁道数 × 一个盘片上表面数目（对三维生物来说=2）× 每个磁盘的盘片数</strong>；</p></blockquote></li><li><p>机械硬盘借助悬浮在盘面上方的传动臂进行读取，许多传动臂在磁盘同一半径处读写，其搜索读取读取速度取决于三个因素：<strong>寻道时间（一般最长，大约 3~9 ms）、旋转延迟、传输时间</strong>。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/disk_op.png" height="200px"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/disk_access_time.png" height="200px"></p></li><li><p>关于数据访问的耗时，有一些数字可以了解一下：</p><ul><li><p>一般情况下机械硬盘的 <strong>寻道时间 &gt; 旋转延迟 ≈ 4 ms &gt;&gt; 传输时间</strong>；</p><blockquote><p>机械硬盘访问扇区的第一个 bit 耗时最多，其他几乎不耗时；</p></blockquote></li><li><p>SRAM 访问 8 bytes 数据平均需要 4 ns，DRAM 需要 60 ns，<strong>而机械磁盘比 SRAM 慢 40000 倍，比 DRAM 慢 2500 倍</strong>；</p></li></ul></li><li><p>硬盘（机械 / SSD）的<strong>逻辑块（Logical Disk Blocks）</strong>：现代硬盘提供了一个面向 CPU 的更简单的抽象。硬盘的可用扇区被抽象为一组 b-sized 的逻辑块（编号从 0 开始）；</p><ul><li><p>每个逻辑块是<strong>扇区大小的整数倍</strong>（跳过 gaps），最简单的情况下，一个逻辑块就是一个扇区；</p></li><li><p>磁盘控制器来保持从物理扇区到逻辑块之间的<strong>映射</strong>（间接层面、抽象层面）；</p><blockquote><p>这允许磁盘控制器保留一部分 <strong>柱面</strong>（前面提到的存储信息按照同心磁道组成的柱面） 不进行映射，作为 <strong>备用柱面</strong>。</p><p>当某一柱面上的一个扇区损坏，那么磁盘控制器可以直接将数据复制到备用柱面，然后磁盘就能继续正常工作。</p><p><strong>这就是为什么磁盘的 “格式容量”（formatted capacity）比实际容量小</strong>。</p></blockquote></li></ul></li></ul><p><strong>固态硬盘</strong></p><p>固态硬盘作为一种更新的、用来代替机械磁盘的外存形式，其控制器接口和机械磁盘一样，所以 CPU 一视同仁，不过它的速度介于 DRAM 和 机械硬盘之间。</p><p>其内部<strong>全部由闪存构建</strong>，并且由一个固件（firmware）称为闪存翻译层（<strong>flash translation layer</strong>）充当控制器（其作用和机械硬盘的磁盘控制器相当）；</p><p>数据在 SSD 中是以 <strong>页（page）</strong> 为单位从闪存中读取和写入的。页的大小 512 KB ~ 4 KB，块（block，和之前提到的 CPU 所认为的逻辑块<strong>不同</strong>，下面解释）一般包含 32 ~ 128 页，<strong>取决于 SSD 实现的技术</strong>；</p><blockquote><p>这里所说的 “块” 为啥和之前的 “逻辑块” 不同？</p><p>首先明确，这是个术语重叠的现象。这里的 SSD 中的 “块” 是闪存的性质导致的。目前技术下闪存的数据擦除是<strong>成块成块擦除</strong>，这意味着一次会同时擦除多个页。因此，人们把<strong>闪存一次擦除的一组页集合称为 “块”</strong>。</p><p>因此，想要修改某个块中的某个页，需要 <strong>将该块全部擦除（之前应该复制到其他位置）</strong> / <strong>找到一个已被擦除的块</strong> 才能写入；</p><p>现代的闪存翻译层中实现了很多专有算法，能够延长 SSD 的使用寿命，例如缓存技术。</p></blockquote><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/ssd_struct.png" height=240></p><p>固态硬盘的读写效率大致是 <strong>随机访问 300 MB/s 左右，顺序访问 500 MB/s 左右</strong>（Intel SSD 730 的数据），可以说<strong>在计算机的存储系统的层次结构中，随机访问总是比顺序访问更耗时</strong>。其中 SSD 写入速度都略低于读取速度，这是因为闪存写入前需要擦除原先数据。总的来说，SSD 的访问速度大约比机械硬盘快 10 倍左右。</p><p>其实，SSD 和机械硬盘各有优劣，相较于机械硬盘，SSD 具有以下特征：</p><ul><li>（优势）没有机械移动，更快、耗能更低、更结实（较不易摔坏），适合用在便携设备中；</li><li>（劣势）可能磨损，但问题不大，一般生命周期中可以写 100 PB+ 的数据（足够用多年）；</li></ul><p>最后看一下各种存储介质和 CPU 时钟频率的关系：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/CPU_memory_gap.png" height="400px"></p><blockquote><p>2003 年，CPU 设计达到性能能源瓶颈，其发展从增大时钟频率转向增大 CPU 内核数。</p></blockquote><h4 id="8-1-3-Traditional-Bus-Structure-Connecting-CPU-and-Memory"><a href="#8-1-3-Traditional-Bus-Structure-Connecting-CPU-and-Memory" class="headerlink" title="8.1.3 Traditional Bus Structure Connecting CPU and Memory"></a>8.1.3 Traditional Bus Structure Connecting CPU and Memory</h4><p>说完计算机存储系统的硬件，那么它们是怎么与 CPU 建立连接，进而抽象出 “内存空间” 和 “存储空间” 的呢？</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/io_bus.png" width="600px"></p><blockquote><p>其中 I/O 桥是另外的一些芯片组，另一些芯片的集合。</p></blockquote><p><strong>CPU 访问主存</strong></p><p>上面的图仅仅是比较简单粗略的抽象，不要较真。在比较老的计算机架构中（因为现代系统有专有的总线设计，非常复杂），采用 <strong>总线（bus）</strong>来连接 CPU 和主存的，数据通过总线在主存和 CPU 间来回传输。<strong>并且总线通常与其他多种设备共享</strong>。</p><p>正常情况下，CPU 中的 ALU 根据汇编机器指令只需访问最近的寄存器就行；如果指令要求它访问内存，那么 ALU 会交由总线接口（Bus Interface）去从主存中取出相应位置的数据。</p><p>大家可以思考一下，在上面这幅图中，<code>movq %rax, $A</code> （A 为内存地址）和 <code>movq $A, %rax</code> 应该如何形象表示？</p><p>大家不难发现，<strong>寄存器离 CPU 很近，所以访问速度很快</strong>，通常在 3 个时钟周期左右就能读写到值。但是内存（图中 Memory Devices 芯片组）离 CPU 相当远，中间的步骤相当多，所以<strong>对内存读写所消耗的时间大约是对寄存器读写耗时的 100 倍左右</strong>。这就是计算机内存系统引入所发现的其中一个性能损耗。</p><p><strong>CPU 访问外部设备（以外存: 磁盘为例）</strong></p><p>再来看 I/O 总线（I/O Bus），它将各个设备与 I/O 桥连接，<strong>使得外部设备能和主存一样被 CPU 访问</strong>。I/O Bus 看起来是一条线，可实际不是如此。因为在老式的计算机中，它被称为 PCI 总线（广播总线），主干连接到各个设备，任何设备只要更改其上的数据，其他设备就能发现。</p><p>但现代的 I/O 总线并不是一条线了，它采用了 PCI Express 的总线结构，并不像上面画的一样，它是 <strong>点对点地连接两个设备</strong>，实现不同（我们不会深入讨论），但提供的功能就像图上画的一样。所以可以把 I/O Bus 看作一组电子线路即可。</p><p>其中 Disk、Mouse、Keyboard、Monitor 等设备使用细双箭头，表示它们不是焊在主板上，而是插入主板上的控制器（adapter、controller）来连接。</p><p>考虑如果 CPU 想要访问某个磁盘设备的某个扇区，那么会进行如下步骤：</p><ul><li>CPU 生成一个三元组（triple）：<strong>指令</strong>（read / write）、<strong>逻辑块编号</strong>、该块中的数据要放到哪个<strong>内存地址</strong>中（CPU 先从磁盘读入内存，再从内存读入 CPU 寄存器，反方向亦然），并且当前线程的程序暂停执行（如果是 I/O 阻塞的话），等待数据传输；</li><li>三元组通过总线接口、I / O 桥、I / O 总线传给磁盘控制器；</li><li>磁盘控制器通过读取与该逻辑块对应的任何扇区（一个逻辑块可能包含很多扇区）读入磁盘缓存；</li><li>磁盘控制器取得总线控制权，并且<strong>将数据通过 I/O 总线、I/O 桥和内存总线直接送往指定内存地址，而无需将数据传给 CPU</strong>；</li><li>数据传输结束后，磁盘控制器借助 “I/O 总线 - I/O 桥” 从<strong>新的通路</strong>（不经过总线接口）直接用电信号触发 CPU 的某个<strong>引脚</strong>，这个信号代表一种<strong>中断（interrupt）</strong>，通知 CPU 该扇区已被复制，此时暂停的程序继续执行；</li></ul><h3 id="8-2-Locality"><a href="#8-2-Locality" class="headerlink" title="8.2 Locality"></a>8.2 Locality</h3><p>无论是 8.1.2 中介绍的各自存储介质在物理层面上的性能约束，还是 8.1.3 中介绍的数据读取流程上的性能限制，都是计算机存储系统需要解决的重要问题，否则，在硬件上计算机就难以继续提升运行速度了。</p><p>其实，弥补 CPU 和内外存读写速率之间差距的机制之一就是<strong>程序的基本属性之一：局部性（locality）</strong>。</p><p>局部性原则：程序倾向于使用 “<strong>内存地址接近或等于最近使用过的数据/指令地址的</strong>” 那些数据和指令。</p><blockquote><p>原文：Programs tend to use data and instructions with addresses near or equal to those they have used recently.</p></blockquote><p>这个原则来源于程序编写的逻辑——<strong>当程序访问到某个内存地址上的数据，那么在不久的将来，有很大的可能程序会访问该数据项或者附近的数据项</strong>。</p><p>这种局部性有两种表现形式：</p><ul><li><p>时间局部性（Temporal Locality）：最近引用的存储器位置可能在不久的将来再次被引用；</p></li><li><p>空间局部性（Spatial Locality）：如果访问了一个存储器的位置，那么有很大可能在将来会访问一个临近的位置；</p></li></ul><blockquote><p>例子：识别代码中的局部性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> sum += a[i];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure><p>这串代码中，有对<strong>数据的引用</strong>（Data references，转为汇编后会引用数据，通常只要有变量就有数据的引用）。</p><p>例如上面的数组 <code>a</code>，其元素在内存上连续，索引 i 每自增一个单位就访问一下（称为 stride-1 reference pattern），属于空间局部性；上面的变量 <code>sum</code> 在循环的每次迭代中都会被引用，属于时间局部性；</p><p>还有对<strong>指令的引用（Instruction references）</strong>，例如循环中每一次都会执行循环体的内容，属于时间局部性；再比如程序代码顺序执行，本身就属于空间局部性。</p></blockquote><p>不同编写方法的代码，其局部性不同。这就需要开发者训练观看的能力。举一个很简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array1</span><span class="params">(<span class="type">int</span> a[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_array2</span><span class="params">(<span class="type">int</span> a[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们考虑对数据的引用，<strong>回忆 6.1 中对于 Nested Array 的内存排列的知识</strong>，数组数据连续排列且<strong>行优先</strong>，所以我们发现，使用 <code>sum_array2</code> 方式遍历数组，其<strong>数据相距距离很远</strong>，这意味着程序的局部性差于 <code>sum_array1</code>。而事实上，<code>sum_array2</code> 也真的会比 <code>sum_array1</code> 慢一个数量级；</p><blockquote><p>例题：请修改以下代码，使得它满足 stride-1 reference pattern（即更优的程序局部性）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array_3d</span><span class="params">(<span class="type">int</span> a[M][N][N])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i, j, k, sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">     <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">         <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">             sum += a[k][i][j];</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="8-3-Conclusions-for-8-1-amp-8-2"><a href="#8-3-Conclusions-for-8-1-amp-8-2" class="headerlink" title="8.3 Conclusions for 8.1 &amp; 8.2"></a>8.3 Conclusions for 8.1 &amp; 8.2</h3><p>没错，前面两节全部在为存储系统的层次结构<strong>做准备</strong>，之后我们才开始正式讨论 Memory Hierarchy。在此之前，我们先小总结一下前面的内容。</p><p>在本章开始，我们认识了计算机存储系统在硬件层面的两大组成：主存和外存。主存由 RAM（又分为 SRAM 和 DRAM）组成；外存则是硬盘（又分为机械硬盘、SSD）、可移动磁盘为主。</p><blockquote><p>广义的内存包括：主存（RAM）、全部 ROM、Cache（高速缓存存储器）；</p></blockquote><p>我们紧接着比较了 SRAM 和 DRAM 的特征、异同，以及它们所使用的场合；对于 ROM，我们了解了不同的 ROM 类型，还有闪存的定义。</p><p>在外存方面，我们详细介绍了机械磁盘的物理结构（磁盘控制器、盘面、柱面、磁道、扇区、记录区、承载量计算、访问耗时分析、逻辑块），并类比出功能相同、实现不同的固态硬盘物理结构（闪存翻译层、页、块）。</p><p>于是，我们从上面存储介质的物理结构中分析并得出 <strong>其数据访问模式的性能限制和优劣</strong>。</p><p>最后，我们分析了 <strong>CPU 访问主存</strong> 和 <strong>CPU 访问外存</strong> 的情况和流程，从中我们得知了在内存读取的流程中也存在着性能的限制或者说损失。</p><p>基于这些物理结构的限制，我们讨论出代码结构层面能够在一定程度上弥补这些性能鸿沟的性质：<strong>局部性</strong>。我们根据 <strong>存储设备的物理结构</strong> 和 <strong>数据存放的方式</strong>，可以设计写出更符合程序局部性的代码，这在一定程度上可以缓解 CPU 和内存之间访问的性能差距。</p><p>而观察代码的局部性，就需要对数据在内存中的 layout，还有储存设备的工作原理有一个很好的认识，这就是前几章、前几节的内容。</p><p><strong>这些存储介质的物理特性，和程序的局部性相辅相成，相得益彰，为人们提供一种 “怎样设计存储系统” 的建议和信息。</strong></p><p>接下来，我们将基于这些存储介质的物理性质，讨论在其上所建立的层次结构，和这些层次结构是如何抽象硬件，尽可能地为上层的计算机软件提供更连续完整的资源的。</p><h3 id="8-4-Memory-Hierarchy-amp-Idea-of-Caching"><a href="#8-4-Memory-Hierarchy-amp-Idea-of-Caching" class="headerlink" title="8.4 Memory Hierarchy &amp; Idea of Caching"></a>8.4 Memory Hierarchy &amp; Idea of Caching</h3><p>下图是计算机存储系统的一个层次结构图。</p><p>其中，寄存器是访问速度最快的存储结构，它在每个 CPU 时钟周期内都可以直接访问到（大小最小、数量很少、价格最贵、速度最快）；</p><p>接下来的是由 SRAM 组成的高速缓存存储器（Cache Memory），也处于 CPU 芯片内部，既不是主存，也不是寄存器；大小虽然是 MB 级，但已经比寄存器大多了。其中 3 层 Cache Memory 的具体结构将在下一章进行深入讨论；</p><p>再向下是 DRAM 组成的计算机的主存，一般你能看到的 “内存条” 就是它的组合结构，也是普通人经常说的 “内存”（狭义内存），一般从几个 G 到 几十 G 不等，程序运行内存（或者说后面要提到的<strong>虚拟内存</strong>）就是它的一部分；</p><p>最底层的像本地硬盘结构，甚至云端存储结构，空间一般都很大，但访问效率低下。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/memory_hierarchy_example.png" height="400px"></p><p><strong>设计的核心：在 Memory Hierarchy 中，每一层都包含着从下一层所检索的数据</strong>（例如 CPU 寄存器保存着从 L1 高速缓存中取出的数据，依此类推）；</p><p>这样设计的原因是为了充分利用各个层级资源的特征，将整体数据访问效率最大化（<strong>底层是极大的数据池，却能够以极快的速度进行访问</strong>）。</p><p>这么做之所以有效，是因为 <strong>缓存思想（Caching）的存在</strong>。</p><p>这里所说的缓存，<strong>不是高速缓存存储器（Cache memories），而是一种思想</strong>。<strong>作为一个更小、更快的存储设备，充当更慢设备中数据的暂存区域、能更快访问的数据子集</strong>。例如，主存 可以看成是本地硬盘的 缓存，这样一旦从磁盘获取数据，就无需在磁盘上访问它，在上一个层级内存中访问，速度得到提升。依此类推，<strong>缓存的思想在 Memory Hierarchy 中逐级传播</strong>。</p><blockquote><p>第 k 层更快、更小的存储设备，就是第 k+1 层更慢、更大存储设备的 缓存。</p></blockquote><p>在真实场景中，每当程序访问一个不在缓存设备（第 k 层）中的数据，都会从第 k+1 层检索，并复制到第 k 层缓存起来。这是因为，<strong>根据程序的局部性</strong>，相较于第 k+1 层的设备，会更经常访问第 k 层设备中的数据，这就是 Memory Hierarchy 能最大化数据访问效率的原因。</p><hr><p>在详细介绍高速缓存存储器（狭义的 Cache）前，我们简单介绍一下<strong>缓存的实现</strong>，因为缓存思想存在于存储层次结构的每一层。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/general_cache_concept.png" height="240px"></p><p>储存数据的下层设备的空间（k+1 层）通常被分为一个个固定大小的块（blocks），缓存设备和下层设备间传输的数据以块为单位进行。</p><blockquote><p>如果第 k+1 层是 Web 云端存储介质，那么 blocks 通常以文件形式传给磁盘（第 k 层，缓存设备）；</p><p>如果第 k+1 层是主存，那么 blocks 可能是以某个特定大小的数据块传给高速缓存存储器（第 k 层，缓存设备）；</p><p>……</p></blockquote><p>在任意时间点，第 k 层的缓存设备中的数据都是第 k+1 层设备数据的一个子集。</p><p>对于 CPU 请求一个位于第 k+1 层的某个位置的数据这种情况，则 CPU 会先去层级最高的设备中寻找（假设找到第 k 层），则有两种情况：</p><ul><li><p>如果恰好找到了（假设请求如下图绿色块 14 的数据），那么 CPU 就直接从缓存（第 k 层）中读走这个数据，无需向下请求数据，总体提升了效率。这种情况称为 <strong>Cache Hit</strong>（缓存命中）；</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/cache_hit.png" height="240px"></p></li><li><p>如果没有找到，那么 CPU 就需要从更下一层取得此数据块，并<strong>将它存放在缓存设备中</strong>。这种情况称为 <strong>Cache Miss</strong>（缓存不命中）；其本身又分为 3 个类型：</p><ul><li><p>Cold（compulsory）Miss：缓存为空，所以 Miss，不可避免；</p></li><li><p>Capacity Miss：由于较小的缓存空间而导致的不命中，通常是因为程序的工作集大于缓存空间所致。可以由增大缓存空间而减少；</p><blockquote><p>工作集（working set）：当前不断被程序访问的块，也即活跃的缓存块（active cache block）；</p></blockquote></li><li><p>Conflict Miss：由于大部分缓存设备（尤其硬件缓存）必须设计的比较简单，它限制了缓存块的放置位置（例如第 i 块必须放在 <code>i mod sizeof(Cache)</code> 的位置，很类似 hash table 的碰撞），这与缓存实现方式有关，也在下一章进一步讨论；</p></li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/cache_miss.png" height="240px"></p></li></ul><p>最后，我们总结一下缓存在存储系统各层级的实现情况：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/caching_in_hierarchy.png" height="400px"></p><blockquote><p>注：TLB（Translation Lookaside Buffer，后备缓冲）是一个在虚拟内存中使用的缓存，<strong>是虚拟地址翻译为物理地址的翻译过程的缓存</strong>；</p></blockquote><p>需要注意的是，<strong>各个层级的缓存究竟是由谁实现和管理的</strong>，这是缓存思想的一个重点，也能解释早在第 3 章的疑问——<strong>汇编代码中找不到管理高速缓存存储器的代码</strong> 的原因。</p><p>例如，当寄存器看作缓存设备时，是编译器决定用哪个寄存器、用多少个寄存器（怎么用的 conventions 是 ABI 决定的）；</p><p>综上，缓存思想存在于计算机系统的几乎每个用到数据 I/O 的地方。</p><p>下一章将讨论 Memory Hierarchy 中一个具体的部分 <strong>高速缓存存储器</strong>，来深入了解缓存思想。</p><h2 id="Chapter-9-Cache-Memories"><a href="#Chapter-9-Cache-Memories" class="headerlink" title="Chapter 9. Cache Memories"></a>Chapter 9. Cache Memories</h2><blockquote><p>本章讲述 Memory Hierarchy 缓存思想中的重要一个体现：高速缓存存储器（Cache memories），它介于寄存器和内存之间，充当缓存设备的角色。</p></blockquote><p>回忆上一章的内容，高速缓存器本质上是一种由 SRAM 组成的、由硬件直接管理的小型缓存存储设备：<strong>Cache memories are small, fast SRAM-based memories managed automatically in hardware</strong>.</p><p>它一般封装于 CPU 芯片中，几乎和寄存器距离 CPU 核心同样近（只是由于电路存取特性导致其慢于寄存器），存储主存中被频繁引用的数据块。</p><h3 id="9-1-General-Cache-Organization"><a href="#9-1-General-Cache-Organization" class="headerlink" title="9.1 General Cache Organization"></a>9.1 General Cache Organization</h3><p>那么硬件是如何管理高速缓存存储器中的数据，在 CPU 需要的时候进行寻找呢？我们首先需要借鉴<strong>层次架构中一般的缓存模型</strong>，它们共同有一种缓存的管理方式和 layout；</p><p>首先，缓存本身就需要极速，这意味着设计缓存机制必须<strong>以非常严格且简单的方式去组织缓存模型</strong>，便于各个设备层级间进行查找。于是人们设计了下面的缓存数据组织形式：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/general_cache_organization.png" height="350px"></p><p>缓存空间中一般包含 $S=2^s$ 个数据组（set），每一组又包含 $E=2^e$ 个数据行（line，图中<strong>横着排列</strong>），每一数据行由大小为 $B=2^b$ bytes（B binary digits）的数据区块和一个 tag 区、一个 valid bit 组成；现在解释一下目前可能有的疑惑：</p><ul><li>valid bit 指示当前缓存数据行中的数据实际上也真实存在于下层的存储介质中，可以直接使用（例如第一次打开机器的时候，这些数据区块位置上是随机 bits，因此这些 valid bit 会提示数据区块无效）；</li><li>tag 位（标记位）编码了这串数据位于下层存储介质的位置，在 CPU 搜索时有用；</li><li>为何无论是组数、数据行数还是每个数据行中的字节数都是 2 的幂次呢？<strong>这是一个非常重要的点。因为，缓存空间按照 内存地址的数码的各个位 来直接对应该内存数据应该存放的位置</strong>。这个比较抽象，后面的例子就会慢慢理解。</li></ul><h3 id="9-2-Read-Cache"><a href="#9-2-Read-Cache" class="headerlink" title="9.2 Read Cache"></a>9.2 Read Cache</h3><p>那么缓存是如何被读取的？详细数据结构（和具体存储设备有关）又是什么样子的？</p><p>实际上，程序在运行中可能请求了下层存储介质中某个位置的数据，我们<strong>以高速缓存存储器和主存间查找数据的关系为例</strong>。步骤如下：</p><ul><li>假设程序指令要求引用主存中虚拟内存的某个地址（设为 <code>X</code>）的数据，那么 CPU 会向高速缓存存储器请求 <code>X</code> 地址下的值；</li><li>这个请求的地址会被 高速缓存存储器 <strong>直接用来查找缓存存放的位置（即这个地址的数据存放在）</strong>。其中 <code>X</code> 会被 高速缓存存储器 <strong>解析成</strong>如下图所示的结构（<strong>这就是为什么上面的 <code>S</code>、<code>E</code>、<code>B</code> 都是 2 的幂</strong>。看着这张图你能想明白吗？还不能明白的话，后面会有更具体的例子）：</li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/addr_B.png" height="125px"></p><ul><li>高速缓存存储器 <strong>首先 extract <code>X</code> 中 s bits 的 <code>set index</code></strong>（缓存组索引）看作为 unsigned int，用它找到缓存空间中特定的组（和数组索引很像）；</li><li>高速缓存存储器 接着<strong>并行检查（依赖于硬件电路的检查机制）</strong>该组中所有的数据行，将 tag 字段与每个数据行中的 tag 进行比较。如果找到了相同的 tag，那么再检查 valid bit 是否指示有效。所以会出现以下情况：<ul><li><strong>情况一</strong>：该组的数据行中不存在 tag 与 <code>X</code> 一致的行，<strong>说明请求的数据块不在缓存中（Cache miss）</strong>；</li><li><strong>情况二</strong>：该组的数据行找到了 tag 与 <code>X</code> 一致的行，但 valid bit 指示无效，<strong>说明请求的数据块无效，当前也不在缓存中（Cache miss）</strong>；</li><li><strong>情况三</strong>：该组的数据行找到了 tag 与 <code>X</code> 一致的行，并且 valid bit 指示有效，<strong>Cache hit</strong>！</li></ul></li><li>如果是 cache hit，那么<strong>extract</strong> <code>X</code> 中 b bits 的 <code>block offset</code>，从该数据行的数据区块开头地址加上这个 offset，将得到的地址再数据行中剩余部分规定大小读出，直接传给 CPU，结束查找过程；</li><li>如果是 cache miss，那么高速缓存存储器会放弃查找，将原本的请求地址 <code>X</code> 传给下一级存储设备（主存），那么查找工作交给主存（重复上面类似的步骤）。<strong>注意，当主存找到数据向上提交时，再次给到高速缓存存储器</strong>，将数据放在高速缓存存储器的应该是 <code>X</code> 的位置<strong>缓存起来</strong>（通常会覆盖相同位置的其他数据），然后高速缓存存储器再将数据向上提交给 CPU；</li></ul><p>总体呈现出 <strong>“逐层向上缓存数据，逐层向下查找数据”</strong> 的形式。</p><h4 id="9-2-1-Direct-Mapped-Cache-Simulation"><a href="#9-2-1-Direct-Mapped-Cache-Simulation" class="headerlink" title="9.2.1 Direct-Mapped Cache Simulation"></a>9.2.1 Direct-Mapped Cache Simulation</h4><p>下面详细解释上面的步骤。为了便于理解，我们首先从简单的情况讨论，<strong>当每一个缓存组只包含一个数据行的情况，这种情况被称为 “直接映射”（Direct-Mapped Cache Simulation）</strong>：</p><p>假设某个机器的内存空间大小 M = 16 bytes（可以用 4-bit digit 代表地址），缓存空间中含有 4 个组（S = 4），每个组含有一个数据行（E = 1），每个数据行含有 2 bytes 的数据区块（B = 2）。</p><p>在数据区块中，block offset 的长度为 1 byte（b = 1，因为数据区块只有 2 bytes，一般有 $B=2^b$），set index 的长度为 2 bytes（s = 2，因为缓冲区只有 4 组数据组，有 $S=2^s$）；</p><p>现在程序开始运行的时候，分别请求内存地址（$X$）为 0、1、7、8、0 的 1 byte 数据；</p><p>现在，高速缓存存储器中的所有数据行的 valid bit 都是 0（假设 0 代表无效，1 代表有效），并且开始接受 CPU 请求内存地址 $X = 0 = 0000_2$ 的数据 的请求。</p><p>首先，$X$ 的 block offset <strong>就是中间 2 bit</strong>，<code>00</code>，所以在 <code>set 0</code>（第 0 组）中寻找；然后，将 $X$ 的 tag 位（即最左边的 1 bit，0）与 <code>set 0</code> 的 tag 比较（是随机数），再看 valid bit 是 0，所以 cache miss（cold miss），如下动画（本人不会 Acrobat Animate，比较粗糙）：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="imgs/directMappedCacheSimulation_part1.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" allowfullscreen="true" style="position: absolute; width: 50%; height: 50%; left: 0; top: 0;"> </iframe></div><p>思考两个问题，第一个，为什这里的 tag 是 0 ？这是因为，我们在给定的 set offset 下（组相同），前面的 t bit（t=1）的 tag 位<strong>只是用来区分数据行</strong>的，<strong>借助了原内存地址 <code>X</code> 的前 t bits 数据</strong>而已，没有实际意义。</p><p>第二个，为什么这里要从 main memories 中同时读入 0、1 地址的数据？也就是说，为什么设定 <code>B == 2</code> 呢？<strong>这是因为，除去 set offset 的 2 bits、tag 的 1 bit，剩下内存地址 <code>X</code> 数码还有 1 bit 留给 block offset</strong>，因此 <code>X</code> 只能在该组的数据行中索引 2 bytes 的数据。</p><p>细细体会上面的话，你会发现这就是缓存空间如此设置、<code>X</code> 如此解析的原因（这里设计的和 IEEE 浮点数表示法一样巧妙，不容易用语言描述）。</p><hr><p>好了，又有同学会好奇了，既然这些索引本身没有意义，只是借助了原地址的数码，<strong>那为什么设计缓存索引的人一定要 <code>set index</code> 在中间、tag 在最前面、block index 在最后面呢</strong>？</p><p>这个问题非常有水平，这和<strong>二进制数码的变化方式有关</strong>。我们这里就分析对比 2 种解释 <code>X</code> 地址的方式：</p><ul><li>Middle Bits Indexing：就是上面的 <code>X</code> 的结构，Tag 在前、<code>Set index</code> 在中间、<code>Block index</code> 在最后；</li><li>High Bits Indexing：<code>Set index</code> 在前、Tag 在中间、<code>Block index</code> 在最后；</li></ul><p>我们接下来<strong>将缓存空间的组标为不同颜色，再把内存中将要分配到哪一组的数据块填上相同的颜色</strong>，发现结果如下：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/middle_bits_indexing.png" width="360px"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/high_bits_indexing.png" width="360px"></p><p>我们发现，<strong>如果用 high bits indexing，那么内存地址相近的内存区域很容易被分配到相同的缓存组中，根据<u>空间局部性</u>，这样做会导致发生 conflict miss 的概率大大增加</strong>。所以，在缓存效率上，middle bits indexing 是优于 high bits indexing 的。其他情况同理。</p><p>这就是设计者们为什么要如此设计内存地址 <code>X</code> 在缓存中的这种解析方法。</p><hr><p>继续看接下来的过程动画：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="imgs/directMappedCacheSimulation_part2.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" allowfullscreen="true" style="position: absolute; width: 50%; height: 50%; left: 0; top: 0;"> </iframe></div><p>我们发现，5 次访问中，有<strong>高达 4 次的 cache miss</strong>。后面 2 次的 cache miss 都是 conflict miss，完全能够由 提高每组的数据行数（<code>E</code> 的大小）来避免。<strong>因此，缓存结构中 <code>E</code> 的大小越大越好（也就是每组中的数据行越多越好）</strong>。但是我们前面提到，一个组中各个数据行<strong>使用并行比较</strong>，这个操作依赖硬件的多路判断——<strong>也就是说，<code>E</code> 越大，硬件电路越复杂，硬件越贵</strong>。所以真实计算机硬件中会进行取舍，选择一个特定的 <code>E</code> 值。</p><blockquote><p>当代（21 世纪初）市面上的常见的单组中数据行数目取值 <code>E = 8</code>，最大有 <code>E = 16</code>，是 Intel 的 16 路相联 L3 三级缓存。</p></blockquote><p>事实上，<code>B</code>（数据区块的大小，block size）也是越大越好，因为越大越可以利用局部性，提升缓存命中概率。但 <code>B</code> 受限于<strong>两个因素</strong>：一是<strong>硬件成本</strong>（例如 Cache memories 由 昂贵的 SRAM 组成），二是<strong>块复制的时间代价</strong>，因为如果想要把很大的数据区块从内存挪至缓存中，也是一个不小的开销。</p><p>综合上面的考虑，设计者真正确定缓存空间各个参数的步骤如下：</p><ol><li><strong>确定合适的数据区块（就是在数据行中的那个字段）大小 <code>B</code></strong>（通常被称为<strong>固定的缓存高级设计参数</strong>。Intel 一般 64 bytes）；</li><li>根据实际应用场景和硬件成本情况<strong>确定大致的缓存空间总大小</strong>（也是固定的缓存高级设计参数之一）；</li><li>根据硬件和实际情况<strong>确定数据组的关联性（associativity，即一个数据组中有多少数据行）<code>E</code></strong>；</li><li>由 1、2、3 就能计算出大致的<strong>缓存数据组数（<code>S</code>）</strong>。</li></ol><blockquote><p>最极端的情况是 <strong>全相关联高速缓存（Fully Associative Caches）</strong>，缓存空间中只有一个组（<code>S = 1</code>，所有数据行在一个组中），这个时候如果能够并行比较，那么缓存效率是极高的。但是通常由于上述原因，我们大多数时候只能在<strong>软件级别的缓存 或者 在主存和硬盘之间的缓存模式（因为硬盘读取时间开销很大，值得我们使用复杂算法来获得更高的缓存效率，我们在“虚拟内存”一章会讨论）</strong>中找到这种组织形式。</p></blockquote><h4 id="9-2-2-E-Way-Set-Associative-Cache-Simulation"><a href="#9-2-2-E-Way-Set-Associative-Cache-Simulation" class="headerlink" title="9.2.2 E-Way Set Associative Cache Simulation"></a>9.2.2 E-Way Set Associative Cache Simulation</h4><p>除了直接映射，还有一个稍微复杂点的例子，<strong>当不改变上面例子中的缓存空间大小，讨论每个缓存组包含 2 个数据行的情况，这也被称为 “2-Way Set Associative Cache（2 路相连高速缓存）Simulation”</strong>。</p><p>这个时候 tag 变为 2-bit，set index 变为 1-bit，block index 还是 1-bit；</p><p>我们有类似上面 Directed-Mapped Cache Simulation 相近的步骤，如下图：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/2_way_associative_cache_sim.png" height="300px"></p><blockquote><p>注意到一点，当关联性大于 1 的时候，同一个数据组中可能不同的数据行的 tag 可能是相同的，那么当我们想要覆盖数据的时候，就涉及到了<strong>选择覆盖</strong>的问题，它可以通过设计算法来完成。</p><p>根据<strong>局部性原理的逆定理（通常成立）</strong>，如果一个数据长时间不被引用，那么它在未来的某个时间也不太可能被引用。所以，最常见的算法是 <strong>“最近最少使用” 策略（Least Recently Used Strategy）</strong>，这种算法一般不需要额外的 bit 存储数据，只是从硬件层面跟踪在缓存中数据的使用频率（如按序保存虚拟时间戳），确保无效的数据行最先被覆盖，然后是使用频次更低的数据先被覆盖。</p></blockquote><h3 id="9-3-Write-Cache"><a href="#9-3-Write-Cache" class="headerlink" title="9.3 Write Cache"></a>9.3 Write Cache</h3><p>事实上，真正要更改某些数据恐怕比读数据更难，因为我们的缓存机制通常会产生多份数据的复制品。例如层级从低到高：硬盘、主存、L1 / L2 / L3 高速缓存，其中可能包含了同一份数据的副本。</p><p>于是在程序要求修改内存（仍然以 高速缓存存储器 和 内存 这对存储同样有 2 种情况 <strong>write-hit</strong> 和 <strong>write-miss</strong>：</p><p>如果遇到 <strong>write-hit</strong>（要写的内存数据就在缓存设备中）的情况，由于数据分布特殊性，那么有两种处理方法：</p><ul><li><p><strong>Write-through</strong>：立即将数据写入缓存（即覆盖当前行）并主动刷新（flush）到内存；</p><ul><li>优势：内存始终是缓存的镜像，二者数据同步；</li><li>劣势：从 CPU 到 内存，时间开销必然很大；</li></ul></li><li><p><strong>Write-back</strong>：先把数据写入缓存，但不立即刷新，直到下一个数据要覆盖这个数据行的时候，才更新到内存中（defer write to memory until replacement of line，<strong>只是尽可能推迟了写入内存的时间</strong>）；</p><ul><li><p>优点：如果数据的 dirty bit 指示没有被污染时，那么覆盖这一行就不用执行 write 操作；</p></li><li><p>特点：<strong>这种方法需要一个标记（dirty bit），用来指示当前数据和内存中是否相同，即是否有被修改过</strong>；</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/dirty_bit.png" height="100px"></p></li><li><p>劣势：必然存在 <strong>write-miss</strong> 现象，因为如果修改的内存数据不在缓存中，那么就需要与内存交互；</p></li></ul></li></ul><p>如果遇到的是 <strong>write-miss</strong>，那么也有 2 种方法（<strong>和 write-hint 是对称的操作</strong>）：</p><ul><li><strong>Write-allocate</strong>：写分配，在 write-miss 后，<strong>先将原数据从内存读入缓存，转换为 write-hit 的情况，再 write-back（仅修改缓存 + dirty bit）</strong>；</li><li><strong>No-write-allocate</strong>：直接写入内存，不加载到缓存（缓存中没有这个数据所在的数据行，因为本来就是 write-miss）；</li></ul><p>一般情况下，由于对称性，人们一般选择 “<strong>write-back + write-allocate</strong>” 或 “write-through + no-write-allocate” 的策略中的其中一对（根据实际情况）；</p><h3 id="9-3-The-Hierarchy-of-Cache-Memories"><a href="#9-3-The-Hierarchy-of-Cache-Memories" class="headerlink" title="9.3 The Hierarchy of Cache Memories"></a>9.3 The Hierarchy of Cache Memories</h3><p>讨论完了缓存读写的具体的逻辑实现，我们再来看看实际上硬件是如何对应这些实现的。同样以 高速缓存存储器 为例。<strong>到目前为止，我们都假设计算机系统中只有一个高速缓存存储器的缓存空间</strong>，但是实际上，早在前面第 8 章中就介绍了，一般计算机中有 L1、L2、L3 3 类 Cache memories。它们在硬件上是如何设置和协调的呢？</p><p>以 Intel Core i7 芯片为例，它的高速缓存层次结构如下：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/intel_i7_cache_hierarchy.png" height="300px"></p><p>如图，一般情况下，现代 CPU 有 4（桌面系统）/ 8 ~ 12（服务器类系统）个核，<strong>每个核可以各自并行，独立执行各自的指令流</strong>，每个处理器内核可以包含<strong>各自的</strong>通用寄存器（位于存储系统层次结构 L0）.</p><p>在其中，每个核还会有 2 种 L1 Cache。其中一种是 <strong>d-cache（data cache，1 级数据高速缓存器）</strong>，另一种是 <strong>i-cache（instruction cache，1 级指令高速缓存器</strong>）。它们的读取时延（4 个时钟周期）仅次于寄存器，正因速度和成本的关系，它们的大小非常小，只有约 32 KB；它们的关联性一般是 8 路（一个缓存组中有 8 个数据行）；</p><p>在 L1 Cache 的下一层是 L2 Cache（L1 和），只有一种联合的高速缓存器（unified cache，同时包含某个核的数据和指令的缓存），读取速度稍慢（10 个时钟周期）于 L1 Cache，也是 8 路关联性，不过大小稍微大一点，有 256 KB；</p><p>再下层的 L3 Cache 不在 CPU 的核内，是被所有核心所共享的联合高速缓存存储器。8 bytes 大小、16 路关联性，但访问时延长达 40 ~ 75 个时钟周期；</p><p><strong>它们间的关系和之前所说的各个层级的缓存设备一模一样，都是 “逐层向上缓存数据，逐层向下查找数据”</strong>。</p><p>根据这些实际的物理结构，我们考虑一下高速缓存存储器的性能和损耗情况。我们建立如下的衡量指标（Cache Performance Metrics）：</p><ul><li>Miss Rate:  cache memories 不可避免的会发生 cache miss，这就是 cache memories 性能可能产生损耗的原因之一；<ul><li>定义：缓存未命中次数 / 总访问次数（ = <strong>1 - hit rate</strong>）；</li><li>一般情况下，L1 Cache 的 未命中率在 3 ~ 10%，L2 Cache 在 1% 左右，<strong>和缓存大小紧密相关</strong>（<strong>如此低的 Miss Rate 得益于 程序局部性</strong>）；</li></ul></li><li>Hit Time：虽然有时缓存成功命中，但从缓存的数据行中传输到处理器中仍然需要时间。<ul><li>定义：从检查标志位，到 hit 直接返回 block 中的缓存数据所需时间；</li></ul></li><li>Miss Penalty：由于 Miss Rate，从内存传输到缓存和 CPU 中通常会花费更多时间；<ul><li>定义：从检查标志位，到 miss、从内存读取数据，直到数据传回 CPU 所需时间；</li><li>一般情况下从主存中读取数据大约花费 50 ~ 200 个时钟周期（如果在其他的存储系统的层次中，花费可能大得多）；</li></ul></li></ul><p><strong>事实上，这些一次两次看似影响不大的 Cache miss 和 hit，对系统性能影响相当大！数学证明表明，99% 的 hit rate 的系统性能比 97% 的 hit rate 对应的系统性能迅速 2 倍</strong>！</p><h3 id="9-4-Performance-Impact-of-Cache"><a href="#9-4-Performance-Impact-of-Cache" class="headerlink" title="9.4 Performance Impact of Cache"></a>9.4 Performance Impact of Cache</h3><h4 id="9-4-1-Writing-Cache-Friendly-Code-Ⅰ"><a href="#9-4-1-Writing-Cache-Friendly-Code-Ⅰ" class="headerlink" title="9.4.1 Writing Cache Friendly Code Ⅰ"></a>9.4.1 Writing Cache Friendly Code Ⅰ</h4><p>考虑上一节惊人的缓存性能的情况，我们确实应该写出一些 Cache Friendly 的代码，<strong>这是优化代码性能的一个重要方面</strong>。在分析了缓存的特性和程序局部性之后，我们可以这样来充分利用高速缓存带给程序的性能提升：</p><ul><li><p>关注<strong>经常被调用的</strong>函数中<strong>执行次数最多的内层循环</strong>的性质，积极对它进行算法层面优化；</p></li><li><p>尽量使用重复的变量引用，而不是很多的全局变量（利用了时间局部性，减少 cache miss 的可能）；</p><blockquote><p>它和 第 15. 章的 CSE 优化不冲突，后者是尽量避免 Memory Alias；</p></blockquote></li><li><p>尽量使用 stride-1 reference patterns（或者说<strong>程序循环的步长尽量小</strong>，尤其是逐个访问数组元素，这就将 cache block 的优点发挥了出来，利用了空间局部性，减小 cache miss 的可能）；</p></li></ul><p><strong>总结：我们分析缓存的组织原理和特性，是进一步定量地（如上面的指标）去体现、印证程序局部性的概念</strong>。</p><h4 id="9-4-2-The-Memory-Mountain"><a href="#9-4-2-The-Memory-Mountain" class="headerlink" title="9.4.2 The Memory Mountain"></a>9.4.2 The Memory Mountain</h4><p>之前简单地对缓存组成的分析，让我们看到了关注缓存能够对程序带来较显著地性能影响。那么这节我们更深入地去探究缓存对程序性能的影响。</p><p>首先引入一个概念：</p><ul><li>Read throughput（吞吐量，或者说 read bandwidth，读带宽）：<strong>单位时间内从内存中读取数据的最大字节数</strong>，单位 MB/s；</li></ul><p>于是，我们可以绘制一个 <strong>时间局部性、空间局部性 关于 机器吞吐量的三维坐标图（存储器山）</strong>，以此展示缓存对程序性能的重要影响。</p><p>其中，我们以访问数组的程序为例。我们将遍历数组的步长作为衡量程序空间局部性的指标（步长越大，空间局部性越小），将一次读取数组元素数量作为衡量程序时间局部性的指标（一次取出的数据越多，访问到相同地址数据的机会越小，时间局部性越小）；</p><p>如图：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/memory_mountain.png" height="350px"></p><p>我们<strong>从读取数据量 size 的方向</strong>看图，会发现 memory mountain 有一个个像山脊一样的结构，这恰好对应了从 L1 到 Memories 的数据引用的平均性能（小的数据量更有可能在每次遍历时放在同一个缓存的 block 中，发生 cache miss 的机会就更小，只需要依靠更接近寄存器层级的缓存设备就能得到答案）；</p><p>而<strong>从数组访问步长 stride 的方向</strong>看图，会发现随着步长的增加，整体有一个负向的斜率。而随着步长大到一定程度，负向的斜率趋于平缓，这是因为<strong>步长大过了缓存 block size，导致几乎每次都会存在 Cache miss，就很难得到缓存的增益了</strong>。</p><h4 id="9-4-3-Writing-Cache-Friendly-Code-Ⅱ-Rearranging-loops-to-improve-spacial-locality"><a href="#9-4-3-Writing-Cache-Friendly-Code-Ⅱ-Rearranging-loops-to-improve-spacial-locality" class="headerlink" title="9.4.3 Writing Cache Friendly Code Ⅱ - Rearranging loops to improve spacial locality"></a>9.4.3 Writing Cache Friendly Code Ⅱ - Rearranging loops to improve spacial locality</h4><p>借助上面对于 memory mountain 的进一步分析，我们还可以想到更多的具体<strong>利用缓存来优化程序性能的方法</strong>。</p><p>例如，我们<strong>以矩阵乘法运算为例</strong>，我们假定以下的条件：</p><ul><li>N × N 方阵，元素为 double（8 bytes）类型；</li></ul><p>那么按照正确的一般矩阵相乘的方法，总单位运算次数 $O(N^3)$；</p><p>事实上，计算的一般方法有许多种（但都是 结果矩阵 $C=(c_{ij})_{N\times N}$ 的元素 $c_{ij}=a_{ik}\cdot b_{kj}$），我们<strong>这里着重讨论缓存的效率受代码安排的影响，也即，什么样的矩阵乘法最能充分利用缓存</strong>。</p><p>首先来对不同策略的矩阵乘法分析 Miss Rate：</p><ul><li>前提假设<ul><li>机器缓存空间的 <strong>块大小（<code>B</code>）为 32 Bytes（能够一次性放下 4 个 double 数据）</strong>；</li><li>矩阵维度 <code>N</code> 非常大（$\dfrac{1}{N}\approx0$）;</li><li>缓存空间的总大小不足以装下矩阵的多个行；</li></ul></li><li>分析方法：<strong>检查内层循环的函数访问模式</strong>（因为外层循环次数不可避免）；</li></ul><p>由于运算的方式固定，我们可以通过更换内外层循环顺序（共 $3!=6$ 种）来看究竟哪种方法最好。</p><p>在分析前，先再次回顾一下 C 中数组的 memory layout：</p><ul><li>二维数组的<strong>至少每一行的数据空间是 contiguous 的</strong>，并且<strong>行优先（row major）</strong>；</li><li>stride-1 逐个访问数组行的方法最能利用 spacial locality，它的 $miss\space rate=\dfrac{sizeof(a_{ij})}{B}$，其中 $B$ 是缓存空间的块大小；</li><li>stride-1 逐个访问较大数组列的方法完全无法利用 spacial locality，因为 每一列同一行的元素一定不在同一个缓存数据块中（之前已经假设 “缓存空间的总大小不足以装下矩阵的多个行”），因此 miss rate = 1（100% cache miss）；</li></ul><p><strong>情况 1：先固定 i（A 的行），再固定 j（B 的列），最后遍历 k（A 第 i 行每一列、B 第 j 列每一行）</strong></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/cache_analysis_matrix_multiply_ijk.png" height="200px"></p><p>这种情况下，<strong>对每一个最内层循环</strong>：</p><ul><li>每次要求从内存中取出 A 矩阵的同行相邻元素，<strong>miss rate = 8 / 32 = 0.25</strong>；</li><li>每次要求从内存中取出 B 矩阵的同列相邻元素，<strong>miss rate = 1</strong>；</li><li>每次要求从内存中取出 C 矩阵的一个元素，所以对单个元素而言 <strong>miss rate 近似为 0</strong>；</li></ul><p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 0 次，cache miss 次数 1.25 次</strong>；</p><p>这种情况与 <strong><code>jik</code></strong> 顺序的情况相同；</p><p> <strong>情况 2：先固定 k（B 的行），再固定 i（A 固定位置 第 i 行 第 k 列），最后遍历 j（C 的第 i 行每一列）</strong></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/cache_analysis_matrix_multiply_kij.png" height="175px"></p><p>这种情况下，<strong>对每一个最内层循环</strong>：</p><table>    <tr>        <th>Op Matrix</th>        <td>A</td>        <td>B</td>        <td>C</td>    </tr>    <tr>        <th>Miss Rate</th>        <td>0.0</td>        <td>0.25</td>        <td>0.25</td>    </tr></table><p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 1 次，cache miss 次数 0.5 次</strong>；</p><p>这种情况与 <strong><code>ikj</code></strong> 顺序的情况相同；</p><p><strong>情况 3：先固定 j（C 的第 j 列每一行），再固定 k（A 的第 k 列），最后遍历 i（固定 B 遍历 C 的 列）</strong></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/cache_analysis_matrix_multiply_jki.png" height="175px"></p><p>这种情况下，<strong>对每一个最内层循环</strong>：</p><table>    <tr>        <th>Op Matrix</th>        <td>A</td>        <td>B</td>        <td>C</td>    </tr>    <tr>        <th>Miss Rate</th>        <td>1.0</td>        <td>0.0</td>        <td>1.0</td>    </tr></table><p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 1 次，cache miss 次数 2.0 次</strong>；</p><p>这种情况与 <strong><code>kji</code></strong> 顺序的情况相同；</p><hr><p>综合上面的三种情况，我们进行实际的测试，发现结果如我们所料：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/core_i7_matrix_multiply_perf.png" height="300px"></p><p>事实证明，<strong><code>kij/ikj</code> 遍历方法（固定 A / B 的位置，遍历剩下一个运算矩阵的行，来得到结果矩阵的行）是最能利用 cache memories 的优势的方法</strong>，而我们最常用的 <code>ijk</code> 方法却不是最好的方法。</p><h4 id="9-4-4-Writing-Cache-Friendly-Code-Ⅲ-Using-blocking-to-improve-temporal-locality"><a href="#9-4-4-Writing-Cache-Friendly-Code-Ⅲ-Using-blocking-to-improve-temporal-locality" class="headerlink" title="9.4.4 Writing Cache Friendly Code Ⅲ - Using blocking to improve temporal locality"></a>9.4.4 Writing Cache Friendly Code Ⅲ - Using blocking to improve temporal locality</h4><p>上一节的例子主要以矩阵乘法为例，从提升<strong>空间局部性</strong>的层面来充分利用缓存、提示程序缓存效率。本节将从另一个角度——提升程序<strong>时间局部性</strong>来讨论如何写出缓存友好的代码。</p><p>再举一个针对矩阵乘法的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="type">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmm</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                c[i*n + j] += a[i*n + k] * b[k*n + j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的乘法而言，我们作如下假设：</p><ul><li>机器缓存空间的 <strong>块大小（<code>B</code>）为 64 Bytes（能够一次性放下 8 个 double 数据）</strong>；</li><li>矩阵维度 <code>N</code> 非常大（$\dfrac{1}{N}\approx0$）;</li><li>缓存空间的总大小不足以装下矩阵的多个行；</li></ul><p>在这种情况下，最内层的循环中，每一个循环的 cache miss 平均次数为：$\dfrac{n}{8}+n=\dfrac{9}{8}n$，于是总的 cache miss 的数量在 $\dfrac{9n^3}{8}$ 左右，显然，这样的 cache miss 数量会显著影响程序性能和对缓存的利用。于是，一种利用时间局部性的方法就出现了：</p><p><strong>我们在每次内存循环取矩阵乘法的 $C$ 的单元的时候，将单独取一个改为选取一个 block（小型块），如图所示，block 的宽度为 $B$：</strong></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/multi_simple.png" height="150px"></p><p>改为：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/multi_block.png" height="150px"></p><p>即计算代码改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="type">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmm</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i+=B)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j+=B)</span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k+=B)</span><br><span class="line">                    <span class="comment">/* B x B mini matrix multiplications */</span></span><br><span class="line">                    <span class="keyword">for</span> (i1 = i; i1 &lt; i+B; i1++)</span><br><span class="line">                        <span class="keyword">for</span> (j1 = j; j1 &lt; j+B; j1++)</span><br><span class="line">                            <span class="keyword">for</span> (k1 = k; k1 &lt; k+B; k1++)</span><br><span class="line">                                c[i1*n+j1] += a[i1*n + k1]*b[k1*n + j1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们再次分析 cache miss 的情况。</p><p>假设选取的 $B$ 的大小能够被缓存利用：$3B^2\lt C$，那么：</p><ul><li><p>每一个 sub-block（子块）内部的 cache miss 数量：$\dfrac{B^2}{8}$；</p></li><li><p>每一次行循环的 cache miss 数：$\dfrac{2n}{B}\cdot\dfrac{B^2}{8}=\dfrac{nB}{4}\sim O(nB)$；</p></li><li>总的 cache miss 数：$\dfrac{nB}{4}\cdot(\dfrac{n}{B})^2=\dfrac{n^3}{4B}$；</li></ul><p>总而言之，这样的改进并没有根本上提升算法的时间复杂度，但是它却能确确实实地减少常数级别的 cache miss 数量（$\dfrac{9}{8}n^3\rightarrow\dfrac{1}{4B}n^3$），在一定程度上达到提升时间局部性的效果。这样，只要我们选择满足 $3B^3\lt C$ 的最大的 $B$ 的取值，就能找到这种思路的最优计算方法。</p><p>为什么能够引起如此大的常数优化呢？主要是以下原因：</p><ul><li>我们在选取 block 的时候，相当于加载了一个地址上更相邻的、之后能被反复使用的变量，因为我们缩小了矩阵乘法的 $N$，逐个 block 攻破，这样的矩阵乘法更能利用时间局部性；<ul><li>输入数据 $3n^2$，计算 $2n^3$，而每个元素需要被使用 $O(n)$ 次；</li></ul></li></ul><h4 id="9-4-5-Cache-Performance-Summary"><a href="#9-4-5-Cache-Performance-Summary" class="headerlink" title="9.4.5 Cache Performance Summary"></a>9.4.5 Cache Performance Summary</h4><p>在 9.4 节中，我们通过几个例子了解到，<strong>虽然我们无法显式控制 cache 的存储方式，但是通过对于程序局部性的分析，我们可以更高效地利用 cache，从而提升程序允许效率。</strong>这主要可以从两个方面下手：</p><ul><li>使用 stride-1 reference pattern、关注内层循环的步长和方式，以提升程序的空间局部性；</li><li>多次使用相同的局部变量、分块访问，以提升程序的时间局部性；</li></ul><blockquote><p>注：中间 10 ~ 14 章单独作为一部分呈现，此处略过</p></blockquote><h2 id="Chapter-15-Program-Optimization"><a href="#Chapter-15-Program-Optimization" class="headerlink" title="Chapter 15. Program Optimization"></a>Chapter 15. Program Optimization</h2><blockquote><p>One of the themes for this chapter:</p><ul><li>去除程序不必要的工作、编写编译器友好代码、提升运行速度；</li><li>利用机器代码特性，针对特定机器对程序优化；</li></ul></blockquote><p>编译器无法理解一些内容，例如 int 数据类型可能只用到相当小的范围、procedure call 究竟是什么意思，等待。编译器只是针对一些特定情况，对照 “cookbook” 进行有选择地优化。其遇到复杂或者特殊情况的 “保底” 方案是不对代码进行优化。</p><p>初始思路：查看程序汇编代码哪些地方没被优化，找到对应的源码部分进行重写，直至重构成编译器友好代码（只要不过度牺牲程序可读性就行）。</p><h3 id="15-1-Goals-of-Optimization"><a href="#15-1-Goals-of-Optimization" class="headerlink" title="15.1 Goals of Optimization"></a>15.1 Goals of Optimization</h3><ul><li>Minimize number of instructions<ul><li>避免重复计算；</li><li>避免不必要的计算；</li><li>避免较大计算量的操作（例如乘、除）；</li></ul></li><li>Avoid waiting for memory<ul><li>尽量将数据和运算过程放在 register 中，而非内存中；</li><li>使用 cache-friendly 的方式访问内存；</li><li>尽早从内存加载数据，并且加载次数越少越好；</li></ul></li><li>Avoid branching<ul><li>不要写出不必要的判断结构；</li><li>写成让 CPU 容易预测分支的代码（流水线）；</li><li>尽量解开循环，分摊分支的开销；</li></ul></li><li>Make good use of locality &amp; cache: 写出程序局部性良好的代码、充分利用缓存机制（8.2 &amp; 9.X）；</li></ul><h3 id="15-2-Limits-to-Compiler-Optimization"><a href="#15-2-Limits-to-Compiler-Optimization" class="headerlink" title="15.2 Limits to Compiler Optimization"></a>15.2 Limits to Compiler Optimization</h3><ul><li><p>无法优化算法的渐进时间复杂度；</p></li><li><p>绝不会改变程序语义、行为；</p></li><li><p>编译时仅仅分析每个函数一次（inline 函数除外）；</p><blockquote><p>目前 Whole-program analysis (“LTO”) 比较受欢迎，尽管开销很大；</p></blockquote></li><li><p>无法很好地针对运行时的输入内容进行优化</p><ul><li>可能出现最坏情况，尤其是面对非法输入的时候；</li></ul></li></ul><h3 id="15-3-Generally-Useful-Optimizations"><a href="#15-3-Generally-Useful-Optimizations" class="headerlink" title="15.3 Generally Useful Optimizations"></a>15.3 Generally Useful Optimizations</h3><blockquote><p>本部分的优化技巧不针对特定的编译器或者处理器，具有普适性。</p><p>绝大多数编译器在一定的优化等级下，都能优化本节的情况，但是我们应该学习这些方法。</p><p>注：一个能看到优化过程的网站：<a href="https://godbolt.org/z/Es5s8qsvj">COMPILER EXPLORER</a></p></blockquote><p>根据 15.1 中的目标，我们可以整理出一些常见的情况，这些情况下编译器能够优化，或者说具有普适性的优化策略，主要有以下两类：</p><ul><li>Local Optimizations (<strong>work inside a single basic block</strong>)<ul><li>Constant folding（常数折叠）</li><li>Strength reduction（计算强度削减）</li><li>Dead code elimination（死代码剔除）</li><li>Local CSE（Local Common Subexpression Elimination，局部的相似子表达式复用）</li><li>……</li></ul></li><li>Global Optimizations (<strong>process the entire control flow graph of a function</strong>)<ul><li>Loop transformations（循环结构转换）</li><li>Code motion（代码移动）</li><li>Inlining（内联化）</li><li>Global CSE（全局的相似子表达式复用）</li></ul></li></ul><p>这章仅仅叙述它们的思路，不涉及具体实现，因为具体实现就涉及到编译原理（AST 语法树等知识）；</p><h4 id="15-3-1-Constant-Folding"><a href="#15-3-1-Constant-Folding" class="headerlink" title="15.3.1 Constant Folding"></a>15.3.1 Constant Folding</h4><p>常数折叠的方法主要有以下几个方面：</p><ul><li><p>直接运算代码中的常数表达式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> mask = <span class="number">0xFF</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 优化为：</span></span><br><span class="line"><span class="type">long</span> mask = <span class="number">0xFF00</span>;</span><br></pre></td></tr></table></figure></li><li><p>直接运算一切可以常量化的表达式，例如针对常量调用的库函数、常量输入等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> namelen = <span class="built_in">strlen</span>(<span class="string">&quot;Harry Bovik&quot;</span>);</span><br><span class="line"><span class="comment">// 优化为：</span></span><br><span class="line"><span class="type">size_t</span> namelen = <span class="number">11</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="15-3-2-Dead-Code-Elimination"><a href="#15-3-2-Dead-Code-Elimination" class="headerlink" title="15.3.2 Dead Code Elimination"></a>15.3.2 Dead Code Elimination</h4><p>死代码删除方法的思路主要来源于 15.1 中的 “Avoid Branching” 和 “Minimize number of instructions”，分为以下几种情况：</p><ul><li><p>删除语义上不可能执行到的代码（无效代码）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Hello, 0&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Hello, 1&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Hello, 1&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除结果被覆盖的代码（也是无效代码）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">23</span>; x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">x = <span class="number">42</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这类优化方式看起来很蠢，但也很重要，因为有时候这些死代码不容易被肉眼识别，或者在编译器进行其他优化过程中，在语义树上出现了，那么就需要这种方法来清理。</p><h4 id="15-3-3-Common-Subexpression-Elimination"><a href="#15-3-3-Common-Subexpression-Elimination" class="headerlink" title="15.3.3 Common Subexpression Elimination"></a>15.3.3 Common Subexpression Elimination</h4><p>CSE 的思路就是根据 AST 树的特征，约去<strong>重复计算</strong>，从而降低运算量，例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处展示的是 Local CSE */</span></span><br><span class="line"></span><br><span class="line">up = val[(i<span class="number">-1</span>)*n + j];</span><br><span class="line">down = val[(i+<span class="number">1</span>)*n + j];</span><br><span class="line">left = val[i*n + j - <span class="number">1</span>];</span><br><span class="line">right = val[i*n + j + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以改为：</span></span><br><span class="line"><span class="type">long</span> inj = i*n + j;</span><br><span class="line">up = val[inj - n];</span><br><span class="line">down = val[inj + n];</span><br><span class="line">left = val[inj - <span class="number">1</span>];</span><br><span class="line">right = val[inj + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">norm[i] = v[i].x * v[i].x + v[i].y * v[i].y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">elt = &amp;v[i];</span><br><span class="line">x = elt-&gt;x;</span><br><span class="line">y = elt-&gt;y;</span><br><span class="line">norm[i] = x * x + y * y;</span><br></pre></td></tr></table></figure><h4 id="15-3-4-Code-Motion"><a href="#15-3-4-Code-Motion" class="headerlink" title="15.3.4 Code Motion"></a>15.3.4 Code Motion</h4><p>I.e., reduce frequency with which computation performed（也是降低代码重复运算频率，不过是在 global 范围进行）</p><ul><li><p>If it will always produce same result（这种改动<strong>语义不变</strong>）；</p></li><li><p>Especially moving code out of loop（常见于将代码移出循环结构，但为了保持语义，要求移动的代码在每次循环中的结果不变）；</p></li><li><p>Example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_row</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> i, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        a[n*i + j] = b[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为（将 n*i 这个与循环无关的变量提出循环，避免重复运算）：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_row</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> i, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">int</span> ni = n * i;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        a[ni + j] = b[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="15-3-5-Inlining"><a href="#15-3-5-Inlining" class="headerlink" title="15.3.5 Inlining"></a>15.3.5 Inlining</h4><p>I.e., copy body of a function into its caller(s);</p><p>对于一些短的、计算开销小的非递归函数，即便编程人员不指定 <code>inline</code> 关键字，编译器也应该识别到并且内联操作。这样做的好处有两点：</p><ul><li>消除函数调用的栈帧分配开销；</li><li>为其他许多优化方法<strong>创造条件</strong>。例如，对代码中的一些函数内联，可以被编译器找到例如 dead code elimination、constant fold 的机会；</li></ul><p>这是个例子：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/inlining_example1.png"></p><p>缺点：这种优化方法在某些情况下（内联函数很长、开销很大）会导致整体代码空间占用变大、速度降低；</p><h4 id="15-3-6-Strength-Reduction"><a href="#15-3-6-Strength-Reduction" class="headerlink" title="15.3.6 Strength Reduction"></a>15.3.6 Strength Reduction</h4><p>I.e., replace costly operation with simpler one.（计算量减小）</p><ul><li>可以用移位、加法尽量代替乘法、除法（优化的比例取决于不同的机器）；</li></ul><h3 id="15-4-Obstacles-for-Compiler-to-Optimization"><a href="#15-4-Obstacles-for-Compiler-to-Optimization" class="headerlink" title="15.4 Obstacles for Compiler to Optimization"></a>15.4 Obstacles for Compiler to Optimization</h3><p>现在反过来看，有哪些操作会阻碍编译器优化？</p><p>阻碍编译器优化的原因之一就是期间调用了其他函数，这样 gcc 可能就无法识别到优化方法。还有一个主要原因就是 “内存别名” 的存在。</p><h4 id="15-4-1-Optimization-Blocker-1-Procedure-Calls"><a href="#15-4-1-Optimization-Blocker-1-Procedure-Calls" class="headerlink" title="15.4.1 Optimization Blocker #1: Procedure Calls"></a>15.4.1 Optimization Blocker #1: Procedure Calls</h4><p>典型例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，循环判断条件中有一个函数 <code>strlen(s)</code>，我们都知道这是计算字符串长度的函数。但是<strong>编译器不知道</strong>，它认为<strong>这个函数有可能在每次循环中，返回值可能改变</strong>，所以不会把它优化为一个常数，而是保持<strong>每次循环判断时，都重新调用 <code>strlen(s)</code></strong>。</p><p>可是，<code>strlen(s)</code> 的复杂度是  $O(n)$ 啊！这样好端端的 $O(n)$ 能实现的函数被硬生生干成了 $O(n^2)$ ……</p><p>所以，正确的做法是，先把 <code>strlen(s)</code> 算出来。更好的主意是，<strong>干脆不使用 <code>strlen()</code>，因为判断字符串结束原本就是能在循环中发现的情况</strong>，并且把数组索引改成指针取值，这样还能再节省常数时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *s &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            *s -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回过头来，为什么绝大多数的编译器没法优化这种 procedure calls 的情况？主要有几点原因：</p><ul><li>Procedure may have side effects; 就像前面说的，编译器不知道运行这个 procedure 会不会改变当前环境中其他变量的值，所以不敢贸然改变 procedure 运行顺序；</li><li>Procedure 会出现重载、重写的情况，这些函数有不同版本，可能分布在不同文件中，只有编译结束，链接的时候才知道最终用的函数是谁。对于虚函数而言，甚至要在运行时才知道调用的是哪一个同名函数；所以更不敢随意判断某个 procedure 的作用，也就无法解决上面的问题；</li><li>如果全面分析所有同名 procedure，并且找到它们的含义、作用，那么编译开销过大，非常不现实；</li></ul><p>综上，编译器一般的做法是<strong>将 procedure 看作一个黑盒，行为不确定，所以一般不会优化它的执行顺序</strong>。因此，开发者应该清楚意识到函数的作用，并且重视它执行的位置对代码性能的影响。</p><h4 id="15-4-2-Optimization-Blocker-2-Memory-Aliasing"><a href="#15-4-2-Optimization-Blocker-2-Memory-Aliasing" class="headerlink" title="15.4.2 Optimization Blocker #2: Memory Aliasing"></a>15.4.2 Optimization Blocker #2: Memory Aliasing</h4><p>先看示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sum rows is of n x n matrix a and store in vector b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum_rows1</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        b[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">               b[i] += a[i*n + j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看起来性能上没什么问题，大多数人都会如此实现代码。但是我们看看对应的 x86-64 汇编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># sum_rows1 inner loop</span><br><span class="line">.L4:</span><br><span class="line">    movsd(%rsi,%rax,8), %xmm0# FP load</span><br><span class="line">    addsd(%rdi), %xmm0# FP add</span><br><span class="line">    movsd%xmm0, (%rsi, %rax, 8)# FP store</span><br><span class="line">    addq$8, %rdi</span><br><span class="line">    cmpq%rcx, %rdi</span><br><span class="line">    jne.L4</span><br></pre></td></tr></table></figure><p>我们发现，小小的 <code>b[i] += a[i*n + j]</code> 竟然有两次对内存的操作（从内存读到寄存器，计算后再写回内存），为什么会这样？为什么不直接在内存中计算？</p><p>这是因为 <strong>Memory Alias（内存别名）在 C 中是允许的</strong>。比如，如果我这么调用 <code>sum_rows1</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> A[<span class="number">9</span>] =</span><br><span class="line">    &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">          <span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,</span><br><span class="line">         <span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* B = A+<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">sum_rows1(A, B, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>那么，第二参数 <code>B</code> 就是 <code>A</code> 的一部分的<strong>内存别名</strong>，也就是说，程序有两个指针指向一块内存地址，这样的话，在每次 <code>B[i] = 0</code> 后，就会改变 <code>A</code> 的内容，从而改变求和的值。因此编译器仍然不敢直接优化。</p><p>问题在于，我们知道这个函数的作用是数组列求和，我们不会传入两个内存别名。但是编译器不知道——因为要检查所有的 memory alias 开销也非常大，所以编译器默认程序中都存在内存别名。</p><p><strong>所以解决方法是</strong>，我们暗示编译器这里不会有内存别名导致循环中数组值的更改：<strong>在求和时不直接加到 <code>b</code> 中，而是以临时局部变量存储，求和循环结束后同一赋值给 <code>b</code></strong>，这样在一次求和循环中编译器就不会重复从内存读取信息了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sum rows is of n x n matrix a and store in vector b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum_rows1</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">double</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">               val += a[i*n + j];</span><br><span class="line">        b[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样内层求和循环的汇编码就变得简单了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># sum_rows1 inner loop</span><br><span class="line">.L10:</span><br><span class="line">    addsd(%rdi), %xmm0# FP load + add</span><br><span class="line">    addq$8, %rdi</span><br><span class="line">    cmpq%rax, %rdi</span><br><span class="line">    jne.L10</span><br></pre></td></tr></table></figure><blockquote><p>实际上，内存读写仍然是耗时大头，所以改写后性能提升不会非常明显。</p></blockquote><p>对开发者而言，应该习惯于在循环前引入一些局部变量（<strong>Accumulate in temporary</strong>），尤其是含有数组索引的循环，这样能够暗示编译器按照没有内存别名的情况处理。</p><p>总结一下就是：</p><ul><li>多使用临时局部变量来存放中间值，尤其是在循环中；</li><li>使用更严格的关键字，例如 <code>int[]</code> 好过 <code>int*</code> 来让编译器知道不会有 memory alias；</li></ul><p>上面的几种优化技巧都是比较简单和零碎的，不宜死记硬背，应该贯通在实践当中。下面从另一个角度考虑优化问题。</p><h3 id="15-5-Machine-Dependent-Optimization"><a href="#15-5-Machine-Dependent-Optimization" class="headerlink" title="15.5 Machine-Dependent Optimization"></a>15.5 Machine-Dependent Optimization</h3><blockquote><p>这类优化取决于处理器机器和系统，根据汇编处理方式进行优化。</p></blockquote><p>表面上与机器无关的优化方法都考虑得差不多了，但在机器层面还有一些优化的方法。为了考虑这些方法，我们需要先了解机器的简单组成和基本运作原理。下面是上个世纪末的处理器的大概的设计样式：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/modern_CPU_design.png" height="400px"></p><p>底层机制过于复杂，一般人短时间内几乎不可能理解，所以这里仅仅浅浅介绍一下。</p><p>CPU 执行代码时，借助了多种方法和技术，构建了健全的硬件设施，使得其执行指令的速度远远快于一条一条读取执行的速度。其中一种技术被称为 “超标量乱序执行” 技术（superscalar out of order execution），它的思路可以理解为：CPU 一次性读入大量机器指令，再将顺序的指令拆开，发现逻辑上某两句间不相互依赖，于是 CPU 可以不按顺序、尽可能多地同时执行这些代码。</p><p>指令的这种特性被称为 <strong>指令级并行性（instruction level parallelism）</strong>；</p><p>上图的 Instruction Control 展示了 CPU 如何从高速缓存中抓取指令，并放入运算单元的。<strong>注意，这里所有的操作都使用缓存和寄存器</strong>，因为其他储存介质（包括内存）都太慢了。</p><p>上面<strong>在一个时钟周期中处理、执行多条指令的处理器</strong>被称为 Superscalar Processor，它们通常一次性获取一串指令流，并动态地进行调度和执行。它的好处是 <strong>充分利用了代码中的指令级并行性</strong>，所以大多数现代 CPU 都是超标量的，并且现代 CPU 的执行模型也几乎都是乱序执行的模型。</p><p>现代 CPU 的策略是乱序执行，固然非常复杂，但是它的功能实现单元更加复杂——<strong>流水线（piplining）</strong>。</p><p>流水线的基本思想是，<strong>处理器将每个计算分解为一系列不同阶段，每个阶段都有一个专用硬件可以独立完成。于是，当一个计算阶段的硬件空闲下来时，就可以接受下一个数据的计算工作</strong>。</p><p>其中，除法运算无法被分解在流水线上进行，一次操作 3 ~ 30 个时钟周期，所以是一个昂贵的操作。</p><blockquote><p>这些并行性都是单个 CPU 的单核的并行性，不涉及多核并行。</p></blockquote><p>按照这些思路，我们可以发现在机器层面的优化方法：</p><h4 id="15-5-1-Branch-Misprediction-Recovery"><a href="#15-5-1-Branch-Misprediction-Recovery" class="headerlink" title="15.5.1 Branch Misprediction Recovery"></a>15.5.1 Branch Misprediction Recovery</h4><p>我们在 4.2.2 中提到过，机器层面的分支预测技术（Branch Prediction）就是为了让 CPU 流水线的效率得到充分利用而诞生的。在很多情况下，如果我们不使用条件移动的话，那么在分支预测错误的时候，很有可能整个流水线的指令和数据全部需要重新载入，这将耗费大量的运算资源和时间。</p><p>所以第一个思路就是从降低 <strong>Branch Misprediction Penalty</strong> 方面着手。首先了解一下分支预测技术的大概原理是啥。分支预测技术在早期使用的是简单的 heuristic：向后分支（backwards branches）经常是判断（if），向前分支（forwards branches）经常是循环（loop）。我们可以通过一些算法<strong>跟踪这些分支（尤其是循环）的历史行为，如果它经常通过某一分支，那么以后预测该分支的可能性会大一点</strong>。</p><p>这种预测方法在有些代码中效果显著，但是另一些代码（<strong>例如强数据依赖、强随机数据</strong>）中效果极差，甚至导致更多的 Branch Misprediction Penalty；</p><p>因此接近这个方面问题的可能途径如下：</p><ul><li>减少分支结构的数量：<ul><li>Transform loops（尽量转换、消除不必要的循环）</li><li>Unroll loops（下面介绍）</li><li>Use Conditional Moves（4.2.2）</li></ul></li><li>使得分支<strong>更容易被分支预测器预测</strong><ul><li>为循环中的数据排序（需要权衡）</li><li>尽量避免间接的分支结构（因为间接分支基本上都没有预测依据）<ul><li>函数指针判断跳转</li><li>虚函数运行时判断跳转</li></ul></li></ul></li></ul><p>这里介绍一下 unroll loops 的思路。unroll loops 就是<strong>将循环中的代码成倍数展开，达到均摊 Branch Misprediction Penalty 的目的</strong>。同时，这种方法还能为其他的优化方法创造条件（例如 CSE、Code Motion、Scheduling 等）。方法的示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts; i++)</span><br><span class="line">    A[i] = B[i]*k + C[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    A[i  ] = B[i  ]*k + C[i  ];</span><br><span class="line">    A[i+<span class="number">1</span>] = B[i+<span class="number">1</span>]*k + C[i+<span class="number">1</span>];</span><br><span class="line">    A[i+<span class="number">2</span>] = B[i+<span class="number">2</span>]*k + C[i+<span class="number">2</span>];</span><br><span class="line">    A[i+<span class="number">3</span>] = B[i+<span class="number">3</span>]*k + C[i+<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方法有两个明显的缺陷，一是如果过度展开，会增长代码长度，同样会影响性能。所以需要根据数据量进行权衡；二是在某些循环中，依赖 i 进行判断的场合，这种展开就不适用了。</p><h4 id="15-5-2-Scheduling"><a href="#15-5-2-Scheduling" class="headerlink" title="15.5.2 Scheduling"></a>15.5.2 Scheduling</h4><p>在上面的流程中，除了 Branch Misprediction Penalty，还有一种会影响 CPU 运算性能的情况——数据读取和写入。I/O 操作的开销一直是处理器设计者头疼的地方，尽管现在有高速缓存器来进行弥补，但数据的存取在运算过程中还是尽量能少就少。</p><p>因此，<strong>将源代码中读取、写入的部分和运算的部分分开（最好在运算前就读入所有必需的数据、在所有运算后才写入必要的数据），能够让处理器的性能发挥到最大</strong>（这个优化也可以由编译器完成）。这种方法就称为代码调度（Scheduling）。</p><p>例如 15.5.1 中的代码还可以继续优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    B0 = B[i]; B1 = B[i + <span class="number">1</span>]; B2 = B[i + <span class="number">2</span>]; B3 = B[i + <span class="number">3</span>];</span><br><span class="line">    C0 = C[i]; C1 = C[i + <span class="number">1</span>]; C2 = C[i + <span class="number">2</span>]; C3 = C[i + <span class="number">3</span>];</span><br><span class="line">    A[i  ] = B0*k + C0;</span><br><span class="line">    A[i+<span class="number">1</span>] = B1*k + C1;</span><br><span class="line">    A[i+<span class="number">2</span>] = B2*k + C2;</span><br><span class="line">    A[i+<span class="number">3</span>] = B3*k + C3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，这样的操作对于有些情况也不适用，比如在一些业务逻辑下，读取操作必须在一群算数运算之间出现。</p><h4 id="15-5-3-Benchmark-Example"><a href="#15-5-3-Benchmark-Example" class="headerlink" title="15.5.3 Benchmark Example"></a>15.5.3 Benchmark Example</h4><p>为了展示上面所有优化方法的效果，我们举个例子。</p><p>先以一个结构体数据类型为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* data structure for vectors */</span></span><br><span class="line"><span class="comment">/* we can use different declarations for data_t */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">data_t</span> *data;</span><br><span class="line">&#125; vec;</span><br></pre></td></tr></table></figure><p>其中的一个函数是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retrieve vector element and store at val. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_vec_element</span><span class="params">(vec* v, <span class="type">size_t</span>, idx, <span class="type">data_t</span>* val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= v-&gt;len) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">/* Out of range. */</span></span><br><span class="line">    *val = v-&gt;data[idx];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个函数进行<strong>基准测试（Benchmark Computation）</strong>：</p><ul><li><p>测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine1</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    *dest = IDENT;                        <span class="comment">/* IDENT macro */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; v-&gt;len; i++) &#123;</span><br><span class="line">        <span class="type">data_t</span> val;</span><br><span class="line">        get_vec_element(v, i, &amp;val);</span><br><span class="line">        *dest = *dest OP val;            <span class="comment">/* OP macro */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将使用不同数据类型（<code>data_t</code> 分别是 <code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>），针对不同运算和值（<code>OP</code> 分别是 <code>+</code>、<code>*</code>，<code>IDENT</code> 分别是 0、1）；</p></li><li><p>测试指标：<strong>CPE (Cycle Per Element)</strong></p><ul><li>Convenient way to express performance of program that operates on vectors or lists.</li><li><strong>在这里，CPE 就是一个时钟周期中的进行 <code>OP</code> 运算的次数，总时长指标 <code>T = CPE * n + Overhead</code></strong>（这里 overhead 就是 n = 0 时的基础开销）；</li><li>tips: 在检查代码性能时，不应该以真实时间做单位（例如 nanosecond），应该使用处理器内部时钟周期作为单位更有用。因为开发者无法控制处理器频率，但是可以控制并衡量操作的时钟周期。</li></ul></li><li><p>基准测试结果：</p><ul><li><code>-O0</code> 级别下，平均每个元素花费约 20 个时钟周期（T-n 图斜率）；</li><li><code>-O1</code> 级别下，平均每个元素花费约 10 个时钟周期；</li></ul></li></ul><p>现在进行在 15.3 中出现的与机器无关的基础优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;        <span class="comment">/* 将可能重复计算的部分提出循环 */</span></span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)    <span class="comment">/* 不使用额外的 procedure 来重复检查 v-&gt;len */</span></span><br><span class="line">        t = t OP d[i];</span><br><span class="line">    *dest = t;                    <span class="comment">/* 不直接在循环内给数组赋值，使用 local variable */</span></span><br><span class="line">&#125;                                <span class="comment">/* 暗示编译器没有 memory alias */</span></span><br></pre></td></tr></table></figure><p>结果在 <code>-O1</code> 级别下，<strong>加法平均每个元素花费的时钟周期降至 1.2 左右，整数乘法降低至 3 左右，浮点数乘法降低至 5 左右</strong>；</p><p>这个时候，我们再考虑与机器相关的优化，比如 unrolling loops：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unroll2a_combine</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>)</span><br><span class="line">        t = (t OP d[i]) OP d[i+<span class="number">1</span>];        <span class="comment">/* Loop Unrolling (2x1). */</span></span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可惜的是，只有加法运算获得了比较明显的提速（平均每个元素花费的时钟周期降至 1 个时钟周期），但是其他的 3 则运算没有获得显著提升。这可能是原来的代码在计数循环上的开销比较大，而现在的加法运算更加接近计算机性能利用的极限范围了；对于其他运算（乘除等），还是逐级运算，即后一阶段依赖前一阶段的结果，所以速率仍没有提升。</p><p>但是，如果做出如下 “优化”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unroll2aa_combine</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>)</span><br><span class="line">        t = t OP (d[i] OP d[i+<span class="number">1</span>]);        <span class="comment">/* ??? */</span></span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交换了循环中的运算次序，会发现整型加法性能提升到 0.5，整型乘法、除法更是提升到 1 左右（<strong>实际上，浮点数乘法和整型加法一样快，这是因为在 6.3.2 中介绍的 “浮点数寄存器的结构” 导致的</strong>：一个浮点数寄存器可以同时处理 2 个乘法、1 个加法）。因为，这里我们交换的运算次序有点特殊，它改变了整体的运算流程（如图），使得整体的运算效率可以提高 1 倍：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/seq1.png" width="350px"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/seq2.png" width=350px></p><p>因为 <code>d[i] * d[i + 1]</code> 的无依赖性，所以这二者的积运算在 CPU 中可以更早地运算，节省下来大量时间。</p><p><strong>但对于这种转换而言，编译器通常不会对浮点数进行优化。这是因为这种转换改变了语义——如果是浮点数运算，并且存在舍入的情况，那么是不满足分配律的</strong>。这就意味着，在存在浮点数舍入的情况下，这种“优化方法”会导致错误的结果，所以应该由编程人员自行判断舍入情况，并优化。</p><hr><p>其实，我们除了这种 unrolling 的方式以外，还可以更进一步，使用 <strong>Separate Accumulators</strong>，将偶数和奇数索引的数据分开，减少值依赖的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unroll2a_combine</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> x0 = IDENT;</span><br><span class="line">    <span class="type">data_t</span> x1 = IDENT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Combine 2 elements at a time. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        x0 = x0 OP d[i];</span><br><span class="line">        x1 = x1 OP d[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Finish any remaining elements. */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)z</span><br><span class="line">        x0 = x0 OP d[i];</span><br><span class="line">    *dest = x0 OP x1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/seq3.png" height="400px"></p><p>这就是两个临时变量的分段累计（unrolling loops 2x2）。所以，更一般的思路是：</p><ul><li>unrolling to degree L；</li><li>accumulate K results and <strong><code>K mod L == 0</code></strong>；</li></ul><p>在考虑完这种情况下的限制之后，接下来更基本的限制就是 <strong>程序基本开销</strong> 和 <strong>吞吐量限制</strong>，后者是在硬件数量和性能层面——某些硬件的 I/O 速度最大只有那么快，我们依靠源码和汇编层面的小修小改是没有办法继续提升的。</p><p>不过在更新的 CPU 上，我们在浮点数寄存器 <code>%xmm</code>（16 bytes，128 bits）的基础上，增添了16 个 <code>%ymm</code>（32 bytes，256 bytes）大小的浮点数寄存器，这类寄存器不使用 <code>SSE3</code> 指令，而是用 <code>AVX2</code> 指令，整体数据承载量、并行运算量都大于原来的情况。</p><p>所以我们可以根据 AVX 指令的特征，对上面代码继续进行修正（向量化代码），充分利用其并行运算的特点，理论上还能得到提升。</p><p>这些根据 AVX 指令来编写向量化的代码（unrolling loops），就是在一些游戏、音视频处理软件的领域内，对于框架中的代码做的优化的一种方式。</p><h3 id="15-6-Summary"><a href="#15-6-Summary" class="headerlink" title="15.6 Summary"></a>15.6 Summary</h3><p>本章讲述了一些程序优化的基本思路，主要从两个方向描述。</p><p>一个是与机器无关方向的优化小技巧，而这些技巧也常常会内置在编译器中，成为编译工作的一个部分。它们大致可以分为以下几类：</p><ul><li>局部的优化：例如 <strong>常数折叠、计算强度减小（通过更换运算符实现）、死代码剔除、局部的相近表达式复用消除</strong>；</li><li>全局的优化：例如 <strong>循环结构转换、代码移动（减少不必要的运算）、内联化、全局的相近表达式复用消除</strong>；</li></ul><p>在这个方面，我们考虑了相反的情况——什么样的编码会阻碍编译器帮助我们进行上面的优化。</p><ul><li>Procedure Calls：我们应该在代码设计时，充分考虑函数调用的位置对于性能影响；</li><li>Memory Alias：尤其是在循环结构中，多使用局部变量暂存中间结果，或者使用更严格的关键字；</li></ul><p>这都在提醒我们编码时，能尽早确定的定值，尽量存在局部变量中，以防编译器认为中间存在变数，而不敢于进行优化。</p><p>另一个是与具体机器有关方向的优化技巧（但是目前世界上的机器种类就这些，所以理论上也有一定的普适性，例如 ARM 架构和 x86 架构都能使用这种优化来提升性能），编译器不一定会帮你做这些优化，这是因为这些方法有着各自的局限性。</p><p>我们分析了现代 CPU 的结构特性，找到了 2 处可以进行优化的地方，一个是分支预测的部分，另一个是代码中的 I/O 调度。</p><p>首先我们了解了分支预测器的原理和性质，我们发现想要弥补 Branch Misprediction Penalty，就需要从两个方面入手：</p><ol><li>让它少预测点，就少错一点（减少分支结构）。这方面的方法大致有 <strong>循环转换、unrolling loops 和 conditional moves</strong>；</li><li>提升它预测的正确率。依从分支预测器的原理，我们可以让每次产生的分支判断的结果有迹可循。总的来说，我们可以通过<strong>为需要的判断数据排序</strong>（局限性强）、<strong>减少编码一些难以预测的结构</strong>（例如函数指针判断、虚函数）。</li></ol><p>在 I/O 调度方面我们发现，CPU 频繁地从高速缓存器中读入和写出数据也会降低程序性能，因此在编码过程中写出能够让汇编码中读内存次数越少的源码越好。因此，这里的重要建议是<strong>将源代码中读取、写入的部分和运算的部分分开（最好在运算前就读入所有必需的数据、在所有运算后才写入必要的数据）</strong>。</p><p>本章最后举了一个对矢量行进行基准运算的例子，说明了上面方法所能够带来的性能提升。尤其是介绍了 unrolling loops 和 流水线的思想。</p><h2 id="Chapter-16-Exceptional-Control-Flow"><a href="#Chapter-16-Exceptional-Control-Flow" class="headerlink" title="Chapter 16. Exceptional Control Flow"></a>Chapter 16. Exceptional Control Flow</h2><blockquote><p>对应书中第 8 章。</p></blockquote><p>异常控制流是现代计算机系统的一个相当重要的部分。</p><h3 id="16-1-Control-Flow"><a href="#16-1-Control-Flow" class="headerlink" title="16.1 Control Flow"></a>16.1 Control Flow</h3><ul><li><p>控制流：从机器打开到关闭的过程中，处理器只做一件事：<strong>读指令、执行指令，一个周期做一个指令</strong>。多核的机器则每个核心依次交替执行指令。这些<strong>指令序列</strong>被称为控制流。硬件正在执行的<strong>实际指令序列</strong>就被称为<strong>物理控制流</strong>。</p></li><li><p>改变内存中控制流的方法：<strong>分支 &amp; 跳转</strong>，<strong>过程调用 &amp; 返回</strong>（Branches &amp; Jumps &amp; Procedure call and return）；</p><blockquote><p><strong>都是对于程序状态变化的处理</strong>。</p></blockquote></li></ul><p>但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）；</p><p>什么是 “系统级别的状态变化”？</p><ul><li>数据从磁盘 / 网卡到达内存中；</li><li>I/O 设备输入 Ctrl+C；</li><li>系统分时复用的时钟到期了，接下来要打断当前执行的进程；</li><li>除零指令；</li><li>……</li></ul><p>这些事件不能指望应用程序的开发者来解决（应用程序的开发者只负责开发正常的程序控制流），而这应该是 OS 需要处理的事情。为了高效处理以上在执行程序中出现的或意外、或故意的系统级状态变更的情况，OS 有一套策略：<strong>异常控制流（Exception control flow，简称 ECF）</strong>来处理上述情况，这样很多事件就无需应用开发者来考虑了。</p><h3 id="16-2-Exception-Control-Flow-Overview"><a href="#16-2-Exception-Control-Flow-Overview" class="headerlink" title="16.2 Exception Control Flow: Overview"></a>16.2 Exception Control Flow: Overview</h3><p>异常控制流的重要特征之一在于，它们会改变系统级别的状态，<strong>而且存在于计算机系统的各个层级</strong>：</p><p>首先是底层级 ECF 的机制：</p><ol><li><strong>Exception</strong>（异常，又称 <strong>Hardware ECF（硬件异常控制流）</strong>，和我们平时编程的软件异常处理不是一个概念）<ul><li>作用：<strong>响应某些底层系统事件（A System Event）的控制流的变化</strong>；</li><li>实现方法：硬件与操作系统的配合；</li></ul></li></ol><p>再看高级别（既指抽象层面，又指逻辑层面，这意味着下面的机制可能利用到，或者包含了上面的 Exception）的 ECF 的机制：</p><ol><li><strong>Process Context Switch</strong>（进程上下文切换）<ul><li>作用：使操作系统在两个进程间无缝切换；</li><li>实现方法：硬件时钟和操作系统的配合；</li></ul></li><li><strong>Signals</strong>（信号）<ul><li>作用：应用、操作系统、硬件三者之间的异常（不是错误，而是指在上层应用程序正常控制流以外的部分）通信；</li><li>实现方法：操作系统控制；</li></ul></li><li><strong>Nonlocal Jumps</strong>（非本地跳转）<ul><li>作用：<strong>应用程序开发者层面（而非操作系统层面）主动更改程序正常控制流（上面介绍的分支跳转、调用返回），无视正常控制流的规则</strong>（例如不需要等到一个函数返回，就跳到另一个函数执行）；</li><li>实现方法：因为是用户级别，所以由 C library 提供：<code>setjmp()</code>、<code>longjmp()</code>；</li></ul></li></ol><p>了解完计算机中各个层面的 <strong>4 大类 ECF 机制</strong>，我们开始深入探讨各个机制的运作原理。</p><h3 id="16-3-Exception-Control-Flow-Exception"><a href="#16-3-Exception-Control-Flow-Exception" class="headerlink" title="16.3 Exception Control Flow: Exception"></a>16.3 Exception Control Flow: Exception</h3><h4 id="16-3-1-Definitions"><a href="#16-3-1-Definitions" class="headerlink" title="16.3.1 Definitions"></a>16.3.1 Definitions</h4><p>一个异常就是<strong>为了应对一些（软件 / 硬件的）事件，控制流由程序转移到 OS kernel 的过程</strong>。</p><blockquote><ol><li>什么是操作系统内核（OS Kernel）？</li></ol><p>内核是<strong>操作系统在内存中驻留的部分</strong>，你可以理解成当前加载到内存的、运行中的操作系统代码；</p><ol><li>Exception 定义中的 “事件” 具体有哪些？</li></ol><ul><li>除零、算数溢出、page fault（页错误）、I/O 请求完成、键盘设备输入 Ctrl + C；</li><li>……</li></ul></blockquote><h4 id="16-3-2-Process-Procedure"><a href="#16-3-2-Process-Procedure" class="headerlink" title="16.3.2 Process Procedure"></a>16.3.2 Process Procedure</h4><p>Exception 的处理过程如下：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/exception_flow.png" height="200px"></p><ol><li><p>如图所示，因为以上的事件（event）而改变了系统状态，执行到 $I_{current}$ 的用户代码被立即暂停，此时 exception 将控制权从用户代码转移到内核态代码。这部分内核代码被称为 <strong>exception handler（异常处理程序）</strong>；</p></li><li><p>接着，内核执行异常处理程序代码来处理这个事件，过程被称为 <strong>exception processing（异常处理）</strong>；</p></li><li><p>处理结束后，通常有 3 种情况：返回到原先被打断的指令位置（$I_{current}$，已执行）、返回到被打断的指令的下一条（$I_{next}$，未执行）、终止原用户程序执行。</p></li></ol><h4 id="16-3-3-Implementations-of-Exception"><a href="#16-3-3-Implementations-of-Exception" class="headerlink" title="16.3.3 Implementations of Exception"></a>16.3.3 Implementations of Exception</h4><p>前面介绍过，Exception 是由 OS 和硬件共同实现的，那么具体实现是什么？</p><p>事实上，控制流想要改变，必须依靠硬件改变程序计数器（PC，或者说前面提到的 <code>%rip</code>）。由于 Exception handler 的代码又位于 Kernel code 中，所以实现就很清楚了：</p><ol><li><p><strong>OS 负责组织 Exception Handler 的代码，来处理可能的 Exception</strong>；</p></li><li><p><strong>硬件负责在 Event 出现的时候改变 <code>%rip</code>，使控制流转向 Exception Handler</strong>；</p></li></ol><p>等等，还有一个问题，OS 会预先编写很多类 Exception Handler 以应对不同 Exception 的情况，那么硬件在 Event 发生时，怎么知道转向哪一个 Exception Handler？所以还有一条、再改正一条：</p><ol><li><p><strong>硬件负责在 Event 出现时按种类改变 Exception Table Base Register，通过这个寄存器取得 Exception Table 中存放的 Exception Handler 的地址（硬件规定是虚拟地址），把取得的地址置于 <code>%rip</code> 中，完成转向</strong>；</p></li><li><p>OS 负责在 Kernel 中组织 <strong>Exception Table（异常表）</strong>，告诉硬件何种 event 对应何种 Exception Handler 的地址；</p></li></ol><blockquote><p>什么是 异常表？</p><p>OS 为了将每种 Event 产生的 Exception 与 Exception Handler 对应起来，将每种类型的事件进行编号。<strong>每种类型的事件对应位于的 异常编号（Exception Number，又称为中断向量，Interrupt Vector）</strong>，这个编号被作为一个跳表的索引，而表中装的是各个对应的 Exception Handler 的地址。这个表就称为 <strong>异常表</strong>。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/exception_table.png" height="300px"></p></blockquote><h4 id="16-3-4-Types-of-Exceptions"><a href="#16-3-4-Types-of-Exceptions" class="headerlink" title="16.3.4 Types of Exceptions"></a>16.3.4 Types of Exceptions</h4><p>上面我们提到过，在 Exception 的处理过程中，最后可能会发生 3 种情况（$I_{current}$、$I_{next}$、abort），这是因为具体发生的 event 不同，其 Exception Handler 的处理方式也不同。所以，我们有必要了解一下 Exception（或者说对应的 event）有哪些种类，exception handler 的默认行为又有哪些。</p><p><strong>Asynchronous Exceptions（异步异常）：又称 Interrupt（中断）</strong></p><ul><li>引发的 Event 的种类：<strong>来自处理器外的事件。通常是 I/O 设备发出的</strong>；</li><li>例子：<ul><li>I/O 设备中断事件（数据从磁盘、网卡等外部设备已到达内存的通知，键盘 Ctrl+C 等）；</li><li>系统分时复用时钟中断（Timer Interrupt），OS 在硬件时钟中定时，要求从用户程序切换到内核中，以便让 OS 取得控制权（这个是<strong>为进程上下文切换提供条件</strong>，让系统决定是否要进行进程上下文切换）；</li></ul></li><li>触发方法 / 系统状态如何改变：电脉冲通知处理器的 <strong>中断引脚</strong>；</li><li>触发后默认行为：<ul><li>可能与当前运行程序无关事件，从 $I_{next}$ 继续向下运行（<strong>recoverable</strong>）；</li></ul></li></ul><p><strong>Synchronous Exceptions（同步异常）</strong></p><ul><li>引发的 Event 的种类：<strong>因为处理器执行某条指令而造成的事件</strong>；</li></ul><p>而同步异常又可以分为几个种类：</p><ol><li><p>Traps（陷阱）</p><ul><li><p>触发方法：<strong>执行程序故意触发系统级别 Exception</strong>；</p></li><li><p>例子：<strong>system calls（系统调用）、breakpoint traps（程序断点）、特殊指令</strong>；</p><blockquote><p><strong>什么是系统调用？</strong></p><p>应用程序的某些功能可能需要使用一些硬件设备，例如 I/O 设备。而这些驱动硬件的程序则嵌在 OS Kernel 中。</p><p>但另一方面，由于安全问题，人们在系统中划分了若干特权级：Ring 0 ~ Ring 3，数字越大，权限越低。应用程序运行在 Ring 3 级别，因此不能直接调用内核函数、无法访问内核数据（位于 Ring 0 级别），因此无法直接使用 I/O 设备。</p><p>那么应用程序为了完成一项使用 I/O 设备的工作，只能调用 OS 准备的专门的接口（称为系统服务）来通知 OS 协助完成。这个过程被称为 <strong>系统调用</strong>。</p><p><strong>系统调用的详细过程？</strong></p><p>首先，系统调用就是调用系统接口的过程，咱首先得了解 x86-64 架构下系统调用有哪些接口。以 x86-64 Linux 为例：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/system_calls.png" height="250px"></p><p>每一个系统调用接口都有一个唯一的编号，这个编号由 OS 分配，例如 <code>read</code> 是 0 号；</p><p>以打开文件这个 I/O 操作为例，应用程序想要将磁盘中的数据读到内存中，那么：</p><ol><li><p>程序先调用 C library 封装好的函数 <code>open/fopen</code>；</p></li><li><p>C library 的 <code>open/fopen</code> 经过几层包装，接着调用系统接口 <code>__open</code>（上面的 2 号系统调用），其汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000000e5d70 &lt;__open&gt;:</span><br><span class="line">...</span><br><span class="line">e5d79: b8 02 00 00 00         mov $0x2,%eax # openis syscall #2</span><br><span class="line">e5d7e: 0f 05                 syscall # Return value in %rax</span><br><span class="line">e5d80: 48 3d 01 f0 ff ff     cmp $0xfffffffffffff001,%rax</span><br><span class="line">...</span><br><span class="line">e5dfa: c3 retq</span><br></pre></td></tr></table></figure><p>我们可以看到，系统调用的 calling conventions 与普通函数不一样：</p><ul><li><strong>第一传入参数必须是 系统调用编号，并且存放在 <code>%rax</code> 中</strong>，这里是 2，表示 2 号系统调用；</li><li><strong>其他传入参数依此放在：<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%r10</code>、<code>%r8</code>、<code>%r9</code></strong>；</li><li><strong>返回值也放在 <code>%rax</code> 中</strong>；</li><li><strong>使用 <code>errno</code> 宏来记录系统调用的状态或错误情况</strong>；</li><li><strong><code>%rcx</code> 、<code>%r11</code> 可能被破坏：<code>%rcx</code> 存放 $I_{next}$ 地址方便返回，<code>%r11</code> 用于存放 <code>rflags</code>，也即当前程序的 conditional codes</strong>；</li></ul></li><li><p>当处理器执行到系统调用汇编指令时，触发 <code>Trap</code>（Exception），相应值传入 Exception Table Base Register；硬件通过该寄存器找到 Exception table 中的相应 Exception handler（x86-64 通常是 software interrupt exception handler），将 <code>%rip</code> 地址改为该 handler 的地址，于是控制流转向 OS Kernel；</p></li><li><p>OS Kernel 处理系统调用的 exception handler 会按之前的 conventions 读取各参数值，执行对应系统调用服务。完成后，先切换特权级等信息，再读取 <code>%rcx</code> 和 <code>%r11</code> 中的信息，将控制流转交给 user mode 中原程序的 $I_{next}$；</p></li><li><p>最终系统调用成功返回的话，open 返回一个 <strong>file descriptor（文件描述符，一个区别已打开文件的小整数编号）</strong>，以供后续读写调用使用。</p></li></ol></blockquote></li><li><p>触发后默认行为：从 $I_{next}$ 继续向下执行（<strong>recoverable</strong>）；</p></li></ul></li><li><p>Faults（错误）</p><ul><li><p>触发方法：程序执行了一条指令，<strong>无意引发了硬件或软件层面的问题</strong>，从而产生 Exception；</p></li><li><p>例子：<strong>page fault（页错误，possibly recoverable）</strong>、<strong>protection fault（访问权限错误，unrecoverable）</strong>，<strong>floating point exceptions（浮点异常，例如除零错，unrecoverable）</strong>；</p><blockquote><p><strong>什么是页错误 和 访问权限错误？</strong></p><p>首先在 10 ~ 14 章中，我们介绍了物理内存和虚拟内存。操作系统为了将离散、有限的资源抽象为连续、近乎无限的资源给应用程序使用，并将各个程序隔离开，使用了复杂的策略。</p><p>在<strong>内存的使用</strong>层面，操作系统和硬件配合引入了 “虚拟内存” 的概念，操作系统维护了一个从物理内存（简称 PM）到虚拟内存（简称 VM）的映射（还记得 Chapter 8 最后介绍的 TLB cache 吗？就是为这个准备的），<strong>将主存（main memory）上离散的空间映射到连续的虚拟内存空间上</strong>。</p><p>这个 “映射” 存在处理器芯片的 MMU（Memory Managing Unit） 中，这个映射的数据结构被称为 <strong>页表</strong>。为了充分利用主存（物理内存）的空间，页表将 PM 和 VM 切分为很小的块（大家能懂往瓶子里装石子、沙子、水的道理吧？），这些很小的数据块被称为 <strong>页</strong>，而页表就是将这些虚拟内存页映射到物理内存页，如下：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/page_table.png" height="300px"></p><p>那么这样能同时完成两个目标：</p><ul><li>充分利用有限物理空间，为应用程序提供连续的虚拟空间；</li><li>每个应用程序间的虚拟内存很容易实现隔离（页表数据不同就行，这样哪怕相同的虚拟地址，映射到的物理地址也不同），相互不影响对物理内存的访问。</li></ul><p>每个应用程序所能看到的就是完整的虚拟内存，其中有独立的运行时栈。运行在 CPU 上的应用程序也直接使用虚拟地址，因为 VMA 出 CPU 前会经过 MMU 转换为物理地址，再向硬件请求。</p><p>但是！为了节约空间，操作系统不会一次性将全部的虚拟内存（地址 0 ~ FFFFFFFF）全部用页表映射上物理内存（一来大小不够，二来浪费资源），只是先为虚拟内存的必要部分（例如程序栈的 data 段、code 段、shared libraries 段、stack 段等）分配物理内存、记录在页表上。其余部分被称为<strong>未被分配的段</strong>。这个有 2 种可能：</p><ul><li>应用程序没有权限（执行 kernel space 段，或执行了标记为不可执行的栈区），或这里确实不应该有数据；</li><li>应用程序确实向操作系统申请了大量空间，不过有些还没使用过，OS 自己还<strong>没有</strong>将这段区域通过页表建立与物理内存的映射。</li></ul><p>所以，当程序指令访问上述 2 种段的时候，硬件发现在页表中找不到对应的物理地址，于是发出一个 Synchronous Exception，其类型是 Page Fault。</p><p>如果是因为访问了上面第一种情况的 “未分配的段”，那么在进入 Exception Handler 后，操作系统发现程序确实不应该访问这里，那么操作系统向原进程<strong>发送 SIGSEGV 信号 / SIGGPF 信号（Segmentation Fault 软件信号，或者 Protection Fault 软件信号，前面介绍过，这些信号是另一种 ECF 机制，下下节讨论）</strong>，控制流直接离开原程序（abort），属于 <strong>unrecoverable</strong> 类型；</p><p>如果是因为访问了上面第二种情况的 “未分配的段”，那么操作系统发现是自己没分配，于是在 Exception Handler 中，OS 会将一段新的物理地址分配给虚拟内存，记录在页表中，<strong>回到 $I_{current}$ 的位置</strong>，属于 <strong>recoverable</strong> 类型；</p></blockquote></li><li><p>触发后默认的行为：回到 $I_{current}$（recoverable），或者终止（unrecoverable）；</p></li></ul></li><li><p>Aborts（终止）</p><ul><li><p>触发方法：程序执行了一条神奇的指令，硬件层面严重错误，操作系统对应的 Exception Handler  也没辙，默认行为就是终止程序；</p></li><li><p>例子：<strong>illegal instruction（非法指令，通常因为低特权程序执行了高特权指令，或者压根汇编指令就有问题）、parity error（硬件奇偶校验错误）、machine check（硬件检查未知错误）</strong>；</p><blockquote><p>后两种可能是机器被宇宙射线击中，发生了 bits flop，或者硬件电路出问题了；</p></blockquote></li><li><p>默认行为：<strong>abort（unrecoverable）</strong>；</p></li></ul></li></ol><h4 id="16-3-5-Summary-of-Exception"><a href="#16-3-5-Summary-of-Exception" class="headerlink" title="16.3.5 Summary of Exception"></a>16.3.5 Summary of Exception</h4><p>16.3 中，我们介绍了非常底层级的一种硬件 ECF 机制：Exceptions，请大家回忆：<strong>Exception 的 概念、处理过程、实现方法、种类以及各种类之间的处理模式</strong>。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/exception_taxonomy.png" height="200px"></p><table>    <tr>        <th>Exception Type</th>        <td>Interrupt</td>        <td>Traps</td>        <td>Faults</td>        <td>Aborts</td>    </tr>    <tr>        <th>Recoverable</th>        <td>✔</td>        <td>✔</td>        <td>Possibly</td>        <td>❌</td>    </tr>    <tr>        <th>Return to</th>        <td>I next</td>        <td>I next</td>        <td>I current / abort</td>        <td>abort</td>    </tr></table><p>这种低层级的控制转移可以由操作系统和硬件联合实现，也是其他高级 ECF 机制的基础。</p><h3 id="16-4-Exception-Control-Flow-Process-Context-Switch"><a href="#16-4-Exception-Control-Flow-Process-Context-Switch" class="headerlink" title="16.4 Exception Control Flow: Process Context Switch"></a>16.4 Exception Control Flow: Process Context Switch</h3><p>要了解进程上下文切换，首先要了解什么是进程。</p><h4 id="16-4-1-Process"><a href="#16-4-1-Process" class="headerlink" title="16.4.1 Process"></a>16.4.1 Process</h4><ul><li><p>定义：一个进程是一个正在运行的程序的实例。</p><blockquote><p>与程序（program）不同，程序可以看作存在于 <code>*.c</code> 文件中的、存在于二进制文件的 <code>.text</code> 区域的、存在于已加载内存的字节中。</p><p>进程是计算机科学中最为影响深远的思想之一。</p></blockquote></li><li><p>进程的 3 种状态：Running、Blocked（Stopped）、Terminated</p></li><li><p><strong>进程提供的 2 个关键抽象</strong>：</p><ol><li><p>Logical Control Flow：</p><ul><li>每个进程都感觉自己独占了 CPU 资源，不用担心寄存器、CPU 的重要数据被更改；</li><li>这种逻辑上的控制流的隔离机制来源于 <strong>OS 内核和硬件提供的重要 ECF —— Process  Contest Switching</strong>；</li></ul><blockquote><p>啥是 Logical Control Flow，在本节结束后你就会知道。</p></blockquote></li><li><p>Private Address Space：</p><ul><li>每个进程都感觉自己独占了主存资源，不用担心别的程序未经同意访问自己的资源；</li><li>这种隔离机制来源于 <strong>OS 和硬件提供的重要抽象：Virtual Memory</strong>（前面说过）；</li></ul></li></ol><p>以上的两个抽象为操作系统提供了<strong>多进程执行与并发（Multiprocessing &amp; Concurrency）的能力</strong>。</p></li><li><p>基于上面 2 条关键抽象，我们的进程满足：</p><ol><li>有整套独立的虚拟内存空间，互不干扰；</li><li>有看起来能够持续执行的 CPU 及稳定的寄存器资源；</li></ol></li></ul><h4 id="16-4-2-How-does-Multiprocessing-work-on-single-processor"><a href="#16-4-2-How-does-Multiprocessing-work-on-single-processor" class="headerlink" title="16.4.2 How does Multiprocessing work on single processor ?"></a>16.4.2 How does Multiprocessing work on single processor ?</h4><p>那么，操作系统是如何同时运行多个进程的呢？我们以仅有一个处理器核为例。</p><p>我们在 16.3.4 中曾经提到过 “系统时钟中断和分时复用”。操作系统想要随时能够取得控制权，就需要<strong>借助硬件时钟，每隔一段时间触发一次时钟中断（interrupt）的 exception，让程序从用户态回到内核态</strong>，由操作系统判断情况，是否要进行一些调度或者切换等处理操作。</p><p>为了充分利用 CPU 等资源，同时运行多个进程，操作系统对每个进程的单次执行时间设置较短（大约 1 ms 量级），<strong>一旦该进程执行时间片耗尽</strong>，那么操作系统会<strong>借助时钟中断的机会</strong>触发一种高级的 ECF: Process Context Switch，将处理器上下文数据切换到另一个进程继续执行。</p><p>这里 “进程的上下文数据” 就是 <strong>能够让系统处理器从其他进程回到当前进程所需额外的数据</strong>。由于每个进程独享一段虚拟内存，所以原本在虚拟内存中的上下文数据无需另外保存。所以，进程的上下文数据一般指 <strong>处理器芯片中的各个寄存器的值、内核数据结构（页表、进程表、文件表等，都放在 kernel space 中）以及各进程虚拟内存总体的物理位置</strong>。</p><p>那么这样也不难理解为什么 OS 和硬件能做到在各个进程之间的无缝切换了。我们小小总结一下：</p><ul><li><p>什么是 Process Context Switch？</p><p>进程上下文切换是指 OS 和硬件 控制处理器保存在当前进程的上下文数据，并切换到另一个进程继续执行的过程。这种交替执行的方式被称为 <strong>interleaving</strong>；</p></li><li><p>为什么需要 Process Context Switch？</p><p>这能够让操作系统利用有限的 CPU 执行多进程任务（multiprocessing），充分利用系统资源，也不至于让一个进程卡死就波及到其他进程的执行。也就是说，<strong>interleaving 可以实现 multiprocessing</strong>；</p></li><li><p>什么时候出现 Process Context Switch？</p><ol><li><strong>（必定）当 Hardware Timer 触发了时钟中断 Exception</strong>；</li><li><strong>（必定）当该进程出现耗时的系统调用</strong>（通常是类似 <code>read/write/sleep</code> 的系统调用）时，哪怕该进程时间片没耗尽，操作系统依然会 suspend 这个进程（进程转为 blocked 状态）；</li><li><strong>（可能）当该进程出现了普通的系统调用</strong>，控制权流转到 OS Kernel 中，操作系统会根据情况（例如优先级等情况）选择是否进行进程上下文切换。</li></ol><blockquote><p>我们发现，这三种原因全都是 <strong>Exception</strong>，因此说底层 Hardware ECF 为高级 ECF 提供了基础条件。</p></blockquote></li><li><p>底层的 Process Context Switch 如何实现 / 进行的？</p><p>step 1. 因为上面所述的 3 种原因之一，当前进程执行到某一位置时暂停，并暂时转移到内核态，控制流交给 OS；</p><p>step 2. OS 判断当前是否应该进行 Process Context Switch，如果不是，则退出内核态，恢复原程序执行。不过大部分情况是应该进行切换的，因此进入下一步；</p><p>step 3. 确认要进行进程切换后，操作系统会评估各个进程的<strong>优先级、进程状态等信息</strong>，按照评估结果决定切换到哪个进程上，这个做出决定的内核程序段被称为 <strong>scheduler</strong>；</p><p>step 4. 操作系统在切换前找到原进程的信息，将上下文的处理器中的各个寄存器值存入该进程的虚拟内存中，然后转到 scheduled process 中，从 scheduled process 的虚拟内存中读出处理器的上下文数据，继续执行 scheduled process，过程如下：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/context_switch.png" height="200px"></p></li><li><p>在 Context Switch 中需要注意的是：</p><ul><li>OS Kernel 并不是一个单独的进程，OS Kernel 的数据存在于每个进程中，作为它们的一部分。通常数据位于各进程虚拟内存 <strong>栈区的下层（用户态不可访问）</strong>；</li></ul></li></ul><h4 id="16-4-3-Concurrency-amp-Parallelism-amp-Interleaving"><a href="#16-4-3-Concurrency-amp-Parallelism-amp-Interleaving" class="headerlink" title="16.4.3 Concurrency &amp; Parallelism &amp; Interleaving"></a>16.4.3 Concurrency &amp; Parallelism &amp; Interleaving</h4><p>之前我们讨论的实现 multiprocessing 的方式是 interleaving，而计算机科学中还有两个概念叫 <strong>并发（concurrency）和 并行（parallelism）</strong>，它们之间的关系是什么？我们来对比一下：</p><ul><li>并发：指<strong>在一个较短的时间内同时执行多条任务或进程</strong>，它是一种<strong>执行策略</strong>，我们可以由多种方案来实现这个策略；</li><li>交织（interleaving）：指<strong>交替（在时间上 sequential）执行多条任务或进程，但 “appeals to”（看起来像是）同时在执行所有任务</strong>，这个名词通常被用作多任务或分时复用的系统中，表明<strong>处理器短时间内在不同任务间切换以达到同时执行的效果</strong>。</li><li>并行：指<strong>严格同时地执行多条任务或进程</strong>，主要的目标是利用<strong>多核 / 多处理器</strong>共同工作的杠杆作用来同时地执行任务，提升系统性能；</li></ul><p>我们将上面的概念解析成几个容易理解的观点：</p><ol><li>并发是一个很广的概念，它可以通过多种机制实现，比如 并行（simultaneous execution）、交织（sequential execution with rapid switching），所以说 <strong>并行和交织都是实现并发的途径</strong>；</li><li>交织则强调在一个处理器上，充分利用有限资源执行多个任务，而并行则强调在多个处理器相互协作，同时处理不同的任务，达到 1+1 &gt; 2 的效果；</li></ol><p>可能还有同学会问，那多进程（multiprocessing）和它们又有啥关系？</p><p>实际上，我们上面讨论的都是抽象层面的策略和方案，它们可以针对计算机系统中的进程，也可以针对其他的任务。所以<strong>并发、并行、交织都是实现多进程的思路之一</strong>。</p><h4 id="16-4-4-Concurrent-Process"><a href="#16-4-4-Concurrent-Process" class="headerlink" title="16.4.4 Concurrent Process"></a>16.4.4 Concurrent Process</h4><p>理解了并行、并发、交织的概念后，我们再来看<strong>进程的并发</strong>。进程的并发有以下重要的概念：</p><p>首先我们在 16.1 中介绍过，物理控制流（大家回忆一下）是指硬件上正在执行的实际指令序列。现在，我们将每一个进程都看作一个 <strong>Logical Control Flow</strong>（逻辑控制流），所谓逻辑控制流就是<strong>从这个进程的开始到最终 terminated 的全过程</strong>（包括中间 blocked 的部分）。画一对图大家就理解了：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/physical_control_flow.png" height="200px"></p><p>如上图，假设在一个处理器上，进程 A、B、C 的物理控制流如图所示。我们可以看到这采取了一种多进程交替执行的方式实现了进程的并发。所以它所对应的逻辑控制流是：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/logical_control_flow.png" height="200px"></p><p>我们可以形象地理解，进程逻辑控制流就是将它的物理控制流从头至尾连接起来。</p><blockquote><p>注意：如果 <code>graph 2</code> 是物理控制流，那么这个行为就是多核并行了。</p></blockquote><p>在这个基础上，我们做出如下定义：</p><ul><li>如果两个进程的逻辑控制流在时间上相互重叠（overlap in time），那么称这两个进程是<strong>并发执行</strong>（concurrently）的；</li><li>否则称这两个进程是<strong>顺序执行</strong>（sequentially）的；</li></ul><h4 id="16-4-5-Process-Control"><a href="#16-4-5-Process-Control" class="headerlink" title="16.4.5 Process Control"></a>16.4.5 Process Control</h4><p>在了解很多进程的理论后，我们需要转向实践层面的学习。现代 Linux 系统提供了很多控制进程的<strong>系统级函数</strong>，这些函数操作进程的过程称为 “<strong>进程控制</strong>”，而这些<strong>系统级函数最终大多数都会进行系统调用</strong>。</p><p>以 x86-64 Linux 为例，大多数系统函数的规范是：</p><ul><li><p>如果执行出错，则返回 <strong>-1</strong>，同时设定全局宏 <code>errno</code> 来提示出错的原因。</p><blockquote><p>因此在使用系统级函数时，有一个约定俗成的硬性规定（hard and fast rule）：<strong>当调用系统级函数后，必须检查其返回值，已确认其是否正确执行</strong>。</p><p>某些特别的系统级函数除外，例如 <code>exit</code>、<code>free</code> 返回 <code>void</code> 类型；</p></blockquote></li></ul><p>首先遇到的第一个进程控制的系统级函数，用于<strong>复制 / 创建进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>作用：复制一个与当前进程一模一样的进程。复制出的进程被称为原进程的<strong>子进程</strong>，父进程的含义不解释。</p></li><li><p><strong>注意，一模一样是进程的虚拟内存中的几乎所有数据都一致，但父进程和子进程虚拟内存相互独立（相当于 deep copy）</strong>；</p><ul><li>虚拟地址、进程总体程序栈数据都一样；</li><li>文件标识符直接可以继承使用，也就是可以访问任何父进程已打开的文件；</li><li>父、子进程间 PID、页表等信息不一致；</li></ul></li><li><p>返回值：<strong>在父、子进程中分别返回一次。</strong></p><ul><li>当创建进程失败后，返回 -1；</li><li>当进程创建成功，且当前进程为父进程时，返回<strong>子进程的 PID（正整数）</strong>；</li><li>当进程创建成功，且当前进程为子进程时，返回 <strong>0</strong>；</li></ul></li><li><p>⚠ 使用提示：</p><ol><li><p>此方法创建的新进程与原进程的<strong>运行的顺序和同步性完全不能保证</strong>（即在逻辑控制流中没有明确先后关系）。因此输出时序具有随机性，在编程时不应该假设二者的执行顺序；</p></li><li><p>适宜使用<strong>树状拓扑图的结构</strong>（这被称为 <strong>进程图，process graph</strong>）分析存在多个 fork 进程控制的情况；</p><blockquote><p><strong>进程图的使用方法</strong></p><p>一个进程图是分析<strong>并发程序</strong>的语句<strong>部分执行顺序</strong>的有力工具。</p><ul><li>进程图是一个有向无环图（DAG，没有自环、重边），图的每个顶点代表每条语句的执行情况；</li><li><code>a -&gt; b</code> 表示 a 语句发生在 b 语句之前，二者<strong>在逻辑控制流上有明确先后关系</strong>；</li><li>进程图的<strong>边</strong>可以标注当前情况下<strong>变量的值</strong>；</li><li>进程图的<strong>点</strong>可以标注当前语句的<strong>输出或其他信息</strong>；</li><li>进程图的<strong>任意一种拓扑排序与一种可能的执行顺序</strong><u><strong>一一对应</strong></u>（所有拓扑排序则代表所有所有可能的执行顺序）；</li></ul><p>这里一个常见考题：给出一个含有很多 <code>fork()</code> 的程序，要求写出输出情况；</p></blockquote></li></ol></li></ul><p>其次，我们还可以<strong>获取进程号（PID）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>二者作用：获取当前进程 / 获取父进程 PID；</li><li>返回值：当前进程 / 父进程 PID；</li></ul><p>系统级函数还可以<strong>终止一个进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><ul><li>作用：以 <code>status</code> 状态数终止这个进程；</li><li>约定：<code>status</code> 状态数 0 表示正常退出，非零代表异常退出；</li><li>返回值：不返回任何值，一个进程只会执行一次；</li></ul><p>系统级函数还可以<strong>让一个进程主动进入 stopped 状态并持续一段时间</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;    <span class="comment">/* in &lt;unistd.h&gt; */</span></span><br></pre></td></tr></table></figure><ul><li>作用：让当前进程进入 stopped 状态 suspend 起来，不接受 OS 调度，直到 <code>sec</code> 秒后恢复 running 状态；</li><li>返回值：进程实际<strong>还剩多少秒没有 sleep</strong>（因为中途可能会被信号等 ECF 机制打断）；</li></ul><p>系统级函数也可以<strong>让一个进程无限期进入 stopped 状态，直到向其传入任意信号</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>作用：当前进程进行系统调用，直接进入 stopped 状态；</li><li>返回值：如果控制流能回来，那么总是返回 -1；</li></ul><hr><p>此外，系统函数还提供了 <strong>回收子进程（Reaping Child Process）</strong> 的能力。</p><p>为了了解这是什么意思，我们有必要 recap 一下在 16.4.1 中介绍的 Process 的概念。从编程人员的角度来看，一个进程具有 3 种状态（运行、阻塞 和 终止）。现在我们结合之前了解到的 Process Context Switch 和进程调度的基础知识，再重新认识一下这 3 种状态：</p><ul><li><p>Running：处于该状态的进程<strong>可能正在被执行</strong>，<strong>也可能是退出了阻塞状态，等待被 OS 调度执行</strong>；</p></li><li><p>Stopped：处于该状态的进程<strong>已挂起（suspended），并且无法被 OS 调度，除非有信号通知</strong>；</p></li><li><p>Terminated：处于该状态的进程<strong>已经永久结束运行</strong>；</p><blockquote><p>进程终止的 3 点原因：</p><ol><li>收到一个<strong>默认行为是终止进程的信号</strong>；</li><li><code>main</code> 流程执行完毕；</li><li>进程种的程序主动调用 <code>exit</code> 函数；</li></ol></blockquote></li></ul><p>我们发现，改变进程状态的方法是<strong>操作系统与应用程序间的</strong>高级 ECF：<strong>信号</strong>；而信号的发出又需要 硬件 ECF（Exception）作为条件。</p><blockquote><p>下一节会提及高级 ECF 信号的机制，举个例子，Ctrl + C -&gt; Interrupt Exception -&gt; Kernel 发出 SIGINT -&gt; 信号提醒进程进行默认行为）。</p></blockquote><p>除此之外，我们还看到，进程的状态中有一个是 terminated，这说明<strong>操作系统在一个进程终止后，会一直保存这个进程的状态和部分数据（包括退出状态、多种 OS 表），直到它被 “回收（reaped）”</strong>。那么为什么进程结束了还需要等待回收？为何不直接清除这个进程的数据？</p><p>这是因为，我们通常需要知道<strong>进程退出的一些状态信息（正常退出，还是因为其他原因退出）</strong>，如果 OS 在进程结束后就直接清除数据，那么我们无从知晓其中的信息。</p><p>通常情况下，在一个进程从永久退出执行，直到被回收的时间段内，我们将这个进程称为 <strong>zombie</strong>（僵尸进程，在 <code>ps</code> 命令下显示 <code>&lt;defunct&gt;</code>）。</p><p>那么进程最终应该由谁回收？答案是<strong>父进程或者是系统根进程 <code>init</code> (PID = 1)</strong>。父进程如果想要等待在子进程退出后获取子进程的退出状态，那么就需要使用系统级函数 <code>wait</code> 和 <code>waitpid</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *child_status)</span>;    <span class="comment">/* Equivalent to waitpid(-1, &amp;s, 0); */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* child_status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><p>由于 <code>wait</code> 是对 <code>waitpid</code> 的默认包装，因此我们这里仅介绍 <code>waitpid</code>；</p><ul><li><p>第一参数 <code>pid</code>指定父进程要等待的子进程的 PID；如果传入 <strong>-1</strong>，则表示<strong>等待任意一个子进程状态改变即返回</strong>；</p><blockquote><p>“状态改变”，而不是永久终止（terminated）。</p></blockquote></li><li><p>第二参数 <code>child_status</code> 应该传入一个整型地址，函数返回时会将子进程的状态码（<strong>和退出码不一样，需要专门的宏进行读取</strong>）填写进去；如果传入 <strong>NULL</strong>，则表示不关心子进程的状态，只是等待指定的子进程状态改变；</p><blockquote><p>读取该参数的宏位于 <code>&lt;sys/wait.h&gt;</code> 头文件中：</p><p><code>WIFEXITED(child_status)</code>：返回子进程是否被正常终止（调用了 <code>_exit(2)/exit(3)</code> 或从 <code>main</code> 返回）；</p><p><code>WEXITSTATUS(child_status)</code>：返回子进程的退出状态（当且仅当 <code>WIFEXISTED</code> 为真的时候有效）；</p><p><code>WIFSIGNALED(child_status)</code>：返回子进程是否被信号终止；</p><p><code>WTERMSIG(child_status)</code>：返回终止子进程信号的编号（当且仅当 <code>WIFSIGNALED(child_status)</code> 为真时有效）；</p><p>还有 <code>WCOREDUMP(child_status)</code>、<code>WIFSTOPPED(child_status)</code>、<code>WSTOPSIG(child_status)</code>、<code>WIFCONTINUED(child_status)</code> 等，大家可以用到再查；</p></blockquote></li><li><p>第三参数 <code>options</code> 常用的参数有 4 个，可以由按位或运算符连接：</p><ul><li><p>0：指定 <code>waitpid</code> 函数<strong>阻塞</strong>，直到子进程状态改变、获取信息后才返回；</p></li><li><p><code>WNOHANG</code>：指定 <code>waitpid</code> 函数<strong>非阻塞</strong>，如果子进程状态还没改变，那么立即返回；</p></li><li><p><code>WUNTRACED</code>：指定 <code>waitpid</code> 在子进程<strong>不是因为 <code>ptrace</code> 而进入 stopped 状态时</strong>也直接返回；</p><blockquote><p>什么是 <code>ptrace</code> ?</p><p><code>ptrace</code> 是 Linux 的<strong>另一个系统调用</strong>，为一个进程提供了<strong>观察</strong>和<strong>控制</strong>另一个进程的执行过程的能力，同时也提供<strong>检查</strong>和<strong>改变</strong>另一个进程的内存值以及相关寄存器信息。</p><p>大名鼎鼎的 <code>gdb</code> 和系统工具 <code>strace</code> 都是基于 <code>ptrace</code> 完成调试工作 和 逆向工程的。</p><p>这里的 <code>ptrace</code> 的系统级函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span>       </span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid, <span class="type">void</span> *addr, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure><p>事实上，当 <code>ptrace</code> 被调用来 attach 一个进程时，首先进入 syscall（Exception），操作系统在 exception handler 中的默认行为是通过<strong>信号</strong>沟通 <code>ptrace</code> 所在进程 和 attach 的进程，最后该进程会进入 <strong><code>Traced</code> 状态</strong>（一个与 Stopped 状态几乎相同的状态，都是暂时中止进程执行和调度），等待 <code>ptrace</code> 所在进程的调试工作。</p></blockquote></li><li><p><code>WCONTINUED</code>：指定 <code>waitpid</code> 在子进程接受到信号 <code>SIGCONT</code> 而从 stopped 状态恢复为 running 状态时，也直接返回；</p></li></ul></li><li><p>返回值：如果成功执行，则返回状态改变的子进程 PID（<strong>如果指定了 <code>WNOHANG</code>，并且指定的子进程存在，但是子进程还没改变状态，那么直接返回 0</strong>）；如果执行错误，那么返回 -1，错误码位于 <code>errno</code>；</p></li></ul><p>这两个函数不仅可以查看子进程的退出状态，而且也告诉操作系统，“如果子进程结束，则可以直接回收该进程了”。</p><p>如果父进程不想了解子进程的退出情况（<strong>没有调用上述两个函数</strong>），或者<strong>在子进程结束前就退出了（那么这时，子进程被称为孤儿进程，orphaned child process）</strong>，那么操作系统<strong>会自动将回收权交给 <code>init</code> 根进程，等待孤儿进程结束后直接回收</strong>。</p><p>这种回收的流程可以总结为：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/reap_process.png"></p><blockquote><p>⚠ 一种可能的内存泄漏的情形：</p><p>在一个长期运行的服务器上，系统可能运行了大量的进程。对于一些服务程序，<code>init</code> 根进程不会回收这些 zombie 进程，因为服务器是长期运行的，也等不到父进程结束的情况。如果父进程不显式回收子进程，那么会导致 zombie 进程堆积，内存溢出，甚至内核崩溃。</p></blockquote><p>⚠ <strong>另外，还有一个要点，即 <code>waitpid</code> 只能等待父进程的直接子进程（immediate child process），它无法等待子进程的子进程的结束并返回信息的</strong>。</p><hr><p>最后，系统级函数还提供了<strong>更改当前进程运行的程序</strong>的功能（毕竟之前只提供了 <code>fork()</code> 通过复制创建进程）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> _Nullable argv[],</span></span><br><span class="line"><span class="params">           <span class="type">char</span> *<span class="type">const</span> _Nullable envp[])</span>;</span><br></pre></td></tr></table></figure><p>这条系统级函数也是系统调用的接口，可以在<strong>当前进程中加载并运行指定程序</strong>。</p><ul><li><p>第一参数 <code>pathname</code>：可执行文件名，它可以是二进制文件，也可以是由 <code>#!interpreter</code> 开头的脚本（Linux 约定俗成，在脚本文件前注释解释器名，例如 <code>#!/bin/bash</code>）；</p></li><li><p>第二、参数 <code>argv[]</code> 和 <code>envp[]</code> 分别是参数列表和环境变量列表，可以为空；</p><p><code>envp</code> 的设置就是简单字符串：<code>&quot;&lt;name&gt;=&lt;value&gt; ...&quot;</code>，或者使用 <code>getenv</code>、<code>putenv</code>、<code>printenv</code> 进行解析和设置环境变量字符串；</p><blockquote><p>注：<code>envp[]</code> 会在执行前由 OS append 几个参数，参数就是系统环境变量；</p></blockquote></li><li><p>返回值：<strong>仅在执行错误（找不到指定文件）时返回 -1</strong>；</p></li></ul><p>⚠ 注意，在当前进程运行该指令后，<strong>如果正确执行，那么程序控制流永远不会回到该指令的下一行，程序整体会在虚拟内存中完全被替换为新运行的程序，即完全覆盖当前程序虚拟空间，包括 code 区、data 区、stack 区等等</strong>，仅保留 PID、file descriptor 和 signal context（信号上下文）。</p><p>这意味着，正确执行的情况下，<strong><code>execve</code> 不会有返回值</strong>。</p><p>这还意味着，如果你想开发一个 Linux bash，那么你使用 <code>execve</code> 时，应该 <code>fork</code> 一个子进程出来，然后在子进程中执行该命令。否则当前程序会被覆盖。</p><p>当新的程序被从可执行文件加载到虚拟内存后，程序的虚拟内存的结构应该是这样（不包括 kernel space）：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/new_user_stack.png" height="350px"></p><blockquote><p>有同学可能会问，为啥不做一个<strong>同时创建一个进程并运行指定程序的系统调用呢？</strong>实际上，设计者从实用性和冗余性两个方面考虑，<code>fork</code> 非常有用，例如对于一个并发服务器而言，想要创建多个副本来响应 client，那么只需要 fork 就行；</p><p>而且你可以在运行指定程序前、fork 之后的时间内可以做一些其他自定义的准备工作，非常灵活。</p></blockquote><h4 id="16-4-6-Summary-of-Process-amp-Process-Control"><a href="#16-4-6-Summary-of-Process-amp-Process-Control" class="headerlink" title="16.4.6 Summary of Process &amp; Process Control"></a>16.4.6 Summary of Process &amp; Process Control</h4><p>在本节中，我们学习了一种高级的 ECF 机制：Process Context Switch。为了深入讨论这个话题，我们首先了解了进程的概念（一个正在运行的程序的实例），以及进程重要的 2 个抽象——对 CPU（logical control flow 是连续的）和 主存（private address space 是独享的）的抽象。</p><p>另外，我们从 “系统如何充分利用有限资源实现多进程并发” 的问题入手，了解了当今 Linux 操作系统<strong>利用 Timer Interrupt Exception</strong>（分时复用和时间片轮转）<strong>和 系统调用</strong> 达到 Process Context Switch 的目的，进而实现多进程执行的 interleaving。于是 进程上下文切换的 <strong>What、Why、When、How</strong> 四个问题都得到了解答。</p><p>其中，我们还详细比较了 interleaving、parallelism、concurrency、multiprocessing 的概念的异同，分析了怎么看 Physical Control Flow、怎么画 Logical Control Flow、怎么判断进程是 concurrent 还是 sequential 执行的。</p><p>最后一部分，在实际编程层面，我们介绍了控制 process 的、包装了系统调用的<strong>系统级函数</strong>，它们分别有：<code>fork</code>、<code>getpid</code>、<code>getppid</code>、<code>exit</code>、<code>sleep</code>、<code>waitpid(wait)</code>、<code>execve</code>。我们重点分析了这些函数的参数、返回值的含义，以及调用时的注意事项和技巧。</p><p>例如分析多重 <code>fork</code> 的进程图，<code>fork</code> 和 <code>execve</code> 的独特返回方式，<code>waitpid</code> 的复杂参数，最重要的点之一还是 “<strong>为什么要有进程回收、怎么进行进程回收</strong>” 的问题。</p><p>不过，我们在这节多次提到信号的概念，足以说明信号在操作系统与应用程序间的 ECF 的重要性。下节我们就讨论高级 ECF 中的信号（signal）机制。</p><h3 id="16-5-Exception-Control-Flow-Signals"><a href="#16-5-Exception-Control-Flow-Signals" class="headerlink" title="16.5 Exception Control Flow: Signals"></a>16.5 Exception Control Flow: Signals</h3><p>信号是由 OS 进行管理的软件信号，信号的种类和规范都由 OS 制定，完成 OS 和应用程序间的通信，实现高级的 Exception Control Flow；因此，我们需要先了解一下 OS（以 x86-64 Linux 为例）进程的继承结构，这样有助于在分析信号的时候不至于晕头转向。</p><h4 id="16-5-1-Linux-Process-Hierarchy-amp-Shell-Example"><a href="#16-5-1-Linux-Process-Hierarchy-amp-Shell-Example" class="headerlink" title="16.5.1 Linux Process Hierarchy &amp; Shell Example"></a>16.5.1 Linux Process Hierarchy &amp; Shell Example</h4><p>在 Linux 中，只有一种方法创建新的进程 —— <code>fork</code>；而由 <code>fork</code> 创建的进程有明确的父子关系，因此，Linux 中的所有程序所在进程实际上形成了一个层次结构：<strong>进程树</strong>。</p><p>在 Linux 启动的第一个进程是 <code>init</code> 根进程（PID = 1），其后所有生成的进程均为 <code>init</code> 的子进程。<code>init</code> 进程一般会创建 2 类进程：</p><ul><li><p><code>Daemon</code>：守护进程，是一类长期运行的程序，用来提供服务（例如对于一个 web 服务器，那么可能运行的服务是 apache 服务 <code>httpd</code>）；</p></li><li><p><code>login shell</code>：登录进程，这个进程运行的是命令行程序，为用户提供命令行接口，这样用户在登录后，可以以特定用户的身份，通过输入命令的方式与程序进行交互；</p><blockquote><p>例如用户输入 <code>echo &quot;Hello, Linux.&quot;</code> 的指令并回车，发生的是如下情况：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/login_shell.png" height="200px"></p></blockquote></li></ul><p>知道了这个道理，再结合上一节我们接触到的 process control 的系统级函数，我们就可以开始自己尝试用 C 写一个系统命令行了。我们来看看这个小型的命令行程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Fgets</span><span class="params">(<span class="type">char</span>* dst, <span class="type">int</span> cnt, FILE* input)</span>;    <span class="comment">/* 定义略，就是对 fgets 的包装 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* line, <span class="type">char</span>* argv[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];    <span class="comment">/* command line */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* read */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* evaluate */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS];    <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];        <span class="comment">/* Holds modifiled command line */</span></span><br><span class="line">    <span class="type">int</span> bg;                    <span class="comment">/* Should the job run in bg or fg ? */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;        <span class="comment">/* Ignore empty lines */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123;    <span class="comment">/* Check if it is a builtin command */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;    <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, atgv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>细心的同学会发现，这个程序有个严重的 bug —— 它只对运行在 foreground（前台）的程序进行回收，对运行在 background（后台）的程序则仅仅是打印一条信息，就不再关心了。前一节我们讨论过，像 shell 这样长期运行的程序如果不回收其子进程，会导致 zombie 的堆积，引发内存泄漏的问题。</p><p>那么问题来了，对于运行在后台的子进程，我们不想等待，但该如何知道它何时结束，并且回收呢？这个问题的解决方案就是<strong>利用 Exception Control Flow</strong>，因为只有它能够不按照应用程序原先控制流，而是转向 OS Kernel，让 OS Kernel 配合通知我们的 shell 后台子进程的情况。这就是本节的主角，也是这类问题的解决方案 —— 信号（高级的 ECF 机制之一）。</p><h4 id="16-5-2-The-Features-of-Signals"><a href="#16-5-2-The-Features-of-Signals" class="headerlink" title="16.5.2 The Features of Signals"></a>16.5.2 The Features of Signals</h4><ul><li>定义：信号是一种软件产生的，<strong>用来通知进程，系统中某一种事件发生的小型信息</strong>。</li></ul><p>我们发现，信号的定义很像之前的 Hardware ECF（Exception），它们都是某种事件发生时触发的信息通知机制，但是后者是<strong>硬件和操作系统层面</strong>（包括 Asynchronous Exception 的硬件引脚 Interrupt 和 Synchronous Exception 的处理器触发进入 Exception table），前者则完全是<strong>由操作系统软件产生的软件层面的信息</strong>，抽象层级更高。</p><ul><li><p>发送方：通常是 <strong>OS Kernel</strong>，有时是<strong>一个 Process 请求内核（利用 <code>syscall</code> 这个 Exception）来向另一个进程发送</strong>（所以本质上<strong>只有</strong> OS Kernel 有权限发送信号）；</p></li><li><p>接收方：总是一个 Process；</p></li><li><p>发送时机：<strong>总是因为</strong>处理器触发了一个 Hardware ECF，进入某个 Exception Handler 中的行为，可能有以下两个原因：</p><ol><li>System call（<code>trap</code>）：有几种<strong>向另一个进程发送特定信号的系统调用</strong>：<code>kill -&lt;sigNum&gt;</code>（不是专门 terminated 进程的系统调用，而是用来发信号的，名字起的不好！），和之前我们接触过的 <code>ptrace</code> 等；</li><li>其他 unintended hardware ECF（例如 Interrupt（典型是 <code>Ctrl+C/D/Z</code> 键盘 I/O）、Fault（常见是 Page Fault、Floating Point Exception）等等）；</li></ol></li><li><p>接收时机：？？？（<strong>我们在下一节介绍</strong>）</p></li><li><p>内容：它真的很小，<strong>仅仅是一个小整型 ID（1 ~ 30）</strong>，来代表信号的种类；</p><p>不过每个整型在 OS 中对应唯一的信号类型和含义。下面是常见的几个信号：</p><table>    <tr style="text-align: center;">        <th>ID</th>        <th>Name</th>        <th>Default Action</th>        <th>Corresponding Event</th>    </tr>    <tr>        <td>2</td>        <td>SIGINT</td>        <td>Terminate</td>        <td>User typed ctrl-c</td>    </tr>    <tr>        <td>9</td>        <td>SIGKILL</td>        <td>Terminate</td>        <td>Kill program (<b>cannot override or ignore</b>)</td>    </tr>    <tr>        <td>11</td>        <td>SIGSEGV</td>        <td>Terminate &amp; Core dump</td>        <td>Segmentation violation</td>    </tr>    <tr>        <td>14</td>        <td>SIGALRM</td>        <td>Terminate</td>        <td>Timer signal</td>    </tr>    <tr>        <td>17</td>        <td>SIGCHLD</td>        <td>Ignore</td>        <td>Child stopped or terminated</td>    </tr></table></li></ul><p>  我们解释一些上面的信号。</p><p>  首先，<code>SIGINT</code> 就是我们对前台运行的程序触发 <code>Ctrl+C</code> 按键后，首先发生 Asynchronous Exception（Interrupt），通知处理器，处理器按照 Exception 处理流程转移到 OS Kernel 中处理 Keyboard Interrupt 的 Exception Handler 中，发现这是个 <code>Ctrl+C</code>，因此向目标进程发送一个 <code>SIGINT</code> 信号，然后把 Control Flow 交还 user mode 的 $I_{next}$；同时，目标进程收到信号会进行默认行为 —— terminated（可以 override，即自己设计接收信号的 procedure）；</p><p>  对于 <code>SIGKILL</code> 过程类似上面的情况，但是它一般利用 <code>kill -9</code> 指令，进行了系统调用，通过 <code>trap</code> 来发送信号；</p><p>  对于 <code>SIGSEGV</code>，一般是处理器访问非法地址后出现 <code>page fault</code>，可能发送这个信号；</p><p>  对于 <code>SIGALRM</code>，一般可以用作自定义信号，利用硬件时钟进行一些任务（例如设置与超时相关的行为）；</p><p>  对于 <code>SIGCHILD</code>，一般在<strong>一个进程的子进程的状态改变后</strong>，OS Kernel 会向该父进程发送这条信号，但默认行为是忽略。如果父进程是一个 long-run program 并且不使用阻塞的 <code>waitpid</code>，那么我们在父进程中应该主动捕获这个信号，防止发生子进程的内存泄漏；</p><blockquote><p>除此之外，我们在前面还见到过 <code>SIGFPE</code>、<code>SIGGPE</code> 等等信号，用到时再查也不迟；</p></blockquote><h4 id="16-5-3-Implementations-of-Sending-a-Signal"><a href="#16-5-3-Implementations-of-Sending-a-Signal" class="headerlink" title="16.5.3 Implementations of Sending a Signal"></a>16.5.3 Implementations of Sending a Signal</h4><p>那么，通过上面的解释，我们大致知道了，OS Kernel 大多是借助 Exception（Hardware ECF）这个时机来实现信号的发送的，但具体是如何进行的呢？</p><p>实际上，OS Kernel 向某个进程发送信号是通过<strong>改变目标进程上下文的状态数据</strong>来实现的。</p><blockquote><p>Linux 官方文档原文：</p><p>Kernel sends a signal to a destination process by updating some state in the context of the destination process.</p></blockquote><p>对，仅仅是目标进程的上下文的某个数据改变了，仅此而已。</p><p>那么，目标进程的响应机制呢？主要有以下几种：</p><ul><li><p><strong>Ignore</strong>：忽略该信号；</p></li><li><p><strong>Terminate</strong>：该进程终止，或被迫终止（不是中止，stopped）；</p></li><li><p><strong>Catch</strong>：捕获信号并处理（这里捕获信号并处理的程序称为 <strong>Signal Handler</strong>，<strong>它与 Exception Handler 不一样，它位于用户态代码中——也就是说，咱可以自己在 C 程序中设计 Signal Handler</strong>）；</p><p>对于 catch 这个选项而言，我们还要了解一下 signals 到达目标进程后的过程：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/signal_procedure.png" height="200px"></p><p>但是，在<strong>信号到达后、进程 A 收到（就是感知到）并处理之前</strong>的一段时间内，由于<strong>某个给定的时刻，只能有一个类型的待处理信号</strong>（因为信号是一个整型，发送信号就是改变一个数据，没有队列这个数据结构，所以重复发就会覆盖，下面会看到这种数据结构）。所以有两个问题：</p><ol><li>我们不能继续给这个进程发送信号，那么 OS 应该怎么知道目标进程有没有收到？</li><li>进程 A 是按照普通控制流正常运行的，怎么让它去临时接收这个信号呢？</li></ol><p>实际上，这引入了信号的 2 个概念：<strong>Pending 和 Blocked</strong>；不仅如此，我们还要了解 <strong>进程组的概念</strong>，然后我们才能完整地解释信号的收发过程。</p></li></ul><hr><p>下面是 16.5.3 的知识补充：</p><h5 id="16-5-3-1-Signal-Concepts-Pending-amp-Blocked"><a href="#16-5-3-1-Signal-Concepts-Pending-amp-Blocked" class="headerlink" title="16.5.3.1 Signal Concepts: Pending &amp; Blocked"></a>16.5.3.1 Signal Concepts: Pending &amp; Blocked</h5><p>其实信号也存在状态，其中两个特殊的状态是 pending 和 blocked：</p><ul><li>如果一个信号被 OS Kernel 发送，但是还没有被目标进程接收（感知并处理），那么这个信号处于 Pending 状态；（<strong>重复一遍，没有队列数据结构</strong>）</li><li>如果一个信号被 OS Kernel 发送，但是目标进程显式地阻塞特定信号的接收（感知但保留信号不处理），那么这个信号处于 Blocked 状态，除非该进程主动 unblock；</li></ul><p>从这里我们可以知道，<strong>pending 状态的 signals 至多只会被目标进程接收一次，但 blocked 状态的 signals 可以接收多次</strong>；</p><p>我们说过，信号只是一个表示信号类型的小整型，存不了其他数据，因此<strong>信号的状态是由 OS Kernel 维护的</strong>。</p><p>OS Kernel 中<strong>保存了各进程的 Pending / Blocking bits 组成的 bit vectors</strong>，位于每个进程的上下文虚拟内存的 kernel space 中。维护方法如下。</p><p><strong>对于 Pending Signals</strong>；</p><ul><li>当一个另一个进程的 OS Kernel 向当前（目标）进程发送<strong>第 k 号</strong>信号，那么当前进程的 OS Kernel 会设置当前进程的 Signal Pending Vector 的<strong>第 k 位</strong>为有效位（假设是 1）；</li><li>当当前进程接收了这个信号 k，那么当前进程的 OS Kernel 会设置当前进程的 Signal Pending Vector 的第 k 位为无效位（对应是 0）；</li></ul><p><strong>对于 Blocked Signals</strong>：</p><blockquote><p>Signal Blocked Vector 相当于是对 Signal Pending Vector 的<strong>掩码</strong>（被称为 <strong>signal mask，信号掩码</strong>）。</p></blockquote><p>如果 block / unblock 特定信号，那么目标进程会使用 <strong><code>sigprocmask</code>（又一个系统调用）</strong>显式设置掩码位对应的 Pending Signal 是否有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> <span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> oldset)</span>;</span><br></pre></td></tr></table></figure><p>具体用法见 16.5.5 节；</p><h5 id="16-5-3-2-Process-Concept-Process-Groups"><a href="#16-5-3-2-Process-Concept-Process-Groups" class="headerlink" title="16.5.3.2 Process Concept: Process Groups"></a>16.5.3.2 Process Concept: Process Groups</h5><p>在 Linux 下，每个进程都明确属于一个进程组。那么如何为一个新产生的进程分配进程组？</p><p>实际上，进程组的分配有专门的系统调用（又来几个系统调用）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">/* Equivalent to getpgid(currentPID); */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">/* Equivalent to setpgid(currentPID, currentPID); */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>上述函数执行失败返回值均为 -1，均会设置 <code>errno</code>，注意检查。</p></blockquote><p>注意，进程组号 PGID 和进程 PID 是共用类型 <code>pid_t</code> 的。</p><p>此外，创建一个进程，<strong>默认的进程组号与父进程的进程组号相同</strong>；</p><p>这样的话，可以方便我们向<strong>在同一进程组中的所有进程都发送信号</strong>。例如，如果我们使用系统调用 <code>kill</code> 来给一个进程或进程组发送信号（以包装好的系统命令为例。当然，C library 也包装了一个系统级函数 <code>kill</code>，能够在 C 中向另一个进程发送信号）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 12345</span><br></pre></td></tr></table></figure><p>上面的指令就表示请求 bash 调用系统调用 <code>kill</code>，向<strong>进程号</strong>为 <code>12345</code> 的一个进程发送 9 号信号（<code>SIGKILL</code>）；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 -12344</span><br></pre></td></tr></table></figure><p>上面的指令由于进程号前加了一个短 dash，因此被解释为 <strong>进程组号</strong>，上面的行为是向<strong>进程组号</strong>为 <code>12344</code> 的所有进程发送 9 号信号。</p><p>然后我们回过头解释一下 <code>Ctrl+C/Z</code> 是如何发送信号的。如下图。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/process_group.png" height="300px"></p><p>首先，我们在 bash 中输入的指令和我们之前了解的一样，分为前台和后台任务；bash shell 在 <code>fork</code> + <code>execve</code> 一个指令的时候，会根据指令后面有没有 <code>&amp;</code> 来判断这是条前台还是后台任务。如果是前台任务，那么创建进程后还会进行系统调用，将前台任务放到<strong>前台进程组</strong>中。前台进程在一个 shell 主进程中只有一个，所以一般这个前台进程组由 shell 进程直接管理。</p><p>如果我们按下 Ctrl+C/Z，那么 Interrupt Exception Handler 的默认行为就是向 shell 进程发送 <code>SIGINT/SIGSTP</code> 信号；而 shell 定义了对于该信号的 Signal Handler，也就是<strong>向前台进程组中所有进程发送 <code>SIGINT/SIGSTP</code></strong>（不影响后台进程）。这就完成了一次键盘 I/O 信号的发送和传递。</p><blockquote><p>注：<code>SIGSTP</code> 信号的默认行为是让目标进程的状态 suspend 到 stopped 状态，直到接收到 <code>SIGCONT</code> 信号后才恢复。</p></blockquote><hr><h4 id="Back-to-16-5-3"><a href="#Back-to-16-5-3" class="headerlink" title="Back to 16.5.3"></a>Back to 16.5.3</h4><p>了解了信号的状态和管理的知识 和 进程组的知识，我们再回到 16.5.3，看看<strong>完整的信号处理过程</strong>应该是什么样子的。</p><p>考虑一个会经常出现的情形：某一个进程 A 正在执行，进程 B 的 OS Kernel 想向进程 A 发送一个第 k 号信号，怎么办？OS 是这么做的：</p><p><code>step 1.</code> 在某次 Process Context Switch 中，OS 的 scheduler 决定切换到 Process B，于是按照 Process Context Switch 的规范进行切换（保存当前进程上下文数据到当前进程的虚拟内存中，读 Process B 的进程上下文数据并加载到处理器中）；<strong>在运行 B 的代码前，OS Kernel 会按照想要发送给 A 的信号（k）来更改  A 的 Kernel space 中的 Pending Vector（将第 k bit 置为有效位 1）</strong> 然后转入用户态，正式运行 Process B 的代码；</p><p><code>step 2.</code> 在执行 Process B 一段时间后，处理器触发了 Exception（Interrupt、Trap、Recoverable Fault），于是控制流重新进入内核态。假如 scheduler 决定切换到另一个进程（也就是目标进程）A，<strong>那么在正式切换前，Kernel 会检查进程 A 的 signal 情况：使用 <code>pnb = pending &amp; ~blocked</code> 计算出上次 Kernel 发给这个进程的信号的集合，<code>pnb</code> 就是所有未被阻塞的信号的 bit vector</strong>；</p><ul><li>如果 <code>pnb == 0</code>，那么说明当前没有收到未阻塞的信号，OS Kernel 会继续进行 Context Switch 操作，切换到 Process A；</li><li>否则，OS Kernel 会选择 <code>pnb</code> 中最低非零位的 bit（假设第 k 位）作为信号接收。那么，OS Kernel 将 pending vector 第 k 位置为无效位（0），<strong>并且执行对应 k 号信号的 Signal Handler</strong>，<strong>此后重新回到 step 2 计算并检查 <code>pnb</code>，直至 <code>pnb == 0</code></strong>；</li></ul><p>这样信号的发送和接收的流程就形成了闭环：</p><ul><li><strong>信号接收时机：在 Process Context Switch 进入目标进程前统一检查并接收</strong>；</li></ul><p>于是我们可以说：</p><p><strong>信号的发送和接收依靠 Process Context Switch 实现，而 Process Context Switch 又是依靠 Hardware ECF（Exception）来实现的，三者抽象层级依次升高，密不可分，分别构成了硬件与操作系统、操作系统与应用程序间的 ECF 交互机制</strong>。</p><h4 id="16-5-4-Signal-Handlers-amp-Default-Action"><a href="#16-5-4-Signal-Handlers-amp-Default-Action" class="headerlink" title="16.5.4 Signal Handlers &amp; Default Action"></a>16.5.4 Signal Handlers &amp; Default Action</h4><p>好了，到目前为止，我们已经大致将信号机制的脉络捋清了。还有一点，我们之前就很想了解的：<strong>怎么自定义 signal handlers 呢？</strong> 这就需要我们更改一个进程收到某个信号的默认行为（Default Action）了。</p><p>提供修改信号 Default Action 的还是一个<strong>系统调用</strong>：<code>signal</code>（名字和 <code>kill</code> 一样有误导性。这里 <code>signal</code> 系统调用不是发送信号，而是设置进程对于信号的 default action）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">handler_t</span> *<span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注 ：<code>handler_t*</code> 类型被 <code>typedef</code> 为一个函数指针类型 <code>void(*)(int)</code>；</p></blockquote><ul><li><p>第一参数 <code>signum</code>：要修改该进程默认行为的信号编号（在 <code>&lt;signal.h&gt;</code> 中有宏定义可供使用）；</p></li><li><p>第二参数 <code>handler</code>：类型为 <code>void(*)(int)</code> 的函数指针，即为 signal handler（其参数也为信号编号）；</p><blockquote><p>如果是要设置 Ignore / Terminate 为默认行为，那么它们（函数指针）在 <code>&lt;signal.h&gt;</code> 还有特定的宏：<code>SIG_IGN</code>、<code>SIG_DFL</code>；</p></blockquote></li><li><p>返回值：如果执行成功，则返回传入的 signal handler 指针；否则返回宏 <code>SIG_ERR</code>（0）；</p></li></ul><p>可是问题又来了。我们知道，signal handler 会在 Process Context Switch 前被调用，调整程序的 control flow。因此，signal handler 用户态代码 和 普通代码一样，都可以作为<strong>并发流（concurrent flow）</strong>。以前我们接触的并发流都是不同进程间的 control flow。不同进程间资源不共享，它们间的切换依靠 Process Context Switch；</p><p>但是！一旦引入了 signal handler，<strong>signal handler 本身是和原进程并发的</strong>，而它又会共享原进程的一切资源，这可能出现问题（<strong>什么问题？在 16.5.6 节讨论</strong>）</p><p>我们结合 signal handler，顺便复习一下 16.5.3 中的内容，从另一个角度来看<strong>完整的信号收发过程和并发</strong>的情况：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/full_signal_procedure.png" height="300px"></p><ul><li>首先我们知道，如果有一个进程 B 想要想要给 Process A 发送信号，那么在某次从 Process A  Process Context  Switch 到 Process B <strong>前</strong>（置位操作不一定正好发生在 Process Context Switch 时，可以在此之前），Kernel 就为 Process A 的 Pending Vector 置了有效位（如上图最上面的箭头）；</li><li>随后通过 Process Context Switch 后，控制流进入 Process B；</li><li>一段时间后，如果再次出现了一个 Process Context Switch，决定向 Process A 跳转，那么在进入 A 正式执行前，会检查其 <code>pnb</code> 向量是否为 0（如上图下面的箭头），然后按 default action 进入位于 user code 中的 <code>handler</code>（signal handler）中；</li><li>当 <code>handler</code> 执行完成后，控制流再次进入 kernel code 进行一些准备（例如恢复 $I_{next}$ 数据）；</li><li>最后控制流真正回到 user code 的 $I_{next}$ 的位置继续执行；</li></ul><h4 id="16-5-5-Nested-Signal-Handlers"><a href="#16-5-5-Nested-Signal-Handlers" class="headerlink" title="16.5.5 Nested Signal Handlers"></a>16.5.5 Nested Signal Handlers</h4><p>⚠ 这会出现一种情况 “Nested Signal Handlers”，因为在运行在 signal handler 时，毕竟也是 user code，也有可能发生 process context switch：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/nested_signal_handlers.png" height="250px"></p><p>为啥要讨论这种情况？因为 <strong>OS Kernel 对已经正在处理同类型信号时（即位于该信号的 Signal Handler 时），会自动阻塞该进程对同类型信号的接收</strong>。这种信号阻塞方式称为 <strong>Implicit blocking（隐式阻塞）</strong>；</p><blockquote><p>例如上图，如果程序位于第（4）步，那么它既会阻塞 <code>S</code> 信号，又会阻塞 <code>T</code> 信号的接收。</p></blockquote><p>而我们之前 16.3.5.1 介绍过的 <code>sigprocmask</code> 系统调用，则是程序可以显式地修改对信号的阻塞情况。</p><p>我们再回顾一下它的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> <span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> oldset)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>sigset_t</code> 就是之前我们说的 Pending Bit Vector 的数据；</p></blockquote><ul><li>第一参数 <code>how</code> 可不是信号编号，因为信号编号应该是 <code>set</code> 的 bit 位；它是 <strong><code>sigprocmask</code> 要执行的行为</strong>，具体也是由宏定义的：<ul><li><code>SIG_BLOCK</code>：将指定参数 <code>set</code> 的有效位加入现在的 blocking bit vector，阻塞指定信号；</li><li><code>SIG_UNBLOCK</code>：将指定参数 <code>set</code> 中的有效位从现在的 blocking bit vector 移除，停止阻塞某种信号；</li><li><code>SIG_SETMASK</code>：直接将参数 <code>set</code> 作为 blocking bit vector；</li></ul></li><li>第二参数 <code>set</code> 是一个与 pending bit vector 格式相同的数据，作用在第一参数中能看到，具体我们怎么操作这个向量并且填上去，还有专门设置这个 vector 的函数：<ul><li><code>sigemptyset</code>：返回一个空的 pending bit vector 数据；</li><li><code>sigfillset</code>：返回一个每个信号位都有效的 pending bit vector 数据；</li><li><code>sigaddset</code>：返回一个在输出 pending bit vector 基础上置位指定信号位的新的 pending bit vector 数据；</li><li><code>sigdelset</code>：同理，删除；</li></ul></li><li>第三参数在接下来的例子中就能看到。</li></ul><p><strong>这个虽然很多，但很重要！！！在 Shell Lab 中会用到</strong>。</p><p>为什么我们要用到它们呢？直接交给 OS Kernel 隐式阻塞不好吗？<strong>我们不妨考虑一个场景，如果程序中有一串代码不希望被用户用 Ctrl+C 打断，那么我们就需要暂时显式地阻塞 <code>SIGINT</code> 信号</strong>，下面就是例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> mask, prev_mask;</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line">sigaddset(&amp;mask, SIGINT);</span><br><span class="line"><span class="comment">/* Block SIGINT and save previous blocked set */</span></span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Code region that will not be interrupted by SIGINT */</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Restore previous blocked set, unblocking SIGINT */</span></span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>看完这串代码你大概能明白 <code>sigprocmask</code> 的第三个参数的含义了：以指针传入，<strong>存储以前的信号掩码信息，便于之后的恢复工作</strong>。</p><h4 id="16-5-6-Safe-Signal-Handling-⚠IMPORTANT"><a href="#16-5-6-Safe-Signal-Handling-⚠IMPORTANT" class="headerlink" title="16.5.6 Safe Signal Handling [⚠IMPORTANT]"></a>16.5.6 Safe Signal Handling [⚠IMPORTANT]</h4><p>讨论完前面的知识，相信大家心里有点数了——信号非常难缠，不仅约定、机制和系统调用接口贼多，而且你必须小心再小心，否则会出大问题：</p><ul><li><p>不正确地处理信号会导致一些系统级问题，包括但不仅限于：</p><ul><li><p>内存泄漏（zombie 堆积等原因）；</p></li><li><p>共享内存访问冲突（<strong>死锁 dead lock、段错误 Segmentation fault 等问题都会出现</strong>。由于 signal handlers 与普通 user code 共享内存，但它们是并发的，很像一对<strong>并发的线程，thread</strong>），<strong>你要像写多线程程序一样小心，保证线程安全性</strong>；</p><blockquote><p>为什么？这还是因为 signal handlers 和 普通程序构成了<strong>并发流</strong>。</p><p>因为在 signal handler 执行前后，原程序都停留在 $I_{current}$ 的位置上，这样在 Logical Control Flow 上看，它们是并发的，<strong>几乎和两个线程的效果一样</strong>。</p><p>如果原程序正在改变一个诸如链表一样的数据结构，结果被 Exception 打断，进入了 signal handler；那么如果 signal handler 也改变了这个链表，当控制流回到原程序时，<strong>原程序并不知道自己的链表被改变了，因为从他的角度看，它还一步指令都没执行呢！</strong></p><p>⚠ 相信我，这种 Bug 非常难找，因为就算 <code>gdb</code> 也只能逐线程、逐进程地看。</p><p>所以在写 signal handlers 的时候，请<strong>一定注意访问全局 / 其他共享变量时的安全问题</strong>！！！</p></blockquote></li></ul></li><li><p>信号除了类型，没有其他语义。这是因为多个信号可能在接收时发生覆盖。<strong>因此我们不能用信号进行计数（即计信号发送了几次）</strong>！</p></li><li><p>不同版本的 Linux 中，<strong>信号的语义不同，难以移植</strong>；</p><ul><li>某些老旧系统在触发自定义的 signal handler 后，会重新变为 default action，需要重新设置。不过在 Linux 上不用担心；</li><li>某些系统根本不会在进程处理该类型信号时隐式阻塞；</li></ul><blockquote><p>为了解决这个问题，我们可以利用 <code>sigaction</code> 进行覆写处理。</p></blockquote></li><li><p>某些<strong>慢系统调用</strong>（类似 <code>read</code> 这样一定会触发 Process Context Switch 的）会使得 <code>errno</code> 变为 <code>EINTR</code>；</p><blockquote><p>因为如果触发慢系统调用的进程先于系统调用退出，那么系统调用会发生错误，并且设置 <code>errno</code> 为 <code>EINTR</code>；</p><p><strong>所以如果你在程序中发现这种错误，就重新进行这个系统调用</strong>；</p></blockquote></li></ul><p>那么怎样做是安全的呢？</p><ol><li><p>Signal Handlers 写的越简单越好，尽量能不往里面加代码，就不加；</p><blockquote><p>比如，你可以在一个信号函数中只是设置一个全局变量，然后立即返回；</p></blockquote></li><li><p>仅使用 <strong>异步信号安全（async-signal-safe）的</strong> 函数；</p><blockquote><p>什么是<strong>异步信号安全</strong>的函数？</p><p>它是指，一种函数是可重入（reentrant）的，也就是说，<strong>它访问的所有变量（包括指针的指向）都在自己的栈帧上</strong>。这样的函数在多线程、进程信号 handle 的时候，一定不会出现共享内存访问冲突，啥时候运行都不会改变语义。</p><p>事实上，POSIX 标准中保证了以下几种（共 117 种）函数一定是异步线程安全的：</p><p><code>_exit</code>（和 <code>exit</code> 不一样！它是系统调用接口，<code>exit</code> 是 C library 包装的系统级函数）、<code>write</code>、<code>wait</code>、<code>waitpid</code>、<code>sleep</code>、<code>kill</code>、……</p><p><strong>但不幸的是</strong>：</p><p><code>printf</code>、<code>sprintf</code>、<code>malloc</code>、<code>exit</code> 这些<strong>涉及 I/O 访问的、改变进程状态的系统调用或系统级函数</strong>大多都不是异步信号安全的，请谨慎在 signal handlers 里添加！</p><p>为什么它们不安全？因为它们会使用<strong>锁</strong>来对 I/O 设备或者变量进行读写，在 “多线程” 一章你会明白，这样很容易导致经典的死锁。</p><p><strong>所以……你一般没法在 signal handlers 里面打印输出内容……</strong>除非你能设计出一个能够对 signal handler 安全的 I/O 库。</p></blockquote></li><li><p>每次进入、退出 signal handlers 时<strong>应该保存、恢复 <code>errno</code> 变量，有助于系统错误追踪</strong>；</p><blockquote><p>因为在 signal handlers 被中断后，<strong>其他的 signal handlers 可能会更改掉 <code>errno</code></strong>；</p></blockquote></li><li><p><strong>在读写共享 / 全局变量时，请阻塞所有其他信号！！！</strong>这步操作保证当前 Signal Handler 不会被同进程的其他 signal handler 打断，<strong>相当于在多线程程序中加入读写锁</strong>；</p></li><li><p>如果你的 signal handlers 要用到一个全局变量，<strong>请将它声明为 <code>volatile</code></strong>。这一步也是在多线程编程中常见的。</p><blockquote><p>我们复习一下 C 中的关键字 <code>volatile</code>，这个关键字可以：<strong>阻止编译器优化由该关键字修饰的变量</strong>，即始终不将它放入寄存器中，<strong>每次读取都从内存中进行</strong>。这样做的好处是，多线程程序中的 <code>volatile</code> 变量不会发生值修改不同步的情况。</p><p>我们考虑以下情况：如果一个 signal handler 是修改某全局变量 <code>flag</code> 然后返回；该进程程序主体会定时检查这个 <code>flag</code>，做出相应动作。</p><p>如果我们在声明 <code>flag</code> 的时候，不加这个关键字，那么很有可能 <code>flag</code> 的值会被编译器解释成直接放到寄存器中，然后仅仅修改寄存器中的值。这样<strong>主程序可能永远也收不到 signal handler 更改的 <code>flag</code></strong>。</p></blockquote></li><li><p>如果你的全局变量是 <strong>仅读写的简单类型</strong>（数组、标准库中的容器是聚合类型，不是简单类型），除了加上 <code>volatile</code>，还建议使用 <code>sig_atomic_t</code> 类型。<strong>这就相当于多线程编程中的原子操作（<code>atomic&lt;&gt;</code>）</strong>；</p></li><li><p>对于一些慢系统调用，如果希望提升程序健壮性，应该在执行完检查是否 <code>errno == EINTR</code>，查看中途慢系统调用是否会被 Process Context Switch 阻断产生偶然错误；</p></li></ol><p>那么一个超级有难度的考题就来了——<strong>判断给定程序的异步信号安全性</strong>。来看下面一个程序：</p><p>这个 <code>fork14()</code> 想将自己创建的所有子进程通过信号的方式回收。这样做对吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ccount = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">child_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = wait(<span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">    ccount--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Handler reaped child &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>((<span class="type">long</span>)pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; \n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fork14</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid[N];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ccount = N;</span><br><span class="line">    signal(SIGCHLD, child_handler);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid[i] = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* Child exits */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ccount &gt; <span class="number">0</span>) <span class="comment">/* Parent spins */</span></span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很遗憾，这样写可以说没有一点异步信号安全性。能够成功回收应该是小概率事件。</p><p>我们从简入繁地分析一下：</p><ul><li>上面的信号处理程序没有保存和恢复 <code>errno</code>，这样会造成不必要的错误追踪的麻烦；</li><li>很显然，<code>printf</code> 不是信号安全的，极其容易发生死锁。要么不用，要么换成异步信号安全的函数；</li><li><code>ccount</code> 变量没有添加 <code>volatile</code> 关键字，可能被编译器优化，甚至在 <code>child_handler</code> 减少了 <code>ccount</code> 后，<code>main</code> 都无法感知；</li><li>最严重的一个问题是，<strong>任何时候，都不应该用收到信号的次数来作为真正发送信号的次数</strong>。因为前面介绍过信号的发送和接收的过程：从信号发送给进程，到进程真正接收，中间至少间隔 2 次 Process Context Switch。在此期间，<strong>由于没有队列数据结构，所有重复的相同信号都会被覆盖成一次信号</strong>。此外，在进程处理该信号的同时，还有隐式阻塞的问题，也会产生相同信号覆盖的情况。</li></ul><p>现在我们来改正。当我们收到一个 <code>SIGCHILD</code> 信号时，应该假设有多个子进程都结束了（因为无法计数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">child_handler2</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="type">int</span> oldErrno = errno;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">while</span> ((pid = wait(<span class="literal">NULL</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ccount--;    <span class="comment">/* 这里改成了回收子进程数，而不是依靠信号数来直接计数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)    <span class="comment">/* 说明上一个 wait 还没等完 */</span></span><br><span class="line">        sio_error(<span class="string">&quot;wait error&quot;</span>);    <span class="comment">/* 安全 I/O 库 */</span></span><br><span class="line">    errno = oldErrno;    <span class="comment">/* 用完 errno 后恢复它 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一个更难的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123; <span class="comment">/* Reap child */</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">        deletejob(pid); <span class="comment">/* Delete the child from the job list */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span> &amp;&amp; errno != ECHILD)</span><br><span class="line">        sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 5 */</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* Initialize the job list (a queue) */</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></span><br><span class="line">            execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); <span class="comment">/* Parent */</span></span><br><span class="line">        addjob(pid); <span class="comment">/* Add the child to the job list */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里的错误很难发现。在我们很早以前说 <code>fork</code> 的时候就讲过，<strong>不能保证父子进程的运行的时间顺序</strong>。这里可能会发生一个问题：<strong>在父进程 <code>addjob</code> 之前，<code>execve</code> 的子进程可能已经结束</strong>。这就意味着，父进程将一个已经结束的 job 加入 job list 中，这样任务队列永远不会为空。</p><p>如果要想 debug 找出，难点在于，你很难弄清楚各个父子进程间的 interleaving 的执行关系。所以在写信号的时候，一不留神就可能写出一个很恶心的 bug，还找不出来。</p><p>改正方法是，<strong>我们没法控制子进程和父进程执行的顺序，但我们可以控制 signal handler 执行的时机</strong>。我们在创建子进程前，阻塞所有信号（<strong>为什么？</strong>）。 在子进程中，在任务开始前，解除阻塞（<strong>又是为什么？</strong>）。</p><p>在创建子进程前阻塞所有信号，是为了<strong>让父进程在将任务添加到任务列表后，再考虑信号接收问题，防止 signal handler 在父进程还没加入任务列表时就被触发</strong>；</p><p>在创建子进程后，子进程开始后、<code>execve</code> 前解除阻塞，是因为要让 <code>SIGCHILD</code> 信号放出去，否则切换执行程序后就没有机会了。</p><p>于是改正后的程序长这样（<code>handler</code> 没有问题）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 5 */</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">    signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* Initialize the job list*/</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child process */</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">            execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>); <span class="comment">/* Parent process */</span></span><br><span class="line">        addjob(pid); <span class="comment">/* Add the child to the job list */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了这个方面的知识，我们可以明白一件事，我们在写一个这样的前后台程序的时候，如果不放心，可以用 <strong>进程图</strong> 模拟一下，确认自己的程序在各种极限情况下都能正常工作。</p><p>还有一个问题。在 shell lab 中，其实是不允许在 <code>main</code> 中写 <code>wait</code> 的，因为普通的 shell 程序都会将前台子进程的控制也交给信号，这样可以将前后台的处理方式大致统一。那么，<strong>怎么设计主程序能够显式的等待信号</strong>呢？别看这个好像很好办，实际要考虑的东西多得惊人。例如下面的一个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchild_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* Main is waiting for nonzero pid */</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">/* Do something */</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 10 */</span></span><br><span class="line">    signal(SIGCHLD, sigchild_handler);</span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="comment">/* Child: do somthing... */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">        <span class="comment">/* Wait for SIGCHLD to be received (wasteful!) */</span></span><br><span class="line">        <span class="keyword">while</span>(!pid)</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">/* Do some work after receiving SIGCHLD */</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能够写出上面的程序，那么前面的内容你都已经掌握了。这是个正确的程序，但是美中不足的是，父进程在等待子进程的时候，使用 <code>while (!pid);</code>，这样的做法比较低效，大部分 CPU 资源都浪费在无意义的 <code>while</code> 循环中了。</p><p>那么这个时候有同学可能会说，这简单，我可以在 <code>while(!pid)</code> 循环中加入一个 <code>pause</code> 系统调用，这样有 <code>SIGCHILD</code> 或者 <code>SIGINT</code> 触发后，程序可以自动从 <code>pause</code> 中退出，然后判断一遍 <code>pid</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!pid) pause();</span><br></pre></td></tr></table></figure><p>很可惜，这样<strong>可能会造成死锁</strong>。我们不妨画一个进程图，发现如果子进程向父进程发送信号，而且 Process Context Switch 的位置位于 <code>while (!pid)</code> 和 <code>pause()</code> 之间，那么，程序会先接收并处理 <code>SIGCHILD</code> / <code>SIGINT</code> 然后进入 <code>pause</code>。想象一下，如果这正好是最后一个给父进程发信号的进程呢？那么父进程会永远 stopped 在 <code>pause</code> 中。</p><p>同学还想了，那我换成 <code>sleep(1)</code> 不就不会死锁了吗？行是行，但是每隔一秒才检查一次子进程会严重拖慢程序运行速度。而设置为其他的固定时间，要么太慢（速度问题），要么太快（和没有 <code>sleep</code> 的效率一样低下）。</p><p>那么我们可不可以不那么快地恢复对 <code>SIGCHILD</code> 的响应（第 25 行）？让 “恢复 <code>SIGCHILD</code> 响应” 和 “<code>pause</code> 执行” 成为一对原子操作。那么答案就是新的系统调用：<strong><code>sigsuspend</code></strong>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure><p>它等价于以下 3 条指令的 <strong>整体原子操作</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>这样，我们只需要在阻塞 <code>SIGCHILD</code> 的时候，在 <code>while</code> 循环中调用 <code>sigsuspend(&amp;prev)</code>，这样  “取消 <code>SIGCHILD</code> 阻塞” 的行为 和 “<code>pause()</code> 执行” 的行为就原子化了，无需担心中间的死锁问题。这样如果有信号，并且交由 signal handlers 处理后，重新开始对 <code>SIGCHILD</code> 的阻塞，并检查 <code>pid</code>，完美实现要求。于是改进代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchild_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* Main is waiting for nonzero pid */</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">/* Do something */</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 10 */</span></span><br><span class="line">    signal(SIGCHLD, sigchild_handler);</span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="comment">/* Child: do somthing... */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Wait for SIGCHLD to be received */</span></span><br><span class="line">        <span class="comment">/* SIGCHILD is still blocked */</span></span><br><span class="line">        <span class="keyword">while</span>(!pid)</span><br><span class="line">            sigsuspend(&amp;prev);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Unblock SIGCHLD (optional) */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* Do some work after receiving SIGCHLD */</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-5-7-Summary-of-Signals"><a href="#16-5-7-Summary-of-Signals" class="headerlink" title="16.5.7 Summary of Signals"></a>16.5.7 Summary of Signals</h4><p>在讨论信号有关概念之前，我们先认识了 Linux 中的 “进程树” 这种进程层次结构。我们了解到，Linux 一号进程是 <code>init</code> 进程，它是所有进程的父进程。<code>init</code> 进程则会启动两类进程，一种是 <code>Daemon</code> 守护进程，另一种是 <code>Login Shell</code> 命令行。</p><p>我们利用之前对于进程控制的知识尝试写了一个小的 Demo，却发现对于运行在后台的子进程，我们没有办法 handle 它们。为了解决这个问题，我们引入了 Linux 系统中的信号的概念。</p><p>信号是一个小整型，由 OS Kernel 发出，用来通知进程事件发生、要求处理的一种高级 ECF 机制。</p><p>信号的发送和接收的非同时性决定了信号必须在 OS Kernel 中以一种数据结构存储起来，以供目标进程对信号的接收。这种数据结构非常朴素，只是一个 Pending bit vector 和一个 Blocked bit vector，这样的存储方式注定了 <strong>信号在接收过程中可能被覆盖</strong>，因此接收信号的次数不能代表信号发送的次数；</p><p>信号机制运作的流程看起来很简单：</p><ol><li><p>某一时刻，位于某个进程的 OS Kernel 向 Process A 发送一个信号，于是改变了 Process A 的 Pending bit vector；</p></li><li><p>当某次 Process Context Switch 即将切换到 Process A 前，OS Kernel 检查 <code>pnb = pending &amp; ~blocking</code> 的情况；发现有信号，那么对每个信号都进行处理：进入对应的 signal handler 并重置该位 pending bit vector；</p><blockquote><p>由于 signal handler 位于用户态，共享了原程序的一切内存，因此 signal handler 和 原程序在 Logical Control Flow 上成为一对共享资源的<strong>并行流</strong>，这个情况与多线程等效，但<strong>给信号处理和数据访问带来了极大的不安全性</strong>。</p></blockquote></li><li><p>signal handler 执行中，由于是用户态代码，所以仍然可能会出现 Process Context Switch，因此免不了有 Nested Signals Handlers 的情况。不过，一般的 OS Kernel 会帮助我们将正在处理的相同信号阻塞起来（<strong>隐式阻塞</strong>），防止多次调用相同的 signal handler；</p></li><li><p>在 signal handlers 调用完成后，控制流先回到 OS Kernel 恢复 $I_{next}$ 等必需数据然后继续原程序 $I_{next}$ 执行。</p></li></ol><p>只是，别小看这个 <strong>同进程并行流的不安全性</strong>，如果在书写 signal handlers 时处理不当，那么可能造成相当大的危害。</p><p>我们从处理多线程程序安全性的同样思路出发，提出了以下几点避免<strong>异步信号冲突</strong>的解决方案：</p><ol><li>signal handlers 尽量保持简洁，使用 <strong>异步信号安全</strong> 的函数；</li><li>每次进入、退出 signal handler 时要及时保存、恢复 <code>errno</code>，因为 signal handler 内部可能有系统调用错误，为了防止系统错误难以追踪，我们最好这么做；</li><li>在同时被原程序、Signal Handler 使用的共享变量前应该声明 <code>volatile</code> 关键字，对于仅读写的简单类型最好使用 <code>sig_atomic_t</code> 类型；</li><li>在原程序、Signal Handler 操作共享变量时，应该阻塞其他所有信号，防止同进程的 interleaving 造成共享资源访问冲突；</li><li>不以信号接收次数来计信号发送次数；</li><li>对于含有 <code>fork</code> + 信号的程序设计，如果拿不准，建议画进程图，因为你不能假设父子进程的先后顺序，及时进行信号阻塞。这通常是造成共享资源访问冲突的常见点；</li><li>最后，对于显式等待信号的问题，我们可以使用 <code>sigsuspend</code> 系统调用，保证 <strong>取消阻塞和暂停等待两步操作的原子性</strong>。</li></ol><p>此外，我们还认识了进程组，一种关联多个进程，可以同时向进程组中所有进程发送信号的机制。</p><h3 id="16-6-Non-local-Jump"><a href="#16-6-Non-local-Jump" class="headerlink" title="16.6 Non-local Jump"></a>16.6 Non-local Jump</h3><blockquote><p>Powerful (but dangerous) user-level mechanism for transferring control to an arbitrary location.</p></blockquote><p>略</p><h2 id="Chapter-17-System-Level-I-O"><a href="#Chapter-17-System-Level-I-O" class="headerlink" title="Chapter 17 System Level I/O"></a>Chapter 17 System Level I/O</h2><p>本章将讨论操作系统较为底层的 I/O，在 Unix 和其他类型的操作系统上一样支持。</p><h3 id="17-1-Unix-I-O-Overview"><a href="#17-1-Unix-I-O-Overview" class="headerlink" title="17.1 Unix I/O Overview"></a>17.1 Unix I/O Overview</h3><p>我们先讨论 Unix 上的 I/O 的原因是，比起其他的操作系统，Unix 中的 I/O 更加简单并且一致。我们都知道在 Unix 类系统上，<strong>一切皆文件</strong>，而这些文件本质上上一个 m bytes 的<strong>字节序列（a sequence of bytes）</strong>，<strong>不去区分文件的类型</strong>，所以 Unix 操作系统实际上基本不了解文件内部的详细结构。它将文件看作存放在磁盘或外部存储介质上的某段数据，并且提供打开、写入、关闭等标准操作。</p><p>正因如此，即使是一些 I/O Device，甚至是操作系统内核也能抽象表示为具体的文件。</p><blockquote><p><code>/dev/sdaN</code>: Unix 的 N 号磁盘分区；</p><p><code>/dev/ttyN</code>：Unix 的 N 号终端（为何叫 TTY？因为早期人们多使用 “电传打字机（teletype）” 用于描述打字机与计算机的接口）；</p><p><code>/boot/vmlinuz-xxx-generic</code>：Unix 的内核镜像文件；</p><p><code>/proc</code>：Unix 的内核数据结构；</p><p><code>/var/run/*.sock</code>、<code>/run/*.sock</code>、<code>/dev/shm/*.sock</code>：Unix 的网络套接字文件；</p><p>补充：什么是套接字（socket）？</p><p>在网络一章会深入讨论。简单来说，就是在互联网规范中，当机器通过互联网通信时，消息是一段通过写入套接字这个数据结构来发送的，另一端通过读取套接字的内容来接收的。</p></blockquote><p>这样的简洁明了的抽象（elegant mapping of files to devices）就允许 Unix 类操作系统内核以一套简单的接口完成对文件和设备的访问。<strong>这套简单、核心的接口被成为 Unix I/O</strong>：</p><ul><li><p>打开、关闭文件：<code>open()</code>、<code>close()</code>；</p></li><li><p>读写文件：<code>read()</code>、<code>write()</code>；</p></li><li><p>当前文件位置（注意，<strong>不是当前文件路径</strong>：是 current file position，而不是 current file path）；</p><ul><li><p>作用：indicates next offset into file to read or write（<strong>提示下一次向文件中写或读的字节偏移量，即下次从哪里读写</strong>）；</p></li><li><p>接口：<code>lseek()</code>，改变当前文件指针的指向；</p></li><li><p>特征：<strong>只有某些文件有这个接口</strong>。因为对那些文件而言，没法移动、备份和恢复先前的已读入的数据，也无法提前接收未写入的数据。</p><blockquote><p>例如 socket 文件就是没有这种接口的，因为它无法在时间上进行跳转，只能在数据包进入时对其读写；</p></blockquote></li></ul></li></ul><p>由于这些文件本质上还是不同的具体事物，在客观上有内在差别（就像一些类都继承于一个公共类，但它们终究需要实现不同功能）。这些文件属性上的差别则可以抽象为<strong>文件类型</strong>。</p><p>Unix 中的文件类型有以下几种：</p><ul><li>Regular file：普通文件（存储于磁盘驱动器上）；</li><li>Directory：一组特定文件的索引文件，其中的条目描述了其他文件的位置和属性；</li><li>Socket：与另一台机器上的一个进程沟通的文件；</li><li>Named pipes（<strong>FIFOs</strong>，先入先出型数据结构）：管道流文件。Unix 上一些程序的输出，同时也是另外一些文件的输入；</li><li>Symbolic links：符号链接。Unix 上又称软链接（与硬链接相对）；</li><li>Character and block devices：字符设备与块设备。其抽象在操作系统的设备访问层，其名称与实际物理设备特性无必然联系。<ul><li>操作系统能够<strong>随机访问固定大小数据块（chunks）</strong>的设备称为块设备（例如磁盘、软盘、CD、flash memory 等）；</li><li>操作系统只能<strong>按照字符流的方式有序访问</strong>的设备称为字符设备（例如串口、键盘等）；</li></ul></li></ul><p>本章着重讨论前三种文件，因为它们比较常见。</p><h3 id="17-2-Unix’s-Files"><a href="#17-2-Unix’s-Files" class="headerlink" title="17.2 Unix’s Files"></a>17.2 Unix’s Files</h3><h4 id="17-2-1-Regular-Files"><a href="#17-2-1-Regular-Files" class="headerlink" title="17.2.1 Regular Files"></a>17.2.1 Regular Files</h4><p>普通文件可以包含任何类型的数据。一般情况下，操作系统并不会试图分析文件内部的细节，因此操作系统内核<strong>并不知道</strong>文本文件（plain text）和二进制文件（binary）之间的差别。</p><p>注意，区分文件内容是文本还是二进制数据通常发生在应用程序层级（更高级别）。</p><blockquote><p>文本文件和二进制文件的差别：<strong>仅含有代表 ASCII / Unicode 字符的数据的文件被称为文本文件，否则被称为二进制文件</strong>；</p><p>二进制文件可以是：actual object file、图片音视频文件等等，它们包含<strong>直接以某种形式编码的字节序列</strong>；</p></blockquote><p>文本文件有个重要特征，就是它们可以看作<strong>由一系列文本行（text lines）构成</strong>的文件。通常情况下，文本行是一个以 <strong>newline 字符</strong>结尾的字符（char）序列。</p><blockquote><p>事实上，newline 字符在不同操作系统平台上定义不同，例如 Unix 上将 <code>0xa</code>（<code>\n</code>）代表的字符 <strong>line feed（LF）character</strong> 作为换行符，而 Windows 则约定以两个字符 <code>0xd 0xa</code>（<code>\r\n</code>）代表的字符 Carriage Return &amp;&amp; Line Feed（CRLF）character 作为换行符。</p><p>二者的区别与历史中的 typewriter（打字机）有关，因为换行（垂直运动，即 Line Feed）和回车（水平复位运动，即 Carriage Return）是打字机作为机械设备在换到下一行必须要做的两个运动，Windows 保留了这层含义。</p></blockquote><h4 id="17-2-2-Directories"><a href="#17-2-2-Directories" class="headerlink" title="17.2.2 Directories"></a>17.2.2 Directories</h4><p>在 Unix 操作系统（或者说操作系统中的文件系统）中，每个目录文件包含了一个 “链接” 数组，每个 “链接” 建立了一个从文件名到文件的映射关系。</p><p>每一个目录文件包含<strong>至少两个 entries</strong>：<code>.</code>（a link to itself，链接到自身）和 <code>..</code>（a link to the parent directory in the directory hierarchy，链接到目录层次中的上层目录）；</p><p>Unix 的文件系统层次结构与 Linux 相近，因此 Unix 文件系统层次结构就不再赘述。</p><p>而 <strong>当前工作目录（current working directory，<code>cwd</code>）</strong>是由 OS Kernel 维护的数据，每个进程下的不一定一致。可以通过使用 <code>cd</code> 改变当前进程的该数据；</p><p>在 Unix 和其他多数操作系统中，<strong>Pathnames（路径名）</strong>是文件层次结构中导向某个特定文件的导航方式，可以由目录文件的链接名称组成。</p><h3 id="17-3-Basic-Operations"><a href="#17-3-Basic-Operations" class="headerlink" title="17.3 Basic Operations"></a>17.3 Basic Operations</h3><p>本节的系统级函数和宏大多在 <code>&lt;fcntl.h&gt;</code>（file control）中；</p><h4 id="17-3-1-Opening-Files"><a href="#17-3-1-Opening-Files" class="headerlink" title="17.3.1 Opening Files"></a>17.3.1 Opening Files</h4><p>针对各类文件的基本操作方式之一是打开文件。它的实质是<strong>提醒 OS Kernel 已经做好访问该文件的一切准备</strong>。对此 Unix 有一个系统级函数 <code>open</code>，常用声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>第一参数可以是绝对路径，也可以是相对路径；</p></li><li><p>第二参数是 2 的某次幂的标志量（flag），允许按位运算。说明文件的打开方式（结合一些头文件，可以得到相关宏定义，例如 <code>O_RDONLY</code> 只读等）；</p></li><li><p>返回值体现了一个非常重要的思想：<strong>文件描述符</strong>。如果文件打开错误，则返回 <strong>-1</strong>（I/O 操作的失败情况比普通情况多很多，一定在实际使用描述符前检查是否成功打开）；</p><blockquote><p>什么是文件描述符（file descriptor）？</p><p>文件标识符是<strong>用来标识当前程序正在操作的某个已打开文件的小整型（这个小整型只有 0 ~ 1024 的范围）</strong>。</p><p>它们是按照打开顺序依此编号（从运行程序开始编号），所以大部分机器有最大打开文件数量的限制。这意味着打开了超过限制数量的文件将会造成文件资源泄漏。其中机器各方面的限制可以由以下指令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a</span><br></pre></td></tr></table></figure><p>另外一个值得注意的点是，在<strong>每个进程一创建的时候就会有 3 个已创建的文件：0（<code>stdin</code>）、1（<code>stdout</code>）、2（<code>stderr</code>），它们都是由 Unix Shell 打开并创建的</strong>（请回忆前一章的进程树并考虑为什么）。</p><p>其他具体内容将在 <strong>17.5.2</strong> 中讨论。</p></blockquote></li></ul><p>注：本章的系统级函数都非常底层，有些函数直接使用整型文件描述符。为了使用规范，如果你想用 <code>stdin/stdout/stderr</code> 这类文件时，请不要直接使用 <code>0/1/2</code>，更建议使用宏 <code>STDIN_FILENO/STDOUT_FILENO/STDERR_FILENO</code>；</p><h4 id="17-3-2-Closing-Files"><a href="#17-3-2-Closing-Files" class="headerlink" title="17.3.2 Closing Files"></a>17.3.2 Closing Files</h4><p>关闭文件的系统级函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> file_descriptor)</span>;</span><br></pre></td></tr></table></figure><p>你可能会好奇，为什么这个也要有返回值，难道关闭一个文件也会报错？答案是肯定的。</p><p>在多线程编程中（就像之前提到的，它们会共享内存和数据结构），可能会出现关闭一个已经被关闭的文件的情况，这种情况也会发生问题。</p><h4 id="17-3-3-Reading-Files-amp-Writing-Files"><a href="#17-3-3-Reading-Files-amp-Writing-Files" class="headerlink" title="17.3.3 Reading Files &amp; Writing Files"></a>17.3.3 Reading Files &amp; Writing Files</h4><p>Unix 系统级函数提供了一种块读取和块写入的方式，即从当前文件指针位置开始，向后指定长度的空间的数据读入缓冲区 / 向文件写缓冲区内容，并且更新文件指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> file_descriptor, <span class="type">void</span> *buffer, <span class="type">size_t</span> buf_size)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> file_descriptor, <span class="type">void</span> *buffer, <span class="type">size_t</span> buf_size)</span>;</span><br></pre></td></tr></table></figure><p>值得注意的是，如果正确运行，那么 <code>read</code> / <code>write</code> 的返回值是<strong>实际读取 / 写入的字节数</strong>（因为从当前文件指针到最后不一定有 <code>buf_size</code> 大小的数据，这种情况称之为 <strong>short read / short write</strong>）；错误则返回 <strong>-1</strong>；而（对于 <code>read</code> 而言）如果返回 0，说明已经到达 <code>EOF</code>；</p><blockquote><p>这里介绍一个之前提到的非常有名的工具 <code>strace</code>；这个工具的功能非常强大，不过现在我们先介绍一些简单的使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace &lt;prog&gt;</span><br></pre></td></tr></table></figure><p>以上指令在运行指定程序的同时，会跟踪并向  <code>stdout</code> 打印程序使用到的<strong>所有系统调用（system call）情况</strong>；</p><p>有时候看到很乱的情况，可能是终端上 <code>stderr</code> 和 <code>stdout</code> 交织输出的原因。</p><p>如果加上参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=&lt;syscall_name[,...]&gt; &lt;prog&gt;</span><br></pre></td></tr></table></figure><p>那么就仅仅追踪指定名称的系统调用情况。</p></blockquote><p>那么，什么时候会出现 short read / short write？</p><ul><li>读文件时遇到 EOF；</li><li>从<strong>终端</strong>读一个文本行；</li><li>读写网络套接字；</li><li>……</li></ul><p>其实，short read / short write 一直是应用程序层面较为棘手的问题，所以我们一般看到很多涉及 I/O 的库几乎都将这个低层级的 I/O 接口封装起来。</p><blockquote><p>为什么棘手？</p><p>其实，short read / write 在普通程序中的问题还影响不大，因为大多数是向磁盘中写文件，而向磁盘写不会出现 EOF，因此没有 short write；从磁盘读发生 short read 只要跳出读循环就行，影响也不大）。</p><p>但是在网络套接字的读写方面影响很大。考虑一个场景，你要用 socket 发一个网络包，但是写不下的值还要判断，而且还有可能因为其他偶然原因触发 <code>EINTR</code>，并且在循环中重新拿出来再发一次。</p></blockquote><h3 id="17-4-The-RIO-Package"><a href="#17-4-The-RIO-Package" class="headerlink" title="17.4 The RIO Package"></a>17.4 The RIO Package</h3><p>为了解决 short read / short write 对应用程序编程开发带来的麻烦，有一种对 I/O 接口的封装方式是 CMU 教授开发的 RIO Package. 这个包提供了对于底层的 Unix I/O 的包装，能够使得程序在处理 I/O 方面有较强的健壮性（robust）和较好的效率，尤其是后面章节要讨论的、受 short read / write 影响较大的网络编程。</p><p>RIO Package 提供了 2 种不同级别的 I/O 文件接口。</p><p>其中，较低级别的 I/O 接口只是对上面说到的低级 Unix I/O 进行了简单的封装，以应对 short read / write 的情况；函数 <code>rio_readn</code>  和 <code>rio_writen</code> 就是这样较低级别的封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rio_writen 永远不会 short count. */</span></span><br><span class="line"><span class="comment">/* rio_readn 当正常执行时，返回 num 代表实际读取的字节数（和 Unix I/O 不同，这是产生 short count 的唯一情况）；遇到 EOF 返回 0；*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二者遇到错误都返回 -1，errno 由系统级函数 read/write 设置 */</span></span><br></pre></td></tr></table></figure><p>这两个函数属于对二进制数据的非缓冲式的读入和输出（unbuffered input &amp; output of binary data），在未读够 / 未写够指定字节数的数据之前不会返回。对于 <code>rio_readn</code>，如果是处理具有很多数据的网络套接字，那么在当前套接字读完、总体数据未读完的情况下<strong>挂起并等待</strong>；如果是读到了与给定字节数不同的时候出现 EOF，那么会返回错误；</p><p>对于 <code>rio_writen</code>，<strong>对于使用者的情况会比 <code>rio_readn</code> 简单些，所以也只需要包装到这个层次即可</strong>，因为使用者只需担心网络问题，这个函数本身会在要求的字节数内通过循环发送套接字（因为一个 socket 规范只有 1500 bytes 左右，具体大小取决于它位于哪个协议层）；</p><p>另一类是带缓冲区的 I/O 接口（<code>rio_readinitb</code>、<code>rio_readlineb</code>、<code>rio_readnb</code>），比前一类封装更高级一些，也是很多库对于 Unix I/O 常见的包装形式。它们的做法是在用户代码空间创建一个小型缓冲区（mini-buffer），用来存放已读入但未被应用程序使用的 bytes，或者为程序创建一块空间以便未来输出到文件或网络中；</p><blockquote><p>这种<strong>缓冲区的思想</strong>也存在与计算机的相当多的方面。</p></blockquote><p>带缓冲区的 RIO 有两种，一种是基于文本的，另一种是基于字节（二进制数据）的。如下代码注释，可见，在网络套接字的文本行阅读方面，<code>rio_readlineb</code> 非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read a text line of up to `maxlen` bytes from file `fd` and store the line in `usrbuf`.</span></span><br><span class="line"><span class="comment"> * Stopping Conditions:</span></span><br><span class="line"><span class="comment"> * - `maxlen` bytes read;</span></span><br><span class="line"><span class="comment"> * - EOF encountered;</span></span><br><span class="line"><span class="comment"> * - Newline (`\n`) encountered</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read up to `n` bytes from file `fd` and store them in `usrbuf`.</span></span><br><span class="line"><span class="comment"> * Stopping Conditions:</span></span><br><span class="line"><span class="comment"> * - `maxlen` bytes read;</span></span><br><span class="line"><span class="comment"> * - EOF encountered;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当正常执行时，返回 num 代表实际读取的字节数（和 Unix I/O 不同，这是产生 short count 的唯一情况）；*/</span></span><br><span class="line"><span class="comment">/*遇到 EOF 返回 0；遇到错误返回 -1，errno 由系统级函数 read 设置 */</span></span><br></pre></td></tr></table></figure><p>这种 RIO 库的健壮性还在于，<code>rio_readlineb</code> 和 <code>rio_readnb</code> 允许对一个文件描述符进行交织运行（多线程中对一个文件描述符），但别和 <code>rio_readn</code> 连用；</p><p>至于含缓冲区的 RIO 的实现也不难，它的目标就是设计一个读取内容的缓冲地带，让重复的读取内容不至于每次访问 I/O 都使用系统调用；举个例子：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/rio_readnb.png" height="300px"></p><p>如上图，假设程序想要读取系统上的一个 Unix file，那么该文件从头至 current file position 就是我们想要的 buffered portion；在读取的时候，<code>rio_readnb/rio_readlineb</code> 会按 buffered portion 的大小在 user code space 中创建一个同等大小的缓冲区（上图 buffer），由 <code>rio_buf</code> 指针管理这片空间的起始地址，由 <code>rio_bufptr</code> 管理当前程序读到 buffer 的哪里；而 <code>rio_cnt</code> 则代表当前还有多少数据没有读入缓冲区；</p><p>因此，根据 <code>rio buffer</code> 的使用分析，我们发现维护 <code>rio_t</code> 的结构体应该是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;</span><br><span class="line">    <span class="type">int</span> rio_cnt;</span><br><span class="line">    <span class="type">char</span> *rio_bufptr;</span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE];</span><br><span class="line">&#125; <span class="type">rio_t</span>;</span><br></pre></td></tr></table></figure><p>更多的内容大家可以通过阅读 RIO Package 的源码获取，并且可以在此基础上包装属于自己的 routines；</p><h3 id="17-5-File-Metadata-Sharing-and-Redirection"><a href="#17-5-File-Metadata-Sharing-and-Redirection" class="headerlink" title="17.5 File Metadata, Sharing and Redirection"></a>17.5 File Metadata, Sharing and Redirection</h3><h4 id="17-5-1-Metadata"><a href="#17-5-1-Metadata" class="headerlink" title="17.5.1 Metadata"></a>17.5.1 Metadata</h4><p>几乎所有操作系统平台上，每个文件中都有一个非常重要的部分是文件元数据（file metadata）。所谓 metadata 就是文件中实际包含的数据的信息，例如<strong>应用层级的文件类型信息、文件权限信息（R/W/X）、文件所有权信息、创建/访问/修改时间……</strong></p><blockquote><p>什么？你说 Windows 上创建一个文本文件，然后把后缀名删了，好像就没有了？其实操作系统在创建文件、在显示到桌面之前就将文件元信息设置好了，不信你看看右击属性。</p></blockquote><p>在 Unix 系统中，这种 metadata 以一个结构体 <code>stat</code> 进行存储，这种结构体类型也是 C library 函数 <code>stat</code>、<code>fstat</code>（查看文件元数据的函数）的返回值类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Metadata returned by the stat and fstat functions */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>st_dev; <span class="comment">/* Device */</span></span><br><span class="line">    <span class="type">ino_t</span>st_ino; <span class="comment">/* inode */</span></span><br><span class="line">    <span class="type">mode_t</span>st_mode; <span class="comment">/* Protection and file type */</span></span><br><span class="line">    <span class="type">nlink_t</span>st_nlink; <span class="comment">/* Number of hard links */</span></span><br><span class="line">    <span class="type">uid_t</span>st_uid; <span class="comment">/* User ID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>st_gid; <span class="comment">/* Group ID of owner */</span></span><br><span class="line">    <span class="type">dev_t</span>st_rdev; <span class="comment">/* Device type (if inode device) */</span></span><br><span class="line">    <span class="type">off_t</span>st_size; <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blksize; <span class="comment">/* Blocksize for filesystem I/O */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blocks; <span class="comment">/* Number of blocks allocated */</span></span><br><span class="line">    <span class="type">time_t</span> st_atime; <span class="comment">/* Time of last access */</span></span><br><span class="line">    <span class="type">time_t</span> st_mtime; <span class="comment">/* Time of last modification */</span></span><br><span class="line">    <span class="type">time_t</span> st_ctime; <span class="comment">/* Time of last change */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *statbuf)</span>;    <span class="comment">/* `fd` should be a valid open file descriptor. */</span></span><br></pre></td></tr></table></figure><p>如何用这些数据？一般情况下，我们可以借助一些 C library 内置宏来检查数据的含义。这里不多赘述，以一个程序为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">char</span> *type, *readok;</span><br><span class="line">    </span><br><span class="line">    Stat(argv[<span class="number">1</span>], &amp;stat);</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(stat.st_mode))    <span class="comment">/* Determine file type. */</span></span><br><span class="line">        type = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(stat.st_mode))</span><br><span class="line">        type = <span class="string">&quot;directory&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> type = <span class="string">&quot;other&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (stat.st_mode &amp; S_IRUSER)    <span class="comment">/* Check read access. */</span></span><br><span class="line">        readok = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> readok = <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;type: %s, read: %s\n&quot;</span>, type, readok);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>知识补充：Unix 系统中的 man page 的正确使用方法。</p><p>我们都知道，Unix 中的 <code>man</code> 指令相当于一个帮助文档，通常情况下，<code>man &lt;fname&gt;</code> 会进入 <code>fname</code> 所添加的帮助文档的<strong>第一章</strong>中。你可以使用 <code>man &lt;chapterN&gt; &lt;fname&gt;</code> 来指定查看第几章的 <code>fname</code> 文档。</p><p>在 man 程序管理帮助文档的规范中，每章的内容有明确的使用范围：</p><p>man 的第一章通常介绍 <code>fname</code> 作为一个<strong>系统指令</strong>（编译为了一个二进制文件放在系统中）的使用方法，通常包含一些该命令的命令行技巧和参数；</p><p>man 的第二章通常介绍 <code>fname</code> 作为一个<strong>系统级函数/系统调用</strong>在源码中的使用方法，通常包含了一些该函数的 API 文档内容和声明；</p><p>有些 <code>fname</code> 既在 Unix 中包装成了二进制的程序供命令行使用，又在头文件和系统的链接库中存在，以供源码使用（例如 <code>kill</code>），所有会同时存在这两章。</p><p>man 还有更多的章节，一般到第 8 章，其中的含义可以自行搜寻。</p></blockquote><h4 id="17-5-2-File-Sharing-amp-File-Descriptor"><a href="#17-5-2-File-Sharing-amp-File-Descriptor" class="headerlink" title="17.5.2 File Sharing &amp; File Descriptor"></a>17.5.2 File Sharing &amp; File Descriptor</h4><p>之前我们用了很长时间的 “file descriptor” 这个名词，接下来将讨论一下所有的文件在程序中如何用 file descriptor 进行标识，或者说，背后的机制是怎样的。</p><blockquote><p>⚠ <strong>这里是考试的难点！！！光听老师讲、看这部分的信息，想把题目做对是不够的！需要自行研究习题和历年考题。</strong></p></blockquote><p>OS 内部很多内部数据结构都与具体执行中的进程有关，例如前面提到的页表、用户栈、OS Kernel 等等，它们都存放在这个进程对应的虚拟内存中。</p><p>文件描述符也不例外，<strong>每个进程都会在其虚拟内存中维护唯一一个描述符表（descriptor table）</strong>。</p><p>还有两种非常特殊的数据结构，一种是 <strong>文件表（open file table）</strong>，另一种是 <strong>虚拟结点表（v-node table）</strong>；<strong>它们被计算机中所有进程共享</strong>；</p><p>如图所示：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/fd.png"></p><p>很早之前我们就了解过，文件描述符为 0、1、2 的特殊含义，这里不再赘述。</p><p>我们需要注意以下几点：</p><ul><li><p>v-Node Table 就是 Unix files 的 <code>stat</code> 结构体的表，每个 v-Node Table 与物理存储器上的文件<strong>一一对应</strong>（双射），无论文件是否被打开；</p></li><li><p>Descriptor Table 各个 entry 的内容存放的是<strong>指向各个 Open File Table 的指针</strong>，也表示<strong>当前进程已打开但未关闭的文件</strong>。而描述符相当于是对 Descriptor Table 的<strong>索引</strong>；</p></li><li><p>Open File Tables 由 OS Kernel 维护。每个 Open File Table 的第一个字段即为指向 v-Node Table 的指针，与每个 v-Node Table 的关系<strong>必然是函数关系，但既不是单射也不是满射</strong>；</p><blockquote><p>即：</p><ol><li><p>对任意一个 Open File Table 而言，它必然指向一个唯一的 v-Node Table（即物理文件）；</p></li><li><p>存在两个 Open File Table 它们指向<strong>同一个物理文件（也就是同一个 v-Node Table）</strong>，但他们本身不一定完全相同，因为它们的字段 <strong><code>File pos</code> 是分别由各个打开进程维护的</strong>。</p><p><strong>这意味着程序调用了两次 <code>open</code>，但是参数是同一个 filename</strong>（再次强调：<strong>可能在不同的进程中，而且 <code>File pos</code> 不一定相同</strong>），如下图：</p></li></ol><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/fd_same_open.png" height="300px"></p><ol><li><p>允许一个 v-Node Table 不被任何 Open File Table 指向。</p><p><strong>这意味着这个物理文件还没有被程序的任何进程打开过</strong>。</p></li></ol></blockquote></li><li><p>每个 Open File Table 的第二个字段是 <code>refcnt</code>（reference count，引用计数），这个字段表明这个 Open File Table 被描述符表中的多少个 entry 指向；</p><blockquote><p>为什么要有这项数据？</p><p>因为在程序中，可能出现多进程（尤其是 <code>fork()</code> 产生）共享文件资源的情况，这时 OS 需要追踪内存分配，如果程序结束时，OS 需要回收这些部分（引用次数为 0 时不会立即清除）。堆的内存管理也有这种机制，不过比这个复杂很多。</p></blockquote></li></ul><p>有个相当重要的点，回忆一下，之前讨论 <code>fork</code> 的时候提到，创建的子进程总是可以直接继承使用父进程的文件描述符，达到二者共享文件资源的目的。但是，之前说描述符表是由每个进程的 OS Kernel 单独维护的。</p><p>那么这样的情况下，父子进程共享的文件资源是如何实现的？如下图过程：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/file_sharing_before.png" height="300px"></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/file_sharing_after.png" height="300px"></p><p>总结一下父子进程共享文件描述符的要点：</p><ul><li>子进程<strong>完全复制</strong>父进程的描述符表；</li><li>父进程描述符表中指向的所有文件表的引用计数各加 1；</li></ul><p>因此我们得知，<strong>父子进程共享的不是物理文件，而是 Open File Tables</strong>（共用了文件指针）；这意味着父子进程任意一方读写文件，二者的文件指针一起变化；</p><p>⚠ <strong>最重要的是，每个进程都必须显式调用 <code>close</code>（除了 0、1、2 号文件），才能最终使引用计数为 0，操作系统才能回收。</strong></p><h4 id="17-5-3-I-O-Redirection"><a href="#17-5-3-I-O-Redirection" class="headerlink" title="17.5.3 I/O Redirection"></a>17.5.3 I/O Redirection</h4><p>再思考一个问题，Unix Shell 是如何实现 I/O 管道流和重定向的功能的呢？实际上，这个功能的实现也与文件描述符表有关。我们以一个例子为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> &gt; foo.txt</span><br></pre></td></tr></table></figure><p>这个指令将 <code>ls</code> 命令输出的结果重定向到 <code>foo.txt</code> 文件中，实际在 shell 的源码中应该使用了一个特殊的系统级函数（再次提示，系统级函数是<strong>系统调用的封装</strong>）：<code>dup2</code>；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* More: */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;    <span class="comment">/* uses the lowest-numbered unused descriptor for the new descriptor. */</span></span><br></pre></td></tr></table></figure><ul><li>作用：<strong>先将描述符为 <code>newfd</code> 的文件关闭以释放资源，再将描述符为 <code>oldfd</code> 的 descriptor table entry 复制到指定描述符为 <code>newfd</code> 的 entry 中</strong>；<ul><li>⚠ 如果 <code>oldfd</code> 是无效的描述符（即 descriptor table 在该位置的 entry 不指向有效的 open file table），则 <code>dup2</code> 执行错误，<strong>这个时候 <code>newfd</code> 对应的资源不会关闭</strong>；</li><li>⚠ 如果 <code>oldfd</code> 是有效的描述符，但是 <code>newfd == oldfd</code>，<strong>那么 <code>dup2</code> 什么都不会做，直接返回 <code>newfd</code></strong>;</li></ul></li><li>返回值：如果正确执行，则返回更新后的 <code>newfd</code>；如果执行错误，则返回 <strong>-1</strong> 并且设置 <code>errno</code>；</li></ul><p>切记，这条指令相当危险，除非你是在设计与操作系统层级很近的应用程序（例如 shell），否则不用轻易使用它，因为它能轻易将你绕晕，不知道哪些文件还没有释放。</p><h4 id="17-5-4-Standard-I-O"><a href="#17-5-4-Standard-I-O" class="headerlink" title="17.5.4 Standard I/O"></a>17.5.4 Standard I/O</h4><p>这里的库是 C standard library 包装的一些更高层级的 I/O 接口，它和之前我们接触到的 Unix I/O、RIO 的关系如下：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/IO_interface.png"></p><p>这些标准 I/O 实际上是 C 的一部分。先归一归类，大家都比较熟悉了：</p><ul><li>Opening and closing files（<code>fopen</code>、<code>fclose</code>）；</li><li>Reading and writing files（<code>fread</code>、<code>fwrite</code>）；</li><li>Reading and writing text files（<code>fgets</code>、<code>fputs</code>）；</li><li>Formatted reading and writing（<code>fscanf</code>、<code>fprintf</code>）；</li></ul><p>不仅如此，你见到的很多 standard I/O 都带有 buffering，所以规避了很多低层级的操作。</p><p>那么 standard I/O 的 buffer 和 RIO 的 buffer 有什么不同呢？</p><p><strong>在功能上</strong>，standard I/O 对于终端文件（terminal）或普通文件的访问方面包装显然要远远优于 RIO；但是 standard I/O 没有考虑到一些网络套接字方面的细节和小问题，所以在<strong>网络套接字的读写方面</strong>用起来还是 RIO 更胜一筹。</p><p><strong>在 buffer 设计上</strong>，standard I/O buffer 有一套 <strong>flush 机制</strong>。</p><p>对于写的情况，standard I/O 的 buffer 仅当出现以下情况之一时，才将 buffer 整体写入 Unix file，这么做可以减少系统调用次数，提升程序性能：</p><ul><li>标准输出函数（<code>fprintf/sprintf/...</code>）的结尾含有 <code>\n</code> 换行（<strong>换行结尾</strong>）；</li><li>Standard I/O 内部的 buffer 已经写满（<strong>缓冲占满</strong>）；</li><li>执行标准输出函数的进程从 <code>main</code> 函数退出了（<strong>程序结束</strong>）；</li><li>程序显式地调用 <code>fflush(FILE*)</code> 刷新缓冲区（<strong>手动刷新</strong>）；</li></ul><p>而 RIO 设定了固定大小的 buffer，并根据用户输入的读取或写入的大小分次进行系统调用，二者各有利弊。</p><p>综上，RIO 比 standard I/O 更适宜用在网络套接字读写方面，而 standard I/O 则在其他大部分文件读写的情况下表现更加优秀。</p><h3 id="17-6-Summary-of-System-I-O"><a href="#17-6-Summary-of-System-I-O" class="headerlink" title="17.6 Summary of System I/O"></a>17.6 Summary of System I/O</h3><p>本章开始，我们介绍了 Unix File 的概念和常见类型。对于 Unix File 的基本操作，则被操作系统抽象成了 Unix I/O（有系统级函数、系统调用），这些操作非常底层，不过有优势也有劣势：</p><ul><li>Pros<ul><li>Unix I/O 是<strong>最通用、开销最小的 I/O 接口形式</strong>（其他所有 I/O 库都基于此）；</li><li>Unix I/O 提供了一系列访问文件 metadata 的函数（<code>stat</code>、<code>fstat</code>）；</li><li>⚠ <strong>重大优点：它们都是 异步信号安全 的，可以用在 signal handlers 中</strong>；</li></ul></li><li>Cons<ul><li>应对 short counts 的处理很麻烦（尤其是应对 <code>EINTR</code> 和网络传输时），容易出错；</li><li>想要按照文本行读取出一行也很麻烦，也易错；</li></ul></li></ul><p>Standard I/O 非常优秀，同样有它的优缺点：</p><ul><li>Pros<ul><li>使用特殊的 buffer 机制，减少了系统调用的访问次数；</li><li>自动解决 short counts 的异常问题；</li></ul></li><li>Cons<ul><li>不提供访问文件元信息的接口；</li><li>其中的函数几乎<strong>都不是</strong>异步信号安全的函数；</li><li>不适宜用在读写网络套接字上，很容易出错；</li></ul></li></ul><p>最后，根据各个 I/O 的封装特性和抽象层级，我们可以总结出这些 I/O 库的选择注意事项 和 推荐：</p><p><strong>⚠ 注意事项 ⚠</strong></p><ol><li><p><strong>在条件允许的情况下，尽可能使用抽象层级高的 I/O 库</strong>；</p><blockquote><p>这样可以避免一些诸如 <code>EINTR</code>（之前提到，这个系统错误码是因为运气不好，重新调用一次就能修复）等底层奇奇怪怪的信息或错误；</p></blockquote></li><li><p><strong>使用 I/O 库的接口前，一定弄清楚接口的具体作用和逻辑</strong>；</p><ul><li><p>例如<strong>读二进制文件不能用 识别文本信息 的接口</strong>（例如用 <code>rio_readlineb</code> 去读图片、用 <code>strlen/strcpy</code> 去操作 socket 数据）；</p><blockquote><p>因为大多数识别文本信息的接口，尤其是按行输入的，会识别文本中的换行符（<code>0xa</code> 或 <code>0xd 0xa</code>，即 <code>EOL</code>，end of line），并以此分割读入；</p><p>不仅如此，它们还会把 byte value 0 解释为文本结束（end of string），这样会导致读入操作提前结束。而 <code>0x0</code> 只不过是二进制数据中一个数据而已，只有字符串是以 0 结尾的。</p></blockquote></li></ul></li><li><p><strong>Standard I/O 和 RIO 不应该混合使用！因为二者内部维护的 buffer 不同，在运行中可能出现干扰和错误</strong>；</p></li></ol><p><strong>ℹ 使用建议 ℹ</strong></p><ol><li>当 I/O 操作的对象是 <strong>disk / terminal files</strong> 的时候，使用 Standard I/O 最佳；</li><li>当需要一些尽量底层的操作（例如写 signal handlers 时），或者极其需要程序性能的时候（少见），使用 raw I/O（Unix I/O）；</li><li>当 I/O 操作的对象是网络 socket 文件时，最好使用 RIO 来处理一些特殊的情况，例如 <code>EINTR</code> 和针对网络的 short counts 的处理；</li></ol><hr><p>补充知识：操作目录文件</p><p><strong>唯一推荐对 directory 的操作：打开、读取 entries</strong>；</p><p>看下面的这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *directory;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">de</span>;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">if</span> (!(directory = opendir(dir_name)))</span><br><span class="line">        error(<span class="string">&quot;Failed to open directory&quot;</span>);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != (de = readdir(directory))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found file: %s\n&quot;</span>, de-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    closedir(directory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chapter-8-The-Memory-Hierarchy&quot;&gt;&lt;a href=&quot;#Chapter-8-The-Memory-Hierarchy&quot; class=&quot;headerlink&quot; title=&quot;Chapter 8. The Memory Hierarchy&quot;</summary>
      
    
    
    
    <category term="review" scheme="https://sjtuxhw.top/categories/review/"/>
    
    
    <category term="GNU" scheme="https://sjtuxhw.top/tags/GNU/"/>
    
    <category term="CSAPP" scheme="https://sjtuxhw.top/tags/CSAPP/"/>
    
    <category term="ICS" scheme="https://sjtuxhw.top/tags/ICS/"/>
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>《只有我不在的城市》番评</title>
    <link href="https://sjtuxhw.top/2023/10/01/%E3%80%8A%E5%8F%AA%E6%9C%89%E6%88%91%E4%B8%8D%E5%9C%A8%E7%9A%84%E5%9F%8E%E5%B8%82%E3%80%8B%E7%95%AA%E8%AF%84/"/>
    <id>https://sjtuxhw.top/2023/10/01/%E3%80%8A%E5%8F%AA%E6%9C%89%E6%88%91%E4%B8%8D%E5%9C%A8%E7%9A%84%E5%9F%8E%E5%B8%82%E3%80%8B%E7%95%AA%E8%AF%84/</id>
    <published>2023-10-01T02:20:47.000Z</published>
    <updated>2023-10-25T12:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: </i> 维基百科词条、<a href="https://movie.douban.com/subject/26427106/">只有我不在的街道 (豆瓣)</a></p><p><strong>声明：本文仅代表个人主观观点，侵删。</strong></p><p><strong>【重要】本文除去剧透警戒线下部分，其他内容不含具体故事情节。</strong></p><hr><p>在我看过的一百多来部的番剧中，有的能真正扣住我心弦，这大抵是少数；现在看来大多却是 “食之无味，弃之可惜”。初中时期的我曾经浅浅尝试过一部，但是由于开头比较惊悚的画面，还有网友打上的 NTR 标签，让我一直敬而远之、束之高阁。这部番的名字是《只有我不在的城市》(僕だけがいない街) 。</p><p>距离我第一次接触它已经过了好几年的时间，我也不是当年看番只看 HE 类型的观众了。于是我鼓起勇气，在这个国庆重温了这个多年前的老动画。</p><p>本以为我每天在睡前看一小会很快就能结束，可是万万没想到，我最终却熬了大夜将其一口气补完了。没错，在我个人看来，这部番绝对算得上是能排上名的一个相当优秀的作品。下面我将从我自己的视角来讲述这个作品带给我的小小震撼。</p><h3 id="优秀的理由"><a href="#优秀的理由" class="headerlink" title="优秀的理由"></a>优秀的理由</h3><blockquote><p>注：本节几乎没有剧透内容。</p></blockquote><p>这个作品是由同名漫画动画化而来，本人先观看了动画作品，而后再了解的漫画，所以这里的评价主要是围绕着<strong>动画的表现</strong>。</p><p>在我心目中，一个番剧想要做到不淹没在其他同质化的番剧之中、“泯然众人”，达到优秀的层面，有这几点要求：<strong>世界观的架构（设定）</strong>或真实或新颖，<strong>故事逻辑</strong>清晰合理，<strong>故事情节</strong>或流畅或跌宕，<strong>人物刻画</strong>不千篇一律。</p><p>《只有我不在的城市》在这些方面看来就已经超过了许多 “流水线生产” 的番：</p><ul><li>设定上男主（悟）生活在普通城市，有 “重放” 的能力。这一点虽然和<a href="https://zh.moegirl.org.cn/%E5%91%BD%E8%BF%90%E7%9F%B3%E4%B9%8B%E9%97%A8%E7%B3%BB%E5%88%97"><strong>石头门</strong></a>的设定有些相似，但不至于落入俗套；并且在情节的加持下，真正观看的时候反而是一个比较吸引人的点；</li><li>故事的情节发展遵循唯一主线，紧密跟随男主视角；叙事节奏相当紧凑，但不慌乱，整体给人一种 “看完一集就忍不住继续下一集” 的想法；</li><li>故事对发生的事件和人物的描绘非常讲究主次和详略，对关键人物和群体的性格表现的比较丰满和立体，不会出现特意为某些角色补戏份、添加降智行为，或者套上标签和刻板印象的情况。</li><li>这部作品无论是动画还是漫画，其画风都比较戳我，颜值尚佳。</li></ul><blockquote><p>遗憾的是，最近这段时间我能找到的番剧中，达到甚至超越上面特征的可谓凤毛麟角。</p></blockquote><p>最后，还是在我<strong>个人</strong>看来，这部作品并没有让我避之不及的 NTR 元素，纯爱战士也能够无伤通关，所以别因为这一点而停下你观赏的脚步。至于原因我会在后面分析，这毕竟是比较主观的方面，一千个人眼中有一千个哈姆雷特嘛。</p><p>🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧 ⚠⚠⚠ <strong>剧透警告</strong> ⚠⚠⚠ 🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧</p><h3 id="故事的主线梳理"><a href="#故事的主线梳理" class="headerlink" title="故事的主线梳理"></a>故事的主线梳理</h3><p>这里简短地回顾一下在动画中的叙事内容。</p><p>首先 29 岁的男主 <strong>藤沼悟</strong> 出生于 1977 年 3 月 2 日，刚登场时看起来发表过一些漫画作品，在披萨店 <code>Oasi Pizza</code> 打工。他的 “重放” 能力能够倒退时间（自身无法控制），回到事件（<strong>通常是坏事件</strong>）未发生的时候。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/z_1.jpg" height="300px"></p><p>2006 年，<strong>悟</strong> 在某次在打工中途借助了能力救下了一位小学生，恰巧被披萨店的同事 <strong>片桐爱梨</strong> 看见。虽然受到了轻伤，但他的母亲 <strong>藤沼佐知子</strong> 因为担心他，而决定暂时搬过来照顾他。一日，打工回来的他目睹母亲死亡的现场，却被当作凶手通缉。情急之下 <strong>悟</strong> 无意间触发了 “重放” 而回到了 1988 年，也就是自己就读于市立美琴小学的时期。这是 <strong>悟</strong> 从最开始的时间线跳跃到第二条时间线。</p><p>为了解决发生在上个时间线上的小学生连续诱拐事件，同时想办法避免母亲的死亡（据主角推测，是因为目前猜出当年的真正凶手，才惨遭毒手），<strong>悟</strong> 想尽办法与 <strong>雛月加代</strong>（连环案中第一个遇害的学生）处好关系，却在生日（主角推算的案发时间）过后的第二天失踪——这仅仅将她的遇害时间延迟到了 3 月 3 日。到此，主角的所做的努力以失败告终。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/z_2.jpg" height="300px"></p><p>在 <strong>悟</strong> 结束 “重放”，回到第二个时间线的 2006 年时，他仍然是警方通缉的对象。在与警察的周旋中，<strong>片桐爱梨</strong> 坚信 <strong>悟</strong> 不是弑母凶手，帮助 <strong>悟</strong> 躲避警察追捕。也正因如此，她被真正的犯人纵火困于居住地而昏迷，最后被 <strong>悟</strong> 和 <strong>高桥店长</strong> 救出。在 <strong>爱梨</strong> 住院期间，为了避开警方监视，她拜托母亲伪装，自己逃出意愿与 <strong>悟</strong> 会面，提供了真凶可能是 <strong>西园学</strong>（原名 八代学，1988 年是 悟 的小学班主任）的线索。紧接着 <strong>悟</strong> 继续 “重放”，回到 3 月 2 日 <strong>加代</strong> 未遇害的第三条时间线。</p><p><strong>悟</strong> 在第三条时间线上成功阻止了 3 人被害，但真凶，就是当时的 <strong>八代学</strong>，设圈套利用被孤立的 <strong>柳原美里</strong> 骗 <strong>悟</strong> 并使其溺水成为植物人的状态。15 年后在医院苏醒，在取回记忆后，识破 <strong>西园学</strong>（以前的 八代学）的诡计，并用计让 <strong>西园学</strong> 坦白罪行。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/z_3.jpg" height="300px"></p><p>故事的最后，<strong>西园学</strong> 被逮捕，而 <strong>悟</strong> 成为了人气漫画家，在桥下躲雪与 <strong>爱梨</strong> 相遇，全剧终。</p><h3 id="番剧内容补充"><a href="#番剧内容补充" class="headerlink" title="番剧内容补充"></a>番剧内容补充</h3><p>事实上，这个动画刷完后，我还有一些地方不是很理解，或者说突兀，例如 八代学 的作案动机等。根据网友的解答，这和动画版删改的细节有关。</p><p>漫画中曾提到，八代学 的哥哥是一个三观扭曲的罪犯，在他的影响下，八代学 小时候就将朋友赠送的数只仓鼠尽数处决。不仅如此，漫画中还交代了他还是个非常缜密的罪犯，他只会找几个特质的人进行处决：“孤立”、“无助”、“不关心他人”、“孩童”，这些人在他的眼中仿佛是 <strong>攀于蛛丝上的犍陀多</strong>（用典 “蜘蛛之丝”）。他想要看到他所处决的对象对于生命执著的样子，而他能从中取得 “快乐”。而且他每处决一人之前，都会先做好缜密的计画，包含了如何取得被害人信任，以及怎样消除能追到他的证据，甚至是如何把这些罪行推到无关的人身上。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/3_1.jpg" width="350px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/3_2.jpg" width="350px" align=center></div></div></div></div><p>至于为什么 八代学 在 悟 破坏了他的计划后的 15 年内都没有犯罪，这在漫画中有所暗示，其实不是如此。他设计抹除了他入赘的议员女儿的男朋友，之后入赘到这个议员家里面改姓 “西园”，之后又设计做了岳父，取得了他的人脉后当上议员。接下来靠著议员的身份一直在观察 悟，希望他能够苏醒后亲手处决他。</p><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>这部带给我的不仅仅是绮丽的画风、引人入胜的紧凑剧情以外，我更喜欢的是作者笔下的人情世故。</p><p>悟 坐在 八代学 的车上说，“我想要弥补人心中的空缺”。在成长过程中，我们可能或多或少遇到这样那样的缺失——应该说却没说出口的话，应该保护却没有保护好的人，应该挺身而出却逃避的事……悟 心中的心结之一就是没能在那天夜晚叫上 加代 回家，这样很可能她就不会遇害了。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/0_k.jpg" height="300px"></p><p>通过 “重放” 回到以前的 悟，卸下以往不关心他人的面具，29 岁的灵魂也勇于说出 “成为正义的伙伴” 的豪言壮语，勇敢地保护同伴，让追求正义地精神感染了身边地同伴，以实际行动弥补过去地遗憾和后悔。虽然最后 悟 在第三条时间线上牺牲了自己 18 年的青春，换来的是伙伴们的安然无恙，算是呼应了作品的标题 “只有我不在的城市”。</p><p>作者通过这种方式，向我们传递了 “悟以往之不谏，知来者之可追” 的人生态度。尽管我们多多少少心怀遗憾，心想 “如果当时这么做就好了”，但也希望我们像假面超人一样的坚韧不拔。我们无法回到过去，但我们拥有未来。愿我们不被胆怯束缚，敢闯敢拼，不留遗憾。</p><p>悟 的母亲 佐知子 也是一个让我印象深刻的人物。尽管警察没有采用 悟 的证言，她在看到 悟 坚定的眼神和解释后，选择相信 悟，并且在第一时间线的 18 年中都一直联系媒体同事追查真凶，即使案件已过追诉时效。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/0_s.jpg" height="300px"></p><p>在三时间线的最后，悟 在成为植物人的 15 年间，母亲 佐知子 在商店打工照顾 悟，日复一日，她也坚信自己的儿子有一天终将会醒来。动画中，制作组给到的无声的镜头，例如母亲望向柜面上浓重的黑眼圈，独自坐在在公园长椅上，注视着前方熙攘的人群。很难想象，这 15 年里究竟是什么支撑着母亲、又是什么给予母亲继续的希望。想到这里，一种酸楚的感觉仿佛涌上心头。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/0_1.jpg" width="350px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/0_2.jpg" width="350px" align=center></div></div></div></div><p>在作者和制作组的笔下，佐知子 这位观察力敏锐、行动力强、坚强善良和极富舐犊之情的母亲形象跃然纸上。</p><p>作品的最后，加代 没有成为 悟 的妻子，这固然是一个遗憾，但这又未尝不是这个作品情节和设计的新颖之处呢？在漫画的外传中，加代 无比感激 悟 为她所做的一切，每天都去 悟 所在的医院协助 佐知子 帮 悟 进行肌肉按摩，一直与他谈学校的故事。直到上了国中以后，悟 更换了病房，善意的 佐知子 给 加代写了封信，一方面是感谢 加代 能给 佐知子 希望，另一方面则是希望加代能把握 “现在”，找到属于自己的另一半。</p><p>这样的设计的情节却更加真实，不落窠臼，也是让我眼前一亮的优点。就像网友所说，“悟选择奋不顾身地去拯救加代，不是出于对加代的爱慕，而是童年时对正义超人的憧憬，和由于过去无法挽救加代而一直深埋潜意识的挥之不去的愧疚”。所以说，<strong>战胜恶龙的勇者需要的或许不是那位被拯救的公主</strong>。这也是这部作品脱离千篇一律的 “包饺子” 结局的一个重要特征。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/0_0.jpg" height="300px"></p><blockquote><p>从这个角度来看，这个作品（叠甲：<strong>在我个人看来</strong>）是没有 NTR 的成分的，至少我的第一印象如此。并不是所有的结局都是理想直至虚无缥缈的 “大团圆”。</p></blockquote><p>另外插一嘴，动画制作组真的细节，在 11 集的 OP 中移除了 悟 的身影，暗示着 悟 成功更改了时间线，这是只有 悟 不存在的城市。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/1_1.jpg" width="350px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/1_2.jpg" width="350px" align=center></div></div></div></div><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/2_1.jpg" width="350px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/2_2.jpg" width="350px" align=center></div></div></div></div><hr><p>最后，喜欢这部动画的观众可以找到对应的漫画（44 话 + 外传）进行进一步阅读，相信会有不一样的感受😉</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt; 维基百科词条、&lt;a href=&quot;https://movie.douban.com/subject/26427106/&quot;&gt;只有我不在的街道 (豆瓣)&lt;/a&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Chat" scheme="https://sjtuxhw.top/categories/Chat/"/>
    
    
    <category term="Anime" scheme="https://sjtuxhw.top/tags/Anime/"/>
    
    <category term="Appreciation" scheme="https://sjtuxhw.top/tags/Appreciation/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Notes Part 1</title>
    <link href="https://sjtuxhw.top/2023/09/17/CSAPP-Notes-Part-1/"/>
    <id>https://sjtuxhw.top/2023/09/17/CSAPP-Notes-Part-1/</id>
    <published>2023-09-17T11:47:15.000Z</published>
    <updated>2023-12-26T06:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: </i> <a href="http://www.cs.cmu.edu/~213/schedule.html">CMU - 213</a>, <i>Computer Systems A Programmer’s Perspective 3rd Edition</i> by Randal Bryant, David O’Hallaron</p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p><i>内容很长，写起来很慢</i> 😳</p><hr><span id="more"></span><h2 id="Chapter-0-Intro"><a href="#Chapter-0-Intro" class="headerlink" title="Chapter 0. Intro"></a>Chapter 0. Intro</h2><h3 id="0-1-Ints-are-not-Integers-Floats-are-not-Reals"><a href="#0-1-Ints-are-not-Integers-Floats-are-not-Reals" class="headerlink" title="0.1 Ints are not Integers, Floats are not Reals"></a>0.1 Ints are not Integers, Floats are not Reals</h3><ul><li>$x^2\ge 0$：int（32-bit）may overflow；</li><li>$a+(b+c)=(a+b)+c$：floats may discard some “unsignificant” digits；</li></ul><h3 id="0-2-Learn-Assembly-but-never-write-it"><a href="#0-2-Learn-Assembly-but-never-write-it" class="headerlink" title="0.2 Learn Assembly but never write it"></a>0.2 Learn Assembly but never write it</h3><h3 id="0-3-Memory-Matters-Unbounded"><a href="#0-3-Memory-Matters-Unbounded" class="headerlink" title="0.3 Memory Matters: Unbounded"></a>0.3 Memory Matters: Unbounded</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125; <span class="type">struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">struct_t</span> t;</span><br><span class="line">    t.d = <span class="number">3.14</span>;</span><br><span class="line">    t.a[i] = <span class="number">109390032</span>;</span><br><span class="line">    <span class="keyword">return</span> t.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// func(0)/func(1) -&gt; 3.14</span></span><br><span class="line"><span class="comment">// func(2)    -&gt; 3.13...</span></span><br><span class="line"><span class="comment">// func(6)    -&gt; segment fault</span></span><br></pre></td></tr></table></figure><ul><li>C/C++ don’t provide <strong>any</strong> memory protection（out of bounds/invalid pointer/abuse of malloc-free）: can lead to nasty bugs.</li></ul><h3 id="0-4-There’s-more-to-performance-than-asymtotic-complexity"><a href="#0-4-There’s-more-to-performance-than-asymtotic-complexity" class="headerlink" title="0.4 There’s more to performance than asymtotic complexity"></a>0.4 There’s more to performance than asymtotic complexity</h3><p>(有比渐进复杂度更能够优化性能的做法)</p><ul><li>渐进复杂度中没有体现的“常数”也很重要；</li><li>应该在多方面优化性能：算法、数据结构表示、代码过程、循环等；</li><li><strong>Understand system to optimize performance</strong>;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyij</span><span class="params">(<span class="type">int</span> src[<span class="number">2048</span>][<span class="number">2048</span>], dst[<span class="number">2048</span>][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2048</span>; ++j)</span><br><span class="line">            dst[i][j] = src[i][j];        <span class="comment">// Row first.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyji</span><span class="params">(<span class="type">int</span> src[<span class="number">2048</span>][<span class="number">2048</span>], dst[<span class="number">2048</span>][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2048</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; ++i)</span><br><span class="line">            dst[i][j] = src[i][j];        <span class="comment">// Column first.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In a particular machine it was about close to 20 times difference in performance! (4.3ms vs 81.8ms) </span></span><br><span class="line"><span class="comment">// Memory hierachy: Cache memory</span></span><br></pre></td></tr></table></figure><h3 id="0-5-Computers-do-more-than-execute-programs"><a href="#0-5-Computers-do-more-than-execute-programs" class="headerlink" title="0.5 Computers do more than execute programs"></a>0.5 Computers do more than execute programs</h3><ul><li>They need to get data in &amp; out: I/O system;</li><li>They communicate with each other over network;</li></ul><h2 id="Chapter-1-Bits-Bytes-and-Integers"><a href="#Chapter-1-Bits-Bytes-and-Integers" class="headerlink" title="Chapter 1. Bits, Bytes and Integers"></a>Chapter 1. Bits, Bytes and Integers</h2><h3 id="1-1-Everythings-is-bits"><a href="#1-1-Everythings-is-bits" class="headerlink" title="1.1 Everythings is bits"></a>1.1 Everythings is bits</h3><blockquote><p>本部分知识零碎，应该在数电 + 初级数据结构中接触。</p></blockquote><ul><li>Each bit is 0 or 1;</li><li>By encoding/interpreting sets of bits in various ways;</li><li>Why bits? - Electronic Implemetation.<ul><li><strong>Easy to store</strong> with bistable elements.</li><li><strong>Reliably transmitted</strong> on noisy and inaccurate wires.</li></ul></li><li><strong>Base 2 Number Representation</strong></li><li><p>1 Byte = 8 bits；</p><ul><li>Binary: $00000000_2$ to $11111111_2$；</li><li>Decimal: $0_{10}$ to $255_{10}$；</li><li>Hexadecimal: $00_{16}$ to $FF_{16}$；<ul><li>掌握快速 16 进制转 2 进制：$1010=A,\space1100=C,\space1111=F$，B/D/E 在其中；</li></ul></li></ul></li><li><p>Data Representation in C language</p><table>    <tr>        <td>C Data Type</td>        <td>Typical 32-bit</td>        <td>Typical 64-bit</td>        <td>x86-64</td>    </tr>    <tr>        <td>char</td>        <td>1</td>        <td>1</td>        <td>1</td>    </tr>    <tr>        <td>short</td>        <td>2</td>        <td>2</td>        <td>2</td>    </tr>    <tr>        <td>int</td>        <td>4</td>        <td>4</td>        <td>4</td>    </tr>    <tr>        <td>long</td>        <td>4</td>        <td>8</td>        <td>8</td>    </tr>    <tr>        <td>float</td>        <td>4</td>        <td>4</td>        <td>4</td>    </tr>    <tr>        <td>double</td>        <td>8</td>        <td>8</td>        <td>8</td>    </tr>    <tr>        <td>long double</td>        <td>N/A</td>        <td>N/A</td>        <td>10 / 16</td>    </tr>    <tr>        <td>pointer</td>        <td>4</td>        <td>8</td>        <td>8</td>    </tr></table><ul><li><strong>注：单位 bytes，CSAPP 关注 x86-64 架构</strong>；</li><li><strong>注2：Intel x86-64 处理器的 <code>long double</code> 定为 10 bytes，但数据增量是 16 bytes，意味着会浪费 6 bytes 的存储空间</strong>；</li><li><strong>注3：pointer 值就是虚拟空间的地址，上面也正说明了 32 位和 64 位的名字的来源：这些虚拟内存的地址是 32 bits / 64 bits 长度的值</strong>；我们常说的 32 位机器、64 位机器就是指对应地址值的长度是 32/64 bits；</li></ul></li></ul><h3 id="1-2-Boolean-Algebra"><a href="#1-2-Boolean-Algebra" class="headerlink" title="1.2 Boolean Algebra"></a>1.2 Boolean Algebra</h3><ul><li><p>Developed by George boole in 19C, “True”: 1, “False”: 0;</p></li><li><p>Operations: And(<strong>\&amp;</strong>) / Or(<strong>|</strong>) / Not(<strong>~</strong>) / Exclusive-or(<strong>Xor, ^</strong>);</p><ul><li>Exercise: Operate on Bit Vectors;</li></ul></li><li><p><strong>Example: Representing &amp; Manipulating Sets</strong></p><ul><li><p>Representation: <strong>Width <code>w</code> bit vector can represent subsets of <code>&#123;0,...,w-1&#125;</code></strong>;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp; &lt;=&gt; Intersection</span><br><span class="line">| &lt;=&gt; Union</span><br><span class="line">^ &lt;=&gt; Symmetric Difference</span><br><span class="line">~ &lt;=&gt; Complement</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Shift Operations</p><ul><li>left shift、right shift；</li><li>logic shift：Fill with “0”；</li><li>arithmetic shift：if (negetive) Fill with “1”，else Fill with “0”；</li><li><strong>Undefined Behavior</strong>: shift amount <strong>&lt; 0</strong> or shift amount <strong>≥ word size</strong>；</li></ul></li></ul><h3 id="1-3-原码-true-form-、反码-1’s-complement-、补码-2’s-complement"><a href="#1-3-原码-true-form-、反码-1’s-complement-、补码-2’s-complement" class="headerlink" title="1.3 原码(true form)、反码(1’s complement)、补码(2’s complement)"></a>1.3 原码(true form)、反码(1’s complement)、补码(2’s complement)</h3><ul><li><p>补码速译：<strong>最高位权重变为负值</strong>；</p></li><li><p>Unsigned range：$0\sim 2^w-1$；</p><p>Two’s complement range：$-2^{w-1}\sim2^{w-1}-1$；</p></li><li><p><strong>模 8 运算：保留补码后三位</strong>；</p></li><li><p>Exercise 1: <strong>Mapping between signed &amp; unsigned</strong></p><p>（将同一个数码看作不同的数，例如 11111111 可以表示 unsigned 的 255，也可以表示 signed -1，这两者相同的数码被称为 “<strong>相同的位模式（bit pattern）</strong>”）</p><blockquote><p>这对计算机很重要，因为它原本不知道是 signed 还是 unsigned；</p></blockquote></li><li><p>Exercise 2: <strong>Casting Surprises</strong>（模糊的常数给定，什么时候类型转换？怎么转换？）</p><ul><li><p>什么时候：C++ 书中说，在赋值、比较时进行<strong>隐式类型转换（implicit casting）</strong>，还可以进行强制类型转换；</p></li><li><p>怎么转换：</p><ol><li><p>占用空间小的类型向大的类型转换：<strong>同时有 unsigned int 和 int，则向 unsigned int 转换</strong>（隐式类型转换）；</p><p>⚠ <strong>隐式类型转换转换唯一需要注意的点：“原来是什么，后来还是什么”。例如，<code>int</code> 向 <code>unsigned long</code>、<code>unsigned</code> 向 <code>long</code>是否会 signed / zero extension，取决于原来的数是否有正负。</strong></p></li><li><p>Bit pattern（位模式）保持不变；</p></li></ol></li><li><p>编程的麻烦：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// situation 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="built_in">func</span>(a[i]);</span><br><span class="line"><span class="comment">// situation 2</span></span><br><span class="line"><span class="comment">// 提示：sizeof 的返回值会被编译器认为是 size_t (unsigned long)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i - <span class="built_in">sizeof</span>(<span class="type">char</span>) &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="built_in">func</span>(a[i]);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Exercise 3: <strong>Sign Extension</strong>（在不改变值的情况下，将 w-bit 数变为 w+k-bit (k∈Z) 数）</p><ul><li><p><strong>Expanding Conclusion: Make k copies of MSB in signed, but fill “0” in unsigned.</strong></p><blockquote><p>想想为什么。</p></blockquote></li><li><p><strong>Truncating Conclusion: mod $2^w$ in unsigned,  很像 mod $2^w$ 但不是 in signed (negative or positive)</strong>;</p></li></ul></li></ul><h3 id="1-4-Operations"><a href="#1-4-Operations" class="headerlink" title="1.4 Operations"></a>1.4 Operations</h3><ul><li><p>Unsigned Addition: $sum=UAdd_w(u,v)=u+v\mod2^w$（为什么成立？<strong>Truncating Conclusion</strong>）；</p><ul><li>一种溢出，这种溢出是模运算可以描述的；</li></ul><blockquote><p>e.g., $(unsigned)13+5=1101_2+0101_2\Rightarrow0010_2$ (<strong>Truncated</strong>)</p></blockquote></li><li><p>Two’s complement Addition: $sum=TAdd_w(u,v)=UAdd_w(u,v)$（<strong>equal in bit pattern</strong>, <strong>Truncating Conclusion</strong>）;</p><ul><li>两种溢出：负溢出（$sum\le-2^{w-1}$ 时）和 正溢出（$sum\ge w^{w-1}$ 时）;</li></ul></li><li><p>Unsigned Multiplication: $multi=UMult_w(u,v)=u\cdot v\mod2^w$（与加法同理）;</p></li><li><p>Signed Multiplication Multiplication: $multi=TMulti_w(u,v)=UMulti_w(u,v)$（与加法同理）;</p></li></ul><blockquote><p>这意味着计算机的乘法、加法可以共用硬件；</p></blockquote><ul><li><p>Shift &amp; Power-of-2 Multiply / Divide: 原因可以看作改变权重；</p><ul><li><p>Unsigned: no problem；</p></li><li><p>Signed: <strong>Use arithmetic shift. Add a bias（偏移量 1）to bit pattern and then right shift</strong></p><blockquote><ol><li><p>为什么用 <strong>算数移位</strong>？因为 <strong>Expanding Conclusion</strong>；至于什么移位，C++ 标准没有明确说，但绝大多数机器都会算术移位；</p></li><li><p>为什么要偏移量？使结果向大数舍入；</p></li></ol></blockquote></li></ul></li><li><p>Negative（取相反数，当然只有 signed 做得到）：<strong>flip all the bits and then add 1</strong>（“~” 取反 + 1）</p></li><li><p>在介绍完移位运算后，回忆 1.3 中的 “编程麻烦”，能不能不用 unsigned，通通用 signed （全用补码表示）不就不会出现这些 casting suprises 了吗？确实，C++ 中尽量别用 unsigned，容易出问题；</p><blockquote><p>Java 就是这么做的。取消了 unsigned 的类型，<strong>并且禁止了某些隐式类型转换</strong>。但因为某些其他的需求，Java 不得不引入算数移位（&gt;&gt;&gt; 和 &lt;&lt;&lt;），就是 C++ 中处理 signed divide 的运算符;</p></blockquote><p><strong>但 unsigned 也有用处</strong>：</p><ul><li>取模运算：利用 unsigned 加法溢出特性；</li><li>使用 bits 来代表集合（1.2）；</li></ul></li></ul><h3 id="1-5-Miscellaneous"><a href="#1-5-Miscellaneous" class="headerlink" title="1.5 Miscellaneous"></a>1.5 Miscellaneous</h3><ul><li><p><strong>2 的幂次数大小估算</strong>：因为 $2^{10}\approx10^3$，这意味着每 3 位十进制数和 10 位二进制数相当，所以 $2^{20}\approx10^6$；</p></li><li><p>segmentation fault 的产生：64-bits pointer 让程序认为真的有 $2^{64}$ bit 的内存空间，但实际上并不是。所以当程序访问到操作系统未给它分配的内存时，会抛出 segmentation fault；</p></li><li><p><strong>字长究竟是多大</strong>：不确定。一般是由一种语言中指针表示的范围、存储器上最大存储块大小决定。例如 64 位机器就是擅长 64-bits 计算、指针大小 64-bits 的机器；<strong>因此一个程序的位数是由硬件和编译器共同决定的</strong>；</p><blockquote><p>所以 64 位机器可以运行 32 位程序（向后兼容）；</p><p>考虑内存对齐，32-bits 下字长相当于 4 bytes，64-bits 下字长相当于 8 bytes；</p></blockquote></li><li><p>Byte Ordering</p><ul><li><p>Big Endian（大端序）：<strong>现在常出现的地方就是 Internet，即当发送 32-bits 数据包时</strong></p><ul><li>Least significant byte has highest address（前面的 bits 排在地址靠前的位置，符合人类习惯）；</li></ul></li><li><p>Little Endian（小端序）：<strong>目前支持主流操作系统的处理器都能用小端序</strong></p><ul><li>Least significant byte has lowest address（前面的 bits 排在地址靠后的位置）</li></ul></li><li><p>Representing of integers</p><ul><li><p>Example of <code>01234567</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address: 0x100 0x101 0x102 0x103</span><br><span class="line">big       :  0123  4567</span><br><span class="line">little :  67    45  2301</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Representing of pointers</p></li><li><p>Representing of strings: Every machine is <strong>the same</strong>; (ended by ‘\\0’);</p></li></ul></li></ul><h3 id="1-6-Puzzles"><a href="#1-6-Puzzles" class="headerlink" title="1.6 Puzzles"></a>1.6 Puzzles</h3><p>Initialization:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">foo</span>();</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">bar</span>();</span><br><span class="line"><span class="type">unsigned</span> ux = x;</span><br><span class="line"><span class="type">unsigned</span> uy = y;</span><br></pre></td></tr></table></figure><ul><li><p>$x\lt0\Rightarrow(x*2\lt0)$ ? </p><blockquote><p>False, $x=TMin$ (negative overflow) ?</p></blockquote></li><li><p>$ux\ge0$ ?</p><blockquote><p>True;</p></blockquote></li><li><p>$x\space\And\space7==7\Rightarrow(x&lt;&lt;30)\lt0$ ?</p><blockquote><p>True, $(x&lt;&lt;30)==-2^{31}+2^{30}\lt0$;</p></blockquote></li><li><p>$ux\gt-1$ ?</p><blockquote><p>Always False, implicit casting：$(unsigned)(-1)=(\sum\limits_{k=0}^{31}2^k)_{10}\Longrightarrow\forall x((unsigned)x\le(unsigned)(-1))$;</p></blockquote></li><li><p>$x\gt y\Rightarrow-x\lt-y$ ?</p><blockquote><p>False, $y==TMin\Rightarrow-y==TMin$.</p><p>So: $\forall x(y==TMin\rightarrow -x\ge-y)$</p></blockquote></li><li><p>$x*x\ge0$ ?</p><blockquote><p>False. Positive overflow.</p></blockquote></li><li><p>$x\gt0\space\And\And\space y\gt0\Rightarrow x+y\gt0$ ?</p><blockquote><p>False. Positive overflow.</p></blockquote></li><li><p>$x\ge0\Rightarrow-x\le0$ ?</p><blockquote><p>True.</p></blockquote></li><li><p>$x\le0\Rightarrow-x\ge0$ ?</p><blockquote><p>False, $x==TMin\Rightarrow-x==TMin$.</p></blockquote></li><li><p>$(x|-x)&gt;&gt;31==-1$ ?</p><blockquote><p>False. $x==0$ ?</p></blockquote></li></ul><h2 id="Chapter-2-Floating-Point"><a href="#Chapter-2-Floating-Point" class="headerlink" title="Chapter 2. Floating Point"></a>Chapter 2. Floating Point</h2><h3 id="2-1-Fractional-Binary-Numbers"><a href="#2-1-Fractional-Binary-Numbers" class="headerlink" title="2.1 Fractional Binary Numbers"></a>2.1 Fractional Binary Numbers</h3><ul><li><p>Limitations: Can only exactly represent numbers of the form $x/2^k$; Other rational number have repeating bit representations.</p></li><li><p>IEEE Floating Point</p><ul><li><p>Numerical form: $(-1)^s\cdot M\cdot2^E$;</p><blockquote><ul><li>Sign bit $s$ determines whether number is positive or negative;</li><li>Significand（尾数，Mantissa） M normally a fractional value in $[1.0,2.0)$;</li><li>Exponent E weights value by power of 2;</li></ul></blockquote></li><li><p>Single precision: 32-bits</p><p>$s$: 1-bit; $exp$: 8-bits; $frac$: 23-bits;（$s$、$exp$、$frac$ 代表对应的数据域而已，下略）</p></li><li><p>Double precision: 64-bits</p><p>$s$: 1-bit; $exp$: 11-bits; $frac$: 52-bits;</p></li><li><p><strong>Normalized values</strong>:</p><ul><li><p>$exp$ 不全为 0，也不全为 1；</p></li><li><p>$exp$ coded as a biased value: $E=Exp-Bias$;</p><p>$Exp$: <strong>unsigned</strong> value of exp field.</p><p>$Bias=2^{k-1}-1$, where <strong>$k$ is number of exponent bits</strong>（当前 $exp$ 字段的 bit 长度，非常巧妙）</p><blockquote><p>为什么这么设定 Bias？</p><p>Single precision’s bias: 127（Exp: 1…254, E: -126…127）</p><p>Double precision’s bias: 1023（Exp: 1…2046, E: -1022…1023）</p></blockquote><p><strong>考虑为什么 $E$ 要这么表达？因为这么做比较起来非常方便</strong>（$Exp$ 0000… 最小，1111…最大）；</p></li><li><p>Significand $M$ coded with implied leading 1: $M = (1.xxxx…x)_2$</p><p>$xxxx…x$: bits of $frac$ field（0000…0最小，此时 M = 1；1111…1最大，此时 $M=2-\varepsilon$）</p><blockquote><p><strong>由于前导 1，normalized value 只能表示绝对值 $[2^{1-Bias},(2-2^{-bitsOfFrac})\cdot2^{Bias})$ 范围的 floating point</strong>；</p></blockquote></li><li><p>理解：像科学计数法，$2^E$ 相当于十进制中的 $10^E$，用于移位，前面的 $M$ 规定具体数值；</p></li></ul></li><li><p><strong>Denormalized values</strong>:</p><ul><li><p>$exp$ 全为 0；</p></li><li><p>$exp$ coded as: $E=1-Bias$;（<strong>可以理解为此时 $exp$ 字段全 0 本身没意义，它们的个数来表示 $Bias$ 进而表示 $E$</strong>）</p></li><li><p>Significand $M$ coded with implied leading 0: $M=(0.xxx…x)_2$;</p><p>$xxx…x$: bits of $frac$ field;</p><blockquote><p>注意，这里会发现可以表示 “+0” 和 “-0”；⚠ 在比较大小和判断的时候要当心！</p><p><strong>denormalized value 只能表示绝对值 $[0,2^{1-Bias})$ 范围的 floating point</strong>；</p></blockquote></li></ul></li><li><p><strong>Special values</strong>:</p><ul><li>$exp$ 全为 1；</li><li>这种编码<strong>只有两种情况</strong>：<ol><li>$frac$ 域全为 0：代表 $\infty$;</li><li>$frac$ 域不全为 0：代表 $NaN$（not a number），例如 $\sqrt{-1}$、$\infty-\infty$、$\infty\times0$ 等；</li></ol></li></ul></li></ul><blockquote><p>这样规定就会发现，浮点数<strong>恰好可以溢出到 $\pm\infty$</strong>，而且错误数恰为 $NaN$；</p><p>Visualization： <img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/float_visualization.png"></p><p>想要理解上面规定的原因还可以用少量的数位来模拟，<strong>你会发现之前的设定非常巧妙</strong>：</p><p>（这里以 $s$: 1-bit，$exp$: 4-bits，$frac$: 3-bits 为例）</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/float_range.png" height="350"></p></blockquote></li><li><p>Special Properties of IEEE Encoding</p><ul><li>FP（Floating Point）zero same as Integer zero（<strong>All bits = 0</strong>）；</li><li>Can <strong>almost（except NaN）</strong> use <strong>unsigned integer comparison</strong>；<ul><li>Must first compare sign bits；</li><li>Must consider <strong>-0 = +0</strong>；</li><li>What should comparison with NaN yield？</li><li><strong>Otherwise OK ($+\infty$ 和 $-\infty$ 都能与数比较)</strong>；</li></ul></li></ul></li><li><p>Exercise: <strong>write float pointing in bit-level representation</strong>;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> F = <span class="number">15213.0</span>;</span><br></pre></td></tr></table></figure><ul><li>$15213_{10}=11101101101101_2=1.1101101101101_2\times2^{13}$</li><li>$M=1.1101101101101_2$, $frac=11011011011010000000000_2$</li><li>$E=13$, $Bias=127$, $Exp=E+Bias=140_{10}=10001100_2$;</li><li>$Normalized\space value=01000110011011011011010000000000$</li></ul></li></ul><h3 id="2-2-The-Operations-for-Floating-Point"><a href="#2-2-The-Operations-for-Floating-Point" class="headerlink" title="2.2 The Operations for Floating Point"></a>2.2 The Operations for Floating Point</h3><ul><li><p>Basic idea</p><ol><li>First compute exact result;</li><li>Make it fit into desired precision<ul><li>possibly overflow if exponent too large;</li><li>possibly <strong>round</strong> to fit into $frac$;</li></ul></li></ol></li><li><p>Rounding for base 10 numbers</p><ul><li><p>Towards zero（向 0 舍入）；</p></li><li><p>Round down（向下舍入）；</p></li><li><p>Round up（向上舍入）；</p></li><li><p>Nearest Even（default）</p><blockquote><p>即 <strong>四舍六入五成双</strong>，见概率统计；</p><p>超过一半都是 “六” 的情况，少于一半都是 “四” 的情况，正好一半看最后保留位的奇偶；</p></blockquote></li></ul></li><li><p>Rounding Binary number: Nearest Even 与 普通十进制数思路相同；</p><blockquote><p>举例：Round to nearest 1/4（2 bits right of binary point）：</p><p>$10.00011_2\Rightarrow 10.00_2$，$10.00110_2\Rightarrow10.01_2$，</p><p>$10.11100_2\Rightarrow11.00_2$，$10.10100_2\Rightarrow10.10_2$；</p></blockquote></li><li><p>FP Multiplication: $multi=(-1)^s\cdot M\cdot2^E=(-1)^{s_1}\cdot M_1\cdot 2^{E_1}\cdot(-1)^{s_2}\cdot M_2\cdot2^{E_2}$</p><ul><li>Sign $s=s_1\space^\wedge\space s_2$;</li><li>Significand $M=M_1\times M_2$;</li><li>Exponent $E=E_1+E_2$;</li><li><strong>Fixing</strong><ol><li>If $M\ge2$，shift $M$ right, increment $E$; (<strong>That’s why  $M\lt 2$</strong>) </li><li>If $E$ out of range ($Exp$ out of range), overflow;</li><li>Round $M$ to fit $frac$ precision;</li></ol></li></ul></li><li><p>FP Addition: $sum=(-1)^s\cdot M\cdot2^E=(-1)^{s_1}\cdot M_1\cdot2^{E_1}+(-1)^{s_2}\cdot M_2\cdot2^{E_2}$. (assume $E_1\gt E_2$)</p><ul><li>Sign $s$, Significand $M$: <strong>Result of signed align &amp; add</strong>;</li><li>Exponent $E$: <strong>the same as $E_1$, which means $E_2$ will be ignored if $E_1\gt\gt E_2$</strong>;</li><li><strong>Fixing</strong><ol><li>If $M\ge2$, shift $M$ right, increment $E$;</li><li>If $M\lt1$, shift $M$ left $k$ positions, decrement $E$ by $k$; (<strong>The difference between multiplication</strong>)</li><li>If $E$ out of range, overflow;</li><li>Round $M$ to fit $frac$ precision;</li></ol></li></ul></li><li><p><strong>Mathematical Properties of FP addition / multiplication</strong>:</p><ul><li>具备交换律 (commutative)，不具备结合性 (associative)：舍入的不准确性和溢出、大数和小数之和会丢失小数、大数和大数乘积会变为 $\infty$；</li><li>Every element has additive inverse (相反数) <strong>except for infinites \&amp; NaNs</strong>；</li><li>几乎具备单调性 (Monotonicity): $a\ge b\Rightarrow a+x\ge b+c$ <strong>except for infinites \&amp; NaNs</strong>;</li></ul><blockquote><p><strong>总而言之，在考试时，忘记这些问题不大，想要快速判断是否满足某个定律，只需找特殊：$\infty$、$NaN$、overflow、0，这四者是大多数特例的来源</strong>；</p></blockquote></li></ul><h3 id="2-3-Floating-Point-in-C"><a href="#2-3-Floating-Point-in-C" class="headerlink" title="2.3 Floating Point in C"></a>2.3 Floating Point in C</h3><ul><li><p><code>float</code>（single precision），<code>double</code>（double precision）；</p></li><li><p>Conversions / Casting:</p><ul><li><p><strong><code>int</code>、<code>double</code>、<code>float</code> 间的转换会改变 bit representation</strong>；</p><blockquote><p>回忆 signed 和 unsigned 间的转换，不改变 bit pattern，只是改变某些位置的解释方式；</p></blockquote></li><li><p>implicit casting 发生在占用小空间的类型（int）向占用大空间类型（double）转换，也可显式声明；</p><ul><li><code>int -&gt; double</code>: <strong>准确转换。因为 <code>int</code> 大小小于 53-bits</strong>；</li><li><code>int -&gt; float</code>: <strong>Will rounding according to rounding mode</strong>；</li></ul></li><li><p>显式类型转换 <code>double/float -&gt; int</code></p><ul><li>Truncates (截断) fractional part;</li><li>Like rounding toward 0 (<strong>可以看作向 0 舍入</strong>);</li><li>Not defined when out of range / NaN: <strong>Generally sets to <code>TMin</code></strong>;</li></ul></li></ul></li></ul><h3 id="2-4-Puzzles"><a href="#2-4-Puzzles" class="headerlink" title="2.4 Puzzles"></a>2.4 Puzzles</h3><p>initialization:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = ...;</span><br><span class="line"><span class="type">float</span> f = ...;</span><br><span class="line"><span class="type">double</span> d = ...;</span><br><span class="line"><span class="comment">// Assume neither d nor f is NaN;</span></span><br></pre></td></tr></table></figure><ul><li><p>$x==(int)(float)x$ ?</p><blockquote><p>False; (int)x -&gt; (float)x (rounded)</p></blockquote></li><li><p>$x==(int)(double)x$ ?</p><blockquote><p>True;</p></blockquote></li><li><p>$f==(float)(double)f$ ?</p><blockquote><p>True;</p></blockquote></li><li><p>$d==(double)(float)d$ ?</p><blockquote><p>False; (double)d -&gt; (float)d (rounded)</p></blockquote></li><li><p>$f==-(-f)$ ?</p><blockquote><p><strong>True. Even $f==\pm\infty$ is true.</strong></p></blockquote></li><li><p>$2/3==2/3.0$ ?</p><blockquote><p>False; $(int)2/3=0$, $(double)2/3.0=0.666…67$;</p></blockquote></li><li><p>$d\lt0.0\Rightarrow(d*2\lt0.0)$ ?</p><blockquote><p><strong>True; Even $d*2==-\infty$ is true.</strong></p></blockquote></li><li><p>$d\gt f\Rightarrow-f\gt-d$ ?</p><blockquote><p><del>False;</del></p><p><strong>True.</strong></p></blockquote></li><li><p>$d*d\ge0.0$ ?</p><blockquote><p><strong>True. Even $d==\pm\infty\Rightarrow d*d==+\infty$ is true.</strong></p></blockquote></li><li><p>$(d+f)-d==f$ ?</p><blockquote><p>False; $d&gt;&gt;f\Rightarrow(d+f)\approx d$;</p></blockquote></li></ul><blockquote><p>C1 &amp; C2 结束，请完成 Data Lab！</p></blockquote><h2 id="Chapter-3-Machine-Level-Programming-Ⅰ-Basics"><a href="#Chapter-3-Machine-Level-Programming-Ⅰ-Basics" class="headerlink" title="Chapter 3. Machine-Level Programming Ⅰ- Basics"></a>Chapter 3. Machine-Level Programming Ⅰ- Basics</h2><blockquote><p>和前面说的一样，本章不会教学一段段写汇编，只要求看懂 GCC 输出的汇编代码即完成任务；</p><p><strong>本章涉及的机器语言运行在 Intel x86-64 机器上</strong>；</p></blockquote><ul><li><p>两种机器代码</p><ul><li>计算机实际运行的目标代码（一串字节编码处理器执行的指令，难以阅读）；</li><li>汇编代码：过去用于直接对机器进行编程，现在是编译器输出的目标。</li></ul><blockquote><p>以后说 “机器代码”，有时指第一种（目标代码），有时指第二种（文本格式的汇编代码），它们两者概念几乎相同，可替换。不过为了防止混淆以后对第二种会说 “汇编代码”。</p></blockquote></li></ul><h3 id="3-1-History-of-Intel-processors-and-architectures"><a href="#3-1-History-of-Intel-processors-and-architectures" class="headerlink" title="3.1 History of Intel processors and architectures"></a>3.1 History of Intel processors and architectures</h3><ul><li><p>什么是 Intel 的 x86-64？</p><blockquote><p>x86 是指 Intel 自己的 x86 processors，因为 Intel 这个系列的第一张处理器芯片的代号是 8086（产于 1978）。</p><p>随着时间推移，这个系列的芯片不断添加特性、升级演进；Intel 自己跳过了 81 系列，推出过 8286、8386系列等，都是以 86 结尾，所以被称为 x86。</p><p>后面的 64 表示这是 64-bits 的机器；</p></blockquote></li><li><p>什么是 <code>CISC</code> 和 <code>RISC</code>？</p><ul><li>Reduced Instruction Set Computer（<code>RISC</code>，精简指令集计算机）：一类装备改良的机器指令集的计算机，思想较新；</li><li>Complex Instruction Set Computer（<code>CISC</code>，复杂指令集计算机）：在 <code>RISC</code> 出现后，<code>RISC</code> 开发者把之前的使用旧指令集的计算机统称为 <code>CISC</code>，所以这个概念出现在本体之后，带有贬义；</li></ul><blockquote><p>Intel 采用的是 <code>CISC</code>，CSAPP 中介绍的这方面的知识还是不全面，想要进一步了解 <code>CISC</code> 需要自己阅读 <code>CISC</code> 手册；</p></blockquote></li><li><p>Intel 芯片的进化</p><ul><li><p>8086: 1978, 5-10 MHz;</p><blockquote><p>First 16-bit Intel processor.</p><p>1 MB Address space.</p></blockquote></li><li><p>386: 1985, 16-33 MHz</p><blockquote><p>First 32-bit Intel processor, referred to as IA32（Intel Architecture 32），占据了极大市场份额；<strong>现在不教它了，因为有更新的 x86-64</strong>;</p><p>Added “flat addressing”，capable of running <strong>UNIX</strong>；</p></blockquote></li><li><p>Pentium 4E（奔腾 4E）: 2004, 2800-3800 MHz</p><blockquote><p>First 64-bit Intel x86 processor, referred to as x86-64;</p><p><strong>收到了产品反馈：性能功耗问题，发热严重，不能无限制增加处理器时钟频率</strong>，开始着手多核处理器（一个芯片上放多个独立处理器）；</p></blockquote></li><li><p>Core 2: 2006, 1060-3500 MHz</p><blockquote><p>First multi-core Intel processor;</p></blockquote></li><li><p>Core i7: 2008, 1700-3900 MHz</p><blockquote><p>Four cores processor;（至今性能也不错）</p></blockquote></li></ul></li><li><p>什么是缓存？<strong>大致定义是 a temporary memory used to hold the most recently accessed data</strong>;</p></li><li><p>2015 年的 Intel 芯片架构</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/chip_in_2015.png" height="400"></p><ul><li><code>DDR</code> 接口是连接到主存储器（DRAM，Dynamic Random Access Memory）的通道；</li><li><code>PCI</code> 接口是与外围设备（peripheral devices）的连接通道；</li><li><code>SATA</code> 接口是与不同类型硬盘的连接通道；</li><li><code>Ethernet</code> 接口是网络接口；</li></ul><blockquote><p>结论：集成到单个芯片上的不仅仅是处理器本身，还有很多逻辑单元所组合起的有机整体；</p></blockquote></li><li><p>Intel 的竞争对手：AMD（Advanced Micro Devices）</p><ul><li>总是跟在 Intel 后面发展，同级别的芯片稍微有点慢，但便宜的多；</li></ul></li><li>什么是 ARM？<ul><li>除了 Intel 公司的 x86 类型的处理器，当前常用的、比较主流的另一类处理器是 ARM（Acron RISC Machine），CSAPP 不会深入涉及；</li><li>创造这种处理器及其对应指令集（RISC）的原公司已经破产，但指令集写的很棒，能自定义，功耗比同水准的 x86 处理器更低。</li><li>所以后继者建立了一个公司，但这个公司不销售处理器，只向众多公司销售 ARM 的设计许可权。因此，ARM 处理器是很多芯片厂商（尤其 Intel）生产的芯片的<strong>一部分</strong>，因为 ARM 的优势而被用在方方面面；</li></ul></li></ul><h3 id="3-2-C-Assembly-Machine-code"><a href="#3-2-C-Assembly-Machine-code" class="headerlink" title="3.2 C, Assembly, Machine code"></a>3.2 C, Assembly, Machine code</h3><blockquote><p>本节只是概述一下整个 C、汇编语言、机器语言的<strong>产生过程</strong> 和 <strong>宏观样貌</strong>。</p><p>具体对汇编代码的学习内容在下一节。</p></blockquote><h4 id="3-2-1-Definitions"><a href="#3-2-1-Definitions" class="headerlink" title="3.2.1 Definitions"></a>3.2.1 Definitions</h4><ul><li><strong>Architecture (also ISA: Instruction Set Architecture)</strong>: The <strong>parts</strong> of a processor design that  one needs to understand or write assembly/machine code.<ul><li>架构是处理器设计的一部分。开发硬件的人员在考虑设计机器和对应机器语言的时候，想到了将 “指令集架构” 这层抽象出来。<strong>例如针对某个寄存器，特定的指令集等</strong>，相当于驱动硬件的接口，将<strong>微架构</strong>和机器码隔离开。这样，硬件设计者只需要关心微架构，上层的设计者需要关注机器语言以及更抽象的语言就行。</li><li>开发人员需要了解，以此来编写对应的汇编码、机器语言，以至对应平台的编译器；</li><li>examples:<ul><li>Intel: x86, IA32, Itanium, x86-64;</li><li>ARM: (Name is itself) Used in almost all mobile phones.</li></ul></li></ul></li><li><strong>Microarchitecture: Implementation of the architecture.</strong><ul><li>例如：缓存大小设计、内核频率设计。CSAPP 中也涉及的很少；</li></ul></li><li>Code Form<ul><li>Machine Code: The byte-level programs that a processor executes;</li><li>Assembly Code: A text representation of machine code.</li></ul></li></ul><h4 id="3-2-2-Assembly-Machine-Code-View"><a href="#3-2-2-Assembly-Machine-Code-View" class="headerlink" title="3.2.2 Assembly/Machine Code View"></a>3.2.2 Assembly/Machine Code View</h4><ul><li><p>Programmer-Visible State（在机器语言中需要开发者了解、操作的一些量，含有与真实硬件相关的细节）：</p><ul><li><p>PC (Program Counter, 程序计数器)</p><ol><li>Get the address of next instruction;</li><li>Called “RIP” (in x86-64);</li></ol></li><li><p>Register file: <strong>Heavily used program data</strong>（汇编程序中绝大多数数据存放的位置）;</p></li><li><p>Condition Codes（状态代码，存放于<strong>状态寄存器</strong>）</p><ol><li>存储绝大多数当前最近的算数/逻辑运算的状态信息；</li><li>数据用来判断状态分支；</li></ol></li><li><p>Memory</p><ol><li>由地址组织的 byte 数组，<strong>实际上是用一种不同方式（这个实现的方式以后的章节会详细介绍）实现的虚构对象，完成操作系统和硬件间的协作，因此称为虚拟内存（Virtual Memory）</strong>，所以这使得虽然内存（硬件上实际的内存又称为<strong>物理内存，Physical Memory</strong>）在硬件上可能是零碎的，但汇编开发者看起来的却是一大块可以按地址成块使用的。每个程序都有自己独立的字节数组来访问数据。</li><li>存放代码、用户信息；</li><li>使用堆栈数据结构来支持步骤；</li></ol><blockquote><p>这里解释一下经常提到的<strong>缓存（Cache）</strong>，缓存是指一个动作，就是将最近访问的数据存储到<strong>高速缓存器</strong>（I/O 远快于普通寄存器和外存储器，但造价高，所以容量小）中。下一次访问<strong>相同</strong>数据时，会直接进入高速缓存器中，速度会更快。</p><p>但是<strong>“缓存”</strong>这个动作对汇编开发者而言<strong>也是不可见（invisible）的</strong>，这是写在硬件中的动作（前面说的 microarchitecture），即使在汇编层面也没有专门的指令，无法操作。</p></blockquote></li></ul></li><li><p>C 代码如何转变为 <code>Object Code</code></p><ul><li>在 GNU Tutor 中曾经介绍过从源文件到目标文件的过程；</li><li><strong>C 源文件（*.c, text）</strong> <u>编译器（compiler, C 一般用 gcc）</u>编译为 <strong>ASM 源文件（*.s, text）</strong>，再交给<u>汇编器（assembler，一般用 gcc/as）</u> 汇编为 <strong>目标文件（*.o, binary）</strong>，最后交给<u>链接器（linker，一般用 gcc/ld）</u> 链接用到的第三方静态库，最终变为可执行文件；</li><li>剩余还有一部分是动态链接库，要么自己写并且编译，放置在指定位置，要么用的是系统环境中的库，在程序运行时动态加载。</li></ul></li><li><p>举例说明：下面以一个简单的 C 程序为例，演示其汇编代码及含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: sum.c</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">plus</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sumstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = plus(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">long</span> y = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">long</span> z;</span><br><span class="line">    sumstore(x, y, &amp;z);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld + %ld --&gt; %ld\n&quot;</span>, x, y, z);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在运行 <code>gcc -Og -S sum.c</code>。</p><ul><li><code>-Og</code> 参数是较新的参数，与 <code>-On</code>（n=0，1，2，3） 优化不一样，为开发人员提供了易读的中间汇编码；另外，如果不加 <code>-O</code> 参数，就什么都不优化，那么代码同样难以阅读；</li><li><code>-S</code> 参数意味着 <code>gcc</code> 套件将仅运行到产生汇编代码（<code>*.s</code>）就停止；</li></ul><p>找到代表 <code>sumstore</code> 函数的 asm 代码，以函数名 + 冒号开头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sumstore:</span><br><span class="line">    pushq%rbx</span><br><span class="line">    .seh_pushreg%rbx</span><br><span class="line">    subq$32, %rsp</span><br><span class="line">    .seh_stackalloc32</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    movq%r8, %rbx</span><br><span class="line">    callplus</span><br><span class="line">    movl%eax, (%rbx)</span><br><span class="line">    addq$32, %rsp</span><br><span class="line">    popq%rbx</span><br><span class="line">    ret</span><br><span class="line">    .seh_endproc</span><br><span class="line">    .def__main;.scl2;.type32;.endef</span><br><span class="line">    .section .rdata,&quot;dr&quot;</span><br></pre></td></tr></table></figure><p>这里注意开头含有 <code>.</code> 的操作<strong>实际不是原先代码的部分，它们与一些其他信息有关</strong>。例如为调试器提供行号的、为链接器提供信息表示全局函数的等等。一开始可以不用太过于在意这些，为了演示方便，这里直接删掉说明，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sumstore:</span><br><span class="line">    pushq%rbx; %rbx 表示访问名为 rbx 的寄存器，pushd 表示数据压入memory栈</span><br><span class="line">    subq$32, %rsp</span><br><span class="line">    movq%r8, %rbx</span><br><span class="line">    callplus; 调用函数名为 plus 的函数</span><br><span class="line">    movl%eax, (%rbx); 移动值</span><br><span class="line">    addq$32, %rsp</span><br><span class="line">    popq%rbx; 将栈中值弹出到 名为 rbx 的寄存器中</span><br><span class="line">    ret; 当前函数结束，返回</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-3-Assembly-Characteristics-Data-Types"><a href="#3-2-3-Assembly-Characteristics-Data-Types" class="headerlink" title="3.2.3 Assembly Characteristics: Data Types"></a>3.2.3 Assembly Characteristics: Data Types</h4><ul><li>“Integer” data of 1,2,4, or 8 bytes（不同的整型数据类型，不区分符号）<ul><li>Data types / Address（untyped pointers）</li></ul></li><li>Floating point data of 4,8, or 10 bytes（浮点数处理方式不同，使用不同的寄存器组，之后详细提）</li><li><strong>在汇编层面不存在聚合结构（aggregate types）</strong>，例如数组、结构体，因为它们是在编译器层面人工设计的，本质上就是连续的一段内存，以后也会实现；</li></ul><h4 id="3-2-4-Assembly-Characteristics-Operations"><a href="#3-2-4-Assembly-Characteristics-Operations" class="headerlink" title="3.2.4 Assembly Characteristics: Operations"></a>3.2.4 Assembly Characteristics: Operations</h4><ul><li>Perform arithmetic function on register or memory data（<strong>算术运算</strong>在存储器上的数据）</li><li>Transfer data between memory and register（在内存和寄存器间<strong>转移数据</strong>）<ul><li>load data from memory to register</li><li>store register data into memory</li></ul></li><li>Transfer control（汇编代码<strong>流程控制</strong>）<ul><li>Unconditional jumps to/from procedures</li><li>Conditional branches</li></ul></li></ul><h4 id="3-2-5-Assembling-amp-Disassembling-Object-Code-At-first-glance"><a href="#3-2-5-Assembling-amp-Disassembling-Object-Code-At-first-glance" class="headerlink" title="3.2.5 Assembling &amp; Disassembling Object Code: At first glance"></a>3.2.5 Assembling &amp; Disassembling Object Code: At first glance</h4><p><strong>先来看 C code 到 汇编语言/机器语言的过程</strong>。</p><p>当汇编代码被 assembler（汇编器）汇编为目标代码时，这时所能看到的就只有二进制序列了。接下来还以之前的 <code>sum.c</code> 中的 <code>sumstore</code> 函数为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x0400595:    # 表示本函数段从 0x0400595 处开始</span><br><span class="line">    0x53# 每一条指令长为 1/3/5 bytes，整段函数的长度为 14 bytes</span><br><span class="line">    0x48</span><br><span class="line">    0x89</span><br><span class="line">    0xd3</span><br><span class="line">    0xe8</span><br><span class="line">    0xf2</span><br><span class="line">    0xff</span><br><span class="line">    0xff</span><br><span class="line">    0xff</span><br><span class="line">    0x48</span><br><span class="line">    0x89</span><br><span class="line">    0x03</span><br><span class="line">    0x5b</span><br><span class="line">    0xc3</span><br></pre></td></tr></table></figure><p>这里每条指令只做一件事。以 <code>sumstore</code> 函数中的一个语句为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*dest = t;    <span class="comment">/* Store value t where designated by dest. */</span></span><br><span class="line">            <span class="comment">/* 这里加信号的含义是取 dest 所指向的地址 */</span></span><br></pre></td></tr></table></figure><p>对应这条汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq %rax, (%rbx)</span><br></pre></td></tr></table></figure><p>对应这条目标代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x40059e:    48 89 03</span><br></pre></td></tr></table></figure><p>这里 <code>t</code> 或某些 local variables 会存储于寄存器中（例如上面表示它在寄存器 <code>%rax</code> 中），而 <code>dest</code> 指针值自己也被存储于寄存器中（上面表示 <code>dest</code> 自身的值存于 <code>%rbx</code> 中）；</p><p>这里的 <code>(%rbx)</code> 表示 <code>Memory[%rbx]</code>，即 <code>%rbx</code> 值所代表的地址在 <code>Memory</code> 中的位置；</p><p><code>mov A, B</code> 指令就是将值从 A 处移动到 B 处。上面的汇编语句连起来就是：<strong>将存放于 <code>%rax</code> 中的值移动到 <code>%rbx</code> 所代表 Memory 地址的位置上</strong>；</p><p>根据汇编器翻译，这条指令只用了 3 bytes 来编码：<code>48 89 03</code>；</p><hr><p><strong>再来看机器语言到汇编语言的反汇编过程（disassembling）</strong>。</p><p>反汇编的实现和汇编一样，后者是将文本版本（汇编代码）转换为字节码（机器代码）的形式表示，前者将字节码对应解释成易读的文本即可。</p><p>如果当前没有源文件，甚至没有汇编代码，那么可以由<strong>反汇编器（disassembler）</strong>来将目标代码（*.o）<strong>或者</strong>可执行程序（已链接库的目标代码）转换成汇编代码（*.s）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d <span class="built_in">sum</span> &gt; sum.d <span class="comment"># 反编译之前的 sum 程序，-d 将可执行部分反汇编显示到 stdout</span></span><br></pre></td></tr></table></figure><p>值得注意的是，在汇编代码的层次下，<strong>无法</strong>再向上还原到源文件（*.c），因为其中的函数/变量名、都在汇编过程丢失了，只剩下一些寄存器的名称和 Memory 地址。</p><p>上面使用 <code>objdump</code> 可以得到真正意义上的汇编代码（从机器代码转换而来），此外还有一种方法：使用 <code>gdb</code>。</p><p>如果使用 <code>gdb</code> 打开目标可执行文件，运行 <code>disassemble &lt;funcName&gt;</code> 就可以对可执行文件中对应的函数区域进行反汇编。但只显示这些指令的地址 + 翻译指令，不显示字节级的编码。</p><h3 id="3-3-Assembly-Basics"><a href="#3-3-Assembly-Basics" class="headerlink" title="3.3 Assembly Basics"></a>3.3 Assembly Basics</h3><h4 id="3-3-1-The-names-for-integer-registers"><a href="#3-3-1-The-names-for-integer-registers" class="headerlink" title="3.3.1 The names for integer registers"></a>3.3.1 The names for integer registers</h4><p>下面列举 x86-64 architecture 的 <strong>整数型寄存器（Integer Register）</strong>。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/registers_in_x86_64.png" height="400px"></p><p>如图，这些寄存器共有 16 个，名字大致分为 2 类，一类是字母表示的（ax/bx/…），另一类是数字表示的（8/9/…）。</p><p>目前一个 x86-64 架构的 integer register 总大小有 64-bit。鉴于对以前 32-bit 机器和程序的向前兼容（backwards compatibility），汇编语言允许使用一个寄存器的<strong>不同部分</strong>，怎么用取决于指令。</p><p>对于字母类名称的寄存器（如上图左），如果使用<strong>前缀 <code>%r</code></strong>（例如 <code>%rax</code>），那么这个整型寄存器将保存 <strong>64-bit</strong> 大小的整型数据（即使用全部空间）；如果使用<strong>前缀 <code>%e</code></strong>（例如 <code>%eax</code>），那么这个整型寄存器将保存 <strong>32-bit</strong> 大小的整型数据（即从低位开始使用 32 bits，又称为 <strong>low-order 32-bit</strong>）。</p><p>对于数字类名称的寄存器（如上图右），前缀必须是 <code>%r</code>。如果不加后缀，表示保存 <strong>64-bit</strong> 大小的整型；如果使用<strong>后缀 <code>d</code></strong>，那么将保存 <strong>32-bit</strong> 大小的整型。</p><p>在这些寄存器中，可以使用指令存取数据，<strong>而且这些是机器级编程，和具体机器的型号密切相关，每步即必须清楚指出从哪个寄存器到哪个寄存器</strong>。</p><p>在 x86-64 架构下，最常见的是 64-bit register 的使用，其次是 low-order 8-bit 的使用（用在条件控制中，这个会在下一章介绍）。因此，除非提及，下面默认的 register 全部是以 <code>%r</code> 为前缀的 16 个寄存器。</p><hr><p>下面补充一些历史信息，帮助理解这些寄存器奇怪的（quirky）名字：</p><p>在早期 IA32 架构下 32-bit 处理器只用到了 8 个寄存器，它们的名字分别是：</p><p><code>%eax</code>、<code>%ecx</code>、<code>%edx</code>、<code>%ebx</code>、<code>%esi</code>、<code>%edi</code>、<code>%esp</code>、<code>%ebp</code>（都是 <code>%e</code> 前缀,意味着存 32-bit 整型）</p><p>此位，这些寄存器还能引用 <strong>low-order 16-bits</strong>（它们是最开始出现的 16-bit 寄存器，没有 <code>e/r</code> 前缀，引用的名称为 <code>%ax</code>、<code>%cx</code>、<code>%bx</code>……），甚至是 <strong>low-order 8-bits 和 high-order 8-bits</strong>（分别是 <code>%al</code> 和 <code>%ah</code> 等，如下图）。这里不讲述这些旧版本机器的低位寄存器位置的操作指令，不过在下一章会提到操作 <strong>low-order 8-bits</strong> 的操作指令，因为会涉及汇编条件控制。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/IA32_registers.png" height="350px"></p><p>很早以前，各个寄存器的名字有特定含义，代表它们的目的。例如 <code>a</code> 代表 accumulate，<code>c</code> 代表 counter，<code>d</code> 代表 data，<code>b</code> 代表 base，<code>si</code> 代表 source index，<code>di</code> 代表 destination index，<code>sp</code> 代表 stack pointer，<code>bp</code> 代表 base pointer。</p><p>现在这些寄存器就是普通的存取数据的结构，名字也就没有特定的含义了——<strong>除了名字是 <code>sp</code> 的寄存器</strong>。它在目前的 x86-64 架构中也有一个非常具体的目的，就是上面说的，stack pointer，<strong>栈指针</strong>。</p><p>至于后面数字表示的寄存器，<strong>是后来从 IA32 架构升级到 64 位（x86-64）时，芯片可以在一个时钟周期处理 64-bit 的数据了，旧的寄存器设计不够用了，所以新添加上去的，因为没有特定用途，就以数字进行命名</strong>。</p><p>⚠ 说是没什么“特殊用途”，但还是有约定俗成的使用方法的！</p><p>例如，这些寄存器分为 “<strong>Callee-Saved Register</strong>” 和 “<strong>Caller-Saved Register</strong>”。</p><p>其中，Callee-Saved Register 是由<strong>被调用方保管使用的</strong>寄存器，数据内容只会在被调方的函数内有效、有意义。属于这类的寄存器有：<code>%rbx</code>、<code>%r12-14</code>、<code>%rbp</code> 和 <code>%rsp</code>，后两者是有特殊含义的，前面的寄存器是供被调方存储临时数据（Temporaries）；</p><p>Caller-Saved Register 是<strong>调用方保管使用的</strong>寄存器，它的作用大多数是沟通调用方和被调方的数据信息。例如 <code>%rax</code> 一般存放返回值，<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rcx</code>、<code>%r8</code>、<code>%r9</code> 依此存放调用函数的第 1 ~ 第 6 参数；<code>%r10</code>、<code>%r11</code> 供存储调用方临时数据。</p><p>在下面的部分中，你会一遍遍加深对这个说法的印象的。上面的内容在第五章会进一步提及。</p><p>至于为什么要有 Callee-Saved 和 Caller-Saved Register，这也会在 5.4 中详细说明。</p><hr><h4 id="3-3-2-Move-Operands-and-usage"><a href="#3-3-2-Move-Operands-and-usage" class="headerlink" title="3.3.2 Move, Operands, and usage"></a>3.3.2 Move, Operands, and usage</h4><p>接下来介绍整型寄存器在汇编代码中的使用。</p><h5 id="Moving-Data-Command-movq-lt-SrcR-gt-lt-DstR-gt"><a href="#Moving-Data-Command-movq-lt-SrcR-gt-lt-DstR-gt" class="headerlink" title="Moving Data Command: movq &lt;SrcR&gt;, &lt;DstR&gt;"></a>Moving Data Command: <code>movq &lt;SrcR&gt;, &lt;DstR&gt;</code></h5><blockquote><p>为什么命令名中有 “q” ？因为在 Intel 公司设定中，q 代表 quad，是 4 个字，而在 8086 系列中，1 个字被约定为 16 bits（2 bytes），所以 <strong><code>movq</code> 指令操作的必须是 64 bits 的寄存器</strong>；</p><p>⚠ <strong>另外请格外注意，Intel 和 Microsoft 使用的 x86-64 架构的汇编语言的这些参数和 Linux 使用的 x86-64 架构的参数顺序不一样！CSAPP 教授的指令语法按照 Linux 来，请不要弄错！不要在 Windows 环境下尝试这些指令！</strong></p></blockquote><h5 id="Operands"><a href="#Operands" class="headerlink" title="Operands"></a>Operands</h5><ul><li><p>Immediate（数据直接量，例如常量整型）: <strong>定义和 C 语言一样，但是需要加上前缀 <code>$</code></strong>;</p><blockquote><p>例如：<code>$0x400</code>、<code>$-523</code> 等等；</p></blockquote></li><li><p>Register Name: 16 个中任意一个整型寄存器的名称。</p><blockquote><p><strong>注意：保留作其他用途的寄存器也不应该被手动使用。前面说了，例如在 x86-64 架构中，<code>%rsp</code> 保留做特殊用途</strong>，因为栈中保存其他重要的状态信息，只能由机器内部进行修改。</p></blockquote></li><li><p>Memory: <strong>8 consecutive bytes</strong> of memory <strong>at address</strong> given by registers.</p></li><li><p><strong>汇编代码简单访问 Memory 的方法</strong>：</p><ul><li><p>法 1: Normal <code>(%&lt;registerName&gt;)</code></p><p>即保存在寄存器中的、8 bytes 连续的地址数据对应的 memory 位置。</p><p><strong>也就是说，当把寄存器名称放在括号里时，就是表示把寄存器中数据看作 memory 地址（无论是什么），并用这个地址来引用对应的内存位置</strong>。</p><p>例如：<code>(%rax)</code> 就是代表取存放在 <code>%rax</code> 寄存器中的数据对应 memory 位置的引用；</p><p><u>请牢牢记住</u>，这种在括号内找地址的形式被称为 <strong>Simple Memory Addressing Modes</strong>（简单内存寻址模式），表示这个模式下，寄存器被看作指针，括号相当于取地址并找到 memory 对应的引用。</p></li></ul></li></ul><ul><li><p>法 2: Displacement <code>&lt;D&gt;(%&lt;registerName&gt;)</code></p><p>即保存在寄存器中的、8 bytes 连续的地址对应 memory 的某个位置，以这个位置为基准，向后偏移 <code>D</code> 个 bytes 所对应的内存位置的引用。</p><p>例如：<code>8(%rbp)</code> 就是代表取存放在 <code>%rbp</code> 寄存器中的数据向后偏移 <code>D</code> 个 bytes 的位置对应 memory 的引用；</p></li></ul><ul><li><p><strong>法 3: Most General Form <code>D(&lt;Rbase&gt;, &lt;Rindex&gt;, &lt;Scale&gt;)</code></strong></p><p>等价于 <code>Memory[Reg[Rb] + S * Reg[Ri] + D]</code>，指使用寄存器 <code>Rb</code> 中的数据为基，加上 <code>S</code> 倍率的寄存器 <code>Ri</code> 中的数据（<strong>因此 <code>S</code> 只取 1，2，4，8 这几个之一</strong>），最后总体偏移 <code>D</code> bytes；</p><p><strong>注意，<code>Ri</code> 不建议为寄存器 <code>%rsp</code></strong>;</p><p><strong>法 3 就是原始意义上的数组自然引用的方式</strong>；</p><p>可以思考为什么 <code>S</code> 只取 1、2、4、8 中的一个。原因很简单，这和它存在的意义有关。我们想在引用数组时，<strong>一定希望根据数据类型来缩放索引值</strong>，例如 <code>int</code> 需要缩放 4 倍（4 bytes），<code>long</code> 需要缩放 8 倍；小于这些数，则会导致数据错误，大于这些数据会导致空间浪费。</p></li></ul><ul><li><p>Rules：以上有些 operand 的组合是不允许的。例如：</p><ul><li>直接量作为 destination，没有意义；</li><li>为了方便硬件设计，不允许直接从一个内存位置复制到另一个内存位置，必须 2 步：从内存存入指定寄存器，再由指定寄存器存入另一块内存（<strong>内存到内存必须经过寄存器</strong>）；</li></ul></li><li><p>Examples：</p><ul><li><p>例如 <code>movq $0x4,%rax</code> 可能对应的就是 <code>tmp = 0x4;</code></p></li><li><p>例如 <code>movq $-147,(%rax)</code>可能对应 <code>*p = -147;</code></p></li><li><p>例如 <code>movq %raw,%rdx</code> 可能对应 <code>tmp2 = tmp1;</code></p></li><li><p>例如 <code>movq $rax,(%rdx)</code> 可能对应 <code>*p = tmp;</code></p></li><li><p>例如 <code>movq (%rax),%rdx</code> 可能对应 <code>tmp = *p;</code></p></li><li><p>例如假设下面这段程序可能的汇编代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t0 = *xp;</span><br><span class="line">    <span class="type">long</span> t1 = *yp;</span><br><span class="line">    *xp = t1;</span><br><span class="line">    *yp = t0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">swap:</span><br><span class="line">    movq(%rdi), %rax</span><br><span class="line">    movq(%rsi), %rdx</span><br><span class="line">    movq%rdx, (%rdi)</span><br><span class="line">    movq%rax, (%rsi)</span><br><span class="line">    ret; 回到之前调用 swap 函数的位置，结束当前函数执行</span><br></pre></td></tr></table></figure><p><strong>在上面这个函数体中，<code>%rdi</code> 是保存第一个参数的寄存器，<code>%rsi</code> 是第二个参数寄存器，最多用 6 个</strong>，这是在执行此函数前就设置好的。剩下寄存器的选择是由编译器自己决定的，每次编译都可能不太一样；</p></li></ul></li><li><p>Exercises: Address Computation Examples（根据信息填写下表）</p><p>已知寄存器 <code>%rdx</code> 存放数据 0xf000，寄存器 <code>%rcx</code> 存放数据 0x0100。</p><table>    <tr style="text-align: center;">        <th>Expression</th>        <th>Address Computation</th>        <th>Address</th>    </tr>    <tr>        <td>0x8(%rdx)</td>        <td></td>        <td></td>    </tr>    <tr>        <td>(%rdx,%rcx)</td>        <td></td>        <td></td>    </tr>    <tr>        <td>(%rdx,%rcx,4)</td>        <td></td>        <td></td>    </tr>    <tr>        <td>0x80(,%rdx,2)</td>        <td></td>        <td></td>    </tr></table><p>第一行，就是普通 displacement，<code>0xF000 + 0x8 = 0xF008</code>;</p><p>第二行，省略的 general displacement，<code>0xF000 + 0x0100 = 0xF100</code>;</p><p>第三行，省略的 general displacement，<code>0xF000 + 4 * 0x0100 = 0xF400</code>;</p><p>第四行，省略的 general displacement，<code>0 + 2 * 0xF000 + 0x80 = 0x1E080</code>;</p></li></ul><h4 id="3-3-3-Arithmetic-amp-logical-operations"><a href="#3-3-3-Arithmetic-amp-logical-operations" class="headerlink" title="3.3.3 Arithmetic &amp; logical operations"></a>3.3.3 Arithmetic &amp; logical operations</h4><h5 id="Address-Computation-Instruction-leaq-lt-Src-gt-lt-Dst-gt"><a href="#Address-Computation-Instruction-leaq-lt-Src-gt-lt-Dst-gt" class="headerlink" title="Address Computation Instruction: leaq &lt;Src&gt;, &lt;Dst&gt;"></a>Address Computation Instruction: <code>leaq &lt;Src&gt;, &lt;Dst&gt;</code></h5><blockquote><p>指令含义：load effective address（加载有效地址）；</p><p>指令目标（很抽象，等会慢慢解释）：<strong>相当于 C 的 <code>&amp;</code>（ampersand）符号来计算地址</strong>，基于想要计算的地址的一些内容（一般是指定内存引用）。<strong>同时也作为一种非常方便的算术运算方式</strong>。</p><p>指令的大致过程：通俗来说就是<strong>传入的内存引用 <code>Src</code>，<code>leaq</code> 会找到这个引用的地址值，并把这个地址传给 <code>Dst</code></strong>，最后 <code>Dst</code> 的值是 <code>Src</code> 引用的地址，相当于 <code>Dst</code> 变成了指针，指向了 <code>Src</code>；</p><p><code>Dst</code> 参数<strong>必须是寄存器名称</strong>，不能是直接量、内存引用；</p><p><code>Src</code> 参数<strong>必须是内存引用</strong>，<strong>允许使用之前的 Simple Memory Addressing Mode</strong>，不能是直接量、寄存器名称；</p></blockquote><p>下面举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">m12</span><span class="params">(<span class="type">long</span> x)</span> &#123; <span class="keyword">return</span> x * <span class="number">12</span>; &#125;</span><br></pre></td></tr></table></figure><p>上面的函数对应的汇编代码可以是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m21:</span><br><span class="line">    leaq (%rdi,%rdi,2), %rax</span><br><span class="line">    salq $2, $rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>首先解释 <code>(%rdi,%rdi,2)</code>，这是上面要求记住的 <strong>Simple Memory Addressing Mode</strong>，它代表，把 <code>%rdi</code>（即这里存放函数第一参数 <code>x</code> 的寄存器）中的内容看成地址，进行一个 general displacement：<code>%rdi 的值 + 2 * %rdi 的值</code>，这里<strong>巧妙地完成了找到 3 倍的 <code>%rdi</code> 的值，把它作为索引，其对应的 memory 地址引用</strong>（注：这个地址很可能<strong>不能</strong>被程序使用，这里只是借助它进行算术计算）；</p><p>然后 <code>leaq</code> 将第一参数（3 倍 <code>%rdi</code> 值索引所对应 memory 的引用位置）<strong>对应的地址</strong>赋给了 <code>%rax</code> 寄存器。<strong>到此为止，<code>%rax</code> 中成功获得了 <code>%rdi</code> 中的 3 倍值，中间的方法虽然用到了指针的概念，但本质不是指针操作，是算数操作</strong>（慢慢领悟吧）。</p><p>最后使用的 <code>salq</code> 指令很简单，就是底层的移位指令（在后面介绍），将 <code>%rax</code> 的二进制值向左移动 2 位，相当于 × 4，总的来说 <code>%rax</code> 的值就相当于原来 <code>%rdi</code> 的值 × 12，完成了 × 12 的操作。</p><blockquote><p>有同学可能会问，为什么不全都给 <code>leaq</code> 来计算 × 12 呢？其实移位在效率上会更快一些。一般 C/C++ 程序在乘常数操作时，会被编译器优化，分解出 $2^k$ 的因子，一部分用 <code>leaq</code> 计算，另一部分用 <code>salq</code> 移位。</p></blockquote><h5 id="Some-Arithmetic-Operations"><a href="#Some-Arithmetic-Operations" class="headerlink" title="Some Arithmetic Operations"></a>Some Arithmetic Operations</h5><ul><li><code>addq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst + Src</code></li><li><code>subq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst - Src</code></li><li><code>imulq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst * Src</code></li><li><code>salq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &lt;&lt; Src</code></li><li><code>sarq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &gt;&gt; Src</code>（<strong>算术右移，arithmetic right shift</strong>）</li><li><p><code>shrq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &gt;&gt; Src</code>（<strong>逻辑右移，logical right shift</strong>）</p></li><li><p><code>xorq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst ^ Src</code></p></li><li><code>andq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &amp; Src</code></li><li><code>orq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst | Src</code></li></ul><p><strong>切记，别搞错 operands 的顺序！<code>Src</code> 在前，<code>Dst</code> 在后</strong>；</p><ul><li><code>incq &lt;Dst&gt;</code>：相当于 <code>Dst = Dst + 1</code></li><li><code>decq &lt;Dst&gt;</code>：相当于 <code>Dst = Dst - 1</code></li><li><code>negq &lt;Dst&gt;</code>：相当于 <code>Dst = -Dst</code></li><li><code>notq &lt;Dst&gt;</code>：相当于 <code>Dst = ~Dst</code>（注意是<strong>按位否</strong>）</li></ul><p><strong>还有一部分针对 128 bits 的计算</strong>，先放在这，不急着背，慢慢消化即可：</p><ul><li><p><code>imulq &lt;S&gt;</code>：<strong>默认 <code>%rax</code> 中存放另一个 operand</strong>，<strong>将 <code>S * R[%rax]</code> 的值存放到 <code>R[%rdx]:R[%rax]</code></strong>（high-order 64-bits 由 <code>%rdx</code> 承担，low-order 64-bits 由 <code>%rax</code> 承担）中，<strong>针对 signed 数</strong>；</p><blockquote><p>在 64 位架构下，你会发现 <code>R[%rdx]:R[%rax]</code> 的拼接方法表示 128-bits 数是约定俗成的行为。</p></blockquote></li><li><p><code>mulq &lt;S&gt;</code>：作用与 <code>imulq &lt;S&gt;</code> 相同，不过是对 unsigned 操作；</p></li><li><p><code>idivq &lt;S&gt;</code>：<strong>默认被除数（128-bits）存放在 <code>R[%rdx]:R[%rax]</code>，并与 <code>S</code>（64-bits）进行除法，除数存放在 <code>%rax</code>，余数存放在 <code>%rdx</code></strong>。<strong>针对 signed 数</strong>；</p></li><li><p><code>divq &lt;S&gt;</code>：作用与 <code>idivq &lt;S&gt;</code> 相同，不过是对 unsigned 操作；</p></li><li><p><code>cqto</code>：少见的没有参数的指令。<strong>作用是把 64-bits（quad word，默认存放在 <code>%rax</code>）转为 128-bits（octal word，默认存放在 <code>R[%rdx]:R[%rax]</code>），<u>signed extension</u></strong>；</p></li></ul><p>更多指令请参阅 x86-64 指令手册。</p><hr><p>下面是个 <strong>example</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">arith</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t1 = x + y;</span><br><span class="line">    <span class="type">long</span> t2 = z + t1;</span><br><span class="line">    <span class="type">long</span> t3 = x + <span class="number">4</span>;</span><br><span class="line">    <span class="type">long</span> t4 = y * <span class="number">48</span>;</span><br><span class="line">    <span class="type">long</span> t5 = t3 + t4;</span><br><span class="line">    <span class="type">long</span> rval = t2 * t5;</span><br><span class="line">    <span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arith:</span><br><span class="line">    leaq(%rdi,%rsi), %rax</span><br><span class="line">    addq%rdx, %rax</span><br><span class="line">    leaq(%rsi,%rsi,2), %rdx</span><br><span class="line">    salq$4, %rdx</span><br><span class="line">    leaq4(%rdi,%rdx), %rcx</span><br><span class="line">    imulq%rcx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这里 <code>%rdi</code> 存放了函数第一参数 x，<code>%rsi</code> 存放了函数第二参数 <code>y</code>，<code>%rdx</code> 存放了函数第三参数 <code>z</code>；</p><p>第一步，可以理解为将 <code>%rdi</code> 和 <code>%rsi</code> 值看作地址，找到 <code>%rdi 值 + %rsi 值</code> 对应的 memory 引用，并利用 <code>leaq</code> 将引用代表的地址赋给 <code>%rax</code>，使得 <code>%rax</code> 获得了 <code>%rdi</code> 和 <code>%rsi</code> 值之和的值，<strong>之所以不用 <code>addq</code>，是因为 <code>addq</code>  会把结果加到 <code>Dst</code> 上，但这里显然不想修改任何寄存器中的值，只是想把值给到新的寄存器</strong>（此步对应 <code>long t1 = x + y;</code>，相当于这里 <code>%rax</code> 存的是 <code>t1</code>）；</p><p>第二步，把 <code>%rdx</code> 的值（x）加到 <code>%rax</code> 上，这时的 <code>%rax</code> 存的是 <code>t2</code>（<code>t1</code> 以后不会用了，所以编译器抛弃了，直接用 <code>addq</code> 操作 <code>%rax</code>，这么做可以提升效率，对应 <code>long t2 = z + t1;</code>）；</p><p>第三步、第四步，前面说了好几遍，这里说简单一点，就是把 <code>%rdx</code> （原先存 <code>z</code> 的寄存器，抛弃 <code>z</code> 也是因为之后不用 <code>z</code> 变量了，编译器进行了优化）赋以 3 倍的 <code>%rsi</code> 值，并且把 <code>%rdx</code> 的值乘以 $2^4=16$，总的来说，<code>%rdx</code> 被赋以 48 倍的 <code>%rsi</code>（y）的值，对应 <code>long t4 = y * 48;</code>，这时 <code>%rdx</code> 存放的就是 <code>t4</code> 了；</p><p>第五步，简单说就是 <code>%rcx</code> 被赋以 <code>%rdi 的值（x） + %rdx 的值（t4） + 4</code>，可以看到，这里编译器想尽一切办法，把 <code>long t3 = x + 4;</code> 和 <code>long t5 = t3 + t4;</code> 这步合起来了，整整省下来了一个 <code>t3</code> 的操作，可谓优化到极致。所以，<code>%rcx</code> 存的是 <code>t5</code>；</p><p>最后一步，编译器实在想不到更好的优化方法，只能勉为其难地调用了唯一一次 <code>imulq</code>，把 <code>%rcx</code> 的值（<code>t5</code>）乘到 <code>%rax</code> 上，对应 <code>long rval = t2 * t5;</code>，函数结束，最后存放 <code>rval</code> 的寄存器是 <code>%rax</code>。</p><hr><h2 id="Chapter-4-Machine-Level-Programming-Ⅱ-Control"><a href="#Chapter-4-Machine-Level-Programming-Ⅱ-Control" class="headerlink" title="Chapter 4. Machine Level Programming Ⅱ - Control"></a>Chapter 4. Machine Level Programming Ⅱ - Control</h2><h3 id="4-1-Introduction-to-Condition-Codes"><a href="#4-1-Introduction-to-Condition-Codes" class="headerlink" title="4.1 Introduction to Condition Codes"></a>4.1 Introduction to Condition Codes</h3><h4 id="4-1-1-Processor-State-of-x86-64-partial"><a href="#4-1-1-Processor-State-of-x86-64-partial" class="headerlink" title="4.1.1 Processor State of x86-64, partial"></a>4.1.1 Processor State of x86-64, partial</h4><p>前面介绍过，x86-64 架构具有 16 个寄存器，其中 8 个沿用旧 x86 架构的名称，另外 8 个从 8 ~ 15 命名。可以总结一下，从这些寄存器 / flags 可以看出处理器当前的状态：</p><ul><li><p>Temporary data：除去 <code>%rsp</code> 的所有 15 个寄存器都是处理器运算时存储临时数据的位置；</p></li><li><p>Location of runtime stack：<code>%rsp</code>;（在以后的章节会涉及运行时栈）</p></li><li><p><strong>Location of current code control point</strong>：<code>%rip</code></p><blockquote><p>之前没有见过的寄存器，instruction point，和 <code>%rsp</code> 一样有特殊用途，<strong>可以将它看成程序计数器</strong>。</p><p><strong>它包含了当前正在执行指令的地址</strong>，也不能手动修改，一般是通过获取它的值来进行一些操作；</p><p><strong>它一般由 <code>call</code> 指令 和 <code>ret</code> 指令等修改</strong>；</p></blockquote></li><li><p>Status of recent tests: <strong>Condition Code</strong></p><ul><li>一共 8 种， 现在只说四种，其他的用到再说：<code>CF</code>、<code>ZF</code>、<code>SF</code>、<code>OF</code>;</li><li>它们都是 1-bit flag，不是被直接手动设置，而是根据其他指令操作后的结果进行设置（<strong>implicit setting</strong>）；</li><li>是汇编条件操作的基础；</li></ul></li></ul><h4 id="4-1-2-The-meanings-for-Condition-Codes"><a href="#4-1-2-The-meanings-for-Condition-Codes" class="headerlink" title="4.1.2 The meanings for Condition Codes"></a>4.1.2 The meanings for Condition Codes</h4><ul><li>Single bit register: 这种寄存器不是之前介绍的整型寄存器，它仅存储 1-bit 数据，专门用于存放 condition codes，它们的名称就是对应的 flag 的名称。先介绍其中 4 种的含义：<ul><li><code>CF</code>: Carry Flag (for unsigned, 将两个 unsigned 相加，MSB 的进位)；</li><li><code>SF</code>: Sign Flag (for signed, 当 signed 运算结果的 MSB = 1，说明结果是负值，此位会被置 1);</li><li><code>ZF</code>: Zero Flag (上一个计算结果为 0 时，此位会被置 1。依靠算术指令内部实现);</li><li><code>OF</code>: Overflow Flag (signed 运算溢出的位。<strong>因此可以将 <code>CF</code> 理解为“unsigned 运算溢出的位</strong>”);</li></ul></li><li><strong>注意：之前说的 <code>leaq</code> 不会设置这些 flags</strong>；但之前介绍的算术运算指令会。</li><li><strong>注意2：也有专门利用计算结果值来设置 flags 的指令：<code>compare 和 test</code></strong> (explicit setting)</li></ul><h4 id="4-1-3-Condition-Codes-Explicit-Setting"><a href="#4-1-3-Condition-Codes-Explicit-Setting" class="headerlink" title="4.1.3 Condition Codes: Explicit Setting"></a>4.1.3 Condition Codes: Explicit Setting</h4><h5 id="Compare-cmpq-lt-Src2-Src1-gt"><a href="#Compare-cmpq-lt-Src2-Src1-gt" class="headerlink" title="Compare: cmpq &lt;Src2, Src1&gt;"></a>Compare: <code>cmpq &lt;Src2, Src1&gt;</code></h5><ul><li>作用：几乎和 <code>subq</code> 一样，但不修改结果值，因为它计算 <code>Src1 - Src2</code> 并且不会对 <code>Src1/2</code> 进行任何操作，但会由此设置上面 4 个介绍到的 condition codes；</li><li>内部如何设置 condition codes：主要依据 <code>Src1 - Src2</code> 减法操作。<ul><li><code>CF</code> set if carry out from MSB (used for unsigned comparisons);</li><li><code>ZF</code> set if <code>Src1 == Src2</code>（即 <code>Src1 - Src2</code> 运算结果结果是否为 0）;</li><li><code>SF</code> set if <code>(Src1 - Src2) &lt; 0</code>（即 <code>Src1 - Src2</code> 运算结果的 sign 位是否为 1）;</li><li><code>OF</code> set if <code>(Src1 - Src2)</code> in two’s complement (signed) overflow（即 <code>(Src1 &lt; 0 &amp;&amp; Src2 &gt; 0 &amp;&amp; (Src1 - Src2) &lt; 0) || (Src1 &gt; 0 &amp;&amp; Src2 &lt; 0 &amp;&amp; (Src1 - Src2) &gt; 0)</code>，用的就是判断 signed 溢出的条件：两个同号 signed 相加为异号，说明正/负溢出）;</li></ul></li></ul><h5 id="Test-testq-lt-Src2-Src1-gt"><a href="#Test-testq-lt-Src2-Src1-gt" class="headerlink" title="Test: testq &lt;Src2, Src1&gt;"></a>Test: <code>testq &lt;Src2, Src1&gt;</code></h5><ul><li>作用：几乎和 <code>andq</code> 一样，但不修改结果值，只计算 <code>Src1 &amp; Src2</code>，并由此设置 condition codes；</li><li>内部如何设置 condition codes：<ul><li><code>ZF</code> set when <code>Src1 &amp; Src2 == 0</code>;</li><li><code>SF</code> set when <code>Src1 &amp; Src2 &lt; 0</code>;</li><li>因为按位且不会导致任何的进位，所以不设置 <code>CF/OF</code>;</li></ul></li><li>和上面的 Compare 相比，Test 指令可以进行一个参数的判断，例如 <code>testq %rax, %rax</code>，也把一个参数写成 mask，例如 <code>testq $0x22, %rax</code>;</li></ul><h4 id="4-1-4-Condition-Codes-Reading"><a href="#4-1-4-Condition-Codes-Reading" class="headerlink" title="4.1.4 Condition Codes: Reading"></a>4.1.4 Condition Codes: Reading</h4><p>前面说完如何设置，现在称述一下如何读取使用。这里一般不允许直接访问 flags 对应的寄存器，而是用一系列的 <code>SetX</code> instructions 来读取并操作。</p><p><code>SetX</code> Instructions 的作用就是<strong>按照当前的 condition codes，来将指定的单个寄存器的单个 byte 设置为 1 或 0</strong>；</p><p><code>SetX</code> Instructions 具体的类型如下：</p><table>    <tr style="text-align: center;">        <th>SetX</th>        <th>Condition</th>        <th>Description</th>    </tr>    <tr>        <td>sete</td>        <td>ZF</td>        <td>Equal/Zero</td>    </tr>    <tr>        <td>setne</td>        <td>~ZF</td>        <td>Not Equal/Not Zero</td>    </tr>    <tr>        <td>sets</td>        <td>SF</td>        <td>Negative</td>    </tr>    <tr>        <td>setns</td>        <td>~SF</td>        <td>Nonegative</td>    </tr>    <tr>        <td>setg</td>        <td>~(SF^OF)&amp;~ZF</td>        <td>Greater (signed)</td>    </tr>    <tr>        <td>setge</td>        <td>~(SF^OF)</td>        <td>Greater or Equal (signed)</td>    </tr>    <tr>        <td>setl</td>        <td>(SF^OF)</td>        <td>Less (signed)</td>    </tr>    <tr>        <td>setle</td>        <td>(SF^OF) | ZF</td>        <td>Less or Equal (signed)</td>    </tr>    <tr>        <td>seta</td>        <td>~CF &amp; ~ZF</td>        <td>Above (unsigned)</td>    </tr>    <tr>        <td>setb</td>        <td>CF</td>        <td>Below (unsigned)</td>    </tr></table><blockquote><p><code>SetX</code> Instructions 都有唯一参数（<strong>语法 <code>setX &lt;Dst&gt;</code></strong>），要求是单个寄存器的 low-order 8-bit 的引用名称，这是由这条指令的作用决定的。</p></blockquote><p>看上面的表，就解释一个。以 <code>setl</code> 为例，因为大多数时候我们使用 <code>cmpq</code> 对 condition codes 进行设置，所以当 <code>SF</code> 为 1 时，很可能是 <code>Src1 - Src2 &lt; 0</code> 的情况。但是需要排除 <code>Src1 - Src2</code> 正溢出的情况——正溢出也可能导致结果为负，因此是 <code>SF ^ OF</code>；</p><p>最后还有一个问题。<code>setX</code> 是为单个寄存器的<strong>单个 low-order 8-bit 设置 0/1</strong>，但之前<strong>在 3.3.1 中明确说过</strong>，我们在 x86-64 架构下一般都讨论 64-bit register 的使用，而那些访问寄存器的 low-order 32-bit（例如 <code>%eax</code>）、low-order 16-bit 的方法用的比较少（在 32 位架构下会多一点）。</p><p>而这里，为了条件控制，我们必须访问 64-bit register 的 low-order 8-bit 的位置，这些位置可以由以下名称给出：</p><ul><li>字母类型命名的 register，不使用前缀 <code>r</code>，而使用后缀 <code>l</code> 就能代表对应的 low-order 8-bit 位置；例如：<code>%rax</code> 的 low-order 1-bit 位置是 <code>%al</code>、<code>%rbx</code> 是 <code>%bl</code>、<code>%rcx</code> 是 <code>%cl</code>、<code>%rdx</code>是 <code>%dl</code>、<code>%rsi</code> 是 <code>%sil</code>、<code>%rdi</code> 是 <code>%dil</code>、<code>%rsp</code> 是 <code>%spl</code>、<code>%rbp</code> 是 <code>%bpl</code>；</li><li>数字类型命名的 register，使用后缀 <code>b</code> 就代表对应的 low-order 8-bit 位置；例如 <code>%r8b</code>、<code>%r15b</code> 等；</li></ul><p>这样操作 64-bit integer register 的 low-order 8-bit，不会影响到其他位的信息；</p><hr><p>下面是 <strong>example</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gt</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br></pre></td></tr></table></figure><p>其对应的汇编代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gt:</span><br><span class="line">    cmpq%rsi, %rdi</span><br><span class="line">    setg%al</span><br><span class="line">    movzbl%al, %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>已知 <code>%rdi</code> 存放了函数的第一参数 x 的值，<code>%rsi</code> 存放了函数第二参数 y 的值，函数返回的结果就放在 <code>%rax</code> 中。下面逐步分析：</p><p>第一步使用了 <code>cmpq</code> 将 <code>%rdi 值 - %rsi 值</code>（即 <code>x - y</code>）计算，并为 4 个 condition codes 进行修改；</p><p>第二步，<code>setg</code> 对 <code>%al</code> 操作，这是 <code>%rax</code>  的 low-order 8-bit 的位置，表明如果 <code>~(SF ^ OF) &amp; ~ZF</code> 成立，即 <code>x &gt; y</code> 成立，那么为 <code>%rax</code> 的 low-order 8-bit 位置置为 1，否则置为 0；<strong>显然，这里的 <code>%rax</code> 还需要把前面 7 bytes 全部置为 0，才能成为我要返回的值（(int)0/1）</strong>，我们应该怎么做呢？</p><p>第三步用到了新的指令 <code>movzbl</code>（<strong>move with zero extension byte to long</strong>）</p><blockquote><p>语法：<code>movzbl &lt;Src&gt;, &lt;Dst&gt;</code>;</p><p>作用：把一个 <code>Src</code> 数据引用大小的 <strong>0 数据</strong> 扩展到 <code>Dst</code> 中（会改变 <code>Dst</code>，但不会改变 <code>Src</code>）;</p></blockquote><p>那么好，问题又来了，为什么我们明明要把 <code>%rax</code> 剩下的所有 7 bytes 全部置 0，但是汇编中写的却是对 <code>%eax</code>（之前提到的，register 的 low-order 32-bit 位置）置 0，剩下的 high-order 32-bit 不管了吗？</p><p>⚠ 实际上，这是 x86-64 架构内部令人迷惑的特性。当一个 64-bit register 从 low-order 只被修改 32-bit 数据时，<strong>会自动将剩下的 high-order 32-bit 全部置 0</strong>。（但是如果只是修改 low-order 16-bit、low-order 8-bit 时，却<strong>不会</strong>为前面的部分置 0）</p><p>到此为止，<code>%rax</code> 中的数据应该长这样：<code>0x000000000000000?</code>（最后一位取决于 <code>setg</code> 到底 set 了什么），这就是我们需要返回的 <code>x &gt; y</code> 表达式的值，所以函数结束。</p><hr><h3 id="4-2-Conditional-Branches"><a href="#4-2-Conditional-Branches" class="headerlink" title="4.2 Conditional Branches"></a>4.2 Conditional Branches</h3><p>前一节的例子描述了如何依靠 condition codes 来修改某个寄存器的 low-order 8-bit 的值，这是实现条件分支的基础。</p><p>这一节将利用 condition code 来组织条件分支，本质上也是 reading condition codes；</p><h4 id="4-2-1-JX-Instructions-【Old】"><a href="#4-2-1-JX-Instructions-【Old】" class="headerlink" title="4.2.1 JX Instructions 【Old】"></a>4.2.1 JX Instructions 【Old】</h4><ul><li><p>语法：<code>jX &lt;LABEL&gt;</code>，这里的 <code>&lt;LABEL&gt;</code> 是汇编程序中的一个<strong>段落标签</strong>，在具体例子中会展示。</p><blockquote><p>还有一种语法，会在 4.4 中介绍。</p></blockquote></li><li><p>作用：有条件（根据 condition codes）/ 无条件跳转到指定部分的汇编代码继续执行；</p></li><li><p>具体类型（和 <code>SetX</code> Instructions 使用名称类似）：</p><table>    <tr style="text-align: center;">        <th>jX</th>        <th>Condition</th>        <th>Description</th>    </tr>    <tr>        <td>jmp</td>        <td>1</td>        <td>Unconditional</td>    </tr>    <tr>        <td>je</td>        <td>ZF</td>        <td>Equal/Zero</td>    </tr>    <tr>        <td>jne</td>        <td>~ZF</td>        <td>Not Equal/Not Zero</td>    </tr>    <tr>        <td>js</td>        <td>SF</td>        <td>Negative</td>    </tr>    <tr>        <td>jns</td>        <td>~SF</td>        <td>Nonegative</td>    </tr>    <tr>        <td>jg</td>        <td>~(SF^OF)&amp;~ZF</td>        <td>Greater (signed)</td>    </tr>    <tr>        <td>jge</td>        <td>~(SF^OF)</td>        <td>Greater or Equal (signed)</td>    </tr>    <tr>        <td>jl</td>        <td>(SF^OF)</td>        <td>Less (signed)</td>    </tr>    <tr>        <td>jle</td>        <td>(SF^OF) | ZF</td>        <td>Less or Equal (signed)</td>    </tr>    <tr>        <td>ja</td>        <td>~CF &amp; ~ZF</td>        <td>Above (unsigned)</td>    </tr>    <tr>        <td>jb</td>        <td>CF</td>        <td>Below (unsigned)</td>    </tr></table></li><li><p>Example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">absdiff</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) result = x - y;</span><br><span class="line">    <span class="keyword">else</span> result = y - x;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">    cmpq%rsi, %rdi</span><br><span class="line">    jle.L4</span><br><span class="line">    movq%rdi, %rax</span><br><span class="line">    subq%rsi, %rax</span><br><span class="line">    ret</span><br><span class="line">.L4:</span><br><span class="line">    movq%rsi, %rax</span><br><span class="line">    subq%rdi, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>已知 <code>%rdi</code> 保存的是函数第一参数 x，<code>%rsi</code> 保存的是函数第二参数 y，<code>%rax</code> 保存函数返回值。</p><blockquote><p>再次说一下，<strong>汇编函数返回前只需要把返回值放在特定的寄存器中就行</strong>，只要调用方清除你放在哪就行。比如这里放在 <code>%rax</code>，那么函数结束后，调用方会去 <code>%rax</code> 访问结果。</p></blockquote><p>第一步 <code>cmpq</code> 根据 <code>%rdi 值 - %rsi 值</code> 来设置 condition codes；</p><p>第二步的 <code>jle</code> 对应的条件是 <code>(SF ^ OF) | ZF</code>，结合上一步也就是 <code>x ≤ y</code> 时，跳至 <code>.L4</code> 标签标记的位置继续执行。</p><p>这里 <code>.L4</code> 是一个标签，<code>.</code> 开头表示它是<strong>内部的</strong>操作或标签，只会出现在汇编代码中，不会出现在目标代码（机器代码）中，所以不会被当作独立的函数。</p><blockquote><p>有同学会说，不是说汇编代码就是机器代码的文本表示吗？为啥还有差别？</p><p>其实是这样的，汇编代码相对于机器代码，在转换为易读的文本同时，会把一些<strong>指令地址</strong>设置成内部标签。在汇编转机器代码时，会再计算代入回去。不然你读 <code>jle 0x0F0E2310</code> 肯定没有 <code>jle .L4</code> 好读。</p></blockquote><p>后两步的含义已经比较简单了，不再赘述。</p><p>上面的内容<strong>类似 C/C++ 中的 goto 语句，不建议在 C/C++ 中使用</strong>；</p></li></ul><h4 id="4-2-2-General-Conditional-Expression-Translation-amp-Conditional-Moves"><a href="#4-2-2-General-Conditional-Expression-Translation-amp-Conditional-Moves" class="headerlink" title="4.2.2 General Conditional Expression Translation &amp; Conditional Moves"></a>4.2.2 General Conditional Expression Translation &amp; Conditional Moves</h4><blockquote><p>本小节介绍了 “条件移动” 这种编译器优化的方式，告诉我们在有些情况下，编译器将条件控制一味地翻译成 <code>JX</code> Instructions 不见得是最好的；同时也指明了不应该使用 “条件移动” 优化的情形。</p></blockquote><p>上面介绍的 <code>JX</code> Instructions 真的适合编译器使用吗？效率是最高的吗？如果仔细看上一节标题会发现有一个 “【Old】” 的标志，这说明现在不经常用到它了。如果效率不佳，那么有哪些方法可以考虑呢？为什么呢？</p><p>如果编译器将 C++ 代码翻译为上面的 <code>JX</code> Instructions，那么这种翻译被称为 <strong>General Conditional Expression Translation</strong>，这也是最自然的方法：如果满足某个条件就跳转到哪里执行，否则如何如何。</p><p>还有一种方法被称为 <strong>条件移动（Conditional Moves）</strong>，是将 C/C++ 代码中的条件分支（if-else）的 “then” 分支和 “else” 分支<strong>全部执行</strong>，最后按照条件再决定将谁移动到结果寄存器中。</p><p>伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result    = the value of Then_Expr</span><br><span class="line">eval    = the value of Else_Expr</span><br><span class="line">cond    = !(the value of Test)</span><br><span class="line">if (cond) result = eval</span><br><span class="line"></span><br><span class="line">return result</span><br></pre></td></tr></table></figure><p>有人说，这把 then 子句和 else 子句都运行了，平均的时间复杂度上不是会比之前的 General Condition Expression 更浪费时间吗？其实不然，这里的知识和后面章节的 “流水线” 有关。</p><p>因为现代处理器采用 “流水线（pipeline）” 的运行方式，在到达一行代码时会关联甚至运行下面几行的代码。现代处理器大概可以同时处理 20 行左右的指令深度（主要取决于事先读入的指令条数）。当运行到含有分支的部分时，处理器会采取 “<strong>分支预测技术</strong>”，根据上下文猜测会运行到哪个分支，并将猜测的分支事先读入流水线。</p><p>如果猜对，那么执行非常迅速，直接读取流水线上的信息，并离开这个分支；但是如果猜错，那么将停止执行当前流水线上的代码，并重新读入另一段分支。这是个耗时操作，较差情况下会花费 40 个时钟周期（40 步普通指令执行时间）。</p><p>因此，<strong>在某些情况下</strong>，使用 Conditional Moves 的条件判断方法可能会比 General Conditional Expression 更高效。</p><p><strong>正因如此，大多数编译器在<u>某些情况下</u>都选择 Conditional Moves，而不是上面的 <code>JX</code> 指令（代表 General Condition Expression），所以你几乎看不到 4.2.1 中的汇编代码。</strong>如果实在想看到，那么在用 gcc 编译时，给定参数 <code>-fno-if-conversion</code>，这样不允许编译器使用条件移动。</p><hr><p>所以在 4.2.1 中大多数情况下的汇编代码应该长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">    movq%rdi, %rax</span><br><span class="line">    subq%rsi, %rax</span><br><span class="line">    movq%rsi, %rdx</span><br><span class="line">    subq%rdi, %rdx</span><br><span class="line">    cmpq%rsi, %rdi</span><br><span class="line">    cmovle%rdx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>再稍微解释一下，第一步是将 <code>%rdi</code> 的值（即函数第一参数 x）赋给 <code>%rax</code>；</p><p>从第二步开始就是条件移动的方法了：第二步先把 <code>%rax</code> 的值（x）减去 <code>%rsi</code>（y），相当于先做了 then 分支的内容；</p><p>第三步是将 <code>%rsi</code> 的值（y）移动到 <code>%rdx</code> 中，并再第四步把 <code>%rdx</code> 的值减去 <code>%rdi</code>（x），相当于完成了 else 分支的内容；</p><p>到目前为止，<code>%rax</code> 中存放 <code>x - y</code> 的值，<code>%rdx</code> 中存放 <code>y - x</code> 的值；</p><p>第五步才是按照 x、y 的值来设置 condition codes；</p><p>最后一步是一个<strong>新指令：<code>cmovle</code></strong>;</p><ul><li>语法：<code>cmovle &lt;Src&gt;, &lt;Dst&gt;</code>；</li><li>作用：条件移动，按照当前 condition codes 的状态进行移动。其中 <code>cmov</code> 就是 conditional moves，<code>le</code> 就是之前的 <code>X</code> 情况（小于等于情况），所以猜测还有 <code>cmovl</code>、<code>cmovge</code>、<code>cmovg</code>……</li></ul><hr><p>但是，上面说 <strong>Conditional Moves 更快是在“某些情况下”</strong>，那么什么是 “另外的情况”？</p><p>现在介绍在什么时候，汇编的翻译不应该用 Conditional Moves：</p><p><strong>Situation 1: Expensive Computations</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = Test(x) ? Hard1(x) : Hard2(x);</span><br></pre></td></tr></table></figure><p>这种 then 子句和 else 子句都非常难以计算的时候，不应该用条件移动。因为重新读入流水线的时间很可能会少于把两个子句都计算一遍的时间；</p><p><strong>Situation 2: Risky Computations</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = p ? *p : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>上面的判断语句必须先判断再进行执行，否则会出现程序错误，尤其是在指针的判断上；</p><p><strong>Situation 3: Computations with side effects</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = x &gt; <span class="number">0</span> ? x*=<span class="number">7</span> : x+=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>上面的 then 和 else 子句一旦执行，会破坏程序的原义，造成意想不到的后果。</p><h3 id="4-3-Loops"><a href="#4-3-Loops" class="headerlink" title="4.3 Loops"></a>4.3 Loops</h3><h4 id="4-3-1-Do-While-Loop"><a href="#4-3-1-Do-While-Loop" class="headerlink" title="4.3.1 Do-While Loop"></a>4.3.1 Do-While Loop</h4><p>对于一个计算 x 代表的二进制代码中的 1 的个数的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pcount_do</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result += x &amp; <span class="number">0x1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的汇编代码非常简单，<strong>就可以用 General Conditional Expression 的方法，结合 <code>JX</code> Instructions 实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pcount_do:</span><br><span class="line">    movl$0, %eax</span><br><span class="line">.L2:</span><br><span class="line">    movq%rdi, %rdx</span><br><span class="line">    andl$1, %edx</span><br><span class="line">    addq%rdx, %rax</span><br><span class="line">    shrq%rdi</span><br><span class="line">    jne.L2</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure><p>对应的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    preparations</span><br><span class="line">loop:</span><br><span class="line">    Body</span><br><span class="line">    if (Test)</span><br><span class="line">        goto loop</span><br></pre></td></tr></table></figure><p>这里注意一下，<code>movl</code> 和 <code>andl</code> 都不算新的指令——之前说过 <code>q</code> 的含义代表操作数的位数，quad 指 4 字（4 × 16 bits），<code>l</code> 就指 2 字，2 × 16 bits；</p><h4 id="4-3-2-General-While-Loop-Translation-1-“Jump-to-Middle”-Translation"><a href="#4-3-2-General-While-Loop-Translation-1-“Jump-to-Middle”-Translation" class="headerlink" title="4.3.2 General While Loop Translation #1 - “Jump to Middle” Translation"></a>4.3.2 General While Loop Translation #1 - “Jump to Middle” Translation</h4><p>从 do-while 到 while 只需要更改一下测试条件的顺序就行。例如上一节的代码改成 while 循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pcount_do</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        result += x &amp; <span class="number">0x1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么对应的汇编伪代码<strong>可以是</strong>（一般在编译器优化等级 <code>-Og</code> 时出现）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    goto test;// 先测试</span><br><span class="line">loop:</span><br><span class="line">    Body</span><br><span class="line">test:</span><br><span class="line">    if (Test)</span><br><span class="line">        goto loop;// 通过再进循环体</span><br><span class="line">done:</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure><h4 id="4-3-3-General-While-Loop-Translation-2-“Do-while”-Conversion"><a href="#4-3-3-General-While-Loop-Translation-2-“Do-while”-Conversion" class="headerlink" title="4.3.3 General While Loop Translation #2 - “Do-while” Conversion"></a>4.3.3 General While Loop Translation #2 - “Do-while” Conversion</h4><p>如果把编译器的优化等级调至 <code>-O1</code>，那么编译器在处理 while 循环时不会采用上面的 ”Jump to Middle“ 的翻译策略，而是采用 <strong>转换为 do-while 循环</strong> 的策略，这样会更加高效。</p><p>这相当于把 C/C++ 代码中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test) &#123;</span><br><span class="line">    Body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换成了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Test)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Body</span><br><span class="line">&#125; <span class="keyword">while</span> (Test);</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>具体的汇编伪代码会变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    if (!Test)// 仅进入前判断一下，接下来就变成 do-while</span><br><span class="line">        goto done;</span><br><span class="line">loop:</span><br><span class="line">    Body</span><br><span class="line">    if (Test)</span><br><span class="line">        goto loop;</span><br><span class="line">done:</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure><p>从这个优化上可以看出，其实 do-while 循环会比 while 循环更高效，但现在的编译器比较智能，只要优化等级不低，这个方面会帮你优化掉的。</p><h4 id="4-3-4-For-Loop"><a href="#4-3-4-For-Loop" class="headerlink" title="4.3.4 For Loop"></a>4.3.4 For Loop</h4><p>for loop 的汇编实现没那么简单，我们可能需要向 while 或 do-while 上看齐。比如对如下 for 循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Init; Test; Update) &#123;</span><br><span class="line">    Body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器可以转换成 while 循环，如果使用了 <code>-O1</code> 优化，会优化到 do-while：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Init;</span><br><span class="line"><span class="keyword">while</span> (Test) &#123;</span><br><span class="line">    Body</span><br><span class="line">    Update;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"></span><br><span class="line">Init;</span><br><span class="line"><span class="keyword">if</span> (!Test) &#123;    <span class="comment">// do-while 前的测试块（Initial Test）</span></span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Body</span><br><span class="line">    Update;</span><br><span class="line">&#125; <span class="keyword">while</span> (Test);</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>很多时候，<code>-O1</code> 下的编译器甚至可以识别 <code>Init</code> 块 和 do-while 前的测试块的关联，并且合理舍弃前置的测试块。</p><h3 id="4-4-Switch-Statements"><a href="#4-4-Switch-Statements" class="headerlink" title="4.4 Switch Statements"></a>4.4 Switch Statements</h3><p>将 C/C++ 的 switch 语句翻译为汇编是相当有难度的。首先应该弄清楚 switch 语句在 C/C++ 中的一系列特性：</p><ul><li><p>Match integer values；</p></li><li><p>Fall through cases：当 case 中不存在 break 时，会一直向下运行；</p></li><li>Merge cases：当一个 case 中没有任何内容时，相当于并入下一个 case（上一点的特例）；</li><li>Default case：对于没有匹配的 cases，会进入最后的 default case（如果有的话）；</li></ul><p>当然，现代的编译器对于 switch 语句的翻译绝不是一系列的 if-else 语句的翻译，而是利用了一个数据结构：<strong>跳表（Jump Table Structure）</strong>；</p><p>如下图，switch-case 语句就像一串代码块，每个 case 就是一个块。编译时，switch-case 块会整体一起编译（如下图 Jump Targets），转为汇编指令后，每个块的汇编指令所对应的<strong>地址</strong>会被存储在一个跳表中（如下图 Jump Table）。这样在根据条件调用相应代码块时，只需要 goto 跳表中的对应地址（ray indexing）就能完成任务，无需一个个比对条件。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/jump_table.png" height="300px"></p><p>那么，汇编代码是如何在跳表中找到合适的地址的呢？举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_eg</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        w = y * z;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        w = y / z;</span><br><span class="line">        <span class="comment">/* Fall Through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        w += z;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        w -= z;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        w = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子对应的汇编代码可以是（一部分代码）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch_eg:</span><br><span class="line">    movq%rdx, %rcx</span><br><span class="line">    cmpq$6, %rdi</span><br><span class="line">    ja.L8</span><br><span class="line">    jmp*.L4(,%rdi,8)</span><br></pre></td></tr></table></figure><p>逐步解释：</p><p>第一步将 <code>%rdx</code>（第三参数 z）赋值到 <code>%rcx</code> 寄存器中；</p><p>第二步就将 <code>%rdi</code>（第一参数 x）与常数 6 进行做差比较（为什么是 6？因为在源码中 6 是最大的 case），以此修改 condition codes；</p><p>第三步 <code>ja</code> 表示只要 <code>%rdi</code>（x）的值（<strong>看作 unsigned</strong>）在 6 之上，那么就跳至 <code>.L8</code>（看来是 default 片段），否则第四步会无条件跳至某个位置；</p><blockquote><p>这里编译器处理的非常巧妙：使用 <code>ja</code>（unsigned above）而不是 <code>jg</code>（signed greater），这样同时把 <code>x &gt; 6</code> 和 <code>x &lt; 0</code> 的情况都算入 <code>ja</code> 的条件中，进一步提高了效率；</p></blockquote><p>这里还需要解释一下，之前没有提到的 <code>JX</code> Instructions 的使用语法。除了 <code>jX &lt;LABEL&gt;</code> 直接跳转至对应标签（direct jump），另一种方法是<strong>间接跳转（indirect jump）：<code>jX &lt;effectiveAddress&gt;</code></strong>；</p><p>参数是有效地址，可以是寄存器名称，也可以是右值，例如这个例子中 <code>jmp *.L4(,%rdi,8)</code>，后面的部分 <code>.L4(,%rdi,8)</code> 应该很熟悉了：因为标签会被汇编器翻译为代码段的地址，所以它就是 <code>.L4地址 + 8 * x</code>（<code>%rdi</code> 的值是 x），并把这个值看作 memory 的地址。前面的 <code>*</code> 星号就是直接取地址上内容的意思（和 C/C++ 的相同），可以理解为 <code>leaq</code> 相反的过程；<strong>这个 memory 地址中的值就是跳表中的一个代码段的地址</strong>，所以取出来的也是地址；</p><p>第四步跳转的位置如何，我们需要看看剩下来的汇编代码（跳表部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            ; read only data</span><br><span class="line">.section    .rodata; 这行和下一行是为了构造跳表的基本结构</span><br><span class="line">    .align8; 伪对齐指令，指明下面的变量必须从下一个能被 8 整除的地址开始</span><br><span class="line">.L4:                ; 代码块按照 x 的值的顺序进行排列</span><br><span class="line">    .quad.L8; x = 0 的情况</span><br><span class="line">    .quad.L3; x = 1</span><br><span class="line">    .quad.L5; x = 2</span><br><span class="line">    .quad.L9; x = 3</span><br><span class="line">    .quad.L8; x = 4</span><br><span class="line">    .quad.L7; x = 5</span><br><span class="line">    .quad.L7; x = 6</span><br></pre></td></tr></table></figure><p>如上所示，跳表的结构是由汇编代码指定的，如何填这个表是<strong>汇编器的工作</strong>，不是编译器的工作；</p><p>在编译器生成的汇编代码中，<code>.quad</code> 只是个声明，标记表示这里是一个 4 字（4 × 16 bits）的数据，以后汇编器需要填上后面指定标签指令段的地址；</p><p>我们可以发现，<code>x &lt; 0</code> 和 <code>x &gt; 6</code> 的情况在之前的代码中被 <code>ja</code> 处理，跳至 <code>.L8</code>（default 代码段），剩余在 switch 中整数缺省的情况（<code>x = 4</code> 和 <code>x = 0</code>）也会自动转至 <code>.L8</code>;</p><p>主干看完了，继续看之前提到的各个代码段的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.L3:                    ; 对应 x = 1 的情况的代码段</span><br><span class="line">    movq%rsi, %rax</span><br><span class="line">    imulq%rdx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>接下来，编译器的行为就很迷惑了。大家是否还记得，之前在源码的第一行有 <code>long w = 1;</code> 的初始化操作？但编译器不做，因为在很多 case 下并没有用到这个值，所以赋值被推迟了，直到有一个 case—— <code>x = 3</code>，它的代码段是 <code>w += z;</code> 需要用到之前的值，这个时候编译器才开始赋值 1，这么做只是为了提高效率……如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.L5:                    ; 对应 x = 2 的代码段</span><br><span class="line">    movq%rsi, %rax</span><br><span class="line">    cqto</span><br><span class="line">    idivq%rcx; %rcx 中存放 z，这里是 y/z</span><br><span class="line">    jmp.L6</span><br><span class="line">.L9:                    ; 对应 x = 3 的代码段之前的 x = 1 的赋值操作，也是x = 3入口</span><br><span class="line">    movl$1, %eax</span><br><span class="line">.L6:                    ; 对应 x = 3 的代码段主体</span><br><span class="line">    addq%rcx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>其中 <code>cqto</code> 是 Convert Quadword to Octoword，意为 64-bit 扩展至 128-bit，没有参数，作用是将 <code>%rax</code> 中的 MSB 复制到整个 <code>%rdx</code> 寄存器中（这么做的原因是 <strong>Expanding Conclusion</strong>），一般紧接着 <code>idivq &lt;dividerR&gt;</code>，将 <code>rdx:rax</code> 中的 128-bit 数作为被除数，<code>divderR</code> 作为除数，进行 signed 除法，商存在 <code>%rax</code>，余数存在 <code>%rdx</code>；</p><p>继续：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.L7:                    ; x = 5</span><br><span class="line">    movl$1, %rax</span><br><span class="line">    subq%rdx, %rax</span><br><span class="line">    ret</span><br><span class="line">.L8:                    ; x = 6</span><br><span class="line">    movl$2, %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>明白了跳表的原理，这下明白了为啥 C/C++ 要求 switch 的量必须是可以转换为整型的常量了吧？</p><p>无论如何，编译器都会找出你写的所有 case 的最大值、最小值，在此之外的情况会在进入跳表前进行跳转至 default 块；在最值之间的，会出现在跳表中（也就是说 case 的最大值、最小值决定了跳表的大小）；但是在范围中有缺省的情况的，也会补充在跳表中，跳转到 default 块。</p><blockquote><p>小机灵可能会问，诶，如果这些 case <strong>全是负数咋整</strong>？或者<strong>最小值很大咋整</strong>？还能不能建立跳表、用索引了？因为咱之前的 <code>jmp *.L4(,%rdi,8)</code> 不就直接把 x 做跳表索引了吗？</p><p>实际编译器会确保最小值不会低于 0，也不会太大。为此，编译器可能会加上<strong>偏置值（bias）</strong>让 case 变成小的正数。</p><p>还有小机灵可能会问，如果一个 case 是 0， 另一个是 10000，难度在这之中的全部要建表吗？也就是说，如果 case 的<strong>间隔很稀疏、很大</strong>怎么办？</p><p>这个时候编译器会把这些 switch-case 转换成 if-else 语句，再建立 if-else 树，由于稀疏的数据，所以这个树大概率是平衡树，让比对的时间复杂度保持在 $O(log_2(n))$；</p></blockquote><p>综合上面的讨论，无论如何 switch-case 所依赖的跳表的时间复杂度会在 $O(1)\sim O(log_2(n))$ 之间，总是比 if-else 的线性时间复杂度要好。</p><h3 id="4-5-Summary-for-Chapter-4"><a href="#4-5-Summary-for-Chapter-4" class="headerlink" title="4.5 Summary for Chapter 4"></a>4.5 Summary for Chapter 4</h3><p>这章的知识点比较多，在这里总结一下 Chapter 4 的主要内容。</p><p>在一开始，我们先复习了之前的寄存器及其代表的处理器的状态，再初步了解了汇编中的重要 flags: condition codes（目前只认识了 4 个：<code>CF/OF/SF/ZF</code>），它们可以看作一个个 1-bit 数据，不能被手动更改，但可以通过特定的方式进行访问。</p><p>例如 <code>cmpq</code> 和 <code>testq</code> 能根据计算结果修改 flags，<code>setX</code> Instructions 能根据当前 flags 设置特定的 8-bit 位。我们还了解了几个特殊的指令，例如 <code>movzbl</code>；了解了 x86-64 的 low-order 32-bit 填充特性。</p><p>我们不满足于借助 condition codes 仅仅填充几个 bits，我们进一步学习了根据 condition codes 进行流程控制的方法。</p><p>首先是比较低效的 <code>JX</code> Instructions，它代表着 General Conditional Expression，利用汇编<strong>条件跳转</strong>初步实现条件分支；进一步从流水线层面，我们认识到 <strong>Conditional Moves</strong> 可能是更好、更快的选择，但一定要搞清 3 个禁忌条件。我们还认识了 <code>cmovle</code> 等一系列<strong>条件移动的指令</strong>，让过程更加方便。</p><p>在循环控制方面，我们掌握了 do-while 结构的翻译方法，通过 <code>JX</code> 指令轻松解决；针对 while 循环时，我们想到两种方法：“Jump to Middle” 把判断条件放 loop 的中间，开始循环前跳进去；还有一种是转换为 do-while 的 “set guardian” 方法，效率更高。对于 for 循环，我们也可以容易地将其转换为 while 循环，进一步优化为 do-while，通过合理舍弃 “guardian” 进一步加快运行效率。</p><p>在比较繁琐的 switch-case 语句的翻译上，聪明的人们为它引入了<strong>跳表</strong>的数据结构，利用 <code>jX</code> 的间接跳转在 $O(1)\sim O(log_2(n))$ 的复杂度下完成了分支，远胜 if-else 结构的线性复杂度。</p><p>不过上面的几乎所有内容都是在汇编层面<strong>实现了一些小的 “tricks”</strong> 来帮助提升运行效率，这只是在将代码流程控制的翻译这个 procedure 上加一点东西，或者是<strong>改变流程的方法</strong>。这都是底层指令逐步堆砌实现更高级指令的实例。</p><p>下一章节我们将系统学习汇编运行的整个 procedure，知识点将更为复杂，做好准备！</p><h2 id="Chapter-5-Machine-Level-Programming-Ⅲ-Procedure"><a href="#Chapter-5-Machine-Level-Programming-Ⅲ-Procedure" class="headerlink" title="Chapter 5. Machine Level Programming Ⅲ - Procedure"></a>Chapter 5. Machine Level Programming Ⅲ - Procedure</h2><blockquote><p>本章所指的 Procedure 既可以是 function，method，也可以是 normal procedure；</p></blockquote><p>知识补充：什么是 ABI ？</p><p>虽然 CSAPP 讲述的是基于 x86 硬件及其运行方式，但更重要的是我们采用了一套被普遍承认的约定—— ABI（Application Binary Interface），这是个<strong>机器程序级别的接口</strong>。这个接口在第一台 x86 机器被制造出来的时候就出现了，尤其是为 Linux 制定的。它规定了，所有二进制程序、操作系统各个组件、编译器都要对于管理机器上的资源有共同的理解，并且遵守使用规则。</p><p><strong>例如之前说的，约定俗成哪些寄存器用来传递函数参数、哪些寄存器用来传递返回值，哪些是 “Caller-Saved Register”，哪些又是 “Callee-Saved Register”</strong>，这些都是 ABI 规定的；</p><p>到目前，Windows 和 OSX 等操作系统也有自己的 ABI；</p><h3 id="5-1-Mechanisms-in-Procedures"><a href="#5-1-Mechanisms-in-Procedures" class="headerlink" title="5.1 Mechanisms in Procedures"></a>5.1 Mechanisms in Procedures</h3><blockquote><p>过程机理的概览，下几节会一一回答这些问题；</p></blockquote><ul><li>Passing control<ul><li>To beginning of procedure code（运行过程如何进入一个函数？）</li><li>Back to return point（函数运行结束如何跳转到之前调用位置的下一行？）</li></ul></li><li>Passing data<ul><li>Procedure argument（如何向被调方传递参数？）</li><li>Return value（被调方如何返回数据给调用方？）</li></ul></li><li>Memory management<ul><li>Allocate during procedure execution（某过程开始执行时，内存如何分配以供过程使用？）</li><li>Deallocate upon return（某过程结束后，内存如何销毁？）</li></ul></li><li>Mechanisms all implemented with machine instructions（以上机理如何在机器代码中实现？）</li><li>x86-64 implementation of a procedure uses only those mechanisms required（示例）</li></ul><h3 id="5-2-x86-64-Stack"><a href="#5-2-x86-64-Stack" class="headerlink" title="5.2 x86-64 Stack"></a>5.2 x86-64 Stack</h3><blockquote><p>在此之前，先介绍 x86-64 architecture 的内存栈的机制；</p></blockquote><p>程序总是使用栈来<strong>管理过程中调用和返回状态</strong>，这主要是利用了栈 LIFO 的性质，这和调用-返回的思想很相似。因此它可以被用于：<strong>传递潜在信息、控制信息，分配 local 数据</strong>；</p><p>x86 的程序栈也存在于内存中，<strong>栈底位于 high numbered address（高位地址）</strong>，而栈顶位于 low numbered address；</p><p>前面说的 <strong><code>%rsp</code> 寄存器</strong>就是位于栈顶来管理这个过程的。<code>%rsp</code> 寄存器存储的是<strong>栈顶的地址</strong>，当有数据需要进栈时，<strong>通过递减栈指针来完成进栈操作</strong>；</p><p>之前还说过，<code>%rsp</code> 不应该被手动更改，那么有哪些方法能够使用这个栈呢？</p><p>第一个是 <code>pushq</code> 指令。</p><ul><li><p>语法：<code>pushq &lt;Src&gt;</code>;</p></li><li><p>作用：先从 <code>Src</code> 中取得操作数，再将 <code>%rsp</code> 值减 8（quadword，即 4 × 16 bits，64 bits，8 bytes），最后将从 <code>Src</code> 处获得的操作数写入到 <code>%rsp</code> 对应的 memory 地址中；</p><blockquote><p>⚠ 需要注意的点：<strong>这个栈是先移动指针再往里面写的</strong>；</p></blockquote></li><li><p><code>Src</code> 可以是直接量、寄存器名称、内存引用；</p></li></ul><p>与之对应的是 <code>popq</code> 指令。</p><ul><li><p>语法：<code>popq &lt;Dst&gt;</code>;</p></li><li><p>作用：先将 <code>%rsp</code> 值所代表的 memory 地址中的值读进，再将 <code>%rsp</code> 的值加 8，最后将读到的值写入 <code>Dst</code>;</p><blockquote><p>⚠ 需要注意的点：<strong>这个 <code>Dst</code> 只能是寄存器</strong>，因为前面说了，不允许从内存到内存，也不允许存入直接量；</p></blockquote></li></ul><h3 id="5-3-Calling-Conventions"><a href="#5-3-Calling-Conventions" class="headerlink" title="5.3 Calling Conventions"></a>5.3 Calling Conventions</h3><h4 id="5-3-1-Passing-Control"><a href="#5-3-1-Passing-Control" class="headerlink" title="5.3.1 Passing Control"></a>5.3.1 Passing Control</h4><p>以一个例子说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = mult2(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">    <span class="type">long</span> s = a * b;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是上面的源码经过汇编得到的结果（稍微删除了一些无关紧要的部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">    push%rbx</span><br><span class="line">    mov%rdx, %rbx</span><br><span class="line">    callq400550 &lt;mult2&gt;</span><br><span class="line">    mov%rax, (%rbx)</span><br><span class="line">    pop%rbx</span><br><span class="line">    retq</span><br><span class="line"></span><br><span class="line">mult2:</span><br><span class="line">    mov%rdi, %rax</span><br><span class="line">    imul%rsi, %rax</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure><p>这里注意一下 <strong>Passing Control</strong> 是怎么完成的：</p><ul><li><p>使用了程序栈来支持 procedure 的数据；</p></li><li><p>使用 <code>call &lt;LABEL&gt;</code> 指令来完成：</p><ol><li>把 <strong>return address</strong>（调用结束，返回时的位置）加入到栈中；</li><li>跳至 <code>LABEL</code> 执行；</li></ol></li><li><p>使用 <code>ret</code> 指令来完成：</p><ol><li>将栈中的地址弹出读取；</li><li>跳转到读取的地址；</li></ol><blockquote><p>有的时候会看到 <code>rep; ret</code> 的指令行，不用管，它和 <code>ret</code> 作用一样；</p></blockquote></li></ul><p>因此，Passing Control 的过程主要由两个特殊寄存器、一个栈支持；运行的动态如下（地址信息是虚拟的）：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/procedure_control_1.png" height="200px"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/procedure_control_2.png" height="200px"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/procedure_control_3.png" height="200px"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/procedure_control_4.png" height="200px"></p><h4 id="5-3-2-Passing-Data"><a href="#5-3-2-Passing-Data" class="headerlink" title="5.3.2 Passing Data"></a>5.3.2 Passing Data</h4><p>其实在此之前的前几章，我们已经看到了，汇编程序使用约定俗称的寄存器（“Caller-Saved Resgiter”）来完成函数参数、返回值的传递：</p><ul><li><p><code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rcx</code>、<code>%r8</code>、<code>%r9</code> 这都是 Caller-Saved Register，约定<strong>从前到后</strong>（顺序可以记下来）用来存放函数的六个参数，供被调用方使用；</p><blockquote><p>这里是 integer registers，如果参数不是整型 / 指针，那么会用<strong>浮点数寄存器</strong>来存放，以后说。</p><p>注：在 IA-32 时期，甚至所有参数都放在栈里，这会大大降低程序运行速度的。</p></blockquote></li><li><p>如果函数多于 6 个参数那么从第 7 个参数开始，将按顺序存放在栈里，仅需要才会分配栈（<strong>这个栈也用 <code>%rsp</code> 访问，一般每 8 bytes 一个参数，但是位于另一个栈帧，和调用方的栈帧互不干扰。具体情况见下一节</strong>）</p></li><li><p><code>%rax</code> 也是 Caller-Saved Register，约定是用于存放函数的返回值，供调用方读取；</p></li></ul><h4 id="5-3-3-Managing-Local-Data"><a href="#5-3-3-Managing-Local-Data" class="headerlink" title="5.3.3 Managing Local Data"></a>5.3.3 Managing Local Data</h4><p>早在 5.2 中就介绍了 x86 栈的作用之一就是<strong>分配 local 数据</strong>。那么调用和返回的功能之一就是可以对函数进行嵌套调用。</p><p>此外，我们将栈上<strong>用于特定 call 的每个内存块称为栈帧（stack frame）</strong>，它是特定 procedure、特定 instance 的栈帧。单线程程序共用一个栈，因此通过栈帧来管理各个函数的 Local data；</p><p>栈帧的结构如何？是如何管理的？其中究竟放了些什么？</p><ul><li><p>Structure：大家在 C++ 程序设计课程上应该接触过 “变量作用域”，这个时候应该强调了不同函数的局部变量会存在它的栈帧中。所以可以想象，栈帧就是一段一段堆叠在 stack 上的片段，每个未返回的函数独享一个栈帧；</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/stack_structure.png" height="300px"></p><p><strong>并且 <code>%rsp</code> 就在之前说的栈顶，还有一个普通寄存器 <code>%rbp</code> 可以用来存放两个栈帧交界的位置（只有在一些特殊情况下编译器才会使用它，平时会当作普通寄存器使用）</strong>；</p><p>所以大多数情况下，没有 <code>%rbp</code> 指示，汇编程序员甚至不知道下一层栈帧在哪里，<strong>这只能靠代码自身管理（大部分情况下编译器知道需要分配多少栈帧、销毁多少栈帧），并且正确释放栈帧（本节的一个例子会演示代码如何自身管理栈帧）</strong>；</p><blockquote><p>编译器不知道应该分配多少栈帧的特殊情况：<strong>分配可变大小的数组 / 内存缓冲区</strong> 等情况，这时编译器会无奈选择使用 <code>%rbp</code> 管理；</p></blockquote><p>也正因如此，递归所需的所有基础结构都由栈的原则所保证；</p><p>对于 <strong>x86-64 Linux</strong> 这一特定机器 + 操作系统而言，栈帧的<strong>详细结构</strong>应该是这样的：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/stack_structure_detail.png" height="350px"></p><ul><li><p>之前在 <strong>Passing Control</strong> 中提到 <code>call</code> 指令压入的返回地址存在 Caller Frame 的最上层，下面压着 <strong>Caller 传给 Callee 的参数</strong>（Arguments 7+）；</p></li><li><p>在两个栈帧之间有空间为可选的旧 <code>%rbp</code>（上一层栈帧的 <code>%rdp</code>）空间，当前的 <code>%rbp</code> 就指向这里（如果有的话）；</p></li><li><p>在当前 Callee Frame 中，最底层是 <strong>Callee-Saved Register</strong>（保存 Temporaries）和内存中的<strong>局部变量</strong>；向上就是在 <strong>Pass Data</strong> 中提到的<strong>多于 6 个的传入参数</strong>存放的位置。</p></li><li><p><strong>之前说的 “代码自身管理的方式” 就是在函数返回前将 <code>%rsp</code> 回到一开始的地方（上一层栈帧）</strong>；</p></li></ul></li><li><p>Management：为正在执行、没有返回的函数保留一个栈帧</p><ul><li>Space allocated <strong>when enter procedure</strong><ul><li>“Set-up” code</li><li>Include push by <code>call</code> instruction</li></ul></li><li>Deallocated <strong>when return</strong><ul><li>“Finish” code</li><li>Include pop by <code>ret</code> instruction</li></ul></li></ul></li><li><p>Contents</p><ul><li>Return information</li><li>Local storage（only if necessary）</li><li>Temporary space（only if necessary）</li></ul></li></ul><hr><p>为了演示这一部分，下面列举一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">incr</span><span class="params">(<span class="type">long</span> *p, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = *p;</span><br><span class="line">    <span class="type">long</span> y = x + val;</span><br><span class="line">    *p = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">call_incr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> v1 = <span class="number">15213</span>;</span><br><span class="line">    <span class="type">long</span> v2 = incr(&amp;v1, <span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">incr:</span><br><span class="line">    movq(%rdi), %rax</span><br><span class="line">    addq%rax, %rsi</span><br><span class="line">    movq%rsi, (%rdi)</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">call_incr:</span><br><span class="line">    subq$16, %rsp</span><br><span class="line">    movq$15213, 8(%rsp)</span><br><span class="line">    movl$3000, %esi</span><br><span class="line">    leaq8(%rsp), %rdi</span><br><span class="line">    callincr</span><br><span class="line">    addq8(%rsp), %rax</span><br><span class="line">    addq$16, %rsp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>其实函数 <code>incr</code> 的汇编代码很简单，重点不在这，而是调用它的函数 <code>call_incr</code> 以及过程中的处理情况。我们将一步步分析其中的情况。</p><p>首先，当上层的 caller 刚刚调用 <code>call call_incr</code> 指令、还没有为 <code>call_incr</code> 分配栈帧时，栈中的情况如下图所示：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/procedure_example_1.png" height="150px"></p><p>此时栈顶仍然是上层 caller 的 <code>call</code> 指令刚压入的 return address；随后机器读取 <code>%rip</code> 中保存的 <code>call_incr</code> 的地址开始执行 <code>call_incr</code> 函数；</p><p>现在请注意上面的 <code>call_incr</code> 汇编代码。</p><p>第一步是将 <code>%rsp</code> 的值减去 16，这意味着一口气在栈中分配了 16 bytes 空间，作为 <code>call_incr</code> 的栈帧（此时 <code>%rsp</code> 理所当然在最上层）；</p><blockquote><p>程序一般在栈上分配的空间会比实际需求多一点，这是因为有一些内部的约定，要求保持内存对齐，例如汇编中典型的 <code>.align</code> 伪指令。这个分配的值是由编译器计算得出的。</p></blockquote><p>第二步向 <code>%rsp + 8</code> 的 memory 地址写入常数 15213，这就相当于向栈顶的下面 8 bytes 的位置写入该常数；现在栈中的情况如下图所示：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/procedure_example_2.png" height="150px"></p><p>以上的第 1~2 步对应着源码的 <code>long v1 = 15213;</code> 这一步。</p><p>第三步将 <code>%rsi</code>（<code>%esi</code>）写入 32-bit 的 3000 整型（还记得之前说的特性吗？高 32-bit 会自动被置 0），因为 <code>%rsi</code> 将来会作为调用函数的第二参数；</p><p>第四步还记得吗？找到 <code>%rsp + 8</code> 作为地址对应的 memory 引用（这里就是之前栈中存放常数 15213 的位置）<strong>的地址</strong>（也就是存放 15213 的地址）赋给 <code>%rdi</code>，这就相当于 <code>&amp;v1</code> 给了调用函数的第一参数；</p><p>上面的第 3~4 步对应源码中的 <code>long v2 = incr(&amp;v1, 3000);</code> 的 <strong>Passing Data 部分</strong>；</p><p>而在过程中大家发现，代码是不是自身就管理了 <code>%rsp</code> 的位置和栈的分配？</p><p>在完成函数调用的 Passing Data 部分，我们继续进行 <code>long v2 = incr(&amp;v1, 3000);</code> 这一步的 <strong>Passing Control 部分</strong>：</p><p>接下来汇编调用了 <code>call incr</code>，干了 3 件事：<code>%rsp</code> 减 8，存储 return address（这里的是 <code>call incr</code> 下一行指令的地址），并且向 <code>%rip</code> 写入 <code>incr</code> 的起始地址。</p><p>于是程序进入了 <code>incr</code> 函数，这比较简单，其中的内存分配、变量设置就不说了。直接跳到 <code>incr</code> 函数的 <code>ret</code> 指令，此时经过内部的代码控制，<code>%rsp</code> 应该回到了之前 <code>call_incr</code> 函数栈帧的顶部（存放 return address 的位置）。于是 <code>ret</code> 也做了 3 件事：将 return address 取出来，<code>%rsp</code> 加 8，并向 <code>%rip</code> 写入刚刚取得的地址——也就是 <code>call_incr</code> 函数中 <code>call incr</code> 指令的下一行。</p><p>此时，栈的情况如下图所示（18213 是因为 <code>incr</code> 函数修改了 <code>long *p</code> 参数，还有，别搞混了，这个图里的 return address 是调用 <code>call_incr</code> 的上层 caller 的栈帧中的东西）：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/procedure_example_3.png" height="150px"></p><p>程序进入 <code>call_incr</code> 汇编的最后两步：把 <code>%rax</code>（<code>incr</code> 函数返回值，也就是 <code>v2</code>）加上 <code>%rsp + 8</code> 地址上的内容（18213，也就是新的 <code>v1</code>）作为函数返回值，<strong>并且把 <code>%rsp</code> 加上 16，释放了之前分配给 <code>call_incr</code> 函数的栈帧</strong>（所以你看看，编译器是不是知道之前分配了多少栈帧空间？是不是不需要 <code>%rbp</code> 的指示？）。函数到此结束，栈中的情况如下：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/procedure_example_4.png" height="100px"></p><p>最后的一句 <code>ret</code> 会读取上层 caller 放的 return address，将 <code>%rsp</code> 减 8，并且将 <code>%rip</code> 写入 return address，下一步程序将回到调用 <code>call_incr</code> 的上层 caller 的函数体中。栈的情况如下：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/procedure_example_5.png" height="100px"></p><hr><h3 id="5-4-Register-Saving-Conventions"><a href="#5-4-Register-Saving-Conventions" class="headerlink" title="5.4 Register Saving Conventions"></a>5.4 Register Saving Conventions</h3><p>之前无论是 5.3.2 讲述传递数据的方法，还是介绍 ABI 的约定，又或是早在 3.3.1 中介绍寄存器的使用，我们无数次提及 register 约定俗成的用法。为了加深印象、补充更多内容，我们这里再梳理一遍。</p><p>传递数据的时候，调用方（caller）和被调用方（callee）共同使用这所有的 16 个寄存器。那么，怎么保证 “在 caller 中保存特定数据的某些寄存器，在调用 callee 之后，callee 没有改变这些寄存器，并且还能看作原来的值，继续使用” 呢？</p><p>这就是约定 Callee-Saved 和 Caller-Saved Register 的作用了。它们的定义是：</p><ul><li><p>Caller-Saved: Caller saves temporaries values in its frame before the call <strong>but can be modified by procedures</strong>;</p></li><li><p>Callee-Saved: Callee saves temporaries values in its frame before using <strong>and restore them before returning to caller</strong>;</p><p><strong>（所以如果程序在某个 procedure 中使用了 <code>%rbp</code> 作为普通寄存器，那么能够保证这个函数 return 前 <code>%rbp</code> 会恢复到上一层的值，不会影响把 <code>%rbp</code> 当作 base pointer 使用的函数）</strong></p></li></ul><blockquote><p>回忆一下它们分别有哪些？</p></blockquote><p>所以，如果 caller 真的想要寄存器中的某些值不会被 callee 修改，在调用函数后仍然能使用，那么就应该把值放在 callee-saved register 当中。</p><p>此外，ABI 还规定了，callee 在返回前，需要把 callee-saved register 中的值恢复到原来的样子。</p><p>此外，一个介于特殊和普通之间的寄存器需要强调一下——<code>%rbp</code>，由于它有时作为分隔栈帧的 base pointer，所以如果有 callee 想要看作普通寄存器来使用它，那么需要在 return 前恢复到原来的状态。</p><blockquote><p>考虑一个问题，为什么 caller-saved register 一般没有要求 restore？</p><p>因为首先， caller-saved register 中保存函数参数的寄存器就是为了给 callee 读取的，所以调用前 caller 会设置这些寄存器的值，没有必要保持数据；另外如果 caller 真的想在调用之后使用这些值，那么可以<strong>把它的值放在自己的 callee-saved register 中，进而，因为 caller 自己也会是 callee，所以在 caller return 前也要恢复这个 callee-saved register</strong>（main 函数除外）；</p></blockquote><hr><p>那么这些约定在一般的代码中是如何体现的呢？下面以之前的 <code>incr</code> 函数为例子，我们加入一个 <code>call_incr2</code> 函数来展示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incr 函数见 5.3.3 的例子</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">call_incr2</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> v1 = <span class="number">15213</span>;</span><br><span class="line">    <span class="type">long</span> v2 = incr(&amp;v1, <span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> x + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">call_incr2:</span><br><span class="line">    pushq%rbx</span><br><span class="line">    subq$16, %rsp</span><br><span class="line">    movq%rdi, %rbx</span><br><span class="line">    movq$15213, 8(%rsp)</span><br><span class="line">    movl$3000, %esi</span><br><span class="line">    leaq8(%rsp), %rdi</span><br><span class="line">    callincr</span><br><span class="line">    addq%rbx, %rax</span><br><span class="line">    addq$16, %rsp</span><br><span class="line">    popq%rbx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>在上层 caller 进入 <code>call_incr2</code> 的第一件事就是把 <code>%rbx</code> 的值放到 <code>call_incr2</code> 的栈帧中。这是为什么？</p><p>原来，这个 <code>call_incr2</code> 函数有一个参数 <code>long x</code>，一开始存在 <code>%rdi</code> 中。但是，<code>call_incr2</code> 想要调用 <code>incr</code> 函数，后者要求两个参数，意味着 callee 会用到 <code>%rdi</code> 或更改。而在 <code>call_incr2</code> 的最后，<code>return x + v2;</code> 说明了等会还要用到现在 <code>%rdi</code> 中的值 x。所以，<code>call_incr2</code> 为了能够继续使用 x 这个值，需要将 x 存到 callee-saved register 中，<strong>因为调用 <code>incr</code> 之后，无论如何 <code>incr</code> 会将 callee-saved register 恢复到原来的数据的！</strong> 而在此之前，为了能够将这里使用的 callee-saved register 在返回前恢复到上一层调用前的状态，需要将原来的数据存在栈中。</p><blockquote><p>所以现在的情况是，</p><p>① caller 为了保留 caller-saved register（<code>%rdi</code>）的数据（因为要设置新的值给下一层 callee 来 passing data）所以要把 <code>%rdi</code> 数据放到 callee-saved register 中，这样调用后不变 ；</p><p>② 想要改变 callee-saved register，就需要保存之前的值，以保证上一层调用方在其中的值不变，而这个 callee-saved register 原先的值就放到了当前 caller 的栈帧中。</p><p><strong>考虑一个问题，为什么当前函数不把想要保存的数据直接保存在栈中，而是保存在 callee-saved register 中，完事还要为这个 callee-saved register 原先的值保存在自己的栈帧中？</strong></p><p>这是因为，直接保存在栈里不方便。如果有多个需要保存的数据，而且都放在栈里，那么读取方式、读取效率（可能会读很多次）都不佳；而且就没有必要设置 callee-saved register 了。</p><p>相反，如果保存在 callee-saved register 中，那么 caller 被调用后一开始统一保存上一层的 callee-saved register 的值，caller 返回前统一恢复上一层的 callee-saved register 的值，中间 caller 还能自由使用这些 callee-saved register，多次使用速度快，并且不用担心调用下一层函数会影响其中的值，岂不美哉！</p></blockquote><p>因此，在 <code>call_incr2</code> 调用 <code>incr</code> 之前，栈的情况如下图所示：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/procedure_example2_1.png" height="150px"></p><hr><p>总结：<strong>什么时候栈上会出现 Saved-Register 数据？答：当 caller 需要修改 callee-saved register 来保存某些值的时候，caller 会把数据保存到它的栈帧上。</strong>仅此一种情况。</p><h3 id="5-5-Illustration-of-Recursion"><a href="#5-5-Illustration-of-Recursion" class="headerlink" title="5.5 Illustration of Recursion"></a>5.5 Illustration of Recursion</h3><blockquote><p>本节将详细阐释 “递归” 这个技术在汇编层面的样貌。你会发现，因为有了之前所有的 mechanisms 的支持，C 编译器编译递归函数会和普通函数一样简单。</p></blockquote><p>以一个例子开始，这个 <code>pcount_r</code> 函数就是之前 “计算二进制数中有几个 1”（例子在 4.3）的递归版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Recursive popcount */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">pcount_r</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (x &amp; <span class="number">1</span>) + pcount_r(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个 trick，就是参数是 unsigned long 类型，这是为了让 <code>x &gt;&gt; 1</code> 运算是<strong>逻辑右移</strong>，千万不能用 signed 的类型，因为 <code>x &gt;&gt; 1</code> 是算数右移，所以对于负数而言永远不会停下；</p><p>下面是对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pcount_r:</span><br><span class="line">    movl$0, %eax</span><br><span class="line">    testq%rdi, %rdi</span><br><span class="line">    je.L6</span><br><span class="line">    pushq%rbx</span><br><span class="line">    movq%rdi, %rbx</span><br><span class="line">    andl$1, %ebx</span><br><span class="line">    shrq%rdi</span><br><span class="line">    callpcount_r</span><br><span class="line">    addq%rbx, %rax</span><br><span class="line">    popq%rbx</span><br><span class="line">.L6:</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure><p>你会发现递归版本的源码编译出的汇编代码可能稍微比之前迭代循环版本（loop）的汇编代码更长，这是因为递归版本需要额外管理栈的情况。</p><p>学完了前面几章节，你会发现这些代码就比较好懂了：</p><p>第一步将 <code>%rax</code>（<code>%eax</code>）置零，因为等会可能要 return 0；然后第二步按照 <code>x == 0</code> 的是真是假的答案来设置 condition codes，交由第三步判断并跳转。这是之前的 General Conditional Expression 的翻译方法；</p><p>接下来，将 <code>%rbx</code> 这个 callee-saved register 原来的值备份到当前栈帧中，是因为之后要用这个寄存器保存参数 x；果不其然，下一步就是把 <code>%rdi</code>（x）的值复制到 <code>%rbx</code> 中。</p><p>接下来用到 x 的地方，除了传给下一层 callee 的第一参数，就只有 <code>x &amp; 1</code> 了，所以直接在 <code>%rbx</code> 上与 1 按位且。下一步也直接在 <code>%rdi</code> 上逻辑右移 1 个单位，这就是传给下一层 callee 的第一参数（<code>x &gt;&gt; 1</code>）;</p><p>准备好 passing data 后，进行 passing control，调用 <code>call pcount_r</code> 进行跳转递归。</p><p>如果递归结束，那么紧接着就是把 <code>(x &amp; 1)</code>（即 <code>%rbx</code> 中的值）加到 callee 的结果（<code>%rax</code>）中，得到本函数的结果。最后别忘了在返回前从当前栈帧中恢复 callee-saved register <code>%rbx</code>，函数结束。</p><p>举完这个例子你会发现，这就是前几章所提到所有技巧的综合，它们使用了同一个约定——参数怎么传、可以用哪些寄存器、寄存器怎么用（还有是否要恢复）、如何参与计算等等。这个约定防止了不同函数在调用时相互摧毁寄存器中重要的值的异常情况。总之按照上面的方法使用寄存器，可以让生活更美好！</p><blockquote><p>补充一句，有些函数不依赖栈的结构来完成上述的机制，它们会采用堆或者其他数据结构来完成（例如 SML）。</p></blockquote><p>说了这么多，只有自己上手实践、自己亲自编译、调试这些代码，才能体会到各个部分、tricks、mechanisms 组合起来发挥的作用。</p><h3 id="5-5-Summary-for-Chapter-5"><a href="#5-5-Summary-for-Chapter-5" class="headerlink" title="5.5 Summary for Chapter 5"></a>5.5 Summary for Chapter 5</h3><p>本章的内容也是相当之多。为了进一步加深对于汇编 procedure 的认识，我们现在总结一下本章接触到的内容。</p><p>在本章开头，我们了解一种规范（接口）被称为 ABI，主要围绕 Linux ABI 展开介绍。ABI 规定了所有二进制程序、操作系统各个组件、编译器对于管理机器上的资源的使用规则，例如寄存器使用的场合和管理方法等等，这在之前的章节中也或多或少的提到过。</p><p>想要了解程序运行的总体 procedure，就不得不回答 3 个问题：<strong>程序是如何切换运行控制权的</strong>，<strong>程序如何传递数据的</strong>，还有<strong>程序如何在运行中管理 Memory 内存的</strong>；</p><p>为了搞清以上的问题，我们先了解了 x86 架构下的系统栈的简单结构。因为 C/C++ 是依赖于栈来管理程序上下文的语言，并且根据栈 LIFO 的原则，可以被用于：<strong>传递潜在信息、控制信息，分配 local 数据</strong>。正因如此，栈可以胜任<strong>管理过程中调用和返回状态</strong>的任务，也能隔离各个 procedure 示例之间的数据，为递归提供了坚实高效的结构基础。</p><p>x86 的栈需要注意的点有 3 个：</p><ul><li>栈就是在<strong>内存中的</strong>一段连续的数据结构，栈顶位于 low numbered address，栈底位于 high numbered address（头脑里有张图）；</li><li>栈顶指针由 <strong><code>%rsp</code></strong> 保存，一般不能手动修改，指向最上层被使用的空间，这意味着<strong>要先减小指针，再放入数据</strong>（或先取出数据，再增大指针）；</li><li>想要管理栈中的数据，依靠 <code>pushq</code> 和 <code>popq</code> 这两条指令，这两条指令的参数要求也有重大区别，可以思考一下为什么；</li></ul><p>随后考虑<strong>程序控制权切换的问题</strong>（Passing Control），具体表现就是<strong>调用时 caller 如何跳转到 callee、如何从 callee 返回到 caller</strong>。通过分析，passing control 由 3 个方面实现：</p><ul><li>系统<strong>栈</strong>提供数据结构存储层面的支持；</li><li>指令 <code>call &lt;LABLE&gt;</code> 通过：<strong>向栈中添加 return address</strong>、<strong>改变 <code>%rip</code> 的值来跳转至 callee</strong> 这两大工作来完成 caller 至 callee 的跳转；</li><li>指令 <code>ret</code> 通过：<strong>从栈中取出 return address</strong>、<strong>改变 <code>%rip</code> 的值来跳回 caller</strong> 这两大工作完成 callee 重新返回 caller 的控制流程。</li></ul><p>第二个点就是<strong>程序数据传输问题</strong>（Passing Data），在单线程程序中具体表现为 <strong>caller 如何向 callee 传递参数</strong>、<strong>callee 如何给 caller 返回值</strong>。在前几章的铺垫下，我们进一步记住了各个整型寄存器在 procedure 及其切换时的约定行为，例如 Caller-Saved / Callee-Saved、传入的函数参数由哪个寄存器  / 给出、函数的返回值由哪个寄存器传输。</p><p>前两个问题相对好解决，不过对于 <strong>程序如何在运行中管理 Memory 内存</strong> 这一部分而言，具体表现在进入 procedure 前如何为其分配空间、结束 procedure 前如何释放空间，需要较为详细地了解 x86 栈和<strong>栈帧</strong>的基本结构。对于 x86-64 Linux 而言，一个程序栈在<strong>当前函数实例</strong>中的栈帧从栈底到栈顶应该分别是：</p><ul><li>old <code>%rbp</code>（上一层 base pointer，如果本层也使用 <code>%rbp</code> 做 base pointer 的话，就指向此位置）；</li><li>上层 callee-saved register 备份值（Saved-Register）、local variables（函数局部变量）；</li><li>本函数作为 callee 时传入的超过 6 个的参数存放位置（依次，如果有的话）；</li><li>return address（如果本层函数是 caller，并且正好运行到 <code>call</code> 指令结束时）；</li></ul><p>每个函数结束后能否完全释放栈帧并回到原位、调用其他函数时能否准确分配足够的空间，则<strong>依赖代码的自身管理</strong>。</p><p>搞清了总体 procedure 的样貌，我们进一步讨论了各个寄存器的细节层面的管理约定。包括以下问题：</p><ul><li>Caller-Saved Register 和 Callee-Saved Register 各自有哪些种类和定义；</li><li>什么时候使用 Caller/Callee-Saved Register，在使用前后应该做哪些处理工作；</li><li>为什么要使用 Caller/Callee-Saved Register，栈中的 “Save-Register” 数据是怎么回事。</li></ul><p>到了本章结束，我们已经能从大致轮廓上认识一个程序运行的 procedure，仅限于整数、长整数、指针的数据传递的工作。</p><p>更多的细节，例如之前提到的<strong>浮点数如何传递、保存（浮点寄存器的行为）</strong>，<strong>聚合数据结构在汇编层面如何实现</strong>，等问题，会在下一章进行介绍。</p><h2 id="Chapter-6-Machine-Level-Programming-Ⅳ-Data"><a href="#Chapter-6-Machine-Level-Programming-Ⅳ-Data" class="headerlink" title="Chapter 6. Machine Level Programming Ⅳ - Data"></a>Chapter 6. Machine Level Programming Ⅳ - Data</h2><p>之前我们所见到的程序都是操纵正数 / 长整数 / 指针，它们都是<strong>标量整型数据</strong>。本章将讨论浮点寄存器的情形和聚合数据结构在汇编代码中的实现。</p><h3 id="6-1-Arrays-in-Assembly"><a href="#6-1-Arrays-in-Assembly" class="headerlink" title="6.1 Arrays in Assembly"></a>6.1 Arrays in Assembly</h3><h4 id="6-1-1-Array-Access-Normal-Array"><a href="#6-1-1-Array-Access-Normal-Array" class="headerlink" title="6.1.1 Array Access: Normal Array"></a>6.1.1 Array Access: Normal Array</h4><p>众所周知，数组在 C/C++ 中声明的语法为 <code>T A[L];</code>，表示 Array of data type <code>T</code> and length <code>L</code>；</p><p>这说明了 2 件事：</p><ol><li>数组应该在内存中分配的方式：<strong>Contiguously allocated region of <code>L * sizeof(T)</code> bytes in memory</strong>;</li><li>identifier <code>A</code> 可以被用作<strong>指向数组开头位置的指针（类型 <code>T*</code>）</strong>；</li></ol><blockquote><p>下面的方法都是合理的，请试着分析表达式的含义（<code>val</code> 的类型是 <code>int*</code>）：</p><p><code>val[4]</code>、<code>val</code>、<code>val + 1</code>、<code>&amp;val[2]</code>、<code>*(val + 1)</code>、<code>*val + 1</code>;</p><p>提示：对于指针类型 <code>T*</code> 的增、减运算而言，单位 1 会是 <strong><code>sizeof(T)</code></strong>，也就是说，对这个指针增加 1，那么指针的值实际增加 <code>sizeof(T)</code>；</p><p><strong>补充 C/C++ 基础-1</strong>：指针和数组变量的区别之一是，改变数组变量 <code>val</code> 不是正确的，因为 <code>val</code> 是指针常量；</p></blockquote><hr><p>现在看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZLEN 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> zip_dig[ZLEN];</span><br><span class="line"></span><br><span class="line">zip_dig cmu = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">zip_dig mit = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">zip_dig ucb = &#123; <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>一些编程建议：① 不要将常数随便写死在程序的各个角落，这被称为 magic number，不但不利于阅读，也不利于维护；② 对于 C/C++ 中复杂的数据类型的定义，建议使用 <code>typedef</code> 关键字，这样可以提升可读性；</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_digit</span><span class="params">(zip_dig z, <span class="type">int</span> digit)</span> &#123; <span class="keyword">return</span> z[digit]; &#125;</span><br></pre></td></tr></table></figure><p>上面这个函数的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_digit:</span><br><span class="line">    movl(%rdi, %rsi, 4), %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>由于数组标识符也是指针，因此传入的方式和之前的相同。上面的指令含义是找到地址为 <code>%rdi + 4 * %rsi</code> 的 memory 引用，并将这里的值赋给 <code>%rax</code> 的 low-order 32-bit（<code>%eax</code>）;</p><p>4  就是编译器自己加上的对于 <code>int</code> 类型大小的缩放因子。</p><p>再来一段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zincr</span><span class="params">(zig_dig z)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ZLEN; i++)</span><br><span class="line">        z[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zincr:</span><br><span class="line">    movl$0, %eax</span><br><span class="line">    jmp.L3</span><br><span class="line">.L4</span><br><span class="line">    addl$1, (%rdi, %rax, 4)</span><br><span class="line">    addq$1, %rax</span><br><span class="line">.L3</span><br><span class="line">    cmpq$4, %rax</span><br><span class="line">    jbe.L4</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure><p>这里汇编代码对 for 循环的处理是转化为 while 循环并采用 “jump to middle” translation；</p><p>首先初始化部分将 <code>%rax</code> 置零作为存放 i 的寄存器，接着跳至 <code>.L3</code> 判断部分；</p><p><code>.L3</code> 判断部分将 <code>%rax</code>（i）和 4 比较，只有 unsigned <code>i ≤ 4</code>（<code>CF | ZF</code>）时才进入 <code>.L4</code> 循环；</p><p>在 <code>.L4</code> 循环中，先将地址为 <code>%rdi + 4 * %rax</code> 的 memory 引用处的数据加 1，并且将 <code>%rax</code> 中的数据加 1（<code>i++</code>）；</p><hr><blockquote><p><strong>补充 C/C++ 基础-2</strong>：为了掌握 C/C++ 数组的核心思想，你必须能够理解以下的声明的含义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A1[<span class="number">3</span>];        <span class="comment">// 一个长度为 3 的整型数组</span></span><br><span class="line"><span class="type">int</span> *A2[<span class="number">3</span>];        <span class="comment">// 一个长度为 3 的整型指针 构成的数组</span></span><br><span class="line"><span class="type">int</span> (*A3)[<span class="number">3</span>];    <span class="comment">// 一个指向 长度为 3 的整型数组 的指针</span></span><br></pre></td></tr></table></figure><p><strong>提示：C/C++ 阅读类型声明的关键是从内向外读，这条道理不仅适用于上面的 <code>int (*A3)[3]</code>，还适用于函数指针等复杂类型的阅读</strong>。例如 <code>int**(*)(int*, int)</code> 是指向参数表为 <code>(int*, int)</code>、返回值类型为 <code>int**</code> 的函数的指针。</p><p><strong>补充 C/C++ 基础-3</strong>：数组变量和指针的区别之一是，在声明数组时程序不仅会为数组标识符这个指针来分配空间，而且会为数组中的所有元素分配空间；但指针只会为自身分配空间。这就导致<strong>二者调用 <code>sizeof</code> 的大小是不同的</strong>；例如 <code>sizeof(A3) == 8</code>，<code>sizeof(*A3) == 12</code>，<code>sizeof(**A3) == 4</code>;</p><p>⚠ 另外，如果想判断什么类型的指针取 <code>*</code> 后会导致野指针 / 空指针引用错误，应该想想<strong>在一开始声明的时候，程序有没有为其自动分配空间</strong>。例如上面的例子，如果使用 <code>*A3</code> 则可能出现空指针引用错误，但 <code>*A2</code> 就不会。</p></blockquote><p>为什么要 “补充 C/C++ 基础 1~3” ？<strong>因为只有清楚了解程序的源码表示的含义，才能去关注、正确认识编译后的代码</strong>。</p><h4 id="6-1-2-Array-Access-Two-Dimension-Array"><a href="#6-1-2-Array-Access-Two-Dimension-Array" class="headerlink" title="6.1.2 Array Access: Two Dimension Array"></a>6.1.2 Array Access: Two Dimension Array</h4><blockquote><p>⚠ 本节讨论的 array 规模全部是 <code>constexpr</code>（编译前确定）；</p></blockquote><p>这个时候我们再看二维数组的真实含义。</p><p>⚠ <strong>注意：由上面的讨论可知，一共有 2 类二维数组，尽管源码的使用上是一样的，但汇编层面完全不同！！！</strong></p><ul><li><p>Nested Array</p><ul><li><p>在 C/C++ 中，一种二维数组的声明语法为 <code>T A[R][C];</code>，其实是 <code>T[C] A[R];</code> 的另一种写法，表示 <strong><code>A</code> 是一个包含 <code>R</code> 个元素的数组，其元素是包含 <code>C</code> 个元素的数组</strong>。</p></li><li><p>这种数组被称为 <strong>Nested array</strong>，特点是二维数组中<strong>所有元素的空间在声明时都被自动分配了，更重要的是，它们是连续的</strong>。</p></li><li><p>另一个需要关注的点是，<strong>Nested array 是 “Row-Major” 的，即行优先，第一个索引应该指定行，并且分配空间、存储时，连续的部分也是行，又称 Row Vectors</strong>。</p></li><li><p>Nested Array 的每个行向量 <code>A[i]</code> 开始的地址是 <strong><code>A + i * C * sizeof(T)</code></strong>，每个元素 <code>A[i][j]</code> 的地址是 <strong><code>A + (i * C + j) * sizeof(T)</code></strong>（由 <code>A + i * C * sizeof(T) + j * sizeof(T)</code> 化简得来）;</p></li></ul></li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/nested_array.png" height="200px"></p><ul><li>Multi-Level Array<ul><li>另一种二维数组的声明方式是 <code>T* A[R];</code>，随后在初始化中（在栈中）/ new 上（在堆中）数组的各个元素。</li><li>这种数组称为 <strong>Multi-level array</strong>，在声明时，<strong>仅为每个一级元素（<code>int*</code>）进行了空间分配</strong>。</li><li><strong>事实上，这种声明的数组每一行的存储位置可以不是连在一起的，甚至每一行的元素可以不同</strong>！因此每个元素的地址计算应该<strong>取决于 <code>A</code> 中每个元素的值</strong>！没法通过标识符 <code>A</code> 直接取得。</li></ul></li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/multi_level_array.png" height="200px"></p><hr><p>我们继续利用之前 <code>zip_dig</code> 的例子，我们分别声明两种类型的二维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PCOUNT 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UCOUNT 3</span></span><br><span class="line"></span><br><span class="line">zip_dig pgh[PCOUNT] = &#123;                    <span class="comment">// Nested array</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> *univ[UCOUNT] = &#123; mit, cmu, ucb &#125;;    <span class="comment">// Multi-level array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里分别是使用它们的两个函数</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">get_pgh_zip</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="keyword">return</span> pgh[index]; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_univ_digit</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> digit)</span> &#123; <span class="keyword">return</span> univ[index][digit]; &#125;</span><br></pre></td></tr></table></figure><p>这时对应函数的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">get_pgh_zip:</span><br><span class="line">    leaq(%rdi,%rdi,4), %rax</span><br><span class="line">    leaqpgh(,%rax,4), %rax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">get_univ_digit:</span><br><span class="line">    salq$2, %rsi</span><br><span class="line">    addquniv(,%rdi,8), %rsi</span><br><span class="line">    movl(%rsi), %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>注意到，这里使用的 <code>pgh</code>、 <code>univ</code> 是全局变量，不存储在栈中，意味着在汇编代码中<strong>可以直接使用变量名称来表示全局变量</strong>。有些时候，编译器输出的汇编代码对于全局变量的处理中也会<strong>直接使用地址</strong>。</p><p>注意！这时候两个数组的索引方式就有差别了。</p><p>对于使用 Nested array 的函数 <code>get_pgh_zip</code> 而言，第一步是相当于进行算术计算 <code>%rax = 5 * %rdi</code>，第二步还是相当于算术计算 <code>%rax = pgh + 4 * %rax</code>。这两步的真实含义是：<code>%rax = pgh + sizeof(int) * 5 * index</code>，这里的 5 就是之前提到的<strong>每列列宽</strong>；</p><p>它可以表示：<code>&amp;Memory[pgh + 5 * sizeof(int) * index]</code>，取得其中的指针；</p><p>对于使用 Multi-level array 的函数 <code>get_univ_digit</code> 而言，<strong>事情完全不一样！</strong></p><p>第一步将 <code>%rsi</code> 的值（<code>digit</code>）乘以 4，没什么好说的；</p><p>第二步注意，这里不是 <code>leaq</code> 而是 <code>addq</code>，说明这里先取得 <code>univ + 8 * %rdi</code> 中的值，并把它看作地址，找到 memory 中该地址对应的引用值。最后把 <code>%rsi</code> 加上引用值;</p><p>这两步<strong>没法写出真实含义的表达式，因为涉及 memory 取值。但可以表示为</strong>：</p><p><code>Memory[Memory[univ + sizeof(int*) * index] + sizeof(int) * digit]</code>;</p><p>最后 <code>get_univ_digit</code> 才把计算好的地址使用 Simple Memory Addressing Mode 取出值，并赋给 <code>%rax</code>（<code>%eax</code>）;</p><hr><p>对比上面两种二维数组的汇编操作，这说明了不同的结构决定了不同的计算方法。前者只需要对<strong>数组标识符</strong>和<strong>索引</strong>进行算术计算，就能得到地址；而后者必须先由<strong>数组标识符</strong>和<strong>行参数</strong>找到一级元素内容，然后用<strong>一级元素内容</strong>和<strong>列索引</strong>才能定位具体的元素位置。</p><h4 id="6-1-3-Array-Access-M-×-N-Matrix"><a href="#6-1-3-Array-Access-M-×-N-Matrix" class="headerlink" title="6.1.3 Array Access: M × N Matrix"></a>6.1.3 Array Access: M × N Matrix</h4><ul><li>对于恒定（constexpr）规模、声明时已分配内存的矩阵而言，就是上一节说的 Nested array；</li><li>对于作为参数传入的 Nested array（未知规模，但空间连续），则必须进行乘法计算（开销较大）结合其他算术计算得出位置；</li></ul><p>总而言之，访问数组的思路就是之前说的 Multi-level array 和 Nested array 两类。其他情况可以同理思考。</p><h3 id="6-2-Structures-in-Assembly"><a href="#6-2-Structures-in-Assembly" class="headerlink" title="6.2 Structures in Assembly"></a>6.2 Structures in Assembly</h3><h4 id="6-2-1-Structure-Representation"><a href="#6-2-1-Structure-Representation" class="headerlink" title="6.2.1 Structure Representation"></a>6.2.1 Structure Representation</h4><p>关于结构体的存储和表示，有下面的 3 条简单规则：</p><ul><li><p>结构体本身在内存中的表示是<strong>连续的</strong>，并且 “big enough to hold all of the fields”；</p></li><li><p>结构体中各个字段在内存中的排布顺序<strong>严格</strong>按照源码中的<strong>声明顺序</strong>；</p></li><li><p><strong>编译器来决定所有字段存储的空间和字节偏移、对齐情况</strong>（相对结构体地址的位置）；</p><blockquote><p>整个过程对汇编层面透明，汇编代码是看不出来这里定义了一个结构体的，只能看到一系列变量排列在内存上；</p></blockquote></li></ul><h4 id="6-2-2-Structure-Access-Generate-Pointer-to-Structure-Member"><a href="#6-2-2-Structure-Access-Generate-Pointer-to-Structure-Member" class="headerlink" title="6.2.2 Structure Access: Generate Pointer to Structure Member"></a>6.2.2 Structure Access: Generate Pointer to Structure Member</h4><p>其实通过 structure representation 就能略知如何用指针找各个字段了。这里以一个例子说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rec</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">get_ap</span><span class="params">(<span class="keyword">struct</span> rec *r, <span class="type">size_t</span> idx)</span> &#123; <span class="keyword">return</span> &amp;r-&gt;a[idx]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_val</span><span class="params">(<span class="keyword">struct</span> rec *r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (r) &#123;</span><br><span class="line">        <span class="type">int</span> i = r-&gt;i;</span><br><span class="line">        r-&gt;a[i] = val;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get_ap</code> 函数对应的汇编代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_ap:</span><br><span class="line">    leaq(%rdi,%rsi,4), %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这里的操作表明了 <code>%rax = %rdi + 4 * %rsi</code>，即 <code>%rax = r + sizeof(int) * idx</code>。这说明了 <code>struct rec</code> 中的第一个成员就位于 <code>rec</code> 空间的开头，并按正常的整型数组进行排列。</p><p>但是对于另外一个函数 <code>set_val</code> 而言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set_val:</span><br><span class="line">.L11:</span><br><span class="line">    movslq16(%rdi), %rax</span><br><span class="line">    movl%esi, (%rdi,%rax,4)</span><br><span class="line">    movq24(%rdi), %rdi</span><br><span class="line">    testq%rdi, %rdi</span><br><span class="line">    jne.L11</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>第一步可以认为 <code>movslq</code> 就是 <strong>取 <code>Src</code> 的 32-bit 数据，符号扩展为 64-bit 数据后放入 <code>Dst</code></strong>，作用是将地址为 <code>%rdi + 16</code>（即 <code>r + 4 * sizeof(int)</code>）的 memory 引用的值覆盖到 <code>%rax</code> 上去。完成了源码的 <code>int i = r-&gt;i;</code> 这一步；</p><p>从这里可以看出，编译器将 <code>int a[4]</code>、<code>int i</code> 和 <code>struct rec* next</code> 这三个成员排在一起，<strong>是没有间隔的，如下图。但某些场合下编译器指定可能会出现间隔</strong>，这是是为了<strong>内存对齐的原因，下面马上会讨论结构体的内存对齐</strong>。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/struct_example.png" height="150px"></p><p>第二步 <code>movl</code> 将 <code>%esi</code>（<code>%rsi</code> 的 low-order 32-bit）的值赋给地址为 <code>%rdi + 4 * %rax</code>（即 <code>r + sizeof(int) * i</code>）的 memory 引用，完成了 <code>r-&gt;a[i] = val;</code> 这步；</p><p>第三部让 <code>%rdi</code> 的值变为 “地址为 <code>%rdi + 24</code> 的 memory 引用的值”，相当于 <code>r = r-&gt;next;</code></p><p>剩下的部分就是完成 while 循环的判断任务。</p><p><strong>上面的例子中，还有一个重要的问题没有阐释——结构体的内存对齐问题</strong>。</p><p>那么为什么要对结构体进行内存对齐？又是如何进行内存对齐的？再来看另外一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure><p>对于这个结构体而言，如果每个成员紧紧挨在一起，那么在内存中的排布是这样的：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/struct_example2_unaligned.png" height="60px"></p><p>但实际上编译器会在其中插入一些空数据块，让内存排布变成这样：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/struct_example2_aligned.png" height="125px"></p><p>这就是因为，x86-64（和其他很多架构的机器）规定了结构体内存对齐的规则。为什么要有这样的规则？这其实是 <strong>硬件效率问题</strong>。</p><p>对于当今大多数机器的内存系统而言，实际从硬件内存中一次读取的数据量大约 64 bytes，本身称为一个读取的<strong>数据块</strong>，大小取决于机器硬件中的各种宽度。所以，如果因为没有对齐的地址，而导致读取时特定的数据跨越了两个数据块的边界，那么很可能会导致操作系统需要采取一些额外的步骤来处理这种情况，从而大大降低处理效率。</p><p>除了上面的这种原因，还有种原因是，如果这些未对齐的结构体组成了数组，那么想要<strong>索引</strong>这些数组的计算将会非常复杂，<strong>使用起来也非常不方便</strong>。</p><p>鉴于以上原因，很多架构都采用了这种内存对齐的思路。其实内存对齐除了在结构体这里，我们之前在 “跳表” 的汇编代码（4.4）中也看到了内存对齐的指令（<code>.align</code>）；</p><blockquote><p>如果某种编译器编译程序时，没有安排内存对齐，那么在 x86-64 的架构上运行是没有问题的，因为微架构中有解决这个问题的方法（重新读入），速度可能会慢一点；但有些架构完全不能运行，会抛出内存错误的异常。</p></blockquote><p>那么如何对齐能够解决上面的问题？x86-64 架构提出了以下<strong>内存对齐的原则</strong>：</p><ol><li><p><strong>Primitive data type requires K bytes, so its address must be multiple of K</strong>;</p><p>如果原始数据类型的大小是 K bytes，那么它（所对应成员）的起始地址必须能被 K 整除。</p></li><li><p><strong>Overall structure length must be multiple of $\max\limits_{i}{K_i}$, where $\max\limits_{i}{K_i}$ is the largest alignment requirement in this structure</strong> (otherwise “external padding”).</p><p>结构体总体的大小必须是该结构体中最大的数据类型大小的整数倍。（满足上一条后，编译器可以通过在结构体尾部追加空数据块来实现）</p></li></ol><p>例如：</p><ul><li>对于 1 byte 的数据类型（如 <code>char</code>），这种类型成员在内存上的排布没有限制，哪里有空往哪搬；</li><li>对于 2 bytes 的数据类型（如 <code>short</code>），这种类型成员要求起始地址必须能被 2 整除（即 LSB of address must be $0_2$）；</li><li>对于 4 bytes 的数据类型（如 <code>int, float</code>），要求起始地址必须能被 4 整除（即 lowest 2 bits of address must be $00_2$）；</li><li>对于 8 bytes 的数据类型（如 <code>double, long, x86-64下各种 pointer</code>），要求起始地址必须能够被 8 整除（即 lowest 3 bits of address must be $000_2$）；</li><li>对于 16 bytes 的数据类型（如 <code>x86-64 gcc/Linux下的 long double</code>），要求起始地址必须能被 16 整除（即 lowest 4 bits of address must be $0000_2$）；</li></ul><p>再例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure><p>这个结构体的内存对齐方式如下：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/struct_example2_aligned_tail.png" height="125px"></p><p>因为其中含有 <code>double</code> 数据类型，所以总体大小必须是 8 的整数倍；又因为整体长度不是 8 的整数倍（<code>p + 17</code>），所以尾部补充空数据块到 <code>p + 24</code>;</p><h4 id="6-2-3-Accessing-Arrays-of-Structure"><a href="#6-2-3-Accessing-Arrays-of-Structure" class="headerlink" title="6.2.3 Accessing Arrays of Structure"></a>6.2.3 Accessing Arrays of Structure</h4><p>更进一步地，如果有一个结构体数组，并且结构体是被正确定义的，那么编译器就能很容易地确定各个结构体的大小、成员位置和数组的大小，从而在其他使用到的场合为其正确地分配空间、索引成员；</p><p>来看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> i;</span><br><span class="line">    <span class="type">float</span> v;</span><br><span class="line">    <span class="type">short</span> j;</span><br><span class="line">&#125; a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>如果你使用 <code>sizeof(S3)</code> 的话，你会发现值是 12，说明编译器生成的空数据块的大小也计算在内。具体的结构如下图所示，在 <code>i</code> 和 <code>v</code> 成员间、结构体尾部都有分配空数据块：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/struct_example3.png" height="125px"></p><p>还有使用它的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="title function_">get_j</span><span class="params">(<span class="type">int</span> idx)</span> &#123; <span class="keyword">return</span> a[idx].j; &#125;</span><br></pre></td></tr></table></figure><p>对照 <code>S3</code> 结构体的内存分布图，你就会发现这个函数的汇编代码也没有那么难以理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get_j:</span><br><span class="line">    leaq(%rdi,%rdi,2), %rax</span><br><span class="line">    movzwla+8(,%rax,4), %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>我们来解释上面例子的汇编行为：</p><p>第一步是相当于算术运算 <code>%rax = 3 * %rdi</code>;</p><p>第二步是 <code>%rax = a + 8 + 4 * %rax</code>，实质上是 <code>%rax = a + 8 + 4 * 3 * idx</code>，对照上面的内存分布情况可以理解，<code>a + 8</code> 就指向 <code>a[0].j</code>，而后面加 <code>4 * 3 * idx</code> 则是因为每个结构体占位 <code>4 * 3 bytes = 12 bytes</code> 的空间，这样就对应着 <code>a[idx].j</code> 的位置了。</p><blockquote><p><strong>这里的总结一下遇到的乱七八糟的 <code>movXXX</code> 指令</strong>。</p><p><code>movzbl</code> 和 <code>movsbl</code> 的作用相近，都是<strong>将 8-bit 扩展到 32-bit</strong>。但前者是 <strong>zero extension</strong> 零扩展（根据 <strong>extension conclusion</strong>，针对 unsigned 的扩展），而后者是 <strong>sign extension</strong> 符号扩展（针对 signed 的扩展）；</p><p><code>movzwl</code> 和 <code>movswl</code> 很像，前者是 16-bit（1 word）<strong>零扩展移动</strong>至 32-bit，后者是 16-bit <strong>符号扩展移动</strong>至 32-bit（long）；</p><p><code>movslq</code> 同理。</p><p>⚠ <strong>值得注意的是，<code>movzlq</code> 指令不存在，因为它的字面作用和 <code>movl</code> 相同，想想为什么</strong>。</p><p><strong>如果你会看指令名称的含义的话，上面的内容就无需记忆了</strong>：在 <code>mov&lt;A&gt;&lt;B&gt;&lt;C&gt; &lt;Src&gt;, &lt;Dst&gt;</code> 中，</p><p>A 表示扩展种类，可以是 <code>z</code>（zero extension）、<code>s</code>（sign extension）；</p><p>B 表示扩展源（<code>Src</code>）的大小，可以是 <code>b</code>（1 byte，8 bits），<code>w</code>（word，1 字，16 bits）、<code>l</code>（2 字，32 bits）、<code>q</code>（quadword，4 字，64 bits）；</p><p>C 表示扩展目标（<code>Dst</code>）的大小，可以取的值和 B 相同，但两者不能同时取一个值。</p><p>除此以外就是普通的 <code>mov&lt;X&gt;</code>（没有扩展功能）和条件移动 <code>cmov&lt;cond&gt;</code> 指令了。 </p></blockquote><h4 id="6-2-4-Saving-Space"><a href="#6-2-4-Saving-Space" class="headerlink" title="6.2.4 Saving Space"></a>6.2.4 Saving Space</h4><p>现在，我们了解了结构体的基本排布和表示，也知道了结构体内存对齐的规则。有些同学可能会发现，诶，因为结构体各成员在内存中的排布顺序严格按照源码声明的顺序，那么<strong>结构体中各个成员排布的不同，是不是会导致结构体最终所占的大小不同？</strong></p><p>答案是肯定的，所以，有必要讨论一下 “按什么方式声明结构体，能够让指定结构体的空间占用最小” 这个问题。下面是结论：</p><ul><li><p><strong>将占用空间较大的数据类型声明在前面</strong>。</p><blockquote><p>这种贪心算法是有效的。因为所有数据类型的大小只有 1、2、4、8、16 bytes，全是 2 的整数次幂，在数学上来说能够严格证明。</p></blockquote></li></ul><p>下面的例子中，<code>S4</code> 和 <code>S5</code> 相比，<code>S5</code> 更节省空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125; *p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S5</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure><h3 id="6-3-Floating-Point-in-Assembly"><a href="#6-3-Floating-Point-in-Assembly" class="headerlink" title="6.3 Floating Point in Assembly"></a>6.3 Floating Point in Assembly</h3><h4 id="6-3-1-History-amp-Background-for-Representing-FP"><a href="#6-3-1-History-amp-Background-for-Representing-FP" class="headerlink" title="6.3.1 History &amp; Background for Representing FP"></a>6.3.1 History &amp; Background for Representing FP</h4><p>在 x86 架构中，floating point 的表示有着比较深的历史。</p><p><strong>x87 FP</strong></p><p>很早之前，Intel 的 8087 芯片和 IEEE 浮点数标准一起诞生，安装在 8086 处理器上，是第一个能够完全处理 IEEE 浮点数运算的集成单元。但是编程模型从现在看来比较糟糕，所以 CSAPP 第三版就把这方面的内容完全移除了（expunged）；</p><p><strong>MMX FP</strong></p><p>1997 年 Intel 公司推出了多媒体扩展指令集 MMX，它包括57条多媒体指令。MMX 指令主要用于增强 CPU 对多媒体信息的处理能力，提高 CPU 处理 3D 图形、视频和音频信息的能力。</p><p><strong>SSE FP</strong></p><p>随着人们日益增长的精神文化的需要，例如核显渲染的浮点数运算需求增长，人们迫切需要并行计算的手段，于是一个全新的思路就出现了——<strong>SIMD（Single Instruction Multiple Data），单指令多数据</strong>，和整型寄存器不一样，我们在浮点数寄存器上多放几个数同时计算，那么运算速度不就上去了？</p><p>紧接着，一套新的指令拓展集 SSE（Streaming SIMD Extension）被设计出来，兼容 MMX 指令，配合一套浮点寄存器，来完成标量浮点数，或者单指令多数据的浮点数的计算。</p><p><strong>AVX FP</strong></p><p>在2010 年 AVX 将之前浮点运算数据的宽度从 128 bits 的扩展到 256-bits。同时新的 CPU 架构下数据传输速度也获得了提升。AVX 指令集在 SIMD 计算性能增强的同时也沿用了的 MMX/SSE 指令集。不过和 MMX/SSE 的不同点在于，增强的 AVX 指令在指令的格式上也发生了很大的变化。x86 (IA-32/Intel 64) 架构的基础上增加了prefix，所以实现了新的命令，也使更加复杂的指令得以实现，从而提升了 x86 CPU的性能。</p><blockquote><p>AVX 并不是 x86 CPU 的扩展指令集，可以实现更高的效率，同时和 CPU 硬件兼容性也更好，在 SSE 指令的基础上 AVX 也使 SSE 指令接口更加易用；</p></blockquote><h4 id="6-3-2-Programming-with-SSE3"><a href="#6-3-2-Programming-with-SSE3" class="headerlink" title="6.3.2 Programming with SSE3"></a>6.3.2 Programming with SSE3</h4><p>在 SSE 第 3 版中，指明了 x86 架构有 <strong>16 个 floating point registers</strong>（和之前的 16 个 integer registers 完全不同），每个 floating point register 空间大小 <strong>16 bytes</strong>（大概是 integer register 的两倍大）；</p><p>它们又叫 <code>XMM</code> Register（名称的历史渊源比较多，此处省略，感兴趣看 CSAPP 原书 P294），所以这些寄存器的名称：<code>%xmm0 ~ %xmm15</code>;</p><p>其中，按照<strong>指令使用的不同</strong>，每个 <code>XMM</code> Register 都可以存储：</p><ul><li>16 个 1 byte 整型（<code>char</code>）；</li><li>或 8 个 2 bytes 整型（<code>short</code>）；</li><li>或 4 个 4 bytes 整型（<code>int</code>）；</li><li>或 4 个 单精度浮点数（<code>float</code>）；</li><li>或 2 个双精度浮点数（<code>double</code>）；</li><li>或 1 个 单精度浮点数（<code>float</code>，没存满，有剩余空间）；</li><li>或 1 个 双精度浮点数（<code>double</code>，没存满，有剩余空间）；</li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/xmm_registers.png" height="400px"></p><p>这意味着浮点数寄存器<strong>既可以处理整型，又可以处理浮点数类型</strong>；<strong>既可以处理一个数的运算，又可以多个数并行运算</strong>。</p><p>这种一次计算单个数的指令被称为 <strong>Scalar Operations（标量运算）</strong>，一次并行计算多个数的指令被称为 <strong>SIMD Operations（单指令多数据运算）</strong>。</p><p>具体的命令长什么样子的呢？还是经典的 <strong>名称+后缀</strong> 命名方法，所以如果你能读懂命名方法，那就不用记忆太多的指令了。</p><p>对于浮点数运算而言，主要有 4 种指令：<code>addss</code>、<code>addps</code>、<code>addsd</code>、<code>addpd</code>；</p><p>会读的同学已经懂了，就是 <code>&lt;OP_NAME&gt;&lt;OP_TYPE&gt;&lt;DATA_TYPE&gt;</code> 的组合嘛！</p><ul><li><p><code>OP_NAME</code> 就是运算的名称，这里是 <code>add</code> 加法运算（显然还有 <code>mov</code> 移动、<code>sub</code> 减法等等）；</p></li><li><p><code>OP_TYPE</code> 是运算类型，上面提到的 <code>s</code> 代表 Scalar 标量运算（一次算一个数），<code>p</code> 代表 Packed 多数据运算（一次算一组数）；</p><blockquote><p>特别地，如果强调是对齐的数据，那么 <code>OP_TYPE</code> 还有前缀 <code>a</code> 代表 aligned，例如：<code>movapd</code>;</p></blockquote></li><li><p><code>DATA_TYPE</code> 是运算的数据类型，<code>s</code> 代表 Single precision floating point，<code>d</code> 代码 Double precision floating point；</p></li></ul><p>所以举个例子，<code>addpd</code> 就是双精度浮点数的 SIMD 加法运算指令嘛！</p><p>运算的参数和之前的整型寄存器运算一样，<code>&lt;Src&gt;, &lt;Dst&gt;</code>;</p><p>运算的内存表示就是如图：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/sse_fp_addition.png" height="400px"></p><p>除此以外，FP 还有 <strong>2 点</strong>需要注意：</p><ol><li><p>FP Registers 的 Saving Conventions：</p><ul><li><p><code>%xmm0 ~ %xmm15</code> 就是依次传递参数的 register，参数多于 15 个浮点数类型，则和多出 6 个的整型参数一样，会放到栈帧中去；</p></li><li><p><code>%xmm0</code> 也是约定<strong>返回浮点数值</strong>的存放位置；</p></li><li><p><strong>所有的 <code>XMM</code> Register 都是 Caller-Saved Register</strong>，没有 Callee-Saved Register；</p></li></ul></li><li><p>FP 的还有众多的命令等待认识，不过最重要的还是之前提到的<strong>记忆指令的命名方法</strong>，理解了命名方法就能更少地记忆指令；</p><ul><li><p>FP 数据比较指令：<code>ucomiss</code>（Unordered Compare Scalar Single Precision Floating Point）、<code>ucomisd</code>（Unordered Compare Scalar Double Precision Floating Point）；</p><blockquote><p>和 <code>cmpq</code> 大致相似，会设置 condition codes，包括 <code>CF/ZF/SF</code>；</p></blockquote></li><li><p>FP 常数使用：这里 <code>$</code> 符号<strong>只能</strong>接整型常量，所以如果要使用浮点数常量，需要 <code>xorpd %xmm0 %xmm0</code> 等类似指令运算出 / 从内存中读入才能使用。</p></li></ul></li></ol><p>事实上，之前我们一直担心的 “<strong>浮点数如何通过寄存器传递参数</strong>” 等问题，只要有了命令就非常简单，操作方法几乎和 integer registers 一样。下面是一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">fadd</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">dadd</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">dincr</span><span class="params">(<span class="type">int</span>* p, <span class="type">double</span> v)</span> &#123;</span><br><span class="line">    <span class="type">double</span> x = *p;</span><br><span class="line">    *p = x + v;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fadd:</span><br><span class="line">    addss%xmm1, %xmm0</span><br><span class="line">    ret</span><br><span class="line">dadd:</span><br><span class="line">    addsd%xmm1, %xmm0</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">dincr:</span><br><span class="line">    movapd%xmm0, %xmm1</span><br><span class="line">    movsd(%rdi), %xmm0</span><br><span class="line">    addsd%xmm0, %xmm1</span><br><span class="line">    movsd%xmm1, (%rdi)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>函数 <code>fadd</code> 和 <code>dadd</code> 没有什么好说的，主要看 <code>dincr</code>：</p><p>第一步 <code>movapd</code> 见名知意，Move Aligned Packed Double Precision Floating Point，成组移动双精度浮点数，参数类型和其他的 <code>mov</code> 指令相同；</p><p>这里的 <code>%xmm0</code> 里装的是<strong>函数第二参数 <code>double v</code></strong>（第一参数是指针整型，所以放在 <code>%rdi</code>），移动到了未使用到的 <code>%xmm1</code> 寄存器中；</p><p>第二步 <code>movsd</code>，Move Scalar Double Precision Floating Point，移动标量双精度浮点数，将地址为 <code>%rdi</code> 的 memory 引用值（也就是 <code>p</code> 指向的内存 double 数据）赋给 <code>%xmm0</code>（x），并且最终将作为返回值返回；</p><p>第三步就是标量将 <code>%xmm0</code> 的数据（x）加到 <code>%xmm1</code> 的值（v）上，完成了 <code>*p = x + v;</code></p><p>第四步就将计算结果 <code>%xmm1</code> 的值（t）标量移动到地址为 <code>%rdi</code> 的 memory 引用区域中（p 所指向的区域），完成 <code>*p = t;</code></p><h4 id="6-3-3-AVX-Instructions"><a href="#6-3-3-AVX-Instructions" class="headerlink" title="6.3.3 AVX Instructions"></a>6.3.3 AVX Instructions</h4><p>AVX 新增的指令可以说是非常地多，使用方法、命名规范和之前所有的命令不同的是，加了前缀 “v”（vector，矢量运算），其他都相近。</p><p>AVX 指令用于驱动更新的 浮点数寄存器，例如 <code>%ymm</code> 系列。</p><ul><li><p><code>mov</code> 类命令：<code>vmovss/vmovsd/vmovps/vmovpd/vmovass/...</code>;</p><blockquote><p>命名规范见前面的叙述；</p></blockquote></li><li><p><code>cvt</code> （convert）类命令，一般实现浮点和整型之间的转换：</p><ul><li><p><code>vcvttss2si/vcvttsd2si/vcvttss2si/vcvttss2siq/vcvttsd2siq</code>;</p></li><li><p><code>vcvtsi2ss/vcvtsi2sd/vcvtsi2ssq/vcvtsi2sdq</code>;</p><blockquote><p>有点长，但是命名规范清楚：</p><p><code>vcvt</code> 是 <code>cvt</code> 类命令的前缀；</p><p>中间有 <code>t</code> 表示 truncation，进行截断（<strong>出现在浮点向整型的转换中</strong>）；</p><p>后缀 <code>XX2YY</code> 是 从 <code>XX</code> 类型转换到 <code>YY</code> 类型的意思，<code>XX/YY</code> 可取的值有：<code>ss/sd/ssq/sdq/si(integer, 32-bit)/siq(integer, 64-bit)</code>;</p></blockquote></li></ul></li><li><p>arithmetic 类命令：<code>vaddss/vsubss/vmulss/vdivss/vmaxss/vminss/vxorps/xandps/sqrtss/...</code></p><blockquote><p>新的指令名：<code>sqrt</code>，之前 integer registers 的指令所没有的；</p></blockquote></li><li><p>比较类命令（和 SSE3 相同）：<code>ucomiss/ucomisd</code>;</p></li></ul><h3 id="6-4-Summary-for-Chapter-6"><a href="#6-4-Summary-for-Chapter-6" class="headerlink" title="6.4 Summary for Chapter 6"></a>6.4 Summary for Chapter 6</h3><p>本章的内容密度也相当之大，有必要总结回顾一下本章所学的全部内容。</p><p>本章的一开始我们复习了 C/C++ 中指针和数组的准确定义，从分析<strong>二者的使用方式</strong>和 <strong>2 种区别（常量性、空间分配的自主性）</strong>方面入手，从较深的角度考虑了 <strong>数组标识符的含义和多种声明方式</strong>，以及这些声明方式如何阅读、如何理解。这样我们就能准确地回答：不同标识符的 <code>sizeof</code> 判断问题、空指针/野指针的出现问题，也有助于我们理解在汇编中数组的呈现方式。</p><p>在了解数组在 C/C++ 中的地位后，我们先讨论了普通一维数组的<strong>内存分布</strong>和<strong>访问方式</strong>。</p><p>无论是存在于程序栈帧中的一维数组（<code>T[]</code> 声明法），还是存在于堆中的一维数组（<code>T*</code> 声明法），它们的排布都是位于<strong>连续的</strong>、 <strong><code>L * sizeof(T)</code> 大小的</strong>内存空间中，数组标识符可以看作指向开头位置的指针常量。因此，对于一维数组的汇编访问就是看作<strong>一串连续的同类型数据排布</strong>，按照 Simple Memory Address Mode 进行索引即可。</p><p>而后我们从恒定的（<code>constexpr</code>，编译前确定）数组规模出发，进一步学习二维数组的情况。</p><p>由于 C/C++ 的语言特性，二维数组的两种声明方式（Nested array <code>T[][]</code> 和 Multi-level array <code>T*[]</code>），<strong>尽管二者的使用方法几乎一致</strong>，但所对应的<strong>内存排布方式 和 汇编操作性质完全不同</strong>。</p><p>前者在声明时，所有元素的空间都会被自动分配至栈中，并且以 “Row major” 的方式<strong>连续排布</strong>；而后者则仅有一级元素（<code>T*</code>）被自动分配空间，并且指向的每一行数组之间的存储位置<strong>可以不连续</strong>。</p><p>内存结构上的差异就决定了这两种数组在汇编代码访问方式的不一致。访问 Nested Array 的某个元素时，只需要对<strong>数组标识符</strong>和<strong>索引</strong>进行算术计算（<code>&amp;A[i][j] == A + i * C * sizeof(T) + j * sizeof(T)</code>）就能得到相应地址；而访问 Multi-Level Array 时却必须先由<strong>数组标识符</strong>和<strong>行参数</strong>找到一级元素内容，然后用<strong>一级元素内容</strong>和<strong>列索引</strong>才能定位具体的元素位置。</p><p>讨论完固定规模二维数组的内存排布和访问方式后，我们将眼光拓展到可变规模的 Nested Array（即 M × N Matrix）上。按照所掌握的知识，我们也可以从普通固定规模的两种二维数组出发，类比出访问这种可变规模二维数组的汇编实现。</p><p>聚合结构除了数组，还有一个重要的部分——结构体，也是 C++ 中类的前身。</p><p>结构体在内存中的表示遵循简单的 3 条原则：<strong>连续排布</strong>、<strong>严格按声明顺序</strong>、<strong>编译器决定字段内存对齐</strong>。</p><p>在观察几个例子后，我们发现在有些情况下，结构体的每个程序紧密排布，访问方式与数组相近；但有些情况编译器会在成员间插入空白数据段（也计入数据结构的总大小）。于是我们分析了<strong>结构体内存对齐</strong>的两点<strong>现实原因</strong>和两点<strong>对齐的原则</strong>（“起始地址整除原则”、“最大倍数原则”）；我们根据这些原则能够正确认识结构体在内存中的组织情况，并以此对程序进行存储方面（<strong>如何声明结构体成员，以获得最小的占用空间</strong>）和性能方面的改进。</p><p>对于结构体所组成的数组，则可以看成完整的结构体所为一个基本元素所组成的数组，一级索引方式与普通数组相同，二级索引方式和单一结构体相同，在汇编层面<strong>共同构成结构体数组针对单个元素、单个成员的索引表达式</strong>。</p><p>虽然聚合结构对于汇编层面来说完全透明，但以上建立的规则和约定让底层的一个个指令共同实现了聚合结构的高级功能。</p><p>除了阐明聚合结构在汇编层面的实现之外，我们还整理了非常多的 <code>mov</code> 指令。从中我们归纳出了<strong>指令命名的规则</strong>，这个规则适用于其他几乎所有指令，可以帮助我们<strong>少记忆指令</strong>、<strong>在遇到没有见过的指令时能够推测出其大致作用</strong>。</p><p>最后，我们提及了浮点数指令的历史，及其在内存中的整体存储、汇编层面的使用。</p><p>在 SSE3 指令拓展集中，16 个 <code>XMM</code> Register 既可以存储标量数据，又可以存储成组的数据；既可以存放各种数据类型的整型数据，又可以存放各种数据类型的浮点型数据。在此基础上，我们接触到了两类运算方法（Scalar Op 和 SIMD Op）及其对应的指令，使用方法和整型的情况相近。</p><p>此外，关于 FP Register 的 Saving Conventions、比较指令和常数的使用，进一步加深了我们对浮点数的汇编操作的理解。</p><p>另外介绍的 AVX Instructions 有助于帮助我们理解某些浮点数操作的汇编代码的含义。</p><h2 id="Chapter-7-Machine-Level-Programming-Ⅴ-Advanced"><a href="#Chapter-7-Machine-Level-Programming-Ⅴ-Advanced" class="headerlink" title="Chapter 7. Machine Level Programming Ⅴ - Advanced"></a>Chapter 7. Machine Level Programming Ⅴ - Advanced</h2><h3 id="7-1-Memory-Layout-in-x86-64"><a href="#7-1-Memory-Layout-in-x86-64" class="headerlink" title="7.1 Memory Layout in x86-64"></a>7.1 Memory Layout in x86-64</h3><p>内存（虚拟内存）本质上就是一个很大的字节数组。而之前观察 memory 的角度要么是从汇编 Simple Memory Address Mode 的访问角度，要么是从 x86-64 的程序栈的角度来看内存的。本节将从<strong>更为宏观、更为完整</strong>的角度介绍 <strong>x86-64 Linux 的完整内存布局</strong>。</p><p>首先，从 64 位系统的特征上来说，x86-64 系统上的程序所能访问的内存空间应该是 $2^{64}$ bits（大约 $16\times10^{18}$ bits），但由于当前存储技术的种种限制，当前的硬件限制我们只能使用最高 47 位的地址（大约 $128\times10^{12}$ bits，128 TB）。</p><p>在这个限制下，我们看一看系统提供给程序的运行内存的结构：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/memory.png" height="400px"></p><ul><li><p>最底层的 128 MB 是栈区（<code>0x0000 7FFF FFFF 0000</code>，即 $2^{47}-4096$ 至 <code>0x0000 7FFF F800 0000</code>），实际 x86-64 栈的<strong>实际最大大小</strong>在 8 MB 左右，向低地址增长。栈的结构参考 5.2 和 5.3。</p><blockquote><ol><li>一般操作系统为了保护栈数据不被攻击，一般在栈的前后放置随机数据区域；如果没有这些保护数据，那么栈就放在内存最底层（<code>0x0000 7FFF FFFF 0000</code> 的位置）.</li><li>如果运行中的程序<strong>试图访问超过这里 8 MB 限制范围的地址</strong>，或者<strong>访问的地址还没有通过 virtual memory allocator 的分配</strong>时，系统会抛出 segmentation fault，并强制结束程序；</li></ol></blockquote></li><li><p>在从最下面看起，位置 <code>0x40 0000</code> 开始向高地址位置，有一段 text 区（找不到这个名字的来源），是程序存放运行机器代码的位置（信息从可执行文件读入）。<strong>我们将在 “链接” 一章详细讨论这个部分的具体内容</strong>。数据只读（Read Only）；</p></li><li><p>再下面一段是 Data 区，<strong>是用来存放程序开始时就分配的数据</strong>。存放的内容包括：</p><ul><li>静态分配的数据；</li><li>程序中的全局变量、静态值、字符串常量；</li><li>……</li></ul></li><li><p>再下面一段是堆。堆和栈的分配方式<strong>完全不同</strong>，堆空间在运行时按代码<strong>动态分配</strong>（dynamically allocated，一般由 malloc()、calloc()、new 等方法创建，free()、delete 等方法销毁），最有趣的是，堆的分配位置和生长方向不固定；下面将由例子来说明；</p></li><li><p>堆下面有一段空间的位置是外部库（Shared Libraries），存储的是类似 malloc()、printf() 的库函数。它们一开始是<strong>作为动态链接库存储于磁盘上</strong>，在程序加载时，它们也载入内存的这个位置，供程序使用，称为<strong>动态加载</strong>。<strong>我们将在 “动态链接” 这一部分详细讨论具体内容</strong>。</p></li></ul><p>我们运行下面的程序进行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> big_array[<span class="number">8388608L</span>];        <span class="comment">/* 1&lt;&lt;24, 16 MB */</span></span><br><span class="line"><span class="type">char</span> huge_array[<span class="number">1073741824L</span>];    <span class="comment">/* 1&lt;&lt;31, 2 GB */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">useless</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *phuge1, *psmall2, *phuge3, *psmall4;</span><br><span class="line">    <span class="type">int</span> local = <span class="number">0</span>;</span><br><span class="line">    phuge1 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">28</span>);    <span class="comment">/* 256 MB */</span></span><br><span class="line">    psmall2 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">8</span>);    <span class="comment">/* 256 B */</span></span><br><span class="line">    phuge3 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">32</span>);    <span class="comment">/* 4 GB */</span></span><br><span class="line">    psmall4 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">8</span>);    <span class="comment">/* 256 B */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 GDB 调试可以发现，在 Linux 内存中，<code>big_array</code>、<code>huge_array</code> 和 <code>global</code> 这三个全局变量分布在大致 <code>0x600000</code> 的低地址的位置，位于 <strong>Data 区</strong>；局部变量 <code>local</code> 在地址 <code>0x7FFE 0000 0000</code> 的大致位置，位于<strong>内存栈区</strong>；对于函数 <code>main()</code> 和 <code>useless()</code> 而言，它们的地址在 <code>0x400000</code> 附近，位于 <strong>Text 区</strong>；</p><p>而对于 <code>phuge1</code>、<code>psmall2</code>、<code>phuge3</code>、<code>psmall4</code> 来说略有特殊。它们是使用 <code>malloc</code> 分配在堆里的，但是它们的位置差别较大：<strong>占用空间很大的 <code>phuge1</code> 和 <code>phuge3</code> 位于更靠近栈区的堆中，而占用空间较小的 <code>psmall2</code> 和 <code>psmall4</code> 则位于更靠近 Data 区的堆中</strong>。大致情况如下图：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/memory_pos.png" height="350px"></p><p>奇怪的是，<code>malloc</code> 大数据量的堆在上方和 shared libraries 紧贴，向低地址增长；而普通数据的堆在 Data 区的下方向高地址增长。可以预见，当两块 heap 碰头的时候，<code>malloc</code> 会返回空指针。</p><p>这个规律目前还没有解释，等到以后的章节慢慢了解。</p><h3 id="7-2-Buffer-Overflow"><a href="#7-2-Buffer-Overflow" class="headerlink" title="7.2 Buffer Overflow"></a>7.2 Buffer Overflow</h3><p>在 Chapter 0-0.3 的越界实验中，我们就讨论过内存缓冲区溢出的问题。当时造成的后果是结构体中的其他成员的数据被修改。本节会详细解释内存缓冲区溢出的各个方面的影响和应当措施。</p><h4 id="7-2-1-The-Vulnerability"><a href="#7-2-1-The-Vulnerability" class="headerlink" title="7.2.1 The Vulnerability"></a>7.2.1 The Vulnerability</h4><p>继续以 0.3 中的实验代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125; <span class="type">struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">struct_t</span> s;    <span class="comment">/* volatile 关键字表示易变量，警告编译器不进行任何优化 */</span></span><br><span class="line">    s.d = <span class="number">3.14</span>;</span><br><span class="line">    s.a[i] = <span class="number">1073741824</span>;    <span class="comment">/* Possibly out of bounds */</span></span><br><span class="line">    <span class="keyword">return</span> s.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>i</code> 参数取值大于 1 时会污染 <code>s.d</code> 的值，当 <code>i</code> 参数大于 6 时，可能会出现 segmentation fault；</p><p>但内存缓冲区溢出的问题不仅仅是内部开发者编写错误这一个小问题。相反，这是一个<strong>大问题</strong>。</p><ul><li>Buffer overflow 的出现：when <strong>exceeding</strong> the memory <strong>size</strong> allocated for <strong>an array</strong>;</li><li>Buffer overflow 为什么是大问题：它是<strong>头号的技术层面上的安全漏洞</strong>（#1 technical cause of security vulnerabilities）；</li><li>Buffer overflow 产生的原因列举：<ul><li>Unchecked lengths on string inputs（外部因素：<strong>不对输入字符串的长度和内容进行合法性检查</strong>）；</li><li>Illegal indexing / referring / modifying memory（内部因素：<strong>不对访问 memory 的参数进行检查</strong>）；</li></ul></li></ul><p>下面举一个实际点的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get string from stdin */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = getchar();        <span class="comment">/* get a single char from stdin */</span></span><br><span class="line">    <span class="type">char</span> *p = dest;            <span class="comment">/* the pointer p points to the same addr as dest */</span></span><br><span class="line">    <span class="keyword">while</span> (c != EOF &amp;&amp; c != <span class="string">&#x27;\n&#x27;</span>) &#123;    <span class="comment">/* reading stdin until new line or EOF */</span></span><br><span class="line">        *p++ = c;            <span class="comment">/* add the value of p directly. (A problem ?) */</span></span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;                <span class="comment">/* the dest char must ends with &#x27;\0&#x27; */</span></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Echo Line */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>];            <span class="comment">/* Way too small */</span></span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">call_echo</span><span class="params">()</span> &#123; echo(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a string: &quot;</span>);</span><br><span class="line">    call_echo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>gets</code> 函数不管 <code>dest</code> 的实际被分配的大小，直接进行输入，很可能在内存中出现 Buffer Overflow。于是总结出导致 Buffer Overflow 的罪魁祸首之一：<strong>存储字符串，却不检查边界情况的库函数</strong>；C 库里有很多这样不检查边界的库函数：<code>scanf</code>、<code>fscanf</code>、<code>sscanf</code>（等 <code>scanf</code> 家族，尤其是使用 <code>%s</code> 格式化参量）、<code>strcpy</code>、<code>strcat</code>（等字符串移动家族）……</p><p>现在看看运行这个程序会出现什么问题（如果自己想试试的话，记得<strong>关闭 gcc 栈保护 <code>-fno-stack-protector</code></strong>）：</p><ul><li>如果输入短一点的字符串（长度小于 24 个），那么程序很可能会正常运行；</li><li>如果输入很长的字符串，那么程序会报告 segmentation fault；</li></ul><p>那么，都是缓冲区溢出，为什么短一点的看起来不会出问题呢？这时候就需要从汇编代码解释了。我们生成上面的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">    sub$0x18, %rsp</span><br><span class="line">    mov%rsp, %rdi</span><br><span class="line">    callq400680 &lt;gets&gt;</span><br><span class="line">    mov%rsp, %rdi</span><br><span class="line">    callq400520 &lt;puts@plt&gt;</span><br><span class="line">    add$0x18, %rsp</span><br><span class="line">    retq</span><br><span class="line">call_echo:</span><br><span class="line">    sub$0x8, %rsp</span><br><span class="line">    mov$0x0, %eax</span><br><span class="line">    callq4006cf &lt;echo&gt;</span><br><span class="line">    add$0x8, %rsp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure><p>首先观察，一开始系统为 <code>echo</code> 函数的栈帧分配了 24 bytes（<code>0x18</code>）的空间，<strong>因此，如果输入的输出加入超过了所有的栈空间，进入没有被分配的 memory 时，就会报告 segmentation fault</strong>。</p><p>所以，（<strong>当没有使用 <code>gcc</code> 栈保护机制时</strong>）安全问题通常就出现在 “溢出内容超过了原来分配的位置，但是没有超过栈的总体空间” 这种情况下。这时系统不会抛出 segmentation fault，<strong>栈中数据只能任由输入者篡改</strong>。</p><p>再来看看内存对应的情况：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/buffer_overflow_example1.png" height="260px"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/buffer_overflow_example1_2.png" height="260px"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/buffer_overflow_example1_3.png" height="260px"></p><p>如上左图，当 <code>char buf[4]</code> 声明后，在程序初始化时，编译器为<code>echo</code> 预留了 24 bytes 的空间；<code>echo</code> 栈帧的最顶层存放的是局部变量 <code>buf</code> 数组对应的空间大小是 4 bytes，一切都很正常。</p><p>如上中图，我们不妨假设 <code>call_echo</code> 在 return address 里存放的地址是 <code>0x4006C3</code>（<code>echo</code> 运行结束后应该返回的地址）；如果输入字符串内容超过了 <code>buf</code> 能承受的 3 bytes，则会出现 buffer overflow，如图，数据覆盖了 <code>buf</code> 下方的 20 bytes 其他区域的数据，但因为这个例子中，恰好那个区域没有存放其他数据，所以表面上程序没问题；</p><blockquote><p>如果那 20 bytes 空间放了其他数据，那么会被篡改；</p></blockquote><p>但，如果输入长度更长，那么字符串序列会溢出的更长，如上右图所示，污染了 Return address 的话，问题就出现了。当 echo 想要结束时，会因为 Return address 被修改而转移到一个不知道什么的地方，很可能导致 segmentation fault；<strong>更严重的，如果恰好跳转到一个奇怪的函数中，并且还能运行、没报错，那么坏了，程序不会按预期的方式继续运行，这样的 bug 非常隐晦</strong>；</p><h4 id="7-2-2-Stack-Smashing-Attacks"><a href="#7-2-2-Stack-Smashing-Attacks" class="headerlink" title="7.2.2 Stack Smashing Attacks"></a>7.2.2 Stack Smashing Attacks</h4><p>在上面说到的情况下，如果攻击者想要函数在输入后，跳转到不应该执行的、但是程序里面有的函数中，会让程序出现一些意料之外的行为。</p><blockquote><p>例如登录场景：攻击者想要输入一串内容，让软件跳转到登陆成功的函数中;</p></blockquote><p>这种攻击被称为<strong>缓冲区溢出攻击（stack smashing attack）</strong>，这种攻击就是利用了技术人员不注意输入检查，而导致的缓冲区溢出的问题。</p><p>实现这种攻击的原理比较简单，就是<strong>输入无意义的填充字符（padding）让输入的内容 buffer overflow，并且在末尾设置一个想要跳转到的函数的地址，并且只需让末尾的地址恰好覆盖 return address</strong> 就行。</p><p>如下图所示，正常的流程是 <code>P()</code> 调用 <code>Q()</code>，<code>P</code> 函数在 return address 中写的是 <code>A</code>，也就是 <code>P</code> 函数中调用 <code>Q</code> 的下一行；但由于 <code>Q()</code> 中的 <code>gets(buf)</code> 有溢出风险，在攻击者输入 <code>padding</code> 字符 + <code>S</code> 地址组合的字符串后，<code>gets</code> 函数将缓冲区数据覆盖了，如下图右，return address 被改成了 <code>S</code> 的地址。这样在 <code>Q()</code> 执行结束后，会跳转到 <code>S()</code> 函数中，而不是原来的 <code>P()</code> 中：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/stack_smashing_attack.png" height="300px"></p><p>做法很简单，但是编译时要关闭 <code>gcc</code> 的栈保护机制（<code>-fno-stack-protector</code>）。现在大多数 C/C++ 编译器都有这项功能，利用栈随机化、“金丝雀” 检查等技术，打乱栈空间的实际排布、利用栈两端的 “金丝雀” 侦测栈溢出，发现就立即终止程序，让攻击难以进行。<strong>（后面会详细讨论）</strong></p><ol><li>找到有导致缓冲区溢出风险的函数（像之前提到的 <code>scanf</code> 家族、<code>str</code> 家族），并且技术人员没有为这些函数的输入进行检查；</li><li>反汇编找到想要跳转的函数（也就是上面的 <code>S</code>）的地址；</li><li>反汇编找到汇编代码中编译器为 <code>Q</code> 函数分配的栈帧大小，计算出 <code>pad</code> 填充字符的大小，使得 <code>S</code> 地址恰好覆盖 return address；</li><li>将 padding 数据 + <code>S</code> 的地址（<strong>注意大小端序的问题</strong>）转换为字符串，运行程序并输入即可。</li></ol><h4 id="7-2-3-Code-Injection-Attacks"><a href="#7-2-3-Code-Injection-Attacks" class="headerlink" title="7.2.3 Code Injection Attacks"></a>7.2.3 Code Injection Attacks</h4><p>也是在上面说到的情况下，如果有攻击者刻意如此设置，让缓冲区溢出到 return address，并且恰好让 return address 指向攻击者事先设计好的 exploit code 中，那么程序就会执行攻击者设计的函数，从而给计算机造成威胁。</p><p>这种攻击被称为 <strong>代码注入攻击</strong>，思路和上面的 stack smashing attack 如出一辙，只不过攻击者不满足于执行软件内的其他函数了，他要执行的是自己嵌入的函数，危害可能更大。</p><p>实现攻击的原理就是，<strong>攻击者输入编码有 exploit code + padding string + pointer to exploit code 的内容</strong>，让读入程序执行结束后跳转到攻击者刚刚输入的 exploit code 中执行，如下图所示：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/code_injection_attack.png" height="300"></p><blockquote><p>更聪明的攻击者会在运行完 exploit code 后修复溢出的缓冲区，并且跳转到原来的函数，伪装成没有被攻击的假象。</p><p>知识拓展：计算机病毒和计算机蠕虫的区别</p><ul><li>蠕虫：可以通过某种隐蔽的方式，进行自我复制、独立地在机器上运行预期代码；</li><li>病毒：可以通过某种隐蔽的方式，进行自我复制，攻击一个程序，并改变这个程序的行为，但自己不能独立存在。</li></ul></blockquote><h4 id="7-2-4-The-Protection-in-personal-respective"><a href="#7-2-4-The-Protection-in-personal-respective" class="headerlink" title="7.2.4 The Protection: in personal respective"></a>7.2.4 The Protection: in personal respective</h4><p><strong>Avoid overflow vulnerabilities when writing a program</strong></p><blockquote><p>例如之前的 <code>gets</code> 函数有风险，可以换成 <code>fget</code> 指定读入缓冲区的大小；</p><p><code>strcpy</code> 换成 <code>strncpy</code>、<code>scanf</code> 使用时不轻易用 <code>%s</code> 格式，而使用 <code>%ns</code>，或者直接用 <code>fgets</code>;</p></blockquote><p><strong>Avoid overflow vulnerabilities in system-level</strong></p><ul><li><p>栈随机化（stack randomization），是更宏观策略 ASLR (Address Space Layout Randomization, 地址空间布局随机化) 的一部分；</p><blockquote><p>这样的话，每次运行程序，栈和堆上变量的位置偏移 offset 会随机产生，攻击者就没法找到准确的攻击代码的插入位置了；</p></blockquote></li><li><p>Non-executable code segments：在栈中规定禁止执行代码，只有在 Text 区 / Shared Libraries 区才能执行；</p><blockquote><p>以前人们在内存中每一个 chunk 前放置 3 个 flags，类似 Unix 上的 可读、可写、可执行三个权限，对于栈区的空间中 flags 应该是可读、可写、不可执行；</p></blockquote></li><li><p>Stack Canaries（栈 “金丝雀”），在栈中的 buffer 两端设置特殊的随机值（称为 “金丝雀”，早期人们下矿就用金丝雀的生死来判断矿井中瓦斯是否超标），在写入 buffer 的函数退出前检查这些值。如果这些值被改变了，那么说明 buffer overflow，可能会出问题，就立即终止接下来程序的执行；<strong>现在这个技术已经在 <code>gcc</code> 中成为默认的编译选项：<code>-fstack-protector</code></strong>;</p></li></ul><blockquote><p>这里简单从汇编层面分析一下 “金丝雀” 是如何实现的。</p><p>还是以上面的 <code>echo</code> 函数为例，这时我们编译就删除 <code>-fno-stack-protector</code> 这个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">    sub$0x18, %rsp</span><br><span class="line">    mov%fs:0x28, %rax</span><br><span class="line">    mov%rax, 0x8(%rsp)</span><br><span class="line">    xor%eax, %eax</span><br><span class="line">    mov%rsp, %rdi</span><br><span class="line">    callq4006e0 &lt;gets&gt;</span><br><span class="line">    mov%rsp, rdi</span><br><span class="line">    callq400570 &lt;puts@plt&gt;</span><br><span class="line">    mov0x8(%rsp), %rax</span><br><span class="line">    xor%fs:0x28, %rax</span><br><span class="line">    je400768 &lt;echo+0x39&gt;</span><br><span class="line">    callq400580 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">    add$0x18, %rsp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure><p>我们一步步分析：</p><p>第一步给 <code>echo</code> 栈帧分配了 24 bytes 的空间，非常简单；</p><p>第二步用到了一个没见过的东西 <code>%fs:0x28</code>，实际上 <code>%fs</code> 是一个<strong>为原始 8086 芯片设计的一个寄存器</strong>，由于向下兼容，所以它现在还能<strong>以某种方式</strong>使用，但是基本很少用，甚至已经找不到它的文档了……只需要知道 <code>%fs:0x28</code> 是内存的某个隐匿部位，相当于随机数 “金丝雀”，我们将这个数放到 <code>%rax</code>，第三步再将这个值放到 <code>%rsp</code> 所指向的下面 8 bytes 的位置——这就意味着 <code>buf</code> 只要溢出 8 bytes 就会被察觉；</p><blockquote><p>⚠ <code>%fs</code> <strong>不是</strong>真正可用的寄存器，它是 segment register（段寄存器）in protected mode，其中的值是指向某个有效位置的指针。所以只能用如此方式（<code>%fs:0x28</code>）取出值，它（<code>%fs:0x28</code>）实际上是内存中某个位置的引用，<strong>并且每次运行，这个值都会改变</strong>。</p><p>这也回答了为什么不能直接将 <code>%fs:0x28</code> 的值 <code>mov</code> 到内存中。</p><p>——以上摘自 <a href="https://stackoverflow.com/questions/10325713/why-does-this-memory-address-fs0x28-fs0x28-have-a-random-value">StackOverflow</a>;</p></blockquote><p>第四步将 <code>%rax</code> 清空为 0，然后执行普通的 <code>echo</code> 操作，省略；</p><p>直到倒数第 5 步（第 10 行），系统将 “金丝雀” 取出到 <code>%rax</code> 并和原值 <code>%fs:0x28</code> 比较，如果不等就是缓冲区溢出，立即调用 <code>__stack_chk_fail</code> 报错终止执行；</p></blockquote><h4 id="7-2-5-【New】Return-Oriented-Programming-Attacks"><a href="#7-2-5-【New】Return-Oriented-Programming-Attacks" class="headerlink" title="7.2.5 【New】Return-Oriented Programming Attacks"></a>7.2.5 【New】Return-Oriented Programming Attacks</h4><p>在上面的许多防护措施出来后，给攻击者带来很多难题：</p><ul><li>栈随机化使得他们很难预测缓冲区的位置；</li><li>栈区无法执行代码，使得他们插入代码也没用；</li></ul><p>于是攻击者有了一些替代性的措施，<strong>能够突破上面的两个障碍（栈随机化 + 禁止栈中执行代码）</strong>：</p><ul><li>利用已存在的代码，例如标准库中的代码。因为它们不在栈区和堆区，位置不会轻易变动；</li><li>利用 x86 架构中 <code>ret</code> 指令的特殊行为，来执行代码；</li></ul><p>下面介绍这种攻击的原理。</p><p>这种攻击利用的部件称之为 <strong>gadget</strong>，通常是各个函数的<strong>包含 <code>ret</code> 指令的最后几行或者一段</strong>，如下：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/gadget_1.png" height="225px"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/gadget_2.png" height="225px"></p><p>这些毫无关系的函数的汇编代码最后几行甚至几个片段总会包含一些指令，例如将某个寄存器的值加多少、将某个寄存器的值移动到哪。它们紧接着 <code>ret</code> 指令（对应汇编码 <code>0xC3</code>）。这就意味这我们可以<strong>收集这些 gadget 的地址，按照我们的需求依此排列这些 gadget，通过输入将这些地址溢出到栈里，让栈充当程序计数器的角色，反复执行 <code>gadget1</code> -&gt; <code>ret</code> -&gt; 执行 <code>gadget2</code> -&gt; <code>ret</code> -&gt; …，越过了上面两个限制，将所有 gadget 连在一起，最终让程序段达到我们的目的</strong>，如下图：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="imgs/ROP_execution.png" height="300px"></p><p><strong>可以说是顶级的 “断章取义”！</strong></p><p>不过有两个缺点：</p><ul><li>这种攻击仍然不能突破 “金丝雀” 的防护，因为这毕竟是栈溢出；</li><li>各个 gadget 需要大量地查找，比较费精力。有些人会在标准库中积累一些 gadget；</li></ul><h3 id="7-3-Union-in-Memory"><a href="#7-3-Union-in-Memory" class="headerlink" title="7.3 Union in Memory"></a>7.3 Union in Memory</h3><p>C 中有一个特殊的数据结构：<code>Union</code>，声明方式与 <code>struct</code> 几乎一样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125; *up;</span><br></pre></td></tr></table></figure><p>但用法完全不一样。<strong><code>Union</code> 的所有域共用一块最大的域大小的内存</strong>，这就导致在改动一个域的数据时，其他域的值也会改变；所以 <strong><code>Union</code> 一次只能使用一个域，或者用在通过别名引用不同的内存的场合</strong>。<code>Union</code> 用的地方少，但在单片机、掩码的领域用的比较多。</p><p>还有就是之前的 Data Lab 中用于 <strong>bit-level representation 的 float 和真实的 float 之间相互转换</strong>，不会改变 bit pattern，也能用到 <code>Union</code>（当然不是解题答案，因为不允许）；</p><p><strong>使用 <code>Union</code> 也要特别注意端序的问题</strong>！！！</p><h4 id="7-3-1-Union-Allocation"><a href="#7-3-1-Union-Allocation" class="headerlink" title="7.3.1 Union Allocation"></a>7.3.1 Union Allocation</h4><p>对联合体（<code>Union</code>）而言，内存分配比较简单，只需要判断所有域中占用空间最大的那一个来分配就行。例如上面的例子就是 8 bytes；</p><h4 id="7-3-2-Summary-of-Compound-Types-in-C"><a href="#7-3-2-Summary-of-Compound-Types-in-C" class="headerlink" title="7.3.2 Summary of Compound Types in C"></a>7.3.2 Summary of Compound Types in C</h4><ul><li>Arrays<ul><li>Contiguous allocation of memory（1-D &amp; Nested Array）；</li><li>Aligned to satisfy every element’s alignment requirement；</li><li>Pointer to first element；</li><li>No bounds checking；</li></ul></li><li>Structures<ul><li>Allocate bytes in order declared；</li><li>Pad in middle and at end to satisfy alignment；</li></ul></li><li>Unions<ul><li>Overlay declarations；</li><li>Way to circumvent type system；</li></ul></li></ul><h3 id="7-4-Summary-of-Chapter-7"><a href="#7-4-Summary-of-Chapter-7" class="headerlink" title="7.4 Summary of Chapter 7"></a>7.4 Summary of Chapter 7</h3><p>本章的内容相较于之前两章较少，但是也很重要。</p><p>本章开始我们就从<strong>更全面的</strong>角度来观察 <strong>x86-64 Linux 的完整内存布局</strong>，我们落脚于实际，考虑到实际能够使用的内存不过 128 T 左右，建立了一个 <code>0x0000 7FFF FFFF F000 ~ 0x40 0000</code> 的内存图谱。</p><p>在这个图谱中，自高地址至低地址分布栈区（stack）、外部库区（shared libraries）、堆区（heap）、数据区（data）、机读代码区（text）；</p><p>这些位置都由 virtual memory allocator 进行管理，如果访问了超出整个内存的范围，或是不在已分配的空间内，系统都会抛出 segmentation fault；</p><p>我们了解到，栈区<strong>位于内存的最高地址处</strong>，内部存放见 5.2 和 5.3，实际大小约 8 MB（x86-64），地址在 $2^{47}-4096$ 至 <code>0x0000 7FFF F800 0000</code> 中，前后可能含有因为 ASLR 或 “金丝雀” 产生的<strong>随机数据</strong>，总共约 128 MB；</p><p>在栈区的上方（这里把较低地址的称为 “上方”）是 Shared Libaries 区，<strong>它存放重要的外部库函数</strong>，是动态加载至内存上的部分。如果堆中有较大的数据，可能部分的堆区会与外部库区毗邻，并且向低地址生长。</p><p>跨过中间大片的未分配的区域向低地址看，就是堆区，<strong>由代码函数手段分配和释放的区域，存放大部分由手动分配的普通变量</strong>，向高地址生长；</p><p>在堆区的上方，是数据区，<strong>存放程序开始就分配的数据</strong>，包括静态数据、全局变量、字符串常量等；</p><p>再向上就是内存的地址最低处，机读代码区，开始于 <code>0x40 0000</code>，具体内容会在 “链接” 一章中讨论。</p><p>以上区域，text / data / shared libraries 区域运行时可读可执行，heap / stack 区域可读可写不可执行。</p><p>介绍完 x86-64 Linux 整体的内存分布，我们进一步讨论了 Buffer overflow 的原理和危害性。</p><p>Buffer overflow 出现的<strong>内部原因</strong>是对数组或其他 memory 不恰当的读写访问，<strong>外部原因</strong>是不对输入字符串进行长度和内容的合法性检验。</p><p>最后 Buffer Overflow 或者触发 segmentation fault 导致程序崩溃，或者恰好进行了不恰当的跳转，让程序行为不可预测、难以调试，或者被不法分子利用后，危害计算机系统的正常使用。</p><p>从一个使用容易内存缓冲区溢出的 <code>gets</code> 的函数 <code>echo</code> 出发，我们讨论了输入不同长度的字符串对缓冲区溢出的影响，进而推出了 <strong>3 种</strong>利用缓冲区溢出特点的攻击行为（Stack Smashing Attacks、Code Injection Attacks、Return-Oriented Programming Attacks）。它们共同点是，都利用了溢出影响 return address 的特性，使得程序跳转到攻击者指定的位置执行；但从具体操作上各有差异。</p><p>之后我们介绍了<strong>两类、四种</strong>针对内存缓冲区溢出攻击的防护办法。两类中的一类是<strong>从开发者自己做起</strong>，尽量避免使用有缓冲区溢出风险的函数；另一类是<strong>从系统层面做起</strong>，主要分为 3 种，分别是<strong>栈随机化</strong>、<strong>栈区禁止执行代码</strong> 和 <strong>栈 “金丝雀”</strong>。这 3 种防护思路能够轻松应对 Stack Smashing Attacks 和 Code Injection Attacks，但只有 栈 “金丝雀” 能够防护 Return-Oriented Attacks。</p><p>我们仔细分析了 栈 “金丝雀” 的汇编层面的实现，更加确信这个至今没有被破解的防护方法的强大。</p><p>本章最后，我们接触到了 <code>Union</code> 联合体在内存中的分配和表示，反复强调使用 <code>Union</code> 时<strong>一定要注意端序的问题</strong>，以免出现字节序方面的编程错误。</p><blockquote><p>第 3 ~ 7 章已结束，请完成 Bomb Lab &amp; Attack Lab！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt; &lt;a href=&quot;http://www.cs.cmu.edu/~213/schedule.html&quot;&gt;CMU - 213&lt;/a&gt;, &lt;i&gt;Computer Systems A Programmer’s Perspective 3rd Edition&lt;/i&gt; by Randal Bryant, David O’Hallaron&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;内容很长，写起来很慢&lt;/i&gt; 😳&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="review" scheme="https://sjtuxhw.top/categories/review/"/>
    
    
    <category term="GNU" scheme="https://sjtuxhw.top/tags/GNU/"/>
    
    <category term="CSAPP" scheme="https://sjtuxhw.top/tags/CSAPP/"/>
    
    <category term="ICS" scheme="https://sjtuxhw.top/tags/ICS/"/>
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>MC-Forge开发笔记（一）</title>
    <link href="https://sjtuxhw.top/2023/09/05/MC-Forge%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://sjtuxhw.top/2023/09/05/MC-Forge%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-09-05T13:04:06.000Z</published>
    <updated>2023-09-19T05:18:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: </i><a href="https://docs.minecraftforge.net/en/1.16.x/">Minecraft Forge Doc 1.16.x</a>、<a href="https://boson.v2mcdev.com/introducation/intro.html">Boson 1.16（导论部分）</a></p><p><i>注意：以 MC 版本 1.16.5 为例</i>（同一大版本 1.16.x 的操作方式变化不大）</p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><hr><span id="more"></span><h2 id="Chapter-0-Forge-导论"><a href="#Chapter-0-Forge-导论" class="headerlink" title="Chapter 0. Forge 导论"></a>Chapter 0. Forge 导论</h2><h3 id="0-1-Forge-历史与定义"><a href="#0-1-Forge-历史与定义" class="headerlink" title="0.1 Forge 历史与定义"></a>0.1 Forge 历史与定义</h3><ul><li><p><code>Minecraft</code> 其中发行版的一个大类是由 <code>Java</code>写的<strong>商业</strong>软件，这意味着：</p><ul><li><code>Minecraft</code> 容易反编译和修改：由于 <code>Java</code> 半解释型语言的特性（但凡换成 C++ 就很可能不会有今天 Mod 丰富的生态了，毕竟 Mojang 当年一直不给官方 API）；</li><li>代码本身是闭源的、被混淆的：这毕竟是一款商业软件。</li></ul></li><li><p>为了给 <code>Minecraft</code> 增添更多的游戏特性，大家千方百计地寻找添加代码的办法。最终 <code>MCP</code>（Mod Coder Pack）项目诞生了，它<strong>规避了没有官方 API 的问题，通过反编译、反混淆直接修改 <code>Minecraft jar</code> 包中的内容</strong>。其发展过程中，人们研究各类的名称的产生如下：</p><ul><li><p><code>notch</code> 名：<code>Minecraft</code> 各种类直接反编译、反混淆之后的名称，通常是无意义的字母数字组合。</p><blockquote><p>例如 <code>j</code> 就是一个典型的 <code>notch</code> 名；</p></blockquote></li><li><p><code>srg</code> 名：与 <code>notch</code> 名一一对应。极大的好处是<strong>在一个版本里是不会变动的</strong>，这意味着类名渐渐可读起来，有相应的前缀后缀来区分。之所以叫做<code>srg名</code>，是为了纪念MCP项目开发的领导者Searge；</p><blockquote><p>例如 <code>notch</code> 名 <code>j</code> 对应 <code>srg</code> 名的 <code>func_70114_g</code>。</p></blockquote></li><li><p><code>mcp</code> 名：这是当年 <code>MCP</code> 项目的 mod 开发者使用的最多的名称。在<code>mcp</code> 名中，<strong>代码已经是可读的了</strong>。和我们正常写java程序中的名称没什么两样，但是也会变动。</p><blockquote><p>例如，<code>notch</code> 名为 <code>j</code> 的函数，其 <code>srg</code> 名为 <code>func_70114_g</code>，其 <code>mcp</code> 名是 <code>getCollisionBox</code>；</p></blockquote></li></ul></li><li><p>随着时间推移和生态的扩展，大家发现这么做很不行，因为直接修改 Jar 文件写 mod 的方式太过于粗暴了，而且 Mod 和 Mod 之间的兼容性可以说基本没有。于是，<code>Forge</code> 项目就诞生了。</p></li><li><p><code>Forge</code> 是通过修改 <code>Minecraft</code> 方式实现的<strong>第三方的 API</strong>，给广大 mod 开发者提供了标准化的接口的指引。而Forge本身也在 <code>Minecraft</code> 1.13 版本到来之后经历了一次重写，引入了大量函数式编程的API。</p><blockquote><p>随着时间的发展，<code>MCP</code> 项目现在已经死亡了，除了 <code>Forge</code> 这套API，<code>Fabric</code> 也风头正盛。</p></blockquote></li><li><p><code>Forge</code> 的工作原理也采用了 <code>MCP</code>  的思路。在为指定版本的 <code>Minecraft</code> 安装完 <code>Forge</code> 之后，游戏的运行过程中，所有的内容都会反编译成 <code>srg</code> 运行，你编译好的 mod 同样也会被混淆成 <code>srg</code>，保证它可以正常运行。</p><blockquote><p>用 <code>srg</code> 名就是因为它每个版本不变。</p></blockquote></li></ul><h3 id="0-2-Minecraft-的架构"><a href="#0-2-Minecraft-的架构" class="headerlink" title="0.2 Minecraft 的架构"></a>0.2 Minecraft 的架构</h3><p>除了了解 <code>Forge</code> 的历史和定义，<code>Minecraft</code> 的架构和运作方式在 Mod 开发中也绝对是必要的。</p><ul><li><p><code>Minecraft</code> 是一种 C/S 架构，整体逻辑如下：</p><ul><li>服务端：负责游戏的逻辑，数据的读写。</li><li>客户端：接受用户的输入输出，根据来自服务端的数据来渲染游戏画面。</li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="struct.png" height="400px"></p></li><li><p>Tips 1. 这里客户端和服务端的区分<strong>仅是逻辑上的区分</strong>。</p><ul><li>实际上如果你处于单人模式，那么你的电脑上会<strong>同时存在</strong>服务端和客户端，而且他们处于不同的线程（<code>Server thread</code> &amp; <code>Render thread</code>）；</li><li>但是当你连接某个服务器时，你的电脑上只存在客户端，服务端被转移到了远程的一台服务器上。</li></ul></li><li><p>Tips 2. 客户端、服务端<strong>各存在一份数据模型</strong>。不过「客户端数据模型」只是「服务端数据模型」一个副本，虽然它们都有独立的游戏 <code>Tick</code>，也共享很多相同的代码，但是最终逻辑还是以服务端为准。</p></li><li><p>Tips3. 客户端和服务端是存在于不同线程的，所以它们不可避免地需要同步数据。而数据同步都是通过<strong>网络数据包</strong>实现的。</p><blockquote><p>在大部分时候原版已经实现好了数据同步的方法，我们只需要调用已经实现好的方法就行。</p><p>但是在某些情况下，原版没有实现对应的功能，或者不适合使用原版提供的功能，我们就得自己创建和发送网络数据包来完成数据的同步。【可能需要计算机网络基础、<code>Java</code> 网络编程基础】</p></blockquote></li><li><p>在代码中，<strong>区分服务器端和客户端</strong>的方式：<code>World</code> 中有一个 <code>isRemote</code> 字段，开发时判断它就行。</p></li></ul><h3 id="0-3-Minecraft-的运行模式"><a href="#0-3-Minecraft-的运行模式" class="headerlink" title="0.3 Minecraft 的运行模式"></a>0.3 Minecraft 的运行模式</h3><ul><li><strong>离散事件驱动模式</strong>，详见数据结构书籍。这个模式包含了 3 个概念：<ul><li>事件：“当方块被破坏” 这个就是一个事件，“当玩家死亡” 这个也是一个事件，甚至 “当渲染模型时” 这个也是一个事件；</li><li>事件处理器：用来处理 “事件” 的函数。例如可以注册一个事件处理器来处理 “玩家死亡事件”，里面的内容是 “放置一个墓碑”；</li><li>总线：总线是连接 “事件” 和 “事件处理器” 的工具，当 “事件” 发生的时候，“事件” 的信息将会被发送到总线上，然后总线会选择监听了这个 “事件” 的 “事件处理器”，执行这个事件处理器。</li></ul></li><li>在Minecraft中，所写的逻辑基本上都是事件处理。</li><li>在Forge开发里有两条总线，<code>Mod</code> 总线和 <code>Forge</code> 总线，所有和初始化相关的事件都是在 <code>Mod</code> 总线内，其他所有事件都在 <code>Forge</code> 总线内。</li></ul><h3 id="0-4-重要概念准备"><a href="#0-4-重要概念准备" class="headerlink" title="0.4 重要概念准备"></a>0.4 重要概念准备</h3><ul><li><p>注册：如果想往 <code>Minecraft</code> 里添加一些内容，那么你必须做的一件事就是注册。注册是一种机制，告诉游戏本身，有哪东西可以使用。你注册时需要的东西基本上可以分成两个部分：<strong>一个注册名</strong>和<strong>一个实例</strong>；</p></li><li><p>资源地址（<code>ResourceLocation</code>）：<code>Minecraft</code> 管理、定位资源（音频 / 图片）的方式是<strong>采用特殊格式的字符串</strong>。格式为：<code>&lt;domain&gt;:&lt;UNIX-Style relative path&gt;</code>。</p><ul><li>域可以是 <code>minecraft</code>（原版资源），也可以是 mod 的名称。相对路径是相对于 mod 根目录下的 <code>assets</code> 目录而言（如果是原版资源，即域名为 <code>minecraft</code>，那么相对于 <code>.minecraft/assets</code>）;</li><li>例如：<code>minecraft:textures/block/stone.png</code>，<code>mod1:textures/Alex.png</code>；</li></ul></li><li><p>模型和材质：在游戏中 <code>3D</code> 的对象基本上都有它的模型，模型和材质组合在一起规定了一个对象具体的样子。模型相当于是骨头，材质相当于是皮肤。在大部分时候，你的材质都是 png 图片【可能需要平面设计 和 PS 的相关功底】。</p><blockquote><p>注意保证<strong>材质背景是不透明的</strong>，也不要在材质中使用<strong>半透明像素</strong>，会有不可预知的问题。</p></blockquote></li></ul><h3 id="0-5-开发环境"><a href="#0-5-开发环境" class="headerlink" title="0.5 开发环境"></a>0.5 开发环境</h3><blockquote><p><code>Minecraft Forge</code> 是由 <code>Gradle</code> 管理的项目，而 <code>Forge</code> 官方写了一个叫做 <code>ForgeGradle</code>（以后简称FG）的插件来负责整个 mod 开发环境的配置，本节主要介绍这个环境的配置和使用；</p></blockquote><ul><li><p>前提</p><ol><li><code>JDK 8</code>（1.16.x 兼容版本）和 <code>64 bit JVM</code>；请确保您的操作系统已经安装并配置好环境变量 <code>JAVA_HOME</code>、<code>CLASS_PATH</code>；</li><li>官网获得 <code>MDK(Mod Development Kit)</code>：我们这里 1.16.5 选择官网推荐的 <code>forge-36.2.34</code> <a href="https://files.minecraftforge.net/net/minecraftforge/forge/index_1.16.5.html">Downloads for Minecraft Forge for Minecraft 1.16.5</a>；</li><li>Java 开发 IDE，可以选 VSCode / Eclipse / IDEA，本文<strong>以 IDEA 为例</strong>进行。</li></ol></li><li><p>开发准备工作</p><ol><li><p>这里我们将下载的 MDK 解压到一个空目录下；</p><blockquote><p>FG 项目结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">├─ .gitattributes        # Git 用来记录某些文件属性</span><br><span class="line">├─ .gitignore            # Git 用来忽略版本控制的记录文件</span><br><span class="line">├─ build.gradle            # Gradle 构建脚本</span><br><span class="line">├─ changelog.txt        # Forge 项目版本迭代情况</span><br><span class="line">├─ CREDITS.txt            # Forge 项目致谢和 credits</span><br><span class="line">├─ gradle.properties    # Gradle 属性文件，用来定义其他变量和设置</span><br><span class="line">├─ gradlew                # Unix 类系统执行 Gradle wrapper 的 shell</span><br><span class="line">├─ gradlew.bat            # Windows 系统 ~</span><br><span class="line">├─ LICENSE.txt            # Forge 项目证书</span><br><span class="line">├─ README.txt            # 基本安装指导说明书</span><br><span class="line">│</span><br><span class="line">├─ gradle/</span><br><span class="line">│   └─wrapper/            # 这里包含了 Gradle Wrapper，这里使用的是 7.4.2</span><br><span class="line">│        ├─ gradle-wrapper.jar</span><br><span class="line">│        └─ gradle-wrapper.properties</span><br><span class="line">│</span><br><span class="line">├─ run/                # 在构建项目后会出现，相当于 .minecraft</span><br><span class="line">|</span><br><span class="line">└─src/                    # 源文件目录</span><br><span class="line">└─main/                # main 分组的源文件目录</span><br><span class="line">  ├─java/            # main 分组的 java 源文件</span><br><span class="line">  │              # 这里是 java 的 package，将来在这里写 mod</span><br><span class="line">  │</span><br><span class="line">  └─resources/        # main 分组的资源目录</span><br><span class="line">      ├─ pack.mcmeta    # 被 minecraft 用来识别数据和资源包的文件</span><br><span class="line">      │</span><br><span class="line">      └─META-INF/    # Forge 资源 metadata 信息文件存放目录</span><br><span class="line">           └─ mods.toml    # mod 声明的文件</span><br></pre></td></tr></table></figure><p><strong>其中最为重要的几个分别为</strong>：</p><ul><li><code>build.gradle</code>、<code>gradlew.bat</code>、<code>gradlew</code>、<code>gradle/</code> 目录；</li></ul><p>只要有了上面几个的数据，就能创建一个新 <code>mod</code> 项目；</p></blockquote></li><li><p>把上面说的重要的几个文件复制到新目录，以后这里是 mod 项目的根目录了（这么做是为了减少文件干扰，毕竟我们不需要版本控制，对吧）；</p></li><li><p>用 IDEA 打开这个新目录，即可自动下载依赖配件、设置项目；如果中途出现错误，99% 是因为网络错误。请翻*GFW，或者上网找国内源解决；</p></li><li><p>打开后，在 IDEA Terminal 下执行 <code>gradlew genIntellijRuns</code>（如果是 eclipse/vscode，那么后面一个词分别是 <code>genEclipseRuns</code> 和 <code>genVSCodeRuns</code>），它会进一步下载游戏需要的资源，并且设置 <code>Run Configure</code>；</p></li></ol></li><li><p>mod 的 gradle 脚本个性化：刚入门，介绍简单的个性化方式，主要是编辑 <code>build.gradle</code> 的内容。</p><ul><li><p><strong>注意，在不知道含义的情况下，不能编辑其中的 <code>buildscript &#123;&#125;</code> 块。这些代码对于 <code>ForgeGradle</code> 来说是必须的</strong>；</p></li><li><p><strong>更改构建的结果文件名</strong>：编辑 <code>archivesBaseName</code> 的值；</p></li><li><p><strong>更改 <code>maven</code> 构建系统的根目录</strong>：编辑 <code>group</code> 的值；</p></li><li><p><strong>更改 mod 版本信息</strong>：编辑 <code>version</code> 的值；</p></li><li><p><strong>将其中所有 “examplemod” 都替换为自己 mod id（自己定，唯一，只能有小写字母，不能有大写/空格/其他字符，切记！！！）</strong>；</p></li><li><p><strong>设置项目名称映射（mappings）</strong>：在 <code>minecraft&#123;&#125;</code> 块中，第一个就是 <code>mappings</code>，默认官方的 mappings。但是，官方的<strong>没有参数和 <code>javadocs</code> 提示</strong>。如果之后用的不习惯，可以换成以前 <code>MCP</code> 的 mappings（现在已经停止维护）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minecraft &#123;</span><br><span class="line">    <span class="comment">// 这是最后一次 mappings 的更新</span></span><br><span class="line">    mappings channel: <span class="string">&#x27;snapshot&#x27;</span>, version: <span class="string">&#x27;20210309-1.16.5&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>注意：修改完 <code>build.gradle</code> 脚本后需要重新进行前面的步骤进行设置</strong>；</p></blockquote></li><li><p>forge 项目的构建和测试</p><ul><li><p>当 mod 开发结束后，根目录运行 <code>gradlew build</code>，会向 <code>build/libs</code> 中构建 <code>[archivesBaseName]-[version].jar</code>，您可以直接将这个包放在安装了 forge 的 minecraft 游戏的 <code>mod</code> 目录中，即可加载；</p></li><li><p>当然，每写一次就要加入游戏目录的操作不现实。所以测试中，可以使用 <code>Run Configure</code> 来运行测试的 Minecraft 服务器 + 客户端，<strong>这时会加入开发目录（之前说过，<code>src/main/java</code>）的所有 mod jar 包</strong>；</p><blockquote><p>具体命令：启动服务器 <code>gradlew runServer</code>，自动绑定在 <code>localhost</code> 的指定端口；启动客户端 <code>gradlew runClient</code>；</p><p><strong>测试时建议就用上面的测试服务器环境哦~ 别去网络上正式的服务器测试</strong>😂</p></blockquote></li></ul></li></ul><h3 id="0-6-Mod-结构设计"><a href="#0-6-Mod-结构设计" class="headerlink" title="0.6 Mod 结构设计"></a>0.6 Mod 结构设计</h3><ul><li><p>和普通 Java 项目一样，设定好 top level package，然后为 mod 起一个唯一的名字；比如，我的 top level package 名叫做 <code>com.test</code>，然后我起个包名 <code>helloMC</code>，于是叫 <code>com.test.helloMC</code>；</p><blockquote><p>还是补充一下，如果以后做 Java Web，top level package 的名字需要是自己有的域名前缀，例如我有 <code>xxx.org</code>，那么为这个域名开发 Java Web 服务的规范就是 top level package <code>org.xxx</code>；</p></blockquote></li><li><p><code>mods.toml</code> 文件设计：上面说过，这个文件定义了 mod 的元信息（metadata），<strong>可以被 mod 使用者在游戏添加 mod 的界面看到</strong>；</p><ul><li><p>一个信息文件能够描述多个 mod；</p></li><li><p><code>mods.toml</code> 的语言是 <code>TOML</code>（可以理解为和 <code>YAML</code> 差不多的东西，语法不一样），必须要被存放于 <code>src/main/resources/META-INF/</code> 下；</p></li><li><p>一个 <code>mods.toml</code> 最基本的模板如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The name of the mod loader type to load - for regular FML @Mod mods it should be javafml</span></span><br><span class="line">   <span class="attr">modLoader</span>=<span class="string">&quot;javafml&quot;</span></span><br><span class="line">   <span class="comment"># A version range to match for said mod loader - for regular FML @Mod it will be the forge version</span></span><br><span class="line">   <span class="comment"># Forge for 1.16.5 is version 36</span></span><br><span class="line">   <span class="attr">loaderVersion</span>=<span class="string">&quot;[36,)&quot;</span></span><br><span class="line">   <span class="comment"># The license for your mod. This is mandatory and allows for easier comprehension of your redistributive properties.</span></span><br><span class="line">   <span class="comment"># Review your options at https://choosealicense.com/. All rights reserved is the default copyright stance, and is thus the default here.</span></span><br><span class="line">   <span class="attr">license</span>=<span class="string">&quot;All Rights Reserved&quot;</span></span><br><span class="line">   <span class="comment"># A URL to refer people to when problems occur with this mod</span></span><br><span class="line">   <span class="attr">issueTrackerURL</span>=<span class="string">&quot;github.com/MinecraftForge/MinecraftForge/issues&quot;</span></span><br><span class="line">   <span class="comment"># If the mods defined in this file should show as separate resource packs</span></span><br><span class="line">   <span class="attr">showAsResourcePack</span>=<span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">   <span class="section">[[mods]]</span></span><br><span class="line">     <span class="attr">modId</span>=<span class="string">&quot;examplemod&quot;</span></span><br><span class="line">     <span class="attr">version</span>=<span class="string">&quot;1.0.0.0&quot;</span></span><br><span class="line">     <span class="attr">displayName</span>=<span class="string">&quot;Example Mod&quot;</span></span><br><span class="line">     <span class="attr">updateJSONURL</span>=<span class="string">&quot;minecraftforge.net/versions.json&quot;</span></span><br><span class="line">     <span class="attr">displayURL</span>=<span class="string">&quot;minecraftforge.net&quot;</span></span><br><span class="line">     <span class="attr">logoFile</span>=<span class="string">&quot;logo.png&quot;</span></span><br><span class="line">     <span class="attr">credits</span>=<span class="string">&quot;I&#x27;d like to thank my mother and father.&quot;</span></span><br><span class="line">     <span class="attr">authors</span>=<span class="string">&quot;Author&quot;</span></span><br><span class="line">     <span class="attr">description</span>=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">     Lets you craft dirt into diamonds. This is a traditional mod that has existed for eons. It is ancient. The holy Notch created it. Jeb rainbowfied it. Dinnerbone made it upside down. Etc.</span></span><br><span class="line"><span class="string">     &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">     <span class="section">[[dependencies.examplemod]]</span></span><br><span class="line">       <span class="attr">modId</span>=<span class="string">&quot;forge&quot;</span></span><br><span class="line">       <span class="attr">mandatory</span>=<span class="literal">true</span></span><br><span class="line">       <span class="attr">versionRange</span>=<span class="string">&quot;[36,)&quot;</span></span><br><span class="line">       <span class="attr">ordering</span>=<span class="string">&quot;NONE&quot;</span></span><br><span class="line">       <span class="attr">side</span>=<span class="string">&quot;BOTH&quot;</span></span><br><span class="line">    </span><br><span class="line">     <span class="section">[[dependencies.examplemod]]</span></span><br><span class="line">       <span class="attr">modId</span>=<span class="string">&quot;minecraft&quot;</span></span><br><span class="line">       <span class="attr">mandatory</span>=<span class="literal">true</span></span><br><span class="line">       <span class="attr">versionRange</span>=<span class="string">&quot;[1.16.5,1.17)&quot;</span></span><br><span class="line">       <span class="attr">ordering</span>=<span class="string">&quot;NONE&quot;</span></span><br><span class="line">       <span class="attr">side</span>=<span class="string">&quot;BOTH&quot;</span></span><br></pre></td></tr></table></figure><p>以下是必须要填写的信息列表：</p><table>    <tr style="text-align: center;">        <th>Property</th>        <th>Type</th>        <th>Default</th>        <th>Description</th>    </tr>    <tr>        <td>modid</td>        <td>string</td>        <td>mandatory</td>        <td>The modid this file is linked to (also the modid in build.gradle).</td>    </tr>    <tr>        <td>version</td>        <td>string</td>        <td>mandatory</td>        <td>The version of the mod. It should be just numbers separated by dots, ideally conforming to Forge’s Semantic Versioning structure.</td>    </tr>    <tr>        <td>displayName</td>        <td>string</td>        <td>mandatory</td>        <td>The user-friendly name of this mod.</td>    </tr>    <tr>        <td>updateJSONURL</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>The URL to a version JSON.</td>    </tr>    <tr>        <td>displayURL</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>A link to the mod’s homepage.</td>    </tr>    <tr>        <td>logoFile</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>The filename of the mod’s logo. It must be placed in the root resource folder, not in a subfolder.</td>    </tr>    <tr>        <td>credits</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>A string that contains any acknowledgements you want to mention.</td>    </tr>    <tr>        <td>authors</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>The authors of this mod.</td>    </tr>    <tr>        <td>description</td>        <td>string</td>        <td>mandatory</td>        <td>A description of this mod.</td>    </tr>    <tr>        <td>dependencies</td>        <td>[list]</td>        <td>[]</td>        <td>A list of dependencies of this mod.</td>    </tr></table></li></ul></li><li><p><code>@Mod</code> annotation：在编写 mod 中，这个标识是用来提示 <code>Forge Mod Loader</code>，<strong>这个类是一个 Mod entry point</strong>；另外，这个标识的值需要是 <code>modid</code>（在 <code>build.gradle</code> 和 <code>mods.toml</code> 都写过）；</p></li><li><p><strong>一个建议</strong>（不强制）：比起将源文件散落在文件夹中，使用 <code>sub-packages</code> 的结构可读性更强；例如像物体（items）、方块（blocks）、数据实体（tile entities，或者其他 sub-packages）应该放在 <code>common</code> 包，而屏幕（Screens）、渲染器（Renderers）应该放在 <code>client</code> 下；</p><blockquote><p>这里补充一下什么是 <code>tile entities</code>，后面用到详细说。</p><p>Tile Entities就像简化的实体一样，绑定到Block上。 它们用于存储动态数据，执行基于tick的任务以及动态渲染。 </p><p>原本 Minecraft的一些例子是：处理库存（箱子），熔炉上的冶炼逻辑或信标的区域效应。 mod中存在更高级的示例，例如采石场，分拣机，管道和显示器。</p><p>注意：不要滥用！如果使用不当会导致卡顿；</p></blockquote></li><li><p>类名命名规范：<strong>在您创建的类名之后加上它们的父类名（即是什么），可以让读者更能理解这个类在干什么</strong>；</p><blockquote><p>这其实是所有语言、所有场景开发的共同的规范。</p><p>例如，一个自定义物品 <code>PowerRing</code>，它的类继承于 <code>Item</code>，因此最好定为 <code>PowerRingItem</code>;</p><p>再如一个自定义方块 <code>NotDirt</code>，继承于 <code>Block</code>，因此命名为 <code>NotDirtBlock</code>；</p></blockquote></li></ul><h3 id="0-7-Mod-更新系统"><a href="#0-7-Mod-更新系统" class="headerlink" title="0.7 Mod 更新系统"></a>0.7 Mod 更新系统</h3><p>Forge 提供了一个可选的、轻量级的更新检查的框架，在作者提交更新后，使用 mod 的用户会在游戏中 mod 管理的按钮上看到更新，并且会写入 <code>changelogs.txt</code>，但不会自动下载升级；</p><p>为了集成这个功能，只需设置上面 <code>mods.toml</code> 的可选参数 <code>updateJSONURL</code>，这个 URL 可以指向您提供 “update json” 的网站服务器或者 github 上（只要别人能访问到）；</p><p>而这个 “update json” 的格式为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;homepage/download page for your mod&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;&lt;mcversion&gt;&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&lt;modversion&gt;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;changelog for this version&gt;&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="comment">// List all versions of your mod for the given Minecraft version, along with their changelogs</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;promos&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&lt;mcversion&gt;-latest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;modversion&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// Declare the latest &quot;bleeding-edge&quot; version of your mod for the given Minecraft version</span></span><br><span class="line">    <span class="attr">&quot;&lt;mcversion&gt;-recommended&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;modversion&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// Declare the latest &quot;stable&quot; version of your mod for the given Minecraft version</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>值得注意的是：</p><ul><li><code>homepage</code> 的地址在使用者的 mod 需要更新时会显示出来，注意隐私；</li><li>Forge 使用一套内置算法来判断当前版本和 update JSON 的版本哪个更新，大多数情况下应该没问题，如果有疑惑可以查阅 <code>ComparableVersion</code> 类或 <a href="https://semver.org/">Semantic Versioning</a>；</li><li>上面的 <code>changelog</code> 字符串可以使用 <code>\n</code>，也可以给用户提供一个网站让他们在网站上详细看；</li></ul><h3 id="0-8-Mod-进阶调试"><a href="#0-8-Mod-进阶调试" class="headerlink" title="0.8 Mod 进阶调试"></a>0.8 Mod 进阶调试</h3><p>Minecraft 自身提供了一个 Debug Profiler，能够分析出耗时的代码块，这对于 mod 开发者和服务器管理员非常有用；</p><p>开始分析命令：<code>/debug start</code>，结束分析命令：<code>/debug end</code>；</p><ul><li><p>建议最少给 Debug Profiler 的分析留出 1 min 时间，时间越多，分析约准确；</p></li><li><p>要分析的实体（Entities）需要在当前世界中存在，不然分析不到它；</p></li></ul><p>在结束分析后，会自动生成 <code>profile-results-yyyy-mm-dd_hh.mi.ss.txt</code>，</p><p>文件格式：<code>&lt;the depth of the section&gt; | &lt;the name of the section&gt; - &lt;the percentage of time it took in relation to it’s parent&gt;/&lt;how much time it took from the entire tick&gt;</code></p><h3 id="0-9-第一个-Mod：跑通流程"><a href="#0-9-第一个-Mod：跑通流程" class="headerlink" title="0.9 第一个 Mod：跑通流程"></a>0.9 第一个 Mod：跑通流程</h3><p>上面说了很多内容，现在让我们以一个没有内容的测试 mod 来实际跑一遍：</p><p><strong>step 1.</strong> 在 <code>src/main/java</code> 下创建一个包，例如 <code>com.test</code>，创建 Java 类 <code>HelloMC</code>；</p><p><strong>step 2.</strong> 根据 0.6 节中介绍的 modid，<strong>需要用 <code>@Mod(&lt;modid&gt;)</code> 修饰 mod 的 entry point 类</strong>，保持：<strong>@Mod 修饰值、<code>mods.toml</code> 的 <code>modid</code>、<code>build.gradle</code> 的 <code>examplemod</code> 三者一致</strong>。因此，我们需要给 <code>HelloMC</code> 加 <code>@Mod()</code> annotation。为了方便，我们另外创建一个类，专门存储全局变量，就定为 <code>Utils</code>（你也可以不用，看自己的编码习惯）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HelloMC.java</span></span><br><span class="line"><span class="keyword">package</span> com.test.HelloMC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.minecraftforge.fml.common.Mod;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mod(Utils.MOD_ID)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloMC</span> &#123;</span><br><span class="line">    <span class="comment">// 这里先空着，因为没学</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: Utils.java</span></span><br><span class="line"><span class="keyword">package</span> com.test.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MOD_ID</span> <span class="operator">=</span> <span class="string">&quot;mymod&quot;</span>;        <span class="comment">// 自己写 modid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>step 3.</strong> 现在去写 <code>mods.toml</code>，注意填写 <code>mod_id</code>：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面使用的 @Mod 就在这个 modLoader 中，和 loaderVersion 不用改</span></span><br><span class="line">   <span class="attr">modLoader</span>=<span class="string">&quot;javafml&quot;</span></span><br><span class="line">   <span class="attr">loaderVersion</span>=<span class="string">&quot;[36,)&quot;</span></span><br><span class="line">   <span class="comment"># 自己选证书：https://choosealicense.com/.</span></span><br><span class="line">   <span class="attr">license</span>=<span class="string">&quot;All Rights Reserved&quot;</span></span><br><span class="line">   <span class="comment"># 自己定义 issue 提问网站，可选</span></span><br><span class="line">   <span class="attr">issueTrackerURL</span>=<span class="string">&quot;https://github.com/MinecraftForge/MinecraftForge/issues&quot;</span></span><br><span class="line">   <span class="comment"># 暂时用不到，不管它</span></span><br><span class="line">   <span class="attr">showAsResourcePack</span>=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">   <span class="section">[[mods]]</span></span><br><span class="line">     <span class="attr">modId</span>=<span class="string">&quot;yourID&quot;</span></span><br><span class="line">     <span class="attr">version</span>=<span class="string">&quot;1.0.0.0&quot;</span></span><br><span class="line">     <span class="attr">displayName</span>=<span class="string">&quot;Example Mod&quot;</span></span><br><span class="line">     </span><br><span class="line">     <span class="attr">updateJSONURL</span>=<span class="string">&quot;minecraftforge.net/versions.json&quot;</span>    <span class="comment"># 中间这块都是可选的</span></span><br><span class="line">     <span class="attr">displayURL</span>=<span class="string">&quot;minecraftforge.net&quot;</span></span><br><span class="line">     <span class="attr">logoFile</span>=<span class="string">&quot;logo.png&quot;</span></span><br><span class="line">     <span class="attr">credits</span>=<span class="string">&quot;I&#x27;d like to thank my mother and father.&quot;</span></span><br><span class="line">     <span class="attr">authors</span>=<span class="string">&quot;Author&quot;</span></span><br><span class="line">     </span><br><span class="line">     <span class="attr">description</span>=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">     Lets you craft dirt into diamonds. This is a traditional mod that has existed for eons. It is ancient. The holy Notch created it. Jeb rainbowfied it. Dinnerbone made it upside down. Etc.</span></span><br><span class="line"><span class="string">     &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的依赖是必要的，别碰</span></span><br><span class="line">     <span class="section">[[dependencies.yourID]]</span></span><br><span class="line">       <span class="attr">modId</span>=<span class="string">&quot;forge&quot;</span></span><br><span class="line">       <span class="attr">mandatory</span>=<span class="literal">true</span></span><br><span class="line">       <span class="attr">versionRange</span>=<span class="string">&quot;[36,)&quot;</span></span><br><span class="line">       <span class="attr">ordering</span>=<span class="string">&quot;NONE&quot;</span></span><br><span class="line">       <span class="attr">side</span>=<span class="string">&quot;BOTH&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="section">[[dependencies.yourID]]</span></span><br><span class="line">       <span class="attr">modId</span>=<span class="string">&quot;minecraft&quot;</span></span><br><span class="line">       <span class="attr">mandatory</span>=<span class="literal">true</span></span><br><span class="line">       <span class="attr">versionRange</span>=<span class="string">&quot;[1.16.5,1.17)&quot;</span></span><br><span class="line">       <span class="attr">ordering</span>=<span class="string">&quot;NONE&quot;</span></span><br><span class="line">       <span class="attr">side</span>=<span class="string">&quot;BOTH&quot;</span></span><br></pre></td></tr></table></figure><p><strong>step 4.</strong> 再到 <code>build.gradle</code> 中，将所有 <code>examplemod</code> 换成自己的 modid，修改个性化内容，然后构建！</p><p><strong>step 5.</strong> 启动 IDEA 上的任务设置 “RunClient”，进入游戏查看自己的 mod 是否已经显示！</p><h3 id="0-10-事件系统"><a href="#0-10-事件系统" class="headerlink" title="0.10 事件系统"></a>0.10 事件系统</h3><p>早在 0.3 节说明运行模式的时候，我们提到了 <code>Mod</code> 总线和 <code>Forge</code> 总线，这里在开发前必须要说清楚。Forge 自己的事件系统内是独立于 Minecraft 的事件系统的。</p><p>使用 Forge 事件系统的方法有 2 种，先看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEventHandler</span> &#123;</span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pickupEvent</span><span class="params">(EntityItemPickupEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Item picked up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个类 <code>TestEventHandler</code>，里面有个实例方法 <code>pickupEvent()</code>。注意 <code>@SubscribeEvent</code> 标记，<strong>它的作用就是指示下方的方法为事件处理器</strong>，而它监听的事件类型由它的参数决定（<code>EntityItemPickupEvent</code>，实体捡起物品这个事件）。</p><p>但是只是让他声明为事件处理器还不够，还需要在合适的位置将含有事件处理器的类<strong>实例化</strong>，并<strong>注入事件总线中</strong>。是 <code>Forge</code> 总线还是 <code>Mod</code> 总线？</p><ul><li><p><code>Mod</code> 总线：负责游戏的生命周期事件，也就是<strong>初始化过程的事件</strong>；注册方法：<code>FMLJavaModLoadingContext.get().getModEventBus().register(&lt;subscribed_event_obj&gt;)</code>；</p></li><li><p><code>Forge</code> 总线：负责的就是除了生命周期事件外的所有事件；注册方法：<code>MinecraftForge.EVENT_BUS.register(&lt;subscribed_event_obj&gt;)</code>；</p></li></ul><p>显然，上面 “实体捡起物品” 的事件在初始化过程之外，所以加入 <code>Forge</code> 总线：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MinecraftForge.EVENT_BUS.register(<span class="keyword">new</span> <span class="title class_">TestEventHandler</span>());</span><br></pre></td></tr></table></figure><p>显然这样注册的方法比较麻烦，被称为 “实例注册方式”。还有一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mod</span>.EventBusSubscriber(modid = <span class="string">&quot;mymod&quot;</span>, bus = Bus.FORGE, value = Dist.CLIENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStaticClientOnlyEventHandler</span> &#123;</span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">drawLast</span><span class="params">(RenderWorldLastEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管传给注解的参数（都是可选的），我们发现，这个类中的事件处理器是<strong>静态的</strong>（另注：由于是渲染事件，所以仅客户端）。这里，我们就可以在整个类前加上注解 <code>@Mod.EventBusSubscriber([modid, bus, value])</code>，表示将类中的所有事件处理器都加入指定 modid、总线、端中。</p><p>这里补充，如果是 <code>Mod</code> 总线，那么 <code>bus = Bus.MOD</code>，更多信息可以转到 <code>@Mod.EventBusSubscriber()</code> 的源码查看。</p><h2 id="Chapter-1-创建物品"><a href="#Chapter-1-创建物品" class="headerlink" title="Chapter 1. 创建物品"></a>Chapter 1. 创建物品</h2><h3 id="1-1-第一个物品"><a href="#1-1-第一个物品" class="headerlink" title="1.1 第一个物品"></a>1.1 第一个物品</h3><p>本节了解，创建一个物品就 3 步【所有物品都是这样】：</p><ol><li>创建自己的物品类，一般继承于原版的物品的类 <code>Item</code>；</li><li>在合适的位置实例化这个物品；</li><li>将此物品对象注册进游戏；</li></ol><p>我们先以一个原版游戏中没有 “黑曜石锭” 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianIngot</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObsdianIngot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Properties</span>().group(ItemGroup.MATERIALS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就写了一个构造函数，向父类的构造函数传递了一个 <code>Properties</code> 类的对象，而这个 <code>Properties</code> 对象调用了 <code>group()</code>，<strong>表示设置物品所在组为 <code>Materials</code> 组（杂项栏）</strong>。</p><p>传给父类的 <code>Properties</code> 对象的作用是规定了物品的一些属性，比如：是不是食物，或者这个物品在创造模式的哪一个物品栏。这里的 <code>group()</code> 方法就是设置了物品在创造模式的杂项栏。</p><p>如果不调用 <code>group()</code> 方法设置，那么这个物品就不会出现在创造模式物品栏，只能用 <code>/give</code> 获取；</p><p>然后是实例化 + 注册。现在的 <code>Forge</code> 引入了 <code>DeferredRegister</code>的机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DeferredRegister&lt;Item&gt; item_reg = </span><br><span class="line">        DeferredRegister.create(ForgeRegistires.ITEMS, Utils.MOD_ID);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsdianIngot = </span><br><span class="line">        item_reg.register(<span class="string">&quot;obsidian_ingot&quot;</span>, ObsidianIngot::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先使用 <code>DeferredRegister</code> 泛型类的静态方法 <code>create(&lt;ForgeRegistries.TYPE&gt;, &lt;mod_id&gt;)</code> 向 <code>mod_id</code> 的 mod 创建了一个 <code>DeferredRegister&lt;Type&gt;</code>  对象，表示<strong>这是专门注册 <code>Type</code> 类型实体的类</strong>。</p><p>紧接着告诉这个对象要注册 “注册名为 ‘obsdian_ingot’（不能大写）、其对象构造方法为 <code>ObsidianIngot::new</code>” 的一个类的 <code>supplier</code>。</p><p>最后，由于这个 <code>DeferredRegister</code> 泛型类帮助我们注册物品需要依赖<strong>注入事件</strong>。显然注册是一种初始化的事件，所以将 <code>DeferredRegister</code> 对象注入 <code>Mod</code> 总线（我们以 0.9 中的项目为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mod(Utils.MOD_ID)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloMC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloMC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// DeferredRegister 的 register 方法如果参数是总线，就将自己注入总线中</span></span><br><span class="line">        ItemRegistry.item_reg.register(</span><br><span class="line">            <span class="comment">// 这里前面说过，获取 Mod 总线</span></span><br><span class="line">            FMLJavaModLoadingContext.get().getModEventBus()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会发现新的、没有材质的物品出现在创造模式的物品栏中。</p><h3 id="1-2-物品的模型和材质"><a href="#1-2-物品的模型和材质" class="headerlink" title="1.2 物品的模型和材质"></a>1.2 物品的模型和材质</h3><p>一个物品被注册后，还应该指定它的模型和材质。这种指定方式也是固定的，记忆即可。下面以上面的 <code>ObsidianIngot</code> 为例。</p><p>第一步，在 <code>src/main/resources</code> 创建 <code>assets</code> 目录，表示这个 mod 存储资源的位置。并将目录补充为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resources/</span><br><span class="line">├── META-INF/</span><br><span class="line">│   └── mods.toml</span><br><span class="line">├── assets/</span><br><span class="line">│   └── mymod/        # 你的 modid</span><br><span class="line">│       ├── models/</span><br><span class="line">│       │   └── item/    # MC 中要求这个目录名，不能改，表示 item（物品）类型</span><br><span class="line">│       └── textures/</span><br><span class="line">│           └── item/</span><br><span class="line">└── pack.mcmeta</span><br></pre></td></tr></table></figure><p>一定要创建 <code>pack.mcmeta</code>，这相当于为 mod <strong>规定了资源包</strong>。只有这么做，MC 才能发现 <code>assets</code> 中的资源。格式也是 <code>JSON</code>，模板：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">  <span class="attr">&quot;pack&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pack_format&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span>    <span class="comment">// 看官网，pack_format = 10 时支持 MC 1.20 以下的版本</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Resource Pack&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;language&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;LANG_COUNTRY&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Custom Language&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Country/Region name&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bidirectional&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>第二步，在 <code>models/item</code> 的目录中创建 <code>obsidian_ingot.json</code>，文件名需要和之前<strong>物品注册名</strong>相同。</p><p><code>item</code>（物品类）模型的 JSON 文件的模板如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 父模型，即由什么模型加载而来</span></span><br><span class="line">    <span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/generated&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;textures&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">// 指定了最底层的材质（格式在 0.4 中已经叙述）</span></span><br><span class="line">        <span class="attr">&quot;layer0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mymod:item/obsidian_ingot&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>textures/item</code> 的目录中放入自己设计的材质 <code>obsidian_ingot.png</code>（游戏中 1:1，<strong>仅贴图最好不要大于 32×32 像素</strong>），文件名也是物品注册名。</p><p>最后启动游戏就会发现游戏自动读取了模型和材质。</p><p>注：自己制作模型的网站戳 <a href="https://blockbench.net/">这里</a>；</p><h4 id="补充：BlockBench-笔记"><a href="#补充：BlockBench-笔记" class="headerlink" title="补充：BlockBench 笔记"></a>补充：BlockBench 笔记</h4><ul><li>绑骨：按照父级模型生长方向移动、旋转等操作，可以用作设计动画；</li><li>顶点识别；</li><li>隐藏的菜单：x/y/z 轴翻转；</li><li>缩放参数：可以在不改变材质的情况下改变模型大小，允许小数；</li><li>大纲视图的锁定：可以防止误操作；</li><li>背景图的作用大部分是用来拾色的；</li><li>后期添加模型过大，放不下空白材质时，可以为材质调整大小；</li></ul><h3 id="1-3-Item-类和-ItemStack-类"><a href="#1-3-Item-类和-ItemStack-类" class="headerlink" title="1.3 Item 类和 ItemStack 类"></a>1.3 <code>Item</code> 类和 <code>ItemStack</code> 类</h3><p>前面两节叙述了加入普通自定义物品（<code>item</code>）的大致流程。现在深入一下更抽象的层面，考虑这些物品背后的类，以便我们进一步对它们进行自定义。</p><p>首先，很方便理解的是 <code>Item</code> 类，就是规定每种物品属性的类。细心的同学可能会提问，我们之前创建的 <code>ObsidianIngot</code> 这个类在游戏的框中显示的数量呢？一组应该是多少个呢？<code>Item</code> 类都没有定义。</p><p>这是因为，设计者考虑到 <code>item</code> 的有些信息不会因为数量、耐久等参数的改变而改变，例如：</p><ul><li>使用/放置（左键/右键）的行为；</li><li>在客户端上显示的名称及 Tooltip；</li><li>合成配方；</li><li>et cetera；</li></ul><p>这些抽象的属性都在 <code>Item</code> 类中得到定义；而数量、是否有/有多少耐久等信息，就单独提出去打包为一个类，其名曰 <code>ItemStack</code>。游戏中，玩家的物品栏、背包、手持物品等，<strong>都是 <code>ItemStack</code> 的实例</strong>。</p><p>所以，可以将 <code>ItemStack</code> 和 <code>Item</code> 的关系看作<strong>类的聚集</strong>，在对 <code>ItemStack</code> 可以调用 <code>getItem()</code> 实例方法来获得其中含有的 <code>Item</code> 对象。</p><h4 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h4><p>另外有个极其重要的概念——“<strong>享元（Flyweight Pattern）</strong>”，即<strong>一种特定物品只对应一个实例</strong>，而 <code>Item</code> 就是一个享元。这意味着，以 <code>Apple</code> 类为例，你在游戏里见到<strong>所有</strong>苹果都是 <code>Apple</code> 类的唯一实例。正因如此，我们在编写 mod 中，可以直接用 <code>==</code>（即  <code>&lt;ItemStack_obj&gt;.getItem() == &lt;Item_obj&gt;</code>）来判断 <code>Item</code> 种类，不用担心 <code>==</code> 比较的是地址。</p><h4 id="Item-AIR"><a href="#Item-AIR" class="headerlink" title="Item.AIR"></a><code>Item.AIR</code></h4><p>还有一件事，由于 <code>ItemStack</code> 是 <code>non-null</code> 的属性，永远是非空引用，所以 <strong>MC 中 “空的” 栏的 <code>ItemStack</code> 所含的 <code>Item</code> 对象是个特殊对象：<code>Items.AIR</code></strong>。判断 <code>ItemStack</code> 对应的栏目物品是否为空时，应该使用专用的实例函数 <code>isEmpty()</code>，不能直接判断是否为 <code>null</code>。</p><h3 id="1-4-自定义物品组"><a href="#1-4-自定义物品组" class="headerlink" title="1. 4 自定义物品组"></a>1. 4 自定义物品组</h3><p>物品组可以形象地理解为创造模式物品栏的分栏。我们在最开始就提到的类 <code>ItemGroup</code>，所以自定义物品组很简单——就写一个继承于 <code>ItemGroup</code> 类的子类就行。</p><p>这个继承的类只需要写<strong>两个地方</strong>，一个是构造函数，直接使用父类的即可，<strong>第一个参数是物品组的名称 <code>String</code></strong>。（这个组就以 “ObsidianGroup” 为例）</p><p>另一个是重写类里面的 <code>createIcon()</code> 实例方法（实际用途是创建物品栏的图标），要求返回一个 <code>ItemStack</code> 实例（毕竟需要将物品呈现在物品栏中），这个也很简单，用 <code>ItemStack</code> 构造函数构造个实例就行。<strong><code>ItemStack</code> 构造函数的第一参数就是已注册的 <code>Item</code> 实例对象</strong>。</p><blockquote><p>从哪获取已注册的 <code>Item</code> 实例？简单，之前我们注册完物品后，<code>DeferredRegister::register</code> 方法不是返回了一个 <code>RegisterObject&lt;Item&gt;</code>，它就是包裹了注册信息的 <code>Item</code>，直接用 <code>get()</code> 实例方法就能返回已注册的 <code>Item</code> 实例。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianGroup</span> <span class="keyword">extends</span> <span class="title class_">ItemGroup</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObsidianGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;obsidian_group&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemStack <span class="title function_">createIcon</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ItemRegistry.obsidianIngot 对象在 1.1 中定义，忘了回去看</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemStack</span>(ItemRegistry.obsidianIngot.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个简单的物品组类就做好了。但是想要将它显示在游戏里，还要将它在合适的位置实例化。</p><p>我们再定义一个类，专门存放 mod 中实例化的 <code>ItemGroup</code> 的类，就叫 <code>ModGroup</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModGroup</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ItemGroup</span> <span class="variable">og_group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObsidianGroup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在物品类初始化的时候，用 <code>Properties::group()</code> 实例方法将物品加入 <code>og_group</code> 这个实例即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianIngot</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObsidianIngot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Properties</span>().group(ModGroup.itemGroup));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-食物"><a href="#1-5-食物" class="headerlink" title="1.5 食物"></a>1.5 食物</h3><p>食物就是一种特殊的 <code>Item</code>，也继承于 <code>Item</code> 来创建，只是比普通 <code>Item</code> 多几个属性（包括专门的类 <code>Food</code> 作为属性）。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianApple</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="comment">// 定义食物的属性，使用 Food 类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> (</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Food</span>.Builder().saturation(<span class="number">10</span>)</span><br><span class="line">                          .hunger(<span class="number">20</span>)</span><br><span class="line">                          <span class="comment">// 使用接口创建 Supplier&lt;EffectInstance&gt;</span></span><br><span class="line">                          .effect(() -&gt; <span class="keyword">new</span> <span class="title class_">EffectInstance</span>(Effects.POISON, <span class="number">3</span>*<span class="number">20</span>, <span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">                          .build();</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为 Java 基础补充知识：<code>Java</code> <code>Supplier</code>是一个功能接口，代表结果的提供者，<strong>存在于 <code>java.util.function</code> 包</strong>。常用方法是 <code>get()</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用来返回一个<strong>特定</strong>的结果对象。我们可以用 <code>lambda</code> 表达式，例如上面 <code>() -&gt; new EffectInstance(Effects.POISON, 3*20, 1)</code> 创建一个调用返回新 <code>EffectInstance</code> 对象的匿名函数。这个格式得到的左值就是 <code>supplier</code>。</p><p>也可以定义一个完整的匿名函数：<code>() -&gt; &#123; return XXX; &#125;</code></p></blockquote><p>其中，<code>Food::Builder()</code> 静态方法初始化 <code>Food.Builder</code> 类实例，用来在 <code>Food</code> 属性对象生成前设置好参数，支持 <code>saturation()</code>、<code>hunger()</code>、<code>effect()</code> 方法。</p><p>需要说明的是，其中 <code>effect()</code> 方法的<strong>第一参数</strong>是 <code>Supplier&lt;EffectInstance&gt;</code>，<strong>第二参数</strong>是<strong>触发的概率</strong>。<code>EffectInstance</code> 类的初始化方法第一参数是 <strong><code>Effects</code> 类的枚举量</strong>（含有 MC 中几乎所有效果），第二参数是效果持续的游戏 Tick 时间，第三参数是对应的药水等级。</p><blockquote><p>一个游戏刻 <code>Tick</code> 就是主程序循环一次的时间，固定是 <code>0.05 s</code>；上面的 <code>3*20</code> 就是 3 秒。</p></blockquote><p>最后的 <code>Food.Builder::build()</code> 方法将 <code>Food.Builder</code> 及其中的设置构造为 <code>Food</code> 类的实例，可以在初始化物品时对 <code>Properties</code> 对象使用 <code>food()</code> 方法指定（和 <code>group()</code> 一样）。</p><p>接下来的物品注册、模型和材质都与普通 <code>Item</code> 相差无几。</p><h3 id="1-6-近战武器-和-工具"><a href="#1-6-近战武器-和-工具" class="headerlink" title="1.6 近战武器 和 工具"></a>1.6 近战武器 和 工具</h3><p><strong>MC 原版 1.16.5 的近战武器可以认为只有剑</strong>，如果想要自定义近战物品，就可以按剑的类的做法来做（入门不介绍攻击动画的制作，就复用剑的攻击动画）。</p><p><strong>MC 原版 1.16.5 的工具就是耳熟能详几件：稿子、铲子、斧头、锄头</strong>。</p><p>首先，细心的同学可以发现，木头、石头、铁、黄金和钻石种类的武器面板基础数据（除去附魔等加成的效率、耐久、伤害……）是不同的，并且损坏后修复的材料不同。但它们都是 “剑 / 稿 / 斧 / 锄 / 铲” 这个属性，所以这些额外的数据<strong>可以抽象为一个单独的类 / 枚举类型来管理</strong>，在初始化时再传给 “剑 / 稿 / 斧 / 锄 / 铲” 这个类。在 MC 中，它就是<strong>枚举类型 <code>ItemTier</code></strong>，即 “工具等级”（Tiered adj. 阶梯式的、分层的）。</p><p>官方选择了<strong>接口类</strong>来设计 <code>ItemTier</code>，而由于 Java 的枚举类型在能够大量定义常量的同时，允许添加方法，因此我们只需写一个枚举类来 <code>implements</code> 它。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ModItemTier</span> <span class="keyword">implements</span> <span class="title class_">ItemTier</span> &#123;</span><br><span class="line">    <span class="comment">// 规范来说，enum 内部先定义实例</span></span><br><span class="line">    OBSIDIAN(<span class="number">3</span>, <span class="number">2000</span>, <span class="number">10.0F</span>, <span class="number">4.0F</span>, <span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> harvestLevel;        <span class="comment">// 精准采集等级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxUses;            <span class="comment">// 最大耐久值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> efficiency;        <span class="comment">// 效率值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> attackDamage;    <span class="comment">// 伤害</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> enchantability;    <span class="comment">// 附魔能力</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法就是将属性值全部传进去</span></span><br><span class="line">    ModItemTier(<span class="type">int</span> harvestIn, <span class="type">int</span> maxUsesIn, <span class="type">float</span> effIn, <span class="type">float</span> attIn, <span class="type">int</span> enchantabilityIn) &#123;</span><br><span class="line">        <span class="built_in">this</span>.harvestLevel = harvestIn;</span><br><span class="line">        <span class="built_in">this</span>.maxUses = maxUsesIn;</span><br><span class="line">        <span class="built_in">this</span>.efficiency = effIn;</span><br><span class="line">        <span class="built_in">this</span>.attackDamage = attIn;</span><br><span class="line">        <span class="built_in">this</span>.enchantability = enchantabilityIn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面的部分别看它长，就是把 get 方法简单覆盖一下 -------------------|</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHarvestLevel</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.harvestLevel; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxUses</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.maxUses; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getEfficiency</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.efficiency; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getAttackDamage</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.attackDamage; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEnchantability</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.enchantability; &#125;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------------|</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 之前提到的，修复材料需要单独写一下</span></span><br><span class="line">    <span class="comment">// 但具体的合成表还需要以后写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Ingredient <span class="title function_">getRepairMaterial</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Ingredient.fromItems(ItemRegistry.obsidianIngot.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别问为什么要重新写属性并且 <code>override</code>。因为这是个 <code>enum</code> 类型，不存在继承的说法，只能 <code>implements</code>  方法。</p><p>再来看 “剑 / 稿 / 斧 / 锄 / 铲” 类的继承关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Item --&gt; TieredItem (有工具等级的 item) --&gt; SwordItem</span><br><span class="line">                |</span><br><span class="line">                └─--&gt;    ToolItem// 这里是下一节要说的 “工具”，也有工具等级</span><br><span class="line">                            ├─----------&gt; PickaxeItem</span><br><span class="line">                            ├─----------&gt; ShovelItem</span><br><span class="line">                            ├─----------&gt; AxeItem</span><br><span class="line">                            └─----------&gt; HoeItem</span><br></pre></td></tr></table></figure><p>这里简单到爆炸，只需要掌握这些类的初始化方法就行，以剑为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SwordItem</span><span class="params">(ItemTier tier_obj, <span class="type">int</span>, <span class="type">float</span>, Properties prop)</span>;</span><br></pre></td></tr></table></figure><p>像这里以黑曜石剑为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianSword</span> <span class="keyword">extends</span> <span class="title class_">SwordItem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObsidianSword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的 OBSIDIAN 是之前定义 enum ModItemTier 时创建的实例</span></span><br><span class="line">        <span class="comment">// ItemGroup.COMBAT 是战斗物品组，对应创造模式物品栏“铁剑”图标一栏</span></span><br><span class="line">        <span class="built_in">super</span>(ModIterTier.OBSIDIAN, <span class="number">3</span>, -<span class="number">2.4F</span>, <span class="keyword">new</span> <span class="title class_">Properties</span>().group(ItemGroup.COMBAT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SwordItem</code> 构造函数的第一参数 <code>ItemTier</code> 后面的两个参数分别是<strong>攻击伤害、攻击速度</strong>；</p><p>之后的模型、材质、物品注册也是完全和普通 <code>item</code> 相同。</p><p> 稿子、铲子、斧头、锄头也一样。</p><p>注意：以上数据面板理论上只要不溢出都可以自行设置。但如果想要写成好的 Mod，这边建议自己试试平衡性，再调整数值。</p><blockquote><p>你问为什么不介绍 “弓” 这种远程武器？这大概是因为 minecraft java 到处是高耦合度的代码（尤其是弓这个动作复杂的 item），哪怕仅修改拉弓速度都要引入 7~8 个包，故不再这里叙述。实在想要改，建议直接改材质 + 附魔；</p></blockquote><h3 id="1-7-可穿戴装备"><a href="#1-7-可穿戴装备" class="headerlink" title="1.7 可穿戴装备"></a>1.7 可穿戴装备</h3><p>和近战武器/工具类似，可穿戴装备也有 “工具等级” 来管理和装备位置无关的数据，这就是 <code>IArmorMaterial</code> <strong>接口类</strong>，我们模仿 1.6 中的 <code>ModItemTier</code> 用一个枚举类来自定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ObsidianArmorMaterial</span> <span class="keyword">implements</span> <span class="title class_">IArmorMaterial</span> &#123;</span><br><span class="line">    OBSIDIAN(</span><br><span class="line">        <span class="string">&quot;obsidian&quot;</span>, <span class="number">40</span>, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">5</span>&#125;, <span class="number">20</span>, SoundEvents.ITEM_ARMOR_EQUIP_DIAMOND, <span class="number">2.0F</span>, <span class="number">0.0F</span>, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Ingredient.fromItems(ItemRegistry.obsidianIngot.get());</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 下面是 IArmorMaterial 需要拥有的属性：</span></span><br><span class="line">                                                    <span class="comment">// 最大耐久数值数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] MAX_DAMAGE_ARRAY = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">13</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">11</span>&#125;;</span><br><span class="line">    <span class="comment">// 这个名字是给渲染端用的（也就是客户端），也是找材质用的名字。请确保此处、注册名、材质名三者写的是一个名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxDamageFactor;                <span class="comment">// 最大耐久衰减因数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] damageReductionAmountArray;    <span class="comment">// 减伤数组（保护效果）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> enchantability;                <span class="comment">// 附魔能力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SoundEvent soundEvent;            <span class="comment">// 穿着音效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> toughness;                    <span class="comment">// 文档没说，可以自己尝试</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> knockbackResistance;        <span class="comment">// 击退抵抗数值</span></span><br><span class="line">    <span class="comment">// 这个 LazyValue 可以理解为 Forge 包里面内含的一种容器，实现懒加载。泛型参数是懒加载的结果，而它初始化参数是对应泛型的 Supplier</span></span><br><span class="line">    <span class="comment">// 这个属性相当于 ItemTier 中的 getRepairMaterial()</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LazyValue&lt;Ingredient&gt; repairMaterial;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数还是就把之前的属性给它们赋值一遍</span></span><br><span class="line">    ObsidianArmorMaterial(</span><br><span class="line">        String armorName, <span class="type">int</span> maxDamageF, <span class="type">int</span>[]damageReductionArray,</span><br><span class="line">        <span class="type">int</span> enchantAbility, SoundEvent se, <span class="type">float</span> tough, <span class="type">float</span> knockResist,</span><br><span class="line">        Supplier&lt;Ingredient&gt; repairMaterialSupplier</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = armorName; <span class="built_in">this</span>.maxDamageFactor = maxDamageF;</span><br><span class="line">        <span class="built_in">this</span>.damageReductionAmountArray = damageReductionArray;</span><br><span class="line">        <span class="built_in">this</span>.enchantability = enchantAbility;</span><br><span class="line">        <span class="built_in">this</span>.soundEvent = se; <span class="built_in">this</span>.toughness = tough;</span><br><span class="line">        <span class="built_in">this</span>.knockbackResistance = knockResist;</span><br><span class="line">        <span class="built_in">this</span>.repairMaterial = <span class="keyword">new</span> <span class="title class_">LazyValue</span>&lt;&gt;(repairMaterialSupplier);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面实现 IArmorMaterial 接口，只要给出所有的 get 方法就行。注意名字和参数。</span></span><br><span class="line">    <span class="comment">// 注意，getName 因为是为客户端准备的函数，所以加上 annotation @OnlyIn 就行</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDurability</span><span class="params">(EquipmentSlotType slotIn)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MAX_DAMAGE_ARRAY[slotIn.getIndex()] * <span class="built_in">this</span>.maxDamageFactor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDamageReductionAmount</span><span class="params">(EquipmentSlotType slotIn)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.damageReductionAmountArray[slotIn.getIndex()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEnchantability</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.enchantability;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SoundEvent <span class="title function_">getSoundEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.soundEvent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Ingredient <span class="title function_">getRepairMaterial</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.repairMaterial.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnlyIn(Dist.CLIENT)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getToughness</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toughness;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getKnockbackResistance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.knockbackResistance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，和其他 item 一样设置可穿戴装备对应的对象，并且注册。</p><p>但是！一般情况我们无需继承不同的类，只需要创建 <code>ArmorItem</code> 类的不同实例，就能获得不同部位的 item 对象。这多半是因为可穿戴装备是盔甲，都设计成一套，例如注册时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回忆一下，item_reg 是之前在 ItemRegistry 类中定义的 DeferredRegister 类的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsidianHelmet = item_reg.register(<span class="string">&quot;obsidian_helmet&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ArmorItem</span>(ModArmorMaterial.OBSIDIAN, EquipmentSlotType.HEAD, (<span class="keyword">new</span> <span class="title class_">Item</span>.Properties()).group(ModGroup.itemGroup)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsidianChestplate = item_reg.register(<span class="string">&quot;obsidian_chestplate&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ArmorItem</span>(ModArmorMaterial.OBSIDIAN, EquipmentSlotType.CHEST, (<span class="keyword">new</span> <span class="title class_">Item</span>.Properties()).group(ModGroup.itemGroup)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsidianLeggings = item_reg.register(<span class="string">&quot;obsidian_leggings&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ArmorItem</span>(ModArmorMaterial.OBSIDIAN, EquipmentSlotType.LEGS, (<span class="keyword">new</span> <span class="title class_">Item</span>.Properties()).group(ModGroup.itemGroup)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsidianBoots = item_reg.register(<span class="string">&quot;obsidian_boots&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ArmorItem</span>(ModArmorMaterial.OBSIDIAN, EquipmentSlotType.FEET, (<span class="keyword">new</span> <span class="title class_">Item</span>.Properties()).group(ModGroup.itemGroup)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在传给 <code>DeferredRegister&lt;Item&gt;::register()</code> 的第二参数不再是类自带的 <code>new</code> 方法，而是临时写的匿名函数，利用已存在的类 <code>ArmorItem</code> 的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一参数是之前定义的 可穿戴装备的“等级枚举类”</span></span><br><span class="line"><span class="comment">// 第二参数是盔甲的部位，会针对性读取材质的某一区域</span></span><br><span class="line"><span class="comment">// 第三参数是原始的 item 对象的 supplier</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArmorItem</span><span class="params">(IArmorMaterial material, EquipmentSlotType type, Supplier&lt;Item&gt; item)</span>;</span><br></pre></td></tr></table></figure><p>现在最后一件事需要注意，<strong>就是盔甲的材质添加和其他 item 不一样</strong>。</p><p><strong>首先</strong>从前面共用一个类可以看出，这里<strong>盔甲的材质也在一个图中</strong>。说 “一个图” 不是很准确，准确来说是<strong>穿着状态的盔甲全套一组图，物品栏中的盔甲又是另一组图</strong>。所以这里需要两组材质图，分布在不同 “<code>layer</code>” 中。因此，如果想自己创作，还需要专门的软件，例如上面提到的 blockbench；</p><p><strong>其次</strong>，minecraft 自己把盔甲<strong>穿着</strong>的材质写死到 <code>minecraft:/</code> 资源作用域下，这意味着，我们不能在原来的地方加材质图，应该新建一个 <code>minecraft</code> 目录；而同时盔甲在物品栏的贴图也要自己设计，和普通 item 一样加 model json 和 扁平材质：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">resources/</span><br><span class="line">├── META-INF/</span><br><span class="line">│   └── mods.toml</span><br><span class="line">├── assets/</span><br><span class="line">│   ├── mymod/        # 你的 modid，之前材质存放的地方（作用域为 mymod:/）</span><br><span class="line">│   |   ├── models/</span><br><span class="line">│   |   │   └── item/                    # 盔甲物品栏图标模型 json 存放位置</span><br><span class="line">│   |   └── textures/</span><br><span class="line">│   |       └── item/                    # 盔甲物品栏材质图片存放位置</span><br><span class="line">|    |</span><br><span class="line">|    └── minecraft/# 新建的目录，材质作用域是 minecraft:/</span><br><span class="line">|            └── textures/</span><br><span class="line">|                    └── models/</span><br><span class="line">|                            └── armor/# 盔甲穿着材质图片存放位置</span><br><span class="line">|                                    └── ...</span><br><span class="line">|            </span><br><span class="line">└── pack.mcmeta</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，盔甲材质图命名格式：<code>&lt;Ingredient名称ID&gt;_layer_1</code>（穿着贴图）和 <code>&lt;Ingredient名称ID&gt;_layer_2</code>（物品栏贴图）；</p><h3 id="1-8-Item-属性重写"><a href="#1-8-Item-属性重写" class="headerlink" title="1.8 Item 属性重写"></a>1.8 Item 属性重写</h3><p>现在回忆一下，在 <code>minecraft</code> 中拉弓，是不是随着时间延长，弓的贴图会变化？这是怎么做到的呢？<strong>这里利用了模型 JSON 中的 <code>&quot;overrides&quot;</code> 项的设定</strong>，我们来看原版 minecraft 弓的模型 JSON 的一部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">&quot;overrides&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;pulling&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/bow_pulling_0&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;pulling&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;pull&quot;</span><span class="punctuation">:</span> <span class="number">0.65</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/bow_pulling_1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;pulling&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;pull&quot;</span><span class="punctuation">:</span> <span class="number">0.9</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/bow_pulling_2&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>overrides</code> 配置项中，可以看到许多组类似这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pulling&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/bow_pulling_0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>的组，这好理解，<code>predicate</code> 项就是编程语言中的 IF（如果判断），在其中的是<strong>条件对</strong>，如果满足了条件对，那么模型和材质会采用同组中的 <code>model</code> 项对应的材质。</p><p>按照这个原理，我们可以设计一种 “根据堆叠数量变色” 的特殊 item。这种 item 的类的定义和普通 item 一样，但<strong>注册</strong>有所差别：<strong>需要向 <code>MOD</code> 总线中添加 <code>propertyOverrideRegistry</code> 的特殊事件</strong>，用来初始化并在游戏中监听物品变化，及时覆盖材质。</p><p>假设我们注册好的对象叫：<code>RegisterObject&lt;Item&gt; magicIngot</code>，那么需要写这么个类来作为属性覆盖的事件处理器：</p><blockquote><p><strong>这是我们第一次向总线中加入事件，不知道含义的可以回到 0.10 事件系统 这节复习一下</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mod</span>.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD, value = Dist.CLIENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyRegistry</span> &#123;</span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">propertyOverrideRegistry</span><span class="params">(FMLClientSetupEvent event)</span> &#123;</span><br><span class="line">        event.enqueueWork(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                ItemModelProperties.registerProperty(</span><br><span class="line">                    ItemRegistry.magicIngot.get(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ResourceLocation</span>(Utils.MOD_ID, <span class="string">&quot;size&quot;</span>),</span><br><span class="line">                    (itemStack, clientWorld, livingEntity) -&gt; itemStack.getCount()</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 <code>@Mod</code> 和 <code>@SubscribeEvent</code> 就是经典的静态的事件注册方法，在 0.10 中介绍过；</p><p>那么在接收 <code>FMLClientSetupEvent</code> 事件中，方法 <code>propertyOverrideRegistry</code> 做了什么？</p><p>首先了解 <code>FMLClientSetupEvent</code> 是在 Java FML（Forge Model Loader）加载时必然触发的事件，所以这里的意思是<strong>在 Java FML 加载的时候运行 <code>PropertyRegistry#propertyOverrideRegistry</code> 这个方法</strong>，方法体就一行 <code>event.enqueueWork(Supplier&lt;?&gt;)</code>，这个可以理解为运行里面的 <code>enqueueWork</code> 的 supplier，我们唯一要做的就是把 overrides 这个 item 的情况注册一下。看看注册 item overrides 的函数声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ItemModelsProperties.registerProperty(</span><br><span class="line">    RegisterObject&lt;Item&gt;registered_item,</span><br><span class="line">    ResourceLocation        resourceLocation,</span><br><span class="line">    Supplier&lt;?&gt;                supplier<span class="comment">// ? 为 游戏中想要监测的属性类型</span></span><br><span class="line">);                                        <span class="comment">// supplier 就是调用获取数据的匿名函数</span></span><br></pre></td></tr></table></figure><p>注意，从上面的实例代码可以看出，这里的 <code>ResourceLocation</code> 的作用就是将获取的数据绑定到指定的资源名称，方便在接下来的 JSON 文件中使用并 <code>overrides</code>；它的初始化函数第二参数是资源名称，<strong>必须要记住</strong>，它和外面的 JSON 文件 <code>predicate</code> 条件中的键的名称要一致（如果用到的话）；</p><p>上面示例中的 <code>itemStack.getCount()</code> 就是获取 itemStack 的堆叠数量。</p><p>最后来看补充的模型文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/generated&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;textures&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;layer0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/iron_ingot&quot;</span>        <span class="comment">// 这里投机取巧，普通模式就用了铁锭的材质</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span>                                    <span class="comment">// 下面是 overrides 添加的部分</span></span><br><span class="line">    <span class="attr">&quot;overrides&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;&lt;modid&gt;:size&quot;</span><span class="punctuation">:</span>    <span class="number">16</span><span class="comment">// 这里注意，&lt;modid&gt; 替换为自己的 modid</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span>                            <span class="comment">// size 就是要求记住的、之前注册的名称</span></span><br><span class="line">            <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/gold_ingot&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>最后放上相应的 texture 试运行一下，应该能见到预期的效果。</p><h2 id="Chapter-EX-1-Localization-amp-Language"><a href="#Chapter-EX-1-Localization-amp-Language" class="headerlink" title="Chapter EX-1. Localization &amp; Language"></a>Chapter EX-1. Localization &amp; Language</h2><p>这一章不是必要的，主要讲述如何给之前的物品添加名称，并且提供语言支持。前面的章节创建的 item 名称都是内部的类名，开发者也许懂，但使用者可能会不理解。</p><p>这是 minecraft 为了提升可维护性，方便本地化，默认是没有物体名称，item 只有自己的<strong>编号（<code>transitionKey</code>）</strong>，也就是之前看到的和类名/包名/属性名很像的 <code>XXX.XXX.XXX</code>；</p><p>实际命名和语言的本地化则需要开发者自己完成，有两者方法，第一种比较简单，用 JSON 文件组成<strong>从前面的编号到名字的映射工作</strong>；第二种是使用 <code>I18n.format</code> 的方法，以后用到再提。</p><p>前者使用比较容易，首先找到前面说的 item 的编号（在 <code>Item</code> 类内部，大家可以自己到源码中找一找）；下一步，是创建一个 <code>lang</code> 目录，位置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resources/</span><br><span class="line">├── META-INF/</span><br><span class="line">│   └── mods.toml</span><br><span class="line">├── assets/</span><br><span class="line">│   ├── mymod/        # 你的 modid，之前材质存放的地方（作用域为 mymod:/）</span><br><span class="line">│   |   ├── models/</span><br><span class="line">│   |   ├── textures/</span><br><span class="line">|    |└── lang/# 这里是新建的 lang 目录</span><br><span class="line">|    |</span><br><span class="line">|    └── minecraft/</span><br><span class="line">|            </span><br><span class="line">└── pack.mcmeta</span><br></pre></td></tr></table></figure><p>在 <code>lang/</code> 中写一个简体中文的 JSON map，举个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: zh_cn.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;item.XXX.obsidian_ingot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑曜石锭&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;item.XXX.obsidian_apple&quot;</span><span class="punctuation">:</span><span class="string">&quot;黑曜石苹果&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;item.XXX.obsidian_sword&quot;</span><span class="punctuation">:</span><span class="string">&quot;黑曜石剑&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;itemGroup.obsidian_group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑曜石物品栏&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>键是之前说的 item 编号，后面是名字/翻译内容；</p><p>当然如果想让自己的 mod 国际化，还可以写 <code>zh_tw.json</code>、<code>en_us.json</code>，具体还有哪些语言可用，可以参阅 <a href="https://minecraft-zh.gamepedia.com/index.php?title=%E8%AF%AD%E8%A8%80&variant=zh#%E5%8F%AF%E7%94%A8%E8%AF%AD%E8%A8%80">wiki</a>；</p><p>To be continued……</p><p>—-EOF—-</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt;&lt;a href=&quot;https://docs.minecraftforge.net/en/1.16.x/&quot;&gt;Minecraft Forge Doc 1.16.x&lt;/a&gt;、&lt;a href=&quot;https://boson.v2mcdev.com/introducation/intro.html&quot;&gt;Boson 1.16（导论部分）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;注意：以 MC 版本 1.16.5 为例&lt;/i&gt;（同一大版本 1.16.x 的操作方式变化不大）&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Java" scheme="https://sjtuxhw.top/tags/Java/"/>
    
    <category term="Minecraft" scheme="https://sjtuxhw.top/tags/Minecraft/"/>
    
    <category term="Forge" scheme="https://sjtuxhw.top/tags/Forge/"/>
    
  </entry>
  
  <entry>
    <title>从C++入门Qt（三）</title>
    <link href="https://sjtuxhw.top/2023/08/30/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://sjtuxhw.top/2023/08/30/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2023-08-30T11:05:14.000Z</published>
    <updated>2023-09-19T05:18:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: C++ GUI Programming with Qt 4 (2nd Edition) </i></p><p><i>注意：本文章将讲解 <strong>Qt 5</strong> 入门知识，需要一定的 C++ 基础</i></p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p><strong>观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~</strong></p><hr><span id="more"></span><p>前面 4 章节的内容都是从具体项目来学习 Qt 的方法，也已经让我们初步认识了 Qt 的使用方法，下面的内容将按类分块来介绍，文章的篇幅也会短一些。</p><h1 id="Chapter-5-Qt-常用事件"><a href="#Chapter-5-Qt-常用事件" class="headerlink" title="Chapter 5. Qt 常用事件"></a>Chapter 5. Qt 常用事件</h1><p>Qt 中常用的 <code>Event</code> 主要有：<strong>鼠标事件</strong>、<strong>键盘事件</strong>、<strong>内部事件</strong>。其中内部事件绝大多数都交给 <strong>信号-槽</strong> 来处理，少部分的内部事件在特定情况需要重写，例如 <code>QPaintEvent</code>（下一章说）、 <code>QCloseEvent</code> 关闭事件（实现关闭前确认）。前两个事件是输入事件，都继承于 <code>QInputEvent</code>。</p><h2 id="5-1-内部事件"><a href="#5-1-内部事件" class="headerlink" title="5.1 内部事件"></a>5.1 内部事件</h2><p>前面介绍过，对于内部事件（特指关闭事件），<code>QCloseEvent</code> 的使用方法也很简单，重写 <code>void QWidget::closeEvent(QCloseEvent* event)</code> 即可，如果调用了 <strong><code>event-&gt;accept()</code></strong>，表示控件接受关闭事件，正式关闭；而如果调用了 <strong><code>event-&gt;ignore()</code></strong>，则控件忽略关闭事件。</p><h2 id="5-2-鼠标事件"><a href="#5-2-鼠标事件" class="headerlink" title="5.2 鼠标事件"></a>5.2 鼠标事件</h2><blockquote><p>注意：鼠标滚轮另外归于 <code>QWheelEvent</code> 类。在最后会一笔带过。</p></blockquote><h3 id="5-2-1-简单介绍"><a href="#5-2-1-简单介绍" class="headerlink" title="5.2.1 简单介绍"></a>5.2.1 简单介绍</h3><p>Qt 的鼠标事件交由 <code>QMouseEvent</code> 处理，分为鼠标移动、左键 / 右键的单击、双击、释放。具体为何能够实现，归因于 <code>QWidget</code> 的信号-槽，它们会在鼠标在该控件区域发生特点行为时发出信号，进而传递 <code>QMouseEvent</code> 对象。</p><p>有一个重要的点需要阐释：鼠标<strong>移动事件</strong>只会在<strong>按下鼠标按键</strong>的情况下才会发生！除非通过<strong>显式调用 <code>QWidget::setMouseTracking()</code></strong>函数来开启鼠标轨迹，这种情况下只要鼠标指针在移动，就会产生一系列的鼠标移动事件。</p><h3 id="5-2-2-QMouseEvent-的传递方式"><a href="#5-2-2-QMouseEvent-的传递方式" class="headerlink" title="5.2.2 QMouseEvent 的传递方式"></a>5.2.2 <code>QMouseEvent</code> 的传递方式</h3><p>一个鼠标事件包含一些指定的接受标志 <code>flag</code> 用于指出该事件是否会被接收和处理 ，如果鼠标指针所在的父控件不接收该事件则可以调用函数 <code>QMouseEvent::ignore()</code> 予以忽略；</p><p>多个重叠的控件好比一个倒立的树，鼠标事件会沿着鼠标指针所在的父控件向上传递，直到某个控件调用 <code>QMouseEvent::accept()</code> 函数进行事件处理，否则该事件将被过滤销毁掉；</p><p>此外，<code>QWidget</code> 中的属性 <code>Qt::WA_NoMousePropagation</code> 能够改变这种传递行为。如果设置为 <code>true</code>，那么鼠标信号不会再向父控件传递。</p><h3 id="5-2-3-QMouseEvent-的使用"><a href="#5-2-3-QMouseEvent-的使用" class="headerlink" title="5.2.3 QMouseEvent 的使用"></a>5.2.3 <code>QMouseEvent</code> 的使用</h3><p>需要引入 <code>QMouseEvent</code> 类的头文件。通常通过重写下面的函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::mouseDoubleClickEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br></pre></td></tr></table></figure><p>具体 <code>QMouseEvent</code> 有如下获取位置实例方法（成员函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">QMouseEvent::pos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QMouseEvent::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QMouseEvent::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QPoint <span class="title">QMouseEvent::globalPos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QMouseEvent::globalX</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QMouseEvent::globalY</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>注：<code>QPoint</code> 类的方法也有 <code>QPoint::x()</code> 和 <code>QPoint::y()</code>，代表点对象在当前画布的位置。</p><p>如果鼠标事件还涉及处理移动窗口的坐标计算（pos 在窗口外），那么为了防止抖动可以使用 <code>QMouseEvent::globalPos()</code> 获取屏幕全局坐标。</p><p>还需要注意的问题，就是鼠标指针位置类 <code>QCursor</code> 的方法 <code>pos()</code> 和 这里鼠标事件 <code>globalPos()</code> 不一样，需要使用 <code>QWidget::mapToGlobal(pos())</code> 在窗口坐标和全局坐标间转换；</p><hr><p>鼠标事件除了记录位置，还记录了鼠标击键的方法，可以调用下面这些函数判断：</p><p>注意，<code>Qt::MouseButton</code> 是枚举类型，其取值都以十六进制存储，<strong>可以进行按位或的方法来多选</strong>。常见的值有：<code>Qt::NoButton</code>、<code>Qt::AllButtons</code>、<code>Qt::LeftButton</code>、<code>Qt::RightButton</code>、<code>Qt::MiddleButton</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是鼠标移动事件，那么此函数始终返回 Qt::NoButton</span></span><br><span class="line"><span class="function">Qt::MouseButton <span class="title">QMouseEvent::button</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和上面一个可以相互替代，不过这个函数更准，返回同时将触发的按键值**按位或**起来</span></span><br><span class="line"><span class="function">Qt::MouseButton <span class="title">QMouseEvent::buttons</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>正因为 <code>buttons()</code> 的结果是按位或起来，所以判断自然不是 <code>==</code>，而是<strong>按位与</strong>判断有没有特定的按键。</p><p>注：在 <code>QWidget::mouseDoubleClick()</code> 中，因为双击是同一按键，所以也能用 <code>QMouseEvent::button()</code> 来判断按键的。</p><h3 id="5-2-4-鼠标滚轮"><a href="#5-2-4-鼠标滚轮" class="headerlink" title="5.2.4 鼠标滚轮"></a>5.2.4 鼠标滚轮</h3><p>简单介绍 <code>QWheelEvent</code> 类，用的比较多的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QWheelEvent::delta</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>如果返回值大于 0，说明滚轮向下（远离使用者）；反之向上（接近使用者）。</p><h2 id="5-3-键盘事件"><a href="#5-3-键盘事件" class="headerlink" title="5.3 键盘事件"></a>5.3 键盘事件</h2><p>键盘事件交由 <code>QKeyEvent</code> 来处理。传递方式和鼠标事件几乎相同。在使用方面，键盘事件比鼠标简单，不存在移动、右击、双击的事件，就处理按下和释放两个事件，可以重写的函数有两个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::keyPressEvent</span><span class="params">(QKeyEvent* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::keyReleaseEvent</span><span class="params">(QKeyEvent* event)</span></span>;</span><br></pre></td></tr></table></figure><p>具体 <code>QKeyEvent</code> 有如下的实例方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Qt::Key <span class="title">QKeyEvent::key</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">Qt::KeyboardModifiers <span class="title">QKeyEvent::modifiers</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QKeyEvent::isAutoRepeat</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QKeyEvent::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>这里解释一下 <code>isAutoRepeat()</code>。众所周知，<strong>长按键盘的某个键，就相当于快速重复触发这个键（平时在编辑文本中应该感受到了）</strong>。而在 Qt 的键盘事件中，在控件中按一次键就<strong>各触发一次 <code>QKeyEvent</code> 按下和释放事件</strong>，长按也会快速触发 <code>QKeyEvent</code>，但有种方法能够辨别长按的行为——<code>isAutoRepeat()</code>，只有长按键盘的事件第一次会返回 <code>false</code>，快速触发的接下来所有事件都返回 <code>true</code>，直至物理上松开按键。利用这个函数，可以设计出 “不处理长按事件” 的逻辑（需要在按下和释放的处理函数中都写一下）。</p><p>其次，<code>Qt::Key</code> 也是枚举类型，其取值都以十六进制存储，值的格式为 <code>Qt::Key_&lt;keyName&gt;</code>：</p><p><code>Qt::Key_Escape</code>（Esc）、<code>Qt::Key_Tab</code>、<code>Qt::Key_Backspace</code>、<code>Qt::Key_Enter</code>、<code>Qt::Key_Insert</code>、<code>Qt::Key_Delete</code>、<code>Qt::Key_Pause</code>（对于键盘的 <code>Pause/Break</code>，和多媒体的 “暂停” 丝毫没有关系）、<code>Qt::Key_Print</code>、<code>Qt::Key_Home</code>、<code>Qt::Key_End</code>、<code>Qt::Key_[Left/Right/Up/Down]</code>、<code>Qt::Key_PageUp</code>、<code>Qt::Key_PageDown</code>、<code>Qt::Key_Shift</code>、<code>Qt::Key_Control</code>（MacOS 中的 <code>command</code> 键）、<code>Qt::Key_Alt</code>、<code>Qt::Key_Meta</code>（MacOS 中的 <code>Ctrl</code>，Windows 中的徽标键）、<code>Qt::Key_CapsLock</code>、<code>Qt::Key_NumLock</code>、<code>Qt::Key_ScrollLock</code>、<code>Qt::Key_[F1~35]</code>、<code>Qt::Key_Space</code>、<code>Qt::Key_[0-9]</code>、<code>Qt::Key_[A-Z]</code>……</p><p>多个键同时按下时，还可以使用 <code>count()</code> 返回本次 <code>QKeyEvent</code> 事件按键数量。</p><p>如果多个键按下时，伴随的是<strong>修饰键</strong>（例如 <code>shift</code>、<code>ctrl</code>、<code>alt</code> 等），可以用 <code>modifiers()</code> 查到。</p><p>修饰键有单独的枚举类型 <code>Qt::KeyboradModifiers</code>，值有：</p><p><code>Qt::NoModifier</code>、<code>Qt::ShiftModifier</code>、<code>Qt::ControlModifier</code>、<code>Qt::AltModifier</code>、<code>Qt::MetaModifier</code>……</p><p>举个例子，<strong>想要查到 <code>ctrl+M</code> 事件</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestWidget::keyPressEvent</span><span class="params">(QKeyEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">modifiers</span>() == Qt::ControlModifiers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">key</span>() == Qt::Key_M) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> QWidget::<span class="built_in">keyPressEvent</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后强调一个事，Qt 的键盘事件一次仅能捕捉一个按键 ！！！例如看似我“同时”按下 A 和 S 这两个键，实际上会先触发 <code>Qt::Key_A</code>/<code>Qt::Key_S</code> 中的一个，再触发另一个</strong>。</p><p>这对于想要判断<strong>非修饰键的组合键</strong>的同学来说可能有些麻烦——因为这需要设置一个容器，或者十六进制码进行存储，按下键存进去，松开键删除掉，然后统一判断这个存储的信息。</p><h1 id="Chapter-6-Qt-图形绘制"><a href="#Chapter-6-Qt-图形绘制" class="headerlink" title="Chapter 6. Qt 图形绘制"></a>Chapter 6. Qt 图形绘制</h1><p>Qt 所制作的几乎所有 GUI 上的按钮、编辑框等组件都是通过绘图得到的。Qt 的二维绘图基本功能是使用 <code>QPainter</code> 在绘图设备（包括 <code>QWidget</code>、<code>QPixmap</code> 等）上绘图，通过绘制一些基本的点、线、圆等基本形状组成需要的图形，得到的图形不可交互。</p><p>除了 <code>QPainter</code>，Qt 还提供 Graphics View 架构，使用 <code>QGraphicsView</code>、<code>QGraphicsScene</code>、<code>QGraphicsItem</code> 类来制作更多样复杂的、可交互的图形。</p><h2 id="6-1-QPainter-基本绘图"><a href="#6-1-QPainter-基本绘图" class="headerlink" title="6.1 QPainter 基本绘图"></a>6.1 <code>QPainter</code> 基本绘图</h2><h3 id="6-1-1-绘图区"><a href="#6-1-1-绘图区" class="headerlink" title="6.1.1 绘图区"></a>6.1.1 绘图区</h3><p>Qt 基本绘图系统基于 <code>QPainter</code>（绘图操作使用）、<code>QPaintDevice</code>（可以使用 <code>QPainter</code> 的抽象二维界面）、<code>QPaintEngine</code>（为 <code>QPainter</code> 提供各种设备上绘制的接口）类。</p><p>一般情况下不需要关注底层 <code>QPaintEngine</code>，除非想自定义一个可以绘制的设备类型。</p><p>常见的绘图设备有 <code>QWidget</code>、<code>QPixmap</code>、<code>QImage</code>，为 <code>QPainter</code> 提供了 “canvas”。</p><p>下面先以 <code>QWdiget</code> 这个绘图设备为例。</p><p>想在 <code>QWidget</code> 这一绘图设备上绘图很简单，重写以下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::paintEvent</span><span class="params">(QPaintEvent* event)</span></span>;</span><br></pre></td></tr></table></figure><p>这也是上一章提到的 “内部事件” 之一。利用 <code>QPaintEvent</code> 事件，在函数中创建 <code>QPaint</code> 对象，就可以在控件画布上绘图了。</p><p>当然，重写也是有讲究的，需要使用<strong>专用的宏 <code>Q_DECL_OVERRIDE</code></strong> 来声明这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestWidget::paintEvent</span><span class="params">(QPaintEvent* event)</span> Q_DECL_OVERRIDE</span>;</span><br></pre></td></tr></table></figure><p>再介绍一下绘图坐标系中的<strong>视口（viewport）坐标</strong>：<code>QWidget</code> 的左上角就是（0，0），向右是 x 轴正方向，向下是 y 轴正方向；绘图区宽度和高度分别由控件宽度、高度决定：<code>QWidget::width()</code>、<code>QWidget::height()</code>。</p><p>除了视口坐标，还有逻辑坐标和窗口坐标，以后介绍。</p><h3 id="6-1-2-绘图属性"><a href="#6-1-2-绘图属性" class="headerlink" title="6.1.2 绘图属性"></a>6.1.2 绘图属性</h3><p><code>QPainter</code> 具有 3 各重要属性：</p><ul><li><code>QPainter::pen</code>，是一个 <code>QPen</code> 对象，用于控制<strong>线条颜色、宽度、线型</strong>；</li><li><code>QPainter::brush</code>，是一个 <code>QBrush</code> 对象，用于设置一个区域的填充特性，可以设置<strong>填充颜色、填充方式、渐变特性</strong>，也可以指定图片做材质填充；</li><li><code>QPainter::font</code>，是一个 <code>QFont</code> 对象，用于绘制文字时设置<strong>文字样式、大小</strong>；</li></ul><p>下面以一个实例来介绍。假设 <code>TestWidget</code> 类是一个继承于 <code>QWidget</code>、已设计的一个类，只需要在其上绘制图案就完成任务，那么函数这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestWidget::paintEvent</span><span class="params">(QPaintEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个 QPainter 对象，与 TesWidget 对象关联、</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::TextAntialiasing);</span><br><span class="line">    <span class="type">int</span> W = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>();    <span class="comment">// 记录绘图区宽度和高度</span></span><br><span class="line">    <span class="type">int</span> H = <span class="keyword">this</span>-&gt;<span class="built_in">height</span>();</span><br><span class="line">    <span class="comment">// QRect 类是个二维图形类，初始化一个长方形，后文会详细介绍</span></span><br><span class="line">    <span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个指定的画笔</span></span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.<span class="built_in">setWidth</span>(<span class="number">3</span>);    <span class="comment">// 笔的线宽</span></span><br><span class="line">    pen.<span class="built_in">setColor</span>(Qt::red);    <span class="comment">// 笔的颜色</span></span><br><span class="line">    pen.<span class="built_in">setStyle</span>(Qt::SolidLine);    <span class="comment">// 笔画的线的样式（这里是实线）</span></span><br><span class="line">    pen.<span class="built_in">setCapStyle</span>(Qt::FlatCap);    <span class="comment">// 笔画的线的端点样式</span></span><br><span class="line">    pen.<span class="built_in">setJoinStyle</span>(Qt::BevelJoin);    <span class="comment">// 笔画的线的连接点样式</span></span><br><span class="line">    <span class="comment">// 笔设置完后，给  QPainter 装上指定的笔：</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个画刷</span></span><br><span class="line">    QBrush brush;</span><br><span class="line">    brush.<span class="built_in">setColor</span>(Qt::Yellow);    <span class="comment">// 画刷填充的颜色</span></span><br><span class="line">    brush.<span class="built_in">setStyle</span>(Qt::SolidPattern);    <span class="comment">// 画刷填充的样式（这里是实心）</span></span><br><span class="line">    <span class="comment">// 画刷设置完后，给 QPainter 装上指定画刷：</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘图</span></span><br><span class="line">    painter.<span class="built_in">drawRect</span>(rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序先从 <code>QPainter</code> 说起，<code>QPainter::setRenderHint(QPainter::Antialiasing)</code> 表示绘制图形抗锯齿（默认关闭），<code>QPainter::setRenderingHint(QPainter::Textantialiasing)</code></p><p>然后是 <code>QPen</code>，以上已经展示了大多数情况下会用到的方法：<strong>如何设置线宽、颜色、线的样式、端点样式和连接点样式</strong>。</p><p>其中，线的样式有枚举量 <code>Qt::PenStyle</code>，常用的值有 <code>Qt::SolidLine</code>（实线）、<code>Qt::DashLine</code>（虚线）、<code>Qt::DotLine</code>（点状线）、<code>Qt::DashDotLine</code>（点划线）、还有自定义样式 <code>Qt::CustomDashLine</code>，要结合 <code>setDashOffset()</code> 和 <code>setDashPattern()</code> 使用。</p><p>线端点的样式有枚举量 <code>Qt::PenCapStyle</code>，常用的值有 <code>Qt::Square</code>（方形端点）、<code>Qt::FlatCap</code>（平端点）、<code>Qt::RoundCap</code>（圆润端点）。</p><p>线条连接样式有枚举量 <code>Qt::PenJoinStyle</code>，常用的值有 <code>Qt::BevelJoin</code>、<code>Qt::MiterJoin</code>、<code>Qt::RoundJoin</code>；</p><p>然后是 <code>QBrush</code>，主要常用的方法就 4 个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QBrush::setColor</span><span class="params">(<span class="type">const</span> QColor&amp; color)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QBrush::setStyle</span><span class="params">(Qt::BrushStyle style)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QBrush::setTexture</span><span class="params">(<span class="type">const</span> QPixmap&amp; pixmap)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QBrush::setTextureImage</span><span class="params">(<span class="type">const</span> QImage&amp; image)</span></span>;</span><br></pre></td></tr></table></figure><p><code>QColor</code> 和之前见到过的一样，可以用枚举类型，也可以手动创建对象。</p><p>先介绍 <code>Qt::BrushStyle</code> 枚举类型，它定义的是填充样式，常用的值有：<code>Qt::NoBrush</code>（不填充）、<code>Qt::SolidBrush</code>（单一颜色填充）、<code>Qt::HorPattern</code>（水平线填充）、<code>Qt::VerPattern</code>（垂直线填充）、<code>Qt::TexturePattern</code>（材质填充，<strong>需要指定 texture 或 texture image</strong>）、<code>Qt::LinearGradientPattern</code>（线性渐变，需要使用 <code>QLinearGradient</code> 类作为 brush）、<code>Qt::RadialGradientPattern</code>（辐射渐变，需要使用 <code>QRadialGradient</code> 类作为 brush）、<code>Qt::ConicalGradientPattern</code>（圆锥渐变，需要使用 <code>QConicalGradient</code> 类作为 brush）；</p><p>渐变的使用暂时不介绍了，用到再上网查。</p><h4 id="补充：QPixmap-和-QImage"><a href="#补充：QPixmap-和-QImage" class="headerlink" title="补充：QPixmap 和 QImage"></a>补充：QPixmap 和 QImage</h4><p>下面分析一下 <code>QPixmap</code> 和 <code>QImage</code> 类<strong>本身的</strong>使用方法。</p><p>它们的构造函数比较简单，可以是含有图片的 uri 字符串，也可以是 <code>QUrl</code>，构造后即可将图片像素信息读入对象中。</p><p>两者有一些差别，<code>QPixmap</code> 主要是用于绘图，<strong>针对屏幕显示而最佳化设计</strong>（适合小图片的呈现），<code>QImage</code> 主要是为图像I/O、图片访问和<strong>像素修改</strong>而设计的类（适合大图片的编辑）。</p><p>这些差别可以从常用的方法上看出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QImage 类允许从空构造, QImage::QImageFormat 枚举类型含有多种图片格式</span></span><br><span class="line">QImage::<span class="built_in">QImage</span>(<span class="type">int</span> x, <span class="type">int</span> y, QImage::QImageFormat f);</span><br><span class="line">QImage::<span class="built_in">QImage</span>(<span class="type">const</span> QString&amp; picture);</span><br><span class="line"><span class="comment">// 方法允许直接修改像素点</span></span><br><span class="line"><span class="comment">// 注：QRgb 构造函数参数就是 R、G、B 值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QImage::setPixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> QRgb&amp; rgb)</span></span>;</span><br><span class="line"><span class="comment">// 其他非常多方法，等到用到再介绍</span></span><br></pre></td></tr></table></figure><p>二者相互转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">QPixmap::fromImage</span><span class="params">(<span class="type">const</span> QImage&amp; image)</span></span>;</span><br><span class="line"><span class="function">QImage <span class="title">QPixmap::toImage</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="补充：基本图形元件"><a href="#补充：基本图形元件" class="headerlink" title="补充：基本图形元件"></a>补充：基本图形元件</h4><p>最后，介绍上面的示例中的最后一行 <code>painter.drawRect(rect);</code>，这说明 <code>QPainter</code> 底层能够直接绘制出基本的几何图形，这称为 <strong><code>QPainter</code> 绘制的基本图形元件</strong>。下面介绍一些 <code>QPainter</code> 类中常用的图形元件：</p><ul><li><p>绘制一个点 和 一组点：<code>QPainter::drawPoint(const QPoint&amp; p);</code> 和 <code>QPainter::drawPoints(const QPoint[] points, int size);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">drawPoint</span>(<span class="built_in">QPoint</span>(W/<span class="number">2</span>, H/<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 一组点 --------------------------</span></span><br><span class="line">QPoint points[] = &#123;</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">5</span>*W/<span class="number">12</span>, H/<span class="number">4</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">3</span>*W/<span class="number">4</span>, <span class="number">5</span>*H/<span class="number">12</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">2</span>*W/<span class="number">4</span>, <span class="number">5</span>*H/<span class="number">12</span>)</span><br><span class="line">&#125;;</span><br><span class="line">painter.<span class="built_in">drawPoints</span>(points, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>这里的 <code>QPoint</code> 类之前在鼠标事件中就遇到过，构造函数就是坐标系中的 x 和 y；</p></li><li><p>绘制弧线：<code>QPainter::drawArc(const QRect&amp; rect, int startAngle, int spanAngle);</code>（这里的 angle 是角度制）；示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">90</span> * <span class="number">16</span>;    <span class="comment">// 起始为坐标系中 90° 角，其中 0° 指向 x 轴正向</span></span><br><span class="line"><span class="type">int</span> span = <span class="number">90</span> * <span class="number">16</span>;        <span class="comment">// 旋转 90°</span></span><br><span class="line">painter.<span class="built_in">drawArc</span>(rect, start, span);</span><br></pre></td></tr></table></figure><p>聪明的小伙伴可能会问，为什么要乘以 16 呢？因为，出于绘图精细粒度和数据的保存考量，Qt 中大多数绘图角度使用整型（int），并且一个单位是 <strong>1 / 16</strong> 个角度（degree）。</p></li><li><p>绘制弦：<code>QPainter::drawChord(const QRect&amp; rect, int startAngle, int spanAngle);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">90</span> * <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> span = <span class="number">90</span> * <span class="number">16</span>;</span><br><span class="line">painter.<span class="built_in">drawChord</span>(rect, start, span);</span><br></pre></td></tr></table></figure></li><li><p>绘制矩形：<code>QPainter::drawRect(const QRect&amp; rect);</code> 上面的例子就是示例；</p></li><li><p><strong>擦除矩形</strong>：<code>QPainter::eraseRect(const QRect&amp; rect);</code> 示例显然。<strong>本质上是等效于用当前背景色填充该区域</strong>；</p></li><li><p>绘制圆角矩形：<code>QPainter::drawRoundedRect(const QRect&amp; rect);</code> 使用方法同矩形；</p></li><li><p>绘制扇形：<code>QPainter::drawPie(const QRect&amp; rect, int startAngle, int spanAngle);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">40</span> * <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> span = <span class="number">120</span> * <span class="number">16</span>;</span><br><span class="line">painter.<span class="built_in">drawPie</span>(rect, start, span);</span><br></pre></td></tr></table></figure></li><li><p>绘制凸多边形：<code>QPainter::drawConvexPolygon(const QPoint[] pArr, int size);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QPoint points[<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">5</span>*W/<span class="number">12</span>, H/<span class="number">4</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">3</span>*W/<span class="number">4</span>, <span class="number">5</span>*H/<span class="number">12</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">5</span>*W/<span class="number">12</span>, <span class="number">3</span>*H/<span class="number">4</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(W/<span class="number">4</span>, <span class="number">5</span>*H/<span class="number">12</span>)</span><br><span class="line">&#125;;</span><br><span class="line">painter.<span class="built_in">drawConvexPolygon</span>(points, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li><li><p>绘制闭合多边形（闭合折线）：<code>QPainter::drawPolygon(const QPoint[] points, int size);</code> 使用方法同 “绘制凸多边形”；</p></li><li><p>绘制不闭合折线：<code>QPainter::drawPolyline(const QPoint[] points, int size);</code> 使用方法同 “绘制凸多边形”；</p></li><li><p>绘制椭圆：<code>QPainter::drawEllipse(const QRect&amp; rect);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(rect);</span><br></pre></td></tr></table></figure><p>这里实际上是利用了椭圆的外接矩形唯一的特性，长轴长是矩形的长，宽也同理。</p></li><li><p>绘制<strong>图片</strong>：<code>QPainter::drawImage(const QRect&amp; rect, const QImage&amp; image);</code>  和 <code>QPainter::drawPixmap(const QRect&amp; rect, const QPixmap&amp; pixmap);</code>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">QImage <span class="title">image</span><span class="params">(<span class="string">&quot;:/imgs/qt.jpg&quot;</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawImage</span>(rect, image);</span><br><span class="line"><span class="comment">// 或者 Pixmap 图形 ----------------</span></span><br><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/imgs/qt.jpg&quot;</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawPixmap</span>(rect, pixmap);</span><br></pre></td></tr></table></figure></li><li><p>绘制线段：<code>QPainter::drawLine(const QLine&amp; line);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QLine <span class="title">line</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawLine</span>(line);</span><br></pre></td></tr></table></figure><p>这里的 <code>QLine</code> 类，和之前的 <code>QPoint</code>、<code>QRect</code> 一样，都是表示二维图形的类。它的构造函数可以是两个点的坐标，也可以是两个 <code>QPoint</code> 对象。</p></li><li><p>绘制线段组：<code>QPainter::drawLines(const QVector&lt;QLine&gt;&amp; lines);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">QVector&lt;QLine&gt; lines;</span><br><span class="line">lines.<span class="built_in">append</span>(<span class="built_in">QLine</span>(rect.<span class="built_in">topLeft</span>(), rect.<span class="built_in">bottomRight</span>()));</span><br><span class="line">lines.<span class="built_in">append</span>(<span class="built_in">QLine</span>(rect.<span class="built_in">topRight</span>(), rect.<span class="built_in">bottomLeft</span>()));</span><br><span class="line">lines.<span class="built_in">append</span>(<span class="built_in">QLine</span>(rect.<span class="built_in">topLeft</span>(), rect.<span class="built_in">bottomLeft</span>()));</span><br><span class="line">lines.<span class="built_in">append</span>(<span class="built_in">QLine</span>(rect.<span class="built_in">topRight</span>(), rect.<span class="built_in">bottomRight</span>()));</span><br><span class="line">painter.<span class="built_in">drawLines</span>(lines);</span><br></pre></td></tr></table></figure><p>这里用到了 <code>QRect</code> 类的调用顶点方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">QRect::topLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>绘制定制的路径：<code>QPainter::drawPath(const QPainterPath&amp; path);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">QPainterPath path;</span><br><span class="line">path.<span class="built_in">addEllipse</span>(rect);</span><br><span class="line">path.<span class="built_in">addRect</span>(rect);</span><br><span class="line">painter.<span class="built_in">drawPath</span>(path);</span><br></pre></td></tr></table></figure><p>这里的 <code>QPainterPath</code> <strong>不是</strong>基本图形元件，而是复合图形对象。它是由一系列绘图操作的<strong>顺序集合</strong>，很多方法和 <code>QPainter</code> 很接近，也有专用函数，例如 <code>lineTo(const QPoint&amp;)</code>（在当前起点到指定点间连一条线段） <code>closeSubPath()</code>、<code>connectPath()</code> 等，感兴趣查阅文档。</p></li><li><p>绘制文字：<code>QPainter::drawText(const QRect&amp; rect, const QString&amp; text);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">QFont font;</span><br><span class="line">font.<span class="built_in">setPointSize</span>(<span class="number">30</span>);</span><br><span class="line">font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">painter.<span class="built_in">setFont</span>(font);    <span class="comment">// 这里用 painter 设置字体</span></span><br><span class="line">painter.<span class="built_in">drawText</span>(rect, <span class="string">&quot;Hello, Qt&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="QRect-和-QRectF"><a href="#QRect-和-QRectF" class="headerlink" title="QRect 和 QRectF"></a>QRect 和 QRectF</h4><p>我们在上面的例子中可以看到，几乎所有的绘画过程竟然都用到了 <code>QRect</code> 类。</p><p>看文档的同学可能会问，诶，这个经常看到 <code>QRect</code> 和 <code>QRectF</code> 类同时出现，它们有什么关系吗？实际上两者的目标是一样的，只不过是 “历史遗留问题”。</p><p>先出现的 <code>QRect</code> 的构造方法之一是<strong>左上、右下</strong>的点的坐标。这个构造是准确的，但是调用 <code>bottomRight()</code>、<code>bottonLeft()</code>、<code>topRight()</code> 返回的位置和实际位置<strong>相差 1 个单位</strong>。这是由于对于像素中心的划分方法导致的，只有 <code>topLeft()</code> 返回数据与实际数据相同，官方文档描述如下：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="QRect.png" height="750"></p><p>而后出现的 <code>QRectF</code>，修复了这个问题，所有方法都是准确的。所以，你既可以使用 <code>QRect</code>，但要记住这个 ± 1 的“陷阱”，也可以用 <code>QRectF</code>，这取决于自己，又或是项目的兼容性。</p><p>因为在 Qt 几乎所有的官方函数中，使用到 <code>QRect</code> 类的地方都用了 <code>QRectF</code> 重载了一下。留着 <code>QRect</code> 是为了向前兼容。</p><p>还有 <code>QPoint</code> 和 <code>QPointF</code> 等，想要中文版了解原因，强烈推荐这篇文章：<a href="https://www.cnblogs.com/lvdongjie/p/4816024.html">传送门🚪</a></p><h3 id="6-1-3-绘图坐标系-和-坐标变换"><a href="#6-1-3-绘图坐标系-和-坐标变换" class="headerlink" title="6.1.3 绘图坐标系 和 坐标变换"></a>6.1.3 绘图坐标系 和 坐标变换</h3><h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><p>在 6.1.1 中提到过，目前为止我们使用的都是<strong>视口坐标</strong>，这是 Qt 绘图的默认坐标系统，也被称为绘图设备的物理坐标。为了绘图方便，<code>QPainter</code> 还提供了变换绘图坐标的功能，例如<strong>平移、旋转</strong>等。这个时候，由于旋转涉及大量数学计算，所以使用<strong>逻辑坐标系统</strong>是最方便的。逻辑坐标会在接下来的讨论中逐步解释。</p><p>下面是 <code>QPainter</code> 关于坐标变换的相关方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::translate</span><span class="params">(qreal dx, qreal dy)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::rotate</span><span class="params">(qreal angle)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::scale</span><span class="params">(qreal sx, qreal sy)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::shear</span><span class="params">(qreal sh, qreal sv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::save</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::restore</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::resetTransform</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>先解释 <code>qreal</code>，它就是 Qt 用来存储实数的基础数据类型，和 <code>double</code> 类似的使用。</p><p><code>QPainter::translate()</code> 会<strong>将坐标系统的原点平移给定的偏移量</strong>；</p><p>⚠ 注意，这里平移的是坐标系统，<strong>不会改变已有图形的绝对位置，只会改变当前绘图的坐标、改变原有图形在当前坐标系统下的坐标</strong>。下面所有的功能也都是这样！！！</p><p><code>QPainter::rotate()</code> 会<strong>将坐标系统顺时针（+）旋转给定角度</strong>；</p><p>注：这个角度由于是 <code>qreal</code>，所以是 1° 的角度制。</p><p><code>QPainter::scale()</code> 会<strong>将坐标系统的 x、y 轴分别缩放指定倍数</strong>；</p><p>注：倍数大于 1 放大，小于 1 缩小。</p><p><code>QPainter::shear()</code> 会<strong>将坐标系统在水平、垂直方向做指定倍数的扭转变换</strong>；</p><p><code>QPainter::save()</code> <strong>保存 <code>painter</code> 当前的状态，并将其压入堆栈</strong>；</p><p><code>QPainter::restore()</code> <strong>从堆栈中弹出并恢复到上一个 <code>painter</code> 状态</strong>；</p><p><code>QPainter::resetTransform()</code> <strong>复位所有的坐标变换</strong>；</p><h4 id="绘图坐标系"><a href="#绘图坐标系" class="headerlink" title="绘图坐标系"></a>绘图坐标系</h4><p>现在解释之前的 “<strong>视口坐标系</strong>”、“<strong>窗口坐标系</strong>” 和 “<strong>逻辑坐标系</strong>”。</p><p>视口（viewport）表示绘图设备的<strong>任意</strong>一个矩形区域的物理坐标，默认情况下等于绘图设备的整个矩形区域（意味着可以更改）；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::setViewport</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure><p>窗口（window）和 视口 是同一个矩形，只不过<strong>窗口是用逻辑坐标定义的坐标系</strong>。</p><p>逻辑坐标可以理解为一种相对的坐标，不代表物理坐标，只是数学上的参照。</p><p>上面的解释非常抽象，以一个例子说明：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="viewport_and_window.png" height="150"></p><p>如上图，（a）的外围矩形框代表绘图设备的物理大小、坐标范围，假设宽 300px，高 200px。现在取中间的正方形阴影区域作为视口。因此视口的左上角在设备的物理坐标（50，0），右下角（250，200）；可以这么设置：<code>painter.setViewport(50, 0, 200, 200);</code>；<strong>而在设置指定视口后，逻辑坐标还没有确定，因为没有确定窗口</strong>。</p><p>对于给定的视口，<strong>可以在其上定义窗口</strong>，这里<strong>定义窗口就是在定义逻辑坐标系</strong>。为什么这么说？因为别忘了<strong>窗口和视口是同一个矩形</strong>，这时设置窗口坐标相当于指定窗口在逻辑坐标系中的位置，进而可以由 <code>QPainter</code> 底层计算出逻辑坐标的情况。</p><p>例如，这里我设置 <code>painter.setWindow(-50, -50, 100, 100);</code> 代表当前的窗口左上角在逻辑坐标的位置是（-50，-50），当前窗口的逻辑宽度、逻辑高度都是 100；<strong>注意：逻辑宽度、逻辑高度设置后，可能比例与物理宽高不一致，这取决于您给定的数字。这个例子中逻辑长度和物理长度是 1：1</strong>。由此建立的逻辑坐标系如图（b）所示。<strong>以后的坐标都按逻辑坐标系来给定</strong>。</p><p>为什么要大费周章引入这一系列坐标系？直接用视口坐标（物理坐标）不行吗？其实窗口坐标（逻辑坐标）有优点，就是只需按窗口坐标的定义来绘图，不用管实际物理坐标范围。<strong>例如在固定边长 100px（物理长度）的正方形窗口中绘图，当实际设备的大小变化（可能是用户拖动），绘制图形会自动变化实际大小来适应相对大小</strong>。</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>现在综合之前的知识做个练习：在画布上绘制一个正五角星，并在一旁绘制至少 2 个旋转了不同角度的正五角星。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请自行实现 Canvas 类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Canvas::paintEvent</span><span class="params">(QPaintEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.<span class="built_in">setWidth</span>(<span class="number">3</span>);</span><br><span class="line">    pen.<span class="built_in">setColor</span>(Qt::blue);</span><br><span class="line">    pen.<span class="built_in">setStyle</span>(Qt::SolidLine);</span><br><span class="line">    pen.<span class="built_in">setCapStyle</span>(Qt::RoundCap);</span><br><span class="line">    pen.<span class="built_in">setJoinStyle</span>(Qt::RoundJoin);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">    QBrush brush;</span><br><span class="line">    brush.<span class="built_in">setStyle</span>(Qt::NoBrush);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> H = <span class="keyword">this</span>-&gt;<span class="built_in">height</span>();</span><br><span class="line">    <span class="type">int</span> W = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>();</span><br><span class="line">    <span class="type">const</span> qreal PI = <span class="number">3.141592653</span>;</span><br><span class="line">    <span class="function">QRectF <span class="title">rect</span><span class="params">(-W/<span class="number">2</span>, -H/<span class="number">8</span>, W/<span class="number">2</span>, H/<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setViewport</span>(W/<span class="number">8</span>, H/<span class="number">8</span>, <span class="number">3</span>*W/<span class="number">4</span>, <span class="number">3</span>*H/<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 数学好的同学这里一眼就看出来，逻辑长度:物理长度 = 3:4</span></span><br><span class="line">    painter.<span class="built_in">setWindow</span>(<span class="number">0</span>, -H/<span class="number">2</span>, W, H);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> qreal m = <span class="built_in">qMin</span>(H, W);</span><br><span class="line">    </span><br><span class="line">    <span class="function">QPoint <span class="title">center_1</span><span class="params">(-m/<span class="number">2</span>+m/<span class="number">6</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">center_2</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">center_3</span><span class="params">(m/<span class="number">2</span>-m/<span class="number">6</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_1</span><span class="params">(<span class="number">0</span>, -m/<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_2</span><span class="params">(m/<span class="number">6</span>*std::cos(<span class="number">2</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>), m/<span class="number">6</span>*std::sin(<span class="number">2</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_3</span><span class="params">(m/<span class="number">6</span>*std::cos(<span class="number">4</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>), m/<span class="number">6</span>*std::sin(<span class="number">4</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_4</span><span class="params">(m/<span class="number">6</span>*std::cos(<span class="number">6</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>), m/<span class="number">6</span>*std::sin(<span class="number">6</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_5</span><span class="params">(m/<span class="number">6</span>*std::cos(<span class="number">8</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>), m/<span class="number">6</span>*std::sin(<span class="number">8</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    QPainterPath* path = <span class="keyword">new</span> <span class="built_in">QPainterPath</span>(p_1_1);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_3);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_5);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_2);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_4);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_1);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawPath</span>(*path);</span><br><span class="line">    painter.<span class="built_in">translate</span>(m/<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    painter.<span class="built_in">rotate</span>(<span class="number">30</span>);</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(*path);</span><br><span class="line">    painter.<span class="built_in">translate</span>(m/<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    painter.<span class="built_in">rotate</span>(<span class="number">30</span>);</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(*path);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-2-QGraphicsView-进阶绘图"><a href="#6-2-QGraphicsView-进阶绘图" class="headerlink" title="6.2 QGraphicsView 进阶绘图"></a>6.2 <code>QGraphicsView</code> 进阶绘图</h2><p>在介绍 <code>QGraphicsView</code> 前，请大家回想在第 4 章使用的 <code>QTableWidget</code>（父类 <code>QTableView</code>），它是 <strong>model/view（模型/视图）结构</strong>。在 Qt 中，model/view 结构是 Qt 界面组件显示与编辑数据的一种结构，视图时显示和编辑数据的界面组件，而模型是视图与原始数据之间的接口。最典型的应用是在数据库软件中的表单渲染。</p><p>主要用到的视图组件有 <code>QListView</code>、<code>QTreeView</code>、<code>QTableView</code>  等，它们对应的 <code>XXXWidget</code> 则是一层包装，直接用项存储，而在更高级的用法中就需要 model/view 的结构了。看下面的关系图：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="model_view.png" height="275"></p><ul><li><p>数据（Data）：就是实际的数据，例如数据库的一个表、SQL 查询结果、内存里的一个数组、磁盘文件结构等等；</p></li><li><p>视图或视图组件（View）：是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引（model index），然后依此获得数据并显示。Qt 中的例子如下，大家根据需要，用到再查询文档使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QListView: 用于显示单列的列表数据，适用于一维数据的展示和操作</span><br><span class="line">QTreeView: 用于显示树状结构数据</span><br><span class="line">QTableView: 用于显示表格状数据，适用于二维表格型数据的展示和操作</span><br><span class="line">QColumnView: 用于多个 QListView 显示树状层次，每层用一个 QListView 表示</span><br><span class="line">QHeaderView: 提供表头或列表头的视图组件，例如 QTableView 的行表头和列表头</span><br></pre></td></tr></table></figure><p><strong>这些视图组件一般调用 <code>setModel()</code>  来设置模型或数据模型的种类</strong>。</p></li><li><p>模型或数据模型（Model）：与实际数据通信，并且为视图组件提供数据接口。主要是从原始数据提取内容，并提示视图组件进行显示、编辑。Qt 中的例子如下，大家根据需要，用到再查询文档使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QStringListModel: 用于处理字符串列表的数据模型类</span><br><span class="line">QStandardItemModel: 标准的基于项数据的数据模型类，每个项数据可以是任何数据类型</span><br><span class="line">QFileSytemModel: 计算机上文件系统的数据模型类</span><br><span class="line">QSortFilterProxyModel: 与其他数据类型结合，提供排序、过滤等功能的数据模型类</span><br><span class="line"></span><br><span class="line">QSqlQueryModel: 用于数据库 SQL 查询结果的数据模型类</span><br><span class="line">QSqlTableModel: 用于数据库的一个数据表的数据模型类</span><br><span class="line">QSqlRelationalTableModel: 用于关系型数据库的数据模型类</span><br><span class="line"></span><br><span class="line">// 如果上面的类不能满足要求，还可以自己从 QAbstractItemModel、QAbstractListModel、QAbstractTableModel 等类自行定制</span><br></pre></td></tr></table></figure></li><li><p>代理（Delegate）：这可以让用户定制数据的显示和编辑方式。默认情况下代理显示一个数据，当数据被编辑时，代理通过 model index 和数据模型通信（一般会提供编辑器，默认 <code>QLineEdit</code>）；</p><p>通俗地解释一下，第 4 章中，我们使用 <code>QTableWidget</code> 来创建表格区域时，双击修改表格会弹出一个 <code>QLineEdit</code>，输入回车后消失，它就是代理。当然，除了 <code>QLineEdit</code>，对于特定场景，例如只允许输入整型，那么 <code>QSpinBox</code> 合适，如果要从列表中选择数据填入，那么 <code>QComboBox</code> 合适。<strong>这时，可以从 <code>QStyledItemDelegate</code> 来继承创建一个自定义代理类</strong>。</p></li><li><p>View、Model、Delegate 三者间通过信号-槽通信：源数据改变时，model 向 view 发射信号；用户在 view 中操作数据时，view 向 model 发射信号；用户借助代理编辑数据时，delegate 向 model 和 view 发射信号。</p></li><li><p>Model/View 结构有一些约定的实现需要了解。</p><ul><li>数据<strong>形式上</strong>还是以项的形式存在；这意味着第 4 章中对于 “<code>QTableWidgetItem</code> 设计” 的探讨，这里对于所有的 <code>QStandardItem</code> 都是一样的，都有 “role” 的说法；</li><li>为了保证数据表示 和 数据存取方式的隔离，数据模型中引入了<strong>模型索引（model index）</strong>的概念。通过数据模型存取的每一个数据都有一个模型索引，视图组件 view 和代理 delegate 都通过调用 model 的模型索引来定位、获取数据；</li><li>模型索引有个专门的类来表示：<code>QModelIndex</code>，它提供数据存取的<strong>临时指针</strong>（数据模型内部组织数据的结构随时可能改变）。如果想要持久性的索引，可能需要 <code>QPersistentModelIndex</code> 类，但会牺牲部分的性能和空间；</li><li>由模型索引确定数据，<strong>需要向 <code>QModelIndex</code> 传递 3 个参数：行号、列号、父项的模型索引</strong>。但请注意，这不代表底层的数据以二维数组存储，只是这么表示更方便，所以 <code>QModelIndex</code> 的接口就这么设计。行和列的编号好说，在 <code>List Model</code> 和 <code>Table Model</code> 中就是原本的意思，在 <code>Tree Model</code> 中行指深度优先的编号；父项索引也好说，在 <code>Tree Model</code> 中就是原本的意思，在 <code>List Model</code> 和 <code>Table Model</code> 中就是空对象（<code>QModelIndex()</code>）；</li></ul></li></ul><p>铺垫了这么多 model/view 结构的知识，接下来终于可以开始讨论 <code>QGraphicsView</code> 的使用了。</p><h3 id="6-2-1-场景、视图、图形项"><a href="#6-2-1-场景、视图、图形项" class="headerlink" title="6.2.1 场景、视图、图形项"></a>6.2.1 场景、视图、图形项</h3><p>前一节叙述的 <code>QPainter</code> 绘图只能实现一些简单的绘制事件。对于复杂度高、交互性强、图形间的逻辑关系复杂的情况，很可能就需要 Graphics View 绘图架构来完成。</p><p>这种架构是基于 Graphics/Item 的模型/视图模式，和 Model/View 模式类似。Graphics/Item 模式由 3 个部分组成：<strong>场景、视图、图形项</strong>。</p><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p> <code>QGraphicsScene</code> 类提供绘图场景（Scene）。场景本身不可见，是一个抽象的<strong>管理图形项的容器</strong>，可以向场景加入图形项，获取场景中某个图形项等功能，具体如下：</p><ul><li>提供管理大量图形项的快速接口；</li><li>将事件传播给每个图形项；</li><li>管理每个图形项的状态，例如选择、焦点状态；</li><li>管理未经变换的渲染功能（主要用于打印）；</li></ul><p>场景中除了图形项，还有<strong>背景层</strong>和<strong>前景层</strong>，通常用 <code>QBrush</code> 指定，也可以重写 <code>drawBackground()</code>、<code>drawForeground()</code> 来自定义效果；</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p><code>QGraphicsView</code> 提供绘图的视图（view）组件，用于显示场景中的内容。可以为一个场景设置多个视图，也可以对同一个数据集提供不同视口。下图展示了场景、视图、图形项三者间的关系：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="graphics_view.png"></p><p>虚线框是场景，视图 1 范围比场景大，因此可以显示全部内容（默认居中显示在视图中，可调整视图的 <code>Alignment</code> 属性）；视图 2 小于场景，仅能显示一部分内容，但会<strong>自动</strong>提供滚动条在整个场景中滚动。</p><p><strong>视图负责接收键鼠输入事件，并转换为场景事件，经过坐标变换后传送给可视场景</strong>。</p><h4 id="图形项"><a href="#图形项" class="headerlink" title="图形项"></a>图形项</h4><p>图形项（Graphics Item）就是一些基本图形元件，基类是 <code>QGraphicsItem</code>。Qt 提供了一些基本的图形项，例如椭圆 <code>QGraphicsEllipseItem</code>、矩形 <code>QGraphicsRectItem</code>、文字 <code>QGraphicsTextItem</code> 等。</p><p><code>QGraphicsItem</code> 支持如下操作：</p><ul><li>一切鼠标、键盘、按键输入事件；</li><li>支持拖放操作；</li><li>支持组合，可以是父子项关系组合，也可以通过 <code>QGraphicsItemGroup</code> 类进行组合；</li></ul><h3 id="6-2-2-Graphics-View-的坐标系统"><a href="#6-2-2-Graphics-View-的坐标系统" class="headerlink" title="6.2.2 Graphics View 的坐标系统"></a>6.2.2 Graphics View 的坐标系统</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Graphics View 系统有 3 个有效坐标系：<strong>图形项坐标</strong>、<strong>场景坐标</strong>、<strong>视图坐标</strong>。</p><p>其中，<strong>绘图时，场景坐标等价于 <code>QPainter</code> 的逻辑坐标</strong>，一般以场景中心为原点；</p><p><strong>视图坐标与设备坐标（物理坐标）相同，是绝对的，默认以左上角为原点</strong>；</p><p><strong>图形项坐标是 <u>局部逻辑坐标</u></strong>，一般以某个图形项的几何中心为原点。</p><p>这里很多教程和书籍写的很麻烦，下面用一段话来总结一下：</p><p>首先对于一个图形项而言，就只讨论图形项坐标。图形项坐标就是<strong>以当前图形项为参考系的坐标</strong>；而这个图形项本身整体坐标以几何中心为位置，按其父级 <code>QGraphicsItem</code> 的图形项坐标来表示位置。如果上层没有 <code>QGraphicsItem</code>，那么事件的位置就是<strong>场景坐标位置</strong>。这就意味着图形项坐标层层嵌套，最外层是场景坐标系。因此，场景坐标描述了每个顶层图形项的坐标位置。</p><p>而视图坐标就是<strong>窗口界面（widget）的物理坐标（单位像素）</strong>，只与 widget 有关，与场景无关。<strong>更重要的是，所有鼠标事件、拖动事件的坐标首先由视图坐标定义，然后由转换矩阵转换为场景坐标，以便与图形项交互</strong>。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>那么如何使用？首先创建场景的时候就可以定义场景坐标范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsScene::<span class="built_in">QGraphicsScene</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height);</span><br></pre></td></tr></table></figure><p>在使用时，虽然 <code>QGraphicsScene</code> 描述的是顶层 <code>QGraphicsItem</code>，但有一层封装可以取得所有图形项的场景坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">QGraphicsItem::scenePos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>还有 <code>QGraphicsItem</code> 在其父级中的坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">QGraphicsItem::pos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>注：除了上面两个方法，<code>QGraphicsItem</code> 的方法返回的位置几乎都是自己的<strong>局部坐标</strong>；</p><p>例如获得 <code>QGraphicsItem</code> 的边界矩形框的方法，返回的就是边界矩形在自己的局部坐标系下的坐标值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">QGraphicsItem::boundingRect</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></blockquote><p>既然 <code>pos()</code> 有对应在场景中的 <code>scenePos()</code>，那么 <code>boundingRect()</code> 也有在场景中的 <code>sceneBoundingRect()</code>，<strong>可以指出当前图形项在场景中的边界矩形、图形项的边界有什么变化等</strong>。</p><p><strong>场景本身也会在变化时发射 <code>QGraphicsScene::changed()</code> 信号，参数是一个场景坐标中的 <code>QRect[]</code>，表示发生变化的矩形区</strong>；</p><h4 id="坐标映射"><a href="#坐标映射" class="headerlink" title="坐标映射"></a>坐标映射</h4><p>在场景中操作图形项的时候，在场景、图形项、视图间的坐标变换是非常有用的，这被称为 “坐标映射”。我们可以通过 <strong><code>QGraphicsView::mapToScene()</code></strong> 从视图坐标映射为场景坐标，然后用 <strong><code>QGraphicsScene::itemAt()</code></strong> 获取场景中<strong>鼠标光标处的图形项</strong>；</p><h3 id="6-2-3-主要类的接口"><a href="#6-2-3-主要类的接口" class="headerlink" title="6.2.3 主要类的接口"></a>6.2.3 主要类的接口</h3><p>在接口列表中，<strong>我们省去了设置函数对应的读取函数，例如 <code>setScene()</code> 有对应的 <code>scene()</code> 读，后者是有的，但不会赘述</strong>，同时省去作用域符 <code>::</code> 和显然的参数、<code>const</code> 修饰。</p><h4 id="QGraphicsView"><a href="#QGraphicsView" class="headerlink" title="QGraphicsView"></a><code>QGraphicsView</code></h4><p>对于这个类，主要讨论的是它的视口坐标（视图坐标，也就是物理坐标）。下面列出类中常用的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景类型的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScene</span><span class="params">()</span></span>;        <span class="comment">// 设置与 view 关联的场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSceneRect</span><span class="params">()</span></span>;    <span class="comment">// 用 QRect 设置</span></span><br><span class="line"><span class="comment">// 外观类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlignment</span><span class="params">()</span></span>;    <span class="comment">// 设置场景在视图中的对齐方式，默认上下都居中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setBackgroundBrush</span><span class="params">()</span></span>;    <span class="comment">// 设置场景的背景画刷，用来管理背景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setForegroundBrush</span><span class="params">()</span></span>;    <span class="comment">// 前景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setRenderHints</span><span class="params">()</span></span>;    <span class="comment">// 设置绘图选项，回想一下 QPainter::setRenderHints()</span></span><br><span class="line"><span class="comment">// 交互类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setInteractive</span><span class="params">()</span></span>;    <span class="comment">// 设置场景是否允许交互。如果禁止，那么键鼠事件也会被忽略</span></span><br><span class="line"><span class="function">QRect <span class="title">rubberBandRect</span><span class="params">()</span></span>;    <span class="comment">// 返回当前选中的矩形框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setRubberBandSelectionMode</span><span class="params">()</span></span>;    <span class="comment">// 就是设置选择模式：能否选择、能否多选等，请回想 QTableWidget::setSelectionMode()</span></span><br><span class="line"><span class="function">QGraphicsItem* <span class="title">itemAt</span><span class="params">()</span></span>;    <span class="comment">// 获取视图（物理）坐标系中某位置处的图形项</span></span><br><span class="line"><span class="function">QList&lt;QGraphicsItem*&gt; <span class="title">items</span><span class="params">()</span></span>;    <span class="comment">// 返回场景中所有 / 某个选中区域的图形项列表</span></span><br><span class="line"><span class="comment">// 坐标映射型</span></span><br><span class="line"><span class="function">QPoint <span class="title">mapFromScene</span><span class="params">()</span></span>;    <span class="comment">// 场景坐标 转 视图坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapToScene</span><span class="params">()</span></span>;    <span class="comment">// 视图坐标 转场景坐标</span></span><br></pre></td></tr></table></figure><h4 id="QGraphicsScene"><a href="#QGraphicsScene" class="headerlink" title="QGraphicsScene"></a><code>QGraphicsScene</code></h4><p>这个类就是用于管理图形项的场景，是图形项的容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSceneRect</span><span class="params">()</span></span>;    <span class="comment">// 设置场景的矩形边界，和 QGraphicsView 一样能改</span></span><br><span class="line"><span class="comment">// 分组类型</span></span><br><span class="line"><span class="function">QGraphicsItemGroup* <span class="title">createItemGroup</span><span class="params">()</span></span>;    <span class="comment">// 创建图形项组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroyItemGroup</span><span class="params">()</span></span>;    <span class="comment">// 解除一个图形项组</span></span><br><span class="line"><span class="comment">// 输入焦点类型</span></span><br><span class="line"><span class="function">QGraphicsItem* <span class="title">focusItem</span><span class="params">()</span></span>;    <span class="comment">// 返回当前获得焦点的图形项</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearFocus</span><span class="params">()</span></span>;            <span class="comment">// 去除选择焦点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasFocus</span><span class="params">()</span></span>;            <span class="comment">// 当前视图是否有焦点</span></span><br><span class="line"><span class="comment">// 图形项操作类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addItem</span><span class="params">()</span></span>;                <span class="comment">// 添加一个**已创建**的图形项</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeItem</span><span class="params">()</span></span>;            <span class="comment">// 删除图形项</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;                <span class="comment">// 清除场景中所有图形项</span></span><br><span class="line"><span class="function">QGraphicsItem* <span class="title">mouseGrabberItem</span><span class="params">()</span></span>;    <span class="comment">// 返回鼠标抓取的图形项</span></span><br><span class="line"><span class="function">QList&lt;QGraphicsItem*&gt; <span class="title">selectedItems</span><span class="params">()</span></span>;    <span class="comment">// 与QGraphicsView::items()差距很小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearSelection</span><span class="params">()</span></span>;        <span class="comment">// 清除当前所有选中</span></span><br><span class="line"><span class="function">QGraphicsItem* <span class="title">itemAt</span><span class="params">()</span></span>;    <span class="comment">// 获取场景坐标系下某位置的顶层图形项，和 QGraphicsView::itemAt(); 就是输入坐标有差异</span></span><br><span class="line"><span class="function">QList&lt;QGraphicsItem*&gt; <span class="title">items</span><span class="params">()</span></span>;    <span class="comment">// 参考 QGraphicsView::items();</span></span><br><span class="line"><span class="comment">// 添加图形项类型</span></span><br><span class="line"><span class="function">QGraphicsEllipseItem* <span class="title">addEllipse</span><span class="params">()</span></span>;    <span class="comment">// 加一点椭圆</span></span><br><span class="line"><span class="function">QGraphicsLineItem* <span class="title">addLine</span><span class="params">()</span></span>;        <span class="comment">// 加一点线段</span></span><br><span class="line"><span class="function">QGraphicsPathItem* <span class="title">addPath</span><span class="params">()</span></span>;        <span class="comment">// 加一点 QPainterPath</span></span><br><span class="line"><span class="function">QGraphicsPixmapItem* <span class="title">addPixmap</span><span class="params">()</span></span>;    <span class="comment">// 加一点 pixmap</span></span><br><span class="line"><span class="function">QGraphicsPolygonItem* <span class="title">addPolygon</span><span class="params">()</span></span>;    <span class="comment">// 加一点多边形</span></span><br><span class="line"><span class="function">QGraphicsRectItem* <span class="title">addRect</span><span class="params">()</span></span>;        <span class="comment">// 加一点矩形</span></span><br><span class="line"><span class="function">QGraphicsSimpleTextItem* <span class="title">addSimpleText</span><span class="params">()</span></span>;    <span class="comment">// 加一点简单文字</span></span><br><span class="line"><span class="function">QGraphicsTextItem* <span class="title">addText</span><span class="params">()</span></span>;        <span class="comment">// 加一点字符串</span></span><br><span class="line"><span class="function">QGraphicsProxyWidget* <span class="title">addWidget</span><span class="params">()</span></span>;    <span class="comment">// 加一点界面组件</span></span><br><span class="line">                                    <span class="comment">// 味道好极了</span></span><br></pre></td></tr></table></figure><h4 id="QGraphicsItem"><a href="#QGraphicsItem" class="headerlink" title="QGraphicsItem"></a><code>QGraphicsItem</code></h4><p>它是所有图形项的基类，用户可以从它继承定义自己的图形项类。Qt 中常见的图形项类的继承关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsItem</span><br><span class="line">    |</span><br><span class="line">    ├─ QAbstractGraphicsShapeItem</span><br><span class="line">    ||</span><br><span class="line">    |├─ QGraphicsEllipseItem</span><br><span class="line">    |├─ QGraphicsPathItem</span><br><span class="line">    |├─ QGraphicsPolygonItem</span><br><span class="line">    |├─ QGraphicsRectItem</span><br><span class="line">    |└─ QGraphicsSimpleTextItem</span><br><span class="line">    |</span><br><span class="line">    ├─ QGraphicsLineItem</span><br><span class="line">    ├─ QGraphicsPixmapItem</span><br><span class="line">    ├─ QGraphicsObject</span><br><span class="line">    ||</span><br><span class="line">    |└─ QGraphicsTextItem</span><br><span class="line">    |</span><br><span class="line">    └─ QGraphicsItemGroup</span><br></pre></td></tr></table></figure><p>这个 <code>QGraphicsItem</code> 类提供了对图形项的基本操作方法，常见方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性设置类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setFlags</span><span class="params">()</span></span>;        <span class="comment">// 设置图形项的操作属性，例如可选择、可移动等</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setOpacity</span><span class="params">()</span></span>;        <span class="comment">// 如其名，设置透明度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGraphicsEffect</span><span class="params">()</span></span>;    <span class="comment">// 设置图形效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSelected</span><span class="params">()</span></span>;        <span class="comment">// 设置图形项是否被选中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">()</span></span>;            <span class="comment">// 用户自定义数据</span></span><br><span class="line"><span class="comment">// 坐标类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">()</span></span>;            <span class="comment">// 图形项在父级中的 X 坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">()</span></span>;            <span class="comment">// Y 坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setZValue</span><span class="params">()</span></span>;        <span class="comment">// Z 值控制叠放次序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPos</span><span class="params">()</span></span>;            <span class="comment">// 图形项在父级中的位置</span></span><br><span class="line"><span class="function">QPointF <span class="title">scenePos</span><span class="params">()</span></span>;        <span class="comment">// 返回图形项在场景中的坐标，相当于在 mapToScene 上包装</span></span><br><span class="line"><span class="comment">// 坐标变换类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetTransform</span><span class="params">()</span></span>;    <span class="comment">// 复位坐标系，取消所有变换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setRotation</span><span class="params">()</span></span>;        <span class="comment">// 顺时针(+)旋转指定角度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScale</span><span class="params">()</span></span>;        <span class="comment">// 等比例缩放</span></span><br><span class="line"><span class="comment">// 坐标映射类型</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapFromItem</span><span class="params">()</span></span>;    <span class="comment">// 将另一个图形项的一个**点**映射到本图形项的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapFromParent</span><span class="params">()</span></span>;<span class="comment">// 将父级的一个点映射到本图形项的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapFromScene</span><span class="params">()</span></span>;    <span class="comment">// 将场景的一个点映射到本图形项的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapToItem</span><span class="params">()</span></span>;    <span class="comment">// 将本图形项的一个点映射到另一个图形项的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapToParent</span><span class="params">()</span></span>;    <span class="comment">// 将本图形项的一个点映射到父级的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapToScene</span><span class="params">()</span></span>;    <span class="comment">// 将本图形项的一个点映射到场景坐标</span></span><br><span class="line"><span class="comment">// 绘制类型</span></span><br><span class="line"><span class="comment">// 注意！QGraphicsItem 也可以像 QPainter 一样指定绘制的工具</span></span><br><span class="line"><span class="comment">// ...(略)</span></span><br><span class="line"><span class="comment">// 再补充一个改变鼠标悬停样式的方法：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setCursor</span><span class="params">()</span></span>;        <span class="comment">// 参数请参考 QApplication::setOverrideCursor()</span></span><br></pre></td></tr></table></figure><p>这里说一下 <code>QGraphicsItem::setFlags()</code>  的使用，参数就是 <code>QGraphicsItem::QGraphicsItemFlag</code> 枚举类型，其值也是十六进制数码，<strong>也允许按位或组合</strong>，常见值有：<code>QGraphcisItem::ItemIsMovable</code>、<code>QGraphicsItem::ItemIsSelectable</code>、<code>QGraphicsItem::ItemIsFocusable</code> 等；</p><h2 id="6-3-章末总结"><a href="#6-3-章末总结" class="headerlink" title="6.3 章末总结"></a>6.3 章末总结</h2><h3 id="6-3-1-知识补充"><a href="#6-3-1-知识补充" class="headerlink" title="6.3.1 知识补充"></a>6.3.1 知识补充</h3><p>Qt 中有格式化字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static function</span></span><br><span class="line"><span class="function">QString <span class="title">QString::asprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, __VAR_ARGS__)</span></span>;</span><br></pre></td></tr></table></figure><p>格式化占位符和 C++ 的 <code>printf</code> 函数相同；</p><p>Qt 中还有一个类，比较常用，但是内容很少，就不再另起一节——它就是 <code>QTimer</code>；</p><p><code>QTimer</code> 用于创建和管理定时器。它提供了一种机制，可以在给定的时间间隔内发出信号。比较常用的方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QTimer::<span class="built_in">QTimer</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTimer::interval</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 查询时间间隔</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setInterval</span><span class="params">(<span class="type">int</span> milliSeconds)</span></span>;    <span class="comment">// 设置触发间隔</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isActive</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 当前是否正在计时</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isSingleShot</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// 是否是只触发一次的计时器</span></span><br><span class="line"><span class="comment">// slots:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::start</span><span class="params">()</span></span>;                        <span class="comment">// 计时开始</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::stop</span><span class="params">()</span></span>;                        <span class="comment">// 计时停止</span></span><br><span class="line"><span class="comment">// signals:</span></span><br><span class="line"><span class="comment">// 除非是仅触发一次的计时器，否则每当开始后 interval 的整数倍时间就 emit 一次这个信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::timeout</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="6-3-2-类图总结"><a href="#6-3-2-类图总结" class="headerlink" title="6.3.2 类图总结"></a>6.3.2 类图总结</h3><p>前面几章遇到的类图的总结如下：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="C6.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: C++ GUI Programming with Qt 4 (2nd Edition) &lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;注意：本文章将讲解 &lt;strong&gt;Qt 5&lt;/strong&gt; 入门知识，需要一定的 C++ 基础&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
    <category term="Qt" scheme="https://sjtuxhw.top/tags/Qt/"/>
    
    <category term="C++" scheme="https://sjtuxhw.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>从C++入门Qt（二）</title>
    <link href="https://sjtuxhw.top/2023/08/16/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://sjtuxhw.top/2023/08/16/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2023-08-16T15:15:11.000Z</published>
    <updated>2023-09-19T05:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: C++ GUI Programming with Qt 4 (2nd Edition) </i></p><p><i>注意：本文章将讲解 <strong>Qt 5</strong> 入门知识，需要一定的 C++ 基础</i></p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p><strong>观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~</strong></p><hr><span id="more"></span><h1 id="Chapter-4-第一个完整的-Qt-入门项目"><a href="#Chapter-4-第一个完整的-Qt-入门项目" class="headerlink" title="Chapter 4 第一个完整的 Qt 入门项目"></a>Chapter 4 第一个完整的 Qt 入门项目</h1><blockquote><p>在完成以上的学习过程后，在座诸位都具有独立写出一个<strong>极简的、</strong>较为完整 Qt 项目的能力；</p><p>以下，本人将用 <strong>纯代码方式</strong> 方式完成这个项目；</p><p><strong>本章末，会总结到目前为止学到的所有 Qt 类的继承/思维图</strong>。</p></blockquote><p><strong>观前提示：本项目的设计思路很长，完整源代码放在 仓库 里，有需要可以取出查看 ~ 本章的目的是为了学习 Qt 一些组件的用法而已 ~</strong></p><p><strong>项目目标：模仿 <code>Microsoft Excel</code> 设计一个表格应用程序</strong>。</p><h2 id="4-1-创建主窗口-UI"><a href="#4-1-创建主窗口-UI" class="headerlink" title="4.1 创建主窗口 UI"></a>4.1 创建主窗口 UI</h2><h3 id="4-1-1-子类化-QMainWindow"><a href="#4-1-1-子类化-QMainWindow" class="headerlink" title="4.1.1 子类化 QMainWindow"></a>4.1.1 子类化 QMainWindow</h3><p>创建一个主窗口最方便的方法是利用 Qt 库中已有的设计类：<code>QMainWindow</code>。</p><p><code>QMainWindow</code> 和 <code>QDialog</code> 都是 <code>QWidget</code> 的子类，所以之前的很多方法在创建主窗口时同样有效。</p><p>编写前先认识 <code>QMainWindow</code> 类的对应结构：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="QMainWindow.png"></p><p>其中中央窗口部件可以放置 Widget，使用 <code>QMainWindow::setCentralWidget(QWidget*)</code> 在此区域添加 Widget；</p><p>首先根据目标，声明一个主窗口类（自己起个名字，这里用  <code>MainWindow</code>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: MainWindow.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面才添加上的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FindDialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HolySheet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义的常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxRecentFiles 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    <span class="comment">// Q_OBJECT</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>();    <span class="comment">// 主窗口构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// closeEvent 时 QWidget 类的虚函数，在 widget 关闭时可以自动调用。所以这里打算覆写此函数，达到“退出时弹出询问窗口”的功能，并保存一些设置到磁盘里</span></span><br><span class="line">    <span class="comment">// 流程：用户点击绑定了原生槽 QWidget::close() 的控件发出的信号(内部emit)，</span></span><br><span class="line">    <span class="comment">// 然后通过内置信号-槽自动调用原生槽 void closeEvent(QCloseEvent* event).</span></span><br><span class="line">    <span class="comment">// 注意，QCloseEvent* event 只有调用了 event-&gt;accept() 才会真正退出窗口，</span></span><br><span class="line">    <span class="comment">// 如果调用了 event-&gt;ignore()，将忽略关闭动作。详细见下文本函数实现的代码。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:    <span class="comment">// 之所以声明为私有槽，是因为它们是需要用户点击后作出相应的函数，而且不需要从类外被调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newFile</span><span class="params">()</span></span>;        <span class="comment">// 私有槽实现新建文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span></span>;        <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">save</span><span class="params">()</span></span>;        <span class="comment">// 保存文件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">saveAs</span><span class="params">()</span></span>;        <span class="comment">// 另存为文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">()</span></span>;        <span class="comment">// 表格查找功能，可以复用之前的 findDialog 窗口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">goToCell</span><span class="params">()</span></span>;    <span class="comment">// 表格定位功能，可以复用之前的 GoToCellDialog 窗口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>;        <span class="comment">// 表格排序功能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">about</span><span class="params">()</span></span>;        <span class="comment">// 关于软件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以上部分是一开始设计出来的 -----------------------------</span></span><br><span class="line">    <span class="comment">// 以下功能是后来加上的，所以实现到再解释 -------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openRecentFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateStatusBar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">holySheetModified</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:    <span class="comment">// 工具函数，大多是代码创建 UI 组件、被上面函数调用的底层功能等</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createActions</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createMenus</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createContextMenu</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createToolBars</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createStatusBar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">readSettings</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">writeSettings</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">okToContinue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">loadFile</span><span class="params">(<span class="type">const</span> QString&amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">saveFile</span><span class="params">(<span class="type">const</span> QString&amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCurrentFile</span><span class="params">(<span class="type">const</span> QString&amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateRecentFileAction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">strippedName</span><span class="params">(<span class="type">const</span> QString&amp; fullFileName)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一些私有数据成员，不用管它，真正编程时，先空着用到再添加</span></span><br><span class="line">    HolySheet* holySheet;    <span class="comment">// 注：HolySheet 类是表格的数据管理类，以后实现</span></span><br><span class="line">    FindDialog* findDialog;</span><br><span class="line">    QLabel* locationLabel;</span><br><span class="line">    QLabel* formulaLabel;</span><br><span class="line">    QStringList recentFiles;    <span class="comment">// 新类 QStringList，QString 类型的列表</span></span><br><span class="line">    QString curFile;</span><br><span class="line">    </span><br><span class="line">    QAction* recentFileActions[MaxRecentFiles];</span><br><span class="line">    QAction* separatorAction;</span><br><span class="line">    </span><br><span class="line">    QMenu* fileMenu;</span><br><span class="line">    QMenu* editMenu;</span><br><span class="line">    QToolBar* fileToolBar;</span><br><span class="line">    QToolBar* newAction;</span><br><span class="line">    QAction* newAction;</span><br><span class="line">    QAction* openAction;</span><br><span class="line">    QAction*aboutAction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在实现以上的内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: MainWindow.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MainWindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化中央窗口部件</span></span><br><span class="line">    holySheet = <span class="keyword">new</span> HolySheet;</span><br><span class="line">    <span class="comment">// QMainWindow 的方法，用于将 widget 设置在中央窗口区</span></span><br><span class="line">    <span class="built_in">setCentralWidget</span>(holySheet);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建顶部栏、侧边栏等其他部件</span></span><br><span class="line">    <span class="built_in">createActions</span>();</span><br><span class="line">    <span class="built_in">createMenus</span>();</span><br><span class="line">    <span class="built_in">createContextMenu</span>();</span><br><span class="line">    <span class="built_in">createToolBars</span>();</span><br><span class="line">    <span class="built_in">createStatusBar</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取磁盘中的软件偏好设置</span></span><br><span class="line">    <span class="built_in">readSettings</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等调用 MainWindow::find() 后再创建</span></span><br><span class="line">    findDialog = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置窗口图标，至于为何前面是“：”，请看解析</span></span><br><span class="line">    <span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/images/icon.png&quot;</span>));</span><br><span class="line">    <span class="built_in">setCurrentFile</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明的是 <code>QMainWindow::setWindowIcon(QIcon)</code> 和 <code>QIcon</code> 类；</p><p>在应用程序需要读取一些资源的时候，通常开发者会把资源放在一个文件夹中，需要的时候通过<strong>和系统相关的路径</strong>载入，这种方法可移植性较低，并且容易因为移动而丢失资源，<strong>最讨厌的是资源路径比较麻烦</strong>；</p><p>因此，比较推荐的是 <strong>Qt 的资源机制（resource mechanism）</strong>，优点是比运行时载入更方便、适用于任意文件格式；推荐的使用方法是：</p><ol><li><p>将资源分类放在各目录下，比如图片放在项目创建的 <code>images</code> 子目录下；</p></li><li><p>新建 <strong>Qt 资源系统文件</strong> <code>*.qrc</code> ，名字自己起，格式是 <code>XML</code> ，举个例子（用相对路径）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RCC</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qresource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/icon.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/gotocell.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RCC</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>记得在项目 <code>*.pro</code> 文件中添加：<code>RESOURCE = yourFileName.qrc</code>（如果您用 Qt Creator  IDE 自动添加，就当我没说）</p></li></ol><p><strong>这样在 Qt 程序的绝大多数地方路径字符串 <code>:/</code> 代表 <code>*.qrc</code> 存在的路径，不会出错</strong>；例如调用上面的 <code>icon.png</code> 时可以这么用：<code>QIcon(&quot;:/images/icon.png&quot;)</code>；</p><h3 id="4-1-2-实现菜单栏、上下文菜单和工具栏"><a href="#4-1-2-实现菜单栏、上下文菜单和工具栏" class="headerlink" title="4.1.2 实现菜单栏、上下文菜单和工具栏"></a>4.1.2 实现菜单栏、上下文菜单和工具栏</h3><p>现在介绍前面没提到的 <code>QAction</code> 类，<strong>Qt 通过 “动作” 的概念简化了有关于菜单和工具栏的编程</strong>，一个动作就是一个可以添加到任意数量的菜单和工具栏上的项；</p><p>所以在 Qt 中创建菜单和工具栏包括以下几个步骤：</p><ol><li>创建并设置动作属性，例如文本、提示、信号-槽、图标、快捷键等；</li><li>创建菜单并将动作添加到菜单上；</li><li>创建工具栏并将动作添加到工具栏上；</li></ol><p>以本章的项目来举个栗子🌰：</p><p><strong>Firstly</strong>，要创建菜单栏的项并设置属性：实现上面的 <code>MainWindow::createActions()</code> 函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建文本为“New”、父控件为 MainWindow 的动作（这样就不用手动释放了）</span></span><br><span class="line">    newAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;New&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    newAction-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/image/new.png&quot;</span>));    <span class="comment">// 设置动作的图标</span></span><br><span class="line">    newAction-&gt;<span class="built_in">setShortcut</span>(QKeySequence::New);        <span class="comment">// 设置动作的快捷键</span></span><br><span class="line">    <span class="comment">// 设置提示性文本</span></span><br><span class="line">    newAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Create a new holySheet file&quot;</span>));</span><br><span class="line">    <span class="comment">// 将动作项与底层函数连接</span></span><br><span class="line">    <span class="built_in">connect</span>(newAction, <span class="built_in">SINGAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">newFile</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下省略 Open、Save、Save As 的动作编写，因为几乎一模一样</span></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Recent Open Files 动作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxRecentFiles; ++i) &#123;</span><br><span class="line">        recentFileActions[i] = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 这里设置隐藏，因为第一次打开没有最近文件</span></span><br><span class="line">        recentFileActions[i]-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 将动作和底层的 openRecentFile() 连接</span></span><br><span class="line">        <span class="built_in">connect</span>(recentFileActions[i], <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()),</span><br><span class="line">               <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">openRecentFile</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Exit 动作</span></span><br><span class="line">    exitAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Exit&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    exitAction-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">tr</span>(<span class="string">&quot;Ctrl+Q&quot;</span>));</span><br><span class="line">    exitAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Exit the Application&quot;</span>));</span><br><span class="line">    <span class="comment">// 这里的 close() 是 QWidget::close() 自带槽</span></span><br><span class="line">    <span class="built_in">connect</span>(exitAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Select All 动作</span></span><br><span class="line">    selectAllAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;All&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    selectAllAction-&gt;<span class="built_in">setShortcut</span>(QKeySequence::SelectAll);</span><br><span class="line">    selectAllAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Select all the cells in the sheet&quot;</span>));</span><br><span class="line">    <span class="comment">// 注意，这里 holySheet 是设计成 QTableWidget 的子类，因为需要看表；</span></span><br><span class="line">    <span class="comment">// 而 QTableWidget 具有内置槽 selectAll()，因此无需自行实现</span></span><br><span class="line">    <span class="built_in">connect</span>(selectAllAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()),</span><br><span class="line">           holySheet, <span class="built_in">SLOT</span>(<span class="built_in">selectAlll</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置中的 Show Grid 动作，是否展示表格边框</span></span><br><span class="line">    showGridAction = <span class="keyword">new</span> <span class="built_in">Action</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Show Grid&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 可勾选模式</span></span><br><span class="line">    showGridAction-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 今后需要在 holySheet 中实现的方法，同步勾选状态 和 显示状态</span></span><br><span class="line">    showGridAction-&gt;<span class="built_in">setChecked</span>(holySheet-&gt;<span class="built_in">showGrid</span>());</span><br><span class="line">    showGridAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Show or hide the holySheet&#x27;s grid&quot;</span>));</span><br><span class="line">    <span class="comment">// 又一个今后需要在 holySheet 中实现的槽，同步勾选动作 和 设置显示槽</span></span><br><span class="line">    <span class="built_in">connect</span>(showGridAction, <span class="built_in">SIGNAL</span>(<span class="built_in">toggled</span>(<span class="type">bool</span>)),</span><br><span class="line">           holySheet, <span class="built_in">SLOT</span>(<span class="built_in">setShowGrid</span>(<span class="type">bool</span>)));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处省略 Auto Recalculate 动作</span></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// About 动作</span></span><br><span class="line">    aboutAction = <span class="keyword">new</span> <span class="built_in">Action</span>(<span class="built_in">tr</span>(<span class="string">&quot;About&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    aboutAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Show the information about the app&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(aboutAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">about</span>());</span><br><span class="line">    <span class="comment">// About Qt 动作</span></span><br><span class="line">    aboutQtAction = <span class="keyword">new</span> <span class="built_in">Action</span>(<span class="built_in">tr</span>(<span class="string">&quot;About &amp;Qt&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    aboutQtAction-&gt;<span class="built_in">setStatusTip</span>(<span class="string">&quot;Show the Qt library&#x27;s About Box&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里的 qApp 将设置为全局变量，QApplication 类，包含 aboutQt() 方法</span></span><br><span class="line">    <span class="built_in">connect</span>(aboutQtAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), qApp, <span class="built_in">SLOT</span>(<span class="built_in">aboutQt</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>其中 <code>QKeySequence</code> 类提供了一套标准化的键盘快捷键的对应 enum 值，可以通过查看文档中 <code>enum QKeySequence::StandardKey</code> 的枚举值来找到运行平台上正确的快捷键表示；</p><blockquote><p>标准键如：全选<code>QKeySequence::SelectAll =&gt; &quot;Ctrl+A&quot;</code>，复制 <code>Ctrl+C</code> 等；</p><p>可惜的是，上面的 <strong>退出</strong> 就没有标准化快捷键，只能自定义：<code>&quot;Ctrl+Q&quot;</code>；</p></blockquote></li><li><p>还可以通过 <code>QActionGroup</code> 类来实现<strong>相互排斥</strong>的勾选 <code>Action</code>，这里不需要就不演示了；</p></li></ol><p><strong>Secondly</strong>，需要创建菜单，并且把创建好的菜单项放进菜单中：实现 <code>MainWindow::createMenus()</code>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createMenus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意：QMainWindow 和 QMenu 类进行了组合，本身有 QMainWindow::menuBar()，</span></span><br><span class="line">    <span class="comment">// 调用即返回内嵌于 QMainWindow 中的菜单栏，位置见上面 QMainWindow 结构展示</span></span><br><span class="line">    fileMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(saveAsAction);</span><br><span class="line">    separatorAction = fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxRecentFile; ++i)</span><br><span class="line">        fileMenu-&gt;<span class="built_in">addAction</span>(recentFileActions[i]);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>(exitAction);</span><br><span class="line">    </span><br><span class="line">    editMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Edit&quot;</span>));</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(cutAction);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(copyAction);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(pasteAction);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(deleteAction);</span><br><span class="line">    </span><br><span class="line">    selectSubMenu = editMenu-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Select&quot;</span>));</span><br><span class="line">    selectSubMenu-&gt;<span class="built_in">addAction</span>(selectRowAction);</span><br><span class="line">    selectSubMenu-&gt;<span class="built_in">addAction</span>(selectColAction);</span><br><span class="line">    selectSubMenu-&gt;<span class="built_in">addAction</span>(selectAllAction);</span><br><span class="line">    </span><br><span class="line">    editMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(findAction);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(goToCellAction);</span><br><span class="line">    </span><br><span class="line">    toolsMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Tools&quot;</span>));</span><br><span class="line">    toolsMenu-&gt;<span class="built_in">addAction</span>(recalculationAction);</span><br><span class="line">    toolsMenu-&gt;<span class="built_in">addAction</span>(sortAction);</span><br><span class="line">    </span><br><span class="line">    optionsMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Options&quot;</span>));</span><br><span class="line">    optionsMenu-&gt;<span class="built_in">addAction</span>(showGridAction);</span><br><span class="line">    optionsMenu-&gt;<span class="built_in">addAction</span>(autoRecalculation);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是菜单间间隔的写法，menuBar() 没有 addMenu，有些系统呈现的是</span></span><br><span class="line">    <span class="comment">// 将之后的菜单放在最右侧，有些系统会直接忽略，有些系统仅仅显示一个分割线</span></span><br><span class="line">    <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    </span><br><span class="line">    helpMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Help&quot;</span>));</span><br><span class="line">    helpMenu-&gt;<span class="built_in">addAction</span>(aboutAction);</span><br><span class="line">    helpMenu-&gt;<span class="built_in">addAction</span>(aboutQtAction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thirdly</strong>，实现完菜单栏，再关注 <strong>上下文菜单栏（context menu 直译，或译作 “右键菜单”）</strong>：实现 <code>MainWindow::createContextMenu()</code>；</p><p><strong>实现上下文菜单的重要机制是：Qt 的上下文菜单策略（context menu policy）</strong></p><p>任何 QWidget 都有一个与之相关联的 <code>QAction</code> 列表，也有上下文菜单策略枚举变量：<code>enum Qt::ContextMenuPolicy</code>；当设置上下文菜单策略为枚举量 <code>Qt::ActionsContextMenu(=2)</code> 时，会以该 QAction 列表为 widget 的上下文菜单，当右击这个 widget 时，会展开上下文菜单；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createContextMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    holySheet-&gt;<span class="built_in">addAction</span>(cutAction);</span><br><span class="line">    holySheet-&gt;<span class="built_in">addAction</span>(copyAction);</span><br><span class="line">    holySheet-&gt;<span class="built_in">addAction</span>(pasteAction);</span><br><span class="line">    holySheet-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::ActionsContextMenu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种设计的方法比较繁琐，不重用之前的 <code>QAction</code>，即上下文菜单策略是<code>Qt::DefaultContextMenu(=1)</code> 时，重新实现：<code>QWidget::contextMenuEvent()</code> 函数，在其中创建一个 <code>QMenu</code>，添加，再对该部件调用 <code>exec()</code>，感兴趣可以尝试，这里不做演示；</p><p><strong>Last but not the least</strong>，关注<strong>工具栏</strong>：实现 <code>MainWindow::createToolBars()</code>；注意，如果你之前设置的 Action 有设置图标的话，可以直接复用，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createToolBars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fileToolBar = <span class="built_in">addToolBar</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">    fileToolBar-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line">    fileToolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">    fileToolBar-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line">    </span><br><span class="line">    editToolBar = <span class="built_in">addToolBar</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Edit&quot;</span>));</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(cutAction);</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(copyAction);</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(pasteAction);</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(findAction);</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(goToCellAction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-设置状态栏"><a href="#4-1-3-设置状态栏" class="headerlink" title="4.1.3 设置状态栏"></a>4.1.3 设置状态栏</h3><blockquote><p>什么是状态栏？大家看 Microsoft Word 中左下角每当进行一些操作时，会显示不同文字，如下，这就是状态栏：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="statusBar-example.png"></p></blockquote><p>下面实现 <code>MainWindow::createStatusBar()</code>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createStatusBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    locationLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot; w999 &quot;</span>);</span><br><span class="line">    locationLabel-&gt;<span class="built_in">setAlignment</span>(Qt::AlignHCenter);</span><br><span class="line">    locationLabel-&gt;<span class="built_in">setMinimumSize</span>(locationLabel-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">    </span><br><span class="line">    formulaLabel = <span class="keyword">new</span> QLabel;</span><br><span class="line">    formulaLabel-&gt;<span class="built_in">setIndent</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">statusBar</span>()-&gt;<span class="built_in">addWidget</span>(locationLabel);</span><br><span class="line">    <span class="built_in">statusBar</span>()-&gt;<span class="built_in">addWidget</span>(formulaLabel, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">connect</span>(holySheet, <span class="built_in">SIGANL</span>(<span class="built_in">currentCellChanged</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">updateStatusBar</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(holySheet, <span class="built_in">SIGNAL</span>(<span class="built_in">modified</span>()),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">holySheetModified</span>()));</span><br><span class="line">    <span class="built_in">updateStatusBar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分状态栏的实现大致可以分为两个部分：</p><ol><li><p>创建控件（大多是 QLabel），设置控件的布局；</p><ul><li>初始的 <code>locationLabel</code> 设置内容 “ w999 ” 表示最大单元格位置，配合 <code>locationLabel-&gt;setMinmumSize(locationLabel-&gt;sizeHint())</code> 可以确定位置状态标签大小满足要求；</li><li><code>locationLabel-&gt;setAlignment(Qt::AlignHCenter)</code> 确保文本居中对齐；</li><li><code>formulaLabel-&gt;setIndent(3)</code> 表示标签内添加文本缩进，这是实现之后进行的微调，确保美观；</li><li><code>statusBar()-&gt;addWidget(QWidget*, int)</code> 中第二个参数是<strong>伸展因子</strong>，参数为 0 表示<strong>紧贴模式（默认）</strong>，参数为 1 表示<strong>最大占用模式（还剩多少就占多少，类似 CSS 中的 auto 参数）</strong>；</li></ul></li><li><p>为状态栏的变化建立连接；</p><ul><li><p>先利用将要实现的 <code>holySheet</code> 信号 <code>currentCellChanged(int, int, int, int)</code>，和更新状态栏的槽 <code>updateStatusBar()</code> 绑定；<code>MainWindow::updateStatusBar()</code> 实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::updateStatusBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    locationLabel-&gt;<span class="built_in">setText</span>(holySheet-&gt;<span class="built_in">currentLocation</span>());</span><br><span class="line">    formulaLabel-&gt;<span class="built_in">setText</span>(holySheet-&gt;<span class="built_in">currentFormula</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>此外，为了实现 <strong>“已修改后会改变窗口标题”</strong>（很多软件在文件修改后，会在窗口标题加一个记号，如 <code>*</code>） ，还要实现 <code>MainWindow::holySheetModified()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::holySheetModified</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QMainWindow 的固有槽</span></span><br><span class="line">    <span class="built_in">setWindowModified</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">updateStatusBar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<strong>每个 <code>QWidget</code> 都有一个 <code>windowModified</code> 属性</strong> ~</p></li></ul></li></ol><h2 id="4-2-主窗口的底层函数实现"><a href="#4-2-主窗口的底层函数实现" class="headerlink" title="4.2 主窗口的底层函数实现"></a>4.2 主窗口的底层函数实现</h2><blockquote><p>函数比较多，还是从窗口的菜单功能下手；</p></blockquote><h3 id="4-2-1-File-菜单"><a href="#4-2-1-File-菜单" class="headerlink" title="4.2.1 File 菜单"></a>4.2.1 File 菜单</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新文件创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::newFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前窗口有没保存的改动，提醒是否保存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">okToContinue</span>()) &#123;</span><br><span class="line">        holySheet-&gt;<span class="built_in">clear</span>();    <span class="comment">// holySheet 等待实现的函数，清屏</span></span><br><span class="line">        <span class="built_in">setCurrentFile</span>(<span class="string">&quot;&quot;</span>);    <span class="comment">// 当前文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::okToContinue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断当前窗口是否有没有保存的修改，也是 QMainWindow 的方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isWindowModified</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> res = QMessageBox::<span class="built_in">warning</span>(</span><br><span class="line">            <span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">            <span class="built_in">tr</span>(<span class="string">&quot;The document has been modified.\n&quot;</span></span><br><span class="line">               <span class="string">&quot;Do you want to save your changes?&quot;</span>),</span><br><span class="line">            QMessageBox::Yes | QMessageBox::No | QMessageBox::Cancel</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (res == QMessageBox::Yes) <span class="keyword">return</span> <span class="built_in">save</span>();    <span class="comment">// 保存更改</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res == QMessageBox::Cancel) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 确认立即继续</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上值得一提的是，<code>QMessageBox</code> 提供了很多标准的信息对话框模板，例如：提示信息、提问、警告、严重错误，语法：<code>QMessageBox::warning(QWidget* parent, QString title, QString message, (enum)QMessageBox::StandardButtons buttons)</code>；</p><p>其中枚举类型 <code>QMessageBox::StandardButtons</code> 含有枚举值 <code>QMessageBox::Yes</code>、<code>QMessageBox::No</code>、<code>QMessageBox::Cancel</code>、<code>QMessageBox::Apply</code>等等，有特殊需要可以参考官方文档，<strong>这里设计非常巧妙，枚举值设置为 16 进制数码，使用多个 buttons 时，利用按位或 <code>|</code> （参考上面代码），达到类似 Linux 权限掩码的多选效果</strong>；</p><p>除了 <code>warning</code> 警告对话框，还有 <code>information</code> 提示对话框、<code>question</code> 提问对话框、<code>critical</code> 严重错误对话框；<strong>语法是相同的</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开已有文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">okToContinue</span>()) &#123;</span><br><span class="line">        QString fileName = QFileDialog::<span class="built_in">getOpenFileName</span>(</span><br><span class="line">                                <span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Open sheet&quot;</span>), <span class="string">&quot;.&quot;</span>,</span><br><span class="line">                                <span class="built_in">tr</span>(<span class="string">&quot;HolySheet file (*.hs)&quot;</span>)</span><br><span class="line">                            );</span><br><span class="line">        <span class="keyword">if</span> (!fileName.<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="built_in">loadFile</span>(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层实现：载入指定文件，之所以不和 MainWindow::open() 合在一起，就是为了在“打开最近文件”的功能中重用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::loadFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holySheet-&gt;<span class="built_in">readFile</span>(fileName)) &#123;    <span class="comment">// holySheet 等待实现的函数</span></span><br><span class="line">        <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;Loading canceled&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setCurrentFile</span>(fileName);</span><br><span class="line">    <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;File loaded&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>借助上面的代码，再补充一些重要的点，<code>QFileDialog</code> 类提供各种<strong>打开文件名（“浏览”）</strong>的对话窗口，和前面介绍的 <code>QMessageBox</code> 都继承于 <code>QDialog</code>；比较常用的是 <code>QFileDialog::getOpenFileName(QWdiget* parent, QString title, QString startPath, QString filter)</code>；</p><p>还有 <code>QFileDialog::getSaveFileName(...)</code>，语法相同，之和代码会介绍；</p><blockquote><p>注意：① 这里的QFileDialog 一般窗口优先级都比父窗口的高，显示在其上层；② 文件过滤器参数 <code>filter</code> 参数的格式是 “<code>&lt;description&gt; (*.suffix)</code>”，如果允许多个文件类型，则用换行符分割：“<code>&lt;desc1&gt; (*.suffix1)\n&lt;desc2&gt; (*.suffix2)</code>”；</p></blockquote></li><li><p><code>QStatusBar::showMessage(QString text, int milisec)</code> 的调用不会影响到 <code>QStatusBar</code> 中添加的 widget，会单独再显示消息；第二个参数 <code>milisec</code> 表示消息停留的<strong>毫秒数</strong>；</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curFile.<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="built_in">saveAs</span>();    <span class="comment">// 当前不存在文件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">saveFile</span>(curFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::saveFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holySheet-&gt;<span class="built_in">writeFile</span>(fileName)) &#123;    <span class="comment">// holySheet 等待实现的函数</span></span><br><span class="line">        <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;Saving canceled&quot;</span>, <span class="number">2000</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setCurrentFile</span>(fileName);    <span class="comment">// 保存成功，则设置当前文件为指定文件</span></span><br><span class="line">    <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;File saved&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::saveAs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QString fileName = QFileDialog::<span class="built_in">getSaveFileName</span>(</span><br><span class="line">                            <span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Save sheet&quot;</span>), <span class="string">&quot;.&quot;</span>,</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;HolySheet file (*.hs)&quot;</span>)</span><br><span class="line">                        );</span><br><span class="line">    <span class="keyword">if</span> (fileName.<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">saveFile</span>(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>QFileDialog::getSaveFileName</code> 和 <code>QFileDialog::getOpenFileName</code> 不同的是，<strong>如果给定的文件已经存在，会自动弹出对话框提醒是否需要覆盖</strong>；也可以传递附加参数： <code>QFileDialog::DontConfirmOverwrite</code>来改变这个行为；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::closeEvent</span><span class="params">(QCloseEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">okToContinue</span>()) &#123;</span><br><span class="line">        <span class="built_in">writeSettings</span>();    <span class="comment">// 写入配置</span></span><br><span class="line">        event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> event-&gt;<span class="built_in">ignore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得之前<strong>在声明这个函数的时候的注释内容</strong>吗？</p><p>此外，<code>QApplication</code> 默认 <code>quitOnLastWindowClosed = true</code>，如果想要**关闭最后一个窗口后，<code>QApplication</code> 仍然运行（例如托盘运行），那么可以将它设置为 <code>false</code>；</p><p>顺便实现内部函数 <code>setCurrentFile</code> 和 <code>strippedName</code>。前者用于<strong>指定当前文件（<code>curFile</code> 私有变量）、修改窗口标题、修改 “最近文件” 列表、修改窗口是否改动的状态</strong>，后者用于得到文件除去后缀的名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::setCurrentFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    curFile = fileName;</span><br><span class="line">    <span class="built_in">setWindowModified</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    QString shownName = <span class="built_in">tr</span>(<span class="string">&quot;Untitled&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!curFile.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        shownName = <span class="built_in">strippedName</span>(curFile);</span><br><span class="line">        recentFiles.<span class="built_in">removeAll</span>(curFile);</span><br><span class="line">        recentFiles.<span class="built_in">prepend</span>(curFile);</span><br><span class="line">        <span class="built_in">updateRecentFileActions</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Qt 的格式化字符串！</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;%1 [*] - %2&quot;</span>).<span class="built_in">arg</span>(shownName).<span class="built_in">arg</span>(<span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">MainWindow::strippedName</span><span class="params">(<span class="type">const</span> QString&amp; fullFileName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QFileInfo</span>(fullFileName).<span class="built_in">fileName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到了更新 “最近文件” 列表，还有之前说到的 “最近文件” 列表的动作绑定，现在来实现 <code>updateRecentFileActions</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::updateRecentFileActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QMutableStringListIterator <span class="title">iter</span><span class="params">(recentFiles)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (iter.<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!QFile::<span class="built_in">exists</span>(iter.<span class="built_in">next</span>()))</span><br><span class="line">            iter.<span class="built_in">remove</span>();    <span class="comment">// 移除还在列表中，但已不存在的文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxRecentFiles; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; recentFiles.<span class="built_in">count</span>()) &#123;</span><br><span class="line">            QString text = <span class="built_in">tr</span>(<span class="string">&quot;&amp;%1 %2&quot;</span></span><br><span class="line">                              .<span class="built_in">arg</span>(i + <span class="number">1</span>)</span><br><span class="line">                              .<span class="built_in">arg</span>(<span class="built_in">strippedName</span>(recentFiles[i]))</span><br><span class="line">                             );</span><br><span class="line">            recentFileActions[i]-&gt;<span class="built_in">setText</span>(text);</span><br><span class="line">            recentFileActions[i]-&gt;<span class="built_in">setData</span>(recentFiles[i]);</span><br><span class="line">            recentFileActions[i]-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> recentFileActions[i]-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    seperatorAction-&gt;<span class="built_in">setVisible</span>(!recentFiles.<span class="built_in">isEmpty</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 <code>QMutableStringIterator</code> 可以看作是 <code>QStringList</code>（<code>recentFiles</code> 的类型）的可变的迭代器；</p><p>其次，对于 <code>recentFileActions[i]-&gt;setData(recentFiles[i])</code> 这一步，其实 <code>QAction</code> 类的函数 <code>setData(QVariant qvar)</code> 对应设置了 <code>QVariant QAction::data</code>  数据成员，它可以保存很多种 C++ / Qt 的数据类型，<strong>包括 <code>QString</code>、一切 <code>numerical</code>、<code>bool</code>、<code>QStringList</code> 等</strong>（以后会进一步讨论）；</p><p>下面实现 <code>openRecentFile</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::openRecentFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">okToContinue</span>()) &#123;</span><br><span class="line">        QAction* action = <span class="built_in">qobject_cast</span>&lt;QAction*&gt;(<span class="built_in">sender</span>());</span><br><span class="line">        <span class="keyword">if</span> (action) <span class="built_in">loadFile</span>(<span class="built_in">action</span>()-&gt;<span class="built_in">data</span>().<span class="built_in">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QObject::sender()</code> 返回 <code>QObject*</code>，用于<strong>查出是哪个信号 / 动作调用了当前的槽（所以在槽函数内使用）</strong>；这里知道调用 <code>openRecentFile()</code> 函数的一定是 <code>QAction</code> 的动作，所以强制转换到它的指针类型，并且读出 <code>data</code> 数据，进而找到点击的 “最近文件” 并调用 <code>loadFile()</code>；</p><h3 id="4-2-2-主窗口调用-Dialog：模态和非模态"><a href="#4-2-2-主窗口调用-Dialog：模态和非模态" class="headerlink" title="4.2.2 主窗口调用 Dialog：模态和非模态"></a>4.2.2 主窗口调用 Dialog：模态和非模态</h3><p>这里会用到之前所写的 <code>findDialog</code>、<code>goToCellDialog</code>、<code>sortDialog</code> 等对话框，进行功能的<strong>拼接</strong>，同时会制作简单的 <code>about</code> 对话框。</p><p>首先是之前的 <code>findDialog</code> 对话框。由于希望用户可以在主窗口、子窗口间<strong>自由切换</strong>（毕竟只是查找功能），所以 <code>findDialog</code> 必须是 <strong>非模态的（modeless）</strong>——在运行的程序中，这种窗口独立于其他窗口，不会覆盖或阻挡，实现方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!findDialog) &#123;    <span class="comment">// 从未创建过 findDialog，懒加载模式</span></span><br><span class="line">        findDialog = <span class="keyword">new</span> <span class="built_in">FindDialog</span>(<span class="keyword">this</span>);    <span class="comment">// 设置父对象可以不用另外析构</span></span><br><span class="line">        <span class="comment">// 将 findDialog 的两个信号绑定到 holySheet 的两个槽上进行查找处理</span></span><br><span class="line">        <span class="built_in">connect</span>(findDialog, <span class="built_in">SIGNAL</span>(<span class="built_in">findNext</span>(<span class="type">const</span> QString&amp;, Qt::CaseSensitivity)), holySheet, <span class="built_in">SLOT</span>(<span class="built_in">findNext</span>(<span class="type">const</span> QString&amp;, Qt::CaseSensitivity)));</span><br><span class="line">        <span class="built_in">connect</span>(findDialog, <span class="built_in">SIGNAL</span>(<span class="built_in">findPrev</span>(<span class="type">const</span> QString&amp;, Qt::CaseSensitivity)), holySheet, <span class="built_in">SLOT</span>(<span class="type">const</span> QString&amp;, Qt::CaseSensitivity));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    findDialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    findDialog-&gt;<span class="built_in">raise</span>();</span><br><span class="line">    findDialog-&gt;<span class="built_in">activateWindow</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过点击 <code>Edit-&gt;Find</code> 菜单来调出 <code>find()</code> 函数有 3 种情况：</p><ol><li>用户第一次调用这个对话框：由于懒加载，会先创建它，再打开；</li><li>用户曾经打开过，现在是关闭（<code>visible=false</code>）状态：直接 <code>show()</code> 就足以完成<strong>显示、置顶、激活</strong>这 3 个状态；</li><li>用户曾经打开，仍没有关闭：这时 <code>show()</code> 不能完成置顶、激活这两个状态，分别需要 <code>raise()</code> 和 <code>activateWindow()</code> 来完成；</li></ol><p>按照这个逻辑，后面 3 行还可以写成：（<strong>不过没必要</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (findDialog-&gt;<span class="built_in">isHidden</span>()) findDialog-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    findDialog-&gt;<span class="built_in">raise</span>();</span><br><span class="line">    findDialog-&gt;<span class="built_in">activateWindow</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看 <code>goToCellDialog</code>，我们希望用户弹出、使用、关闭它，不希望在使用它的期间去碰主窗口，这种子窗口就是 <strong>模态的（modal）</strong>——可弹出并阻塞应用程序的对话框：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::goToCell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里为什么不 new，而只是在栈中建立一个 dialog，是由对话框目的决定；</span></span><br><span class="line">    <span class="comment">// 这里用完就可以销毁，没必要 new + delete.</span></span><br><span class="line">    <span class="function">GoToCellDialog <span class="title">dialog</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (dialog.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        QString str = dialog.lineEdit-&gt;<span class="built_in">text</span>().<span class="built_in">toUpper</span>();</span><br><span class="line">        holySheet-&gt;<span class="built_in">setCurrentCell</span>(str.<span class="built_in">mid</span>(<span class="number">1</span>).<span class="built_in">toInt</span>() - <span class="number">1</span>, str[<span class="number">0</span>].<span class="built_in">unicode</span>() - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：模态对话框不能使用 <code>show()</code>，否则变成非模态对话框！应该使用 <code>QDialog::exec()</code> 阻塞获取对话框返回结果</strong>（由 <code>accept()</code> 和 <code>reject()</code> 决定，<code>QDialog::Accepted=true</code>、<code>QDialog::Rejected=false</code>）；</p><p>另外，<code>HolySheet::setCurrentCell(int x, int y)</code> 等待实现；</p><p><code>QString::mid(int)</code> 指提取从第 int 个字符串以后的子串、<code>toInt()</code> 不解释，其正确性由之前 <code>GoToCellDialog::lineEdit</code> 中设置的 <code>QRegExpValidator</code> 来保证；</p><p>再来看 <code>sortDialog</code>，它也是一个模态对话框，允许用户<strong>在当前选定区域</strong>使用<strong>给定的列</strong>进行排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SortDialog <span class="title">dialog</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 注意：这个函数没写错，就是之后需要在 HolySheet 类中实现的一个函数</span></span><br><span class="line">    <span class="comment">// 它不是 QTableWidget 的原生函数 selectRanges()</span></span><br><span class="line">    QTableWidgetSelectionRange range = holySheet-&gt;<span class="built_in">selectedRange</span>();</span><br><span class="line">    dialog.<span class="built_in">setColumnRange</span>(<span class="string">&#x27;A&#x27;</span> + range.<span class="built_in">leftColumn</span>(),</span><br><span class="line">                          <span class="string">&#x27;A&#x27;</span> + range.<span class="built_in">rightColumn</span>());</span><br><span class="line">    <span class="keyword">if</span> (dialog.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        </span><br><span class="line">        HolySheetCompare compare;</span><br><span class="line">        compare.keys[<span class="number">0</span>] = dialog.primaryColumnCombo-&gt;<span class="built_in">currentIndex</span>();</span><br><span class="line">        compare.keys[<span class="number">1</span>] = dialog.secondaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() - <span class="number">1</span>;</span><br><span class="line">        compare.keys[<span class="number">2</span>] = dialog.tertiaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() - <span class="number">1</span>;</span><br><span class="line">        compare.ascending[<span class="number">0</span>] = </span><br><span class="line">            (dialog.primaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() == <span class="number">0</span>);</span><br><span class="line">        compare.ascending[<span class="number">1</span>] = </span><br><span class="line">            (dialog.secondaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() == <span class="number">0</span>);</span><br><span class="line">        compare.ascending[<span class="number">2</span>] = </span><br><span class="line">            (dialog.tertiaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() == <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        holySheet-&gt;<span class="built_in">sort</span>(compare);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们看到了 2 个新类。一个是 Qt 原生的 <code>QTableWidgetSelectionRange</code>，用来记录 <code>QTableWidget</code> 选中的区域信息，可以由 <code>QTableWidget::selectRange()</code> 得到当前选中的范围。含有 <code>leftColumn()</code>、<code>rightColumn()</code> 方法查到区域的列；</p><blockquote><p>注意：<code>SortDialog::setColumnRange</code> 是之前我们自己定义为了 <code>column ComboBox</code> 的取值范围而设置的函数。</p></blockquote><p>另一个类是 <code>HolySheetCompare</code>，和 <code>HolySheet</code> 一样，是之后我们自己会实现的类。这个类存储<strong>主键、第二键、第三键以及它们的排序顺序（<code>keys</code> 数组存储键的列号，<code>ascending</code> 数组按 <code>bool</code> 格式存储每个键相关顺序）</strong>，这个对象可以被 <code>HolySheet::sort()</code> 使用，用于两行间的比较；</p><blockquote><p>注意：<code>QComboBox::currentIndex()</code> 返回当前选定项的索引值，第一个为 0；</p><p>上面的 “-1” 指去除前面的 “None” 设置值。</p></blockquote><p>本节最后，我们制作一个简单的 <code>About</code> 对话框，只需要静态函数 <code>QMessageBox::about</code> 就行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::about</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">about</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;About HolySheet&quot;</span>),</span><br><span class="line">                      <span class="built_in">tr</span>(<span class="string">&quot;&lt;h2&gt;HolySheet 0.1&lt;/h2&gt;&quot;</span></span><br><span class="line">                         <span class="string">&quot;&lt;p&gt;Copyright &amp;copy; 2023 SJTU-XHW Inc.&lt;/p&gt;&quot;</span></span><br><span class="line">                         <span class="string">&quot;&lt;p&gt;HolySheet is a small application that &quot;</span></span><br><span class="line">                         <span class="string">&quot;demonstrate QAction, QMainWindow, QMenuBar, &quot;</span></span><br><span class="line">                         <span class="string">&quot;QStatusBar, QTableWidget, QToolBar and many &quot;</span></span><br><span class="line">                         <span class="string">&quot;other Qt classes.&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QMessageBox::about(QWidget* parent, const QString&amp; title, const QString&amp; contents)</code> 和 <code>warning/information/critical</code> 不同的是，<strong>它的图标取决于父控件的图标</strong>。</p><h3 id="4-2-3-设置的持久化"><a href="#4-2-3-设置的持久化" class="headerlink" title="4.2.3 设置的持久化"></a>4.2.3 设置的持久化</h3><p>现在关注 <code>readSettings()</code>、<code>writeSettings()</code> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::writeSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QSettings <span class="title">settings</span><span class="params">(<span class="string">&quot;SJTU-XHW Inc.&quot;</span>, <span class="string">&quot;HolySheet&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 这里的 saveGeometry() 是 QWidget 类的原生方法，</span></span><br><span class="line">    <span class="comment">// 返回 QByteArray，可以被 QVariant 存储</span></span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;geometry&quot;</span>, <span class="built_in">saveGeometry</span>());</span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;recentFiles&quot;</span>, recentFiles);</span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;showGrid&quot;</span>, showGridAction-&gt;<span class="built_in">isChecked</span>());</span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;autoRecalc&quot;</span>, autoRecalcAction-&gt;<span class="built_in">isChecked</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>QSettings</code> 类的值设置非常类似 <code>Python</code> 的字典键值对，值也是用 <code>QVariant</code> 存储的；默认情况下，<code>QSettings</code> 在系统上存储方法和系统种类有关（<code>Windows</code> 上就存在注册表，<code>UNIX</code> 存在文本文件中，<code>MacOS</code> 存在 <code>Core Foundation Preferences</code> 编程接口中），详细内容如下表：</p><table>    <tr style="text-align: center;">        <th>Platform</th>        <th>Format</th>        <th>Scope</th>        <th>Path</th>    </tr>    <tr>        <td rowspan=4>Windows</td>        <td rowspan=2>Native</td>        <td>User</td>        <td>HKEY_CURRENT_USER\Software\*</td>    </tr>    <tr>        <td>System</td>        <td>HKEY_LOCAL_MACHINE\Software\*</td>    </tr>    <tr>        <td rowspan=2>INI</td>        <td>User</td>        <td>%APPDATA%\*.ini</td>    </tr>    <tr>        <td>System</td>        <td>%COMMON_APPDATA%\*.ini</td>    </tr>    <tr>        <td rowspan=4>Unix</td>        <td rowspan=2>Native</td>        <td>User</td>        <td>$HOME/.config/*.conf</td>    </tr>    <tr>        <td>System</td>        <td>/etc/xdg/*.conf</td>    </tr>    <tr>        <td rowspan=2>INI</td>        <td>User</td>        <td>$HOME/.config/*.ini</td>    </tr>    <tr>        <td>System</td>        <td> /etc/xdg/*.ini</td>    </tr>    <tr>        <td rowspan=4>Mac OS X</td>        <td rowspan=2>Native</td>        <td>User</td>        <td>$HOME/Library/Preferences/com.*.plist</td>    </tr>    <tr>        <td>System</td>        <td> /Library/Preferences/com.*.plist</td>    </tr>    <tr>        <td rowspan=2>INI</td>        <td>User</td>        <td> $HOME/.config/*.ini</td>    </tr>    <tr>        <td>System</td>        <td> /etc/xdg/*.ini</td>    </tr></table><p><code>QSettings</code> 类的构造函数的参数分别是组织名、程序名，为的是方便设置的<strong>读取、查找</strong>。</p><p>此外，<code>QSettings</code> 的设置还能以路径形式指定子键的值（如 <code>findDialog/matchCase</code>）或者用 <code>beginGroup(QString)</code> 和 <code>endGroup()</code> 的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">settings.<span class="built_in">beginGroup</span>(<span class="string">&quot;findDialog&quot;</span>);</span><br><span class="line">settings.<span class="built_in">setValue</span>(<span class="string">&quot;matchCase&quot;</span>, caseCheckBox-&gt;<span class="built_in">isChecked</span>());</span><br><span class="line">settings.<span class="built_in">setValue</span>(<span class="string">&quot;searchBackward&quot;</span>, backwardCheckBox-&gt;<span class="built_in">isChecked</span>());</span><br><span class="line">settings.<span class="built_in">endGroup</span>();</span><br></pre></td></tr></table></figure><p>还有 <code>readSettings</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::readSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按组织名 + 程序名读取设置</span></span><br><span class="line">    <span class="function">QSettings <span class="title">settings</span><span class="params">(<span class="string">&quot;SJTU-XHW Inc.&quot;</span>, <span class="string">&quot;HolySheet&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">restoreGeometry</span>(settings.<span class="built_in">value</span>(<span class="string">&quot;geometry&quot;</span>).<span class="built_in">toByteArray</span>());</span><br><span class="line">    recentFiles = settings.<span class="built_in">value</span>(<span class="string">&quot;recentFiles&quot;</span>).<span class="built_in">toStringList</span>();</span><br><span class="line">    <span class="built_in">updateRecentActions</span>();    <span class="comment">// 更新 “最近文件” 菜单栏</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二参数是默认值，类似 Python dict 类的 setdefault()</span></span><br><span class="line">    <span class="type">bool</span> showGrid = settings.<span class="built_in">value</span>(<span class="string">&quot;showGrid&quot;</span>, <span class="literal">true</span>).<span class="built_in">toBool</span>();</span><br><span class="line">    showGridAction-&gt;<span class="built_in">setChecked</span>(showGrid);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> autoRecalc = settings.<span class="built_in">value</span>(<span class="string">&quot;autoRecalc&quot;</span>, <span class="literal">true</span>).<span class="built_in">toBool</span>();</span><br><span class="line">    autoRecalcAction-&gt;<span class="built_in">setChecked</span>(autoRecalc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以在应用程序的其他任何地方使用 <code>QSettings</code> 方便地查询、修改设置。</p><p>到目前为止，<code>MainWindow</code> 及其 UI 界面已经几乎完全实现，主要的任务就是实现 <code>HolySheet</code> 类和 <code>HolySheetCompare</code> 类了。</p><h3 id="4-2-4-锦上添花：多文档模式"><a href="#4-2-4-锦上添花：多文档模式" class="headerlink" title="4.2.4 锦上添花：多文档模式"></a>4.2.4 锦上添花：多文档模式</h3><p>现在我们可以准备编写程序的 <code>main</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainWindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow win;        <span class="comment">// 这里不用 new 创建</span></span><br><span class="line">    win.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑这个问题：我们想要<strong>同一时间打开、处理多个表格</strong>，怎么办？</p><p>肯定不能让用户重复打开程序——这是不方便的。应该像浏览器打开页面一样，提供多个窗口。这就是程序的<strong>多窗口（文档）模式</strong>。</p><p>这时，我们就需要对 <code>File</code> 菜单进行一些改动，<strong>使得一个应用程序实例，能够处理多个文档</strong>：</p><ul><li><p><code>File-&gt;New</code> 操作不再是使用原先存在的窗口，而是<strong>创建一个空文档窗口</strong>，已存在的窗口需要手动关闭；</p></li><li><p><code>File-&gt;Close</code> 关闭当前的主窗口，而不是清除内容；</p><blockquote><p><strong>注：原来的 <code>MainWindow</code> 没有这个 <code>Close</code> 选项，因为是单窗口，它的作用和 <code>Exit</code> 相同</strong>；</p></blockquote></li><li><p><code>File-&gt;Exit</code> 关闭所有窗口，而不是关闭当前仅有的窗口。</p></li></ul><p>想要具有多窗口功能，需要使用 <code>new</code> 来统一创建、销毁窗口。所以 <code>main.cpp</code> 改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainWindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow* win = <span class="keyword">new</span> MainWindow;</span><br><span class="line">    win-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着修改 <code>newFile()</code> 槽和 <code>Actions</code> 的组成和提示信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: mainWindow.cpp</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWondow::newFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MainWindow* otherWin = <span class="keyword">new</span> MainWindow;</span><br><span class="line">    otherWin-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    closeAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Close&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    closeAction-&gt;<span class="built_in">setShortCut</span>(QKeySequence::Close);</span><br><span class="line">    closeAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Close this window&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(closeAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line">    </span><br><span class="line">    exitAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;E&amp;xit&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    exitAction-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">tr</span>(<span class="string">&quot;Ctrl+Q&quot;</span>));</span><br><span class="line">    exitAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Exit the application&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(exitAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), qApp, <span class="built_in">SLOT</span>(<span class="built_in">closeAllWindows</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>QApplication</code> 的槽 <code>closeAllWindows()</code> 会关闭所有在 <code>app</code> 循环中创建的窗口，并且不用担心释放问题，每个窗口都会调用 <code>closeEvent()</code> 处理。</p><p>同时需要注意另一个问题，是创建窗口过多的问题。<strong>这时就需要考虑 <code>MainWindow</code> 的析构问题了</strong>。解决方法很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个设置会使得所有 <code>close()</code> 的控件立即被析构。可是有个更需要解决的问题：<strong>“最近文件” 列表的问题</strong>——多个窗口需要共享一个 “最近文件” 的列表。</p><p>这个问题可以通过将 <code>recentFiles</code> 改成静态变量的方法解决，读者可以自行思考。</p><p>实现本节 “多文档” 的目标不止这一种，还可以采用 <code>Qt</code> 的 <code>MDI</code>（multiple document interface）管理方法，以后介绍。</p><h3 id="4-2-5-锦上添花：程序启动画面"><a href="#4-2-5-锦上添花：程序启动画面" class="headerlink" title="4.2.5 锦上添花：程序启动画面"></a>4.2.5 锦上添花：程序启动画面</h3><p>这个需求可能是因为甲方的要求，又或是要掩饰程序启动慢的事实（手动狗头）；很简单，只需要在 <code>main</code> 函数中使用 <code>QSplashScreen</code> 类就能解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    QSplashScreen* splash = <span class="keyword">new</span> QSplashScreen;</span><br><span class="line">    splash-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/splash.png&quot;</span>));    <span class="comment">// 设置启动界面背景图</span></span><br><span class="line">    splash-&gt;<span class="built_in">show</span>();        <span class="comment">// 不管主程序有没有启动，先启动“启动画面”再说</span></span><br><span class="line">    </span><br><span class="line">    Qt::Alignment topRight = Qt::AlignRight | Qt::AlignTop;</span><br><span class="line">    </span><br><span class="line">    splash-&gt;<span class="built_in">showMessage</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;Setting up the main window...&quot;</span>),</span><br><span class="line">                        topRight, Qt::black);</span><br><span class="line">    MainWindow win;</span><br><span class="line"></span><br><span class="line">    splash-&gt;<span class="built_in">showMessage</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;Testing windows (5s)...&quot;</span>),</span><br><span class="line">                        topRight, Qt::black);</span><br><span class="line">    QTime timer;</span><br><span class="line">    timer.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">while</span> (timer.<span class="built_in">elapsed</span>() &lt; <span class="number">5000</span>)</span><br><span class="line">        app.<span class="built_in">processEvents</span>();</span><br><span class="line">    </span><br><span class="line">    win.<span class="built_in">show</span>();</span><br><span class="line">    splash-&gt;<span class="built_in">finish</span>(&amp;win);    <span class="comment">// 完成，把位置让给 MainWindow</span></span><br><span class="line">    <span class="keyword">delete</span> splash;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-程序中央窗口实现：QTableWidget"><a href="#4-3-程序中央窗口实现：QTableWidget" class="headerlink" title="4.3 程序中央窗口实现：QTableWidget"></a>4.3 程序中央窗口实现：<code>QTableWidget</code></h2><p>中央窗口部件常见的设计方法有下面几种：</p><ol><li>使用一个<strong>标准的 Qt 窗口部件</strong>（或继承于其的控件）作为 <code>centralWidget</code>，例如 <code>QTableWidget</code>、<code>QTextEdit</code> 等，本工程就是用这种方法；</li><li>使用一个<strong>自定义窗口部件</strong> 作为 <code>centralWidget</code>，以后会介绍怎么自定义窗口部件（继承得到的不叫自定义部件）；</li><li>使用一个<strong>带布局管理器的普通 <code>QWidget</code></strong> 作为 <code>centralWidget</code>，这也是初学者最喜欢用的方法；</li><li>使用<strong>切分窗口（<code>QSplitter</code>）</strong>，利用切分条（<code>splitter handle</code>）控制它们的尺寸；</li><li>使用<strong><code>MDI</code></strong>。上一节说了，以后再讨论。</li></ol><p>本项目使用的是标准 Qt 窗口部件 <code>QTableWidget</code>，并采用继承的方法来给 <code>HolySheet</code> 类添加一些必要的功能。先搞清 <code>QTableWidget</code> 的继承关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QObject -&gt; QWidget -&gt; QTableView -&gt; QTableWidget -&gt; HolySheet(自定义)</span><br><span class="line"></span><br><span class="line">// 这是个纯粹的数据类，就是存放数据、为 QTableWidget 类服务</span><br><span class="line">QTableWidgetItem -&gt; Cell(自定义)</span><br></pre></td></tr></table></figure><p>再了解一下 <code>QTableWidget</code> 类对象的组成：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="QTableWidget.png"></p><h3 id="4-3-1-表格的定义"><a href="#4-3-1-表格的定义" class="headerlink" title="4.3.1 表格的定义"></a>4.3.1 表格的定义</h3><p>最后开始设计 <code>HolySheet</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QTableWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后会说 Cell 类的定义和实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Cell.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一些常量</span></span><br><span class="line"><span class="keyword">namespace</span> holysheet &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> MagicNumber = <span class="number">0x7F51C883</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> RowCount = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ColumnCount = <span class="number">26</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> holysheet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类是自己写的，先声明以供 HolySheet 类使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HolySheetCompare</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HolySheet</span> : <span class="keyword">public</span> QTableWidget &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HolySheet</span>(QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 这些函数几乎全是之前在 MainWindow 类里面要用的，可以回忆一下它们被用在哪里</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAutoRecalc</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> autoRecalc; &#125;</span><br><span class="line">    <span class="function">QString <span class="title">currentLocation</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">currentFormula</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QTableWidgetSelectionRange <span class="title">selectedRange</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 之所以写 clear 的原因是，不想“全部清除”</span></span><br><span class="line">    <span class="comment">// 想要留下表头提示信息等，所以需要自定义</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">readFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">writeFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span></span>;</span><br><span class="line">    <span class="comment">// 后面实现的时候再说 HolySheetCompare 的定义和实现</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">const</span> HolySheetCompare&amp; compare)</span></span>;</span><br><span class="line"><span class="keyword">public</span> slot:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paste</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectCurrentRow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectCurrentColumn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recalculate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAutoRecalculate</span><span class="params">(<span class="type">bool</span> recalc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findNext</span><span class="params">(<span class="type">const</span> QString&amp; text, Qt::CaseSensitivity cs)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findPrev</span><span class="params">(<span class="type">const</span> QString&amp; text, Qt::CaseSensitivity cs)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modified</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">somethingChanged</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> autoRecalc;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Cell* <span class="title">cell</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">text</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">formula</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFormula</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">const</span> QString&amp; formula)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-表格的-“文本”-和-“公式”"><a href="#4-3-2-表格的-“文本”-和-“公式”" class="headerlink" title="4.3.2 表格的 “文本” 和 “公式”"></a>4.3.2 表格的 “文本” 和 “公式”</h3><p>下面正式开始实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HolySheet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">HolySheet::<span class="built_in">HolySheet</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QTableWidget</span>(parent) &#123;</span><br><span class="line">    </span><br><span class="line">    autoRecalc = <span class="literal">true</span>;    <span class="comment">// 默认选中</span></span><br><span class="line">    <span class="comment">// 自定义表格每个格子的内容模式，参数类型需要 QTableWidgetItem</span></span><br><span class="line">    <span class="comment">// 这里用的是继承的 Cell 实例</span></span><br><span class="line">    <span class="built_in">setItemPrototype</span>(<span class="keyword">new</span> Cell);</span><br><span class="line">    <span class="comment">// 设置 QTableWidget 的选择方法，这里仅限连续格子的选择</span></span><br><span class="line">    <span class="built_in">setSelectionMode</span>(ContiguousSelection);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原生信号 QTableWidget::itemChanged(QTableWidgetItem*)</span></span><br><span class="line">    <span class="comment">// 为何不直接连接 modified 信号，而非要经过 somethingChanged 槽？</span></span><br><span class="line">    <span class="comment">// 因为 somethingChanged 槽中需要检查 autoRecalc 并且自动更新！(实现会说)</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">itemChanged</span>(QTableWidgetItem*)),</span><br><span class="line">            <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">somethingChanged</span>()));</span><br><span class="line">    <span class="comment">// 第一次启动需要清空格子内容</span></span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清除行列数（为了删除内容）并重设行列总数</span></span><br><span class="line">    <span class="built_in">setRowCount</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">setColumnCount</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">setRowCount</span>(RowCount);</span><br><span class="line">    <span class="built_in">setColumnCount</span>(ColumnCount);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是给每列第一行加上表头</span></span><br><span class="line">    <span class="comment">// 无需为每行第一列考虑，它们默认数字编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ColumnCount; ++i) &#123;</span><br><span class="line">        QTableWidgetItem* item = <span class="keyword">new</span> QTableWidgetItem;</span><br><span class="line">        item-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="built_in">QChar</span>(<span class="string">&#x27;A&#x27;</span> + i)));</span><br><span class="line">        <span class="comment">// 原生函数，设置指定内容的 QTableWidgetItem 实例为每一列的表头</span></span><br><span class="line">        <span class="built_in">setHorizontalHeaderItem</span>(i, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将选中的位置回归到原点</span></span><br><span class="line">    <span class="built_in">setCurrentCell</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明中的 <code>cell()</code> 函数是为了给定行列，返回一个 <code>Cell</code> 指针，目的和 <code>QTableWidget::item()</code> 取 <code>QTableWidgetItem</code> 一样。只不过之前设置了每个格子类型为 <code>Cell</code>，所以这里自定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cell* <span class="title">HolySheet::cell</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Cell*&gt;(<span class="built_in">item</span>(row, col));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更方便的是，可以直接取单元格的数据为字符串、公式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">HolySheet::text</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Cell* c = <span class="built_in">cell</span>(row, col);</span><br><span class="line">    <span class="keyword">if</span> (c) <span class="keyword">return</span> c-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">HolySheet::formula</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Cell* c = <span class="built_in">cell</span>(row, col);</span><br><span class="line">    <span class="keyword">if</span> (c) <span class="keyword">return</span> c-&gt;formula();    <span class="comment">// Cell 类等待实现：Cell::formula()</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠ 注意：<strong>“公式” 和 “文本” 数据在每个 <code>Cell</code> 中存储在不同地方（机理和 <code>QTableWidgetItem</code> 类有关，由 <code>role</code> 参数控制，等实现 <code>Cell</code> 类再说。目前只需要知道看文本用 <code>text()</code>、看公式 <code>formula()</code>）</strong>，而公式数据可以按照计算结果来修改本格的文本数据。</p><p>这里需要搞清楚，很多情况下，公式和文本是相同的，它的<strong>处理规则</strong>如下：</p><ul><li><p>公式是普通文本时，和文本数据一样，不会计算。例如公式 “Hello” 等价于文本 “Hello”；</p></li><li><p>公式是数字的时候，公式的数字会被认为双精度浮点数（double），而非文本；</p></li><li>公式以单引号开始（Excel 中把这个叫做转义内容），那么剩余部分会被认为是文本，例如：公式 “ ‘12345 ” 就是文本，等价于字符串 “12345”；</li><li>公式以等号开始，那么公式会被认为是算数公式，例如公式 “ =A1+A2 ” 会计算 A1 和 A2 单元格的文本（转化为数字）之和的值，并填入 <code>Cell</code> 的文本数据中；</li></ul><p>这里 <strong>由公式计算出值</strong> 的过程会由 <code>Cell</code> 类完成，<code>HolySheet</code> 类不会涉及。</p><p>上面实现的是取数据的函数，下面实现设定数据的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::setFormula</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">const</span> QString&amp; formula)</span> </span>&#123;</span><br><span class="line">    Cell* c = <span class="built_in">cell</span>(row, col);</span><br><span class="line">    <span class="keyword">if</span> (!c) &#123;                    <span class="comment">// 当前格子还没有创建对应的 Cell 对象</span></span><br><span class="line">        <span class="comment">// 不用担心释放问题，这里 QTableWidget 会自动</span></span><br><span class="line">        <span class="comment">// 取得新的 QTableWidgetItem 的所有权，并且在合适的时机自动析构</span></span><br><span class="line">        c = <span class="keyword">new</span> Cell;</span><br><span class="line">        <span class="built_in">setItem</span>(row, col, c);</span><br><span class="line">    &#125;</span><br><span class="line">    c-&gt;<span class="built_in">setFormula</span>(formula);        <span class="comment">// Cell 类来设定、计算公式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的读者会发现，这里只有 <code>setFormula</code>，没有 <code>setText</code>，刚刚不是说两个分开存储吗？对，这里还是和 <code>QTableWidgetItem</code> 类有关。<strong>我们会在 “<code>QTableWidgetItem</code> 机理简介” 一节进行解释</strong>。</p><p>另外能看出来的是，我们存储表并不是使用二维数组或字符串列表，而是<strong>存储为项（item）</strong>，有助于节省空间、加快运行速度等。这种方法在 <code>QListWidget</code> 和 <code>QTreeWidget</code> 类中也能看到（对应 <code>QListWidgetItem</code> 和 <code>QTreeWidgetItem</code> 类）；</p><p>此外，对于更大数据量的应用场景，Qt 还支持模型/视图类（model/view），以后介绍。</p><p>再来实现其他用到的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">HolySheet::currentLocation</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// currentRow() 和 currentColumn() 还是 QTableWidget 的原生函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QString</span>(<span class="string">&#x27;A&#x27;</span> + <span class="built_in">currentColumn</span>()</span><br><span class="line">                + QString::<span class="built_in">number</span>(<span class="built_in">currentRow</span>() + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原本在 MainWindow 中的用途是展示在 formulaLabel 中的</span></span><br><span class="line"><span class="function">QString <span class="title">HolySheet::currentFormula</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> formula(<span class="built_in">currentRow</span>(), <span class="built_in">currentColumn</span>());    <span class="comment">// 上面的取公式函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::somethingChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为什么不直接 emit modified() 的原因在这</span></span><br><span class="line">    <span class="keyword">if</span> (autoRecalc) <span class="built_in">recalculate</span>();</span><br><span class="line">    <span class="function">emit <span class="title">modified</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-表格数据的存取"><a href="#4-3-3-表格数据的存取" class="headerlink" title="4.3.3 表格数据的存取"></a>4.3.3 表格数据的存取</h3><p>再来看<strong>表数据的存储和读取</strong>的问题。我们要用一种<strong>自定义的二进制格式</strong>来实现 <code>HolySheet</code> 文件的读取和存储。这时就用到了 <strong><code>QFile</code> 类和 <code>QDataStream</code> 类</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HolySheet::writeFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="comment">// 如果只写的打开方式失败，说明文件不存在或有权限问题等</span></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::WriteOnly)) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;Cannot write file %1:\n%2.&quot;</span>)</span><br><span class="line">                            .<span class="built_in">arg</span>(file.<span class="built_in">fileName</span>())</span><br><span class="line">                            .<span class="built_in">arg</span>(file.<span class="built_in">errorString</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">QDataStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">    <span class="comment">// 这个版本看你的 Qt 版本。例如 5.12 版本就用 QDataStream::Qt_5_12</span></span><br><span class="line">    out.<span class="built_in">setVersion</span>(QDataStream::Qt_5_14);</span><br><span class="line">    out &lt;&lt; <span class="built_in">quint32</span>(MagicNumber);        <span class="comment">// 混淆作用，你可以随便改 MagicNumber</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更改鼠标指针样式为 “等待”</span></span><br><span class="line">    QApplication::<span class="built_in">setOverrideCursor</span>(Qt::WaitCursor);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; RowCount; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; ColumnCount; ++col) &#123;</span><br><span class="line">            QString str = formula(row, col);</span><br><span class="line">            <span class="keyword">if</span> (!str.<span class="built_in">isEmpty</span>())</span><br><span class="line">                out &lt;&lt; <span class="built_in">quint16</span>(row) &lt;&lt; <span class="built_in">quint16</span>(col) &lt;&lt; str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还原鼠标指针样式</span></span><br><span class="line">    QApplication::<span class="built_in">restoreOverrideCursor</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>QDataStream</code> 模仿了标准 C++ 的流（<code>stream</code>）类，都使用 <code>&gt;&gt;/&lt;&lt;</code> 运算符来输入输出流，例如：<code>in &gt;&gt; x &gt;&gt; y;</code> 和 <code>out &lt;&lt; x &lt;&lt; y;</code>。</p><p>这里还考虑到 C++ 的基本类型<strong>在不同平台下的空间大小不同</strong>，所以将它们强制转换为 <code>qint8/quint8/...(16、32)/qint64/quint64</code>，其中 <code>quint64</code> 最安全，但占用空间也比较多，所以结合实际数据范围，上面的代码以 <code>quint16</code> 为例。</p><p>在上面的例子中，<code>HolySheet</code> 程序的文件（<code>*.hs</code>）存储格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MagicNumber(混淆码，32 bits, 4 Bytes) | row(16 bits) | column(16 bits) | string (32 bits) | row | column | string | ...</span><br></pre></td></tr></table></figure><p>而具体存储方式由 <code>QDataStream</code> 内部决定。例如，<code>quint16</code> 会被 <code>QDataStream</code> 按<strong>小端序</strong>存成 2 Bytes，<code>QString</code> 会被存成 <code>字符串长度 + Unicode字符</code> 形式；</p><p><strong>而且不同版本的 Qt ，存储方式不同</strong>，这也是为什么上面要指定 <code>QDataStream</code> 的版本（<code>setVersion</code>）；</p><p><code>QDataStream</code> 除了使用在 <code>QFile</code> 上，还能用在 <code>QBuffer</code>、<code>QProcess</code>、<code>QTcpSocket</code>、<code>QUdpSocket</code>、<code>QSslSocket</code> 等类中。</p><p>如果仅仅是读取文本，还可以用 <code>QTextStream</code> 来代替 <code>QDataStream</code>。以后会深入介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HolySheet::readFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly)) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;Cannot read file %1:\n%2.&quot;</span>)</span><br><span class="line">                            .<span class="built_in">arg</span>(file.<span class="built_in">fileName</span>())</span><br><span class="line">                            .<span class="built_in">arg</span>(file.<span class="built_in">errorString</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">QDataStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">    in.<span class="built_in">setVersion</span>(QDataStream::Qt_5_14);</span><br><span class="line">    </span><br><span class="line">    quint32 magic;</span><br><span class="line">    in &gt;&gt; magic;</span><br><span class="line">    <span class="keyword">if</span> (magic != MagicNumber) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;The file is broken / not a HolySheet file.&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">clear</span>();    <span class="comment">// 读取文件之前已经确认过，所以这里直接清空表格</span></span><br><span class="line">    </span><br><span class="line">    quint16 row, column;</span><br><span class="line">    QString str;</span><br><span class="line">    </span><br><span class="line">    QApplication::<span class="built_in">setOverrideCursor</span>(Qt::WaitCursor);</span><br><span class="line">    <span class="keyword">while</span> (!in.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">        in &gt;&gt; row &gt;&gt; column &gt;&gt; str;</span><br><span class="line">        <span class="built_in">setFormula</span>(row, column, str);</span><br><span class="line">    &#125;</span><br><span class="line">    QApplication::<span class="built_in">restoreOverrideCursor</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-4-表格编辑功能"><a href="#4-3-4-表格编辑功能" class="headerlink" title="4.3.4 表格编辑功能"></a>4.3.4 表格编辑功能</h3><p>到现在为止，<code>HolySheet</code> 除 “公式处理功能” 以外的其他功能已经基本具备（准确地说是接口做好了，可以当作 <code>Cell</code> 类已经实现），现在把 <code>Edit</code> 菜单中对应的诸如 <strong>复制、粘贴、剪切、删除</strong> 等功能补充完全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.cpp ------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::cut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">copy</span>();</span><br><span class="line">    <span class="built_in">del</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QTableWidgetSelectionRange range = <span class="built_in">selectedRange</span>();</span><br><span class="line">    QString str;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// QTableWidgetSelectionRange::rowCount 和 columnCount 是原生方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range.<span class="built_in">rowCount</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) str += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; range.<span class="built_in">columnCount</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) str += <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">            <span class="comment">// QTableWidgetSelectionRange::topRow 和 bottomRow 也是原生方法</span></span><br><span class="line">            str += formula(range.<span class="built_in">topRow</span>() + i, range.<span class="built_in">leftColumn</span>() + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置系统剪切板的静态方法</span></span><br><span class="line">    QApplication::<span class="built_in">clipboard</span>()-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的复制方法的结果认为，<strong>每列每格间隔一个制表符（<code>\t</code>），每行间格一个换行符（<code>\n</code>）——这是几乎全球通用的格式</strong>，<code>Microsoft Excel</code> 也这么用，所以可以直接粘贴到其他多数软件上。</p><p>对于<strong>粘贴、删除</strong>（剪切包含在其中）的操作，会导致<strong>modified</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里考验信息提取的简单方法的设计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::paste</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QTableWidgetSelectionRange range = <span class="built_in">selectedRange</span>();</span><br><span class="line">    QString str = QApplication::<span class="built_in">clipboard</span>()-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="comment">// 下面解析剪切板中的内容</span></span><br><span class="line">    QStringList rows = str.<span class="built_in">split</span>(<span class="string">&#x27;\n&#x27;</span>);        <span class="comment">// 和 Python 很像</span></span><br><span class="line">    <span class="type">int</span> numRows = rows.<span class="built_in">count</span>();</span><br><span class="line">    <span class="type">int</span> numColumns = rows.<span class="built_in">first</span>().<span class="built_in">count</span>(<span class="string">&#x27;\t&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 区域合法性检验</span></span><br><span class="line">    <span class="keyword">if</span> (range.<span class="built_in">rowCount</span>() * range.<span class="built_in">columnCount</span>() != <span class="number">1</span></span><br><span class="line">       &amp;&amp; (range.<span class="built_in">rowCount</span>() != numRows || range.<span class="built_in">columnCount</span>() != numColumn)) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;The contents in the clipboard cannot be&quot;</span></span><br><span class="line">                              <span class="string">&quot; pasted because the contents and the &quot;</span></span><br><span class="line">                              <span class="string">&quot;selected area aren&#x27;t the same size.&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">        QStringList columns = rows[i].<span class="built_in">split</span>(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numColumns; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> row = range.<span class="built_in">topRow</span>() + i;</span><br><span class="line">            <span class="type">int</span> column = range.<span class="built_in">leftColumn</span>() + j;</span><br><span class="line">            <span class="keyword">if</span> (row &lt; RowCount &amp;&amp; column &lt; ColumnCount)</span><br><span class="line">                <span class="built_in">setFormula</span>(row, column, columns[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">somethingChanged</span>();        <span class="comment">// 手动触发槽，其中 emit modified() 信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::del</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QTableWidget::selectedItems 原生函数</span></span><br><span class="line">    QList&lt;QTableWidgetItem*&gt; items = <span class="built_in">selectedItems</span>();</span><br><span class="line">    <span class="keyword">if</span> (!items.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="comment">// Qt 自带的 foreach，模仿 Java</span></span><br><span class="line">        foreach (QTableWidgetItem* item, items)</span><br><span class="line">            <span class="keyword">delete</span> item;</span><br><span class="line">        <span class="built_in">somethingChanged</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用了那么多次自定义的 <code>selectedRange()</code> 函数，现在看看如何实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTableWidgetSelectRange <span class="title">HolySheet::selectedRange</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QTableWidget::selectedRanges() 原生函数</span></span><br><span class="line">    <span class="comment">// 返回放置所有选中的、连续区域对应的 QTableWidgetSelectionRange</span></span><br><span class="line">    QList&lt;QTableWidgetSelectionRange&gt; ranges = <span class="built_in">selectedRanges</span>();</span><br><span class="line">    <span class="keyword">if</span> (ranges.<span class="built_in">isEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QTableWidgetSelectRange</span>();</span><br><span class="line">    <span class="comment">// 还记得吗？之前设置 setSelectionMode(ContiguousSelection)</span></span><br><span class="line">    <span class="comment">// 只会选择连续区域的单元格，所以 ranges 的 size 只会是 0 或 1</span></span><br><span class="line">    <span class="keyword">return</span> range.<span class="built_in">first</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看 <code>MainWindow</code> 的菜单栏中 <code>select</code> 子菜单中，有两个功能（另外一个 <code>selectAll</code> 函数就是 <code>QTableWidget</code> 的原生函数，不用写，直接 <code>connect</code> 就行），一个是 <code>select column</code>，另一个是 <code>select row</code>，它们就是选定当前选中单元格所在的列 / 行，只需要交给原生的 <code>QTableWidget::selectColumn/selectRow(int)</code> 就行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::selectCurrentRow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">selectRow</span>(<span class="built_in">currentRow</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::selectCurrentColumn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">selectColumn</span>(<span class="built_in">currentColumn</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再实现心心念念的 <code>findNext</code>、<code>findPrev</code>（早在 <code>findDialog</code> 的编写上就看到了）：</p><blockquote><p>注意：无论是向前找，还是向后找，都是从当前选中位置开始的，这是共识</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::findNext</span><span class="params">(<span class="type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为要找下一个，所以从同一行、下一列开始</span></span><br><span class="line">    <span class="comment">// 思考：为什么这里不用考虑出界？——有 while 循环条件保证</span></span><br><span class="line">    <span class="type">int</span> row = <span class="built_in">currentRow</span>(), column = <span class="built_in">currentColumn</span>() + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (row &lt; RowCount) &#123;</span><br><span class="line">        <span class="keyword">while</span> (column &lt; ColumnCount) &#123;</span><br><span class="line">            <span class="comment">// QString::contains(QString, Qt::CaseSensitivity) 原生函数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">text</span>(row, column).<span class="built_in">contains</span>(str, cs)) &#123;</span><br><span class="line">                <span class="built_in">clearSelection</span>();    <span class="comment">// 清除当前选择</span></span><br><span class="line">                <span class="built_in">setCurrentCell</span>(row, column);    <span class="comment">// 选择到下一个符合要求的格子</span></span><br><span class="line">                <span class="built_in">activateWindow</span>();    <span class="comment">// 焦点落回表格</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++column;</span><br><span class="line">        &#125;</span><br><span class="line">        column = <span class="number">0</span>; ++row;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使系统鸣叫一下，表示没找到</span></span><br><span class="line">    QApplication::<span class="built_in">beep</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::findPrev</span><span class="params">(<span class="type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为要查找上一个，所以从同一行、上一列开始</span></span><br><span class="line">    <span class="type">int</span> row = <span class="built_in">currentRow</span>(), column = <span class="built_in">currentColumn</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (row &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (column &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">text</span>(row, column).<span class="built_in">contains</span>(str, cs)) &#123;</span><br><span class="line">                <span class="built_in">clearSelection</span>();</span><br><span class="line">                <span class="built_in">setCurrentCell</span>(row, column);</span><br><span class="line">                <span class="built_in">activateWindow</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --column;</span><br><span class="line">        &#125;</span><br><span class="line">        column = ColumnCount - <span class="number">1</span>;</span><br><span class="line">        --row;</span><br><span class="line">    &#125;</span><br><span class="line">    QApplication::<span class="built_in">beep</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来实现支持 <code>MainWindow</code> 的 <code>Tools</code> 和 <code>Options</code> 菜单的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此函数是将所有单元格全部遍历一遍，并标记存在数据的 cell 实例，</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::recalculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; RowCount; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> column = <span class="number">0</span>; column &lt; ColumnCount; ++column) &#123;</span><br><span class="line">            <span class="comment">// Cell::setDirty() 等待实现</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cell</span>(row, column)) <span class="built_in">cell</span>(row, column)-&gt;<span class="built_in">setDirty</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面对于所有有数据的格子都调用了 setDirty()，</span></span><br><span class="line">    <span class="comment">// 接下来调用原生函数 QTableWidget::viewpoint() 获得全局视口</span></span><br><span class="line">    <span class="comment">// 对视口（类型）更新重新绘制 update()，调用每一个 “dirty” 的格子重新计算 text</span></span><br><span class="line">    <span class="built_in">viewport</span>()-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置自动重计算</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::setAutoRecalculate</span><span class="params">(<span class="type">bool</span> recalc)</span> </span>&#123;</span><br><span class="line">    autoRecalc = recalc;</span><br><span class="line">    <span class="keyword">if</span> (autoRecalc) <span class="built_in">recalculate</span>();    <span class="comment">// 设置后立即先生效一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-5-表格的排序功能"><a href="#4-3-5-表格的排序功能" class="headerlink" title="4.3.5 表格的排序功能"></a>4.3.5 表格的排序功能</h3><p>接下来解释 <code>HolySheetCompare</code> 类 和 <code>HolySheet::sort()</code> 排序的实现原理。</p><p>首先，我们要想起 <code>sort</code> 操作的用户使用方法就是：<strong>先选中一个区域，然后在弹出的 <code>sortDialog</code> 对话框中选择第一、二、三键（比较的列数）和升降序的要求，最终程序按数据和要求排序</strong>；</p><p><strong>我们简单设计给表格排序的算法</strong>：</p><ol><li><p>将选中的区域分割成 <strong>行列表</strong>（每一行在一个列表中，不同列的作为列表的不同元素），对这些行列表进行编号；</p></li><li><p>使用 Qt 自带的 <code>qStableSort</code> 算法（看到名字就知道是稳定的排序算法），它的参数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemT</span>&gt;</span><br><span class="line"><span class="built_in">qStableSort</span>(</span><br><span class="line">    QList&lt;elemT&gt;::iterator iter_start,</span><br><span class="line">    QList&lt;elemT&gt;::iterator iter_end,</span><br><span class="line">    <span class="built_in">bool</span> (comp)(elemT obj1, elemT obj2)    <span class="comment">// 这不是正规写法，源代码是typename</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中 <code>comp</code> 函数指针<strong>一定要对传入的所有可能的 <code>elemT</code> 类数据都能比较</strong>，要求：<strong>如果第一参数小于第二参数，则返回 <code>true</code>，反之无论如何返回 <code>false</code>，那么最后是升序排序</strong>；</p><blockquote><p>如果想降序，只要让 <code>comp</code> 指向的函数在大于关系时返回 <code>true</code> 就行；</p></blockquote><p>这里利用传入的将行列表作为排序的最小单元，所以传给 <code>qStableSort</code> 的第一、二参数都会是 <code>QList&lt;QStringList&gt;</code> 类型；第三个参数的函数指针<strong>是设计的核心</strong>，类型要求：<code>bool (comp)(QStringList, QStringList)</code>，<strong>并且能够按 <code>QStringList</code> 中指定的键进行依此排序</strong>；</p></li><li><p>最后只需把排序好的 <code>QList&lt;QStringList&gt;</code> 重新写入当前列表，并且标记为 “modified” 就完成了。</p></li></ol><p>为了完成上面的第二步的要求，我们设计出了 <code>HolySheetCompare</code> 类，使其<strong>不仅能够保存用户排序的需求信息，还能并且能够按用户指定的键进行元素先后判别</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.h</span></span><br><span class="line"><span class="keyword">namespace</span> hsCompare &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> KeyCount = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> hsCompare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HolySheetCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里重载括号运算符，使得这个类能有函数一样的行为：compare(A, B) -&gt; bool</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> QStringList&amp; row1, <span class="type">const</span> QStringList&amp; row2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 保存第 n 键在 QStringList 中的索引</span></span><br><span class="line">    <span class="type">int</span> keys[KeyCount];</span><br><span class="line">    <span class="comment">// 保存第 n 键是否为升序</span></span><br><span class="line">    <span class="type">bool</span> ascending[KeyCount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里是实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HolySheetCompare::operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> QStringList&amp; row1, <span class="type">const</span> QStringList&amp; row2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第一键到第三键，如果当前键比较的数据不同，那么可以得出结果，结束单次比较；</span></span><br><span class="line">    <span class="comment">// 否则，进入下一键的比较；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KeyCount; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> column = keys[i];    <span class="comment">// 当前比较的键的列索引</span></span><br><span class="line">        <span class="comment">// -1 的含义是用户没有要求这个键（对应 comboBox 界面中的 None）</span></span><br><span class="line">        <span class="comment">// column != -1 说明用户选择了这个键（要比较，否则就不比了）</span></span><br><span class="line">        <span class="keyword">if</span> (column != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(row1[column] != row2[column]) &#123;    <span class="comment">// 说明这个键就能得出结果</span></span><br><span class="line">                <span class="comment">// qStableSort 的要求。详细见上面的参数分析</span></span><br><span class="line">                <span class="keyword">if</span> (ascending[i]) <span class="keyword">return</span> row1[column] &lt; row2[column];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> row1[column] &gt; row2[column];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果本键相同，说明无法比较，需要进行下一个键的比较</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// 所有能比较的键都比完了，还是相同（不是小于），所以返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就能完整实现 <code>HolySheet::sort</code> 函数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheeet::sort</span><span class="params">(<span class="type">const</span> HolySheetCompare&amp; compare)</span> </span>&#123;</span><br><span class="line">    QList&lt;QStringList&gt; rows;    <span class="comment">// 行列表</span></span><br><span class="line">    QTableWidgetSelectionRange range = <span class="built_in">selectedRange</span>();</span><br><span class="line">    <span class="type">int</span> i;    <span class="comment">// 提出来，因为频繁用到计数变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历每一行</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; range.<span class="built_in">rowCount</span>(); ++i) &#123;</span><br><span class="line">        QStringList curRow;    <span class="comment">// 当前读到的行</span></span><br><span class="line">        <span class="comment">// 对当前行的每一列遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; range.<span class="built_in">columnCount</span>(); ++i)</span><br><span class="line">            curRow.<span class="built_in">append</span>(formula(range.<span class="built_in">topRow</span>() + i,</span><br><span class="line">                                  range.<span class="built_in">leftColumn</span>() + j));</span><br><span class="line">        rows.<span class="built_in">append</span>(curRow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qStableSort</span>(rows.<span class="built_in">begin</span>(), rows.<span class="built_in">end</span>(), compare);</span><br><span class="line">    <span class="comment">// 把行列表放回原位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; range.<span class="built_in">rowCount</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; range.<span class="built_in">columnCount</span>(); ++j)</span><br><span class="line">            <span class="built_in">setFormula</span>(range.<span class="built_in">topRow</span>() + i,</span><br><span class="line">                       range.<span class="built_in">leftColumn</span>() + j,</span><br><span class="line">                       rows[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">clearSelection</span>();    <span class="comment">// 排序完清除选中</span></span><br><span class="line">    <span class="built_in">somethingChanged</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-6-表格的公式计算实现"><a href="#4-3-6-表格的公式计算实现" class="headerlink" title="4.3.6 表格的公式计算实现"></a>4.3.6 表格的公式计算实现</h3><p>到此为止，<code>HolySheet</code> 的全部要求都实现完毕，现在进行 <code>Cell</code> 的定义和实现，一举解决公式计算问题。</p><p>根据上面 <code>HolySheet</code> 类对于 <code>Cell</code> 的请求，<code>Cell</code> 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: Cell.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QTableWidgetItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 Cell 类不需要信号-槽机制，所以就不需要 Q_OBJECT 宏</span></span><br><span class="line"><span class="comment">// 更何况 QTableWidgetItem 并不是由 QObject 派生而来</span></span><br><span class="line"><span class="comment">// 这也是为了让项（item）的开销尽可能地低、访问效率尽可能地高</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span> : <span class="keyword">public</span> QTableWidgetItem &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cell</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFormula</span><span class="params">(<span class="type">const</span> QString&amp; formula)</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">formula</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDirty</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下没见过的函数 / 数据成员，会在后面讲它们的含义</span></span><br><span class="line">    <span class="function">QTableWidgetItem* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> role, <span class="type">const</span> QVariant&amp; value)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QVariant <span class="title">data</span><span class="params">(<span class="type">int</span> role)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">QVariant <span class="title">value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前缓存的单元格的值</span></span><br><span class="line">    <span class="keyword">mutable</span> QVariant cachedValue;</span><br><span class="line">    <span class="comment">// 这个值是否不是最新的，即：是否需要更新</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> cacheIsDirty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先解释基础 C++ 知识（和 Qt 没关系）——什么是 <code>mutable</code> 关键字。在 C++ 面向对象中，<code>const(constant)</code> 和 <code>mutable</code> 是一对含义恰好相反的关键字。</p><p>考虑这个场景：<strong>如果我有个函数（<code>func_1</code>），只想改变一个数据成员（<code>A</code>），其他（<code>B/C/D/...</code>）变量都不允许它改变，想要保护起来。</strong>为了<strong>强调</strong> “保护数据成员” 这一要求，我们可能会想把 <code>func_1</code> 声明为 <code>const</code> 常量函数，但是怎么能改到 <code>A</code> 呢？</p><p>没错！把 <code>A</code> 声明为 <code>mutable</code> 变量就行了！<strong>所谓 <code>mutable</code> 关键字的作用就是：类中的、凡被此关键字修饰的数据成员，都可以被常量函数修改！</strong>这样做可以起到一个作用：强调 “这个静态函数不会修改其他任何数据” 的特点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: Cell.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Cell.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Cell::<span class="built_in">Cell</span>() &#123; <span class="built_in">setDirty</span>(); &#125;    <span class="comment">// 构造函数意思是单元格刚创建时，就需要更新</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cell::setDirty</span><span class="params">()</span> </span>&#123; cacheIsDirty = <span class="literal">true</span>; &#125;    <span class="comment">// 当前 cell 设置需要更新</span></span><br></pre></td></tr></table></figure><p>这里没必要传递父对象，因为当你 <code>new</code> 一个 <code>Cell</code> 对象，并且用 <code>setItem()</code> 插入到 <code>QTableWidget</code> 当中时，<code>QTableWidget</code> 会<strong>自动获得对该 <code>Cell</code> 对象的控制权，也会自动帮您析构</strong>。</p><h3 id="4-3-7-补充：QTableWidgetItem-类的机理简介"><a href="#4-3-7-补充：QTableWidgetItem-类的机理简介" class="headerlink" title="4.3.7 补充：QTableWidgetItem 类的机理简介"></a>4.3.7 补充：<code>QTableWidgetItem</code> 类的机理简介</h3><p>现在也不得不回答，之前提出的问题：<strong>“为什么在 <code>HolySheet</code>、<code>Cell</code> 里面都只有 <code>setFormula</code>，没有 <code>setText</code>，但却说 ‘公式和文本分开存储’ 呢？”</strong></p><p>实际上，在上面 <code>Cell.h</code> 的声明中也能看到，<code>Cell</code> 和它的父类都采用 <strong><code>role</code> 参数来控制 <code>Data</code> 的方法，而这就是 <code>QTableWidgetItem</code> 的设计。</strong></p><p>在 Qt 中有几个枚举值：<code>Qt::DisplayRole</code>、<code>Qt::EditRole</code>、<code>Qt::TextAlignmentRole</code>，用来指定 <code>QTableWidgetItem</code> 存储数据的 “不同模式”：</p><ul><li><code>Qt::EditRole</code> 表示编辑模式，指的是单元格的原始内容（raw）；</li><li><code>Qt::DisplayRole</code> 表示显示模式，指的是单元格的显示内容；</li><li><code>Qt::TextAlignmentRole</code> 表示对齐样式模式，指的是单元格的对齐方式；</li></ul><p>无论是原式内容，还是显示内容，都由 <code>QTableWidgetItem::data(Qt::role)</code> 这个原生原生函数统一返回。在默认情况下，<code>QTableWidgetItem</code> 的显示内容和原始内容是一模一样的。</p><p><strong>但是我们的程序是模仿 Excel 表格，要处理公式——于是乎，我们自定义了 <code>data(Qt::role)</code> 函数，使得公式所在单元格的显示内容和原始内容可能不一样</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QVariant <span class="title">Cell::data</span><span class="params">(<span class="type">int</span> role)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用方想要获得显示模式（已计算）的信息</span></span><br><span class="line">    <span class="keyword">if</span> (role == Qt::DisplayRole) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">value</span>().<span class="built_in">isValid</span>()) <span class="keyword">return</span> <span class="built_in">value</span>().<span class="built_in">toString</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;####&quot;</span>;    <span class="comment">// 计算失败，不符语法的公式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用方想要获得显示模式中，内容（已计算）显示的格式</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (role == Qt::TextAlignmentRole) &#123;</span><br><span class="line">        <span class="comment">// 如果里面存的是字符串（已计算）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">value</span>().<span class="built_in">type</span>() == QVariant::String) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(Qt::AlignLeft | Qt::AlignVCenter); <span class="comment">//垂直居中，左对齐</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果里面存的是数据（已计算）</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(Qt::AlignRight | Qt::AlignVCenter);<span class="comment">//垂直居中，右对齐</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用方想要获得表格的原始内容</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的方法，将格子中的所有数据原封不动地给调用方</span></span><br><span class="line">        <span class="keyword">return</span> QTableWidgetItem::<span class="built_in">data</span>(role);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先解释一下上面的 <code>if (value().isValid())</code>：这个 <code>Cell::value()</code> 是等会会实现的自定义函数，<strong>用来从 EditRole 的原始内容计算出 DisplayRole 的展示内容，换言之，这个函数用来计算公式的！！！</strong></p><p>只有当 “文本是公式，并且不符合语法“的，<code>value()</code> 函数才会返回 <code>QVariant()</code>，其他的无论是<strong>纯文本（原封不动）</strong>，还是<strong>符合语法的公式（解析得到答案）</strong>都会返回有数据的 <code>QVariant</code> 实例。</p><p>大家可能会奇怪，<code>QVariant::isValid()</code> 是用来判断什么有效的？事实上，<strong>只有使用 <code>QVariant</code> 的默认构造函数构造（无参数）出来的实例，其 <code>isValid()</code> 返回值才是 <code>false</code>，其他含有数据的实例都是 <code>true</code></strong>。</p><p>现在就能解释 “为什么只有 <code>setFormula</code> 没有 <code>setText</code>” 的问题。</p><p>因为 <code>QTableWidgetItem::text()</code> 是原生函数（这里 <code>Cell</code> 类没有覆写，因为满足要求），在内部会调用 <code>QTableWidgetItem::data(Qt::DisplayRole)</code>。也就是说：<strong><code>text()</code> 获取的是 “展示模式” 的数据，<code>formula()</code> 获取的是 原始数据</strong>。</p><p>所以，我们只需要设置原始数据（<code>Cell::setFormula</code>，更底层调用 <code>Cell::setData</code>）、设置原始数据的计算方式（<code>Cell::value</code> 及相关函数），就能让展示模式、原始内容各自呈现出我们想要的内容！</p><p>既然我们现在知道了 <code>setFormula</code>、<code>formula</code>、<code>value</code>、 <code>setData</code> 的作用，现在我们分别实现它们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cell::setFormula</span><span class="params">(<span class="type">const</span> QString&amp; formula)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用底层自定义的 data 设置原始内容</span></span><br><span class="line">    <span class="built_in">setData</span>(Qt::EditRole, formula);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">Cell::formula</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用自定义的 data 以 QString 形式返回原始数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>(Qt::EditRole).<span class="built_in">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写底层的 QTableWidgetItem::setData，添加一个 “标记 dirty” 的功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cell::setData</span><span class="params">(<span class="type">int</span> role, <span class="type">const</span> QVariant&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置数据的功能和父类一样</span></span><br><span class="line">    QTableWidgetItem::<span class="built_in">setData</span>(role, value);</span><br><span class="line">    <span class="comment">// 增添的是标记功能</span></span><br><span class="line">    <span class="keyword">if</span> (role == Qt::EditRole)</span><br><span class="line">        <span class="built_in">setDirty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>Cell::setData</code> 的 <code>if (role == Qt::EditRole)</code>，有同学可能会问，为啥要判断一下？既然修改了，直接 <code>setDirty</code> 不就行？其实不是这样。</p><p>前面说了，用户只能改原始数据 （<code>Qt::EditRole</code>）；而展示数据（<code>Qt::DisplayRole</code>）是程序内部计算公式 / 纯文本的时候才会更改。<code>setDirty</code> <strong>只需要，也只能</strong> 标记用户的修改行为。一旦标记了机器的修改行为，轻则浪费系统资源，重则会陷入 “机器更新展示数据 -&gt; <code>setDirty</code> -&gt; 机器更新展示数据 -&gt; …” 的<strong>死循环</strong>中。</p><p>继续：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里偷个懒，用我很早以前写的简易计算器程序，支持+-*/^()运算</span></span><br><span class="line"><span class="comment">// 简易计算器不在这里展示，详情请看项目源码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value() 底层函数，用于计算原始数据</span></span><br><span class="line"><span class="comment">// 是纯文本 / 符合语法的公式 -&gt; return QVariant(计算结果)</span></span><br><span class="line"><span class="comment">// 是不符合语法的公式 -&gt; return QVariant()，可以被 isValid() 发现</span></span><br><span class="line"><span class="function">QVariant <span class="title">Cell::value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cacheIsDirty) &#123;</span><br><span class="line">        cacheIsDirty = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        QString formulaStr = formula();</span><br><span class="line">        <span class="keyword">if</span> (formulaStr.<span class="built_in">startsWith</span>(<span class="string">&#x27;\&#x27;&#x27;</span>))    <span class="comment">// 单引号引起的内容代表纯文本</span></span><br><span class="line">            cachedValue = formulaStr.<span class="built_in">mid</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (formulaStr.<span class="built_in">startsWith</span>(<span class="string">&#x27;=&#x27;</span>)) &#123;    <span class="comment">// 以等号开头的是公式</span></span><br><span class="line">            cachedValue = <span class="built_in">QVariant</span>();</span><br><span class="line">            <span class="comment">// 将中缀表达式中所有变量（正则式如下）全部递归替换为已计算内容</span></span><br><span class="line">            <span class="function">QRegularExpression <span class="title">exp</span><span class="params">(<span class="string">&quot;([a-zA-Z][1-9][0-9]&#123;0,2&#125;)&quot;</span>)</span></span>;</span><br><span class="line">            QRegularExpressionMatch curMatch;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                curMatch = exp.<span class="built_in">match</span>(formulaStr);</span><br><span class="line">                <span class="keyword">if</span> (!curMatch.<span class="built_in">hasMatch</span>()) <span class="keyword">break</span>;</span><br><span class="line">                QString var = curMatch.<span class="built_in">captured</span>(<span class="number">1</span>);</span><br><span class="line">                QChar tmp = var[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> column = tmp.<span class="built_in">toInt</span>(), row = var.<span class="built_in">mid</span>(<span class="number">1</span>).<span class="built_in">toInt</span>() - <span class="number">1</span>;</span><br><span class="line">                Cell* varCell = <span class="built_in">static_cast</span>&lt;Cell*&gt;(</span><br><span class="line">                    <span class="built_in">tableWidget</span>()-&gt;<span class="built_in">item</span>(row, column)</span><br><span class="line">                );</span><br><span class="line">                QString cur;</span><br><span class="line">                <span class="keyword">if</span> (varCell) cur = varCell-&gt;<span class="built_in">text</span>();    <span class="comment">// 递归替换内容</span></span><br><span class="line">                <span class="keyword">else</span> cur = <span class="string">&quot;0.0&quot;</span>;</span><br><span class="line">                formulaStr.<span class="built_in">replace</span>(</span><br><span class="line">                    formulaStr.<span class="built_in">indexOf</span>(var),    <span class="comment">// offset</span></span><br><span class="line">                    var.<span class="built_in">size</span>(),                    <span class="comment">// length</span></span><br><span class="line">                    cur                            <span class="comment">// new string</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="function">calc <span class="title">calculator</span><span class="params">(formulaStr.toStdString().c_str())</span></span>;</span><br><span class="line">                cachedValue = calculator.<span class="built_in">getResult</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (exprErr err) &#123;    <span class="comment">// 公式计算错误</span></span><br><span class="line">                QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                                    <span class="built_in">tr</span>(err.<span class="built_in">what</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;    <span class="comment">// 是纯文本，但不清楚是不是纯数字</span></span><br><span class="line">            <span class="type">bool</span> ok;    <span class="comment">//能否转换为数字</span></span><br><span class="line">            <span class="type">double</span> d = formulaStr.<span class="built_in">toDouble</span>(&amp;ok);</span><br><span class="line">            <span class="keyword">if</span> (ok) cachedValue = d;        <span class="comment">// 赋值为双精度浮点数</span></span><br><span class="line">            <span class="keyword">else</span> cachedValue = formulaStr;    <span class="comment">// 只能作为字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后可能需要覆写一个父类里的函数 <code>QTableWidget::clone()</code>，它的作用是，当用户在表格中从未创建过的单元格中写入数据时，自动调用 <code>clone()</code> 传递给之前的 <code>QTableWidget::setItemPrototype()</code>，这里需要用 <code>Cell</code> 类 <code>new</code>，不能用父类来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTableWidgetItem* <span class="title">Cell::clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Cell</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样返回的虽然是父类指针，但是指向子类的对象，在 <code>setItemPrototype</code> 函数里会转换回去，所以满足要求。</p><hr><p>至此，<code>Cell</code>、<code>HolySheet</code> 类已经全部完成，现在只需要回到 <code>MainWindow</code> 中，把剩下还没加入的一些 <code>Action</code> 添加进去，<strong>整个程序就完成了</strong>！</p><p>如果你不是 IDE 用户，别忘了写一写 <code>CMakeLists.txt/Makefile</code> 或者运行运行 <code>qmake</code>，把项目跑起来吧 ~</p><h2 id="4-4-章末总结-amp-下文预告"><a href="#4-4-章末总结-amp-下文预告" class="headerlink" title="4.4 章末总结 &amp; 下文预告"></a>4.4 章末总结 &amp; 下文预告</h2><p>下面是本人总结的 Qt 5 类图，和上次总结相比，非常非常地长。需要 <code>*.xmind/*.pdf/*.png</code> 格式的同学可以联系本人 ~</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="C4.png"></p><p><strong>同系列下一篇文章预告：将会是关于 Qt 的 <code>event</code>（事件）、图形绘制 和 游戏的内容。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: C++ GUI Programming with Qt 4 (2nd Edition) &lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;注意：本文章将讲解 &lt;strong&gt;Qt 5&lt;/strong&gt; 入门知识，需要一定的 C++ 基础&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
    <category term="Qt" scheme="https://sjtuxhw.top/tags/Qt/"/>
    
    <category term="C++" scheme="https://sjtuxhw.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2023 HDC 参会笔记与感悟</title>
    <link href="https://sjtuxhw.top/2023/08/07/2023-HDC-%E5%8F%82%E4%BC%9A%E7%AC%94%E8%AE%B0%E4%B8%8E%E6%84%9F%E6%82%9F/"/>
    <id>https://sjtuxhw.top/2023/08/07/2023-HDC-%E5%8F%82%E4%BC%9A%E7%AC%94%E8%AE%B0%E4%B8%8E%E6%84%9F%E6%82%9F/</id>
    <published>2023-08-07T13:01:05.000Z</published>
    <updated>2023-09-19T05:18:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>Author: SJTU-XHW</i></p><p><i>Language: Simple Chinese</i></p><p><i>License:</i> <a href="https://creativecommons.org/licenses/by/4.0/deed.cy">CC BY 4.0</a></p><p><i>本人学识有限，内容难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><p>注：在笔记的 <a href="#display">这里</a> 你可以体验有趣的 WebXR 的项目 Demo ~</p><hr><h1 id="8-月-4-日"><a href="#8-月-4-日" class="headerlink" title="8 月 4 日"></a>8 月 4 日</h1><h2 id="主会场：HarmonyOS-4-与-SDK-主题演讲"><a href="#主会场：HarmonyOS-4-与-SDK-主题演讲" class="headerlink" title="主会场：HarmonyOS 4 与 SDK 主题演讲"></a>主会场：HarmonyOS 4 与 SDK 主题演讲</h2><h3 id="一、-Harmony-4-UX-设计"><a href="#一、-Harmony-4-UX-设计" class="headerlink" title="一、 Harmony 4 UX 设计"></a>一、 Harmony 4 UX 设计</h3><ul><li><p>系统输入法表情更新：上千个专属定制的 <code>unicode</code> 表情符号，精细化表情符号所代表的语义；</p><ul><li>举例：一碗面条所对应的表情就有 4 种之多，提供 “宽面”、“窄面”，“拌面”、“汤面” 之选择；</li></ul></li><li>结合 HarmonyOS 4 图像识别处理的技术，用户可以 <strong>定制 “以自己主角” 的壁纸、主题</strong>，体现个性化界面设计之美；</li><li>系统界面 UI 焕然一新，同时给用户和开发者提供更多不同的<strong>窗口组件</strong>；</li></ul><h3 id="二、-Security"><a href="#二、-Security" class="headerlink" title="二、 Security"></a>二、 Security</h3><ul><li><p>细化权限控制粒度，最小化权限给予。将应用权限交由用户决定；</p><ul><li>举例：用户不允许透露的信息（如通讯录），可以采取提交 “虚假信息” 或者空信息的方法；</li></ul></li><li><p>优化应用行为跟踪的逻辑，可以由用户自己决定是否要关联；</p></li></ul><h3 id="三、-Widget"><a href="#三、-Widget" class="headerlink" title="三、 Widget"></a>三、 Widget</h3><ul><li>通知栏不仅仅按时间排序，更按种类归类，区分轻重缓急，不会胡乱堆砌；</li><li>窗口小组件 和 负一屏 连通各个应用，例如<strong>快递/外卖的进程</strong>，<strong>天气组件关联桌面壁纸</strong>等等；</li><li><strong>应用流转</strong>，如分布式相机，端到端间 <strong>各种文件在各个界面的拖放/拉取</strong>；</li></ul><h3 id="四、-小艺"><a href="#四、-小艺" class="headerlink" title="四、 小艺"></a>四、 小艺</h3><ul><li>接入盘古大语言模型，提供模糊意图支持，语音书写通讯录、车辆设备控制……</li><li><strong>低代码编程能力</strong>：语言/文字输入意图，例如语音定制一个有特殊用途的桌面卡片组件（2 周前纪念日提醒等等）；</li></ul><h3 id="五、-Software【方舟引擎】"><a href="#五、-Software【方舟引擎】" class="headerlink" title="五、 Software【方舟引擎】"></a>五、 Software【方舟引擎】</h3><ul><li>GPU Turbo + 微内核调度 开销下降；</li><li>超帧方舟游戏引擎：编码加速、极速休眠；</li><li>超空间存储压缩引擎、动态内存引擎；</li><li>EROFS 文件系统；</li><li>拒绝 Linux 4k 小内存页管理，创新 4K、8K、16K、64K 的动态内存页管理，优化资源利用率；</li></ul><h3 id="六、-合作伙伴发言-amp-应用案例"><a href="#六、-合作伙伴发言-amp-应用案例" class="headerlink" title="六、 合作伙伴发言 &amp; 应用案例"></a>六、 合作伙伴发言 &amp; 应用案例</h3><ul><li>中国农业银行、网易、去哪儿旅行……</li></ul><h3 id="七、-SDK"><a href="#七、-SDK" class="headerlink" title="七、 SDK"></a>七、 SDK</h3><ul><li><p>便捷性：几行代码轻松设计配合系统 UI 的应用控件；</p><ul><li>案例：配合系统原生 UI 和 原生大模型接口，添加一个自定义信息显示卡片；</li></ul></li><li><p>独创 <strong>ArkTS 语言、方舟编译器及一系列开发套件</strong>，规避 JS-TS 开发生态的不足之处；</p><ul><li>结合 DevEco Studio，把模型接入开发、调试过程中；</li></ul></li><li>自动利用系统的大语言模型，帮助各个应用更智能地与用户交互；</li></ul><h1 id="8-月-5-日"><a href="#8-月-5-日" class="headerlink" title="8 月 5 日"></a>8 月 5 日</h1><blockquote><p>课程、论坛的种类很多，我只选了其中的两个论坛听；</p></blockquote><h2 id="Forum-1-Harmony-应用开发-新能力"><a href="#Forum-1-Harmony-应用开发-新能力" class="headerlink" title="Forum 1 Harmony 应用开发-新能力"></a>Forum 1 Harmony 应用开发-新能力</h2><h3 id="一、-ArkUI"><a href="#一、-ArkUI" class="headerlink" title="一、 ArkUI"></a>一、 ArkUI</h3><ul><li><p>ArkUI 框架功能集</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="ArkUIFrame.jpg" height="275px"></p></li><li><p>组件节点能力提升</p><ul><li>细粒度组件分层设计，优化视觉 &amp; 交互效果；</li><li>轻量级图文混排的效果优化；</li><li>实时模糊效果，多种模糊材质可以选择；</li><li>组件级共享元素动画，页面内<strong>一镜到底</strong>；</li></ul></li><li><p>视觉 &amp; 动效增强</p><ul><li>可动画属性增多，更多开发自由度；</li><li>强大的拖拽能力，提供文件中转站；</li><li>更多开箱即用的组件工具，更多惊艳的视觉效果；</li></ul></li></ul><h3 id="二、-智慧生活应用-ArkUI"><a href="#二、-智慧生活应用-ArkUI" class="headerlink" title="二、 智慧生活应用 ArkUI"></a>二、 智慧生活应用 ArkUI</h3><ul><li>设备详情页实现方式：95% 终端设备（台灯/空调/打印机等）采用 H5 设计；5% 终端设备（路由器/摄像头等）采用<strong>原生平台开发</strong>，多平台，维护成本高；</li><li>“<strong>一次开发、两次编译、三平台部署</strong>”；</li><li>总结：ArkUI 跨平台框架开发的优势<ul><li>性能：Harmony OS <strong>原生渲染</strong>，Android / iOS 自渲染，<strong>持平竞品</strong>；</li><li>成本<ol><li>统一 ArkUI 范式，不需要额外框架；</li><li>声明式 UI 框架、丰富 UI 组件；</li></ol></li><li>能力<ol><li>支持动态加载，版本与宿主<strong>解耦</strong>；</li><li>跨平台支持 <strong>*.so </strong> 库，<strong>降低宿主 ROM 占用</strong>；</li></ol></li></ul></li></ul><h3 id="三、-ArkUI-跨平台方案的实现"><a href="#三、-ArkUI-跨平台方案的实现" class="headerlink" title="三、 ArkUI 跨平台方案的实现"></a>三、 ArkUI 跨平台方案的实现</h3><ul><li><p>ArkUI 的架构</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="ArkUIMainFrame.jpg" height="275px"></p></li><li><p>新一代跨平台框架：<strong>ArkUI-X</strong>；</p><ul><li>扩展 ArkUI 支持跨平台的开源项目；</li><li>一次开发，多平台运行；</li><li>高性能<strong>方舟运行时</strong> + <strong>方舟渲染引擎</strong>；</li><li>生态统一的跨平台 API 能力集 + 扩展机制；</li><li>开发友好便捷，高代码复用性；</li></ul></li><li><p>命令行工具 <strong>ACE Tool</strong> 的使用</p></li><li><p>DevEco Studio IDE：跨平台 SDK 支持，运行时开销监测</p><ul><li>应用开发能力：Stage 模型 + Resource 支持 + 特化 UI 组件 + 支持 25+ 种 标准插件的 API；</li><li>应用测试能力：将资源检测、热点函数监控、行数定位的能力引入 IDE；</li><li>支持按模块集成（支持构建共享库）</li></ul></li></ul><h3 id="四、-元服务"><a href="#四、-元服务" class="headerlink" title="四、 元服务"></a>四、 元服务</h3><ul><li><p>定义：面向万物互联时代 HarmonyOS 的一种为用户提供更便捷服务的轻量级<strong>应用程序新形态</strong>；</p></li><li><p><strong>基于</strong> HarmonyOS API 开发，支持 <strong>1 + 8 + N（手机 + 电脑/平板/车载屏等 8 个平台 + N 个其他设备）</strong> 设备；</p></li><li><p>特征：随处可及、服务直达（免安装，卡片信息）、跨设备；</p></li><li><p>增强技术特性</p><ul><li><p>服务免安装提速：分包预加载；</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="MetaService.jpg" height="200px"></p></li><li><p>卡片能力演进</p><ul><li>统一 ArkUI 卡片开发范式；</li><li>卡片自定义能力；</li><li>Push 刷新，卡片信息及时推送；</li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="std.jpg" height="300px"></p></li><li><p>跨设备分享：元服务快速分享；</p></li><li><p>用户体验提升</p><ul><li>元服务<strong>即点即用，服务直达</strong>；</li><li>服务卡片<strong>便捷交互，信息直达</strong>；</li></ul></li></ul></li><li><p>元服务应用案例</p><ul><li>华为智慧生活；</li><li>讯飞听见，快速上线 + 图形翻译；</li></ul></li></ul><h3 id="五、-HarmonyOS-性能体验优化"><a href="#五、-HarmonyOS-性能体验优化" class="headerlink" title="五、 HarmonyOS 性能体验优化"></a>五、 HarmonyOS 性能体验优化</h3><ul><li><p>涉及性能的典型场景</p><ul><li>启动：启动时延；</li><li>点击响应：响应时延；</li><li>滑动/动效：帧率 60/90/120；</li></ul></li><li><p>编程模式影响</p><ul><li>同步 和 异步：异步模式。避免阻塞主线程；</li><li>命令式 和 声明式：状态变量驱动 UI 变更；</li></ul></li><li><p>关键流程</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="pipline.jpg" height="260px"></p></li><li><p>关键优化方向</p><ul><li><p>语言</p><ul><li>编码建议</li><li>Taskpool 并行化</li><li>AOT + PGO 方舟编译器优化</li></ul><blockquote><p>解析时间：60ms -&gt; 0.725ms</p></blockquote></li><li><p>UI </p><ul><li>布局优化</li><li>节点复用</li></ul></li><li><p>动效</p><ul><li>图形动画优化：结合 Ark 动画引擎</li></ul></li><li><p>后台</p><ul><li><p>后台任务运行模型</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="tasks.jpg"></p></li></ul></li></ul></li></ul><h3 id="六、-Cocos-验证-HarmonyOS-性能优化"><a href="#六、-Cocos-验证-HarmonyOS-性能优化" class="headerlink" title="六、 Cocos 验证 HarmonyOS 性能优化"></a>六、 Cocos 验证 HarmonyOS 性能优化</h3><ul><li><p>背景介绍</p><ul><li>游戏项目验证的原因<ul><li>CPU + GPU 利用率高；</li><li>对帧率敏感，不得低于 30；</li></ul></li><li>第一个适配 OpenHarmony 的游戏引擎；</li></ul></li><li><p>性能优化之旅</p><ul><li>AOT 优化（Ahead of Time）：能够在 Host 端将字节码提前编译成 Target 端可运行的机器码，这样字节码可以获得充分编译优化，放到 Target 端运行时可以获得加速；</li><li>优化方向<ul><li><strong>保存并完善 TS 源码类型信息（因为 TypeScript 打包为 JavaScript 时丢失变量类型信息）</strong>；</li><li>使用 <strong>PGO（Profile Guided Optimization）定位热点函数</strong>；</li></ul></li></ul></li><li><p>实现路径</p><ul><li>解决运行时问题；</li><li>Profile 工具分析热点函数；</li><li>TsAutoReturnType 自动补齐类型；</li><li>制定高性能编码规范；</li></ul></li></ul><h3 id="七、-HarmonyOS-端云开放能力"><a href="#七、-HarmonyOS-端云开放能力" class="headerlink" title="七、 HarmonyOS 端云开放能力"></a>七、 HarmonyOS 端云开放能力</h3><ul><li>华为账号接入；</li><li>软硬协同<ul><li>统一扫码服务实现方案；</li><li>Analytics Kit 能力框架；</li><li>Ad API；</li><li>Map 能力框架；</li></ul></li></ul><h3 id="八、-媒体生态一致性"><a href="#八、-媒体生态一致性" class="headerlink" title="八、 媒体生态一致性"></a>八、 媒体生态一致性</h3><ul><li><p>拍摄效果一致性</p><ul><li><p>系统相机 和 第三方相机 的 不一致问题的解决</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="problem.jpg" height="200px"></p><p><strong>解决方案</strong>：</p><ol><li>统一接口，统一流程，统一效果；</li><li>分离预览、拍照、录像操作流，明确数据流的用途；</li></ol></li></ul></li><li><p>音视频焦点、时延、播控一致性</p><ul><li>音频焦点管理；</li><li>低时延播放；</li></ul></li></ul><h3 id="九、-HarmonyOS-文件存储技术进展"><a href="#九、-HarmonyOS-文件存储技术进展" class="headerlink" title="九、 HarmonyOS 文件存储技术进展"></a>九、 HarmonyOS 文件存储技术进展</h3><ul><li>端云一体的文件系统：<strong>统一数据管理框架 UDMF</strong>；</li><li>应用文件分享框架；</li><li>备份恢复框架；</li></ul><h3 id="十、-HarmonyOS-网络应用开发"><a href="#十、-HarmonyOS-网络应用开发" class="headerlink" title="十、 HarmonyOS 网络应用开发"></a>十、 HarmonyOS 网络应用开发</h3><ul><li>蜂窝网络；</li><li>HTTP 2-&gt;3；</li><li>指定 HTTP 合理优先级和数据类型；</li><li>建议支持 IPv4/6 双栈；</li></ul><h2 id="Forum-2-Huawei-AR-amp-VR"><a href="#Forum-2-Huawei-AR-amp-VR" class="headerlink" title="Forum 2 Huawei AR &amp; VR"></a>Forum 2 Huawei AR &amp; VR</h2><h3 id="一、-产业背景-和-资源"><a href="#一、-产业背景-和-资源" class="headerlink" title="一、 产业背景 和 资源"></a>一、 产业背景 和 资源</h3><ul><li><p>Devices：</p><ul><li><p>Head mounted displays</p></li><li><p>Controllers</p></li><li><p>Base station</p></li><li>Body / hand / Object / Eye Tracker</li><li>……</li></ul></li></ul><ul><li>想要获取 OpenXR 资源或者 API 文档：<ul><li><a href="https://registry.khronos.org/OpenXR/#apispecs">OpenXR API specs</a>；</li><li><a href="https://github.com/KhronosGroup/OpenXR-Tutorials">Github - OpenXR Tutorials</a>；</li></ul></li></ul><h3 id="二、-OpenXR"><a href="#二、-OpenXR" class="headerlink" title="二、 OpenXR"></a>二、 OpenXR</h3><ul><li><p>和 OpenGL 的地位很像，就是一种<strong>跨平台的 API 规范</strong>，适配各种标准 XR 设备；</p><blockquote><p>X 仅仅是占位符，可以代表 AR，VR，Mixed Reality等</p></blockquote></li><li><p>适配 Unreal、Unity 等游戏引擎；</p></li><li><p>最新应用：Kitware Paraview / Beat Saber；</p></li><li><p>工作小组：一致性测试（Conformance Test Suite），Input Device Plugin，5G/Cloud……</p></li><li><p>KHR / EXT：是否通过 CTS 验证的 lib；</p></li><li><p>OpenXR Resources；</p></li></ul><h3 id="三、-Metaverse"><a href="#三、-Metaverse" class="headerlink" title="三、 Metaverse"></a>三、 Metaverse</h3><ul><li>元宇宙的标准开发 与 元宇宙标准论坛：Metaverse Standard Forum (MSF)</li></ul><h3 id="四、-WebXR"><a href="#四、-WebXR" class="headerlink" title="四、 WebXR"></a>四、 WebXR</h3><ul><li><p>Web 并不局限于浏览器，具有 UA 和 对应的数据类型</p><blockquote><p>WebXR 基于 WebGL</p></blockquote></li><li><p>W3C Immersive Web 的工作组和标准</p><ul><li>开发资源 three.js + unity</li></ul></li><li><p>Web XR Core 的 API 规范</p></li></ul><h3 id="五、-Web3D-助力-WebXR"><a href="#五、-Web3D-助力-WebXR" class="headerlink" title="五、 Web3D 助力 WebXR"></a>五、 Web3D 助力 WebXR</h3><ul><li><p>WebXR 的背景</p><ul><li>Web3D 与 元宇宙同时产生于 1992 年；</li><li>元宇宙被称为新一代 3D 引擎技术；</li><li>元宇宙有互联网方面 3D 引擎的需求；</li><li>云渲染的计算/传输/运营成本大；</li><li>优势：用户的选择<ul><li>易用便捷普通去中心化；</li><li>上线访问随时随地随意；</li><li>上线创作任意场景任意操作多人协同；</li></ul></li></ul></li><li><p>Web3D 的痛点剖析</p><ul><li><p>总体量瓶颈：场景体量太大</p><ul><li>网络带宽却实在有限，相对于3D规模与体量的扩张显得越来越狭窄；</li><li>Web3D大数据的互联网传输之路永远都是一条 “窄路”；</li></ul></li><li><p>文件粒度瓶颈：目前的场景文件结构没有考虑到网络传输</p><ul><li>图形文件均以粗粒度模式来存储；</li><li>不利于网上在线加载与即时渲染的细粒度化调度处理；</li><li>网页端算力与缓存的双重受限；</li><li>传统的重量级粗粒度场景文件结构以及本地的场景管理需要改造；</li></ul></li><li><p>网络传输瓶颈</p><ul><li>初始加载时间过长，而用户容忍时长仅通常仅为秒级；</li><li>漫游时渐进式在线加载要流畅，因带宽堵塞而很容易导致网络瘫痪；</li><li>多人同步在线易造成服务器崩溃；</li></ul></li><li><p>网页端渲染瓶颈</p><ul><li>难以支撑在线渲染规模越来越大的场景；</li><li>难以达到在线实时全局光照的高品质渲染；</li></ul></li></ul></li><li><p><span id="display">关键技术</span></p><blockquote><p><strong>下面的 “教授的网页演示” 比较有趣，可以点击探索 ~ 不保证网站永久有效 ~</strong></p></blockquote><ul><li><p>建筑物细粒度化预处理</p></li><li><p>大规模树木群落的轻量级细粒度化处理：<a href="http://smartweb3d.com/forest/">教授的网页演示</a>；</p></li><li><p>海量 Web3D 数字孪生智慧工厂：<a href="http://smartweb3d.com/huayi">教授的网页演示</a>；</p></li><li><p>细粒度化边缘对等传输调度：<a href="http://smartweb3dlab.cn">教授的网页演示</a>；</p><blockquote><p>理论上人越多，速度越快；</p></blockquote></li><li><p>轻量级 Web3D 全局光照在线高品质渲染：<a href="http://116.225.120.225:8888/">教授的网页演示</a>；</p><blockquote><p>据教授说，一张 GTX 20 系的显卡就能实现 300+ 人同时在线；</p></blockquote><ul><li>大规模人群的轻量级细粒度化在线渲染：<a href="http://smartweb3d.com/gym/">教授的网页演示</a>；</li></ul></li></ul></li><li><p>总结</p><ul><li>OS层面：HarmonyOS 与轻量级在线 3D 关键技术融合；</li><li>浏览器层面：与轻量级 Web3D 引擎相融合；</li><li>通讯传输层面：三维元宇宙无穷大数据的部署与分布式传输调度协议；</li></ul></li></ul><h3 id="六、-华为-AR"><a href="#六、-华为-AR" class="headerlink" title="六、 华为 AR"></a>六、 华为 AR</h3><ul><li><p>华为的 AR 生态：AR Engine 全球 Top3 AR 开发引擎；</p></li><li><p>Instant AR 实现快速放置虚拟物体</p></li><li><p>环境跟踪 和 光照估计、实时环境构建、图像锚定、语义跟踪、表面 Mesh 跟踪；</p></li><li><p>人脸跟踪和人体跟踪：面部表情，人脸 mesh，头部位姿矩阵，2/3D 骨骼，姿态识别，人体 mask；</p></li><li><p>开发框架</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="ARFrame.jpg" height="350px"></p></li><li><p>开发框架的难题</p><ol><li>跟踪手机的位置姿态，统一虚拟坐标系和物理坐标系；</li><li>识别桌面，锚定虚拟物体；</li><li>提供手机相机的实时参数，统一渲染引擎虚拟相机的相应参数；</li></ol></li></ul><h3 id="七、-华为-VR-Engine"><a href="#七、-华为-VR-Engine" class="headerlink" title="七、 华为 VR Engine"></a>七、 华为 VR Engine</h3><ul><li>VR 交互进展：手柄🎮交互，<strong>手眼交互</strong>【重要的是触觉反馈】，空间感知；</li><li>渲染领域：AI 画质增强，Smart Render 3.0【动态注视点，PTW】；</li><li>VR Engine 的 XR 框架；</li><li>端到端空间视频设计方案 + 体积视频部署案例；</li></ul><h3 id="八、-Cocos-CreatorXR"><a href="#八、-Cocos-CreatorXR" class="headerlink" title="八、 Cocos CreatorXR"></a>八、 Cocos CreatorXR</h3><ul><li>Cocos 数字内容生产平台<ul><li>Cocos 开发工具链的优势特点</li><li>Cocos 产品图谱</li></ul></li><li>CreatorXR 创作工具<ul><li>Cocos CreatorXR 的使用方法/工作流：5个步骤，一站式配置开发</li><li>集成了主流标准：WebGL OpenXR</li><li>同时支持：WebXR AR MR 构建创作</li></ul></li><li>共建 XR 内容生态<ul><li>持续为开发者提供完善快捷的跨平台开发工具；</li></ul></li><li>总结<ol><li>Cocos 3D 引擎轻量高效跨平台，适用于车机、元宇宙、游戏等各种业务场景；</li><li>CreatorXR 一站式创作工具，一次开发，多平台、多设备、多形式发布；</li><li>CocosXR Runtime安全轻量低功耗，系统级运行容器，快速推动生态繁荣；</li></ol></li></ul><h3 id="九、-Unity-打造高画质多交互的-XR-内容"><a href="#九、-Unity-打造高画质多交互的-XR-内容" class="headerlink" title="九、 Unity 打造高画质多交互的 XR 内容"></a>九、 Unity 打造高画质多交互的 XR 内容</h3><ul><li>Unity XR 新架构优势</li><li>Unity XR 开发者工具介绍<ul><li>XR Interaction Toolkit<ul><li>视频功能展示：UI 交互，套件交互，物体抓取，注视交互（XR Gaze Interaction）；</li></ul></li><li>AR Foundation；</li><li>MARS；</li></ul></li><li>Unity XR 新增功能介绍和使用<ul><li>New Input System for XR；</li><li>URP for XR；</li><li>HDRP for XR；</li></ul></li><li>Unity XR 相关案例</li></ul><h1 id="8月-6-日"><a href="#8月-6-日" class="headerlink" title="8月 6 日"></a>8月 6 日</h1><h2 id="活动：Codelabs-amp-体育馆展区"><a href="#活动：Codelabs-amp-体育馆展区" class="headerlink" title="活动：Codelabs &amp; 体育馆展区"></a>活动：Codelabs &amp; 体育馆展区</h2><ul><li>所需技术：ArkTS（<strong>TypeScript 的超集</strong>），简单的项目认知能力，会看 OpenHarmony 的文档，了解 DevEco Studio 的基本使用；</li><li>本人参与的 Tasks 有：HarmonyOS 页面 Scroller 二级联动的实现、HMS Core ML QRCode 识别程序补全、HMS Core Swap 产品购买程序的补全、OpenGallery Connect 程序的低代码开发和 UI 设计；</li></ul><h1 id="附录-Ⅰ-快讯整理"><a href="#附录-Ⅰ-快讯整理" class="headerlink" title="附录 Ⅰ  快讯整理"></a>附录 Ⅰ  快讯整理</h1><p>2023 年 8 月 4 日，华为开发者大会（HDC.Together）开幕演说在东莞篮球中心成功举行。华为发布了 HarmonyOS 4 和 全新升级的鸿蒙开发套件。另外，HarmonyOS Next 开发者预览版本等一系列领先技术也为用户提供前所未有的革新体验。</p><p>5 至 6 日，HDC 在三丫坡开设了数个开发者论坛供来自各地的工程师和技术研究人员进行学习和交流讨论。另外，现场的多个地点还设置了多种趣味性十足的闯关和运动游戏，让参会者们在学习讨论之余放松心情、锻炼身体。</p><p>最为火爆的是位于 B3 区的 Codelabs 活动，将华为 ArkUI 和 ArkTS 语言融入编程趣味挑战中，提供不同代码量、不同难度的闯关赛题。在学习到最新的优秀语言的同时，还能获得大量丰富的奖励。</p><h1 id="附录-Ⅱ-随笔-amp-感悟"><a href="#附录-Ⅱ-随笔-amp-感悟" class="headerlink" title="附录 Ⅱ  随笔 &amp; 感悟"></a>附录 Ⅱ  随笔 &amp; 感悟</h1><p>三天的时间一转眼就过去了，在东莞三丫坡召开的华为开发者大会在思维的碰撞和交流中落下帷幕。回顾这几天的经历，可以说是让我受益匪浅。会场内，来自不同国家的人们满怀激情和热忱，交流着技术观点；志愿者和工作人员在超过 30℃ 的天气下维护秩序、给参会者提供无微不至的帮助。</p><p>虽然目前我的学识有限，会议的内容我还无法全部理解，但是这里开放包容、开源共享的氛围，将激励着我努力学习，向我感兴趣的方向继续前进。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="more/oc.jpg"></p><p>我要感谢这次会议跟随我们的吴老师、李老师，还有安排这次活动的老师和工作人员，他们在我遇到某些问题时及时、热心地协助我解决。没有他们的帮助，我可能就无法享受到这次的视听盛宴。</p><p>我所参加的两个论坛，一个在 ArkUI 方面为开发者介绍了一种新语言 ArkTS（衍生自 TypeScript），这为我们展开了贴近于 HarmonyOS UI 设计的新方法；另一个论坛向我们介绍了关于华为 AR &amp; VR 方面的最新进展，基于 OpenXR 规范的 Web3D 和 鸿蒙 XR 的技术正不断成熟，开发生态也不断扩大。</p><hr><p>在本次大会的讨论中，有几项技术让我比较感兴趣，其中一个是华为独创的 <code>ArkUI</code> 及其配套的设计语言 <code>ArkTS</code>，它是 <code>TypeScript</code> 的超集，包含了绝大多数 TS 的语法，并且集成了新的 features，像 <code>@entry</code> annotation，还有更新颖、简洁的 UI 声明语法。</p><p>相较于 <code>HTML + CSS + JS</code> 三件套组织形式，华为的 <code>ArkTS</code> 则简化了编写人员的技术栈，在一个编码文件中轻松 handle 了 HarmonyOS 的控件外观设计。</p><p>在 Codelabs 活动中，我也上手初步认识了这样的一个开发流程，通过 AppGallery 和 HMS Core 等项目的补充实现，让我深深体会到这项技术是如此的便捷和优雅。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="more/mosaic.jpg"></p><hr><p>此外，工作人员还向我们介绍了 HarmonyOS 的软总线技术。他们强调，这种华为独创的技术能够成功地支持 <code>WI-FI / Bluetooth</code> 双通道连接，并且在传输文件的同时，优先选择速度更快的通道，并且<strong>切换对用户无感知</strong>，保证当前最大的传输速率。这是 Apple 等厂商所不具备的技术。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="more/dbus.jpg"></p><p>现场的工作人员还强调，在工业应用场景中，HarmonyOS 软总线会更注重 <strong>海量设备互联、发送的成功率</strong>，以确保满足大规模流量的实际应用场景。</p><p>作为 HarmonyOS 其他繁荣的上层应用的基石之一，软总线不仅需要速度和质量，更要安全。OpenHarmony 俱乐部也同时关注<strong>机密软总线</strong>的底层技术，相信能够为 HarmonyOS 的软总线的进一步发展提供更多优秀的思路。</p><hr><p>本次大会论坛的热点之一是华为 XR 技术，而同济大学的贾金原教授在 Web3D 和元宇宙方面所做的报告更是让我眼前一亮。从剖析 Web3D、WebXR 和元宇宙的背景和当前痛点出发，提供了数个全面提升视觉效果和渲染性能的算法。教授还在会上分享了多个超大规模的在线 Demo，同时具有十足的趣味性和启发性。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="more/XR.jpg"></p><p>这次的 HDC 让我收获到了很多，可以说是不虚此行！</p><h1 id="附录-Ⅲ-饮食-in-深圳-东莞"><a href="#附录-Ⅲ-饮食-in-深圳-东莞" class="headerlink" title="附录 Ⅲ  饮食 in 深圳/东莞"></a>附录 Ⅲ  饮食 in 深圳/东莞</h1><blockquote><p>“ <strong>有一千双手，就有一千种味道。中国烹饪，无比神秘，难以复制</strong> ”  —— <i>《舌尖上的中国》</i></p></blockquote><ul><li><p>茶餐厅比较有名。去里面吃饭貌似服务员会默认你带上一个饮品（奶茶/凉茶/红茶的种类挺多），好像是饮食习惯。平均单人价格 40+；</p></li><li><p>东莞这边的餐厅，汤汤水水的名称明显密集。让我极为震惊的是，汤的名字可谓各具特色——“川贝雪梨猪肺汤”、“五指毛桃猪骨汤”、“XX爪XX壳汤”（名字忘了），比较后悔的是没有拍个照片，每个汤的成分似乎都出在了我意料之外的地方（没有见识实锤，，</p></li><li><p>点名表扬 “XX鱼泡”（名字还是忘了），极薄的像馄饨皮一样的一层包裹着鱼肉丸，口感 Q 弹爽滑，还是比较吸引人的；</p></li><li><p>这里的卤味的“叉烧包”和我想象中的大相径庭：上海那边买到的叉烧包更像小煎包，大约是婴儿的拳头大小，可能灌汤；但这里的叉烧包更像馒头（不是指馅，指的是材质和大小），馅的话我点的是卤味，所以里面是 juicy 的五花肉和腊肠；</p></li><li><p>印象最深刻的是<strong>从内到外都呈现 <u>淡瓦片颜色</u> 的豆腐</strong>（不知道瓦片颜色的同学可以打开 “植物大战僵尸”，并从僵尸脸上取色）；味道比较奇妙，有一种腥味和豆腐原生的厚重的感觉杂糅在一起。很好奇是用什么手法做出来的，毕竟我见过的豆腐不都是白色的材质么。我们问了服务员做法是啥，服务员<strong>笑而不语</strong>（说吧，是商业机密还是科技狠活</p></li><li><p>这边有一种全新的烹饪方式我从未听说过：<strong>啫</strong>。说实话，菜单上有一片区域的菜名全部都以 “啫” 开头，我都误以为是加啫喱做出来的菜😂；晚上回去网上查了一下才发现这是<strong>粤菜的一种做法</strong>：</p><blockquote><p>生啫是将生的食材直接投入瓦煲内，加入味料和酱料，全程大火干烧至熟，不加入一滴水，因此，这种技法对瓦煲的杀伤力非常大，上边是生冷的食材，下边是猛烈的旺火，在一冷一热的刺激之下，瓦煲用上一、两次就会出现裂缝，而有裂缝的瓦煲就不能再循环使用了，如果勉强上阵，上一次啫时渗入裂缝中的油和肉汁就会跑出来，那股异味会传到这一次的食材里面。</p><p>而熟啫则是由于有个别食材特别难熟、或韧度特别大，所以前期必须要先经过熟处理才能拿来啫。</p><p>小声说：我们点的 “啫芥兰” 用的锅就裂开了，事后回想起难怪味道比较奇怪……</p></blockquote></li></ul><h1 id="附录-Ⅳ-大会园区美景"><a href="#附录-Ⅳ-大会园区美景" class="headerlink" title="附录 Ⅳ 大会园区美景"></a>附录 Ⅳ 大会园区美景</h1><p>图片由本人摄制。篇幅有限，只展示一部分。</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="more/1.jpg"></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="more/2.jpg"></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="more/3.jpg"></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="more/4.jpg"></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="more/5.jpg"></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="more/6.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;i&gt;Author: SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Language: Simple Chinese&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;License:&lt;/i&gt; &lt;a href=&quot;https://creativecommons.org/licenses/by/4.</summary>
      
    
    
    
    <category term="literary" scheme="https://sjtuxhw.top/categories/literary/"/>
    
    
    <category term="HDC" scheme="https://sjtuxhw.top/tags/HDC/"/>
    
    <category term="HarmonyOS" scheme="https://sjtuxhw.top/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>从C++入门Qt（一）</title>
    <link href="https://sjtuxhw.top/2023/07/28/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://sjtuxhw.top/2023/07/28/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-07-28T06:44:12.000Z</published>
    <updated>2023-09-19T05:26:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: C++ GUI Programming with Qt 4 (2nd Edition) </i></p><p><i>注意：本文章将讲解 <strong>Qt 5</strong> 入门知识，需要一定的 C++ 基础</i></p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p><strong>观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~</strong></p><hr><span id="more"></span><h1 id="Chapter-0-前置知识"><a href="#Chapter-0-前置知识" class="headerlink" title="Chapter 0 前置知识"></a>Chapter 0 前置知识</h1><h2 id="0-1-C-基础-和-面向对象编程"><a href="#0-1-C-基础-和-面向对象编程" class="headerlink" title="0.1 C++ 基础 和 面向对象编程"></a>0.1 C++ 基础 和 面向对象编程</h2><h2 id="0-2-C-的宏（macro）"><a href="#0-2-C-的宏（macro）" class="headerlink" title="0.2 C++ 的宏（macro）"></a>0.2 C++ 的宏（macro）</h2><ul><li>宏的定义非常自由甚至可以把一个符号定义为一个很长的字符串，甚至代码；主要是因为宏的工作原理是<strong>编译前将宏直接原封不动地替换</strong>；例如下面的极端例子：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接把 HELLO 定义为一串代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLO \</span></span><br><span class="line"><span class="meta">    QLabel* label = new QLabel(<span class="string">&quot;&lt;h2&gt;&lt;i&gt;Hello,&lt;/i&gt;&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;&quot;</span>);\</span></span><br><span class="line"><span class="meta">    QPushButton* btn = new QPushButton(<span class="string">&quot;Quit&quot;</span>);\</span></span><br><span class="line"><span class="meta">    QObject::connect(btn, SIGNAL(clicked()), &amp;app, SLOT(quit()));\</span></span><br><span class="line"><span class="meta">    label-&gt;show();\</span></span><br><span class="line"><span class="meta">    btn-&gt;show();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接写 HELLO 就相当于替换了</span></span><br><span class="line">    HELLO</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0-3-Qt-环境配置"><a href="#0-3-Qt-环境配置" class="headerlink" title="0.3 Qt 环境配置"></a>0.3 Qt 环境配置</h2><blockquote><p>Unix 系统：不是安装完就能在命令行里用了吗？</p></blockquote><p>Windows 系统：在下载安装的 Qt 目录中找到编译器文件夹（安装时应该提醒你设置过了），把编译器目录下 <code>bin</code> 文件夹目录添加到 <strong>用户/系统环境变量 <code>Path</code></strong> 中；</p><h1 id="Chapter-1-Qt-初认识"><a href="#Chapter-1-Qt-初认识" class="headerlink" title="Chapter 1 Qt 初认识"></a>Chapter 1 Qt 初认识</h1><h2 id="1-1-简单示例"><a href="#1-1-简单示例" class="headerlink" title="1.1 简单示例"></a>1.1 简单示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span>    <span class="comment">// Qt 中一些类的定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QApplication 支持两个参数，说明 Qt 也有自己的命令行参数</span></span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;    <span class="comment">// 创建 QApplication 对象，用于管理程序资源</span></span><br><span class="line">    <span class="comment">// 创建了显示 “……” 的 QLabel 窗口部件(widget)</span></span><br><span class="line">    QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, Qt!&quot;</span>);</span><br><span class="line">    <span class="comment">// 显示该 widget，详见 tips2.</span></span><br><span class="line">    label-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// 将应用程序的控制权传递给 Qt，程序进入循环等待状态，监听用户动作并根据代码作出反应</span></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="comment">// 此处不考虑内存泄漏，因为整个程序结束后，空间能直接被操作系统回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>widget：窗口部件，指用户界面中的一个可视化元素，相当于 Windows 中的控件、容器。按钮、菜单、滚动条、框架等都是窗口部件。</p><p>tips 1. <strong>绝大多数应用程序会使用 <code>QMainWindow</code> 或 <code>QDialog</code> 作为窗口</strong>；而且在 Qt 中很灵活，甚至可以使用 QLabel 窗口部件来作为窗口（如上例）；</p><p>tips 2. <strong>创建 widget 时，大多都是“隐藏”属性，这可以使得我们先更改一些性质，在手动显示它们</strong>；</p><p>tips 3. <code>QLabel</code> 类的初始化参数的字符串<strong>允许简单 HTML 文本</strong>！例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLabel* label = <span class="built_in">QLabel</span>(<span class="string">&quot;&lt;h2&gt;&lt;i&gt;Hello,&lt;/i&gt;&lt;/h2&gt;&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><h2 id="1-2-要点：通过命令行（qmake）创建、编译-Qt-工程"><a href="#1-2-要点：通过命令行（qmake）创建、编译-Qt-工程" class="headerlink" title="1.2 要点：通过命令行（qmake）创建、编译 Qt 工程"></a>1.2 要点：通过命令行（qmake）创建、编译 Qt 工程</h2><p>本文单独提出为一个小节足以证明重要性，这里不会，连程序都跑不起来……</p><p>【⚠ 劝退警告】了解 Qt 前，本文默认大家已经对 C++ 从编码到编译运行的过程都基本了解；</p><blockquote><p>不了解就想学 Qt，只能说你是抱着没打算学透彻的心态，或者是只会用 IDE，一碰到报错就四处提问，，建议直奔 B 站 “1天速成”，或者某 CSDN 看“教程”；</p><p>但如果想要了解这方面内容可以参见博客 “GNU Tutor” 来入门，或者配合 GCC、CMake 相关课程学习（当然要先学会 C++ 基础）；</p></blockquote><p>从现在开始将使用 Qt 的用户分为 2 类（和操作系统环境无关）：</p><ol><li><p>使用 Qt Creator 的用户（即在官网安装 Qt Creator IDE 及 全套 Qt 运行环境的用户），<strong>以后称这类用户为 “IDE 用户”</strong>；</p><blockquote><p>这很像 C++ 使用 VS、VSCode、CLion 等 IDE（集成开发环境） 一键编译运行的用户；</p></blockquote></li><li><p>使用单独的 Qt Designer 的用户（即 Qt 库 + 命令行编译 + Qt Designer 的用户），<strong>以后称这类用户为 “非 IDE 用户”</strong>；</p><blockquote><p>这很像 C++ 使用<strong>编辑器</strong>写代码、手动使用 CMake/Make/GCC 编译、使用命令行运行的<strong>亲力亲为</strong>的用户；</p></blockquote></li></ol><h3 id="非-IDE-用户如何创建、编译运行-Qt-项目"><a href="#非-IDE-用户如何创建、编译运行-Qt-项目" class="headerlink" title="非 IDE 用户如何创建、编译运行 Qt 项目"></a>非 IDE 用户如何创建、编译运行 Qt 项目</h3><blockquote><p>由于手动编译更困难、更接近 Qt 运行的原理，所以优先介绍非 IDE 用户的做法；</p><p>劝退警告：Windows 环境配置复杂于 Linux，不过能让你更好了解 Qt 项目编译全过程，如果感兴趣可以使用这种方法；本人在开发 Windows 桌面应用时就采用这种方法</p></blockquote><ul><li><p><span id="script-env">【此步仅 Windows 用户】</span>确认编译器环境：Windows 中你可能在之前就有一个 C++ 编译器，并且已经配置在环境变量里，例如 MSVC 或者 minGW，所以为了防止手动编译用错了编译器，导致报错，<strong>这步是必须的</strong>；</p><p>在编译前，需要<strong>临时加入2个环境变量，来确保覆盖系统内其他C++编译器的环境变量</strong>：</p><ol><li><p>和 Qt 库配套的 C++ 编译器目录。如果你安装了 Qt Creator，那么在安装时应该顺带让你设置并安装了对应版本的 minGW 编译器，它的位置和 Qt 是放在一起的；</p><p><strong>通常位置是：<code>&lt;Qt安装根目录&gt;\Tools\mingw&lt;版本号&gt;\bin</code></strong>;</p><p>例如本人的位置：<code>D:\Qt5.14.2\Tools\mingw730_64\bin</code>；</p></li><li><p>Qt 库引入新的编译器，例如 <code>moc</code> 编译器、<code>uic</code> 编译器（后面会说），所在的目录；</p><p><strong>通常位置是：<code>&lt;Qt安装根目录&gt;\&lt;Qt版本号&gt;\mingw&lt;版本号&gt;\bin</code></strong>；</p><p>例如本人的位置：<code>D:\Qt5.14.2\5.14.2\mingw73_64\bin</code>；</p></li></ol><p>为了在手动编译完项目后，不影响其他C++编译器的正常使用，应该把这两个环境变量设置为临时环境变量，最方便的做法是<strong>写成 BAT 脚本</strong>，在命令行窗口中使用，只保留到本次会话结束；<strong>坏处是每次编译前都要运行这个脚本</strong>；例如本人的脚本应该这么写：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File: addEnv.bat</span></span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> PATH=D:\Qt5.<span class="number">14.2</span>\<span class="number">5.14</span>.<span class="number">2</span>\mingw73_64\bin;D:\Qt5.<span class="number">14.2</span>\Tools\mingw730_64\bin;%PATH%</span><br></pre></td></tr></table></figure><p>你可以将这个脚本保存在你的项目目录，或者其他目录，编译前运行一下就行，<strong>注意必须用命令行运行，而且编译必须使用这个命令行，不能关闭，否则临时环境变量会丢失，需要重新运行</strong>；</p><blockquote><p><strong>当然，如果你十分肯定系统中唯一的 C++ 编译器就是 Qt 安装的这个编译器，并且还在环境变量里，那么这一整个步骤就不用做了</strong>；</p></blockquote></li><li><p>创建工程：在<strong>已安排源文件（你已经创建了一些 <code>*.h/cpp</code>）的目录</strong>下执行：<code>qmake -project</code>，生成 <code>*.pro</code> 文件，与平台无关的项目文件；</p><blockquote><p>或者你想让项目目录干净点可以新建一个 build 文件夹，将命令行切入 build 中，再执行 <code>qmake -project &lt;你的项目目录&gt;</code></p></blockquote></li><li><p>添加 Qt 库：如果这个项目除了 <code>QtCore</code>、<code>QtGui</code>（默认包含） 以外，还想添加额外的 Qt 库，例如常用的 <code>QtWidgets</code>，<code>QtNetwork</code>，那么在 <code>*.pro</code> 文件的合适位置添加：<code>QT += widgets</code>、<code>QT += network</code>；</p><blockquote><p>想要了解更详细的 <code>*.pro</code> 文件的编写规则，请查阅<a href="https://doc.qt.io/qt-5/qmake-manual.html">官方文档</a>；</p><p><span id="important1"><strong>不过除了添加 Qt 库，其他应该很少会直接修改 <code>pro</code> 文件，例如引入项目文件就不用</strong>：</span></p><ul><li>IDE 用户可以在 Qt Creator 左侧文件栏右击添加文件，会自动更新 pro 文件；</li><li>非 IDE 用户只需在相同文件夹下重新运行 <code>qmake -project</code> 即可更新 pro 文件；</li></ul></blockquote></li><li><p>编译工程：使用 <code>qmake *.pro</code> 将一般项目文件编译为与平台相关的 <code>makefile</code> 文件；最后运行<code>make</code> 直接编译即可；</p><blockquote><p><code>qmake *.pro</code> 的过程有点像 CMake 对照 CMakeLists.txt 生成 Makefile 的过程；</p><p>注：Windows 下稍微麻烦一点，在项目目录下：</p><ol><li><p>运行 <code>qmake *.pro -spec win32-g++ &quot;CONFIG+=debug&quot; &quot;CONFIG += qml_debug&quot;</code></p></li><li><p>运行 <code>mingw32-make.exe</code>，这就相当于 Unix 系统下的 <code>make</code>；</p></li></ol></blockquote><ol><li><p>⚠ <strong>当你在生成 <code>makefile</code> 后，又向程序中加入一些新的包或函数，那么可能需要再次运行 <code>qmake</code> 来生成 新的 <code>makefile</code>，以防编译器无法找到新文件</strong>；</p></li><li><p><strong>有同学可能会问，能不能不用 <code>qmake</code>，就用 <code>cmake</code>？这个可以，下一节就说！</strong></p></li></ol></li></ul><h3 id="IDE-用户如何创建、编译运行-Qt-项目"><a href="#IDE-用户如何创建、编译运行-Qt-项目" class="headerlink" title="IDE 用户如何创建、编译运行 Qt 项目"></a>IDE 用户如何创建、编译运行 Qt 项目</h3><ul><li>法1（纯 IDE 法）：打开 Qt Creator -&gt; 新建项目 -&gt; 按指示配置环境（界面中 Qt Application 模板对新手不友好，可能需要思考一会项目结构） -&gt; 编写项目 -&gt; 编译运行就交给 IDE 吧~；</li><li>法2（命令行法，比较自由）：新建一个项目文件夹 -&gt; 按需创建 <code>*.cpp</code> <code>*.h</code> 等项目文件 -&gt; 命令行进入该目录运行 <code>qmake -project</code> -&gt; 进入生成的 <code>*.pro</code> 按需添加所需 Qt 库 -&gt; 双击 pro 文件/进入 Qt Creator 打开项目 -&gt; 编写项目 -&gt; 编译运行就交给 IDE 吧~；</li></ul><h2 id="1-2-EX-使用-CMake-代替-qmake-构建项目"><a href="#1-2-EX-使用-CMake-代替-qmake-构建项目" class="headerlink" title="1.2-EX 使用 CMake 代替 qmake 构建项目"></a>1.2-EX 使用 CMake 代替 qmake 构建项目</h2><p><strong>使用 IDE 的小伙伴就可以跳过了哦 ~ 因为你们只需要在创建项目时，选择 “项目构建系统” 为CMake，就完成了！</strong></p><p>下面，在原来的 CMake 语法的基础上（基础语法不作介绍，可以看本站以前的文章，或者网上学习），本人仅会介绍 <strong>和普通 C++ 项目构建的不同之处</strong>：</p><ol><li><p><strong>【必要】添加 Qt 专属编译器</strong>（这些编译器在后面会一一介绍，学完可以回来看看）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动调用 uic 编译器处理 *.ui</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"><span class="comment"># 自动调用 moc 编译器处理 Qt 宏和关键字</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="comment"># 自动处理 *.qrc Qt 资源文件</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>【必要】</strong>如果 你在 qmake 中需要添加诸如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += widgets network    // *.pro 的写法</span><br></pre></td></tr></table></figure><p>的 Qt 库，在 CMake 中需要这么写：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $ENV&#123;&#125; 调用系统环境变量，这个 Qt_HOME 需要自己设置在系统环境变量里</span></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Widgets Network REQUIRED PATHS $ENV&#123;Qt_HOME&#125;)</span><br></pre></td></tr></table></figure><p><strong>很遗憾，CMake 没有 qmake 的默认设置，qmake 默认加入的 <code>Gui</code>、<code>Core</code> 库需要在 CMakeLists 中手动加入</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Core Gui REQUIRED)</span><br></pre></td></tr></table></figure><p><strong>而且在最后还要手动链接库</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(exeName PRIVATE Qt5::Widgets Qt5::Core Qt5::Gui)</span><br></pre></td></tr></table></figure></li><li><p><strong>【注意】</strong>：在 CMake 中，由于之前添加了专属编译器，所以 <code>*.ui</code> 和 <code>*.h/cpp</code> 一样，都需要在 <code>add_executable</code> 或 <code>add_library</code> 构建目标时，<strong>作为源文件加入进去</strong>；</p></li></ol><p><strong>最后，以一个示例项目为例子（不同的项目没法照抄哦~）</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span>(HelloWorld)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【optional】设置工程包含当前目录</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_INCLUDE_CURRENT_DIR <span class="keyword">ON</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FIND_PACKAGE</span>(Qt5 COMPONENTS Widgets Gui Core REQUIRED PATHS $ENV&#123;Qt5_HOME&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前文件夹中的所有相关文件</span></span><br><span class="line"><span class="keyword">FILE</span>(GLOB SOURCE_FILES <span class="string">&quot;./*.cpp&quot;</span>) </span><br><span class="line"><span class="keyword">FILE</span>(GLOB HEADER_FILES <span class="string">&quot;./*.h&quot;</span>) </span><br><span class="line"><span class="keyword">FILE</span>(GLOB UI_FILES <span class="string">&quot;./*.ui&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过Ui文件生成对应的头文件</span></span><br><span class="line">QT5_WRAP_UI(WRAP_FILES <span class="variable">$&#123;UI_FILES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加资源文件</span></span><br><span class="line"><span class="keyword">SET</span>(RCC_FILES rcc.qrc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【optional】生成UI文件夹</span></span><br><span class="line"><span class="keyword">SOURCE_GROUP</span>(<span class="string">&quot;UI&quot;</span> FILES <span class="variable">$&#123;UI_FILES&#125;</span> <span class="variable">$&#123;WRAP_FILES&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件，需添加RCC_FILES、WRAP_FILES</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SOURCE_FILES&#125;</span> <span class="variable">$&#123;HEADER_FILES&#125;</span> <span class="variable">$&#123;RCC_FILES&#125;</span> <span class="variable">$&#123;WRAP_FILES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Qt5依赖项</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> Qt5::Widgets Qt5::Core Qt5::Gui)</span><br></pre></td></tr></table></figure><h2 id="1-3-建立连接"><a href="#1-3-建立连接" class="headerlink" title="1.3 建立连接"></a>1.3 建立连接</h2><blockquote><p>之前我们认识了简单 Qt 程序的基本运作，那么如何实现 <strong>Qt 响应用户的动作呢？</strong></p></blockquote><h3 id="1-3-1-信号与槽的原理"><a href="#1-3-1-信号与槽的原理" class="headerlink" title="1.3.1. 信号与槽的原理"></a>1.3.1. 信号与槽的原理</h3><ul><li><p>Qt 的 widget 通过<strong>发射信号</strong>（signal，实质是一个函数，和操作系统的信号无关）来表明用户的某个动作已发生，或者状态已改变；</p><blockquote><p>举例：用户点击按钮类 <code>QPushButton</code> 时，按钮会发射 <code>clicked()</code> 信号；</p></blockquote></li><li><p>Qt 的 <strong>槽（slot）能够接收信号</strong>，是一个实际上的函数，一旦触发该信号，slot 会自动执行；</p><p>⚠<strong>注意：槽就是函数！一个类如果具有一个方法，那么它就可以作为这个类的槽</strong>；</p></li><li><p>Qt 通过宏（macro）来将 click() 等对象转化为信号str、将函数 F() 转化为槽，并使用 <code>QObject::connect</code> 函数进行绑定；</p><blockquote><p><strong>宏转化的时候，如果信号 / 槽对应的函数有参数，务必填入参数类型，例如：</strong></p><p><code>SIGNAL(valueChanged(int))</code></p></blockquote></li></ul><p>ℹ 这里简单带过一下，给读者一个初印象，以后会详细深入介绍 信号-槽机制；</p><h3 id="1-3-2-示例代码"><a href="#1-3-2-示例代码" class="headerlink" title="1.3.2. 示例代码"></a>1.3.2. 示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QPushButton* btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;quit&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用 connect 静态成员函数，其参数原型为：</span></span><br><span class="line">    <span class="comment">// QObject::connect(QObject* p1, SIGNAL, QObject* p2, SLOT)</span></span><br><span class="line">    <span class="comment">// 其中 p1 是指向发送信号的widget指针，p2 是指向接受信号的函数槽**所在的widget**指针，这里是 含有quit()方法 的 QApplication 对象；</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(btn, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), &amp;app, <span class="built_in">SLOT</span>(<span class="built_in">quit</span>()));</span><br><span class="line">    button-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-Qt-窗口的布局设计"><a href="#1-4-Qt-窗口的布局设计" class="headerlink" title="1.4 Qt 窗口的布局设计"></a>1.4 Qt 窗口的布局设计</h2><h3 id="1-4-1-widget-间的父子关系"><a href="#1-4-1-widget-间的父子关系" class="headerlink" title="1.4.1 widget 间的父子关系"></a>1.4.1 widget 间的父子关系</h3><blockquote><p>当需要在一个窗口中，<strong>合理地</strong>安排各种 widget 的摆放时，需要考虑这些 widget 间的层次关系；</p><p>Qt 中，和其他类的 GUI 设计库类似的做法是，<strong>引入 widget 间的父子关系</strong>；表示：<strong>A 是 B 的子控件 就可以理解为 A 是布局在 B 上的 控件</strong>；</p></blockquote><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="layout.png" height="100px"></p><p>比如，想要制作如上图的应用界面，就需要遵循这样的步骤（仅供参考，其他方法也能实现）：</p><ol><li><p>在窗口最顶层设置一个 <code>QWidget</code> 类对象的抽象的 widget，用来盛放其他 widget，可以理解现实中的一个 “桌布”；</p></li><li><p>以 <code>QWidget</code> 类对象为父控件（QWidget 自己没有父控件，它就是顶层窗口），设置 <code>QSpinbox</code> 和 <code>QSlider</code> 对象（分别是 微调框 控件类、滑动条 控件类）;</p><blockquote><p><strong>一般情况下，QWidget 及其子类设置父控件的方法是通过布局管理器实现</strong>；理解为“用布局管理器打包在一起”；</p></blockquote></li><li><p>绑定内部信号-槽的关联；</p></li><li><p>最后<strong>使用布局管理器</strong>将子控件<strong>按指定“摆放方式”</strong>显式加入父控件，显示顶层 widget 即可；</p></li></ol><p>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QHBoxLayout&gt;</span>    <span class="comment">// 引入 布局管理器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QSlider&gt;</span>        <span class="comment">// 引入 滑动条控件类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Qtwidgets/QSpinBox&gt;</span>        <span class="comment">// 引入 微调框控件类</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    QWidget* mainWindow = <span class="keyword">new</span> QWidget;</span><br><span class="line">    mainWindow-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;Enter your age&quot;</span>);    <span class="comment">// QWidget 类具有成员函数 setWindowTitle</span></span><br><span class="line">    </span><br><span class="line">    QSpinBox* spinBox = <span class="keyword">new</span> QSpinBox;</span><br><span class="line">    QSlider* slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal);    <span class="comment">// QSlider 的构造函数的第一个参数可以使用 Qt 枚举量 Horizontal 设置滑动方向</span></span><br><span class="line">    spinBox-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">130</span>);</span><br><span class="line">    slider-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">130</span>);    <span class="comment">// 两个类都具有成员函数 setRange</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个类都具有：valueChanged(int) 信号、setValue(int) 槽，因此将两者相互绑定</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(spinBox, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), slider, <span class="built_in">SLOT</span>(<span class="built_in">setValue</span>(<span class="type">int</span>)));</span><br><span class="line">    QObject::<span class="built_in">connect</span>(slider, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), spinBox, <span class="built_in">SLOT</span>(<span class="built_in">setValue</span>(<span class="type">int</span>)));</span><br><span class="line">    </span><br><span class="line">    spinBox-&gt;<span class="built_in">setValue</span>(<span class="number">35</span>);    <span class="comment">// 初始化值为35</span></span><br><span class="line">    </span><br><span class="line">    QHBoxLayout* layout = <span class="keyword">new</span> QHBoxLayout;    <span class="comment">// 初始化布局管理器</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(spinBox);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(slider);    <span class="comment">// 布局管理器将子控件打包在一起</span></span><br><span class="line">    <span class="comment">// QWidget 具有成员函数 setLayout，可以传入布局管理器实现布局设计</span></span><br><span class="line">    window-&gt;<span class="built_in">setLayout</span>(layout);    <span class="comment">// 再将包传给父控件，底层会自动将管理器中的所有子控件定向其父控件</span></span><br><span class="line">    </span><br><span class="line">    window-&gt;<span class="built_in">show</span>();        <span class="comment">// 最后只需展示顶层 widget 即可</span></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-布局设计的意义"><a href="#1-4-2-布局设计的意义" class="headerlink" title="1.4.2 布局设计的意义"></a>1.4.2 布局设计的意义</h3><p>有同学会问，为什么需要 layout？<strong>layout 可以让多个 widget 按想要的方式排列在一个窗口上</strong>；如果不这么做，就没法定义摆放方式了！你可以试一试，不用布局管理器，你会发现两个或多个 widget 是分布在不同的窗口下的；</p><h3 id="1-4-3-布局管理器的类型"><a href="#1-4-3-布局管理器的类型" class="headerlink" title="1.4.3 布局管理器的类型"></a>1.4.3 布局管理器的类型</h3><p>除了以上例子介绍的 <code>QHBoxLayout</code> 类，还有 <code>QVBoxLayout</code>、<code>QGridLayout</code>，其作用分别是：</p><ul><li><code>QHBoxLayout</code>：默认在水平方向，从左到右排列 widget；</li><li><code>QVBoxLayout</code>：默认在竖直方向，从上到下排列 widget；</li><li><code>QGridLayout</code>：将 widget 排列在预设的网格中；</li></ul><p>常见的使用方法：先声明、在设置属性，最后添加打包到布局管理器中，设置给父控件；</p><p><strong>它们都继承于 <code>QLayout</code>，所以它们不是 widget（<code>QWidget</code>），一般也不可见</strong>；</p><h2 id="1-5-章末贴士"><a href="#1-5-章末贴士" class="headerlink" title="1.5 章末贴士"></a>1.5 章末贴士</h2><ul><li><p>重要：一定要会使用官方文档；</p></li><li><p>有些同学会想，里面的命令行参数 <code>argc</code> 和 <code>argv</code> 究竟可以做什么？其实，举个例子就明白了，其中一个用途是<strong>设置应用界面的主题</strong>，即：<code>./应用名 -style &lt;style name&gt;</code>，常用的 <code>style name</code> 有：<code>plastique</code>、<code>Cleanlooks</code>、<code>CDE</code>、<code>Motif</code>、<code>Windows</code>、<code>Windows XP</code>、<code>Windows Vista</code>、<code>Mac</code>；</p></li><li><p>本章涉及到的类和一些方法的总结</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="C1.png"></p></li><li><p><strong>和 Qt 4 比较</strong>：QLabel、QPushButton、QSlider、QSpinBox 都还是 QWidget 的子类，但 Qt 5 类的头文件移动到<strong>单独的 <code>QWidgets</code> 模块中</strong>，即 include 时，需要：<code>#include&lt;QtWidgets/QXXX&gt;</code></p><blockquote><p>例如 1.4.1 的例子在 Qt 4 环境下应该这么写<strong>【亲测能跑】</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QSpinBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QSlider&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// …… （后面一毛一样）</span></span><br><span class="line"><span class="comment">// 记得在 *.pro 中移除：QT += widgets</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>最后强调一下， Qt 4 到 5、Qt 5 到 6 的很多操作都改变了，所以别轻易更换项目的 Qt 大版本！</strong></p></li></ul><h1 id="Chapter-2-面向对象的-Qt"><a href="#Chapter-2-面向对象的-Qt" class="headerlink" title="Chapter 2 面向对象的 Qt"></a>Chapter 2 面向对象的 Qt</h1><h2 id="2-1-纯代码设计"><a href="#2-1-纯代码设计" class="headerlink" title="2.1 纯代码设计"></a>2.1 纯代码设计</h2><h3 id="2-1-1-示例：以简单对话框为例"><a href="#2-1-1-示例：以简单对话框为例" class="headerlink" title="2.1.1 示例：以简单对话框为例"></a>2.1.1 示例：以简单对话框为例</h3><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="QDiag.png" height="150px"></p><blockquote><p>想象一下，这是一个庞大应用程序的一个小部分对话框，现在想要单独设计它。但是第一章的代码都写在一个 main 函数中，如果窗口一多，不仅不利于维护，而且容易编写错误；</p><p>所以我们从现在开始采用 C++ 中的不同类来编写不同窗口，可以形成很好的封装性，增强可读性；</p></blockquote><p>下面将这个窗口编写为一个类 <code>findDialog</code>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: findDialog.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FINDDIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FINDDIALOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QDialog&gt;</span>    <span class="comment">// 包含 Qt 对话的基类，派生于 QWidget，和 1.5 中说的一样，在 Qt 4 中要写 #include&lt;QDialog&gt;，以下不再赘述；</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QCheckBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">findDialog</span> : <span class="keyword">public</span> QDialog &#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">// 很重要的一个宏，里面写了 QObject 类的几乎所有信号和槽，还有其他属性和方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这是一个典型的 Qt widget 类的定义方式，第一个参数指定父控件</span></span><br><span class="line">    <span class="built_in">findDialog</span>(QWidget* parent = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 marco 说明以下定义的函数都是 信号函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">// Qt::CaseSensitivity 是 enum 类型，和 C++ 中的 true、false 如出一辙，本身的值也是 0 或 1，用于区分大小写是否敏感的具体情况，含有值 Qt:CaseSensitive 和 Qt::CaseInSensitive</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findNext</span><span class="params">(<span class="type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findPrevious</span><span class="params">(<span class="type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 声明了私有的槽</span></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findClicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 思考一下，已知 QPushButton 自己有槽函数 setEnabled(bool)，为什么还要包装一层 私有的槽呢？（答案在实现这个槽的时候揭晓）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enabledFindButton</span><span class="params">(<span class="type">const</span> QString&amp; text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLabel* label;</span><br><span class="line">    QLineEdit* lineEdit;</span><br><span class="line">    QCheckBox* caseCheckBox;</span><br><span class="line">    QCheckBox* backwardCheckBox;</span><br><span class="line">    QPushButton* findButton;</span><br><span class="line">    QPushButton* closeButton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这是窗口的实现 cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: findDialog.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtGui&gt;</span>        <span class="comment">// 详见注解 tips 1.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;findDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// findDialog 继承于 QDialog，所以也使用它的一些数据成员，自然需要委托构造</span></span><br><span class="line">findDialog::<span class="built_in">findDialog</span>(QWidget* parent) : <span class="built_in">QDialog</span>(parent) &#123;</span><br><span class="line">    <span class="comment">// 这里有 3 点需要解释，详见 tips 2. 、 tips 3. 和 tips 4.</span></span><br><span class="line">    label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="built_in">tr</span>(<span class="string">&quot;Find &amp;what&quot;</span>));    <span class="comment">// tips2. tips3.</span></span><br><span class="line">    <span class="comment">// 新的类：QLineEdit 类，单行输入框类</span></span><br><span class="line">    lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    label-&gt;<span class="built_in">setBuddy</span>(lineEdit);    <span class="comment">// tips4.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新的类：QCheckBox 类，勾选框类，初始化参数和 QLabel 一样，也是str内容</span></span><br><span class="line">    caseCheckBox = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="built_in">tr</span>(<span class="string">&quot;Match &amp;case&quot;</span>));</span><br><span class="line">    backwardCheckBox = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="built_in">tr</span>(<span class="string">&quot;Search &amp;backward&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    findButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Find&quot;</span>));</span><br><span class="line">    findButton-&gt;<span class="built_in">setDefault</span>(<span class="literal">true</span>);        <span class="comment">// tips 5.</span></span><br><span class="line">    findButton-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);        <span class="comment">// tips 6.</span></span><br><span class="line">    </span><br><span class="line">    closeButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="built_in">tr</span>(<span class="string">&quot;Close&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里不用写作用域 “QObject::”，因为 QDialog 就是 QObject 的子类</span></span><br><span class="line">    <span class="comment">// 详见 tips 7.</span></span><br><span class="line">    <span class="comment">// 还记得之前声明的私有槽吗？（再等会实现定义）这里是将 lineEdit 的文字改变信号连接到 findDiag 窗体的 enabledFindButton(const QString&amp;) 私有槽上；</span></span><br><span class="line">    <span class="built_in">connect</span>(lineEdit, <span class="built_in">SIGNAL</span>(<span class="built_in">textChanged</span>(<span class="type">const</span> QString&amp;)),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">enableFindButton</span>(<span class="type">const</span> QString&amp;)));</span><br><span class="line">    <span class="built_in">connect</span>(findButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">findClicked</span>()));</span><br><span class="line">    <span class="comment">// tips 8.</span></span><br><span class="line">    <span class="built_in">connect</span>(closeButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代码块未完待续----------------------------</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>tips 1.</strong> 头文件 <code>QtGui.h</code> 包含了 Qt GUI 类的 <code>QtCore</code> 和 <code>QtGui</code> 模块的所有类的定义；</p><blockquote><p><strong>回顾一下 Qt 的主要模块：<code>QtCore</code>、<code>QtGui</code>、<code>QtNetwork</code>、<code>QtOpenGL</code>、<code>QtSql</code>、<code>QtSvg</code>、<code>QtXml</code></strong>；</p></blockquote><ul><li>同学会问，为什么不在 <code>findDialog.h</code> 中直接 <code>#include&lt;QtGui&gt;</code>？<strong>因为这个包比较大，引入他可能造成引用的不清晰，不是一个好习惯；理论上用到什么引入什么</strong>；</li></ul></li><li><p><strong>tip 2.</strong>  在 Qt 中，所有字符串都认为是 <code>QString</code> ——有 <code>tr(QString)</code> 方法可以将它们翻译；这就意味着，<strong>在所有用户可见的字符串周围加上 <code>tr()</code> 函数</strong>是个好习惯；这样方便软件后期的翻译工作，对 <code>tr()</code> 的翻译会在后面介绍；</p></li><li><p><strong>tips 3.</strong> 如果想在用户可见的字符串中加入<strong>快捷键来控制焦点（选中的区域，意味着用户可以直接输入，或者按 ENTER=点击）</strong>，那么在字符串前中写 <strong>“&amp;”</strong> 符号，表示<strong>将 <code>Alt + 字符串第一个字符</code> 作为快捷键</strong>；</p></li><li><p><strong>tips 4.</strong> 几乎所有 <code>QWidget</code> 都有一个方法 <code>setBuddy(QWidget* ptr)</code> 用来绑定两个 widget 为兄弟控件，具体表现在<strong>共用同一个快捷键</strong>（这个快捷键会同时聚焦这两个控件）；</p></li><li><p><strong>tips 5.</strong> 大多数 <code>QWidget</code> 都有一个方法 <code>setDefault(bool flag)</code> 用来指定<strong>刚打开窗口时聚焦的控件</strong>；</p></li><li><p><strong>tips 6.</strong> <code>QPushButton</code> 有一个特有属性 <code>enabled</code>，如果是 <code>true</code>，则这个按钮是可以点击的，否则按钮呈现灰色不可点击的状态；</p></li><li><p><strong>tips 7.</strong> 由上面的 <code>connect</code> 函数可以看出，<code>QLineEdit</code> 类有一个 <code>textChanged(const QString&amp;)</code> 信号；</p></li><li><p><strong>tips 8.</strong> 这里 <code>QDialog</code> 的 <code>close()</code> 方法<strong>继承于 <code>QWidget</code> 类</strong>，默认行为是<strong>将 widget 隐藏起来（而非删除）</strong>，这和 <code>QApplication</code> 类的 <code>quit()</code> 方法不一样，<code>quit()</code> 方法是关闭并删除窗口及其上的所有布局、widget；</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 上接上一个代码块 --------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记住在 1.4.1 中说的 4 个基本步骤，这里是倒数第二个：打包布局</span></span><br><span class="line">    <span class="comment">// 这里的案例告诉我们，对于多个 widget 的布局，可以采用多个不同位置、不同类型的布局管理器来进行，这里的具体划分见 tips 9.</span></span><br><span class="line">    QHBoxLayout* topLeftLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    topLeftLayout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">    topLeftLayout-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line">    </span><br><span class="line">    QVBoxLayout* leftLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    <span class="comment">// tip 10.</span></span><br><span class="line">    leftLayout-&gt;<span class="built_in">addLayout</span>(topLeftLayout);</span><br><span class="line">    leftLayout-&gt;<span class="built_in">addWidget</span>(caseCheckBox);</span><br><span class="line">    leftLayout-&gt;<span class="built_in">addWidget</span>(backwardCheckBox);</span><br><span class="line">    </span><br><span class="line">    QVBoxLayout* rightLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    rightLayout-&gt;<span class="built_in">addWidget</span>(findButton);</span><br><span class="line">    rightLayout-&gt;<span class="built_in">addWidget</span>(closeButton);</span><br><span class="line">    <span class="comment">// tip 11.</span></span><br><span class="line">    rightLayout-&gt;<span class="built_in">addStretch</span>();</span><br><span class="line">    </span><br><span class="line">    QHBoxLayout* mainLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(leftLayout);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(rightLayout);</span><br><span class="line">    <span class="comment">// 回想之前在 1.4.1 中对 QWidget 顶层窗口使用 setLayout</span></span><br><span class="line">    <span class="built_in">setLayout</span>(mainLayout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和 1.4.1 中一样，这里是 QWidget 派生来的方法</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Find&quot;</span>));</span><br><span class="line">    <span class="comment">// tip 12.</span></span><br><span class="line">    <span class="built_in">setFixedHeight</span>(<span class="built_in">sizeHint</span>().<span class="built_in">height</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>tips 9.</strong> 此处的布局划分的方式如下图所示：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="QLayout.png" height="200px"></p><p>这样的划分思路很类似 HTML 的设计框架布局，<strong>先划分大的区域，再根据功能或对齐位置逐个 “切开” </strong>；</p></li><li><p><strong>tips 10.</strong> <code>QLayout</code> 类的对象都有 <code>addLayout(QLayout* ptr)</code>，与 <code>addWidget(QWidget* ptr)</code> 类似；前者可以将布局嵌套布局，形成更复杂的结构；</p></li><li><p><strong>tips 11.</strong> <code>QLayout</code> 类中的 <code>addStretch()</code> 方法，如 tip9 中的图片中的 “分隔符” 的作用，用来撑开当前的 <code>Layout</code>，与同级的 <code>Layout</code> 高度或宽度对齐适应，同时使之前加入布局管理器的 widget 更加紧凑；</p></li><li><p><strong>tips 12.</strong> <code>setFixedHeight(int h)</code> 是 <code>QWidget</code> 类的方法，可以设定一个固定的 widget 高度，<code>QWidget::sizeHint()</code> 可以计算当前 widget 中各个布局管理器中各子 widget 默认 size，从而得出比较适宜的高度；</p></li></ul><p><strong>写完构造函数，无需写析构函数。因为：Qt 在删除父对象时，会自动删除所有子 widget 和 子布局；</strong></p><p>下面<strong>定义之前声明的私有槽</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">findDialog::findClicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取当前 lineEdit 中的字符串到 text 中</span></span><br><span class="line">    QString text = lineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="comment">// tips 13.</span></span><br><span class="line">    Qt::CaseSensitivity cs = </span><br><span class="line">        caseCheckBox-&gt;<span class="built_in">isChecked</span>() ? Qt:CaseSensitive : Qt:CaseInSensitive;</span><br><span class="line">    <span class="keyword">if</span> (backwardCheckBox-&gt;<span class="built_in">isChecked</span>())</span><br><span class="line">        <span class="comment">// tips 14.</span></span><br><span class="line">        <span class="function">emit <span class="title">findPrevious</span><span class="params">(text, cs)</span></span>;</span><br><span class="line">    <span class="keyword">else</span> emit <span class="built_in">findNext</span>(text, cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findDialog::enableFindButton</span><span class="params">(<span class="type">const</span> QString&amp; text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代码块 1 中的疑问，答案揭晓：tips 15.</span></span><br><span class="line">    findButton-&gt;<span class="built_in">setEnabled</span>(!text.<span class="built_in">isEmpty</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>tips 13.</strong> <code>QCheckBox</code> 具有方法 <code>isChecked()</code>，指示这个选择框有没有被选中；</p></li><li><p><strong>tips 14.</strong> <code>emit &lt;function&gt;</code> 是 Qt 的关键字之一，<strong>表示向函数 <code>function</code> 发射信号</strong>；</p></li><li><p><strong>tips 15.</strong> 之所以要单独设计一个私有槽，是因为考虑到不仅仅是在输入变换的时候，使这个按钮处于 enable 状态，还要考虑<strong>在文本框为空的时候，使按钮再次 disable</strong>，而这需要额外的逻辑设计；这里就是 <code>!text.isEmpty()</code> 这个方法；</p><blockquote><p>整体逻辑：如果改变了文本，就调用 <code>enableFindButton</code> 槽；如果文本为空，就 disable “Find” 按钮；</p></blockquote></li></ul><p>这下将所有的部件放在一起：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;findDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    findDialog* dialog = <span class="keyword">new</span> findDialog;</span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⚠注意：因为这里没有实际应用场景，所以以上代码的信号 <code>findPrevious(str, cs)</code> 和 <code>findNext(str, cs)</code> 暂时没有应用，以后继续补充</strong>；</p><h3 id="2-1-2-进一步了解信号-槽机制"><a href="#2-1-2-进一步了解信号-槽机制" class="headerlink" title="2.1.2 进一步了解信号-槽机制"></a>2.1.2 进一步了解信号-槽机制</h3><ul><li><p>槽（<code>slot</code>）：和普通 C++ 成员函数<strong>几乎一模一样</strong>：可以是虚函数、可以被重载、可以是 <code>public/protected/private</code>、可以被其他 C++ 成员函数之间调用、参数可以是任意类型；唯一不同的就是<strong>槽可以和信号连接在一起</strong>，只要 <code>emit</code> 了对应的信号，就会自动调用这个槽；</p><blockquote><p><strong>当普通 C++ 函数变成槽调用时，一般会忽略原本的返回值</strong>；</p></blockquote></li><li><p>信号 - 槽的连接的函数：<code>QObject::connect(QObject* sender, SIGNAL(signal), QObject* receiver, SLOT(slot))</code></p><blockquote><p>其中宏 <code>SIGNAL()</code> 和 <code>SLOT()</code> <strong>会将它们的参数转换成相应的字符串</strong>（暂时不必了解这些字符串的结构）；</p></blockquote></li><li><p>信号-槽连接的<strong>要求</strong>：要想信号和槽成功连接，<strong>它们的参数必须有相同的顺序和相同的类型</strong>；</p><blockquote><p>有一种情况例外：<strong>信号的参数多于槽的参数，但对应的参数类型相同</strong>（这样多余的参数会被简单地忽略掉）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ftp, <span class="built_in">SIGNAL</span>(<span class="built_in">rawCommnadReply</span>(<span class="type">int</span>, <span class="type">const</span> QString&amp;)),</span><br><span class="line">    <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">checkErrorCode</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure></blockquote></li><li><p>信号-槽连接的<strong>特性</strong></p><ol><li><p><strong>一个信号可以连接多个槽</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这个例子中，如果信号 slider 被 emit，那么会以不确定的顺序一个接着一个调用这些槽（setValue(int) 和 updateStatusBarIndicator(int)，可以不止两个）</span></span><br><span class="line"><span class="built_in">connect</span>(slider, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)),</span><br><span class="line">        spinBox, <span class="built_in">SLOT</span>(<span class="built_in">setValue</span>(<span class="type">int</span>)));</span><br><span class="line"><span class="built_in">connect</span>(slider, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)),</span><br><span class="line">       <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">updateStatusBarIndicator</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure></li><li><p><strong>多个信号可以连接一个槽</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论发射其中的哪一个信号，都会调用这个槽</span></span><br><span class="line"><span class="built_in">connect</span>(lcd, <span class="built_in">SIGNAL</span>(<span class="built_in">overflow</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleMathError</span>()));</span><br><span class="line"><span class="built_in">connect</span>(calc, <span class="built_in">SIGNAL</span>(<span class="built_in">divisionByZero</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleMathError</span>()));</span><br></pre></td></tr></table></figure></li><li><p><strong>一个信号可以连接另一个信号</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// emit 第一个信号，就会触发 emit 第二个信号</span></span><br><span class="line"><span class="built_in">connect</span>(lineEdit, <span class="built_in">SIGNAL</span>(<span class="built_in">textChanged</span>(<span class="type">const</span> QString&amp;)),</span><br><span class="line">       <span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">updateRecord</span>(<span class="type">const</span> QString&amp;)));</span><br></pre></td></tr></table></figure></li><li><p>连接可以被移除：<strong>这种情况应用较少，因为 <code>Qt</code> 在移除对象时，会自动移除和对象相关的所有连接</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(lcd, <span class="built_in">SINGAL</span>(<span class="built_in">overflow</span>()),</span><br><span class="line">          <span class="keyword">this</span>, <span class="built_in">handlerMathError</span>());</span><br></pre></td></tr></table></figure></li><li><p><strong>信号-槽不仅可以应用在图形化界面的编写中，在哪怕不是为了设计 GUI，在类中声明宏 <code>Q_OBJECT</code> 也可以实现信号-槽机制</strong>；</p></li></ol></li></ul><h3 id="2-1-3-Qt-的元对象编译器-moc-和-元对象系统"><a href="#2-1-3-Qt-的元对象编译器-moc-和-元对象系统" class="headerlink" title="2.1.3 Qt 的元对象编译器 moc 和 元对象系统"></a>2.1.3 Qt 的元对象编译器 moc 和 元对象系统</h3><p>在我一开始尝试写一些基本的程序的时候，一直很疑惑，Qt 的宏 <code>slots</code>、<code>signal</code>、<code>Q_OBJECT</code> 究竟是什么？因为我不理解这其中的原理，所以犯过一个低级的错误——将声明成信号（<code>signal</code>）的函数加以定义，像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: XXX.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XXX</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">signal:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">signalA</span><span class="params">(Type1 p1, Type2 p2)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File: XXX.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XXX::signalA</span><span class="params">(Type1 p1, Type2 p2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 某些代码逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写实际上会在 <code>make</code> 编译是报 <code>multiple definition</code> 的错误，我正纳闷，为啥会 “重复定义” 呢？再一看报错的信息：<strong>重复定义的位置位于 <code>moc_XXX.cpp</code> </strong>，我再想，我也没有写过 <code>moc_XXX.cpp</code> 呀？于是就引出了 <strong><code>Qt</code> 中相当重要的概念：<code>moc</code> 元对象编译器</strong>；</p><p>Qt 的主要成就之一就是使用一种机制对 C++ 进行了扩展，并且使用这种机制创建了软件组件；</p><p>这种机制叫做 “元对象系统（meta-object system）”，它提供了关键的 2 项技术：<strong>信号-槽机制</strong> 和 <strong>内省（introspection）</strong>；</p><p>内省功能对于实现信号和槽是必需的，还允许开发人员获得有关 <code>QObject</code> 子类的 “元信息（meta-information，<strong>包含一些类名和它所支持的信号-槽列表</strong>）”，还支持 Qt 设计师属性（<strong>下一节将提到</strong>）和文本翻译（之前所说的 <code>tr()</code>），为 <code>QScript</code> 模块奠定基础（不过目前接触不到）；</p><p>但以上提到的这些，标准 C++ 没有，这意味着用普通的 C++ 编译器一定没法实现；所以 Qt 引入了新的编译器：<code>moc</code> 元对象编译器；</p><p>因此，Qt 整个编码到运行的工作流程是：</p><ol><li><code>qmake</code> 效仿 <code>cmake</code> ，以平台无关的方式指定了程序编译所需的库，这里包含了标准 C++ 所没有的 Qt 的库；最后生成了普通的 <code>Makefile</code>；</li><li><code>moc</code> 元对象编译器一边识别 Qt 特定的宏或关键字（例如 <code>QObject</code>、<code>slots</code>、<code>signal</code>），添加特定内容（例如自动实现信号函数），一边和普通 C++ 编译器一样，编译链接源文件；</li><li><code>moc</code> 元对象编译器在编译时还会补充 <code>QObject</code> 的 内省函数，完成特殊的触发工作；</li></ol><p>以上内容一般很少需要开发者去考虑，都封装在 <code>qmake</code>、<code>moc</code>、<code>QObject</code>内部；如果感兴趣，可以阅读有关 <code>QMetaObject</code> 文档，或者是前面提到的 <code>moc</code> 自动生成的 C++ 源码 <code>moc_XXX.cpp/h</code>；</p><h2 id="2-2-Qt-Designer：UI-快速设计"><a href="#2-2-Qt-Designer：UI-快速设计" class="headerlink" title="2.2 Qt Designer：UI 快速设计"></a>2.2 Qt Designer：UI 快速设计</h2><p>在上面一些纯代码设计的例子中，我们会发现 GUI 的设计遵循一些基本的规律定式：</p><ol><li>创建、初始化（例如设置文本内容）子窗口部件；</li><li>将 widget 放置到布局中；</li><li>设置 Tab 键顺序；</li><li>建立信号 — 槽连接；</li><li>实现自定义槽；</li></ol><p>现在，可以使用 Qt Designer 将图形化设计的一部分（指前三步）交给图形界面；</p><h3 id="2-2-1-Qt-Designer-的基本使用"><a href="#2-2-1-Qt-Designer-的基本使用" class="headerlink" title="2.2.1 Qt Designer 的基本使用"></a>2.2.1 Qt Designer 的基本使用</h3><blockquote><p>本部分将介绍 Qt Designer 如何设计基本 UI 界面，完成上面所提到的 <strong>前3步</strong>，同时<strong>回顾之前所学到的方法</strong>；</p></blockquote><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="cellDialog.png"></p><p>以上面的窗体为目标设计一个窗口类；</p><ul><li><p>打开 Qt Designer：在进行此步前，建议按之前的方法先创建一个 Qt 项目；</p><ul><li>IDE 用户可以在 Qt Creator 中右击创建 <code>Qt 设计师文件</code> （<strong>文件名很重要，将要作为这个窗体的变量名，需要记住，下面提到</strong>），在左边栏的列表中直接双击打开 <code>*.ui</code>；</li><li>非 IDE 用户可以直接进入 Qt Designer 按所需模板新建一个 <code>ui</code> 文件（<strong>文件名很重要，需要记住，下面提到</strong>）；</li></ul></li><li><p>创建、初始化子窗口部件 和 部分常用属性</p><ol><li><code>text</code> 属性：大部分组件的显示内容（还记得之前 <code>QPushButton</code>、<code>QLabel</code> 的初始化参数吗？），拖动出来双击就可以编辑；</li><li><code>objectName</code> 属性：<strong>这个名字建议自己设置，需要记住，因为这是控件的变量名，之后设计信号-槽时需要用到</strong>；</li><li><code>default</code> 属性：记得之前的方法 <code>QWidget::setDefault</code> 吗？这就是它的图形化；</li><li><code>enabled</code> 属性（<code>QPushButton</code>）：相当于在创建 widget 的同时指定 <code>btn-&gt;setEnabled(bool)</code>；</li><li><code>windowTitle</code> 属性（<code>QMainWindow</code>，这里点击窗体在右边栏就能搜到）：相当于 <code>win-&gt;setWindowTitle(str)</code>；</li></ol></li><li><p>Qt Designer 设计模式</p><ul><li>Edit Widgets 模式：默认模式，可以直接编辑上述部件及其属性，在程序顶部“Edit”菜单可以点击进入；</li><li>Edit Buddies 模式：点击顶部菜单栏相应按钮进入。此模式下，点击控件并拖到另一个部件上可以完成<strong>部件伙伴的设置</strong>，就是之前设置的 <code>widget1-&gt;setBuddy(widget2)</code>；</li><li>Edit Tab Order 模式：点击顶部菜单栏相应按钮进入。此模式下可以<strong>设置 Tab 键顺序</strong>；</li></ul></li><li><p>Qt Designer 中的布局设置</p><ul><li>方法1：使用左边栏的 Layout 控件；</li><li>方法2：按住 CTRL 选中一些 widget，点击顶部菜单栏中的 <code>Lay out Vertically/Horizontally</code>；</li></ul><blockquote><p>注：在布局中加入左边栏中的 <code>Spacer</code> 就等价于之前设置的 <code>layout-&gt;addStretch()</code></p></blockquote></li><li><p>Qt Designer 中的窗口大小设计</p><p>可以点击顶部菜单栏中的 <code>Adjust size</code>（调整大小），可以自动将窗体大小定义为最佳形式（等价于之前的 <code>setFixedHeight(sizeHint().height())</code>）</p></li></ul><h3 id="2-2-2-Qt-Designer-的运行原理【重要】"><a href="#2-2-2-Qt-Designer-的运行原理【重要】" class="headerlink" title="2.2.2 Qt Designer 的运行原理【重要】"></a>2.2.2 Qt Designer 的运行原理【重要】</h3><p>说了这么多 Qt Designer 的基本使用，那么它是怎么将 图形界面中设计的 UI 转换为之前的纯代码，并交给 <code>moc</code> 编译器 和 C++ 编译器的呢？</p><p>细心的同学可能以文本形式打开过 <code>*.ui</code> ，会发现里面的格式是 <code>XML</code> 文件格式，那么它又是如何转化为 <code>*.h/cpp</code> 的呢？<strong>下面先从非 IDE 用户的视角讲述，IDE 用户也建议看一下，因为 Qt Creator IDE 的自动操作比较奇怪，可能不好理解</strong>；</p><p> 以下的案例以名为 <code>myDialog</code> 的主窗口 <code>MainWindow</code> 的设计为例；</p><h4 id="非-IDE-用户的视角"><a href="#非-IDE-用户的视角" class="headerlink" title="非 IDE 用户的视角"></a>非 IDE 用户的视角</h4><p>首先，我们向项目中导入这个 <code>myDialog.ui</code> 文件（创建文件并 <code>qmake -project</code>，即前面的<a href="#important1">要点🔗</a>）；</p><p>你会发现，<code>qmake</code> 自动更新了 pro 文件：<code>FORM += myDialog.ui</code>（不用自己写）；</p><p>紧接着运行 <code>qmake myDialog.pro</code> 生成 <code>Makefile</code> 的同时，<code>qmake</code> 智能识别 <code>myDialog.ui</code>，会在 Makefile 中加入配置规则 <strong>调用 Qt 的新的一种编译器，这不是 GCC，也不是 <code>moc</code>，而是 Qt 用户界面编译器（user interface compiler，uic）</strong>；它会将 <code>myDialog.ui</code> 转换为 C++ 代码存储于 <code>ui_myDialog.h</code> 中；</p><p>在 <code>ui_myDialog.h</code> 会生成一个类，类名是 <code>myDialog</code>，<strong>位于 <code>Ui</code> 命名空间</strong>（命名空间 <code>Ui</code> 是 Qt 中用于存放各种 UI 类 的命名空间，通常存放在里面是一种规范）</p><blockquote><p>⚠ <strong>注意：这里 <code>ui</code> 文件名 <code>XXX.ui</code>、生成的 <code>ui_XXX.h</code> 中的 <code>XXX</code>、生成的类名 <code>XXX</code> 应该是一个名字！！！</strong></p><p>不建议轻易修改，不然有可能在下次编译时，编译器找不到相应组件；</p><p>这也是为什么之前提醒 “创建 <code>*.ui</code> 文件的文件名很重要”；</p></blockquote><p><code>ui_myDialog.h</code> 中自动生成的类看起来像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// #include something</span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE    <span class="comment">// Qt 独有的宏，将其中的类加入特定的namespace中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ui_myDialog</span> &#123;        <span class="comment">// 生成类，由于它谁都不继承，功能少，通常作为中间类使用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Widgets</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setupUi</span><span class="params">(QMainWindow* myDialog)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// realize ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">myDialog</span>: <span class="keyword">public</span> ui_myDialog &#123;&#125;;    <span class="comment">// Qt 自动在 Ui 命名空间中</span></span><br><span class="line">&#125;                                <span class="comment">// 定义了继承于 ui_myDialog 的类 myDialog</span></span><br></pre></td></tr></table></figure><p>而真正想要应用这个窗口类，需要进行<strong>多继承</strong>，使用它和 <code>QMainWindow</code> 的子类——<strong>毕竟这个类不是 <code>QObject</code>，没有办法完成信号-槽的创建</strong>；</p><p>所以一般情况下将 <code>ui_myDialog</code> 类作为中间类，再<strong>手动</strong>为这个窗口创建 <code>myDialog.h</code> 和 <code>myDialog.cpp</code>，分别书写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: myDialog.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_myDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请注意！！！这里的 myDialog 和之前定义在 ui_myDialog.h 文件中 Ui 命名空间中的类 myDialog 不一样！</span></span><br><span class="line"><span class="comment">// 这里的 myDialog 和 Ui::myDialog 类进行了继承，使 myDialog 具有了 Ui::myDialog 类一样的控件作为属性</span></span><br><span class="line"><span class="comment">// 同时 myDialog 还和 QMainWindow 进行多继承，使 myDialog 还具有 QMainWindow的属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myDialog</span> : <span class="keyword">public</span> QMainWindow, <span class="keyword">public</span> Ui::myDialog &#123;</span><br><span class="line">    Q_OBJECT        <span class="comment">// 为何需要继承 Ui::myDialog，组合不行吗？不行。</span></span><br><span class="line"><span class="keyword">public</span>:                <span class="comment">// 因为需要修改信号-槽连接，涉及其中的控件</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">myDialog</span><span class="params">(QWidget* parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: myDialog.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 myDialog 是 QMainWindow 的子类，因此想要重用它的属性，</span></span><br><span class="line"><span class="comment">// 需要委托调用父类的构造函数：QMainWindow(parent)；</span></span><br><span class="line"><span class="comment">// 此外，setupUi(this) 是以当前窗口为顶级控件，按 UI 设计部署控件</span></span><br><span class="line">myDialog::<span class="built_in">myDialog</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个只有图形界面、没有添加 槽-函数 连接的主窗口类 <code>myDialog</code> 就设计完成了；</p><blockquote><p>提示：除了上面的继承方法，还可以把 <code>Ui::myDialog</code> 作为 <code>myDialog</code> 的一个数据成员使用。</p></blockquote><h4 id="IDE-用户视角"><a href="#IDE-用户视角" class="headerlink" title="IDE 用户视角"></a>IDE 用户视角</h4><p>事实上，使用 Qt Creator 的用户在一开始，<strong>向项目中添加 <code>UI 设计师文件</code></strong>，IDE 会提示用户起名的时候，就会同时创建 <code>myDialog.ui</code>、<code>myDialog.h</code>、<code>myDialog.cpp</code> 三个文件，并更新 <code>&lt;项目名称&gt;.pro</code> 文件，直接省去非 IDE 方法中所有步骤；</p><p>值得一提的是，Qt Creator 在编译时生成的 <code>ui_myDialog.h</code> 不在项目目录中（也许是考虑到相关性），而藏在上层 build_XXX 目录里，不过使用的时候也无需注意，因为引入工作已经在自动生成的 <code>myDialog.h</code> 中写好了；</p><p>这下关于 Qt Designer 的运行机制、IDE 封装的机制是不是更清楚了呢？</p><h3 id="2-2-3-案例演示"><a href="#2-2-3-案例演示" class="headerlink" title="2.2.3 案例演示"></a>2.2.3 案例演示</h3><blockquote><p>本节将一步步地完成 2.2.1 中的窗体设计目标；将以非 IDE 的方式完成（IDE 的操作简单就不演示了）（<strong>注意，它的角色是子窗口</strong>）</p></blockquote><ol><li><p>创建一个项目目录：新建项目文件夹 <code>testUI</code>，创建文件 <code>main.cpp</code>、<code>GoToCellDialog.cpp</code>、<code>GoToCellDialog.h</code>；</p></li><li><p>打开 Qt Designer，选择 <code>Dialog without button</code> 模板，按照图中要求设计出 UI，窗体命名为 <code>GoToCellDialog</code>（<code>objectName</code>），保存文件为 <code>GoToCellDialog.ui</code>，记得保存在项目目录中；</p></li><li><p>命令行切换至项目目录，新建目录 build（为了让项目目录更干净，build 就设置在项目目录里面，你也可以设置在其他地方，比如上层目录——Qt Creator IDE 就是这么干的），命令行切入，运行 <code>qmake -project ../</code>，向 生成的 <code>testUI.pro</code> 中添加 <code>QT += widgets</code>；</p></li><li><p>编写 Go to Cell 窗体的主要逻辑代码（包括信号-槽的定义）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: GoToCellDialog.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_GoToCellDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoToCellDialog</span> : <span class="keyword">public</span> QDialog, <span class="keyword">public</span> Ui::GoToCellDialog &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoToCellDialog</span>(QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 自定义槽</span></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="comment">// 注意：这么命名是有讲究的！！！</span></span><br><span class="line">    <span class="comment">// 在 uic 和 moc 编译时，会识别所有 on_&lt;objectName&gt;_&lt;signalName&gt;() 命名的函数，自动连接：</span></span><br><span class="line">    <span class="comment">// connect(lineEdit, SIGNAL(textChanged(const QString&amp;)),</span></span><br><span class="line">    <span class="comment">//             this, SLOT(on_lineEdit_textChanged()));</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_lineEdit_textChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: GoToCellDialog.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GoToCellDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数中的 widget 变量名就是之前你在 GoToCellDialog.ui 设计中的 objectName</span></span><br><span class="line">GoToCellDialog::<span class="built_in">GoToCellDialog</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setupUi</span>(<span class="keyword">this</span>);    <span class="comment">// 以当前对象为父 widget 初始化窗体部件</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">QRegExp <span class="title">reg</span><span class="params">(<span class="string">&quot;[a-zA-Z][1-9][0-9]&#123;0,2&#125;&quot;</span>)</span></span>;        <span class="comment">// 正则表达式类</span></span><br><span class="line">    <span class="comment">// 新方法：为 QLineEdit 类设置正则可接受检验器</span></span><br><span class="line">    <span class="comment">// QRegExpValidator 的构造函数 第一个参数是 QRegExp（正则Pattern）</span></span><br><span class="line">    <span class="comment">// 第二个参数是 parent，使 QRegExpValidator 对象成为 parent 的</span></span><br><span class="line">    <span class="comment">// 子控件，这样就不要手动 delete，在父控件析构时，子控件一起析构了（之前提过）</span></span><br><span class="line">    lineEdit-&gt;<span class="built_in">setValidator</span>(<span class="keyword">new</span> <span class="built_in">QRegExpValidator</span>(reg, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置信号-槽</span></span><br><span class="line">    <span class="comment">// 这里的 accept() 和 reject() 槽是 QDialog 的固有槽，</span></span><br><span class="line">    <span class="comment">// 触发这两槽之一都会关闭窗口，但是分别会修改：</span></span><br><span class="line">    <span class="comment">// QDialog::Accepted 和 QDialog::Rejected 数据成员的值，</span></span><br><span class="line">    <span class="comment">// 以便主窗口判断用户执行了什么操作</span></span><br><span class="line">    <span class="built_in">connect</span>(okBtn, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">accept</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(cancelBtn, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">reject</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是指，当文本框改变，就进入这个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoToCellDialog::on_lineEdit_textChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果经过 QRegExpValidator 检查符合，那么激活 okBtn，否则禁用</span></span><br><span class="line">    okBtn-&gt;<span class="built_in">setEnabled</span>(lineEdit-&gt;<span class="built_in">hasAcceptableInput</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GoToCellDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    GoToCellDialog* dialog = <span class="keyword">new</span> GoToCellDialog;</span><br><span class="line">    </span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行 <code>qmake testUI.pro</code>；</p></li><li><p><strong>Windows 用户</strong>请按照之前所说的，在当前命令行运行 <a href="#script-env">配置临时环境变量的脚本🔗</a> ；</p></li><li><p>Unix 用户 执行 <code>make</code>，Windows 用户执行 <code>mingw32-make</code>，构建完成；</p></li></ol><p>如此一来，一个子窗口类的演示就做好了；</p><h1 id="Chapter-3-Qt：样式更丰富的子窗口"><a href="#Chapter-3-Qt：样式更丰富的子窗口" class="headerlink" title="Chapter 3 Qt：样式更丰富的子窗口"></a>Chapter 3 Qt：样式更丰富的子窗口</h1><blockquote><p>前面几章，只是零碎地介绍基本编写方法；</p><p>在 1.4 中，初步学习了 面向过程的简单<strong>主窗口纯代码</strong>设计；</p><p>在 2.1 中，初步学习了 面向对象的简单<strong>子窗口纯代码</strong>设计；</p><p>在 2.2 中，初步学习了 面向对象的简单<strong>子窗口快速 UI</strong> 设计；</p><p>本章将介绍更多其他样式的子窗口的设计；</p></blockquote><h2 id="3-1-扩展对话框"><a href="#3-1-扩展对话框" class="headerlink" title="3.1 扩展对话框"></a>3.1 扩展对话框</h2><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="externDialog.png" height="300px"></p><p>本节技术栈并没有拓展，还是之前的 Qt Creator、Qt Designer 使用技术；</p><p>此处仅会提及新出现的控件属性或方法等信息；</p><ul><li><code>QPushButton</code> 的属性 <code>checkable</code> ：如果修改为 <code>true</code>，则在用户点击一下后持续有效（相当于 <code>checkBox</code>），再次点击才会还原；</li><li><code>QPushButton</code> 的槽 <code>toggled(bool)</code>：当按钮 <code>enabled</code> 属性被改变时，<code>toggle</code> 会发射信号，参数就不用说了吧，，这个槽在按钮为 <code>checkable</code> 时有用；</li><li><code>QPushButton</code> 的槽 <code>setText(QString)</code>：可以在中途改变按钮的文本；</li><li><code>QGridLayout</code> 布局管理器：在 1.4.3 中介绍过，如果发现按钮较多，而且摆不整齐的时候可以尝试这个布局，它可以使控件按照行、列的规则摆放；</li><li><strong>有些人会疑惑水平/竖直分隔符（spacer）有什么用</strong>，其实它就像 Qt Designer 上画的一样，用来在窗口伸缩时，调节控件之间的位置关系的；</li><li>在 2.2.1 中，其实还有一种 <strong>Qt Designer 设计模式没有介绍到：Edit Signals/Slots</strong>，在此模式下可以<strong>直接编辑信号-槽连接</strong>，无需手动写 <code>connect</code> 函数；使用方法 和 Edit Buddy 模式类似，感兴趣可以尝试一下；</li><li><strong>新的类 <code>QGroupBox</code> 组群盒</strong>：如上图，就是那一个个小方框；</li><li>大多数 Widget 都有一个槽：<code>QWidget::setVisible(bool)</code>，可以理解为<strong>含参数、可重用的 <code>QWidget::close()</code>槽</strong>；</li><li>快捷复制：按住 CTRL，单击要复制的控件，再拖动就能复制了 ~</li><li><strong>新的类 <code>QComboBox</code> 下拉栏选择器</strong><ul><li>具有方法 <code>clear()</code>，常用在初始化时，清空选项；</li><li>具有方法 <code>addItem(QString)</code>，添加下拉栏内容，一般在 Qt Designer 里添加，也可自己在代码里写；</li><li>具有方法 <code>setMinimumSize(int)</code>，设置下拉栏的最小大小值；</li></ul></li><li><p><strong>新的类 <code>QChar</code> 字符类</strong></p><ul><li>具有方法 <code>unicode()</code>：转化为 unicode 码，可以运算；</li><li>可以作为 <code>QString</code> 的初始化参数；</li></ul></li><li><p><strong>设置窗口固定尺寸的常用方法：<code>layoutName-&gt;setSizeConstraint(QLayout::SetFixedSize)</code></strong>；</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: SortDialog.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_SortDialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortDialog</span> : <span class="keyword">public</span> QDialog, <span class="keyword">public</span> Ui::SortDialog &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SortDialog</span>(QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// Initialize the content of each column comboBox</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColumnRange</span><span class="params">(QChar first, QChar last)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: SortDialog.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortDialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtGui&gt;</span></span></span><br><span class="line"></span><br><span class="line">SortDialog::<span class="built_in">SortDialog</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent) &#123;</span><br><span class="line">    <span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// Hide the group box first,</span></span><br><span class="line">    <span class="comment">// Because the setVisible(bool) function hasn&#x27;t been called.</span></span><br><span class="line">    secondaryGroupBox-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    tertiaryGroupBox-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="comment">// Fix the size of the window</span></span><br><span class="line">    <span class="built_in">layout</span>()-&gt;<span class="built_in">setSizeConstraint</span>(QLayout::SetFixedSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setColumnRange</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortDialog::setColumnRange</span><span class="params">(QChar first, QChar last)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clear the content of each comboBox</span></span><br><span class="line">    primaryColCombo-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    secondaryColCombo-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    tertiaryColCombo-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional</span></span><br><span class="line">    secondaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">tr</span>(<span class="string">&quot;None&quot;</span>));</span><br><span class="line">    tertiaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">tr</span>(<span class="string">&quot;None&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于 primaryColCombo 中显示单字符时，展示的宽度小于</span></span><br><span class="line">    <span class="comment">// secondary 和 tertiary ColCombo 显示的 “None”，所以设置</span></span><br><span class="line">    <span class="comment">// primaryColCombo 的最小宽度，防止宽度不相同的现象</span></span><br><span class="line">    primaryColCombo-&gt;<span class="built_in">setMinimumSize</span>(secondaryColCombo-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line"></span><br><span class="line">    QChar ch = first;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= last) &#123;</span><br><span class="line">        primaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">QString</span>(ch));</span><br><span class="line">        secondaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">QString</span>(ch));</span><br><span class="line">        tertiaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">QString</span>(ch));</span><br><span class="line">        ch = ch.<span class="built_in">unicode</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    SortDialog* dialog = <span class="keyword">new</span> SortDialog;</span><br><span class="line">    <span class="comment">// 测试函数是否能用</span></span><br><span class="line">    dialog-&gt;<span class="built_in">setColumnRange</span>(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行项目即可；</p><h2 id="3-2-Qt-内置的更多部件和对话框"><a href="#3-2-Qt-内置的更多部件和对话框" class="headerlink" title="3.2 Qt 内置的更多部件和对话框"></a>3.2 Qt 内置的更多部件和对话框</h2><blockquote><p>这里仅作初步介绍，在完整项目的应用中会进一步介绍使用方法，因为一次性看完很可能记不住……</p></blockquote><ul><li><p>Qt 中的按钮类</p><ul><li>QPushButton：之前演示的普通按钮；</li><li>QToolButton：具有图标的功能按钮；</li><li>QCheckBox：复选框类；</li><li>QRadioButton：单选框类，只能在一组中选一个激活；</li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="btns.png" height="100px"></p></li><li><p>Qt 中的单页容器部件</p><ul><li>QGroupBox：之前演示的群组框；</li><li>QFrame：QLabel 的父类，可以用来展示图片、文字等信息（所以 QLabel 也行）；</li></ul></li><li><p>Qt 中的多页容器部件</p><ul><li>QTabWidget：切换多个 Tab 的窗口控件；</li><li>QToolBox：切换不同工具分类的窗口控件；</li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="multiPWidgets.png" height="200"></p></li><li><p>Qt 中的显示窗口部件：<code>QLabel</code>、<code>QLCDNumber</code>、<code>QProgressBar</code>、<code>QTextBrowser</code></p><p>注：QTextBrowser 是只读的 QTextEdit 子类，也可以显示带格式的文本，<strong>建议处理大型格式化文本</strong>，因为它和 QLabel 不同，可以在必要时自动提供滚动条；</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="showWidgets.png"></p></li><li><p>Qt 中的输入窗口部件：<code>QSpinBox</code>、<code>QDoubleSpinBox</code>、<code>QComboBox</code>、<code>QDateEdit</code>、<code>QTimeEdit</code>、<code>QDateTimeEdit</code>、<code>QScrollBar</code>、<code>QSlider</code>、<code>QTextEdit</code>、<code>QLineEdit</code>、<code>QDial</code></p><p>注：QTextEdit 支持输入掩码、检验器（2.2.3 已演示）等功能；</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="inputWidgets.png"></p></li><li><p>Qt 的反馈对话框：<code>QInputDialog</code>、<code>QProgressDialog</code>、<code>QMessageBox</code>、<code>QErrorMessage</code>、<code>QColorDialog</code>、<code>QFontDialog</code>、<code>QFileDialog</code>、<code>QPrintDialog</code> 等；</p></li></ul><h2 id="3-3-Qt-类的第二次总结-amp-下文预告"><a href="#3-3-Qt-类的第二次总结-amp-下文预告" class="headerlink" title="3.3 Qt 类的第二次总结 &amp; 下文预告"></a>3.3 Qt 类的第二次总结 &amp; 下文预告</h2><blockquote><p>学完了以上的知识，目前使用到的 Qt 类的框架如下图所示：</p></blockquote><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="C3.png"></p><p><strong>同系列下一篇文章预告：将会是 第一个完整的 Qt 入门项目（会非常地长，比本篇还长），目的是通过实战来学习 Qt 的更多类的用法，源代码和程序 届时会放在仓库，以供读者参考。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: C++ GUI Programming with Qt 4 (2nd Edition) &lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;注意：本文章将讲解 &lt;strong&gt;Qt 5&lt;/strong&gt; 入门知识，需要一定的 C++ 基础&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
    <category term="Qt" scheme="https://sjtuxhw.top/tags/Qt/"/>
    
    <category term="C++" scheme="https://sjtuxhw.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CMake 进阶</title>
    <link href="https://sjtuxhw.top/2023/07/21/CMake-%E8%BF%9B%E9%98%B6/"/>
    <id>https://sjtuxhw.top/2023/07/21/CMake-%E8%BF%9B%E9%98%B6/</id>
    <published>2023-07-21T13:41:05.000Z</published>
    <updated>2023-09-19T05:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: </i> <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMake Tutor</a></p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p>本文目标：在前文（GNU Tutor）<strong>初步了解 CMake、C++ 编译过程后</strong>，继续深入学习 CMake 在 C++ 构建中的使用；</p><hr><span id="more"></span><blockquote><p>⚠ <strong>劝退警告：如果你只想用 IDE 一键编译运行，而不想了解构建和编译细节，那么这篇文章不是为你准备的！</strong></p></blockquote><h2 id="Chapter-0-Make-介绍"><a href="#Chapter-0-Make-介绍" class="headerlink" title="Chapter 0. Make 介绍"></a>Chapter 0. Make 介绍</h2><blockquote><p><strong>对 Make 没兴趣的这章可以跳过</strong>！</p><p>CMake 生成的 Makefile 究竟是什么？语法是怎样？为什么要有它？</p><p>由于现在是 21 世纪 20 年代，所以像 <code>make</code> 这样底层的古董就点到为止；；</p></blockquote><ul><li><p>地位：GNU 计划的一个开源程序；</p></li><li><p>作用</p><ol><li>制定整个项目的<strong>编译规则</strong>（利用 <code>Makefile</code> 定义整个编译流程以及各个目标文件与源文件之间的依赖关系），自动化编译步骤，以此提高开发效率；</li><li>二次编译时，仅重新编译你的修改会影响到的部分，从而降低编译的时间；</li></ol></li><li><p>劣势：为什么上面说 “点到为止”？因为它比较底层，导致抽象层级不高，<strong>不能跨平台</strong>，每个平台有各自的 make 程序，导致编写 <code>Makefile</code> 较为繁琐；</p><blockquote><p>例如在 前文 “GNU Tutor” 中提到的 MinGW 编译器中的 make 和 Unix 系统下的 make 就有所差别；</p></blockquote><p><strong>这一劣势将由 CMake 进行弥补</strong>，之后讨论；</p></li></ul><h3 id="0-1-Makefile-的规则"><a href="#0-1-Makefile-的规则" class="headerlink" title="0.1 Makefile 的规则"></a>0.1 Makefile 的规则</h3><h4 id="0-1-1-显式规则"><a href="#0-1-1-显式规则" class="headerlink" title="0.1.1 显式规则"></a>0.1.1 显式规则</h4><ul><li><p>定义：显式规则说明了如何生成一个或多个目标文件。这是由 Makefile 的书写者明显指出要生成的文件、文件的依赖文件和生成的命令；</p></li><li><p>基本语法：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt;</span><br><span class="line">    &lt;command&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># And   &lt;-- Makefile 的行注释是 “#” 字符</span></span><br><span class="line"></span><br><span class="line">&lt;pTarget&gt; :</span><br><span class="line">    &lt;command&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>target</code>：可以是一个object file（<code>*.o</code>），也可以是一个执行文件（最终目标）；</p></li><li><p><code>pTarget</code>：在一个 makefile 中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等；被称为<strong>伪目标</strong>；</p><blockquote><p><code>pTarget</code> 部分在运行 <code>make</code> 的时候不会自动调用，外界可以使用 <code>make [pTargetName]</code> 来手动调用，例如：<code>make clean</code>，<code>make install</code> （如果 Makefile 中定义了的话）</p></blockquote></li><li><p><code>prerequisites</code>：生成该 <code>target</code> 所依赖的文件<strong>和</strong> <code>target</code>；</p></li><li><p><code>command</code>：该 <code>target</code> 或 <code>motion</code> 要执行的命令（任意的 shell 命令）</p></li></ul><p><strong>这指明了文件的依赖关系，即：<code>target</code> 这一个或多个的目标文件依赖于 <code>prerequisites</code> 中的文件，其生成规则定义在 <code>command</code> 中。</strong></p><blockquote><p>有有同学会问，Make 是怎么做到 <strong>上面的第二条作用（仅重新编译修改的部分）</strong>的呢？</p><p>很简单，如果 <code>prerequisites</code> 文件的日期要比 <code>targets</code> 文件的日期要新，或者 <code>target</code> 不存在的话，那么，make 就会执行后续定义的 <code>command</code>；</p></blockquote></li><li><p>示例：这个例子可以不需要了解项目依赖关系；废话少说，上栗子🌰：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设有一个项目包含 3 个头文件、8个源文件（名称如下）：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终目标 edit</span></span><br><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间目标</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪目标</span></span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">backup :</span><br><span class="line">    cp edit main.o kbd.o command.o display.o \</span><br><span class="line">     insert.o search.o files.o utils.o /opt/</span><br><span class="line">install :</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><ul><li><p>中间目标一般都是 <code>*.o</code> ；最终目标视需求而定，可以是可执行文件，也可以是动/静态链接库；</p></li><li><p><code>prerequisites</code> 是目标的依赖，一般是 <code>*.h/c/cpp</code>；</p></li><li><p><code>command</code> 是获得目标 / 完成动作的操作；上面的例子中，<strong><code>cc</code> 是 C 的编译器命令，<code>cp</code> 和 <code>rm</code> 是 Unix 系统的命令</strong>；</p><blockquote><ol><li><strong>必须以制表符（或者说 <code>\t</code>、Tab 键）开头</strong>；</li><li>默认工作目录为 Makefile 所在目录；</li></ol></blockquote></li></ul></li><li><p><strong>（规范）伪目标声明</strong>：对于<strong>伪目标</strong>而言，应该使用 <code>.PHONY</code> 关键字声明，更符合规范；</p><p>例如上面例子的规范写法应该加上：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean backup install</span><br></pre></td></tr></table></figure><p>另外，规范来说，请将所有伪目标写在后面，以防读者误认为最终目标；</p><ul><li><p>作用：防止与文件名/最终目标重名，增强可读性；</p></li><li><p>特点：伪目标<strong>可以有依赖</strong>，这样相当于是<strong>委托调用</strong>，例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">    rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">    rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">    rm *.diff</span><br></pre></td></tr></table></figure></li></ul></li><li><p>指定文件查找目录：<code>VPATH</code> 关键字（知道就行）；</p></li></ul><h4 id="0-1-2-隐晦规则"><a href="#0-1-2-隐晦规则" class="headerlink" title="0.1.2 隐晦规则"></a>0.1.2 隐晦规则</h4><blockquote><p>作用：make 有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile；</p></blockquote><ol><li>生成 <code>*.o</code> 时，默认将同名的 <code>*.c/cpp</code> 加入依赖中，同时<strong>省去相应的编译命令</strong>；</li><li>当 make 在 Makefile 中找不到与目标同名的 <code>*.c/cpp</code>，那么 make 认为这个目标为伪目标；</li></ol><p>因此，利用隐晦规则，最开始的例子可以简化为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">    </span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><blockquote><p>注：上面的 “<code>-rm edit</code>” 前面有个 “-”，表示中间如果出现错误，也请继续进行的意思（忽略错误）；</p><p>这里正好补充一下 Makefile 的变量使用：</p><ul><li>定义：<code>name=value</code>；调用：<code>$&#123;variableName&#125;</code>；</li><li><strong>类似 C++ 中的宏替换</strong>（后面介绍赋值运算符）；</li></ul></blockquote><h4 id="0-1-3-文件指示-和-编译设置"><a href="#0-1-3-文件指示-和-编译设置" class="headerlink" title="0.1.3 文件指示 和 编译设置"></a>0.1.3 文件指示 和 编译设置</h4><p><strong>文件指示一共包含 3 个部分</strong>：</p><ol><li><strong>在一个 Makefile 中引用另一个 Makefile</strong>，就像 C 语言中的 #include 一样；</li><li>根据某些情况<strong>指定 Makefile 中的有效部分</strong>，就像 C 语言中的预编译 #if 一样；</li><li>还有就是<strong>定义一个多行的命令</strong>，不会深入介绍，感兴趣请查看 <a href="https://seisman.github.io/how-to-write-makefile/index.html">教程</a>；</li></ol><p>这里就介绍第一个：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make *.mk $&#123;bar&#125;</span><br></pre></td></tr></table></figure><p>上面这行代码的含义是：包含 <code>foo.make</code>，所有后缀为 <code>mk</code> 的，和在变量 <code>$&#123;bar&#125;</code> 中的文件作为 Makefile；</p><p>此外，以 UNIX 为例，make 自动包含了 <code>/usr/local/bin</code> 和 <code>/usr/include</code> 中的文件；</p><p>还可以加上 “-” 表示读取错误全部忽略：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> foo.make *.mk $&#123;bar&#125;</span><br></pre></td></tr></table></figure><p><strong>编译设置</strong> 最常用的是设置 C++ 编译器，可以由修改内置变量完成：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC := clang</span><br><span class="line">CXX := clang++</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码含义是：<strong>将 C 编译器改为 <code>clang</code>，将 C++ 编译器改为 <code>clang++</code></strong>；</p></blockquote><h4 id="0-1-4-赋值运算符"><a href="#0-1-4-赋值运算符" class="headerlink" title="0.1.4 赋值运算符"></a>0.1.4 赋值运算符</h4><blockquote><p>看到上面的例子，大家可能有些疑惑，<code>:=</code> 和 <code>=</code> 赋值有区别吗？答案是，有的。</p></blockquote><ul><li><p><code>=</code> 是<strong>保留计算式</strong>的赋值；</p></li><li><p><code>:=</code> 是<strong>立刻计算结果</strong>并覆盖原来的值；</p></li><li><p><code>?=</code> 是如果没有被赋值过就赋予等号后面的值；</p></li><li><p><code>+=</code> 是添加等号后面的值；</p></li></ul><p>举个例子体会一下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = foo</span><br><span class="line">y = <span class="variable">$(x)</span> bar</span><br><span class="line">x = xyz</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="string">&quot;<span class="variable">$(y)</span>&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := xyz</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="string">&quot;<span class="variable">$(y)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>上面一段 Makefile 运行 <code>make all</code> 会输出：<code>xyz bar</code>；</p><p>而下面一段会输出：<code>foo bar</code>；</p><h4 id="0-1-5-小结：Make-的工作方式"><a href="#0-1-5-小结：Make-的工作方式" class="headerlink" title="0.1.5 小结：Make 的工作方式"></a>0.1.5 小结：Make 的工作方式</h4><ol><li><p>读入所有的 Makefile；</p></li><li><p>读入被 include 的其它 Makefile；</p></li><li><p>初始化文件中的变量；</p></li><li><p>推导隐晦规则，并分析所有规则；</p></li><li><p>为所有的目标文件创建依赖关系链；</p></li><li><p>根据依赖关系，决定哪些目标要重新生成；</p></li><li><p>执行生成命令；</p></li></ol><h3 id="0-2-Make-命令的使用"><a href="#0-2-Make-命令的使用" class="headerlink" title="0.2 Make 命令的使用"></a>0.2 Make 命令的使用</h3><ul><li>Windows 上如果安装 <code>MinGW</code> 编译器套件，那么应该使用 <code>mingw32-make</code> 来进行；不讨论 <code>MSVC</code> 编译器套件 ~ 用它的大多数是用了微软的 Visual Studio 的套件；</li><li>Linux 本身就是 GNU 产物，直接安装 <code>make</code> 就能用了；</li></ul><h2 id="Chapter-1-CMake-命令使用"><a href="#Chapter-1-CMake-命令使用" class="headerlink" title="Chapter 1. CMake 命令使用"></a>Chapter 1. CMake 命令使用</h2><p>众所周知，CMake 可以完成 2 步：① 将 CMakeLists.txt 翻译生成 Makefile；② 代替 make 完成编译构建；</p><p>下面我们特指 ① 为 <strong>生成</strong>，② 为 <strong>编译/构建</strong>；</p><h3 id="1-1-生成指令"><a href="#1-1-生成指令" class="headerlink" title="1.1 生成指令"></a>1.1 生成指令</h3><p>总体语法：<code>cmake [options] &lt;projectDir&gt;</code>（<code>projectDir</code> 需含有 <code>CMakeLists.txt</code>）；</p><p>下面介绍 <code>[options]</code>：</p><ul><li><p>指定生成 Makefile 等中间文件的目录（生成时会将所有文件放入该目录）：<code>-B &lt;dirName&gt;</code>（<code>dirName</code> 默认当前目录，下同）；</p></li><li><p><strong>指定生成的 Makefile 种类</strong>：<code>-G &lt;Makefile-Type&gt;</code>；</p><blockquote><p>这里 Unix 类系统（macOS 和 Linux）会默认 <code>&quot;Unix Makefiles&quot;</code>，<strong>大多数情况下无需更改</strong>，因为<strong>使用 Unix 内置的 GNU/Make 程序和 GNU/GCC 编译器</strong>；</p><p>这里<strong>对于 Windows 用户很重要</strong>，因为 Windows 的 make 工具种类很多，针对您所安装的编译器对应的 <code>make</code>，需要进行合理选择，取值有（有空格，命令行里记得加双引号）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Visual Studio 17 2022        &lt;--- 使用 VS IDE 的同学不需要指定，IDE 会自动设置</span><br><span class="line">Visual Studio 16 2019</span><br><span class="line">Visual Studio 15 2017 [arch]</span><br><span class="line">Visual Studio 14 2015 [arch]</span><br><span class="line">Visual Studio 12 2013 [arch]</span><br><span class="line">Visual Studio 11 2012 [arch]</span><br><span class="line">Visual Studio 9 2008 [arch]</span><br><span class="line">Borland Makefiles</span><br><span class="line">NMake Makefiles            &lt;--- 使用 nmake 的同学选这个</span><br><span class="line">NMake Makefiles JOM</span><br><span class="line">MSYS Makefiles</span><br><span class="line">MinGW Makefiles            &lt;--- 使用正宗 MinGW 编译器的同学选这个</span><br><span class="line">Green Hills MULTI</span><br><span class="line">Unix Makefiles            &lt;--- Unix 系统的同学不需要指定，系统会自动设置</span><br><span class="line">Ninja                    &lt;--- 使用 Ninja 的同学选这个</span><br><span class="line">Ninja Multi-Config</span><br><span class="line">Watcom WMake</span><br><span class="line">CodeBlocks - MinGW Makefiles    &lt;--- 你的 codeblocks 装了什么编译器？</span><br><span class="line">CodeBlocks - NMake Makefiles</span><br><span class="line">CodeBlocks - NMake Makefiles JOM</span><br><span class="line">CodeBlocks - Ninja</span><br><span class="line">CodeBlocks - Unix Makefiles</span><br><span class="line">CodeLite - MinGW Makefiles</span><br><span class="line">CodeLite - NMake Makefiles</span><br><span class="line">CodeLite - Ninja</span><br><span class="line">CodeLite - Unix Makefiles</span><br><span class="line">Eclipse CDT4 - NMake Makefiles</span><br><span class="line">Eclipse CDT4 - MinGW Makefiles</span><br><span class="line">Eclipse CDT4 - Ninja</span><br><span class="line">Eclipse CDT4 - Unix Makefiles</span><br><span class="line">Kate - MinGW Makefiles</span><br><span class="line">Kate - NMake Makefiles</span><br><span class="line">Kate - Ninja</span><br><span class="line">Kate - Ninja Multi-Config</span><br><span class="line">Kate - Unix Makefiles</span><br><span class="line">Sublime Text 2 - MinGW Makefiles</span><br><span class="line">Sublime Text 2 - NMake Makefiles</span><br><span class="line">Sublime Text 2 - Ninja</span><br><span class="line">Sublime Text 2 - Unix Makefiles</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="1-2-编译构建指令"><a href="#1-2-编译构建指令" class="headerlink" title="1.2 编译构建指令"></a>1.2 编译构建指令</h3><ul><li><p><strong>构建编译</strong>（可代替 <code>make</code>）：<code>cmake --build &lt;dirName&gt;</code>；</p><blockquote><p>和 Make 一样，可以仅重新编译你的修改会影响到的部分，从而降低编译的时间；</p></blockquote></li></ul><h2 id="Chapter-2-CMakeList-常见函数"><a href="#Chapter-2-CMakeList-常见函数" class="headerlink" title="Chapter 2. CMakeList 常见函数"></a>Chapter 2. CMakeList 常见函数</h2><blockquote><p>注：CMake 的函数名不区分大小写；</p><p>以下函数分为 3 个等级：optional 可选、recommended 推荐书写、necessary 必要；</p><p>众所周知，C++ 项目的编译和构建的目标可以是 <strong>可执行文件</strong>，也可以是<strong>静/动态链接库</strong>；以下函数如果仅用于某个特定目标，那么会标注 <strong>in EXE Project</strong> 或 <strong>in LIB Project</strong>；</p></blockquote><ul><li><p>【optional】指定 CMake 版本，可选低于版本产生致命错误：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ver 建议是当前系统中的 CMake 版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION &lt;ver&gt; [FATAL_ERROR])</span><br><span class="line"><span class="comment"># 例如我的 CMake 版本是 3.12，并且想让其他人生成时，CMake低于这个版本就报错，那么这么写：</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span> FATAL_ERROR)</span><br></pre></td></tr></table></figure></li><li><p>【recommended】指定 Project 名称、使用编译器语言（不填写也可自动识别）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span> (&lt;projectName&gt; [LANGUAGES CXX])</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意，这里指定项目名称后，变量 <code>$&#123;PROJECT_NAME&#125;</code> 就被设定了，可以在后面使用</strong>；</p></blockquote></li><li><p>【optional】告诉编译器从哪里寻找非标准 C++ 的头文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span> (&lt;dir&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>可以理解为：</p><p>Makefile 中的 include 关键字：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;dir&gt;/*</span><br></pre></td></tr></table></figure><p>或者 g++ 中的 <code>-I</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ [...] -I&lt;<span class="built_in">dir</span>&gt; [...]</span><br></pre></td></tr></table></figure></blockquote></li><li><p>【optional】向指定目标规定寻找非标准 C++ 头文件路径：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TARGET_INCLUDE_DIRECTORIES</span> (&lt;targetName&gt; [INTERFACE | PRIVATE | PUBLIC] &lt;dir&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PUBLIC 表示这个项目的外部使用者能看到</span></span><br><span class="line"><span class="comment"># PRIVATE 则对外部完全隐藏，即不希望调用这个项目目标的使用者知道“这个项目引入了该头文件”</span></span><br></pre></td></tr></table></figure><blockquote><p><strong><code>INCLUDE_DIRECTORIES</code> 和 <code>TARGET_INCLUDE_DIRECTORIES</code> 比较：</strong></p><p>前者是向整个项目（包括子目录和库）添加了寻找头文件的寻找路径；</p><p>后者是向特定目标添加了寻找头文件的寻找路径，<strong>同时可以指定暴露级别</strong>；</p><p><strong>这就和不同范围设置 C++ 标准异曲同工</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_STANDARD <span class="number">11</span>)        <span class="comment"># 全局设置 C++ 规范</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">TARGET_COMPILE_FEATURES</span> (&lt;targetName&gt; [...] cxx_std_11)    <span class="comment"># 设置特定库的规范</span></span><br></pre></td></tr></table></figure><p>从项目规范性上说，<strong>建议使用 <code>TARGET_INCLUDE_DIRECTORY</code> 而非 <code>INCLUDE_DIRECTORY</code></strong>；</p></blockquote></li><li><p>【necessary <strong>in EXE Project</strong>】将指定源文件加入构建为 <strong>可执行文件</strong> 的目标中：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (&lt;exeName&gt; &lt;sourceFileNames&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>位于 <code>TARGET_LINK_LIBRARIES</code> 前，在其他函数之后；</p><p><strong>注意，和 Make 的隐晦规则恰好相反，如果这个头文件被某一源文件引入的话，可以省略对应的头文件</strong>；</p></blockquote></li><li><p>【recommended】查找指定目录下的所有源文件，并将文件名存入变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (&lt;dir&gt; &lt;variableName&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>此后就能使用变量：<code>$&#123;&lt;variableName&gt;&#125;</code>；</p></blockquote></li><li><p>【optional】给项目加入子目录（<strong>即读取这个目录下的 <code>CMakeLists.txt</code></strong>）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span> (&lt;dir&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>书写这个函数后，在主 <code>CMakeLists.txt</code> 中就可以直接指明子目录下生成的目标名，<strong>这在导入并链接自己编写的 动/静态链接库 时用的较多</strong>；</p></blockquote></li><li><p>【necessary <strong>in LIB Project</strong>】将指定源文件加入构建为 <strong>链接库</strong> 的目标中：</p><blockquote><p>请大家复习一下什么是 “静态链接库”、什么是 “动态链接库”：</p><p>静态链接库是 <strong>运行前、编译时可以链接进入到目标文件中</strong>，优点是分发时文件个数少，不依赖外部文件；缺点是修改了静态链接库的内容的话程序整体需要重新编译；</p><p>动态链接库是 <strong>运行时才链接到目标文件中</strong>，优点是只要 API 不变，修改动态链接库可以单独进行编译，并且节省内存（仅在调用库函数时才加载到内存中）；缺点是文件分发数多，不便管理；</p><p><strong>注：C++ 的库的隐含规则——链接库文件名是 “lib” + 库名 + 后缀</strong>；</p></blockquote><ol><li><p><strong>目标为静态链接库</strong>（后缀名可能是 <code>*.a</code>、<code>*.lib</code>，<strong>和操作系统、编译器类型都有关系</strong>）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_LIBRARY</span> (&lt;libName&gt; [STATIC] &lt;sourceFileNames&gt;)    <span class="comment"># 默认 STATIC</span></span><br></pre></td></tr></table></figure></li><li><p><strong>目标为动态链接库</strong>（后缀名可能是 <code>*.so</code>、<code>*.dll</code>、<code>*.dylib</code>）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态链接库一般不和主程序一起编译，因为这样还不如用静态链接库</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span> (&lt;libName&gt; SHARED &lt;sourceFileNames&gt;)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>【optional】告诉编译器从哪里寻找非标准 C++ 的<strong>动态链接库</strong>，<strong>一般也同时指定非标准头文件查找目录（include_directories 或 target_include_directories）</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LINK_DIRECTORIES</span> (&lt;dir&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>可以理解为 g++ 的 <code>-L</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ [...] -L &lt;<span class="built_in">dir</span>&gt; [...]</span><br></pre></td></tr></table></figure></blockquote></li><li><p>【optional】<strong>向 可执行文件目标 或 链接库目标 链接一些库</strong>：</p><blockquote><p>众所周知，想要链接库，必须要有 <strong>头文件、动/静态链接库文件</strong>，并且把它们都引入自己的项目中</p></blockquote><ol><li><p><strong>要链接的库是自己编写的 / 第三方静态链接库</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是自己编写的静态链接库，请确保使用了 add_subdirectory 引入该库的 CMakeLists</span></span><br><span class="line"><span class="comment"># 或者在当前 CMakeLists 中指定编译的库，需要 add_library</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是第三方静态链接库，则建议引入头文件，使用 include_directory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (&lt;targetName&gt; &lt;libName/libFileName&gt;)</span><br></pre></td></tr></table></figure></li><li><p><strong>要链接的库是动态链接库</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span> (&lt;dir&gt;)    <span class="comment"># 引入非标准头文件查找目录</span></span><br><span class="line"><span class="keyword">LINK_DIRECTORIES</span> (&lt;dir&gt;)    <span class="comment"># 引入非标准链接库查找目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果最终目标是可执行文件，那么 add_executable 应该写在这里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (&lt;targetName&gt; &lt;libName/libFileName&gt;)</span><br></pre></td></tr></table></figure></li><li><p><strong>要链接的库是标准 C++ 库</strong>（一般这种情况是这个标准 C++ 库不在标准位置，<strong>最常见的是官方的 C++ 扩充，例如 Qt 的库</strong>）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定标准库名，如果它在环境变量中，那么就不需要后面的 PATHS 参数</span></span><br><span class="line"><span class="keyword">FIND_PACKAGE</span> (&lt;stdLibDirName&gt; [REQUIRED] [PATHS &lt;dir&gt;])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定标准库以何种形式链接到目标中</span></span><br><span class="line"><span class="comment"># PUBLIC 和 PRIVATE 含义和之前的 TARGET_INCLUDE 的含义相同</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (&lt;targetName&gt; [PUBLIC | PRIVATE] &lt;stdLibDirName::stdLibName&gt;)</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="Chapter-3-CMakeLists-变量控制"><a href="#Chapter-3-CMakeLists-变量控制" class="headerlink" title="Chapter 3. CMakeLists 变量控制"></a>Chapter 3. CMakeLists 变量控制</h2><h3 id="3-1-常用内置变量"><a href="#3-1-常用内置变量" class="headerlink" title="3.1 常用内置变量"></a>3.1 常用内置变量</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>        <span class="comment"># 这是 CMakeLists.txt 所在目录</span></span><br><span class="line"><span class="variable">$&#123;PROJECT_NAME&#125;</span>                    <span class="comment"># 项目名称，上面介绍了</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;CMAKE_CXX_STANDARD&#125;</span>            <span class="comment"># 这是 C++ 标准设置，如果要使用新特性，例如 auto 出现在 </span></span><br><span class="line">                                <span class="comment"># C++ 11 中，那么应该指定标准版本为 11，否则会报错</span></span><br><span class="line"><span class="variable">$&#123;CMAKE_C_FLAGS&#125;</span></span><br><span class="line"><span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span>                <span class="comment"># 这两个变量是传给 gcc/g++ 的编译器参数，</span></span><br><span class="line">                                <span class="comment"># 一些常用的参数例如 -Wall 警告、-ggdb 调试行号</span></span><br><span class="line"><span class="comment"># 使用的规范是在后面添加，例如：</span></span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall -ggdb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;CMAKE_BUILD_TYPE&#125;</span>                <span class="comment"># 这是设置编译类型，可以是 Release | Debug</span></span><br></pre></td></tr></table></figure><h3 id="3-2-赋值和使用"><a href="#3-2-赋值和使用" class="headerlink" title="3.2 赋值和使用"></a>3.2 赋值和使用</h3><p>CMake 变量赋值函数 <code>SET</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> (&lt;variableName&gt; &lt;value&gt; [CACHE] [<span class="keyword">STRING</span> | BOOL] [Description])</span><br></pre></td></tr></table></figure><p>使用直接：<code>$&#123;&lt;variableName&gt;&#125;</code>；</p><h3 id="3-3-编译时宏定义"><a href="#3-3-编译时宏定义" class="headerlink" title="3.3 编译时宏定义"></a>3.3 编译时宏定义</h3><blockquote><p>假设程序中有一个量，不希望其他人知道，但其他代码都可以开源——那么需要实现：仅编译时将这个量传入；假设这个量在源码中以 <code>APP_ID</code> 表示，那么 CMakeLists.txt 应该这么写：</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> (</span><br><span class="line">    _APP_ID<span class="comment"># 设置 CMakeLists 临时环境变量</span></span><br><span class="line">    CACHE <span class="keyword">STRING</span></span><br><span class="line">    &lt;Description&gt;</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 要求必须传入这个量，否则报错</span></span><br><span class="line"><span class="keyword">IF</span> (_APP_ID <span class="keyword">STREQUAL</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span> (SEND_ERROR &lt;prompt&gt;)</span><br><span class="line"><span class="keyword">ENDIF</span> ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译时宏定义，相当于编译前加入了：#define APP_ID &lt;值&gt;</span></span><br><span class="line"><span class="keyword">TARGET_COMPILE_DEFINITIONS</span> (&lt;targetName&gt; PRIVATE APP_ID=<span class="string">&quot;$&#123;_APP_ID&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>这是传入临时值的方法是 cmake 的 <code>-D&lt;env=value&gt;</code> 参数，例如上面的<strong>生成指令</strong>应该这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -D_APP_ID=<span class="string">&quot;XXX&quot;</span> &lt;Dir&gt;</span><br></pre></td></tr></table></figure><h2 id="Chapter-4-CMakeLists-常见模板"><a href="#Chapter-4-CMakeLists-常见模板" class="headerlink" title="Chapter 4. CMakeLists 常见模板"></a>Chapter 4. CMakeLists 常见模板</h2><blockquote><p>下面模板的项目依赖极其简单，但不能照抄，需要根据项目实际依赖情况进行调整；</p></blockquote><h3 id="4-1-普通-C-项目"><a href="#4-1-普通-C-项目" class="headerlink" title="4.1 普通 C++ 项目"></a>4.1 普通 C++ 项目</h3><p>项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.    # C++ 标准 11</span><br><span class="line">|</span><br><span class="line">|--- main.cpp</span><br><span class="line">|--- App.h</span><br><span class="line">|--- App.cpp</span><br><span class="line">|--- CMakeLists.txt</span><br></pre></td></tr></table></figure><p>模板：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (myApp)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp App.cpp)</span><br></pre></td></tr></table></figure><h3 id="4-2-多个目录的-C-项目"><a href="#4-2-多个目录的-C-项目" class="headerlink" title="4.2 多个目录的 C++ 项目"></a>4.2 多个目录的 C++ 项目</h3><blockquote><p>多个目录可以考虑使用静态链接库，下面展示一种自定义静态链接库的 CMakeLists.txt 写法</p></blockquote><p>项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.    # 这个项目需要 Debug 模式构建，并且增添编译参数 “-Wall” 和 “-ggdb”</span><br><span class="line">|</span><br><span class="line">|--- main.cpp</span><br><span class="line">|--- App.h</span><br><span class="line">|--- App.cpp</span><br><span class="line">|--- CMakeLists.txt</span><br><span class="line">|--- src/                # 这个目录需要编译为静态链接库并同时链接到主程序</span><br><span class="line">        |</span><br><span class="line">        |--- Manager.h</span><br><span class="line">        |--- Manager.cpp</span><br><span class="line">        |--- CMakeLists.txt</span><br></pre></td></tr></table></figure><p>在项目根目录下的 CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (myApp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAG&#125; -Wall -ggdb&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_BUILD_TYPE Debug)</span><br><span class="line"></span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (. MAIN_SRC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span> (src/)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;MAIN_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> myLib)</span><br></pre></td></tr></table></figure><p>在 <code>src/</code> 目录下的 CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (. LIB_SRC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span> (myLib <span class="variable">$&#123;LIB_SRC&#125;</span>)    <span class="comment"># 默认静态链接库</span></span><br></pre></td></tr></table></figure><h3 id="4-3-使用动态链接库的-C-项目"><a href="#4-3-使用动态链接库的-C-项目" class="headerlink" title="4.3 使用动态链接库的 C++ 项目"></a>4.3 使用动态链接库的 C++ 项目</h3><p>项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.    # 项目使用 C++ 11 规范</span><br><span class="line">|</span><br><span class="line">|--- main.cpp</span><br><span class="line">|--- App.cpp</span><br><span class="line">|--- App.h</span><br><span class="line">|--- CMakeLists.txt</span><br><span class="line">|--- core/                # 这个 core 目录要求链接到主程序</span><br><span class="line">        |</span><br><span class="line">        |--- lib/</span><br><span class="line">        ||</span><br><span class="line">        ||--- libManager.so</span><br><span class="line">        |</span><br><span class="line">        |--- include/</span><br><span class="line">                |</span><br><span class="line">                |--- Manager.h</span><br></pre></td></tr></table></figure><p>项目根目录下的 CMakeLists.txt 写法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (myApp)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (. SRC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">LINK_DIRECTORIES</span> (<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/core/lib/)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_INCLUDE_DIRECTORIES</span> (</span><br><span class="line">    <span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/core/<span class="keyword">include</span>/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> libManager.so)</span><br></pre></td></tr></table></figure><p>或者不用 <code>LINK_DIRECTORIES</code>，直接改为单独设置库的代码：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (myApp)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (. SRC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span> (Manager STATIC IMPORTED)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span> (Manager</span><br><span class="line">    PROPERTIES</span><br><span class="line">        IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/core/lib/libManager.so</span><br><span class="line">        INTERFACE_INCLUDE_DIRECTORIES <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/core/<span class="keyword">include</span>/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> Manager)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt; &lt;a href=&quot;https://cmake.org/cmake/help/latest/guide/tutorial/index.html&quot;&gt;CMake Tutor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;本文目标：在前文（GNU Tutor）&lt;strong&gt;初步了解 CMake、C++ 编译过程后&lt;/strong&gt;，继续深入学习 CMake 在 C++ 构建中的使用；&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="CMake" scheme="https://sjtuxhw.top/tags/CMake/"/>
    
    <category term="GNU" scheme="https://sjtuxhw.top/tags/GNU/"/>
    
    <category term="Programmimg" scheme="https://sjtuxhw.top/tags/Programmimg/"/>
    
  </entry>
  
  <entry>
    <title>Fiddler Everywhere的crack实践</title>
    <link href="https://sjtuxhw.top/2023/07/15/Fiddler-Everywhere%E7%9A%84crack%E5%AE%9E%E8%B7%B5/"/>
    <id>https://sjtuxhw.top/2023/07/15/Fiddler-Everywhere%E7%9A%84crack%E5%AE%9E%E8%B7%B5/</id>
    <published>2023-07-15T04:12:45.000Z</published>
    <updated>2023-09-19T05:12:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><p><i>本文如有侵权，请联系作者删除</i></p><hr><span id="more"></span><p>众所周知，Fiddler 是一个无比好用的、免费的网络调试代理工具，可以方便地进行抓包、代理服务等基本操作。最近在看到一些文章介绍 Fiddler 的使用时无意间发现 Fiddler everywhere 的软件，UI 制作更加用心，而且功能更加强大，可惜的是会订阅收费。在受到 <a href="https://github.com/msojocs/fiddler-everywhere-enhance/tree/master">Github@msojocs</a>（好像停更了）的指引下，我开始了对 Fiddler-Everywhere 软件的 “学习”。</p><blockquote><p>声明：本文不含有实际的<strong>观点导向</strong> 或者 <strong>建议</strong>，如有侵权，请联系删除；</p><p>在尽情使用的同时，欢迎大家订阅官网正版的 <a href="https://www.telerik.com/download/fiddler-everywhere">Fiddler everywhere</a>；</p></blockquote><h2 id="工作环境准备"><a href="#工作环境准备" class="headerlink" title="工作环境准备"></a>工作环境准备</h2><p>要进行 crack 实践，必然得从反编译入手；</p><p>首先了解到 Fiddler Everywhere 是使用 C# 编写的程序，所以事先必须准备关于 C# 的运行环境 和 反编译程序；</p><p>Windows 自带 <code>.net</code> 运行库不够用，需要下载 <code>dotnet-sdk</code>，再将开发包里的反编译程序 <code>ilasm</code> 和 <code>ildasm</code> 设置到环境变量中使用；当然，如果不想下载各种运行库，也可以使用 <code>dnSpy</code> 反编译工具；</p><blockquote><p><code>dnSpy</code> 解压即用：<a href="crack_fiddler/dnSpy-win64.rar">dnSpy.rar</a>，也可上 Github 上找同名的开源项目；</p></blockquote><p>Linux 用户如果觉得直接装的系统环境中没啥问题，可以使用 <code>.net</code> 官网的方式安装 <code>dotnet-sdk</code> 和 反编译工具 <code>ilasm (ildasm)</code></p><p>Linux 用户如果不想 <code>.net</code> 直接装到系统环境里面，可以使用本人配置的 dockerfile 构建镜像，然后进去操作；（这里只是用来隔离一个环境，然而 docker 并不是这么用的，所以不上传到 docker Hub 上去了）</p><ol><li>在 Linux 任意发行版上配置好 docker，在某个新目录下写好 <code>Dockerfile</code>；</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&quot;</span> /etc/apk/repositories \        <span class="comment"># 这里如果在国内上网，则需要更换源</span></span></span><br><span class="line"> &amp;&amp; apk --update <span class="keyword">add</span><span class="language-bash"> --no-cache dotnet7-sdk \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; dotnet new console -n crackFiddler \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mkdir</span> fiddler &amp;&amp; <span class="built_in">cd</span> crackFiddler \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; dotnet add package Microsoft.NETCore.ILAsm \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; dotnet add package Microsoft.NETCore.ILDAsm \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; dotnet publish -c Release --self-contained --runtime linux-x64 \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">printf</span> <span class="string">&quot;PATH=<span class="subst">$(pwd)</span>/bin/Release/netcoreapp3.1/linux-x64/publish:<span class="variable">$PATH</span>&quot;</span> &gt;&gt; /etc/profile \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure><ol><li><p>构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t crackImage .</span><br></pre></td></tr></table></figure></li></ol><p>之后只需等待 Fiddler Everything 装好再修改就行；</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>开始前需要安装 Fiddler Everything 正版软件 <strong>4.0.1 版本</strong>（为什么是这个版本，后面介绍）； </p><p>安装完成后记住安装根目录：Windows 在“快捷方式 -&gt; 打开文件所在目录” 寻找，Linux 在安装目录寻找；</p><p>⚠ <strong>注意：进行反编译前，请注册一个 Fiddler 账户，并且打开软件、“开始试用” 再关闭，不然无法进行 crack；</strong></p><p>后面的步骤会以 Windows 为例，需要修改的部分 linux 也相同，不过 linux 用的是 <code>ildasm</code> （将动态链接库反编译为 <code>*.il</code> 文本）和 <code>ildasm</code> （将 <code>*.il</code> 编译为 动态链接库）。语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ildasm &lt;libFilename&gt; --output=&lt;outputFile&gt;</span><br><span class="line"></span><br><span class="line">ilasm &lt;ilFile&gt; --output=&lt;libName&gt;</span><br></pre></td></tr></table></figure><p>下面介绍 Windows 的详细做法：</p><p>根据 Github 上的高手找到的 Fiddler Everything 授权验证的代码区域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 这是授权认证的入口处变量定义的位置</span><br><span class="line">Fiddler Everywhere\resources\app\out\WebServer\ClientApp\dist\main.xxxxxx.js</span><br><span class="line"></span><br><span class="line"># 这是 Fiddler Everything 文件校验的函数所在的动态链接库</span><br><span class="line">Fiddler Everywhere\resources\app\out\WebServer\Fiddler.WebUi.dll</span><br><span class="line"></span><br><span class="line"># 这是 Fiddler Everything 验证账户是否激活的函数所在的动态链接库</span><br><span class="line">Fiddler Everywhere\resources\app\out\WebServer\FiddlerBackendSDK.dll</span><br><span class="line"></span><br><span class="line"># 这是 Fiddler Everything 自动更新版本功能所在的 javascript 脚本</span><br><span class="line">Fiddler Everywhere\resources\app\out\main.js</span><br></pre></td></tr></table></figure><p>⚠ 本人还发现，这种方法必须是 <strong>4.0.1</strong>，官方在 <strong>4.3</strong> 以后<strong>已经移除了</strong>文件校验函数所在的 <code>Fiddler.WebUi.Helper</code> 命名空间中的 <code>ScriptHelper</code> 类；</p><p><strong>下面是本人的详细步骤</strong>：</p><ol><li><p>修改<strong>授权认证的入口处变量的定义</strong>（位于 Fiddler Everything 根目录下的 <code>resources\app\out\WebServer\ClientApp\dist\main.xxxxxx.js</code>，这里的 “XXX” 在每一版本中都不同，需要自行在目录下确认）；</p><p>有工程经验的同学会发现，<code>dist</code> 文件夹一般是 <code>javascript</code> 源 或者 <code>typescript</code> 编译后所存放的目录，<strong>这里修改生成文件在 JS 开发中是不妥当的：生成代码堆砌在一起难以阅读，并且下一次生成不会保存修改</strong>；但这次是 crack，并且以后不会再编译项目，所以这么改没关系。</p><p>如图，使用搜索工具查找到更新授权信息的函数 <code>updateUserLicense</code> 定义（第一个匹配才是定义，后面的都是引用）：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="crack_fiddler/updateUserLicense.png"></p><p>紧接着<strong>在函数的第一句前</strong>加上如下一段语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;param&gt;.<span class="property">licenseInfo</span>.<span class="property">currentLicense</span> = <span class="string">&quot;Pro&quot;</span>;</span><br><span class="line">&lt;param&gt;.<span class="property">licenseInfo</span>.<span class="property">hasExpiredTrial</span> = <span class="literal">false</span>;</span><br><span class="line">&lt;param&gt;.<span class="property">licenseInfo</span>.<span class="property">isTrialAvailable</span> = <span class="literal">false</span>;</span><br><span class="line">&lt;param&gt;.<span class="property">licenseInfo</span>.<span class="property">hasValidLicense</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>其中 “\<param\>” 需要替换成你的文件里所看到的这个函数的参数（在上面我的图里，这个参数名叫 <code>ve</code>，因此把 “\<param\>” 换成 “ve”）</strong>，效果如下图：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="crack_fiddler/updateUserLicense2.png"></p></li><li><p><strong>反编译 文件校验的函数所在的动态链接库</strong>（位于根目录下 <code>resources\app\out\WebServer\Fiddler.WebUi.dll</code>）；</p><p>打开 <code>dnSpy</code> C# 反编译工具，导入该动态链接库（Linux 同学这步替换为 <code>ildasm</code> 反编译该文件为 <code>*.il</code>），搜索反编译码，找到<strong>命名空间 <code>Fiddler.WebUi.Helper</code></strong>，再在其中找到<strong>类 <code>ScriptHelper</code></strong>，查看到这个类的两个方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x06000943 RID: 2371 RVA: 0x0001C678 File Offset: 0x0001A878</span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryOpenClientMainScript</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">string</span> error</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x06000944 RID: 2372 RVA: 0x0001C8E0 File Offset: 0x0001AAE0</span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryOpenElectronMainScript</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">string</span> error</span>)</span>;</span><br></pre></td></tr></table></figure><p>将其中的 <code>try&#123;&#125; catch&#123;&#125;</code> 块全部删除，它们的作用是<strong>校验启动脚本的正确性</strong>，应该将其删除，最终函数将直接返回 <code>true</code>，如下图：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="crack_fiddler/scriptHelper.png"></p><p>记得将再将该库<strong>编译回去</strong>、<strong>保存这个模块</strong>；</p><p>比如这是我编译出来的动态链接库：<a href="crack_fiddler/Fiddler.WebUi.dll">Fiddler.WebUi.dll</a>；</p></li><li><p><strong>反编译 验证账户激活函数所在的动态链接库</strong>（位于根目录下 <code>resources\app\out\WebServer\FiddlerBackendSDK.dll</code>）；</p><p>继续使用 <code>dnSpy</code> 打开该库，找到<strong>命名空间 <code>FiddlerBackendSDK.User</code></strong>，再定位到其中的一个<strong>类 <code>UserClient</code></strong>，找到其中的<strong>方法 <code>GetBestAccount</code></strong>，将函数体中的判断语句直接换为返回 <code>true</code>，换好后如图：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="crack_fiddler/getBestAccount.png"></p><p>这是我编译出来的动态链接库：<a href="crack_fiddler/FiddlerBackendSDK.dll">FiddlerBackendSDK.dll</a>；</p></li><li><p><strong>禁用自动更新</strong>（位于根目录下 <code>resources\app\out\main.js</code>）；</p><p>找到这么一行语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.<span class="property">settingsService</span>.<span class="title function_">get</span>().<span class="property">autoUpdateSettings</span>.<span class="property">disabled</span></span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span>||e.<span class="property">settingsService</span>.<span class="title function_">get</span>().<span class="property">autoUpdateSettings</span>.<span class="property">disabled</span></span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="crack_fiddler/update_disable.png"></p></li></ol><p>到目前为止，再次打开 Fiddler Everywhere 就完成的本次实践 ~</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="crack_fiddler/finish.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本文如有侵权，请联系作者删除&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Fiddler" scheme="https://sjtuxhw.top/tags/Fiddler/"/>
    
    <category term="Crack" scheme="https://sjtuxhw.top/tags/Crack/"/>
    
    <category term="Disassembly" scheme="https://sjtuxhw.top/tags/Disassembly/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基础</title>
    <link href="https://sjtuxhw.top/2023/07/09/Docker-%E5%9F%BA%E7%A1%80/"/>
    <id>https://sjtuxhw.top/2023/07/09/Docker-%E5%9F%BA%E7%A1%80/</id>
    <published>2023-07-09T14:23:41.000Z</published>
    <updated>2023-09-19T05:18:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference：</i><a href="https://docs.docker.com/engine/reference/builder/">Docker 官方文档</a></p><p><i>本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><blockquote><p><strong>前置知识：Linux、Git、虚拟机、略懂操作系统</strong>；</p></blockquote><h2 id="Chapter-0-Docker-安装"><a href="#Chapter-0-Docker-安装" class="headerlink" title="Chapter 0. Docker 安装"></a>Chapter 0. Docker 安装</h2><h3 id="Mac-安装"><a href="#Mac-安装" class="headerlink" title="Mac 安装"></a>Mac 安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask docker</span><br></pre></td></tr></table></figure><h3 id="Linux-任何-distribution-自动安装"><a href="#Linux-任何-distribution-自动安装" class="headerlink" title="Linux 任何 distribution 自动安装"></a>Linux 任何 distribution 自动安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh    <span class="comment"># 自动安装脚本</span></span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun <span class="comment"># 国内阿里云，如果你在国外，删除 --mirror参数</span></span><br></pre></td></tr></table></figure><h3 id="Ubuntu-手动安装"><a href="#Ubuntu-手动安装" class="headerlink" title="Ubuntu 手动安装"></a>Ubuntu 手动安装</h3><ol><li><p>卸载旧版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker \</span><br><span class="line">               docker-engine \</span><br><span class="line">               docker.io</span><br></pre></td></tr></table></figure></li><li><p>安装 HTTPS 必要软件包 和 CA 证书防止安装包篡改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure></li><li><p>添加软件源的 <code>GPG</code> 密钥，以确认所下载软件包的合法性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你在国外，或者正在科学上网，请使用国外密钥：</span></span><br><span class="line"><span class="comment"># curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span></span><br></pre></td></tr></table></figure></li><li><p>向 APT 源添加国内软件源（stable 版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 如果你在国外……</span></span><br><span class="line"><span class="comment"># echo \</span></span><br><span class="line"><span class="comment">#   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="comment">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br></pre></td></tr></table></figure></li><li><p>更新 APT 缓存并安装 <code>docker-ce</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure></li><li><p>启动 Docker 服务并建立对应用户组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Chapter-1-基本概念"><a href="#Chapter-1-基本概念" class="headerlink" title="Chapter 1. 基本概念"></a>Chapter 1. 基本概念</h2><h3 id="1-1-具体原理、地位和性质"><a href="#1-1-具体原理、地位和性质" class="headerlink" title="1.1 具体原理、地位和性质"></a>1.1 具体原理、地位和性质</h3><blockquote><p>本部分内容涉及内容比较深，学完 <code>Go</code> 和 操作系统再回来填坑……</p></blockquote><h3 id="1-2-Docker-和-传统虚拟化技术的比较"><a href="#1-2-Docker-和-传统虚拟化技术的比较" class="headerlink" title="1.2 Docker 和 传统虚拟化技术的比较"></a>1.2 Docker 和 传统虚拟化技术的比较</h3><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="virtualization.png" height="200px"></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="docker.png" height="150px"></p><p>如上图所示，传统虚拟化技术构建出的 <code>Hypervisor</code> 需要<strong>虚拟出一套硬件</strong>，并在其上运行一个完整的操作系统（<code>Guest OS</code>），再在该系统上运行所需进程；</p><p>而 Docker 容器中的应用进程借助 <code>Docker Engine</code> 直接运行于宿主内核，无需硬件虚拟；</p><table>    <tr style="text-align: center;">        <th>特性</th>        <th>容器</th>        <th>虚拟机</th>    </tr>    <tr>        <td>启动</td>        <td>秒级</td>        <td>分钟级</td>    </tr>    <tr>        <td>硬盘使用</td>        <td>一般为 MB</td>        <td>一般为 GB</td>    </tr>    <tr>        <td>性能</td>        <td>接近原生</td>        <td>弱于</td>    </tr>    <tr>        <td>系统支持量</td>        <td>单机支持上千个容器</td>        <td>一般几十个</td>    </tr>    <tr>        <td>迁移和部署</td>        <td>容易</td>        <td>困难</td>    </tr>    <tr>        <td>维护和扩展</td>        <td>高质量官方镜像</td>        <td>极其困难</td>    </tr></table><h3 id="1-3-镜像"><a href="#1-3-镜像" class="headerlink" title="1.3 镜像"></a>1.3 镜像</h3><ul><li><p>操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持；</p></li><li><p>而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统（实际上就是一个特殊的文件系统）；除了<strong>提供</strong>容器运行时所需的<strong>程序、库、资源、配置</strong>等文件外，还包含了一些为运行时准备的一些配置参数（如<strong>匿名卷、环境变量、用户</strong>等）；</p></li><li><p>Docker 镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变；</p></li><li><p>Docker 镜像采用 <strong><a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a></strong> 技术（操作系统术语），设计为 <strong>分层存储</strong> 的架构——并非像 <code>*.iso</code> 一样打包成一个文件，<strong>而是一组、多层文件系统联合而成</strong>；</p><ol><li><p>镜像的<strong>构建</strong>时，会一层层构建；前一层是后一层的基础；</p></li><li><p>每一层构建完就不再改变，<strong>后一层的任何更改只发生在自己这层</strong>；</p><blockquote><p>比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除（最终容器运行时，也不会看到）；</p></blockquote></li><li><p>优点：<strong>分层存储的特征还使得镜像的复用、定制变的更为容易</strong>；</p></li></ol></li><li><p>镜像的构建方法以后再说；</p></li></ul><h3 id="1-4-容器"><a href="#1-4-容器" class="headerlink" title="1.4 容器"></a>1.4 容器</h3><ul><li><p>Docker 镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，可以看成面向对象程序设计中的 <strong>类</strong> 和 <strong>实例</strong>；</p><blockquote><p>镜像是<strong>静态</strong>的定义，容器是镜像<strong>运行时的</strong>实体；</p></blockquote></li><li><p>容器的实质是<strong>进程</strong>（process），但和运行在 <code>Host OS</code> 上的普通进程不一样，有着<strong>独立的<a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>（<code>Linux namespace</code>），包含独立的 <code>root</code> 文件系统、网络配置、进程空间、用户 ID 空间</strong>；</p><blockquote><p>体现<strong>隔离</strong>特性，有利于保证宿主系统的安全性；</p></blockquote></li><li><p>容器 和 镜像一样，使用<strong>分层存储</strong>——以镜像为<strong>基础层</strong>，在其上创建一个当前容器的存储层，称这个为容器<strong>运行时访问</strong>而准备的存储层为 <strong>容器存储层</strong>；</p><blockquote><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失；</p></blockquote><p><strong>tips 1.</strong> <span id="needVolume">按 Docker 规范，容器不应该向其存储层内写入任何数据，容器存储层要保持<strong>无状态化</strong>；</span></p><blockquote><p>注：Instead，应该使用 <strong>数据卷（Volume，类似 <code>Linux</code> 中的 <code>mount</code> 挂载目录）</strong>、或者 <strong>绑定宿主目录</strong>（这两种方法将在 Chapter 5 介绍），在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高；</p><p>相反，当我们运行一个容器的时候（<strong>如果不使用卷的话</strong>），我们做的任何文件修改都会被记录于容器存储层里，<strong>导致多个无关文件被修改，不利于迁移、维护</strong>；</p></blockquote><p><strong>tips 2.</strong> 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡，因此在容器被删除或重启后，在数据卷中的数据不会丢失；</p></li></ul><h3 id="1-5-仓库"><a href="#1-5-仓库" class="headerlink" title="1.5 仓库"></a>1.5 仓库</h3><ul><li><p>Docker 社区提供集中的<strong>存储、分发镜像</strong>的服务，称为<strong><code>Docker Registry</code> 公开服务</strong>，最常用的是 <code>Docker Hub</code>（可以理解成类似 <code>Github</code>、<code>Gitee</code> 一样）：提供 <strong>公共仓库（public repository）</strong> 服务，允许用户免费上传、下载公开的镜像；</p><blockquote><p>因此，<strong>Registry 和 Repository 是两个完全不同的概念</strong>；前者指注册的、提供这些服务的服务器，后者指可以被认为是一个具体的项目或目录；</p><p>例如，对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名；</p></blockquote></li><li><p>用户也还可以借助 ① Docker 开发团队的开源 Docker Registry 镜像；或 ② 第三方软件（如 Harbor 和 Sonatype Nexus），来实现<strong>本地搭建私有 Docker Registry</strong>；</p></li></ul><h2 id="Chapter-2-使用镜像"><a href="#Chapter-2-使用镜像" class="headerlink" title="Chapter 2. 使用镜像"></a>Chapter 2. 使用镜像</h2><h3 id="2-1-镜像获取"><a href="#2-1-镜像获取" class="headerlink" title="2.1 镜像获取"></a>2.1 镜像获取</h3><ul><li><p>从 <code>Docker Hub</code> 上获取：<code>docker pull [options] [addr:port/]&lt;RepositoryName&gt;[:tag]</code></p><ul><li><code>[options]</code>：请运行 <code>docker pull --help</code> 查看；</li><li><code>[addr:port/]</code>：默认 <code>docker.io:443</code>（<code>Docker Hub</code> 服务器）；</li><li><code>&lt;RepositoryName&gt;</code>：格式为 <code>&lt;userName&gt;/&lt;softwareName&gt;</code>，<strong>如果仅有 <code>softwareName</code>，则默认官方镜像（<code>userName = library</code>）</strong>;</li><li><code>[:tag]</code>：<strong>镜像标签</strong>，可以理解成 <code>Git</code> 中的 <code>tag</code>，起到<strong>标识镜像版本或分类</strong>的作用；<strong>同一个镜像必须有相同的 ID，可以有不同的 <code>tag</code></strong>；</li></ul><blockquote><p>下载会一层层下载（分层存储），完成后会显示<strong>每层 ID 前 12 位</strong>和镜像整体的 <code>sha256</code> 摘要；</p></blockquote></li></ul><h3 id="2-2-列出镜像"><a href="#2-2-列出镜像" class="headerlink" title="2.2 列出镜像"></a>2.2 列出镜像</h3><ul><li><p>列出顶层镜像：<code>docker image ls</code>，显示 <strong>仓库名、标签、镜像 ID、创建时间和占用空间大小</strong>；</p></li><li><p>关于 <strong>“占用空间大小”</strong>：由于 Docker 使用 Union FS 和多层存储结构，<strong>不同层间可以继承、复用</strong>，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比上面命令显示的小很多；</p><blockquote><p>想要查看<strong>镜像、容器、数据卷</strong>所占用的<strong>真实空间</strong>，请运行：<code>docker system df</code>；</p></blockquote></li><li><p><strong>虚悬镜像（dangling image）</strong>：一种特殊的<strong>顶层镜像</strong>，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>；</p><ul><li>产生原因：① 同一标签的镜像因为官方的维护，ID 发生变更，这样在 <code>docker pull</code> 同个镜像 <code>tag</code> 时，此镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消；② 自己本地构建镜像（<code>docker build</code>，以后介绍）时，由于新旧镜像同名，旧镜像名称被取消；</li><li><strong>查找虚悬镜像</strong>：<code>docker image ls -f dangling=true</code>（加 <code>-f</code> 参数，<code>--filter</code> 过滤）；</li><li><strong>删除虚悬镜像</strong>：虚悬镜像已经失去了存在的价值，可以随意删除：<code>docker image prune</code>；</li></ul></li><li><p><strong>中间层镜像</strong>：想要看中间层镜像，需要使用 <code>docker image ls -a</code>（加 <code>-a</code> 参数）；</p><blockquote><p>此时可能会出现没有标签的镜像，<strong>但它们不是虚悬镜像，而是中间层镜像</strong>，由于多层存储结构，它们相互依赖，<strong>千万不能盲目删除</strong>；</p></blockquote></li><li><p><strong>按条件筛选列出镜像</strong>：<code>docker image ls -f &lt;dangling=bool/since=repositoryName/label=labelName&gt;</code></p></li><li><p><strong>输出格式化</strong>：<code>docker image ls --format &quot;&lt;GoTemplate&gt;&quot;</code></p><blockquote><p>这里的 <code>GoTemplate</code> 是 Go 语言的<strong>模板语法</strong>，可以简单使用常见变量：<code>&#123;&#123;.ID&#125;&#125;</code>、<code>&#123;&#123;.Repository&#125;&#125;</code>、<code>&#123;&#123;.Tag&#125;&#125;</code>；</p></blockquote></li></ul><h3 id="2-3-删除镜像"><a href="#2-3-删除镜像" class="headerlink" title="2.3 删除镜像"></a>2.3 删除镜像</h3><ul><li><p>镜像 ID 删除：<code>docker image rm &lt;IMAGE_ID&gt;</code></p><blockquote><p>一般只有脚本使用完整 ID，人工一般都使用短 ID，对长度没有要求，只要能区分就行（一般 长度大于 3 就能区分）</p></blockquote></li><li><p><code>repositoryName</code> 删除：<code>docker image rm &lt;RepositoryName&gt;</code>；</p></li><li><p>镜像 <code>sha256</code> 摘要删除：<code>docker image &lt;name@sha256:VALUE&gt;</code>；</p><blockquote><p>查询镜像 <code>sha256</code> 摘要：<code>docker image ls --digests</code>；</p></blockquote></li><li><p>补充：<code>Untagged</code> 和 <code>Deleted</code> 的区别：请结合 <code>Git</code> 自行品味；<code>Git</code> 和这个很相似；</p></li><li><p><strong>查询删除法</strong>：<code>docker image rm $(docker image ls -q &lt;之前的查询条件&gt;)</code></p></li></ul><h3 id="2-4-镜像定制和构建"><a href="#2-4-镜像定制和构建" class="headerlink" title="2.4 镜像定制和构建"></a>2.4 镜像定制和构建</h3><blockquote><p>注：第一次学习感觉有难度的可以先跳过本节，直接进入下一章 Chapter 3！</p></blockquote><p><strong>镜像的定制实际上就是定制每一层所添加的配置、文件</strong>。</p><blockquote><p>正如官方文档所说：如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决；</p><p><strong>这个脚本</strong>（文本文档）就是 <code>Dockerfile</code>。和 <code>Makefile</code>、<code>CMakeLists</code> 有异曲同工之妙，名字必须是 <code>Dockerfile</code>；</p></blockquote><h4 id="2-4-1-Dockerfile-定制"><a href="#2-4-1-Dockerfile-定制" class="headerlink" title="2.4.1 Dockerfile 定制"></a>2.4.1 Dockerfile 定制</h4><blockquote><p><code>Dockerfile</code> 包含了一条条的 <strong>指令(Instruction)</strong>，每条指令构建一层，每行一条指令，末尾没有分号；</p></blockquote><h5 id="FROM-指令：指定基础镜像"><a href="#FROM-指令：指定基础镜像" class="headerlink" title="FROM 指令：指定基础镜像"></a><code>FROM</code> 指令：指定基础镜像</h5><ul><li><p>语法：<code>FROM &lt;REPO_NAME&gt;</code>，<code>&lt;REPO_NAME&gt;</code> 为之前提到的存储库名；</p></li><li><p>所谓定制镜像，那一定是<strong>以一个镜像为基础，在其上进行定制</strong>；</p></li><li><p>因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是<strong>必备的指令</strong>，并且<strong>必须是第一条指令</strong>；</p></li><li><p><code>Docker Hub</code> 上有很多高质量基础镜像：</p><ol><li>服务类镜像：<code>nginx</code>、<code>redis</code>、<code>mongo</code>、<code>mysql</code>、<code>httpd</code>、<code>php</code>、<code>tomcat</code> 等；</li><li>语言应用类镜像：<code>node</code>、<code>openjdk</code>、<code>python</code>、<code>ruby</code>、<code>golang</code> 等；</li><li>操作系统类镜像（具有对应软件库可更自由地配置）：<code>ubuntu</code>、<code>debian</code>、<code>centos</code> 等；</li></ol></li><li><p><strong>空白基础镜像</strong>：<code>scratch</code>（意味着<strong>不以任何镜像为基础</strong>，接下来所写的指令将作为镜像第一层开始存在）；</p><blockquote><p>不以任何系统为基础，<strong>直接将可执行文件复制进镜像</strong>的做法并不罕见：</p><ol><li>Linux 下静态编译的程序（所需的一切库都已经在可执行文件中，无需操作系统的运行时支持）；</li><li>大部分使用 Go 语言开发的应用（Go 特别适合容器微服务架构的原因之一）；</li></ol></blockquote></li></ul><h5 id="RUN-指令：执行命令"><a href="#RUN-指令：执行命令" class="headerlink" title="RUN 指令：执行命令"></a><code>RUN</code> 指令：执行命令</h5><ul><li><p>语法：<code>RUN &lt;SH_COMMAND&gt;</code> 或 <code>RUN [&quot;executableName&quot;, &quot;param1&quot;, ...]</code>；</p><ul><li><code>RUN &lt;SH_COMMAND&gt;</code> 参数会自动翻译为 <code>RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;&lt;SH_COMMAND&gt;&quot;]</code>；</li></ul></li><li><p>⚠ <strong>注意：每一个 <code>RUN</code> 指令都会新建一层镜像层</strong>，因此从重用性角度出发，<strong>同一个目的的操作尽量写在一个 <code>RUN</code> 语句中</strong>，例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样的 Dockerfile 编写方式是不恰当的！！！结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等</span></span><br><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y gcc libc6-dev make wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这段代码只有一个目的，就是编译、安装 redis 可执行文件，所以没有必要建立很多层，这只是一层的事情。</span></span><br><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x; buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># 以下清理文件是非常重要的步骤，确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</span></span></span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \ <span class="comment"># 清理了 apt 缓存文件</span></span><br><span class="line">    &amp;&amp; rm redis.tar.gz \             <span class="comment"># 清理了所有下载、展开的文件</span></span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps <span class="comment"># 删除了为了编译构建所需要的软件和库</span></span><br></pre></td></tr></table></figure><p>⚠ <strong>更重要的是</strong>，每个 <code>RUN</code> 指令由于所处的层数不一样，所以执行这个命令的命令行也不一样，这样就相当于开了新的命令行窗口，有的时候第一种写法甚至是错误的、无法运行的，例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure><p>你会发现 <code>world.txt</code> 根本不在 <code>/app/</code> 下面，因为下一个 <code>RUN</code> 的 console 已经不在 <code>/app/</code> 下面了；<strong>这就是对 Docker 分层存储理解不透的结果</strong>。也正是这个原因，请不要把 <code>Dockerfile</code> 作为 shell 脚本使用！</p><p>想要实现上面的操作，可以改成：<code>RUN cd /app &amp;&amp; echo &quot;hello&quot; &gt; world.txt</code>；</p><p>⚠ 如果你实在需要分成多个 <code>RUN</code> 步骤（例如为了容器层的可重用性——中间多一层可以有其他用处），但<strong>又希望命令行固定在某个目录下进行</strong>，请参考下文 <strong><code>WORKDIR</code> 指令的使用</strong>；</p></li></ul><h5 id="COPY-指令：复制文件"><a href="#COPY-指令：复制文件" class="headerlink" title="COPY 指令：复制文件"></a><code>COPY</code> 指令：复制文件</h5><ul><li><p>语法：<code>COPY [--chown=&lt;user:group&gt;] &lt;src1&gt;[, src2, ...], &lt;dist1&gt;[, dist2, ...]</code> ；</p></li><li><p>支持 <code>--chown</code> 参数更改文件所属用户和组；</p></li><li><p>使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等；</p></li><li><p><code>src</code> 源路径必须在上下文路径中，关于什么是上下文路径，建议立即查看 <a href="#contextPath"><strong>下文</strong>🔗</a>；</p></li><li><p>不仅可以指定多个文件，<code>src</code> 还支持 <code>Go</code> 语言的 <a href="https://golang.org/pkg/path/filepath/#Match"><code>filepath.Match</code></a> 通配符规则，可以简单认为：</p><table>    <tr style="text-align: center;">        <th>Regex 正则</th>        <th>Go::filepath.Match</th>    </tr>    <tr>        <td>.*</td>        <td>*</td>    </tr>    <tr>        <td>.?</td>        <td>?</td>    </tr>    <tr>        <td>[a-zA-Z]</td>        <td>[{a-zA-Z}]</td>    </tr></table></li><li><p><strong>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径</strong>；举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|</span><br><span class="line">|--- Dockerfile</span><br><span class="line">|--- ABC.txt</span><br><span class="line">|--- testDir/</span><br><span class="line">        |</span><br><span class="line">        |--- DEF.txt</span><br><span class="line">        |--- testDir2/</span><br><span class="line">                |</span><br><span class="line">                |--- FGH.txt</span><br><span class="line">                |--- IJK.txt</span><br></pre></td></tr></table></figure><p>上面的项目目录，如果在 Dockerfile 中有这么一段：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>并且构建镜像以 <code>testDir</code> 为上下文根目录：<code>docker build -f Dockerfile -t XXX ./testDir/</code>，那么在容器中，<strong><code>testDir</code> 本身不会在里面</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app/</span><br><span class="line">|--- DEF.txt</span><br><span class="line">|--- testDir2/</span><br><span class="line">        |</span><br><span class="line">        |--- FGH.txt</span><br><span class="line">        |--- IJK.txt</span><br></pre></td></tr></table></figure></li></ul><h5 id="ADD-指令：自动解压并复制文件"><a href="#ADD-指令：自动解压并复制文件" class="headerlink" title="ADD 指令：自动解压并复制文件"></a><code>ADD</code> 指令：自动解压并复制文件</h5><ul><li>和 <code>COPY</code> 语法几乎相同，<strong>真正需要 <code>ADD</code> 的场景是自动解压缩</strong>，即 <code>&lt;src&gt;</code> 路径是一个 <code>*.zip/*.bz/*.xz/*.gz/*.tar</code> 时会自动解压缩；<strong>其他时候应该使用语义明确的 <code>COPY</code></strong>；</li></ul><h5 id="CMD-指令：设置容器启动命令"><a href="#CMD-指令：设置容器启动命令" class="headerlink" title="CMD 指令：设置容器启动命令"></a><code>CMD</code> 指令：设置容器启动命令</h5><ul><li><p>用于指定默认的容器主进程的启动命令（容器启动指令 <code>docker run</code> 将在 3.1 介绍），语法和 <code>RUN</code> 相同；</p></li><li><p>如果指定了该命令，那么当运行 <code>docker run</code> 后，<strong>默认运行容器中的 <code>/bin/bash</code></strong> 的行为将被更改为 <code>CMD</code> 后的指令；</p></li><li><p><strong>易错点：前台执行 &amp;&amp; 后台执行</strong>；先问大家伙一个问题，下面的指令有意义吗？</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;&lt;h1&gt;Hello, nginx!&lt;/h1&gt;&quot;</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> systemctl start nginx</span></span><br></pre></td></tr></table></figure><p>如果你认为没有任何问题的话，恭喜你，<strong>你成功地将 传统虚拟机 和 docker 容器搞混了！</strong> 请你好好复习 <strong>1.2 和 1.4</strong> 的内容：容器本身就是一种进程，<strong>它不是虚拟机、内部不存在守护进程，因此不允许在“后台”启动应用，必须在前台，否则会直接退出</strong>；</p><blockquote><p>引用官方文档的一句话：对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出；</p></blockquote><p>上面的 <code>CMD systemctl start nginx</code> 会被解释成：<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，这样运行完这条指令后主进程直接结束！</p><p><strong>想要在容器生存周期内持续运行 <code>nginx</code>，必须以指定前台的方式运行，如下：</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;&lt;h1&gt;Hello, nginx!&lt;/h1&gt;&quot;</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="ENTRYPOINT-指令：设置容器入口点"><a href="#ENTRYPOINT-指令：设置容器入口点" class="headerlink" title="ENTRYPOINT 指令：设置容器入口点"></a><code>ENTRYPOINT</code> 指令：设置容器入口点</h5><ul><li><p>语法和 <code>RUN</code>、<code>CMD</code> 都相同，<strong>它存在的主要作用有两个：① 更方便地从外部添加运行参数；② 更方便地进行容器运行前准备工作</strong>；</p></li><li><p>想理解主要作用，需要知道 <code>ENTRYPOINT</code> 如何工作：<strong>当指定 <code>ENTRYPOINT</code> 后，<code>CMD</code> 指令的意义发生变化：<code>CMD</code> 默认值变为空，并且<code>CMD</code> 将作为 <code>ENTRYPOINT</code> 的参数进行传递</strong>；这使得 <code>ENTRYPOINT</code> 实现了上述两个优点；分别举一个栗子🌰说明：</p><p><strong>①</strong> 假设有一个镜像是这么设计的：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>如果<strong>想向里面的 <code>curl</code> 命令添加参数</strong>，例如 <code>-i</code>，是做不到的；</p><p>（之后会介绍 <code>docker run [options] &lt;containerName&gt; [CMD]</code> 启动容器的命令，在”容器名“后面的参数是 <code>CMD</code>，会覆盖 <code>Dockerfile</code> 中的 <code>CMD</code> 指令）</p><p>但是如果这么写就不一样了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>这样在 <code>docker run</code> 最后指定 <code>CMD</code> 时，这个参数会传递给 <code>ENTRYPOINT</code> 作为参数，完美解决这个传参问题；</p><p><strong>②</strong> 再假设我们在使用一个数据库镜像，可能需要以 <code>root</code> 身份完成一些数据库配置、初始化的工作，再根据需要<strong>切换用户以保证安全性</strong>；<strong>比如官方 <code>Redis</code> 镜像是这么做的</strong>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File: Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.4</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># root 身份建立用户组相关设置</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]        <span class="comment"># 容器启动后执行该脚本</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;redis-server&quot;</span> ]    <span class="comment"># 因为上文有 ENTRYPOINT，所以这里不是指容器的启动命令，</span></span></span><br><span class="line">                        <span class="comment"># 而是指传给 ENTRYPOINT 的默认参数是 &quot;redis-server&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    find . \! -user redis -<span class="built_in">exec</span> <span class="built_in">chown</span> redis <span class="string">&#x27;&#123;&#125;&#x27;</span> +</span><br><span class="line">    <span class="built_in">exec</span> gosu redis <span class="string">&quot;<span class="variable">$0</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个脚本指的就是根据 CMD 参数的内容来判断，如果是 redis-server 的话，</span></span><br><span class="line"><span class="comment"># 则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="ENV-指令：设置环境变量"><a href="#ENV-指令：设置环境变量" class="headerlink" title="ENV 指令：设置环境变量"></a><code>ENV</code> 指令：设置环境变量</h5><ul><li><p>语法：<code>ENV &lt;key&gt; &lt;value&gt;</code> 或 <code>ENV &lt;key1&gt;=&lt;value1&gt; [&lt;key2&gt;=&lt;value2&gt; ...]</code>（语法特殊，只有多个环境变量参数间不用加逗号），<strong>环境变量将停留在容器的全生命周期中</strong>；</p></li><li><p>它的作用：设置合适的环境变量可以让维护工作变得轻松，例如 <code>node</code> 官方镜像的 Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; grep <span class="string">&quot; node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt | <span class="built_in">sha256sum</span> -c - \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; tar -xJf <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> -C /usr/local --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">ln</span> -s /usr/local/bin/node /usr/local/bin/nodejs</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="ARG-指令：设置构建参数"><a href="#ARG-指令：设置构建参数" class="headerlink" title="ARG 指令：设置构建参数"></a><code>ARG</code> 指令：设置构建参数</h5><ul><li><p>语法与 <code>ENV</code> 相同，不过 <code>ARG</code> 只是<strong>构建镜像时临时存在的环境变量</strong>，并且<strong>只在 <code>FROM</code> 中生效</strong>，想要在其他语句中使用，必须重新指定，举几个栗子🌰：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 情况 1 ----------------------------</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span> <span class="comment"># 这步是无效输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 2 -----------------------------</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想在 FROM 之后使用，必须再次指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span> <span class="comment"># 这样才是有效输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 3（多阶段构建，后面说） -----------</span></span><br><span class="line"><span class="comment"># 这个变量在每个 FROM 中都生效（使用的场合必须要都是 FROM）</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 4（多阶段构建）-------------------</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span> <span class="comment"># 有效输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span> <span class="comment"># 有效输出</span></span></span><br></pre></td></tr></table></figure></li></ul><h5 id="VOLUME-指令：定义匿名卷"><a href="#VOLUME-指令：定义匿名卷" class="headerlink" title="VOLUME 指令：定义匿名卷"></a><code>VOLUME</code> 指令：定义匿名卷</h5><ul><li><p>语法：<code>VOLUME &lt;inContainerPath&gt;</code> 或 <code>VOLUME &quot;&lt;inPath1&gt;&quot;, &quot;&lt;inPath2&gt;, ...&quot;</code>；</p></li><li><p>它的作用：在 <a href="#needVolume">之前</a> 提到过，容器运行时应该尽量保持容器存储层不发生写操作，所以数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中（后面 <strong>5.1</strong> 会介绍数据卷），而<strong>为了防止用户运行容器 <code>docker run</code> 忘记加 <code>-v</code> 参数（后面说）来指定目录挂载卷，可以在 <code>Dockerfile</code> 中写 <code>VOLUME</code> 匿名卷，相当于“没有指定目录名的默认卷”</strong>；</p><p>这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据；</p><blockquote><p>注意：匿名卷正因为匿名、没有指定在 <code>Host OS</code> 上的挂载目录，docker engine 会自动选择诸如： <code>/var/lib/docker/</code> 这样的一些位置存起来，在容器删除后也不会自动删除，得自己找，比较麻烦；</p><p><strong>所以尽量自己记得挂载数据卷，不要依赖匿名卷</strong>；</p></blockquote></li></ul><h5 id="EXPOSE-指令：声明端口"><a href="#EXPOSE-指令：声明端口" class="headerlink" title="EXPOSE 指令：声明端口"></a><code>EXPOSE</code> 指令：声明端口</h5><ul><li>语法：<code>EXPOSE &lt;port1&gt; [port2 ...]</code> （和 <code>ENV</code> 一样，多个参数没逗号）；</li><li>⚠ <strong>注意：是声明，而不是直接暴露</strong>，意味着在容器运行时<strong>并不会因为这个声明应用就会开启这个端口的服务</strong>；那它有什么用呢？</li><li>它的作用：① <strong>帮助镜像使用者理解</strong>这个镜像服务的守护端口，以方便自行配置映射；② 当使用 <code>docker run</code> 的 <code>-P(大写)</code> 参数（后面介绍，是将容器端口开放到 <code>Host OS</code> 的随机端口）时，默认使用 <code>EXPOSE</code> 声明的端口；</li><li><strong>辨析：<code>EXPOSE</code> 不能和 <code>docker run</code> 的 <code>-p(小写)</code> 参数</strong>（也是后面介绍）<strong>作用搞混，后者是真的会进行从宿主到容器的端口映射，而前者只是声明</strong>；</li></ul><h5 id="WORKDIR-指令：指定工作目录"><a href="#WORKDIR-指令：指定工作目录" class="headerlink" title="WORKDIR 指令：指定工作目录"></a><code>WORKDIR</code> 指令：指定工作目录</h5><ul><li><p>语法：<code>WORKDIR &lt;inContainerDir&gt;</code>（如果容器内该目录不存在，则<strong>会自动创建</strong>）；</p></li><li><p>它的作用：<strong>改变以后各层的工作目录位置</strong>，确保每一层的命令行默认位置都在该目录下；如果参数是<strong>相对路径</strong>，那么和<strong>之前的</strong>工作目录有关，例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span>    <span class="comment"># 此时在容器内命令行中打印的应该是 /a/b/c/</span></span></span><br></pre></td></tr></table></figure></li></ul><h5 id="USER-指令：指定当前用户"><a href="#USER-指令：指定当前用户" class="headerlink" title="USER 指令：指定当前用户"></a><code>USER</code> 指令：指定当前用户</h5><ul><li><p>语法：<code>USER &lt;userName&gt;[:userGroup]</code>；</p></li><li><p>它的作用：<strong>改变</strong>之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的<strong>身份</strong>（之前说过，docker 容器有一套完整独立的命名空间）；</p></li><li><p>和 <code>WORKDIR</code> 的异同比较：</p><ul><li>和 <code>WORKDIR</code> 的作用效果类似，都是<strong>改变环境状态并影响以后的层</strong>；</li><li>和 <code>WORKDIR</code> 不同的是，如果指定用户不存在，则无法切换——<strong>此指令不会自动创建用户</strong>；</li></ul></li><li><p>⚠ 如果要建立一个用户、用户组（大多数时候用 <code>RUN</code>），并且在 <code>RUN</code> 的中途想要切换用户（不添加中间层的情况，就没法使用 <code>USER</code>），请 <strong>一定不要</strong> 使用 <code>su</code> 和 <code>sudo</code>，因为通常在刚下载的原始镜像中都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错；</p><blockquote><p>尤其是这种情况：<strong>如果容器内的应用需要 “优雅停机”（接收信号量 <code>SIGABRT</code>）</strong>，那么一定需要这个应用的进程<strong>在容器内的 <code>PID</code> = 1</strong>；而运行 <code>su/sudo</code> 会先建立 <code>sudo</code> 进程，再建立后面的进程，不能保证容器应用的 <code>PID</code> = 1！</p></blockquote><p><strong>正确做法之一是下载并使用 <code>gosu</code></strong>，以 <code>redis</code> 镜像中用户设置和切换为例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户和用户组</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/gosu \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; gosu nobody <span class="literal">true</span></span></span><br><span class="line"><span class="comment"># 设置 CMD，并使用 gosu 换另外的用户传参（gosu 使用方法：gosu + user + cmd）</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>至于使用 <code>gosu</code> 而不是 <code>su/sudo</code> 的深层原因，我看有篇博客写的不错，如果感兴趣这方面的原理可以戳 <a href="https://www.cnblogs.com/gaoyuechen/p/14336078.html">这里🔗</a>；不过看懂英文的话，最好看 <code>gosu</code> 官方解释：<a href="https://github.com/tianon/gosu">github 传送门</a>；</p><p><strong>另一种正确方法比较方便，是使用 <code>chroot</code> 的 <code>--userspec</code> 参数</strong>：<code>chroot --userspec=&lt;userName&gt;</code>，可以完成相似效果；</p></li></ul><h5 id="HEALTHCHECK-指令：健壮性检查"><a href="#HEALTHCHECK-指令：健壮性检查" class="headerlink" title="HEALTHCHECK 指令：健壮性检查"></a><code>HEALTHCHECK</code> 指令：健壮性检查</h5><ul><li><p>语法：<code>HEALTHCHECK [OPTIONS] CMD &lt;HOST_COMMAND&gt;</code> 或 <code>HEALTHCHECK NONE</code>；</p><ul><li><strong><code>HEALTHCHECK</code> 和 <code>CMD</code>、<code>ENTRYPOINT</code> 一样，只可以出现一次，如果写了多个，只有最后一个生效</strong>；</li><li><code>[options]</code>：<code>--interval=&lt;带单位的数值&gt;</code>、<code>--timeout=&lt;...&gt;</code> 前面两个都默认 <code>30s</code>；<code>--retries=&lt;N&gt;</code> 默认 3 次，超过则认为不健康；</li><li><code>CMD &lt;...&gt;</code>：检查时由宿主机向容器内执行的指令，指令返回值代表本次检查是否成功：<code>0:成功, 1:失败, 2:放弃结果</code>；</li><li><code>NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令；</li></ul></li><li><p>它的作用：引用官方文档的话：</p><blockquote><p>在没有 <code>HEALTHCHECK</code> 指令前，Docker engine 只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入<strong>死锁</strong>状态，或者<strong>死循环</strong>状态，应用进程并不退出，但是该容器已经无法提供服务了。</p><p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而<strong>比较真实地反应</strong>容器实际状态。</p></blockquote></li><li><p>举个例子🌰：对于一个网络服务而言，如果需要检查 WEB 服务是否还有响应，那么可以这么写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5s --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1        <span class="comment"># 使用 curl 来判断</span></span></span><br></pre></td></tr></table></figure></li><li><p>健康检查的日志可以使用 <code>docker inspect --format &#39;&#123;&#123;json .State.Health&#125;&#125;&#39; &lt;containerName&gt;</code> 来查看（json 格式）；</p></li></ul><h5 id="ONBUILD-指令：多级构建准备"><a href="#ONBUILD-指令：多级构建准备" class="headerlink" title="ONBUILD 指令：多级构建准备"></a><code>ONBUILD</code> 指令：多级构建准备</h5><ul><li><p>语法：<code>ONBUILD &lt;所有其他指令&gt;</code>；</p></li><li><p>它的效果：它后面跟的是其它指令，而<strong>在当前镜像构建时并不会被执行</strong>。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行；</p></li><li><p>它的作用：<strong>提升镜像多级构建的重用性和扩展性</strong>；这句非常抽象，需要举例说明；首先说明<strong>什么是多级构建</strong>——利用已构建好的镜像为基础，构建下一级镜像（<strong>事实上所有镜像都是这么构建的，但多级构建更强调这几个镜像都是自己写出来的</strong>）</p><blockquote><p>以下的例子涉及 <code>node.js</code> 相关知识，只需了解 <code>node.js</code> 使用 <code>npm</code> 作为包管理器之一，相关包依赖和启动信息存在 <code>package.json</code> 中，可以类比成 <code>Python</code> 中的 <code>pip</code> 和 <code>requirements.txt</code>；部署项目时需要在根目录下执行 <code>npm install</code> 安装依赖，才能运行项目；</p></blockquote><p>🌰 假设我们在一个 <code>node.js</code> 项目中，目录情况如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|</span><br><span class="line">|--- Dockerfile</span><br><span class="line">|--- package.json</span><br><span class="line">|--- ...             # 其他项目文件</span><br></pre></td></tr></table></figure><p>因此 Dockerfile 应该这么写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app                <span class="comment"># 创建并以 /app 为工作目录</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./package.json /app    <span class="comment"># 将当前上下文目录下的 package.json 文件复制到镜像中的 /app/ 下</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]    <span class="comment"># 执行 sh -c npm install 安装项目依赖</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app/                <span class="comment"># 将当前上下文目录中(即客户端中的项目根目录)所有文件复制到 /app/ 下</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]        <span class="comment"># 设置容器默认启动命令为 npm start</span></span></span><br></pre></td></tr></table></figure><p>很好。那如果还有一个项目，<strong>项目文件不一样，但依赖的包和它一模一样</strong>，如果想要定制为镜像，应该怎么办？你可能会说，简单！把 Dockerfile 直接复制过去不就行了？好，那如果还有 5 个、10个呢？<strong>直接复制 Dockerfile 一定不现实，会给版本控制造成极大阻碍</strong>（例如，如果你想把这些所有项目的镜像基础 <code>node:slim</code> 换成 <code>node:alpine</code>，那你得一个个改）；</p><p>聪明的人会想，这也好办，直接把<strong>和项目无关的部分提出来</strong>——这样公共部分只要修改一次就行（<strong>这就是多级构建的思想</strong>，注意和后面的 <strong>多阶段构建区分</strong>）：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公共镜像的 Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>假设这个生成的镜像名叫 <code>my-node</code>，那么某一个用到这个镜像的项目的 Dockerfile 可以这么写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用到公共镜像的某个项目镜像的 Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> my-node</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br></pre></td></tr></table></figure><p>这么进行 “多级构建” 是没有问题的；但是，如果项目创建容器时，我想给<strong>每个项目的启动命令 <code>npm install</code> 都加个相同的参数呢</strong>？哦吼，完了，问题又回去了，是不是要一个个改呢……有些同学会说：那把 <code>RUN</code> 挪到公共镜像的 Dockerfile 中？不行。因为下面的 <code>COPY</code> 和 <code>RUN</code> 和项目有关，<strong>如果这样构建，某个项目的文件就进入公共镜像中，显然不符合重用的要求</strong>；</p><p>这个时候，应该用 <code>ONBUILD</code> 完成：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公共镜像的 Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>这样 <code>ONBUILD</code> 这几步在构建公共镜像时不会运行，而各个项目只需要写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br></pre></td></tr></table></figure><p><strong>这一句话就行！</strong>是不是非常方便！</p></li></ul><h5 id="LABEL-指令：添加镜像元数据-metadata"><a href="#LABEL-指令：添加镜像元数据-metadata" class="headerlink" title="LABEL 指令：添加镜像元数据 metadata"></a><code>LABEL</code> 指令：添加镜像元数据 metadata</h5><ul><li><p>一般是用来申明镜像的作者、文档地址等：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.authors=<span class="string">&quot;XXX&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.documentation=<span class="string">&quot;https://XXX&quot;</span></span></span><br></pre></td></tr></table></figure></li></ul><h5 id="SHELL-指令：指定命令行运行参数"><a href="#SHELL-指令：指定命令行运行参数" class="headerlink" title="SHELL 指令：指定命令行运行参数"></a><code>SHELL</code> 指令：指定命令行运行参数</h5><ul><li><p>语法：<code>SHELL [&quot;executable&quot;, &quot;params&quot;]</code></p></li><li><p>作用：用来指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell，Linux 中默认为 <code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-cex&quot;</span>]</span></span><br><span class="line"><span class="comment"># 命令转为 /bin/sh -cex &quot;nginx&quot;</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> nginx</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="很重要的网站"><a href="#很重要的网站" class="headerlink" title="很重要的网站"></a>很重要的网站</h5><ul><li><p><code>Docker</code> 官方镜像 <code>Dockerfile</code>：<a href="https://github.com/docker-library/docs">Dockerfile contents - github</a>；</p><p>在你不知道官方镜像的设计，或者想学习官方 Dockerfile 的用法时，这是极好的了解途径；</p></li></ul><h4 id="2-4-2-从容器快照定制"><a href="#2-4-2-从容器快照定制" class="headerlink" title="2.4.2 从容器快照定制"></a>2.4.2 从容器快照定制</h4><p><strong>见 3.4 容器的导入和导出</strong></p><h4 id="2-4-3-构建镜像"><a href="#2-4-3-构建镜像" class="headerlink" title="2.4.3 构建镜像"></a>2.4.3 构建镜像</h4><ul><li><p>语法：<code>docker build [options] &lt;contextPath&gt;</code></p></li><li><p><code>[options]</code> 中 <strong>最常用的是 <code>-t &lt;tagName&gt;</code>，给生成的镜像固定一个标签</strong>、<code>-f &lt;DockerfilePath&gt;</code> 指定 <code>Dockerfile</code>；</p></li><li><p><span id="contextPath"><code>&lt;contextPath&gt;</code> 指<strong>上下文路径</strong>，想要理解它，就需要理解部分 <code>docker build</code> 的工作原理</span>：</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="docker-on-linux.png" height="300"></p><ul><li><p>Docker <strong>采用 C/S 架构设计</strong>，在运行时分为 Docker Engine（也就是服务端守护进程 <code>containerd</code>）和客户端工具（图片最上面的 4 个）；</p></li><li><p>Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能；<strong>这种 C/S 分离式的设计，使得操作远程服务器的 docker engine 和本地一样轻松</strong>；</p></li><li><p>所以什么是上下文路径（contextPath）？</p><ol><li><p>构建镜像时，构建操作一定是在服务器端进行（C/S 架构），因此服务端会请求将 <strong><code>Dockerfile</code> 所在目录（这不是 contextPath，因为默认不用 <code>-f DockerfileName</code> 指定的，引擎默认是上下文目录下的 <code>Dockerfile</code>）下的</strong>所有文件打包，并从客户端传递给 <code>Docker Engine</code>；</p><blockquote><p>正因如此，① 应该将 <code>Dockerfile</code> 置于一个<strong>空目录</strong>下，或者<strong>项目根目录</strong>下；</p><p>② 如果该目录下没有所需文件，那么应该把所需文件<strong>复制一份过来</strong>；</p><p>③ 如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <strong><code>.dockerignore</code></strong>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的；</p></blockquote></li><li><p><strong>真正的 contextPath 是</strong>：<code>docker build</code> 指定<strong>要压缩给服务器的目录</strong>，<strong>并且从此以后，<code>Dockerfile</code> 中的所有的相对路径（如 <code>COPY</code> 等命令，也强烈建议是相对路径）的 “<code>.</code>” 都代表 <code>docker build</code> 中指定的上下文目录</strong>；</p></li></ol></li><li><p>举个两个栗子🌰🌰帮助理解上面内容：</p><ol><li><p>假设有一个项目结构是这样的，想要添加到 <code>nginx</code> 镜像中合成新的镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|</span><br><span class="line">|--- Dockerfile</span><br><span class="line">|--- .dockerignore</span><br><span class="line">|</span><br><span class="line">|--- index.html</span><br><span class="line">|--- webConfig        # nginx 配置文件</span><br></pre></td></tr></table></figure><p>由于 <code>Dockerfile</code> 恰在项目根目录下，因此可以这么写（这里只是演示什么是上下文目录，不建议这么做，建议使用<strong>数据卷或挂载主机目录</strong>）：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./index.html /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./webConfig /etc/nginx/site-avaliable/webConfig</span></span><br></pre></td></tr></table></figure><p>那么指令应该这么写：<code>docker build -t my_nginx:v1 .</code></p><p>这里：</p><p>① 无需指定 <code>Dockerfile</code>，是因为上下文目录恰好指定的是当前目录，该目录下又恰好有 <code>Dockerfile</code>，因此不用指定；</p><p>② <code>Dockerfile</code> 中 <code>COPY</code> 语句中的 “源目录(第一参数)” 中的 “<code>.</code>” 指的是 <strong>contextPath</strong>，也是在服务器端解压后的 “<code>.</code>”，<strong>而非客户端的“当前目录”</strong>；</p></li><li><p>再假设有一个项目结构是这样的，想以 <code>src/</code> 为整个项目打包进容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|</span><br><span class="line">|--- Dockerfile</span><br><span class="line">|--- .dockerignore</span><br><span class="line">|</span><br><span class="line">|--- src/</span><br><span class="line">        |--- index.html</span><br><span class="line">        |--- webConfig# nginx 配置文件</span><br></pre></td></tr></table></figure><p>那么如果 <code>Dockerfile</code> 这么写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./index.html /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./webConfig /etc/nginx/site-avaliable/webConfig</span></span><br></pre></td></tr></table></figure><p>则指令应该这么写：<code>docker build -f ./Dockerfile -t my_nginx:v1 ./src/</code></p><p>这里：</p><p>① <strong>指定了上下文路径是 <code>src/</code>，意味着只会给 docker engine 压缩打包这个目录，仅此而已</strong>；</p><p>② 在这个上下文目录（<code>src/</code>）中，没有 <code>Dockerfile</code>，因此需要指定 <code>Dockerfile</code> 在客户端的位置； <code>-f</code> 参数指定 <code>Dockerfile</code>，<strong>这个路径和 contextPath 无关，真的是客户端的路径</strong>；</p><p>③ 在 <code>Dockerfile</code> 中，<code>COPY</code> 的源路径（第一参数）中的 “<code>.</code>” 可以理解为的是在服务器端<strong>刚解压后的当前路径</strong>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. &lt;--- 它就是上下文路径在 Dockerfile 中表示的含义</span><br><span class="line">|</span><br><span class="line">|--- index.html</span><br><span class="line">|--- webConfig</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h4 id="2-4-4-多阶段构建"><a href="#2-4-4-多阶段构建" class="headerlink" title="2.4.4 多阶段构建"></a>2.4.4 多阶段构建</h4><ul><li><p><strong>多阶段构建和多级构建的对比：后者的目的是为了提升重用性，多写了几个镜像并依赖构建；前者是因为原本的镜像过于庞大，要拆解镜像层次，人为降低镜像的体积</strong>；前者一次只会一次构建出一个镜像，后者强调分步构建好几个镜像；</p></li><li><p>使用方法：<strong>就是一个 Dockerfile 文件中写好几个 <code>FROM</code></strong>，引入 <code>as</code> 关键字，使得外部可以通过 <code>docker build</code> 的 <code>--target</code> 参数<strong>指定构建的阶段</strong>；并且多阶段之间的镜像<strong>可以相互复制文件</strong>！</p><p>举个例子🌰：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest as prod</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是使用上一阶段(--from=0) “builder” 镜像的文件</span></span><br><span class="line"><span class="comment"># 0 是“上一个”的简写，还可以 --from=builder</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /go/src/github.com/go/helloworld/app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>也可以只构建 <code>builder</code>：<code>docker build --target builder -t XXX:XX .</code></p></li><li><p>⚠ <strong>当需要的容器服务过于多的时候，写 <code>Dockerfile</code> 变得很繁琐（例如一个镜像中同时需要 python、nginx、redis 服务等），建议使用 <code>docker compose</code>（见 Chapter 7）</strong>；</p></li></ul><h2 id="Chapter-3-操作容器"><a href="#Chapter-3-操作容器" class="headerlink" title="Chapter 3. 操作容器"></a>Chapter 3. 操作容器</h2><h3 id="3-1-创建和启动容器"><a href="#3-1-创建和启动容器" class="headerlink" title="3.1 创建和启动容器"></a>3.1 创建和启动容器</h3><h4 id="3-1-1-新建容器并启动"><a href="#3-1-1-新建容器并启动" class="headerlink" title="3.1.1 新建容器并启动"></a>3.1.1 新建容器并启动</h4><ul><li><p>语法：<code>docker run [options] &lt;IMAGE_NAME or ID&gt; [CMD]</code>；</p><ul><li><p><code>[options]</code>：① <code>-i</code> 启动容器内 bash 并绑定于 stdin 允许交互；</p><p>② <code>-t</code> 分配伪终端（显示命令提示符，<strong>常和 <code>-i</code> 联用将容器 I/O 绑定在当前 TTY 上：<code>-it</code></strong>）；</p><blockquote><p>如果使用 <code>-i</code> 参数，<code>[CMD]</code> 为必须项，且一般填写 <code>/bin/bash</code> 或 sh；</p></blockquote><p>③ <code>-d</code> 拒绝和当前终端连接（detach，在启动容器后不与当前 TTY 关联，与 <code>-it</code> 互斥，此时 <strong>stdout 的内容可以使用 <code>docker container logs</code> 查看</strong>）；</p><p>④ <code>-p &lt;host_port:container_port&gt;</code> 将容器指定端口映射到主机指定端口；</p><p>⑤ <code>-P</code> 将容器端口开放到 <code>Host OS</code> 的随机端口；</p><p>⑥ <code>-v &lt;host_dir:container_dir&gt;</code> 将主机指定目录作为<strong>数据卷</strong>挂载到容器指定目录上，<strong>不会覆盖</strong> Dockerfile 中的 <code>VOLUME</code> 指令。因为如果有 <code>VOLUME</code> 指令，那么在构建镜像时匿名卷已被创建；（<strong>详细见 Chapter 5</strong>）</p><p>⑦ <code>--name &lt;containerName&gt;</code> 为容器命名，<strong>在容器互联、集群时非常重要</strong>；</p><p>⑧ <code>--network</code> 参数见 <strong>6.2 容器互联</strong>；</p></li><li><p><code>[CMD]</code>：<strong>会覆盖 Dockerfile 中的 <code>CMD</code> 指令</strong>；</p></li></ul></li><li><p>运行该命令后 docker engine 在干什么：</p><ol><li>检查本地是否存在指定的镜像，不存在就从 Docker Registory 下载；</li><li>利用镜像创建并启动一个容器；</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层；</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去；</li><li>从地址池配置一个 ip 地址给容器；</li><li>执行用户指定的应用程序；</li><li>执行完毕后容器被终止；</li></ol></li></ul><h4 id="3-1-2-启动已终止的容器"><a href="#3-1-2-启动已终止的容器" class="headerlink" title="3.1.2 启动已终止的容器"></a>3.1.2 启动已终止的容器</h4><p>就一句：<code>docker container start &lt;ID&gt;</code>（如果容器没有exit，应该用 <code>restart</code>）；</p><h3 id="3-2-终止容器"><a href="#3-2-终止容器" class="headerlink" title="3.2 终止容器"></a>3.2 终止容器</h3><p>也就一句：<code>docker container stop &lt;ID&gt;</code>；</p><p>此外，查看所有<strong>正在运行的</strong>容器：<code>docker container ls</code>；</p><p>⚠ <strong>处于终止状态的容器需要在后面加 <code>-a</code> 参数：<code>docker container ls -a</code></strong>；</p><h3 id="3-3-进入容器"><a href="#3-3-进入容器" class="headerlink" title="3.3 进入容器"></a>3.3 进入容器</h3><p>本质上就是在容器中创建一个 bash 程序，并把 I/O 绑定到当前 TTY 上。总共两种方法：</p><ul><li><code>docker attach &lt;ID&gt;</code>，不建议使用，因为执行 <code>exit</code> 退出这个 bash 后，会给整个容器发送 SIGABRT 信号，导致终止；</li><li><code>docker exec -it &lt;ID&gt; bash</code>：使用 <code>exit</code> 退出 bash 不影响原来容器；显然 <code>docker exec</code> 不止可以进入容器，还能干其他事（把 <code>-it</code> 去掉，最后一个参数换成要运行的命令等等，详细内容请参阅官方文档，或者运行 <code>docker exec --help</code>）；</li></ul><h3 id="3-4-导入和导出"><a href="#3-4-导入和导出" class="headerlink" title="3.4 导入和导出"></a>3.4 导入和导出</h3><ul><li><p>将容器保存为快照（<strong>这会丢弃容器的元数据</strong>）：<code>docker export &lt;ID&gt; &gt; compressFile.tar</code>；</p></li><li><p>将<strong>容器快照展开为镜像</strong>（这是镜像的另一种创建方式：<strong>从容器创建</strong>）：<code>cat compressFile.tar | docker import - &lt;REPO_NAME&gt;</code></p><blockquote><p>复习一下，<code>REPO_NAME</code> = <code>userName/IMAGE_NAME:tag</code>；</p></blockquote><p>除了管道流方法以外，还可以从指定地址展开镜像：<code>docker import http://example.com/exampleimage.tgz example/imagerepo</code>；</p></li></ul><h3 id="3-5-删除容器"><a href="#3-5-删除容器" class="headerlink" title="3.5 删除容器"></a>3.5 删除容器</h3><ul><li><p>删除<strong>处于终止状态的</strong>容器：<code>docker container rm &lt;ID&gt;</code>；</p><ul><li>如果需要删除任何状态的容器（包括正在运行的），则需添加 <code>-f</code> 参数，这会给正在运行的容器先发送 <code>SIGKILL</code> 信号；</li><li>如果实在需要在停止容器的同时删除挂载的数据卷：添加 <code>-v</code> 参数；</li></ul></li><li><p>清除<strong>所有</strong>处于终止状态的容器：<code>docker container prune</code> </p><blockquote><p>复习一下：清除所有虚悬镜像：<code>docker image prune</code></p></blockquote></li></ul><h2 id="Chapter-4-访问仓库"><a href="#Chapter-4-访问仓库" class="headerlink" title="Chapter 4. 访问仓库"></a>Chapter 4. 访问仓库</h2><h3 id="4-1-Docker-Hub"><a href="#4-1-Docker-Hub" class="headerlink" title="4.1 Docker Hub"></a>4.1 Docker Hub</h3><ul><li><p>登录/登出 docker 账户：<code>docker login/logout</code>；</p></li><li><p>查找相关镜像：<code>docker search [--filter=starts=N] &lt;...&gt;</code>（里面示例筛选器是筛选 N 星以上的镜像）；</p></li><li><p>推送镜像到自己账户的公共仓库中（需登录）：<code>docker push &lt;userName/IMGAE_NAME:tag&gt;</code>；</p><blockquote><p>提示：<strong>目前自动构建（Automated build）仅支持付费用户</strong>，没钱没用过，不讨论；</p></blockquote></li></ul><h3 id="4-2-私有仓库管理"><a href="#4-2-私有仓库管理" class="headerlink" title="4.2 私有仓库管理"></a>4.2 私有仓库管理</h3><p><code>docker-registry</code> 相关命令，平时没啥人用，不作介绍；</p><h2 id="Chapter-5-数据管理"><a href="#Chapter-5-数据管理" class="headerlink" title="Chapter 5. 数据管理"></a>Chapter 5. 数据管理</h2><h3 id="5-1-数据卷"><a href="#5-1-数据卷" class="headerlink" title="5.1 数据卷"></a>5.1 数据卷</h3><p>在之前已经无数次接触到数据卷的概念，现在详细说明数据卷的概念和使用；</p><ul><li><p>概念和特征：是一个可供一个或多个容器使用的特殊目录，<strong>可以理解为 Linux 下对目录或文件进行 <code>mount</code></strong>；</p><ul><li><p>数据卷可以<strong>在容器之间共享和重用</strong>；</p></li><li><p>对数据卷的修改会立马生效；但对数据卷的更新，不会影响镜像（挂载的特征）；</p></li><li><p>数据卷默认会一直存在，即使容器被删除（<strong>没有自动回收机制，独立于容器，需要手动删除</strong>）</p><blockquote><p>数据无价，谨慎删除；</p></blockquote></li><li><p><strong>匿名卷也是一个数据卷</strong>；</p></li></ul></li><li><p>管理数据卷：docker 支持在没有启动容器时，手动对数据卷进行管理；</p><ul><li><p>查看所有数据卷：<code>docker volume ls</code>；</p></li><li><p>查看特定数据卷详细信息：<code>docker volume inspect &lt;volumeName&gt;</code>；</p></li><li><p>创建数据卷：<code>docker volume create &lt;volumeName&gt;</code>；</p><blockquote><p>和匿名卷一样，默认挂载于 <code>/var/lib/docker/containers/</code> 中；</p></blockquote></li><li><p>启动一个挂载指定数据卷的容器：3.1.1 介绍过，<code>-v</code> 参数，<strong>等价于：<code>--mount source=&lt;volumeName&gt;,target=&lt;containerPath&gt;</code></strong>；</p></li><li><p>手动删除数据卷：<code>docker volume rm &lt;volumeName&gt;</code>；</p></li><li><p>清理<strong>没有被当前容器使用的</strong>数据卷：<code>docker volume prune</code>；</p></li></ul></li></ul><h3 id="5-2-挂载主机目录"><a href="#5-2-挂载主机目录" class="headerlink" title="5.2 挂载主机目录"></a>5.2 挂载主机目录</h3><ul><li><p>和数据卷比较：挂载主机目录和挂载数据卷极其类似，不过前者是自定义位置，后者默认和匿名卷都放在一起；</p></li><li><p>使用：<code>docker run</code> 的 <code>-v</code> 参数，<strong>如果 Host OS 中没有指定目录，会自动创建</strong>；</p><p>或者：<code>docker run</code> 的 <code>--mount type=bind,source=&lt;dir&gt;,target=&lt;cDir&gt;</code> ，如果本地目录不存在，则报错；</p><p><strong>也可以仅赋予只读权限：<code>--mount type=bind,source=&lt;dir&gt;,target=&lt;cDir&gt;,readonly</code></strong>；</p></li><li><p><strong>甚至可以只挂载一个主机文件</strong>；</p></li></ul><h2 id="Chapter-6-网络配置"><a href="#Chapter-6-网络配置" class="headerlink" title="Chapter 6. 网络配置"></a>Chapter 6. 网络配置</h2><h3 id="6-1-外部访问"><a href="#6-1-外部访问" class="headerlink" title="6.1 外部访问"></a>6.1 外部访问</h3><p>绝大部分内容已在 3.1.1 启动容器时介绍，这里仅介绍一些高级用法；</p><ul><li><p><code>-p</code> 参数可以多次使用来绑定多个端口：<code>docker run -d -p 80:80 -p 443:443 nginx:alpine</code></p></li><li><p><code>-P</code> 参数的 “随机” 是针对 Host OS 的端口随机分配，一般会按照 Dockerfile 中的 <code>EXPOSE</code> 分配指定的容器内部端口；</p><blockquote><p>等价于在 <code>docker run</code> 中加入参数：<code>-p 127.0.0.1::&lt;EXPOSE_port&gt;</code></p></blockquote></li></ul><h3 id="6-2-容器互联"><a href="#6-2-容器互联" class="headerlink" title="6.2 容器互联"></a>6.2 容器互联</h3><p>以前会使用<code>docker run</code> 的 <code>--link</code> 参数，进行点对点的连接；但随着结点数的增大，这么做不容于配置；正确做法是<strong>自行配置容器间的网络</strong>；</p><ul><li><p>新建容器网络：<code>docker network create -d bridge &lt;netName&gt;</code></p><blockquote><p><code>-d</code> 参数指定网络类型，参数值有 <code>bridge</code>（网桥） 和 <code>overlay</code>，前者用的多，后者需要配合 <code>swarm mode</code> 配置集群，暂时不介绍；</p></blockquote></li><li><p>运行容器同时将容器连接到网络：<code>docker run</code> 的 <code>--network &lt;netName&gt;</code> </p><blockquote><p>注意：如果要容器连接网络，强烈建议自己为<strong>容器命名</strong>：<code>--name</code> 参数，因为容器间交互识别就靠容器名——<strong>在一个容器中可以访问同网络的另一个容器：<code>ping &lt;containerName&gt;</code></strong>；</p></blockquote></li></ul><p><strong>其实更方便的做法是：使用 <code>Docker compose</code>（Chapter 7）</strong>；</p><h3 id="6-3-DNS-配置"><a href="#6-3-DNS-配置" class="headerlink" title="6.3 DNS 配置"></a>6.3 DNS 配置</h3><p>这个操作在特殊场合有用（因为一般默认容器中的 DNS 设置就够用了），比如某些同学想用 <code>Grasscutter</code> 建立 Ys 私服的时候，包装成 Docker 镜像时就需要将一系列网络代理到本机上——如果使用 DNS 劫持的方法就需要在容器内配置 DNS；</p><p>最方便的方法是构建镜像时自己写一个 <code>HOST</code> 文件在放到<code>/etc/hosts</code>；</p><p>当然，也可以通过 <code>docker run</code> 的 <code>-h HOSTNAME</code> 写入 <code>/etc/hosts</code> 和 <code>/etc/hostname</code> ，还可以通过 <code>docker run</code> 的 <code>--dns=IP_ADDR</code> 写入 DNS 服务器地址（在 <code>/etc/resolv.conf</code>）；</p><p>还可以通过修改主机 <code>/etc/docker/daemon.json</code> 来<strong>同时修改所有容器的 DNS 服务器</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Chapter-7-Docker-Compose"><a href="#Chapter-7-Docker-Compose" class="headerlink" title="Chapter 7. Docker Compose"></a>Chapter 7. Docker Compose</h2><h3 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h3><ul><li><p>地位：由 <code>Python</code> 编写的 Docker 官方的开源项目；</p></li><li><p>定位：定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）；</p></li><li><p>作用：允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project），<strong>很方便地实现容器运行设置、互联</strong>；</p></li><li><p><strong>两个重要概念</strong>：服务和项目</p><ul><li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例；</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义；</li></ul><blockquote><p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理；</p></blockquote></li><li><p>和 docker 普通用法的比较【重要】：docker compose <strong>不在于构建镜像</strong>，而在于<strong>直接一条龙拉取已有镜像/按 <code>Dockerfile</code> 构建自定义镜像（前面章节的内容），并按配置运行<u>一组</u>容器</strong>；</p></li><li><p><strong>举例认识</strong>🌰：假设有一个项目，使用 <code>Python</code> 建立一个记录页面访问次数的 Web 服务，使用 <code>Flask</code> 框架、<code>redis</code> 服务器；</p><blockquote><p>（本部分无需看懂，只需要感受 <code>docker compose</code> 使用便捷就行）</p><p><strong>如果使用 docker 原来的方法，编写 <code>Dockerfile</code> 来构建容器，那么需要作很多事</strong>：从一个 Python 镜像中开始构建、安装 flask、安装 redis、复制项目文件、删除安装的 apt 缓存和安装包等文件，运行 <code>docker run</code> 还要加各种参数，例如挂载、端口、网络互联……</p><p>但如果使用 <code>docker compose</code> 就不一样了：</p></blockquote><p>编写模板文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File: docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span>        <span class="comment"># 容器内的所有服务</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span>            <span class="comment"># web 服务</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span>    <span class="comment"># 镜像构建方法是当前页面的自定义镜像：./Dockerfile</span></span><br><span class="line">    <span class="attr">ports:</span>        <span class="comment"># 运行该 web 服务的容器时，进行端口映射，相当于 docker run 的 -p</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span>        <span class="comment"># redis 服务</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span>    <span class="comment"># 镜像构建方法是直接从 redis:alpine 拉取</span></span><br></pre></td></tr></table></figure><p>编写 web 服务的镜像构建 Dockerfile（python + flask + 项目文件）：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install redis flask</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>最后直接运行：<code>docker compose up -d</code> ，结束！</p></li></ul><h3 id="7-2-安装"><a href="#7-2-安装" class="headerlink" title="7.2 安装"></a>7.2 安装</h3><blockquote><p>需要已经安装 Docker 及其服务；</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_CONFIG=/usr/local/lib/docker/cli-plugins</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p <span class="variable">$DOCKER_CONFIG</span>/cli-plugins</span><br><span class="line"><span class="comment"># 国内加速：</span></span><br><span class="line"><span class="comment"># sudo curl -SL https://download.fastgit.org/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose</span></span><br><span class="line">sudo curl -SL https://github.com/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 -o <span class="variable">$DOCKER_CONFIG</span>/cli-plugins/docker-compose</span><br><span class="line">sudo <span class="built_in">chmod</span> +x <span class="variable">$DOCKER_CONFIG</span>/cli-plugins</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="7-3-compose-命令"><a href="#7-3-compose-命令" class="headerlink" title="7.3 compose 命令"></a>7.3 compose 命令</h3><blockquote><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响；</p></blockquote><p>语法：<code>docker compose [options] [compose-command]</code>；</p><h4 id="options-参数"><a href="#options-参数" class="headerlink" title="[options] 参数"></a>[options] 参数</h4><ul><li><code>-f template</code> 指定 docker compose 模板，默认 <code>docker-compose.yml</code>；</li><li><code>-p Name</code> 指定项目名称；</li><li><code>--verbose</code> 运行时调试信息更详细；</li></ul><h4 id="compose-command-命令"><a href="#compose-command-命令" class="headerlink" title="[compose-command] 命令"></a>[compose-command] 命令</h4><h5 id="构建-amp-运行命令"><a href="#构建-amp-运行命令" class="headerlink" title="构建&amp;运行命令"></a>构建&amp;运行命令</h5><ul><li><p><code>pull</code>：拉取模板中的基础镜像；</p></li><li><p><code>build [options]</code>：按模板构建项目中的所有镜像并组合为容器；</p><ul><li><code>--force-rm</code>：删除构建过程中产生的临时镜像；</li><li><code>--no-cache</code>： 不使用缓存构建；</li></ul></li><li><code>start [serviceName]</code>：启动<strong>已存在的指定服务容器</strong>；</li><li><code>restart [-t TIMEOUT]</code>：重启项目中的服务；<ul><li><code>-t TIMEOUT</code>：重启前停止容器；</li></ul></li><li><code>run [options] &lt;serviceName&gt; [CMD]</code>：手动<strong>按 <code>docker run</code> 一样的参数</strong>启动指定容器，用的少，因为不如在 <code>docker-compose</code> 里设置并且 <code>up</code>  启动；</li><li><strong><code>up [options]</code>：强大的命令，可以一次性实现上述所有命令（构建镜像、（重新）创建服务、启动服务，并关联服务相关容器）</strong>；<ul><li><code>-d</code>（detach）：后台运行；</li><li>其他选项和上面的前 4 条命令一样；</li></ul></li></ul><h5 id="停止-amp-管理命令"><a href="#停止-amp-管理命令" class="headerlink" title="停止&amp;管理命令"></a>停止&amp;管理命令</h5><ul><li><code>down</code>：停止 <code>up</code> 所启动的容器，同时移除网络；</li><li><code>stop [serviceName]</code>：仅停止指定服务容器，不删除任何东西，可以通过 <code>start</code> 再启动；</li><li><code>kill [-s SIGNAL] [serviceName]</code>：通过 <code>-s</code> 传递终止信号结束服务容器 ；</li><li><code>pause/unpause [serviceName]</code>：暂停指定服务容器 / 恢复被暂停的服务容器；</li><li><code>rm [options] [serviceName]</code>：删除所有处于停止状态的服务容器，options 参数和 docker 一样；</li><li><code>exec [options]</code>：进入指定容器，参数和 docker 一样；</li></ul><h5 id="维护命令"><a href="#维护命令" class="headerlink" title="维护命令"></a>维护命令</h5><ul><li><code>images</code>：列出模板中所含的所有镜像；</li><li><code>ps</code>：列出项目中<strong>当前所有容器</strong>；</li><li><code>top</code>：查看<strong>各服务容器里运行的进程</strong>（这样就不用在容器里装 <code>procps</code> 包了）；</li><li><code>logs [serviceName]</code>：查看某个服务容器的 stdout 输出，对调试有用；</li><li><code>version</code>：版本信息；</li><li><code>help</code>：帮助；</li></ul><h3 id="7-4-docker-compose-模板"><a href="#7-4-docker-compose-模板" class="headerlink" title="7.4 docker-compose 模板"></a>7.4 docker-compose 模板</h3><p>和 7.1 里说的一样，<code>docker-compose.yml</code> 同时完成指定构建什么镜像（自己不会设计镜像）和 <code>docker run</code> 的工作，所有<strong>可以将下面的选项和前几章的指令一一对照</strong>； </p><p>下面直接在文件中说明：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span>    <span class="comment"># 指定一个版本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span>        <span class="comment"># 必不可缺的部分，是容器运行的核心——服务</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">webApp:</span><span class="comment"># 服务名，可以自己取，代表容器的其中一个服务。</span></span><br><span class="line">                <span class="comment"># 注意，每个服务都可以指定一个构建镜像</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&lt;XX/XX&gt;</span><span class="comment"># image 和 build 选项二选一（必选，因为容器必须要从镜像开始）</span></span><br><span class="line">        <span class="attr">build:</span> <span class="string">&lt;dir&gt;</span><span class="comment"># image 指这个容器从已存在的镜像构建，值是 REPO_NAME</span></span><br><span class="line">                        <span class="comment"># build 指这个容器将自行构建镜像，值是上下文目录（必须包含 Dockerfile）</span></span><br><span class="line">        <span class="attr">build:</span><span class="comment"># 但如果上下文目录和 Dockerfile 不在一起，请详细指定，如左</span></span><br><span class="line">            <span class="attr">context:</span> <span class="string">&lt;dir&gt;</span></span><br><span class="line">            <span class="attr">dockerfile:</span> <span class="string">&lt;path&gt;</span></span><br><span class="line">            <span class="attr">args:</span></span><br><span class="line">                <span class="comment"># 这里相当于 docker build 的参数，不过不能缩写，没有“--”</span></span><br><span class="line">                </span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">&lt;name&gt;</span><span class="comment"># 谨慎使用，会降低模板文件的扩展性，因为容器名唯一</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">command:</span> <span class="string">&lt;CMD&gt;</span><span class="comment"># 这里覆盖 Dockerfile 里的 CMD 指令 或者是默认的 CMD 指令</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">devices:</span><span class="comment"># 这里在 Dockerfile 中没讲过，可以映射硬件设备</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;/dev/&lt;host_device&gt;:/dev/&lt;container_device&gt;&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">depends_on:</span><span class="comment"># 这里可以解决依赖问题，会先启动依赖服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;serviceName&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">dns:</span><span class="comment"># DNS 服务器，对应 docker run 的 --dns 参数</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;IP_ADDR&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">tmpfs:</span><span class="comment"># 对应 Dockerfile 中的 VOLUME 指令</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;dir&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">env_file:</span><span class="comment"># 对应 Dockerfile 的 ENV 指令</span></span><br><span class="line">                        <span class="comment"># 通过文件载入环境变量，环境变量文件规范如下：</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;ENV_file&gt;</span><span class="comment"># 以 “#” 作行注释、后缀名 *.env</span></span><br><span class="line">                            <span class="comment"># 内容 “key=value” 顶格、中间不能有空格</span></span><br><span class="line">                            <span class="comment"># 有表达特殊含义的 value 必须用引号引起，特殊词包括：</span></span><br><span class="line">                            <span class="comment">#  y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</span></span><br><span class="line">        <span class="attr">environment:</span><span class="comment"># 环境变量少可以这么用，多的话建议用上面的 env_file</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">key=value</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">expose:</span><span class="comment"># 对应 Dockerfile 的 EXPOSE 指令</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;&lt;port&gt;&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">ports:</span><span class="comment"># 对应 docker run 的 -p 参数</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;&lt;host_port&gt;:&lt;container_port&gt;&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">extra_hosts:</span><span class="comment"># 对应 docker run 的 -h 参数，可以进行 DNS 劫持</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;domain:IP&quot;</span><span class="comment"># 会在 /etc/hosts 文件中添加：&quot;IP domain&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">healthcheck:</span><span class="comment"># 对应 Dockerfile 的 HEALTHCHECK 指令</span></span><br><span class="line">            <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;&lt;COMMAND&gt;&quot;</span>]</span><br><span class="line">            <span class="attr">interval:</span> <span class="string">&lt;time&gt;</span></span><br><span class="line">            <span class="attr">timeout:</span> <span class="string">&lt;time&gt;</span></span><br><span class="line">            <span class="attr">retries:</span> <span class="string">N</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">labels:</span><span class="comment"># 对应 Dockerfile 的 LABEL 指令</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">value</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">user:</span> <span class="string">&lt;name&gt;</span><span class="comment"># 对应 Dockerfile 的 USER 指令</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">working_dir:</span> <span class="string">&lt;dir&gt;</span><span class="comment"># 对应 Dockerfile 的 WORKDIR 指令</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">entrypoint:</span> <span class="string">&lt;COMMAND&gt;</span> <span class="comment"># 对应 Dockerfile 的 ENTRYPOINT 指令</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">restart:</span> <span class="string">&lt;options&gt;</span><span class="comment"># 指定容器退出后的重启策略</span></span><br><span class="line">                            <span class="comment"># 相当有用的选项，对保持服务始终运行十分有效</span></span><br><span class="line">                            <span class="comment"># 在生产环境中推荐配置为 always 或者 unless-stopped</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">logging:</span>    <span class="comment"># 设置容器输出日志</span></span><br><span class="line">            <span class="attr">driver:</span> <span class="string">&lt;&quot;json-file&quot;/&quot;syslog&quot;/&quot;none&quot;&gt;</span><span class="comment"># 写成 json 还是和系统一致</span></span><br><span class="line">            <span class="attr">options:</span><span class="comment"># 日志轮替选项</span></span><br><span class="line">                <span class="attr">max-size:</span> <span class="string">&quot;Nk&quot;</span> <span class="comment"># 或 &quot;Nm&quot;</span></span><br><span class="line">                <span class="attr">max-file:</span> <span class="string">N</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 如此还可以写下一个服务……</span></span><br></pre></td></tr></table></figure><p>还有<strong>两个重要选项 和 一个重要的行为</strong>需要单独拎出来说：</p><p><strong>① <code>volumes</code> 挂载选项</strong>：对应 Dockerfile 的 <code>VOLUME</code> 指令，用法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="string">&lt;serviceName&gt;:</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;host_dir&gt;:&lt;container_dir&gt;</span><span class="comment"># 对应 docker run 本机目录挂载（可选）</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;volumName&gt;:&lt;container_dir&gt;</span><span class="comment"># 对应 docker run 数据卷挂载（可选）</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 如果上面使用了数据卷名（volumnName），那么需要声明创建一个数据卷：</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">    <span class="string">&lt;volumeName&gt;:</span><span class="comment"># 和匿名卷放在一个位置，不用给它值</span></span><br></pre></td></tr></table></figure><p><strong>② <code>networks</code> 网络选项</strong>：对应 docker run 的 <code>--network</code> 参数，用法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="string">&lt;serviceName&gt;:</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">networks:</span><span class="comment"># 容器加入某个指定网络，可以同时加入多个网络</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;netName&gt;</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 上面使用了 networks 就必须指定网络名称</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="string">&lt;netName1&gt;:</span><span class="comment"># 如果名字是 default，设置默认网络，一般不用设置</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">&lt;bridge/overlays&gt;</span><span class="comment"># 对应 docker network create 的 -d 参数</span></span><br><span class="line">        </span><br><span class="line">    <span class="string">&lt;netName2&gt;:</span></span><br><span class="line">        <span class="attr">external:</span><span class="comment"># 如果不希望 docker compose 创建网络，想自己 docker network create，那么引入外部设置网络需要 external 选项</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">&lt;external_netName&gt;</span></span><br></pre></td></tr></table></figure><p>⚠ <strong>重要行为：<code>docker-compose.yml</code> 读取环境变量</strong></p><p>如果在模板文件中使用 <code>$&#123;XXX&#125;</code> 的变量，模板会先搜索<strong>系统环境变量</strong>，再搜索<strong>之前设置的 <code>env_files/environment</code> 选项</strong>；</p><hr><p>docker 入门基础篇完【EOF】</p><p>预计将会跟进 docker 底层实现分析、<code>Kubernetes</code> 集群 等内容；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference：&lt;/i&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;Docker 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Docker" scheme="https://sjtuxhw.top/tags/Docker/"/>
    
    <category term="Container" scheme="https://sjtuxhw.top/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>SQL学习笔记-第一部分</title>
    <link href="https://sjtuxhw.top/2023/06/28/SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <id>https://sjtuxhw.top/2023/06/28/SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</id>
    <published>2023-06-28T13:35:08.000Z</published>
    <updated>2023-09-19T05:12:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>本部分文章是 SQL 的基础部分，纪念我丢掉的 SQL 笔记</i> 😭</p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p>Reference: 《 <a href="https://forta.com/books/0135182794/">SQL 必知必会 (第 5 版 )</a> 》</p><hr><h1 id="使用前须知"><a href="#使用前须知" class="headerlink" title="使用前须知"></a>使用前须知</h1><p>本系列文章的 “章末习题” 使用的数据库和表的关系如下图所示；</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="./sample_tables.jpg"></p><p>这里提供创建表和数据的 SQL 文本（以 MySQL 为例）：<a href="./generate.sql">generate.sql</a>，可以在搭建好 MySQL 环境后直接导入它，以备后面章末习题使用；</p><h1 id="Chapter-0-数据库的基本概念"><a href="#Chapter-0-数据库的基本概念" class="headerlink" title="Chapter 0 数据库的基本概念"></a>Chapter 0 数据库的基本概念</h1><ul><li><p>数据库（从 SQL 角度看）：<strong>以某种有组织的方式存储的数据集合</strong>；</p></li><li><p>关系型数据库 &amp; 非关系型数据库</p><ul><li>关系型数据库：采用关系模型、遵循关系代数模式来组织数据的数据库（例如 MySQL、PostgreSQL等）；<strong>关系模型类似二维表，允许表间数据相互关联，支持多表查询</strong>；</li><li>非关系型数据库（No SQL）：不依赖关系模型的、分布式的数据库（例如 MongoDB、Redis 等）；<strong>以键值来存储，结构不稳定，每个元组的字段可以不相同，可以面向高并发key-value读写 / 面向文档</strong>；</li></ul><div style="text-align: center;">表一 关系型数据库 &amp; 非关系型数据库比</div><table>    <tr>        <td>项目</td>        <td>RDB</td>        <td>NOSQL(Not Only SQL)</td>    </tr>    <tr>        <td>是否依赖关系模型</td>        <td>是，二维表容易理解</td>        <td>否，key-value 存储较为零散</td>    </tr>    <tr>        <td>是否有通用的 SQL</td>        <td>有，使用方便</td>        <td>无，无法提供WHERE字段查询</td>    </tr>    <tr>        <td>事务的一致性</td>        <td>强，ACID属性易于维护</td>        <td>弱，适宜面向网络/文档/高并发读写等场景</td>    </tr>    <tr>        <td>拓展能力</td>        <td>纵向，依赖处理能力提升</td>        <td>横向，天然分布式</td>    </tr>    <tr>        <td>存储数据</td>        <td>适宜结构化数据，例如账户、地址</td>        <td>适宜非结构化数据，例如文章、评论</td>    </tr></table></li></ul><p>  注：一般生产环境会使用 <code>RDB + NoSQL</code> 组合方案，互相取长补短；</p><p>  ⚠ <strong>本文章仅讨论关系型数据库中的 标准 SQL</strong>；</p><ul><li><p>数据库管理系统（DBMS）：俗称数据库管理系统；<strong>数据库是通过 DBMS 创建和操纵的容器</strong>；</p><blockquote><p>MySQL、mariaDB、mongoDB、SQLite 等等都是 DBMS，而它们创建的数据库才是真正的 “数据库”；</p></blockquote></li><li><p>表（table）：某种特定类型数据的结构化清单；</p><blockquote><p><strong>根据定义，可以理解为：在数据库（相当于文件柜）中，存放文件需要放在特定的档案中，这个“文件柜”中的“档案”就是表；</strong></p><p><strong>表存储的是同一种类型的数据或清单，<u>便于归类和查找</u></strong></p></blockquote></li><li><p>表名：表的唯一标识符（ID），在一个数据库中唯一，但不同数据库的表之间名字可以相同；</p></li><li><p>模式（schema）：关于数据库和表的布局及特性的信息；</p><blockquote><p><strong>描述数据库中特定的表，或者描述整个数据库及表的关系</strong>；</p><p>包括：储存什么数据？数据如何分解（parse）？各部分信息如何命名？……</p></blockquote></li><li><p>列（column）：表中的一个字段，存储表的某一个部分/领域（field）的信息；</p><blockquote><p><strong>所有表都是由一个或多个列组成</strong>；</p><p><strong>正确地按需求对数据列分解对于分类、过滤意义重大</strong>；例如，将国家和省市信息组合在一个列中，那么仅按省市查找的难度就比 “国家、省市信息分开在两列中” 的情况更大；</p></blockquote></li><li><p>数据类型：每一列需要有相应的数据类型，限制该列存储的数据（以方便分类和查找）；</p><blockquote><p>对表的各列设计数据类型也是重要的：正确地设计数据类型不仅可以帮助正确分类和查找，还可以优化磁盘容量；</p></blockquote><p>⚠ <strong>因为有些 DBMS 中同一个数据类型的名称不一样（数据类型兼容问题），即便名称相同，定义可能不一样，所以应该总是查阅文档、学习和应用时需要注意</strong>；</p></li><li><p>行：表中的一个记录（从技术上说，行才是正确的术语）；</p></li><li><p>主键（primary key）：表中的每一行都<u>应该</u>有一列（或几列）可以<strong>唯一标识自己（ID）</strong>；</p><blockquote><p><strong>没有主键，更新、删除数据库表的特定行就极其困难，不能保证没有误操作</strong>；</p><p>所以规范来说，表应该总是定义主键；</p></blockquote><p><strong>主键的要求</strong>：</p><ol><li><strong>互异性</strong>：表的任意两行都不具有相同主键值；</li><li><strong>非空性</strong>：每一行必须具有一个主键值（不允许为 NULL 空值）；</li><li><strong>固定性</strong>：主键列中的值不允许修改和更新；</li><li><strong>不可重用性</strong>：如果表的一行从表中被删除，那么它的主键不能赋给以后的新行；</li></ol></li><li><p>SQL：<code>Structured Query Language</code>，结构化查询语言（专门用来与数据库沟通的语言）；</p><ol><li>不是某个数据库厂商、某类 DBMS 特有的语言；</li><li>关键字数量极少，但功能强大；</li></ol><blockquote><p>本文章不考虑某些 DBMS 的 SQL 扩展（某个厂商独有、独自开发的），仅讨论标准 SQL（ANSI SQL）；</p></blockquote></li><li><p>SQL 的关键字：作为 SQL 组成部分的保留字，不能用作表 / 列的名字；会在以后章节中逐渐提及；</p></li><li><p>SQL 语言注意事项</p><ol><li><p>SQL 语句的结束：以分号结尾；</p></li><li><p>SQL 语句不区分大小写，但习惯上约定俗成：关键字大写、列/表名小写；</p></li><li><p>在一个 SQL 语句未结束时，可以在两个词间添加换行，不会有影响，一般是方便阅读；</p></li><li><p>SQL 语言的索引<strong>从0开始</strong>，因此也是一种 <strong>0-index 语言</strong>；</p></li><li><p>注释方式：行内注释 <code>--</code>（后面跟一个空格）、单行注释 <code>#</code> （某些 DBMS 不支持）、多行注释 <code>/* [contents] */</code>；</p><blockquote><p>好习惯：和 其他所有编程语言一样，必要时多加注释；</p></blockquote></li></ol></li></ul><h1 id="Chapter-1-数据检索"><a href="#Chapter-1-数据检索" class="headerlink" title="Chapter 1 数据检索"></a>Chapter 1 数据检索</h1><h2 id="1-1-SELECT-语句"><a href="#1-1-SELECT-语句" class="headerlink" title="1.1 SELECT 语句"></a>1.1 SELECT 语句</h2><ul><li><p>用途：从一个或多个表中检索信息；</p></li><li><p>语法</p><ul><li><p>检索某一个表的 <strong>某一个列</strong>：<code>SELECT &lt;column_name&gt; FROM &lt;table_name&gt;;</code></p></li><li><p>同时检索 <strong>多个列</strong>：<code>SELECT &lt;col_name1, [col_name2, ...]&gt; FORM &lt;table_name&gt;;</code></p></li><li><p>检索 <strong>所有的的列</strong>：<code>SELECT * FORM &lt;table_name&gt;;</code></p><blockquote><p><strong>谨慎使用通配符（*），除非真的需要，或者不知道需要列的列名</strong>；</p></blockquote></li><li><p>检索表中 <strong>某列不同的值</strong>（<code>DISTINCT</code> 关键字）：<code>SELECT DISTINCT &lt;col_name&gt; FROM &lt;table_name&gt;;</code></p><p>⚠ <strong>不可以部分使用 <code>DISTINCT</code> 关键字，例如：<code>SELECT DISTINCT &lt;col_name1, col_name2&gt; FROM &lt;table_name&gt;;</code></strong></p><p>因为 <code>DISTINCT</code> 作用于所有的列！部分使用会导致失去想要的结果（SQL 需要同时考虑其他列也有 <code>DISTINCT</code>，最后会出现组合的现象）；（而且这么做不符合逻辑）</p><p>ℹ <strong>和 <code>DISTINCT</code>  相反的是 <code>ALL</code>，一般无需指定，因为这是默认行为</strong>；</p></li><li><p>检索 <strong>结果限制</strong>（用来缩小范围找到想要的数据）</p><ol><li><p>限制仅查询 N 行</p><div class="tabs" id="limit_select"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="limit_select-1">MySQL</button><button type="button" class="tab " data-href="limit_select-2">Oracle</button><button type="button" class="tab " data-href="limit_select-3">SQL-server</button><button type="button" class="tab " data-href="limit_select-4">DB2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="limit_select-1"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>col_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">LIMIT N;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="limit_select-2"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>col_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> <span class="number">5</span>;    <span class="comment">-- 行计数器</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="limit_select-3"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">5</span> <span class="operator">&lt;</span>col_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="limit_select-4"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>col_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">5</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p><strong>以下仅以常见的 <code>MySQL</code>、<code>MariaDB</code>为例，不再赘述</strong>；</p></li><li><p>限制指定行：<code>M ~ M+N</code></p><p>⚠ <strong>SQL 语言 0-index</strong>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;col_name&gt;</span><br><span class="line">FROM &lt;table_name&gt;</span><br><span class="line">LIMIT N OFFSET M; -- 即 0+M ~ 0+M+N</span><br><span class="line">-- 或者</span><br><span class="line">LIMIT M,N;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>习题</p><ol><li><p>从 <code>customers</code> 表中检索所有的 <code>cust_id</code> 列的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id</span><br><span class="line"><span class="keyword">FROM</span> customers;</span><br></pre></td></tr></table></figure></li><li><p>已知表 <code>OrderItems</code> （订单表）中存在一列 <code>prod_id</code>（产品 ID），问所有出现在订单中的产品 ID，要求每个产品 ID 仅显示一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> prod_id</span><br><span class="line"><span class="keyword">FROM</span> OrderItems;</span><br></pre></td></tr></table></figure></li><li><p>检索 <code>customers</code> 表中所有的列，再检索其中列 <code>cust_id</code>、<code>cust_name</code>、<code>cust_country</code> 的第 5~9 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers;</span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_country</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line">LIMIT <span class="number">5</span> <span class="keyword">OFFSET</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="1-2-排序已检索数据"><a href="#1-2-排序已检索数据" class="headerlink" title="1.2 排序已检索数据"></a>1.2 排序已检索数据</h2><blockquote><p>主要内容：<code>SELECT</code> 的 <code>ORDER BY</code> 子句；</p></blockquote><ul><li><p>子句（clause）的定义：SQL 语句由子句构成；</p><blockquote><ol><li>有些子句是必需的，有些是可选的；</li><li>一个子句通常是由一个关键字 + 所提供的数据组成；</li></ol></blockquote><p>举例：SELECT 语句的 <code>FROM</code> 子句、<code>LIMIT</code> 子句、<code>ORDER BY</code> 子句等；</p></li><li><p>语法</p><ul><li><p>检索时 <strong>按某一列排序</strong>：<code>SELECT &lt;col_name1[, col_name2, ...]&gt; FROM &lt;tb_name&gt; ORDER BY &lt;col_nameN&gt;;</code></p><p>⚠ <strong>必须保证 <code>ORDER BY</code> 子句为 <code>SELECT</code> 语句的最后一句，否则会出错！</strong> </p><p>ℹ 排序依据的列可以不是选择列（即 <code>col_nameN</code> 可以不在 <code>col_name1, col_name2,...</code>中）；</p></li><li><p>检索时 <strong>按多个列排序</strong>：<code>SELECT &lt;col_name1[, col_name2, ...]&gt; FROM &lt;tb_name&gt; ORDER BY &lt;col_nameN1, col_nameN2, ...&gt;;</code></p><blockquote><p>含义：首先按 <code>col_nameN1</code> 排序，再按 <code>col_nameN2</code> 排序，有点像高考录取排序方法；</p></blockquote></li><li><p>检索时 <strong>使用已选择列的列号排序</strong>（仅仅是一种简化方法）：<code>SELECT &lt;col_Name1[, ...]&gt; FROM &lt;tb_name&gt; ORDER BY &lt;col_num1[, ...]&gt;;</code></p></li><li><p>检索时 <strong>指定排序方向</strong>：<code>SELECT &lt;col_name1[, ...]&gt; FROM &lt;tb_name&gt; ORDER BY &lt;col_nameN1[ASC/DESC][, ...]&gt;;</code></p><blockquote><p>关键字 <code>ASC</code>（Ascending，<strong>默认升序</strong>）、<code>DESC</code>（Descending）；</p></blockquote></li></ul></li><li><p>习题</p><ol><li><p>从 <code>Customers</code> 表中检索所有的顾客名称（<code>cust_names</code>），并按从 Z 到 A 的顺序显示结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_names</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_names <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>从 <code>Orders</code> 表中检索顾客 ID（<code>cust_id</code>）和订单号（<code>order_num</code>），并先按顾客 ID 对结果进行排序，再按订单日期（<code>order_date</code>）倒序排列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_id <span class="keyword">ASC</span>, order_date <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="1-3-过滤已检索数据"><a href="#1-3-过滤已检索数据" class="headerlink" title="1.3 过滤已检索数据"></a>1.3 过滤已检索数据</h2><blockquote><p>主要内容：<code>SELECT</code> 的 <code>WHERE</code> 子句、<code>SELECT</code> 的 <code>LIKE</code> 子句（模糊过滤）；</p></blockquote><ul><li><p><span id="principle">应用须知：<strong>对数据的过滤操作应该交给 SQL，而非上层的应用程序（开发语言）</strong>；</span></p><blockquote><p>原因：</p><ol><li>数据库 SQL 对于数据过滤优化力度远远大于你自己在外层写的，造成性能资源浪费；</li><li>降低上层应用程序的可移植性、可读性、可维护性；</li></ol></blockquote></li><li><p>过滤条件：也称“搜索条件”，用于根据特定操作提取表数据的子句；</p><p>模糊过滤条件：使用类似正则式的方式确定过滤条件（仅适用于文本-string）；</p></li><li><p>谓词（predicate）：某些关键字不是操作符，而是作为谓词使用，例如 <code>LIKE</code>；</p></li><li><p>语法</p><ul><li>在检索时 <strong>过滤条件</strong>：<code>SELECT &lt;col_name[, ...]&gt; FROM &lt;tb_name&gt; WHERE &lt;cond&gt;;</code></li><li>在检索时 <strong>使用模糊过滤条件</strong>：<code>SELECT &lt;col_name[, ...]&gt; FROM &lt;tb_name&gt; WHERE &lt;col_str&gt; LIKE &lt;pattern&gt;;</code></li></ul></li><li><p><code>WHERE &lt;cond&gt;</code> 子句判断操作符：小于(等于)、大于(等于)（与普通编程语言相同），<strong>等于（<code>=</code>）</strong>，不等于（<code>!=</code> 或 <code>&lt;&gt;</code>），不小于（<code>!&lt;</code>），不大于（<code>!&gt;</code>）；</p><blockquote><p>另外：在指定两个值之间使用关键字操作符 <code>BETWEEN...AND...</code>，判断是否为 NULL <code>IS NULL</code>；</p><p>以上操作符有冗余，有些 DBMS 不支持，请自行判断；</p></blockquote><p>⚠ <strong>注意1：NULL（空值）和字段包含0、空字符串、仅含空格的情况都不一样</strong>；</p><p>⚠ <strong>注意2：只要使用了过滤条件，除了 <code>IS NULL</code> 操作符，其他的匹配无法选中匹配列记录为 NULL 的记录！</strong></p><p>⚠ <strong>注意3：等于操作符和主流编程语言不一样，只有一个等号！</strong></p></li><li><p><code>WHERE &lt;cond&gt;</code>  子句条件操作符：<code>AND</code>、<code>OR</code>、<code>NOT</code>、圆括号（改变运算顺序）；</p><blockquote><p>运算顺序同主流编程语言；</p></blockquote></li><li><p><code>WHERE &lt;cond&gt;</code> 子句包含操作符：<code>IN</code>、定元组（例如：<code>(&#39;DLL01&#39;, &#39;BRS01&#39;)</code>）；</p><blockquote><p>建议能用 <code>IN</code>，就用它：</p><p>（例如：<code>SELECT prod_name FROM products WHERE prod_id == &#39;DLL01&#39; OR prod_id == &#39;BRS01&#39;;</code> 不如 <code>SELECT prod_name FROM products WHERE prod_id in (&#39;DLL01&#39;, &#39;BRS01&#39;);</code>）</p><p>因为它有好处：</p><ol><li><code>IN</code> 操作符可读性更强；</li><li>数据库底层优化 <code>IN</code> 可以使用一次 HASH 操作，效率高于 <code>OR</code> 连接的运算；</li><li><code>IN</code> 操作符可以实现 <code>WHERE</code> 子句的嵌套（后面讨论）；</li></ol></blockquote></li><li><p><code>WHERE</code> 子句的 <code>pattern</code>：</p><div style="text-align: center;">表二 SQL pattern 和 正则式对比</div><table>    <tr>        <td>SQL pattern</td>        <td>% (NULL excluded)</td>        <td>_</td>        <td>[char set]</td>        <td>[^char set]</td>    </tr>    <tr>        <td>Regex</td>        <td>.?</td>        <td>.</td>        <td>.[char set]</td>        <td>.[^char set]</td>    </tr></table></li></ul><p>  ⚠ <strong>注意1：在 <code>LIKE</code> 匹配时，<code>pattern</code> 区分大小写！</strong></p><p>  ⚠ <strong>注意2：在有些数据库的数据中，对于字符串数据类型按指定位存储时，不满位数的会填充以空格，因此 pattern 可能很难匹配到；正确做法是利用 SQL 自带函数去除字符串两边空格，后面讨论；</strong>、</p><p>  ⚠ <strong>注意3：不宜过度使用通配符、不宜将通配符作为靠前的搜索条件；</strong></p><ul><li><p>习题</p><ol><li><p>从Products 表中检索产品ID（<code>prod_id</code>）和产品名称（<code>prod_name</code>），只返回价格（<code>prod_price</code>）为 9 或更高的产品：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure></li><li><p>从 <code>OrderItems</code> 表中检索出所有不同订单号（<code>order_num</code>），其中包含产品个数（<code>quantity</code>）在 100 个至 200 个之间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> quantity <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">WHERE</span> quantity <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">AND</span> quantity <span class="operator">&lt;=</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure></li><li><p>返回 <code>Products</code> 表中所有价格在 3 美元到 6 美元之间的产品的名称（<code>prod_name</code>）和价格（<code>prod_price</code>），然后先按价格、后按 ID （<code>prod_id</code>）对结果都进行降序排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">6</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name <span class="keyword">DESC</span>, prod_id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>查找所有至少订购了总量（<code>quantity</code>） 100 个的，ID 为 <code>BR01</code>、<code>BR02</code> 或 <code>BR03</code> 的订单。你需要返回<code>OrderItems</code> 表的订单号（<code>order_num</code>）、产品ID（<code>prod_id</code>）和数量，并按产品 ID 和数量进行升序排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, prod_id</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> quantity <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">AND</span> prod_id <span class="keyword">IN</span> (<span class="string">&#x27;BR01&#x27;</span>, <span class="string">&#x27;BR02&#x27;</span>, <span class="string">&#x27;BR03&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_id, quantity;</span><br></pre></td></tr></table></figure></li><li><p>从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回描述中未出现 <code>toy</code> 一词的产品。要求按产品名称对结果进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_desc</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> (prod_desc <span class="keyword">LIKE</span> <span class="string">&#x27;%toy%&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure></li><li><p>从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回在描述<br>中以先后顺序同时出现 <code>toy</code> 和 <code>carrots</code> 的产品：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_desc</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_desc <span class="keyword">LIKE</span> <span class="string">&#x27;%toy%carrots%&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="Chapter-2-字段格式化输出"><a href="#Chapter-2-字段格式化输出" class="headerlink" title="Chapter 2 字段格式化输出"></a>Chapter 2 字段格式化输出</h1><blockquote><p>表中的列称为列，而在“计算字段”（格式化字段）中称为字段（field）；</p><p><strong>格式化输出的思想也遵循<a href="#principle">本思想🔗</a></strong></p></blockquote><h2 id="2-1-字段拼接"><a href="#2-1-字段拼接" class="headerlink" title="2.1 字段拼接"></a>2.1 字段拼接</h2><div class="tabs" id="concat"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="concat-1">MySQL</button><button type="button" class="tab " data-href="concat-2">SQL-Server</button><button type="button" class="tab " data-href="concat-3">DB2/SQLite</button></ul><div class="tab-contents"><div class="tab-item-content active" id="concat-1"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Concat(col_name1<span class="operator">/</span><span class="string">&#x27;string1&#x27;</span>[, ...])</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="concat-2"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_name1<span class="operator">/</span><span class="string">&#x27;string1&#x27;</span> <span class="operator">+</span> ... <span class="operator">+</span> col_nameN<span class="operator">/</span><span class="string">&#x27;stringN&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="concat-3"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_name1<span class="operator">/</span><span class="string">&#x27;string1&#x27;</span> <span class="operator">||</span> ... <span class="operator">||</span> col_nameN<span class="operator">/</span><span class="string">&#x27;stringN&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="2-2-简单算术运算和-strip"><a href="#2-2-简单算术运算和-strip" class="headerlink" title="2.2 简单算术运算和 strip"></a>2.2 简单算术运算和 strip</h2><p><code>+-*/</code> 和简单函数 <code>LTRIM(str)</code>（去左空格）、<code>RTRIM(str)</code>（去右空格）、<code>TRIM(str)</code>（去两边空格）；</p><p>常见数学函数几乎都与主流编程语言相同（<code>SIN()</code>、<code>EXP()</code>、<code>ABS()</code> 等）；</p><p>常量：<code>PI()</code>；</p><p>⚠ <strong>以上描述都没有提及别名（alias，又称导出列，derived column），其实规范来说，对于所有的格式化输出（包括以后提及的），都应该设置别名，好处如下：</strong></p><ol><li>方便客户端引用。没有别名的格式化列无法被某些客户端使用，有些操作会变得困难；</li><li>重命名包含不合法字符的原列名；</li><li>提升可读性。在原来的列名含混、意义不清晰时扩充、具体化它；</li></ol><h2 id="2-3-普通函数处理"><a href="#2-3-普通函数处理" class="headerlink" title="2.3 普通函数处理"></a>2.3 普通函数处理</h2><p>⚠ <strong>本部分内容的可移植性会受到不同 DBMS 对函数名称和定义的影响</strong>；</p><p>⚠ <strong>函数名称也不区分大小写</strong>；</p><div style="text-align: center;">表三 SQL 普通函数对比</div><table style="text-align: center;">    <tr>        <th rowspan=2>函数用法</th>        <th colspan=5>函数语法</th>    </tr>    <tr>        <th>MySQL</th>        <th>SQL Server</th>        <th>DB2</th>        <th>SQLite</th>        <th>Oracle</th>    </tr>    <tr>        <td>字符串子串</td>        <td colspan=2>SUBSTRING()</td>        <td colspan=3>SUBSTR()</td>    </tr>    <tr>        <td>数据类型转换</td>        <td colspan=2>CONVERT()</td>        <td>CAST()</td>        <td colspan=2>因类型不同</td>    </tr>    <tr>        <td>取日期</td>        <td>CURDATE()</td>        <td>GETDATE()</td>        <td>CURRENT_DATE</td>        <td>DATE()</td>        <td>SYSDATE</td>    </tr>    <tr>        <td>格式化日期</td>        <td>YEAR()等</td>        <td>DATEPART(yy, DATE)</td>        <td>同 MySQL</td>        <td>strftime(strf, DATE)</td>        <td>EXTRACT(year FROM DATE)</td>    </tr>    <tr>        <td>去空格</td>        <td colspan=5>LTRIM()、RTRIM()、TRIM()</td>    </tr>    <tr>        <td>求字符串长度</td>        <td>CHAR_LENGTH()</td>        <td>LEN()</td>        <td>STRING-LEGTH()</td>        <td colspan=2>LENGTH()</td>    </tr>    <tr>        <td>求数据所占Byte</td>        <td>LENGTH()</td>        <td>DATALENGTH()</td>        <td>同 MySQL</td>        <td>TYPEOF()对应的Byte</td>        <td>LENGTHB()</td>    </tr></table><p>tips 1. <code>SUBSTRING(str, start, end)</code>，其中 <code>end</code> 包含，且此处函数面向用户，是 <strong>1-index</strong>；</p><p><strong>tips 2. 还有些通用性比较好的函数：<code>UPPER()/LOWER()</code>（取大/小写）、<code>SOUNDEX()</code>（返回字符串的 <code>SOUNDEX</code> 值）</strong>;</p><p><strong><code>SOUNDEX()</code> 适用于英文，实质是一种将单词转化为描述发音的字母数字算法，可以找出发音近似或相同的单词，在有一些误输入的查找中有用，比如顾客名 <code>Michael</code> 误输入为 <code>Michelle</code>，但二者的 <code>SOUNDEX()</code> 相同，因此可以匹配</strong>；</p><h2 id="2-4-聚集函数"><a href="#2-4-聚集函数" class="headerlink" title="2.4 聚集函数"></a>2.4 聚集函数</h2><ul><li><p>定义：对表的<strong>某个列</strong>（某一行数据类型很可能不相同）运行的函数，仅计算返回一个值；</p></li><li><p><code>AVG()</code> 平均值函数</p><ol><li><p><strong>仅能针对单个列使用！！！</strong>如果需要多个列，请依次书写；</p><blockquote><p>仅有一种特例（实质还是一个列——导出列）：<strong>列以算术运算符连接</strong>；</p></blockquote></li><li><p><strong>忽略值为 <code>NULL</code> 的行</strong>；</p></li></ol></li><li><p><code>COUNT()</code> 计数函数</p><ol><li><code>COUNT(*)</code>：<strong>给表中的行计数，不忽略 <code>NULL</code></strong>；</li><li><code>COUNT(column)</code>：<strong>给特定列的行计数，忽略 <code>NULL</code></strong>；</li></ol></li><li><p><code>MAX()/MIN()</code> 最值函数：<strong>返回升序 / 降序排序后的第一行</strong>；</p></li><li><p><code>SUM()</code> 求和函数；</p></li><li><p>注意事项</p><ol><li><strong>允许列结合算数运算符</strong>；</li><li><strong>聚集不同值</strong>：如果对某列要按不同值进行聚集，应该在列名前指定 <code>DISTINCT</code>；</li><li><strong>使用聚集函数时强烈建议取别名</strong>；</li></ol></li></ul><h2 id="2-5-数据分组"><a href="#2-5-数据分组" class="headerlink" title="2.5 数据分组"></a>2.5 数据分组</h2><blockquote><p>主要内容：<code>SELECT</code> 的 <code>GROUP BY</code> 子句 和 <code>HAVING</code> 子句；</p></blockquote><ul><li><p>需求：在 2.4 中的聚集函数一般都是面向整个一列，或者一列的特定部分（如果使用了 <code>DISTINCT</code>、<code>WHERE</code> 约束）；但没法<strong>按照分类组来统计、聚集数据</strong>（例如按照 <code>date</code> 时间段分组求最大值），所以引入了<strong>数据分组</strong>；</p></li><li><p>创建分组：<code>SELECT &lt;col_name-X, [AgFuctions]&gt; FROM &lt;tb_name&gt; GROUP BY &lt;col_name-X&gt;;</code></p><blockquote><p>以上语句的含义指：将 <code>col_name-X</code> 先 <code>DISTINCT</code> 一下（<strong>所以上面的列名仅推荐使用 <code>col_name-X</code></strong>，即<strong>选择的列</strong>），再按 <code>col_name-X</code> 分组（内部完成），<strong>这时通配符 <code>*</code> 指代的对象会变成：<u>当前选择列中</u> 各自分好的组（意味着 <code>col_name-X</code> 只能有一个，否则不能使用通配符 <code>*</code>）</strong>！</p><p>ℹ 你可以使用聚集函数的 <code>*</code> 来试一试上面的理论；</p></blockquote></li><li><p>分组的性质</p><ol><li><p>数据列中 <code>NULL</code> 会被分为一组；</p></li><li><p><strong><code>GROUP BY</code> 子句必须在 <code>WHERE</code> 子句后，在 <code>ORDER BY</code> 子句之后</strong>；</p><blockquote><p><code>GROUP BY</code> 必须在 <code>WHERE</code> 之后的原因：</p><p><strong><code>GROUP BY</code> 产生内部分组，而 <code>WHERE</code> 只能对所有行筛选，<u>完全没有分组的概念</u></strong>，所以 <code>WHERE</code> 不能筛选分组（否则造成意想不到的结果）！</p><p>应该使用可以筛选分组的子句：<code>HAVING</code>（这个子句除了<strong>多了一个“可以筛选分组”的功能</strong>，其他使用与 <code>WHERE</code> 几乎一致、可以替代；但标准来说只有 <code>GROUP BY</code> + 需要筛选时才用到 <code>HAVING</code>）</p></blockquote></li><li><p><code>GROUP BY</code>  子句允许嵌套分组；</p></li></ol></li><li><p>过滤分组：<code>SELECT &lt;col_name-X [AgFunctions]&gt; FROM &lt;tb_name&gt; GROUP BY &lt;col_name-X&gt; HAVING &lt;cond&gt;;</code></p></li><li><p>排序分组：<code>SELECT &lt;col_name-X [AgFunctions]&gt; FROM &lt;tb_name&gt; GROUP BY &lt;col_name-X&gt; ORDER BY &lt;col_name-X&gt;;</code></p><p>⚠ 虽然你可能发现 <code>GROUP BY</code> 本身就可以按分组后的结果排序，但这个行为不在 SQL 规范中，<strong>所以如果有需要对分组进行排序，仍需要 <code>ORDER BY</code> 子句</strong>，不能仅仅依赖 <code>GROUP BY</code>；</p></li></ul><h2 id="2-6-本章习题"><a href="#2-6-本章习题" class="headerlink" title="2.6 本章习题"></a>2.6 本章习题</h2><ol><li><p>从 <code>Vendors</code> 表中检索 <code>vend_id</code>、<code>vend_name</code>、<code>vend_address</code> 和 <code>vend_city</code>，将 <code>vend_name</code> 重命名为 <code>vname</code>，将 <code>vend_city</code> 重命名为 <code>vcity</code>，将 <code>vend_address</code> 重命名为 <code>vaddress</code>。再按供应商名称对结果进行排序。注意所有的字符串变量的存储都有定长、记录前可能有空格：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,</span><br><span class="line">    <span class="built_in">TRIM</span>(vend_name) <span class="keyword">AS</span> vname,</span><br><span class="line">    <span class="built_in">TRIM</span>(vend_city) <span class="keyword">AS</span> vcity,</span><br><span class="line">    <span class="built_in">TRIM</span>(vend_address) <span class="keyword">AS</span> vaddress</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vname;</span><br></pre></td></tr></table></figure></li><li><p>商店正在进行打折促销，所有产品均降价 10%. 编写 SQL 语句，从 <code>Products</code> 表中返回 <code>prod_id</code>、<code>prod_price</code> 和 <code>sale_price</code>，其中<code>sale_price</code> 是一个包含促销价格的计算字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price,</span><br><span class="line">    prod_price<span class="operator">*</span><span class="number">0.9</span> <span class="keyword">AS</span> sale_price</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure></li><li><p>假设商店已经上线了，正在创建顾客账户。所有用户都需要登录名，默认登录名是其名称和所在城市的组合。在表 <code>Customers</code> 中编写 SQL 语句，返回顾客 ID（<code>cust_id</code>）、顾客名称（<code>cust_name</code>）和登录名（<code>user_login</code>），其中登录名全部为大写字母，并由顾客联系人的前两个字符（<code>cust_contact</code>）和其所在城市的前三个字符（<code>cust_city</code>）组成。例如，我的登录名是 <code>BEOAK</code>（<code>Ben Forta</code>，居住在 <code>Oak Park</code>）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name,</span><br><span class="line">    <span class="built_in">UPPER</span>(</span><br><span class="line">        CONCAT(</span><br><span class="line">            <span class="built_in">SUBSTRING</span>(cust_contact, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            <span class="built_in">SUBSTRING</span>(cust_city, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        )</span><br><span class="line">    ) <span class="keyword">AS</span> user_login</span><br><span class="line"><span class="keyword">FROM</span> Customers;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，返回 2020 年 1 月的所有订单（<code>Orders</code> 表）的订单号（<code>order_num</code>）和订单日期（<code>order_date</code>），并按订单日期排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, order_date</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> date_format(order_date, <span class="string">&#x27;%Y-%m&#x27;</span>) <span class="operator">=</span> <span class="string">&#x27;2020-01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，找出 <code>Products</code> 表中的 <code>num_items</code> 项的总个数（不包括 <code>NULL</code>）、值不同的个数、最小、最大、平均值，列在一个表格中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(num_items) <span class="keyword">AS</span> total_cnt,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> num_items) <span class="keyword">AS</span> dist_cnt,</span><br><span class="line">    <span class="built_in">MIN</span>(num_items) <span class="keyword">AS</span> min_items,</span><br><span class="line">    <span class="built_in">MAX</span>(num_items) <span class="keyword">AS</span> max_items,</span><br><span class="line">    <span class="built_in">AVG</span>(num_items) <span class="keyword">AS</span> avg_items</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure></li><li><p>计算 <code>OrderItems</code> 表中各行所要花费的金钱总和（物品数量 <code>quantity</code> * 物品价格 <code>item_price</code> 再求和）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(quantity <span class="operator">*</span> item_price) <span class="keyword">AS</span> total_cost <span class="keyword">FROM</span> OrderItems;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，确定 <code>Products</code> 表中价格不超过 10 美元的最贵产品的价格（<code>prod_price</code>）。将计算所得的字段命名为 <code>max_price</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(prod_price) <span class="keyword">AS</span> max_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，要求统计 <code>Products</code> 表的供应商 ID <code>vend_id</code> 各自提供的商品个数（即每个供应商在 <code>Product</code> 中含有的数据行数），按 “ID、个数（列名 <code>num_prods</code>）” 顺序输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，要求找出 <code>Orders</code> 表中订单数不少于 2 的顾客 ID（<code>cust_id</code>），即每个 <code>cust_id</code> 在表中含有的数据行数，按 “ID、订单数” 顺序输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_orders</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，要求找出 <code>Products</code> 表中 “提供 2 个及以上的、价格（<code>prod_price</code>）不少于4 的产品” 的供应商，按 “供应商ID（<code>vend_id</code>）、满足条件的产品数（列名 <code>num_prods</code>）” 顺序输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span> <span class="number">4</span>    <span class="comment">-- 注意：在这里非分组筛选需要在分组前进行</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>OrderItems</code> 表包含每个订单的每个产品。编写SQL 语句，返回每个订单号（<code>order_num</code>）各有多少行数（<code>order_lines</code>），并按 <code>order_lines</code> 对结果进行升序排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> order_lines</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_lines;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，返回名为 <code>cheapest_item</code> 的字段，该字段包含每个供应商（<code>vend_id</code>）成本最低的产品（使用 <code>Products</code> 表中的 <code>prod_price</code>），然后从最低成本到最高成本对结果进行排序（按 “供应商 ID、<code>cheapest_item</code>” 输出）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注意：此处 prod_price 已不再是整个列，而是各分组的 prod_price，对它用聚集函数会得到各列的结果</span><br><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">MIN</span>(prod_price) <span class="keyword">AS</span> cheapest_item</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cheapeset_item;</span><br></pre></td></tr></table></figure></li><li><p>商店经营中，确定最佳顾客非常重要。有一个店主想出 2 种方法来确定他的最佳顾客：</p><p>Ⅰ. 找出满足 “所有订购产品的数量不少于 100” 的订单，至少持有一个这样订单的顾客是 “最佳顾客”；（注：在 <code>OrderItems</code> 表中特定的订单号 <code>order_num</code>、本订单订购商品名 <code>order_item</code>下的商品数量 <code>quantity</code>，是 “这个订单中 这个产品的数量”）</p><blockquote><p>所以请编写 SQL 语句，只需找出满足上述条件的这个订单，输出订单号即可；</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(quantity) <span class="operator">&gt;=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>Ⅱ. 找出满足 “总价（包含不同的商品）至少为 1000” 的订单，至少持有一个这样订单的顾客是 “最佳顾客”；（注：对于一个订单中的一个商品而言，需要在 <code>OrderItems</code> 表中计算 <code>item_price * quantity</code> 来获得订单中一类商品的总价格）</p><blockquote><p>所以请编写 SQL 语句，找出满足上述条件的订单，以降序输出订单号（<code>order_num</code>），按 “订单号、总价（列名 <code>total_price</code>）” 输出；</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">SUM</span>(item_price <span class="operator">*</span> quantity) <span class="keyword">AS</span> total_price</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> total_price <span class="operator">&gt;=</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_num <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>在不运行下列语句的前提下，指出下列语句的错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> items</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> items</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> items, order_num;</span><br></pre></td></tr></table></figure><p><strong>Answer：<code>GROUP BY</code> 语句不能对聚合函数分组！</strong>从分组聚合的含义上来说，<code>COUNT(*)</code> 是对分组后的组进行计数，这样是循环指代，从逻辑上行不通；</p><p><strong>改正方案：将 <code>GROUP BY items</code> 分组依据改成 <code>GROUP BY order_num</code> 就正确了，如下：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> items</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> items, order_num;</span><br></pre></td></tr></table></figure><p><strong>这段语句的含义是：找出所有满足 “包含不少于 3 种商品” 的订单，并按 “订单所含商品种类数、订单号” 输出（最后按种类数，再按订单号升序排序）；</strong></p></li></ol><h1 id="EX-1-第一部分语法总结"><a href="#EX-1-第一部分语法总结" class="headerlink" title="EX-1 第一部分语法总结"></a>EX-1 第一部分语法总结</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>col_name1[, ...]<span class="operator">&gt;</span> [<span class="keyword">AS</span> new_name]</span><br><span class="line">[<span class="keyword">FROM</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>cond<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>col_name1<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">HAVING</span> <span class="operator">&lt;</span>cond<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>col_name<span class="operator">-</span>N<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本部分文章是 SQL 的基础部分，纪念我丢掉的 SQL 笔记&lt;/i&gt; 😭&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Reference: 《 &lt;a</summary>
      
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
    <category term="SQL" scheme="https://sjtuxhw.top/tags/SQL/"/>
    
    <category term="Database" scheme="https://sjtuxhw.top/tags/Database/"/>
    
    <category term="MySQL" scheme="https://sjtuxhw.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Matlab 复习</title>
    <link href="https://sjtuxhw.top/2023/06/18/Matlab-%E5%A4%8D%E4%B9%A0/"/>
    <id>https://sjtuxhw.top/2023/06/18/Matlab-%E5%A4%8D%E4%B9%A0/</id>
    <published>2023-06-18T11:45:12.000Z</published>
    <updated>2023-09-19T05:18:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><i>Written by SJTU_XHW</i></p><p><i>Version: Matlab R2020b</i></p><p><i>References:</i> <a href="https://www.mathworks.com/help/matlab/">MATLAB Documentation (mathworks.com)</a></p><hr><span id="more"></span><h3 id="Chapter0-Matlab-is-a-1-index-language"><a href="#Chapter0-Matlab-is-a-1-index-language" class="headerlink" title="Chapter0 Matlab is a 1-index language"></a>Chapter0 Matlab is a 1-index language</h3><h3 id="Chapter1-Basic-Operations"><a href="#Chapter1-Basic-Operations" class="headerlink" title="Chapter1 Basic Operations"></a>Chapter1 Basic Operations</h3><h4 id="1-1-operators-numerical-；logical-amp-amp-gt-lt-（按位运算须函数）-；"><a href="#1-1-operators-numerical-；logical-amp-amp-gt-lt-（按位运算须函数）-；" class="headerlink" title="1.1 operators: numerical { +-*/^() } ；logical { ~ || &amp;&amp; &gt; &lt; ==（按位运算须函数） }；"></a>1.1 operators: numerical { +-*/^() } ；logical { ~ || &amp;&amp; &gt; &lt; ==（按位运算须函数） }；</h4><h4 id="1-2-variables-do-not-need-to-be-declaed-before-assignment-类似Python"><a href="#1-2-variables-do-not-need-to-be-declaed-before-assignment-类似Python" class="headerlink" title="1.2 variables: do not need to be declaed before assignment (类似Python)"></a>1.2 variables: do not need to be declaed before assignment (类似Python)</h4><h4 id="1-3-numeric-variable-type：logical、char、numeric、cell、struct、scalar"><a href="#1-3-numeric-variable-type：logical、char、numeric、cell、struct、scalar" class="headerlink" title="1.3 numeric variable type：logical、char、numeric、cell、struct、scalar"></a>1.3 numeric variable type：logical、char、numeric、cell、struct、scalar</h4><h4 id="1-4-constants：ans，i-j，Inf，eps（2-2204e-016），NaN，pi"><a href="#1-4-constants：ans，i-j，Inf，eps（2-2204e-016），NaN，pi" class="headerlink" title="1.4 constants：ans，i/j，Inf，eps（2.2204e-016），NaN，pi"></a>1.4 constants：ans，i/j，Inf，eps（2.2204e-016），NaN，pi</h4><h4 id="1-5-keywords：iskeyword"><a href="#1-5-keywords：iskeyword" class="headerlink" title="1.5 keywords：iskeyword"></a>1.5 keywords：<code>iskeyword</code></h4><h4 id="1-6-calling-priority"><a href="#1-6-calling-priority" class="headerlink" title="1.6 calling priority"></a>1.6 calling priority</h4><blockquote><p>local variable $\gt$ built-in fuction $\gt$ subfunction $\gt$ private fuction(self defined: <em>.mex, </em>.p, *.m)</p></blockquote><h4 id="1-7-numeric-display-“format”"><a href="#1-7-numeric-display-“format”" class="headerlink" title="1.7 numeric display “format”"></a>1.7 numeric display “format”</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format [options]</span><br></pre></td></tr></table></figure><p>short（3.1416）、long（3.1415…）、shortE（3.1416e+00）、longE（3.1415…e+00）、bank（3.14）、hex  、rat（ratio of small integers）</p><h4 id="1-8-command-line-terminal"><a href="#1-8-command-line-terminal" class="headerlink" title="1.8 command line terminal"></a>1.8 command line terminal</h4><ol><li><p>“;” at the end of a command suppresses output to the terminal.</p></li><li><p>“↑” display previous commands.</p></li><li><p><strong>Common commands</strong>：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clc; <span class="comment">% clear command window display</span></span><br><span class="line">clear; <span class="comment">% remove all variables int the workspace</span></span><br><span class="line">who <span class="comment">% variables in the workspace</span></span><br><span class="line">whos <span class="comment">% variable information of the workspace </span></span><br><span class="line">     <span class="comment">% 作用类似于Python中的语句“\”，起到过长文字换行作用</span></span><br><span class="line"><span class="keyword">end</span>; <span class="comment">%    指代当前上下文中数组最后一行/列的索引</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Chapter2-Array-Operations"><a href="#Chapter2-Array-Operations" class="headerlink" title="Chapter2 Array Operations"></a>Chapter2 Array Operations</h3><h4 id="2-1-Array-Definition"><a href="#2-1-Array-Definition" class="headerlink" title="2.1 Array Definition"></a>2.1 Array Definition</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]; <span class="comment">% row vector（“，”can be omitted）</span></span><br><span class="line">b = [<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>]; <span class="comment">% column vector</span></span><br><span class="line">c = [<span class="number">1</span>, <span class="number">21</span>, <span class="number">6</span>;</span><br><span class="line">    <span class="number">5</span>, <span class="number">17</span>, <span class="number">9</span>;</span><br><span class="line">    <span class="number">31</span>, <span class="number">2</span>, <span class="number">7</span>]; <span class="comment">% matrix</span></span><br></pre></td></tr></table></figure><h4 id="2-2-Array-Indexing"><a href="#2-2-Array-Indexing" class="headerlink" title="2.2 Array Indexing"></a>2.2 Array Indexing</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">21</span>, <span class="number">6</span>;</span><br><span class="line">    <span class="number">5</span>, <span class="number">17</span>, <span class="number">9</span>;</span><br><span class="line">    <span class="number">31</span>, <span class="number">2</span>, <span class="number">7</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">% 单参数索引都是“线性索引”-----------</span></span><br><span class="line">A(<span class="number">8</span>) <span class="comment">% 按列来数，第8个元素，这里称它为“线性索引”</span></span><br><span class="line">A([<span class="number">1</span> <span class="number">3</span> <span class="number">5</span>]) <span class="comment">% 以一维向量（数组）作为索引，则每个元素代表一个“线性索引”，构成同形状的数组</span></span><br><span class="line">A([<span class="number">1</span> <span class="number">3</span>; <span class="number">1</span> <span class="number">3</span>]) <span class="comment">% 以矩阵作为索引，每个元素代表一个“线性索引”，构成同一形状的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 双/多参数索引是普通的行（前）-列（后）索引------------</span></span><br><span class="line">A(<span class="number">3</span>, <span class="number">2</span>) <span class="comment">% 第3行，第2列元素</span></span><br><span class="line">A([<span class="number">1</span> <span class="number">3</span>], [<span class="number">2</span> <span class="number">4</span>]) <span class="comment">% 第1、3行，第2、4列元素构成子式对应的矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Colon Operator（省略号操作符）-------------</span></span><br><span class="line"><span class="built_in">j</span>:k <span class="comment">% is equivalent to [j, j+1, j+2, ..., j+m]（j+m ≤ k）</span></span><br><span class="line"><span class="built_in">j</span>:<span class="built_in">i</span>:k <span class="comment">% is equivalent to [j, j+i, j+2i, ..., j+m*i]（j+m*i ≤ k）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Examples:</span></span><br><span class="line">B = <span class="number">1</span>:<span class="number">5</span>;</span><br><span class="line">B = <span class="number">1</span>:<span class="number">2</span>:<span class="number">5</span>;</span><br><span class="line">B = [<span class="number">1</span>:<span class="number">5</span>; <span class="number">2</span>:<span class="number">3</span>:<span class="number">15</span>; <span class="number">-2</span>:<span class="number">0.5</span>:<span class="number">0</span>];</span><br><span class="line">str = <span class="string">&#x27;a&#x27;</span>:<span class="number">2</span>:<span class="string">&#x27;z&#x27;</span>;  <span class="comment">% 字符数组</span></span><br><span class="line"><span class="comment">% 与C++、Python都不同，可以直接这样切片数组赋值</span></span><br><span class="line">A(<span class="number">3</span>, :) = [] <span class="comment">% 索引参数由“：”替代时，表示全选该参数位</span></span><br></pre></td></tr></table></figure><h4 id="2-4-Array-Concatenation"><a href="#2-4-Array-Concatenation" class="headerlink" title="2.4 Array Concatenation"></a>2.4 Array Concatenation</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">2</span> <span class="number">1</span>;</span><br><span class="line">    <span class="number">3</span> <span class="number">2</span>;</span><br><span class="line">    <span class="number">-2</span> <span class="number">2</span>];</span><br><span class="line">B = [<span class="number">1</span> <span class="number">1</span>;</span><br><span class="line">    <span class="number">3</span> <span class="number">4</span>;</span><br><span class="line">    <span class="number">2</span> <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">C = [A, B]; <span class="comment">% 行拼接</span></span><br><span class="line">D = [A; B]; <span class="comment">% 列拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cat函数拼接</span></span><br><span class="line">E = <span class="built_in">cat</span>(dim_direction, A, B);</span><br><span class="line"><span class="comment">% 1=列方向，2=行方向，&gt;2 抽象</span></span><br></pre></td></tr></table></figure><h4 id="2-5-Array-Manipulation"><a href="#2-5-Array-Manipulation" class="headerlink" title="2.5 Array Manipulation"></a>2.5 Array Manipulation</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A [+-*/] const  <span class="comment">% 数组[?]常数--&gt;数组每一个元素都[?]该常数</span></span><br><span class="line">A ^ const  <span class="comment">% 矩阵的const次幂</span></span><br><span class="line">A .^ const  <span class="comment">% 矩阵每个元素分别作const次幂（&quot;.&quot;表示对每个元素操作）</span></span><br><span class="line">A’  <span class="comment">% 矩阵的转置</span></span><br><span class="line">A [+-] B  <span class="comment">% 同型数组之和/差</span></span><br><span class="line">A * B   <span class="comment">% 矩阵乘法</span></span><br><span class="line">A .* B   <span class="comment">% 数组对应元素相乘</span></span><br><span class="line">A / B    <span class="comment">% 与A * inv(B)相同，但内部实现更优</span></span><br><span class="line">A ./ B   <span class="comment">% 数组对应元素相除</span></span><br><span class="line">A \ B    <span class="comment">% inv(A) * B，但内部实现更优。注意和B / A不同！！！</span></span><br><span class="line">A .\ B   <span class="comment">% 对应元素反除，这里相当于 B ./ A</span></span><br></pre></td></tr></table></figure><h4 id="2-6-Special-Matrices"><a href="#2-6-Special-Matrices" class="headerlink" title="2.6 Special Matrices"></a>2.6 Special Matrices</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eye</span>(n);  <span class="comment">% n阶单位矩阵</span></span><br><span class="line"><span class="built_in">zeros</span>(n1, n2);    <span class="comment">% n1×n2 零阵</span></span><br><span class="line"><span class="built_in">ones</span>(n1, n2);    <span class="comment">% n1×n2 1阵</span></span><br><span class="line"><span class="built_in">diag</span>(v, offset=<span class="number">0</span>);    <span class="comment">% 主对角元组成向量v的矩阵，offset＞0，向主对角线上方偏移，反之向下</span></span><br><span class="line"><span class="built_in">diag</span>(A, offset=<span class="number">0</span>);    <span class="comment">% 以上过程的逆过程</span></span><br></pre></td></tr></table></figure><h4 id="2-7-Basic-Functions-of-Matrix"><a href="#2-7-Basic-Functions-of-Matrix" class="headerlink" title="2.7 Basic Functions of Matrix"></a>2.7 Basic Functions of Matrix</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A);    <span class="comment">% 向量最大值、矩阵每一列的最大值行向量、多维数组沿第一个数组维度不为1的维度计算，将元素视为向量（这样此维度大小变为1，其他维度不变）。如果第一个数组维度=0，则返回与原数组大小相同的空数组。</span></span><br><span class="line"><span class="built_in">max</span>(A, [], dim);    <span class="comment">% 规定以哪个维度作为“第一维度”的max，1=行，2=列，＞2时抽象</span></span><br><span class="line"><span class="built_in">min</span>(A, [], dim=<span class="number">1</span>);    <span class="comment">% 同理</span></span><br><span class="line">sum(A, dim=<span class="number">1</span>);    <span class="comment">% 处理规则类似max，返回沿不等于1的第一个数组维度的元素之和</span></span><br><span class="line"><span class="built_in">mean</span>(A, dim=<span class="number">1</span>);    <span class="comment">% 处理规则类似max，返回沿不等于1的第一个数组维度的元素的均值</span></span><br><span class="line"><span class="built_in">mean</span>(A, <span class="string">&#x27;all&#x27;</span>);    <span class="comment">% 返回A中所有元素均值</span></span><br><span class="line"><span class="built_in">sort</span>(A, dim=<span class="number">1</span>);    <span class="comment">% 处理规则类似max。向量：对元素排序；矩阵，排序列向量（dim=1）；多维数组：沿不等于1的第一个数组维度计算，将元素视为向量，进行向量排序</span></span><br><span class="line"><span class="built_in">sortrows</span>(A, col=<span class="number">1</span>);    <span class="comment">% 以第一列作为排序依据，若相同，则看第二优先度的列（本质：对行向量排序）</span></span><br><span class="line"><span class="built_in">size</span>(A);    <span class="comment">% 类似Python.numpy的ndarray.shape，这里返回行向量：[dim1, dim2, ...]</span></span><br><span class="line"><span class="comment">% 可以写：[dim1, dim2, ...] = size(A);</span></span><br><span class="line"><span class="built_in">size</span>(A, dim);    <span class="comment">% 指定维度的size</span></span><br><span class="line"><span class="built_in">length</span>(A);    <span class="comment">% 数组最大维度的长度</span></span><br><span class="line"><span class="built_in">find</span>(X);    <span class="comment">% 返回数组（logical数组为多，结合逻辑运算式）中每个非零元素的索引向量（X为向量：返回方向相同的向量；X为矩阵/多维数组：返回“线性索引”组成的列向量）</span></span><br><span class="line"><span class="comment">% find 可选参数：n：前/后n个索引；direction：‘first’/‘last’</span></span><br></pre></td></tr></table></figure><h3 id="Chapter3-Structured-Programming"><a href="#Chapter3-Structured-Programming" class="headerlink" title="Chapter3 Structured Programming"></a>Chapter3 Structured Programming</h3><h4 id="3-1-Flow-Control"><a href="#3-1-Flow-Control" class="headerlink" title="3.1 Flow Control"></a>3.1 Flow Control</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% if - elseif - else</span></span><br><span class="line"><span class="comment">% switch - case - otherwise</span></span><br><span class="line"><span class="comment">% for</span></span><br><span class="line"><span class="comment">% while</span></span><br><span class="line"><span class="comment">% try - catch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 条件表达式：不需要括号、不需要冒号、不需要大括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% end：以上结构的结束都需要此关键字</span></span><br><span class="line"><span class="comment">% pause：暂停脚本执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% break</span></span><br><span class="line"><span class="comment">% continue</span></span><br></pre></td></tr></table></figure><h4 id="3-2-Programming-Tip-Pre-allocating-Space-to-Variables"><a href="#3-2-Programming-Tip-Pre-allocating-Space-to-Variables" class="headerlink" title="3.2 Programming Tip: Pre-allocating Space to Variables"></a>3.2 Programming Tip: Pre-allocating Space to Variables</h4><blockquote><p>Tips. 提前为变量（尤其是大规模数组）分配内存空间非常必要。Matlab的数组和C++的STL容器类似，使用时会插入元素。当元素数量较多时，频繁分配空间会降低运行效率，所以提前分配好空间（已知大小/大致范围）再更改值会更好。</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tic                                <span class="comment">% 程序改进：</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">2000</span>                    <span class="comment">% A = zeros(2000, 2000);</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">2000</span><span class="comment">% for i=1:size(A, 1)</span></span><br><span class="line">        A(<span class="built_in">i</span>, <span class="built_in">j</span>) = <span class="built_in">i</span> + <span class="built_in">j</span>;<span class="comment">%     for j=1:size(A, 2)</span></span><br><span class="line">    <span class="keyword">end</span><span class="comment">%         A(i, j) = i + j;</span></span><br><span class="line"><span class="keyword">end</span>                                <span class="comment">%     end</span></span><br><span class="line">toc                                <span class="comment">% end</span></span><br></pre></td></tr></table></figure><h4 id="3-3-Good-Habits-for-Script-Writing"><a href="#3-3-Good-Habits-for-Script-Writing" class="headerlink" title="3.3 Good Habits for Script Writing"></a>3.3 Good Habits for Script Writing</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% At the beginning</span></span><br><span class="line">clear all;    <span class="comment">% 1. Remove previous variables</span></span><br><span class="line">close all;    <span class="comment">% 2. Close all figures</span></span><br><span class="line"><span class="comment">% 3. Use semicolon &quot;;&quot; at the end of commands to inhibit unwanted outputs</span></span><br><span class="line"><span class="comment">% 4. Use ellipsis &quot;...&quot; to make scripts more readable:</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">4</span> <span class="number">1</span>; ...</span><br><span class="line">     <span class="number">6</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line"><span class="comment">% 5. Use &quot;Ctrl + C&quot; to terminate the script before conclusion</span></span><br></pre></td></tr></table></figure><h4 id="3-4-Matlab-Functions"><a href="#3-4-Matlab-Functions" class="headerlink" title="3.4 Matlab Functions"></a>3.4 Matlab Functions</h4><ul><li><p>方程作为一个单独脚本（*.m）存在，并且文件名必须与方程名相同；</p></li><li><p>方程文件存放位置必须位于“预设位置”/当前文件夹位置，供程序寻找；</p></li><li><p>查看内置函数方法：<code>edit(which(&#39;函数名.m&#39;))</code></p></li><li><p>方程书写规范（以mean.m为例）：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 文件名：mean.m</span></span><br><span class="line"><span class="comment">% 关键字 output(s)=FunctionName(Input(s))</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">mean</span><span class="params">(x)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 多参数书写方式：e.g., [a F] = acc(v2, v1, t2, t1, m)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%MEAN Average or mean value.  这里写“Online Help”，即帮助文档</span></span><br><span class="line"><span class="comment">%    S = MEAN(X) is the mean value of the elements in X. 描述清调用方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% MATLAB CODES（函数实现方法）</span></span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line"><span class="keyword">if</span> nargin==<span class="number">2</span> &amp;&amp; ischar(dim)</span><br><span class="line">    flag = dim;</span><br><span class="line"><span class="keyword">elseif</span> nargin &lt; <span class="number">3</span></span><br><span class="line">    flag = <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% ...</span></span><br></pre></td></tr></table></figure></li><li><p>方程内部预设变量</p><ul><li><p><code>inputname</code>：Variable name of function input</p></li><li><p><code>mfilename</code>： File name of currently runing function</p></li><li><p><code>nargin</code>：Number of the function input arguments（Linux shell：$#）</p></li><li><p><code>nargout</code>：Number of the function output arguments</p></li><li><p><code>varargin</code>：Variable length input argument list（Python：args，此处是1×n的cell）</p><p>e.g., <code>function y = f(x, t, varargin)</code></p></li><li><p><code>varargout</code>：Variable length output argument list</p></li></ul></li><li><p>特殊函数：Function handles（类似Python、C++的匿名函数）</p><ul><li>Definition：<code>f = @(x) exp(-2*x)</code></li><li>Domain：this file <strong><u>ONLY</u></strong></li><li>Usage（example）：<code>x = 0:0.1:2; plot(x, f(x));</code></li><li>Tips：”@”用在函数前变为函数指针，可以作为函数参数；</li></ul></li><li><p>常见内置函数</p><ul><li><p><code>x = input(prompt)</code>：输入变量函数；</p></li><li><p><code>mod(x, y)</code>：等价于 x % y；</p></li><li><p><code>num2str(A, [int precision])</code>：将数值数组转为数字的字符数组（尤其在使用数值为绘图添加标签和标题时有用）；</p><p><strong><u>以下为针对numeric数组的函数</u></strong></p></li><li><p><code>reshape(A, row, col)</code>：将A数组的形状改为row行col列（注：item num  = row*col）；</p></li><li><p><code>linspace(x1, x2, [n])</code>：生成x1~x2间等间距100个点，加上n参数就是n个点；</p></li><li><p><code>logspace(x1, x2, [n])</code>：生成$10^{x_{1}}$~$10^{x_{2}}$呈以10对数关系间距的50个点；<strong>注意：由于信号系统的方便性，惯例约定当$x_{2}=\pi$时，生成的是$10^{x_{1}}$~$\pi$的对数点</strong>；</p></li><li><p><code>[X, Y] = meshgrid(xVector, yVector)</code>：生成xVector和yVector交叉点网格矩阵（常用于绘制面图）；</p></li><li><p><strong><u>注：以下谓词函数缺省参数</u></strong></p></li><li><p><code>isempty(A)</code>：判空函数（是否为空，即至少一个维度为0的数组）</p></li><li><p><code>isinteger</code></p></li><li><p><code>islogical</code></p></li><li><p><code>isnan</code></p></li><li><p><code>isinf</code></p></li><li><p><code>isnumeric</code></p></li><li><p><code>isprime</code></p></li><li><p><code>isreal</code></p></li><li><p><code>ischar</code></p></li><li><p><code>isequal</code>：numerically</p></li><li><p><code>isglobal</code></p></li></ul></li></ul><h3 id="Chapter4-Data-Structure-amp-File-Access"><a href="#Chapter4-Data-Structure-amp-File-Access" class="headerlink" title="Chapter4 Data Structure &amp; File Access"></a>Chapter4 Data Structure &amp; File Access</h3><h4 id="4-1-Data-Types"><a href="#4-1-Data-Types" class="headerlink" title="4.1 Data Types"></a>4.1 Data Types</h4><ul><li>可作为1~多维数组元素的数据类型（括号内为C++对应类型）：logical，char，cell，struct，numeric：{ int8、unit8、int16（short）、uint16（unsigned short）、int32（int）、uint32（unsigned）、int64（long long）、uint64（unsigned long long）|   single、double }</li><li>作为标量的数据类型：function handle</li></ul><h4 id="4-2-Numeric"><a href="#4-2-Numeric" class="headerlink" title="4.2 Numeric"></a>4.2 Numeric</h4><ul><li>Numeric内部类型间的转换函数均为：类型名()</li></ul><h4 id="4-3-Char-amp-String"><a href="#4-3-Char-amp-String" class="headerlink" title="4.3 Char &amp; String"></a>4.3 Char &amp; String</h4><ul><li>char：和C++相同，底部以数字表示，可以简单认为是ASCII对应数据（uint16），实际上支持中文</li><li>string：与普通numeric数组相同，参与逻辑计算方式相同，同一维度可直接拼接。<ul><li>定义方式有差异：<code>s = &#39;Example&#39;;</code><strong><u>请注意：使用单引号是char数组，双引号是string对象！！！</u></strong></li><li>逻辑运算方式：char数组与char/char数组运算（返回与最长数组同型的logical数组）</li><li>重要拓展：<code>str(str == &#39;a&#39;) = &#39;Z&#39;;</code>表示将所有含’a’的位置全换为’Z’（仅限str为char数组）</li></ul></li><li>相互转换函数<ul><li><code>string(char_arr)</code>：字符数组转string</li><li><code>convertStringsToChars(string/string_arr)</code>：字符串（数组）转字符数组（字符数组元胞）</li></ul></li></ul><h4 id="4-4-Structure"><a href="#4-4-Structure" class="headerlink" title="4.4 Structure"></a>4.4 Structure</h4><ul><li><p>定义、赋值：和C++不同，无需提前声明结构体的字段（fields）和数据类型，直接赋值即可</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 以student结构体为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第一次使用该结构体对象时，对象名即为结构体名</span></span><br><span class="line"><span class="comment">% 第一次定义字段时，在结构体中创建该字段</span></span><br><span class="line">student.name =  <span class="string">&#x27;Alex&#x27;</span>;</span><br><span class="line">student.id = <span class="string">&#x27;12345&#x27;</span>;</span><br><span class="line">student.grade = [<span class="number">100</span>, <span class="number">95</span>, <span class="number">93</span>; ...</span><br><span class="line">                 <span class="number">95</span>, <span class="number">100</span>, <span class="number">91</span>];</span><br><span class="line"><span class="comment">% 目前student既为第一个该类型结构体对象，也为该结构体类型名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第N（N＞1）次应用结构体类型创建新对象时，使用student(N)</span></span><br><span class="line">student(<span class="number">2</span>).name = <span class="string">&#x27;Cindy&#x27;</span>;</span><br><span class="line">student(<span class="number">2</span>).id = <span class="string">&#x27;23456&#x27;</span>;</span><br><span class="line">student(<span class="number">2</span>).grade = []; <span class="comment">% 略</span></span><br></pre></td></tr></table></figure></li><li><p>内置函数（部分见“cell类型的内置函数”）</p><ul><li><code>fieldnames(struct)</code>：返回n×1的cell数组，每列cell储存一个字段名（char数组）</li><li><code>isfield(struct, fieldname)</code>：检查fieldname字符数组是否为一个struct的字段名</li><li><code>isstruct(struct)</code>：struct、是否为一个结构体</li><li><code>rmfield(struct, fieldname)</code>：删除struct的fieldname字段</li><li><code>orderfields(struct)</code>：将struct的字段按ASCII字典序排序，返回新结构体</li><li><code>structfun(function_handle, scalar_struct)</code>：将函数作用于标量结构体的每个字段</li></ul></li></ul><h4 id="4-5-Cell"><a href="#4-5-Cell" class="headerlink" title="4.5 Cell"></a>4.5 Cell</h4><ul><li><p>定义方式（共3种，前两种也是赋值方式）：普通索引引用、元胞引用、直接书写</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 普通索引（说明m×n的cell实际由1×1的cell组合而成）</span></span><br><span class="line">A(<span class="number">1</span>, <span class="number">1</span>) = &#123;[<span class="number">1</span> <span class="number">4</span> <span class="number">3</span>; <span class="number">3</span> <span class="number">4</span> <span class="number">2</span>]&#125;;</span><br><span class="line">A(<span class="number">1</span>, <span class="number">2</span>) = &#123;<span class="string">&#x27;Anne Smith&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 元胞引用</span></span><br><span class="line">A&#123;<span class="number">1</span>, <span class="number">1</span>&#125; = [<span class="number">1</span> <span class="number">4</span> <span class="number">3</span>; <span class="number">3</span> <span class="number">4</span> <span class="number">2</span>];</span><br><span class="line">A&#123;<span class="number">1</span>, <span class="number">2</span>&#125; = <span class="string">&#x27;Anne Smith&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 直接书写</span></span><br><span class="line">A = &#123;<span class="string">&#x27;Anne Smith&#x27;</span>, [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]&#125;;</span><br></pre></td></tr></table></figure></li><li><p>容器的内部机理：实际上每个entry都有指向数据空间的指针，这样使得不同大小数据能存于同一个cell中</p></li><li><p>内置函数</p><ul><li><code>cell2mat(cell)</code>：将cell转为numeric数组，拼接方式按所处在cell中位置为准。<strong><u>注意：cell的entries必须全是numeric标量/“对应位置同型”numeric数组</u></strong></li><li><code>num2cell(A)</code>：将数组每个元素都作为一个元胞，转换为cell</li><li><code>mat2cell(A, dim1List, dim2List, ...)</code>：将mat按每个维度上“元素数量划分列表“转换为cell</li><li><code>cell2struct(cell, fields, dim)</code>：将cell转为结构体。</li><li><code>struct2cell(struct)</code>：…</li><li><code>cellplot(cell)</code>：用figure显示cell的抽象关系</li><li><code>iscell(cell)</code>：是否为cell类型</li></ul></li></ul><h4 id="4-6-Table"><a href="#4-6-Table" class="headerlink" title="4.6 Table"></a>4.6 Table</h4><ul><li>地位：精简行为的结构体，可以和*.csv、数据库等关联，数据处理中比结构体常用</li><li>定义：table构造函数<ul><li><code>tb = table(record1_arr, record2_arr, ...recordN_arr, &#39;VariableNames&#39;, name_cell)</code></li><li>其中，recond1~N_arr都应该是n×1的数组/cell，而name_cell应该是1×N的cell（表的直观印象）</li><li>不指定name_cell时，会按照变量名来记录</li></ul></li><li>类型转换函数<ul><li><code>array2table(array, &#39;VariableNames&#39;, name_cell);</code>  其中array支持符合形状的cell、数组等</li><li><code>table2cell(table)</code>：表格转cell，不包含表头</li></ul></li><li>与结构体一样，直接访问字段名以获得数据（组）：<code>table.FieldName</code></li></ul><h4 id="4-7-Categorial"><a href="#4-7-Categorial" class="headerlink" title="4.7 Categorial"></a>4.7 Categorial</h4><ul><li>地位：类似C++的enum枚举类型，储存有限类型的数据，相较于cell类型，可以规定元素间的大小同时保留易懂的名字，同时意味着能识别相同内容、去重；</li><li>定义：<code>categorial(array)</code>：array可以是几乎所有组：numeric array、logical array、cell array等；</li><li>展示拥有的分类（可用于去重）：<code>categories(categorial_array)</code></li><li>可以用于table数据类型中</li></ul><h4 id="4-8-File-Access"><a href="#4-8-File-Access" class="headerlink" title="4.8 File Access"></a>4.8 File Access</h4><ul><li>save &amp; load：<code>save fileName.mat [variable(s)];  load(&#39;fileName.mat&#39;);</code><ul><li>save未指明variable(s)，则保存全工作区变量</li></ul></li><li>针对table的读写：writetable &amp; readtable<ul><li><code>writetable(table, fileName)</code>：将表变量写入文件，支持类型：*.csv,*.txt, *.xls, *.xlsx, *.dat等</li><li><code>tb = readtable(fileName, &#39;Format&#39;, &#39;...&#39;);</code>：从文件（支持类型同writetable）中读表变量，其中，’Format’的value是格式化字符串，指定每一字段的格式（%s字符向量，%u uint32，%f float64 双精度浮点数，与C++不同）</li></ul></li><li>针对table的大数据量的读写：parquetwrite &amp; parquetread（支持后缀*.parquet，snappy压缩方案）<ul><li><code>parquetwrite(fileName, table)</code></li><li><code>tb = parquetread(fileName);</code></li></ul></li></ul><h3 id="Chapter5-Plotting"><a href="#Chapter5-Plotting" class="headerlink" title="Chapter5 Plotting"></a>Chapter5 Plotting</h3><h4 id="5-1-Basic-Plotting"><a href="#5-1-Basic-Plotting" class="headerlink" title="5.1 Basic Plotting"></a>5.1 Basic Plotting</h4><blockquote><p>知识补充：Matlab中的绘图机制以面向对象为核心，<strong>并把控件对象空间包含关系看作继承关系</strong></p><p>Figure类 -&gt;（包含有）Axes类 -&gt; {Line类，Text类，Surface类…} </p><p>对应：图窗对象（Figure类）、坐标轴对象（Axes类）、函数点集（Line类）、添加文字（Text类）…</p><p><strong>常用内置变量：gca（当前正在编辑的axes对象），gcf（当前正在编辑的figure对象）</strong></p></blockquote><ul><li><p>Basic Commands：基本绘图指令；<strong><u>以下命令默认指定当前figure、当前坐标轴等信息</u></strong></p><ul><li><code>line_obj = plot(x, y, &#39;str&#39;)</code>：’str’={Data_markers, Line_types, Colors}</li><li><p><code>[line_objs] =  plot(x1,y1, str1, x2, y2, str2, ...)</code></p></li><li><p><code>hold on/off</code>：have both plots in one figure</p></li><li><p><code>legend_obj = legend(&#39;name1&#39;, &#39;name2&#39;,...)</code>：按图线构造顺序标记</p></li><li><p><code>title_obj = title(str)</code></p></li><li><p><code>?label_obj = ?label(str)</code>：？可取x，y，z</p></li><li><p><code>text_obj = text(x_pos, y_pos, LaTex_str, &#39;Interpreter&#39;, &#39;latex&#39;)</code>：插入LaTex行公式</p></li><li><p><code>annotation_obj  = annotation(&#39;arrow&#39;, &#39;X&#39;, [from,to], &#39;Y&#39;, [from,to])</code>：插入箭头标识</p></li></ul></li><li><p>Figure Adjustment：实质是调整控件对象的属性</p><blockquote><p><code>set(obj, ‘attrName’, attrVal)</code>：修改对象的属性名对应的属性值</p><p><code>get(obj)</code>：得到对象的所有属性和对应值（字典形式，一个键值对一行）</p><p><code>get(obj, &#39;attrName&#39;)</code>：多用于获得对象的多级属性</p><p><code>del(obj)</code>：提前删除对应对象</p><p>另外的修改属性方式：<code>obj_attr_dict.attrName = attrVal;</code>（必须是对象字典才能用）</p><ul><li>拿到对象字典两种方式：get()/直接将对象赋给一个新变量，Matlab会给变量赋字典，而非对象本身</li></ul></blockquote><ul><li>Font、Font Size：一般有显示文字的控件都有此属性<ul><li>属性名：FontName <strong>[字符数组]</strong>、FontSize <strong>[numeric]</strong>（驼峰命名）</li></ul></li><li>Line Width、Line Style：Line对象属性<i>（可以在plot中以“Name-Value”方式指定）</i><ul><li>属性名：LineWidth <strong>[numeric]</strong>、LineStyle <strong>[字符数组]</strong></li></ul></li><li>Marker Size、Marker Colors：Line对象属性（此属性属于Marker子对象）<ul><li>属性名：MarkerEdgeColor <strong>[同Color的类型]</strong>、MarkerFaceColor、MarkerSize <strong>[numeric]</strong></li></ul></li><li>Axis Limit：Axes对象属性<ul><li>属性名：XLim、YLim（、ZLim）<strong>[1×2 numeric 数组]</strong></li></ul></li><li>Axis Label’s Name：Axes对象的二级属性<ul><li>属性名：XLabel.String、YLabel.String（、ZLabel.String）<strong>[string对象 或 char数组]</strong></li></ul></li><li>Tick Position：Axes对象属性<ul><li>属性名：XTick、YTick（、ZTick）<strong>[1×n numeric 数组]</strong></li></ul></li><li>Tick Label：Axes对象属性<ul><li>属性名：XTickLabel、YTickLabel（、ZTickLabel）<strong>[字符数组 构成的1×n的cell，标量numeric数组也可，底层会转换mat2cell、num2str]</strong></li><li>注：在此属性中，‘p’字符指代了$\pi$字符</li></ul></li><li>Color：大部分对象都具有此属性<ul><li>属性名：Color <strong>[字符数组（颜色字母/十六进制字符）/ 1×3 numeric数组（RGB矩阵）]</strong></li></ul></li></ul></li><li><p>Multiple Figures：多图窗使用（position参数不常使用，略）</p><ul><li>主动创建：<code>fig_obj = figure(&#39;Name&#39;, &#39;标题名称&#39;, &#39;NumberTitle&#39;, &#39;窗口自动编号：on/off&#39;);</code></li><li>切换到指定窗口作为当前编辑窗口：<code>figure(&#39;Name&#39;或Number（自动编号开启时）);</code></li></ul></li><li><p>Several Plots in One Figure：子图使用</p><ul><li>切换到指定子图（同时就是创建）：<code>subplot(m, n, N);</code>：m总列数，n总行数，N按行编号的子图</li></ul></li><li><p>Axis State Adjustment：坐标轴状态调整（关键字法）</p><ul><li><code>axis/box/grid off/on</code></li><li><code>axis normal</code></li><li><code>axis square</code>：坐标轴显示部分呈正方形</li><li><code>axis equal</code>：横纵（竖）轴标度相等（数据-长度比例对应）</li><li><code>axis equal tight</code>：使坐标轴limit适配数据最值</li><li><code>axis ij</code>：坐标轴原点置于左上角</li><li><code>axis xy</code>：坐标轴原点置于左下角</li></ul></li></ul><h4 id="5-2-Advanced-Plotting"><a href="#5-2-Advanced-Plotting" class="headerlink" title="5.2 Advanced Plotting"></a>5.2 Advanced Plotting</h4><ul><li><p>Purpose versus Type</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="pic/adv_purpose.png" height="450"></p></li><li><p>Commands: Global Color Adjustment</p><ul><li><code>colormap(RGBMatrix/Built-in-Name)</code>：指定RGB矩阵作为当前配色方案（适用于所有含有闭合面积的图像中）；内置名”jet”, “hot”, “cool”, “gray”, “winter”, “summer”, “autumn”, “parula”, “prism”；</li><li><code>colorbar(&#39;southoutside&#39;)</code>：在规定位置显示颜色-值条；</li></ul></li><li><p>Commands: Analysis Gragh</p><ul><li><p><code>loglog(...)</code>：作双对数轴图；参数使用方法几乎完全与plot相同；</p></li><li><p><code>semilogx(...) &amp; semilogy(...)</code>：作单对数轴（含有的字母即为对数轴），参数方法同上；</p></li><li><p><code>yyaxis left/right;</code>：关键字方法，声明使用双y轴，此命令可以切换当前编辑的y轴；</p></li><li><p><code>histogram(X, nbins/edges)</code>：绘制频度直方图（nbins指定分块数量，edges向量指定边缘，边缘包含左边，不包含右边，末尾分组两边都包含；当不填nbins、edges时自动调整）</p></li><li><p><code>histogram(CategorialArray, nbins/edges)</code>：为分类数组统计直方图</p><p><strong><u>直方图（histogram）对象较于前面的Line对象的属性有所不同（以下列举属性名，提示：属性可以用到时，再在程序中disp查询，下略</u></strong>：</p><ul><li>Data：直方图源数据；</li><li>NumBins、BinWidth：实际分段数、实际分段宽度；</li><li><p>BinLimits：[1×2 numeric数组] 实际的分块边界数组；</p></li><li><p>Values：[1×n numeric数组] 直方图的分段数据，可以用来数据分段；</p></li><li>FaceColor、EdgeColor：[类型同Color] 直方图的面颜色、边缘颜色；</li></ul></li><li><p><code>bar(Y, [&#39;stacked&#39;])</code>：Y为向量：为每一个元素创建一个条形，高度为其值，横轴名称为排名数字；Y为矩阵时，一列作为一类数据，一行数据作平行比较，最后一个参数指明是否以堆栈形式显示；</p></li><li><p><code>bar(ticks_arr/categorial, Y, [&#39;stacked&#39;])</code>：作用同上，第一个参数指定横轴（categorial数组可以从大到小匹配、普通数组/字符数组cell只能按索引对齐）；</p></li><li><p><code>bar3(...)</code>：参数同bar，只是将前面的一行平行比较的数据拉到另一个维度比较，支持 ‘group’、‘stacked’参数；</p></li><li><p><code>barh(...)</code>：参数类同bar，只是将图数据展示在水平方向上（horizontal）</p></li><li><p><code>pie(X/categorial, [explode], [labels])</code>：X为一维向量/分类数组（sum(X)＜1，值即面积，展示一部分；sum(X)＞1，面积为比例）；explode为同型向量，指明裂开的部分；labels也为同型向量，可以给定名称；</p></li><li><p><code>polar(thetaVector, RVector)</code>：作极坐标图；</p></li><li><p><code>stairs(y)</code>：台阶图；</p></li><li><p><code>stem(y)</code>：枝干图；</p></li><li><p><code>boxplot(x, [labels], [&#39;Notched&#39;, &#39;on&#39;])</code>：箱线图（含中位数、上下四分位数、离群值显示），可以指定是否为缺口箱线图，labels可以是字符数组cell，也可以是数组；</p></li><li><p><code>errorbar(x, y, err)</code>：误差线图；</p></li><li><p><code>imagesc(matrix)</code>：平面颜色显示矩阵值；</p></li></ul></li><li><p>Commands: 3D Plot</p><ul><li><code>plot3(x1, y1, z1, ..., xN, yN, zN, ...)</code>：”Name-Value”参数几乎与plot相同（参数方程、普通方程皆可）；</li><li><code>mesh(x, y, z) &amp; surf(x, y, z)</code>：都能绘出3D网状图，不过mesh是网格（FaceColor透明），surf是平面（FaceColor不透明，可以指定EdgeColor透明）；</li><li><p><code>[C, h] = contour(x, y, z)</code>：基于立体图生成等高线图（参数几乎同mesh、surf）；返回两个参数，第一个为绘制点集，第二个为对应高度数组；</p><ul><li><code>clabel(C, h)</code>：专门对等高线图标记的命令；</li></ul></li><li><p><code>[C, h] = contourf(x, y, z)</code>：上色的等高线图；</p></li><li><code>meshc(x, y, z) &amp; surfc(x, y, z)</code>：组合等高线图的surf和mesh；</li><li><code>[X, Y, Z] = sphere(R)</code>：生成球；</li></ul></li></ul><h3 id="Chapter6-Numeric-Differentiation-amp-Integration"><a href="#Chapter6-Numeric-Differentiation-amp-Integration" class="headerlink" title="Chapter6 Numeric Differentiation &amp; Integration"></a>Chapter6 Numeric Differentiation &amp; Integration</h3><h4 id="6-1-Polynomial-Function"><a href="#6-1-Polynomial-Function" class="headerlink" title="6.1 Polynomial Function"></a>6.1 Polynomial Function</h4><ul><li>多项式表示法：行向量（最后为$x^{0}$项系数，从右向左一次递增，不得省略）:$9x^{3}+3x+7$ =&gt; [9,0,3,7]；</li><li>多项式求值：<code>y = polyval(pVector, x)</code>：求多项式在x数组每个元素上的值；</li><li>多项式求导：<code>yd = polyder(pVector)</code>：对多项式关系式求导；</li><li>卷积与多项式乘法：<strong><u>两个向量的卷积与这两个向量对应的两个多项式乘积结果对应向量相等</u></strong><ul><li><code>conv(pVector1, pVector2)</code>：两个向量的卷积（两个多项式乘法）</li></ul></li><li>多项式积分（含初值）：<code>polyint(pVector, f(0))</code>；给定的f(0)即为多项式常数；</li><li>多项式求根：<code>roots(pVector)</code>;</li></ul><h4 id="6-2-Numerical-Differentiation（数值微分）"><a href="#6-2-Numerical-Differentiation（数值微分）" class="headerlink" title="6.2 Numerical Differentiation（数值微分）"></a>6.2 Numerical Differentiation（数值微分）</h4><ul><li>一阶差分运算<code>diff(vector)</code>：计算vector相邻元素之差的向量（返回少一个元素个数的差分向量）；</li><li>一阶数值微分近似计算：只要差分运算的向量元素间足够接近，则差分可以对函数微分作近似数值计算；<ul><li>举例：<code>x = 0:0.05:pi;  y = sin(x);  m = diff(y)./diff(x);</code>则m向量为各个点间的导数值点；</li><li>注意：求导的结果向量比输入向量少一个元素，记得绘图时舍弃一个点再绘图；</li></ul></li><li>高阶数值微分近似计算：多个微分共用x向量；</li></ul><h4 id="6-3-Numerical-Integration（数值积分）"><a href="#6-3-Numerical-Integration（数值积分）" class="headerlink" title="6.3 Numerical Integration（数值积分）"></a>6.3 Numerical Integration（数值积分）</h4><ul><li><p>Midpoint Rule（中间点积分法）：$\int_{a}^{b}{f(x)dx}\approx h\sum_{i=0}^{n-1}f(x_{i})$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 以sin(x)从0~1的近似数值积分为例</span></span><br><span class="line">a = <span class="number">0</span>; b = <span class="number">1</span>; bins = <span class="number">500</span>; s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = (b-a)/(<span class="number">2</span>*bins):(b-a)/bins:(<span class="number">1</span>-(b-a)/(<span class="number">2</span>*bins))</span><br><span class="line">    s += <span class="built_in">sin</span>(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">s *= (b - a) / bins;</span><br><span class="line"><span class="comment">% 以上过程可以用sum()更快：</span></span><br><span class="line">midP = (x(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>)+x(<span class="number">2</span>:<span class="keyword">end</span>))./<span class="number">2</span>;</span><br><span class="line">y = <span class="built_in">sin</span>(midP); s = sum(y * (b-a)/bins);</span><br><span class="line"><span class="comment">% s 即为所求</span></span><br></pre></td></tr></table></figure></li><li><p>Trapezoid Rule（梯形法则/梯形积分法）：$\int_{a}^{b}{f(x)dx}\approx h[f(a)+f(b)+\dfrac{1}{2}\sum_{i=1}^{n-1}{f(x_{i})}]$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 以sin(x)从0~1的近似数值积分为例</span></span><br><span class="line">a = <span class="number">0</span>; b = <span class="number">1</span>; bins = <span class="number">500</span>; s = <span class="number">0</span>;</span><br><span class="line">s += <span class="built_in">sin</span>(a) + <span class="built_in">sin</span>(b);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = (b-a)/bins:(b-a)/bins:(<span class="number">1</span>-(b-a)/bins)</span><br><span class="line">    s += <span class="number">0.5</span> * (<span class="built_in">sin</span>(<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">s *= (b - a) / bins;</span><br><span class="line"><span class="comment">% s 即为所求</span></span><br></pre></td></tr></table></figure><blockquote><p>也可使用：<code>s = h * trapz(y);</code>其中h为y的取点间隔；</p></blockquote></li><li><p>Simpson’s Rule（辛普森法则/辛普森积分法）：$\int_{a}^{b}{f(x)dx}\approx \dfrac{h}{3}[f(a)+f(b)+4\sum_{i=1}^{2n-1}f(x_{i})+2\sum_{i=2}^{2n-2}f(x_{i})]$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 以sin(x)从0~1的近似数值积分为例</span></span><br><span class="line">a = <span class="number">0</span>; b = <span class="number">1</span>; bins = <span class="number">500</span>; s = <span class="number">0</span>;</span><br><span class="line">x = a:(b-a)/bins:b; y = <span class="built_in">sin</span>(x);</span><br><span class="line">s = (b-a)/(<span class="number">3</span>*bins)*(y(<span class="number">1</span>)+y(<span class="keyword">end</span>)+<span class="number">2</span>*sum(y(<span class="number">3</span>:<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>))+<span class="number">4</span>*sum(y(<span class="number">2</span>:<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>)));</span><br><span class="line"><span class="comment">% s 即为所求</span></span><br></pre></td></tr></table></figure></li><li><p>包装好的数值积分函数</p><ul><li>辛普森法：<code>quad(function_handle, x_start, x_end);</code></li><li>一阶数值积分<code>integral(function_handle, x_start, x_end);</code></li><li>二阶数值累次积分：<code>integral(function_handle, x_start, x_end, y_start, y_end);</code></li><li>三阶数值累次积分：<code>integral3(function_handle, x_start, x_end, y_start, y_end, z_start, z_end);</code></li><li>注：重积分仅介绍符号运算，见符号运算章节</li></ul></li></ul><h3 id="Chapter7-Equation-s-Solving-amp-Symbolic-Approach"><a href="#Chapter7-Equation-s-Solving-amp-Symbolic-Approach" class="headerlink" title="Chapter7 Equation(s) Solving &amp; Symbolic Approach"></a>Chapter7 Equation(s) Solving &amp; Symbolic Approach</h3><h4 id="7-1-Symbolic-Representation"><a href="#7-1-Symbolic-Representation" class="headerlink" title="7.1 Symbolic Representation"></a>7.1 Symbolic Representation</h4><blockquote><p>Matlab 中的新数据类型：sym符号类型，可以组成sym数组；</p><p>定义的：<code>syms x y(x);</code>中x是sym类型，y是symfun类型；等式<code>sin(x) == y</code>也是symfun类型，条件 <code>y(0) == 1</code>也是symfun类型；多个表达式<code>conds = [x == 0, y(1) == 0];</code>的conds是1×2 symfun数组；</p></blockquote><ul><li>Symbolic Variables Definition（<strong>Independent</strong>）：<code>syms a b c...; 或 sym(&#39;x&#39;);</code></li><li><p>Symbolic Variables Definition（<strong>Dependent</strong>，常用于解方程中）：<code>syms z(x, y);</code></p></li><li><p>Symbolic Beautify：<code>pretty(sym_expr)</code></p></li><li>具体值代入符号：<code>subs(sym_expr, [target_var], value);</code>，当sym_expr为单变量时，target_var可省略</li></ul><h4 id="7-2-Symbolic-Plotting"><a href="#7-2-Symbolic-Plotting" class="headerlink" title="7.2 Symbolic Plotting"></a>7.2 Symbolic Plotting</h4><ul><li><code>fplot(function_handle, [left, right], Name-Value)</code>：按符号绘图；</li><li><code>fplot3、fsurf、fcontour</code>：同理</li></ul><h4 id="7-3-Symbolic-Differentiation-amp-Integration"><a href="#7-3-Symbolic-Differentiation-amp-Integration" class="headerlink" title="7.3 Symbolic Differentiation &amp; Integration"></a>7.3 Symbolic Differentiation &amp; Integration</h4><ul><li>Symblic Differentiation：<code>fprime = diff(sym_expr, [arg_sym, n])</code>：对于自变量arg_sym的n阶导数，允许计算偏导数，sym_expr为符号表达式；</li><li>Symbolic Integration（Indefined Intergration, 但默认简单的初值）：<code>fs = int(sym_expr, [arg_sym]);</code></li><li>重积分（几重添几个int，右边以二重积分为例）：<code>int(int(sym, arg), arg)</code></li><li><strong><u>注：无法求解符号积分时，请使用“数值积分”求近似数值</u></strong>；</li></ul><h4 id="7-4-Normal-Equation-s-Solving-Root-Finding"><a href="#7-4-Normal-Equation-s-Solving-Root-Finding" class="headerlink" title="7.4 Normal Equation(s) Solving: Root Finding"></a>7.4 Normal Equation(s) Solving: Root Finding</h4><blockquote><ol><li><p>友情提示：线性方程组可以使用矩阵求解、多项式请用6.1的roots命令，可能更快</p></li><li><p>数据类型提示：无论是这里的solve，还是接下来的dsolve，如果求解有多个结果/变量，返回结果是sym结构体，使用：结果变量.sym_name获得对应sym_name的解析式；</p></li></ol></blockquote><ul><li><p>求解符号方程：<code>S = solve(eqn, target_var)</code>；</p></li><li><p>求解符号方程组（传入eqns、target_vars为sym数组）：<code>S = solve(eqns, target_var/target_vars)</code>；</p></li><li><p><strong><u>注：无法求解符号方程时，先绘图找到大致范围，使用数值近似解</u></strong><code>V = vpasolve(eqn, target_var, [left, right]);</code></p></li><li><p>解不等式（组）：语法与上述相同，只是解S的结构不同：有parameters（结果是范围，参数方程）、conditions（不等式解）等；</p></li></ul><h4 id="7-5-Differential-Equation-s-Solving"><a href="#7-5-Differential-Equation-s-Solving" class="headerlink" title="7.5 Differential Equation(s) Solving"></a>7.5 Differential Equation(s) Solving</h4><blockquote><p>注：纯积分方程可以在7.4中由solve求解；微分、微积分方程可由本部分的dsolve求解。</p></blockquote><ul><li><p>求解符号微分方程：<code>S = dsolve(eqn, cond)</code></p><ul><li><p>举例：<code>dsolve(diff(y, t, 2) == a*y, [y(0) == 5, subs(diff(y, t), t, 0) == 1]);</code></p><p>是给定初值的微分方程：$\dfrac{d^{2}y}{dt^{2}}=ay,\quad y|_{t=0}=5,\quad \dfrac{dy}{dt}|_{t=0}=1$ （其中a为常数）的解</p></li></ul></li></ul><h3 id="Chapter8-Linear-Algebra-Tools"><a href="#Chapter8-Linear-Algebra-Tools" class="headerlink" title="Chapter8 Linear Algebra Tools"></a>Chapter8 Linear Algebra Tools</h3><ul><li>矩阵用于求解线性方程组：结合”Array Operations“和线性代数知识即可，略；</li></ul><blockquote><p>提示：运行后面的矩阵操作前，建议运算这三个参数以评估矩阵的状态</p><p>知识补充：矩阵A条件数$\kappa(A)$用于衡量线性方程$Ax=b$的稳定程度，表征系统解$x$在参数A受扰动时是否会受到剧烈影响的情况。数学证明$\kappa(A)=\dfrac{\sigma_{max}}{\sigma_{min}}$，可以认为“构成A的数据组向量两两间越接近共线，即越线性相关，A越易受到扰动”，此类扰动容易导致LU分解的数值不稳定、方程解不稳定。<strong><u>（条件数越小越稳定）</u></strong></p></blockquote><ul><li>求逆、求秩、求条件数$\kappa$：<code>inv(matrix)</code>、<code>rank(matrix)</code>、<code>cond(matrix)</code></li><li>Gaussian Elimination（使用初等行变换）：<code>R = rref(matrix);</code></li><li>LU Factorization：<code>[L, U] = lu(matrix);</code></li><li>LUP Factorization：<code>[L, U, P] = lu(matrix);</code></li><li>Cholesky Factorization：<code>U = chol(matrix);</code></li></ul><blockquote><p>知识补充：矩阵LU分解可用于：求线性方程组、求逆矩阵、求行列式</p><p>使用LU分解条件：满秩方阵A</p><p><strong>警告：数值不稳定，一般改用LUP分解：$PA=LU$，或者在A为对称正定阵时，使用Cholesky Factorization（LU分解的特例、变形：$A=U^{T}U$），实现数值稳定</strong></p><p>LU分解操作方法：A通过<strong>左乘</strong>若干初等矩阵得到上三角矩阵U，左边的初等矩阵组合一定为下三角矩阵L（也可以将左边矩阵移动到等式右边，再把这个新的下三角矩阵称为L）</p><p>LU分解法求线性方程组：$L\underbrace{Ux}_{y}=b$</p><p>LU分解法求逆矩阵：$A^{-1}=U^{-1}L^{-1}$</p><p>LU分解求行列式：$|A|=|L||U|$</p></blockquote><ul><li>QR Decomposition：<code>[Q, R] = qr(matrix);</code></li></ul><blockquote><p>知识补充：矩阵正交三角形（QR）分解，求一般矩阵全部特征值的最有效并广泛应用的方法。</p></blockquote><ul><li>SVD（Singular Value Decomposition）：<code>[U, S, V] = svd(matrix);</code></li></ul><blockquote><p>知识补充：矩阵奇异值分解（SVD），相较于普通方阵A可以实现的特征分解（$A=W\Sigma W^{T}$），非方阵A也可以由数学证明，按特征值分解为：$B=U\Sigma V^{T}$，其中$U$是$AA^{T}$方阵的特征向量张成矩阵，这些特征向量称<strong>左特征值向量</strong>；$V$是$A^{T}A$方阵的特征向量张成矩阵，这些特征向量称<strong>右特征向量</strong>（不难得出U、V为正交阵）；$\Sigma$为奇异值在对角线排列的矩阵，<strong>由数学证明，奇异值是特征值的平方根</strong>。</p><p>较繁，求解方法请参考各个线性代数书籍。</p></blockquote><ul><li><p>包装好的求特征值和特征向量：<code>[V, D] = eig(matrix);</code></p><ul><li>其中V为特征值在对角元的对角矩阵；D为对应位置的特征向量张成的矩阵；</li></ul></li><li><p>矩阵指数（Matrix Exponential）：<code>Y = expm(matrix);</code></p></li></ul><blockquote><p>矩阵指数的意义：www.bilibili.com 搜索“矩阵指数”-3Blue1Brown</p><p>简单认为：应用层面上<strong>有助于解决线性微分方程组</strong></p><p>类似于$\dfrac{d}{dt}y=ry$的解是$y=r_{0}e^{rt}$，理解为“如果y增长率为自身的r倍，则y是变化因子$e^{rt}$作用于初值$r_{0}$得到的结果”，$\dfrac{d}{dt}\begin{bmatrix}x(t)\\y(t)\end{bmatrix}=\begin{bmatrix}a &amp; b \ c &amp; d \end{bmatrix}\begin{bmatrix}x(t)\\y(t)\end{bmatrix}$表示向量$\begin{bmatrix}x(t)\\y(t)\end{bmatrix}$在空间中的变化率为初值$\begin{bmatrix}x(0)\\y(0)\end{bmatrix}$在增长因子$e^{\begin{bmatrix}a&amp;b\\c&amp;d\end{bmatrix}t}$作用下的结果：$\begin{bmatrix}x(t)\\y(t)\end{bmatrix}=\begin{bmatrix}x(0)\\y(0)\end{bmatrix}e^{\begin{bmatrix}a&amp;b\\c&amp;d\end{bmatrix}t}$</p><p>结论：$\dfrac{d}{dt}\overrightarrow{v(t)}=M·\overrightarrow{v(t)}$ 的解是：$\overrightarrow{v(t)}=\overrightarrow{v_{0}}·e^{Mt}$，其中M为与$\overrightarrow{v(t)}$同维的矩阵，$e^{M}$计算方法是其定义：代入“泰勒级数”：$e^{Mt}=E+Mt+M^{2}\dfrac{t^{2}}{2!}+…+M^{n}\dfrac{t^{n}}{n!}+…$.</p></blockquote><h3 id="Chapter9-Statistics-amp-Data-Analysis"><a href="#Chapter9-Statistics-amp-Data-Analysis" class="headerlink" title="Chapter9 Statistics &amp; Data Analysis"></a>Chapter9 Statistics &amp; Data Analysis</h3><h4 id="9-1-Desciptive-Statistics"><a href="#9-1-Desciptive-Statistics" class="headerlink" title="9.1 Desciptive Statistics"></a>9.1 Desciptive Statistics</h4><ul><li><p>最大值、最小值：<code>max(...)、min(...)</code>（前面介绍过）</p></li><li><p>平均数、中位数、众数：<code>mean(A, [&#39;all&#39; / dim])、median(...)、mode(...)</code>（后面两个参数同mean，之前介绍过）</p></li><li><p>分位数：<code>prctile(X, p, [&#39;all&#39; / dim])</code>，其中p∈[0, 100]，函数对X为向量、矩阵、多维数组时的行为和前面的函数一样；</p></li><li><p>标准差、方差：<code>s = std(X); v = var(X);</code>同理</p></li><li><p>数据偏度（skewness）：<code>y = skewness(X);</code></p><blockquote><p>知识补充：数据偏度衡量数据概率密度分布的偏移程度，定义为样本三阶标准化矩：$Skew(X)=E[(\dfrac{X-\mu}{\sigma})^{3}]$当 平均数＜中位数＜众数时，数据分布为“左偏分布”（Left-Skewed，但图形上向右倾斜，Skewnewss＜0）；当众数＜中位数＜平均数时，数据分布为“右偏分布”（Left-Skewed，但图形上向左倾斜，Skewnewss＞0）；正态分布为标准的“对称分布”，偏度为0.</p></blockquote></li><li><p>数据峰度（Kurtosis）<code>y = kurtosis(X);</code></p><blockquote><p>知识补充：数据峰度表征概率密度分布在平均值处峰值高低大小（也反映了分布曲线顶部的“尖锐程度”），定义为样本四阶标准化中心矩：$Kurt(X)=E[(\dfrac{X-\mu}{\sigma})^{4}]$；相对于正态分布（Kurt=3），Kurt＜3时，瘦尾分布；Kurt＞3，厚尾分布。</p></blockquote></li></ul><h4 id="9-2-Inferential-Statistics"><a href="#9-2-Inferential-Statistics" class="headerlink" title="9.2 Inferential Statistics"></a>9.2 Inferential Statistics</h4><ul><li>常用函数<ul><li><code>rand</code>：返回<code>X~U(0,1)</code>时随机变量X的任意值；</li><li><code>rand(n)</code>：n×n的矩阵，每个元素都是rand计算出的，相互独立；</li><li><code>rand(dim1, dim2, ...)</code>：生成多维随机矩阵（服从(0,1)均匀分布）；</li><li><code>randi(imax, n, [className])</code>：生成1~imax间均匀分布的伪随机数，可指定numeric类型；</li><li><code>randi(imax, dim1, dim2, ..., [className])</code>：同理；</li><li><code>randn(n)</code>：生成n×n矩阵，元素服从标准正态分布；</li><li><code>randn(dim1, dim2, ...)</code>：同理；</li><li><code>normrnd(mu, sigma, dim1, dim2, ...)</code>：生成规定大小随机矩阵，服从<code>N(mu, sigma^2)</code>；</li><li><code>exprnd(mu, dim1, dim2, ...)</code>：生成规定大小随机矩阵，服从均值为mu的指数分布；</li></ul></li></ul><blockquote><p>此章节等复习了概率论与数理统计再补充</p></blockquote><h3 id="Chapter10-Curve-Fitting-amp-Interpolation"><a href="#Chapter10-Curve-Fitting-amp-Interpolation" class="headerlink" title="Chapter10 Curve Fitting &amp; Interpolation"></a>Chapter10 Curve Fitting &amp; Interpolation</h3><blockquote><p><strong><u>概念辨析：拟合方法包括回归、插值、逼近等，本章介绍回归和插值</u></strong></p><p>插值一定会通过所有数据观测点，但回归不一定</p></blockquote><h4 id="10-1-Simple-Linear-Regression-单变量线性回归（最小二乘法）"><a href="#10-1-Simple-Linear-Regression-单变量线性回归（最小二乘法）" class="headerlink" title="10.1 Simple Linear Regression: 单变量线性回归（最小二乘法）"></a>10.1 Simple Linear Regression: 单变量线性回归（最小二乘法）</h4><ul><li>前提：在一组收集的数据中假设x-y线性相关，满足：$\hat{y_{i}}=\beta_0+\beta_1x_i$</li><li>最小二乘法（Least-squares Solution）原理：使平方和误差（Sum of Squared Errors，SSE）最小，即$SSE=\sum\limits_{i}\epsilon_i^2=\sum\limits_i(y_i-\hat{y_i})^2=\sum\limits_i(y_i-\beta_0-\beta_1x_i)^2$最小，求偏导、极值得结论；</li><li><p>多项式曲线拟合：<code>pVector = polyfit(xList, yList, order);</code> 其中order为指定拟合多项式的阶数；</p><ul><li>可以使用双输出参数：<code>[pVector, S] = polyfit(...);</code>，使用结构体S以便进行误差分析：<code>[y_fit, delta] = polyval(pVector, x, S);</code>，其中，95%预测区间为：<code>y_fit ± 2*delta</code>.</li></ul></li><li><p>散点图（除了plot/plot3作散点，此方法也可）：<code>scatter(x, y)、scatter3(x, y, z);</code></p><ul><li>散点常用后缀参数：“filled”，可使散点实心显示；</li></ul></li><li><p>变量线性相关性（correlation coefficient, 即最小二乘法中的“r值”，-1 ≤ r ≤ 1）：<code>corrcoef(x, y);</code></p></li><li><strong><u>注：通过数学处理，也可以解决大部分单变量非线性回归问题，例如拟合假设 $\hat{y}=b+alnx$ 可以将数据集x替换为lnx，继续进行线性拟合.</u></strong></li></ul><h4 id="10-2-Multiple-Linear-Non-Linear-Regression-多变量（非）线性回归"><a href="#10-2-Multiple-Linear-Non-Linear-Regression-多变量（非）线性回归" class="headerlink" title="10.2 Multiple Linear/Non-Linear Regression: 多变量（非）线性回归"></a>10.2 Multiple Linear/Non-Linear Regression: 多变量（非）线性回归</h4><ul><li><p>多元线性回归拟合：<code>[b, bint, r, rint, stats] = regress(y, X, [Alpha]);</code></p><ul><li><p>y：模型观测值（响应值）；</p></li><li><p>X：模型输入矩阵，要求第一列必须为全1列（以便软件处理模型常数）、接下来几列每列分别存放各个<strong><u>预测因式（不是自变量！！！）</u></strong>参数的取值向量（与y位置对应）</p><ul><li>预测因式：假设拟合的表达式为：$\hat{y}=\beta_0+\beta_1x_1+\beta_2x_2^2+\beta_3x_1x_2$，则预测因式为：$x_1$、$x_2^2$、$x_1x_2$，X矩阵应该是：<code>X = [ones(length(X1)) X1 X2.^2 X1.*X2];</code></li></ul></li><li><p>Alpha：显著性水平，用于设定100*（1-Alpha）%置信水平，默认0.05；</p></li><li><p>b：对应于X中预测因式的拟合系数组成的向量；</p></li><li><p>bint：系数估计值95%置信区间的矩阵（n(b)×2数组，每行表示该拟合点置信边界的上、下界）；</p></li><li><p>r：拟合-实际点对应残差向量；</p></li><li><p>rint：用于诊断离群值的区间（n(X)×2数组，每行表示该观测点的离群区间，如果这个区间不包含0，则对应残差在置信区间之外，是离群值）</p></li><li><p>stats：拟合评估向量 $[R^2, F, p, est]$</p></li></ul></li><li><p>非线性回归拟合：<code>beta = nlinfit(X, Y, modelFunc_handle, beta0); 或使用工具cftool();</code></p><ul><li><p>nlinfit原理：迭代最小二乘法估计</p></li><li><p>X、Y为数据列表，modelFunc_handle为模型函数指针，beta0为合适的迭代初值</p></li><li><p>modelFunc如何找，需要对数学模型非常熟悉，按曲线变化类型一个个试；</p><p><strong><u>如何得到合适的beta0？</u></strong></p></li><li><p>目标：越接近真实情况的参数越好（估计实际情况下模型参数大致是多少）</p><blockquote><p>法1：目测观测点估计法；</p><p>法2：代入几个数据点，使用solve/dsolve解出大致参数；</p><p>法3：在评估真实参数大致范围（越小越好）后，使用随机数生成；</p></blockquote></li></ul></li></ul><h4 id="10-3-Common-Interpolation"><a href="#10-3-Common-Interpolation" class="headerlink" title="10.3 Common Interpolation"></a>10.3 Common Interpolation</h4><blockquote><p>以下两个插值函数都具有外插值默认值，针对不同method有不同赋值方式，只需在method后给定默认外插值即可；</p><p>提示：可以对灰度图像矩阵进行插值；</p></blockquote><ul><li>一维数据插值（表查找）：<code>vectorQuery = interp1(x, y, xQuery, method);</code><ul><li>x：样本点；y：样本点对应观测值；</li><li>xQuery：查询点（一般查询内插值点）；</li><li>vectorQuery：查询结果值（估计）；</li><li>method：插值方法</li></ul></li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="pic/methods.png"></p><blockquote><p>注：method=’pchip’等价于命令pchip(…), Piecewise Cubic Hermite Interpolating Polynomial;   method=’spline’等价于命令spline(…), Cubic spline data interpolation;</p></blockquote><ul><li><p>补充相关函数：分段多项式（piecewise polynomial）</p><ul><li>生成分段多项式：<code>pp = mkpp(breakPointsV, pVectors);</code>（其中pp为结构体，可以被ppval读取）</li><li>分段多项式的值：<code>v = ppval(pp, x);</code></li><li>直线绘制：<code>line_obj = line([x_s, x_e], [y_s, y_e], [LineSpec]);</code><ul><li>用于绘制断点x=x0处的垂直虚线：<code>line([x0, x0], ylim或get(gca).YLim, &#39;--&#39;);</code></li></ul></li></ul></li><li><p>二维数据插值：<code>vQuery = interp2(X, Y, Z, XQuery, YQuery, method);</code></p><ul><li>X、Y、Z对应二维数据点及其值，XQuery、YQuery为内部查询点，vQuery为查询值；</li><li>同时支持高维数组填充插值：<code>Mq = interp2(M, k);</code>在每维度M的样本间分割k次插入值；</li><li>method：插值方式</li></ul></li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="pic/methods2D.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;Written by SJTU_XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Version: Matlab R2020b&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;References:&lt;/i&gt; &lt;a href=&quot;https://www.mathworks.com/help/matlab/&quot;&gt;MATLAB Documentation (mathworks.com)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://sjtuxhw.top/tags/Programming/"/>
    
    <category term="Matlab" scheme="https://sjtuxhw.top/tags/Matlab/"/>
    
    <category term="Math" scheme="https://sjtuxhw.top/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>CDN服务分析和推荐</title>
    <link href="https://sjtuxhw.top/2023/06/16/CDN%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90%E5%92%8C%E6%8E%A8%E8%8D%90/"/>
    <id>https://sjtuxhw.top/2023/06/16/CDN%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90%E5%92%8C%E6%8E%A8%E8%8D%90/</id>
    <published>2023-06-16T07:15:35.000Z</published>
    <updated>2023-09-19T05:17:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>请大家放心食用，不是广告，不恰饭。仅提供 CDN 服务的一些数据和行情的信息，供大家参考。</p><span id="more"></span><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>本人在几个月前维护博客网站的时候，总是发现进入博客页面的时间远远长于预料的时间。在服务器上搜索一番后，我发现很可能是因为博客上存放和展示的图片过多，并且很多图片的大小都在 1MB+；更何况我也没有对图片进行压缩和处理，所以在运营一段时间后，打开慢是一种必然现象。</p><p>没办法，只好自己去找 CDN（Content Delivery Network）来加快访客对于网页的访问速度。目前市面上提供 CDN 的企业种类繁多，真能让人看花了眼，尤其是对于我这种小白来说更是害怕。唉！在现在这个互联网时代，想要守好自己的钱袋子和自己的信息安全并不是一件容易的事。</p><h3 id="CDN-服务归纳"><a href="#CDN-服务归纳" class="headerlink" title="CDN 服务归纳"></a>CDN 服务归纳</h3><p>我前前后后找了几家看起来比较正规的 CDN 服务商（因为自己网站的资源和信息的安全还是要有点保障的，太差了可不行），信息罗列如下，评价部分可能带有一定主观色彩，请自行评估！想要直接看结论，戳<a href="#conclusion">这里🔗</a></p><h4 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h4><ul><li>费用：新用户连续 6 个月每月 50G 流量赠送；普通用户 100G（个人网站，如博客）17 元 / 月，500G 84 元 / 月；</li><li>描述：每月提供 10G 免费流量，结点数 10 ~ 20 左右，100G 购买起步；</li><li>口碑：国内大厂，稳定性和安全性有保障；</li></ul><h4 id="百度云"><a href="#百度云" class="headerlink" title="百度云"></a>百度云</h4><ul><li>费用：每月 10G 免费流量，超出的流量会回源处理，不会继续扣费；（<strong>收费项目项目貌似都是面向企业用户？</strong></li><li>描述：个人的加速结点比较少，联通、电信之类的结点，只有几个；</li><li>口碑：还不错，但百度似乎主业不是这个？</li></ul><h4 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h4><ul><li>费用：支持两种购买方式，<strong>按量付费和资源包购买</strong>；资源包 50G 每月 8.4 元，一次买越多，优惠越大；</li><li>描述：HTTP 流量和 HTTPS 流量需要分开购买（类型似乎分的很细？）支持境外流量；</li><li>口碑：国内大厂，这也是它的主营业务之一，安全性和稳定性没话说，我的一个服务器就是买阿里云的；</li></ul><h4 id="又拍云"><a href="#又拍云" class="headerlink" title="又拍云"></a>又拍云</h4><ul><li>费用：账户余额制，资源包、境外流量单独购买，大小和价格取决于购买量，可以自己指定购买天数；</li><li>描述：又拍云联盟<strong>每月10G 免费存储空间、15G 免费 CDN 流量</strong>，HTTP 和 HTTPS 皆可；加入联盟需要在页脚挂广告；<strong>可以自行添加防盗链、加密等功能</strong>；</li><li>口碑：后起之秀；服务贼快，响应时间 &lt; 20min</li></ul><h4 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h4><ul><li>费用：100G 起购买，100G 20元 / 月（最近有6.18大促，降到了15.4），<strong>不分开 HTTP 和 HTTPS</strong>，按 <code>HTTP:HTTPS = 1:1.15</code> 的比例扣费；</li><li>描述：每个月前 10G 流量免费，但仅有 HTTP；</li><li>口碑：还不错，据它自己说，为多家大公司提供 CDN 服务；</li></ul><h4 id="freeCDN"><a href="#freeCDN" class="headerlink" title="freeCDN"></a>freeCDN</h4><blockquote><p>注意识别，口碑不算优秀</p></blockquote><ul><li>费用：普通个人用户建议使用免费版；收费面向企业，300元 / 月；</li><li>描述：免费支持 HTTPS，无防盗链，免费的份额够用；</li><li>口碑：一般；</li></ul><h4 id="Cloudflare"><a href="#Cloudflare" class="headerlink" title="Cloudflare"></a>Cloudflare</h4><ul><li>费用：个人一般选免费版本，收费面向企业；</li><li>描述：对个人的免费力度极大，无限流量；</li><li>口碑：国外大厂，安全性有保障；可惜稳定性很差，对国内环境不算友好；</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><i id="conclusion">注：下表在2023年6月16日前收集</i></p><div style="text-align: center;"><span>表1 CDN 服务对照表</span></div><table>    <tr>        <td>服务商</td>        <td>腾讯云</td>        <td>百度云</td>        <td>阿里云</td>        <td>又拍云</td>        <td>七牛云</td>        <td>freeCDN</td>        <td>Cloudflare</td>    </tr>    <tr>        <td>费用</td>        <td>0.17 元/G/月</td>        <td>1590/年</td>        <td>0.168元/G/月</td>        <td>充值制</td>        <td>年包 0.2元/G</td>        <td>小型企业 300元/月</td>        <td>插件按月</td>    </tr>    <tr>        <td>口碑 &amp; 安全性</td>        <td>++++</td>        <td>+++</td>        <td>+++++</td>        <td>+++</td>        <td>+++</td>        <td>++</td>        <td>+++++</td>    </tr>    <tr>        <td>HTTPS流量</td>        <td>单独收费</td>        <td>单独收费</td>        <td>单独收费</td>        <td>不单独收费</td>        <td>单独收费</td>        <td>Free</td>        <td>Free</td>    </tr>    <tr>        <td>可白嫖</td>        <td>每月10G</td>        <td>每月10G</td>        <td>❌</td>        <td>每月10G+15G</td>        <td>10G HTTP</td>        <td>Totally free✅</td>        <td>Totally free✅</td>    </tr>    <tr>        <td>是否需要备案</td>        <td>是</td>        <td>是</td>        <td>是</td>        <td>是</td>        <td>是</td>        <td>是</td>        <td>否</td>    </tr>    <tr>        <td>稳定性</td>        <td>++++</td>        <td>++++</td>        <td>+++++</td>        <td>++++</td>        <td>++++</td>        <td>++</td>        <td>境外，较差</td>    </tr></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;请大家放心食用，不是广告，不恰饭。仅提供 CDN 服务的一些数据和行情的信息，供大家参考。&lt;/p&gt;</summary>
    
    
    
    <category term="Chat" scheme="https://sjtuxhw.top/categories/Chat/"/>
    
    
    <category term="CDN" scheme="https://sjtuxhw.top/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>一个FLAG</title>
    <link href="https://sjtuxhw.top/2023/06/16/%E4%B8%80%E4%B8%AAFLAG/"/>
    <id>https://sjtuxhw.top/2023/06/16/%E4%B8%80%E4%B8%AAFLAG/</id>
    <published>2023-06-16T02:34:15.000Z</published>
    <updated>2023-09-19T05:24:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近期末考试终于结束了，想到又能将自己的时间分配在自己需要的方面（例如写博客），又是一件令人振奋人心的事情！只可惜大学生的暑假竟然会被老师布置的作业充斥，这真是从未想到 😂</p><span id="more"></span><p>在前天最后一门考试结束后，我迅速进入放松状态，和室友打了整整两天的 MC（感觉有点放纵……于是，在导师的建议下，我得快速开始制定一些计划，防止我过于颓废 [doge].</p><p>咳咳，好的朋友们，我现在要立下一个大 flag：<strong>我将在暑假结束前完成我制定的所有计划和任务，鼓足干劲，绝不颓废！</strong></p><p>下定决心，以此博客为证！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近期末考试终于结束了，想到又能将自己的时间分配在自己需要的方面（例如写博客），又是一件令人振奋人心的事情！只可惜大学生的暑假竟然会被老师布置的作业充斥，这真是从未想到 😂&lt;/p&gt;</summary>
    
    
    
    <category term="Chat" scheme="https://sjtuxhw.top/categories/Chat/"/>
    
    
    <category term="Flag" scheme="https://sjtuxhw.top/tags/Flag/"/>
    
  </entry>
  
  <entry>
    <title>离散数学复习</title>
    <link href="https://sjtuxhw.top/2023/06/09/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
    <id>https://sjtuxhw.top/2023/06/09/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/</id>
    <published>2023-06-09T14:45:15.000Z</published>
    <updated>2023-09-19T05:12:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><i><u>本系列文章为作者复习离散数学过程中的知识点总结、速通，欢迎补充</u></i></p><p><i>written by SJTU-XHW</i></p><p><i>Reference: 清华大学出版社《数理逻辑与集合论（第二版）》《图论与代数结构》</i></p><p><i>提示：大段文字阅读，点击右侧齿轮图标，进入阅读模式体验更佳 ~ </i></p><span id="more"></span><hr><h2 id="Chapter-1-命题逻辑"><a href="#Chapter-1-命题逻辑" class="headerlink" title="Chapter 1 命题逻辑"></a>Chapter 1 命题逻辑</h2><h3 id="1-1-重要概念汇总"><a href="#1-1-重要概念汇总" class="headerlink" title="1.1 重要概念汇总"></a>1.1 重要概念汇总</h3><ul><li><p>命题的定义：能判断真假的陈述句；（真假性：命题的值）</p></li><li><p>命题分类：原子命题、复合命题（成分命题 + 联结词）</p></li><li><p>真值联结词：非（否定式）、且（合取式）、或（析取式）、如果则（蕴含式）、等价（等值式）；</p></li><li><p>命题变元：以真假为变域的变元；</p></li><li><p>真值函数：以真假为定义域、真假为值域的函数；</p></li><li><p>命题演算公式的定义：（通俗）由命题变元利用真值联结词构成的式子；</p><blockquote><p>命题变元是、公式的否定式是、两个公式的合取、析取式是；仅限于此；</p></blockquote></li><li><p>变元组：n元公式 α 含有不同命题变元 p1、p2、……、pn，称（p1, p2, …, pn）为 α 的变元组；</p></li><li><p>完全指派：变元组任一组确定值都称为 α 关于这个变元组的一个 ~；</p></li><li><p>部分指派：仅对变元组部分变元赋以确定值，另外一部分不赋值（X），称……；</p><blockquote><p>完全、部分指派举例：(p, q, r, s) = (T, T, F, T)；(p, q, r, s) = (T, X, X, F)</p></blockquote></li><li><p>成真指派、成假指派；</p><p><strong>一个公式的性质</strong></p></li><li><p>重言式：该公式的所有完全指派都是成真指派；</p></li><li><p>矛盾式：该公式的所有完全指派都是成假指派；</p></li><li><p>可满足公式：该公式存在成真指派；</p><blockquote><p>又可以分为：仅可满足公式、重言式；</p></blockquote></li><li><p>非永真式：该公式存在成假指派；</p><blockquote><p>又可分为：仅可满足公式、矛盾式；</p></blockquote><p><strong>两个公式的关系</strong></p></li><li><p>逻辑等值（<strong>同真假</strong>）：两个公式在它们的合成变元组的任何完全指派下，有完全相同的真假性；</p><blockquote><p>相对地，有<strong>互相矛盾性</strong>，~都取不同的真假值；</p><p>推论：α = β $\Longleftrightarrow$ α $\leftrightarrow$ β 为永真式；</p></blockquote><p><strong>需要记忆的同真假式变换：</strong></p><ul><li>交换律、结合律：<strong>蕴含词不满足</strong>；</li><li>分配律：<strong>等值词不满足、蕴含词分配后不变：$p\rightarrow(q\rightarrow r)=(p\rightarrow q)\rightarrow(p\rightarrow r)$</strong>；</li><li>摩根律、双重否定律、幂等律（与自身运算）、同一律和零律；</li><li><strong>联结词化归结论：$p\rightarrow q=\overline{p}\vee q$、$p\leftrightarrow q=p\wedge q \vee \overline{p}\wedge\overline{q}$</strong>；</li></ul></li></ul><ul><li><p>同永真性：若 α 永真当且仅当 β 永真，则称~；</p></li><li><p>同可满足性</p><blockquote><p>推论：α、β 同真假 $\Longrightarrow$ α、β 既同永真性，又同可满足性；</p></blockquote></li><li><p>对偶式：将任一<strong>不含蕴含词、等价词</strong>的 α 中所有 $\wedge$、$\vee$ 互换得到的公式称为 α 的对偶式，记为 $\alpha^*$；</p><blockquote><p>注：永真（T）、永假（F）看作 $p\vee\overline{p}$、$p\wedge\overline{p}$；</p></blockquote></li><li><p>内否式：将任一 α 中各变元（<strong>不能是子公式</strong>）的所有肯定形式和否定形式互换，得到的公式称为 α 的内否式，记为 $\alpha^-$；</p><script type="math/tex; mode=display">\begin{aligned}&\alpha=(\overline{p\wedge q}\space\vee\space \overline{p\wedge r})\space\wedge\space(p\vee(\overline{q}\wedge\overline{r}))\\&\alpha^*=(\overline{p\vee q}\wedge\overline{p\vee r})\space\vee\space(p\wedge(\overline{q}\vee\overline{r}))\\&\alpha^-=(\overline{\overline{p}\wedge\overline{q}}\vee\overline{\overline{p}\wedge\overline{r}})\space\wedge\space(\overline{p}\wedge(q\vee r))\end{aligned}</script><p>常用性质：</p><ul><li>$\alpha^-\wedge\beta^-=(\alpha\wedge\beta)^-$（对各种真值联结词适应，甚至蕴含词）</li><li>$(P\vee Q\wedge R)^*=P\wedge(Q\vee R)$（变换后不改变原来运算次序）</li><li>$\overline{\alpha^*}=\overline{\alpha}^*$、$\overline{\alpha^-}=\overline{\alpha}^-$（对偶、内否都可与否定交换运算顺序）</li><li>$\overline{\alpha}=\alpha^{*-}$（内否、对偶同时取即为取反）</li></ul><p>推论：</p><ul><li>$\alpha$ 与 $\alpha^-$ 既同永真性，又同可满足性（不一定同真假）；</li><li>$\overline{\alpha}$ 与 $\alpha^*$ 既同永真性，又同可满足性；</li><li>【对偶定理】$\alpha\rightarrow\beta$ 与 $\beta^*\rightarrow\alpha^*$ 既同永真性，又同可满足性、$\alpha\leftrightarrow \beta$ 与 $\alpha^*\leftrightarrow \beta^*$ 既同永真性，又同可满足性；</li></ul></li><li><p><strong>置换规则和代入规则的异同</strong>：</p><ul><li><p>置换规则：对公式的子公式，用与之等值的公式进行替换，得到的新公式与原公式同真假；</p><blockquote><p>可以只对某一个子公式替换；</p></blockquote></li><li><p>代入规则：对公式中出现的所有同一个命题变元代入一个公式，得到的新公式与原公式同真假；</p><blockquote><p>必须处处代入、必须对变元代入；</p></blockquote></li></ul></li><li><p>范式：一个公式到真假指派的<strong>逆过程</strong>——如何从真假指派构造出公式</p></li><li><p>简单合取式：命题变元，或（可兼得）其否定，或（可兼得）由它们利用联结词 $\wedge$ 组成的公式；</p><p>简单析取式：……联结词 $\vee$ ……；</p></li><li><p>实合取式、虚合取式：某一变元的否定及其自身<strong>最多仅出现一次</strong>的简单合取式称为<strong>实合取式</strong>，否则为<strong>虚合取式（即：永假合取式）</strong>；</p><p>实析取式、虚析取式：……简单析取式……（<strong>永真析取式</strong>）；</p></li><li><p>（极大项极小项）唯一指派定理：对一个确定的变元组而言，任一实合取式有且仅有一个成真指派、任一个实析取式有且仅有一个成假指派（回顾数电中的极大项、极小项）；</p><blockquote><p>变元组 (p, q, r) = (T, X, F) 是一个成真指派 对应：$p\wedge\overline{q}$；</p><p>变元组 (p, q, r) = (F, F, T) 是一个成假指派 对应：$p\vee q\vee \overline{r}$；</p></blockquote></li><li><p>范式表示定理：<strong>任一公式 $\alpha$ 恒可以表示为简单合取式的 析取，称为 $\alpha$ 的析取范式（即逻辑代数中的 SOP）</strong>，也可以表示为<strong>简单析取式的 合取，称为 $\alpha$ 的合取范式（POS）</strong>；</p><blockquote><p>合取范式和析取范式不唯一；</p></blockquote></li><li><p>主析取范式、主合取范式：析合范式、合析范式中的简单合取式、简单析取式全为最小项、最大项；（标准SOP和标准POS）</p><p>主析/合取范式定理：任一个 n 元公式，都存在一个唯一的与之等值的、恰含这 n 个变元的主析/合取范式；</p><p><strong>最小项的表示：$m_i$ 指 使最小项为真的各变元组成的二进制数代表 i 的那个组合</strong>；</p><p><strong>最大项的表示：$M_i$ 指 使最大项为真（这里和主流教材不一样）的各变元组成的二进制数代表 i 的那个组合</strong>；</p><p><strong>最小项的性质：</strong></p><ul><li>n 元公式的最小项共 $2^n$ 种；</li><li>在公式的变元组任意完全指派中，有且仅有一种最小项 为真；</li><li>全体最小项析取为1，任意两个最小项合取为0；</li></ul><p><strong>最大项的性质</strong>：</p><ul><li>n 元公式的最大项共 $2^n$ 种；</li><li>在公式的变元组任意完全指派中，有且仅有一个最大项 为假；</li><li>全体最大项合取为0，任意两个最大项析取为1；</li></ul></li><li><p>范式表示定理的延伸：联结词的完备集；</p></li></ul><h3 id="1-2-命题逻辑的推理形式"><a href="#1-2-命题逻辑的推理形式" class="headerlink" title="1.2 命题逻辑的推理形式"></a>1.2 命题逻辑的推理形式</h3><ul><li><p>判断A 和 B是否重言蕴含：<strong>判断 $A\rightarrow B$ 是否永真，即在 A 所有的成真指派下，B是否都为真</strong>；</p></li><li><p>重言蕴含的性质</p><ul><li>若 $A\Rightarrow B$，则：若 A 永真，则 B 永真；</li><li>若 $A\Rightarrow B$、 $B\Rightarrow A$，则 A、B 等价；</li><li>若 $A\Rightarrow B$ 且 $A\Rightarrow C$，则 $A\Rightarrow(B\wedge C)$（归并合取）；</li><li>若 $A\Rightarrow C$ 且 $B\Rightarrow C$，则 $(A\vee B)\Rightarrow C$（归并析取）；</li></ul></li><li><p>基本推理公式</p><ul><li><p>$P\wedge Q\Rightarrow P$（从严格到一般）；</p></li><li><p>$P\Rightarrow(P\vee Q)$（从一般到模糊）；</p></li><li><p>$P\wedge(P\rightarrow Q)\Rightarrow Q$（分离规则）；</p><p>$\overline{Q}\wedge(P\rightarrow Q)\Rightarrow\overline{P}$（分离规则的逆否命题）；</p></li><li><p>$(P\rightarrow Q)\space\wedge\space(Q\rightarrow R)\Rightarrow P\rightarrow R$（三段论）；</p><p>$(P\leftrightarrow Q)\space\wedge\space(Q\leftrightarrow R)\Rightarrow P\leftrightarrow R$</p></li></ul></li><li><p>如何证明推理公式</p><ul><li>可以使用<strong>重言蕴含</strong>的定义（$A\rightarrow B$ 为永真式）——永真推理 / 假设推理；</li><li>使用<strong>重言蕴含</strong>定义的反面（$A\wedge\overline{B}$ 为永假式）——归结推理；</li><li>证明推理公式本身的<strong>逆否命题</strong>；</li><li>按三段论拆分；</li><li>真值表法；</li></ul></li><li><p>推理演算规则</p><ul><li><p>前提引入：推理过程中可以随时引入前提；</p></li><li><p>结论引入：推论过程中获得的结论可以作为后续推理的前提；</p></li><li><p>代入规则、置换规则</p><blockquote><p><strong>代入：对命题变元、代入的必须是重言式、所有出现都要代入</strong>；</p><p><strong>置换：子公式，置换部分需要等值，可以仅一部分</strong>；</p></blockquote></li><li><p>分离规则；</p></li><li><p>条件证明规则：<strong>$A_1\wedge A_2\Rightarrow B\Longleftrightarrow A_1\Rightarrow A_2\rightarrow B$</strong>（将条件移动到另一边）；</p></li></ul></li><li><p>归结推理法</p><p>为证明 $A\rightarrow B$ 重言，从 $A\wedge\overline{B}$ 开始：</p><p>step 1. 将 $A\wedge\overline{B}$ 化为<strong>合取范式</strong>，并由其中的子句（析取式+）构成子句集 S；</p><p>step 2. 对 S 中的子句做归结：<strong>消互补对（$C_1=L\vee C_1^\prime$ 和 $C_2=\overline{L}\vee C_2^\prime$ 归结为 $R(C_1,C_2)=C_1^\prime\vee C_2^\prime$）</strong>；</p><p>step 3. 重复step2，直至得到空子句（矛盾）；</p></li></ul><h3 id="1-3-考点和常见题型"><a href="#1-3-考点和常见题型" class="headerlink" title="1.3 考点和常见题型"></a>1.3 考点和常见题型</h3><ul><li><p>命题的判断</p><blockquote><ol><li>必定为陈述句，否则没有真假；</li><li>必须可以辨别真假；</li><li>未证明的定理算，因为最终是有真假的；</li><li>悖论不算：“这句话是假话”；</li></ol></blockquote></li><li><p>真值联结词和自然语言的差异</p><ul><li>并列“和”、并且“和”；</li><li>可兼得“或”、不可兼得“或”；</li><li>不关心因果的“如果……则……”；</li></ul></li><li><p>波兰表达式（前缀表达式）、逆波兰表达式（后缀表达式）、中缀表达式的转换</p><p><strong>前缀式书写思路：找到当前最后运算的运算符，先放到当前区块的最前面，以此为分割，分别处理左右边的式子</strong>；</p></li><li><p>给定一个公式，确定其成真指派、成假指派</p><p>step 1. 应用等值运算将否定词深入到变元上；</p><p>step 2. 随机指定一个变元（建议选出现次数多、对它指派能轻松得到结果的变元），对其分别做 T、 F 指派（分类讨论），得到两个不含该变元，但有真假值的公式；</p><p>step 3. 化简这两个公式，如果仍存在变元，重复上面的操作，直至能够直接判断真假为止；</p><blockquote><p>e.g., 判定 $(p\vee\overline{r})\rightarrow\overline{((p\rightarrow q)\leftrightarrow\overline{(p\wedge\overline{(q\leftrightarrow r)})})}$ 的永真性和可满足性；</p></blockquote></li><li><p>判断联结词的完备集、联结词相互转化</p><ul><li><p>否定、析取、合取：$\neg$ 和 $\vee$ 、$\neg$ 和 $\wedge$ 构成<strong>最小完备集</strong>，但 $\wedge$ 和 $\vee$ 不行！！！</p></li><li><p>与非（$\uparrow$）、或非（$\downarrow$）：各自独立构成<strong>最小完备集</strong>；</p></li><li><p><strong>否定和蕴含（$\rightarrow$）构成一个最小完备集</strong>，但否定和等价<strong>甚至连完备集都不是</strong>！！！</p></li><li><p>除了以上提到的最小完备集，及其扩充，其他任何联结词组成的集合都不是完备集；</p><blockquote><p>e.g., $\{\wedge,\leftrightarrow\},\{\vee,\rightarrow\},\{\neg,\leftrightarrow\}$ 等，都不是完备集；</p></blockquote></li></ul></li><li><p>n 元联结词的数量：$2^{2^n}$个；</p></li><li><p>将一个公式转换为对应的主析取范式、主合取范式、最简析合范式、最简合析范式；</p><blockquote><p>e.g.1, 将 主析取范式 $A=\bigvee_{0,1,4,5,7}$ 转换为主合取范式；</p><p>e.g.2, 将 合取范式$P\vee Q$ 转换为析取范式；</p></blockquote></li><li><p>证明推理公式：例题略</p></li><li><p>判断推理式是否正确：<strong>从重言蕴含化为蕴含运算，看是否为永真式</strong>；</p></li><li><p>自然语言到命题公式的形式化和证明</p><p>⚠<strong>极易出错点：只有……才、除非……否则、或者……或者的形式化</strong></p><ul><li>“只有P-才Q”：只有满足P，才满足Q，<strong>言外之意，P 是 Q 的必要不充分条件！（如果不满足P，那么并不影响 Q）</strong>，所以翻译为：$Q\rightarrow P$；</li><li>“除非P-否则Q”：等价于只有满足 $P$，才满足 $\neg Q$，所以翻译为 $\neg Q\rightarrow P$；</li><li>“或者P-或者Q”：<strong>有两种理解方式：可兼得或、不可兼得或</strong>，视语境而定；可兼得或，和“……可以，……也可以”的意义相同，这个时候翻译成 $P\vee Q$；不可兼得或，和“要么……要么……”的意义相同，这个时候翻译成 $P\oplus Q=P\wedge\neg Q\vee\neg P\wedge Q$；</li></ul></li></ul><h3 id="1-4-错题"><a href="#1-4-错题" class="headerlink" title="1.4 错题"></a>1.4 错题</h3><ul><li><p>形式化语句：如果水是清的，那么或者张三能见到池底或者他是个近视眼；</p><p><strong>错因：读题问题</strong></p><p><strong>“或者……或者……”在这里是不可兼得或，表示“要么……要么……”</strong></p><blockquote><p>设 P: 水清；Q: 张三能见池底；R: 张三是近视眼；</p><p>$P\rightarrow(Q\wedge\overline{R}\vee\overline{Q}\wedge R)$</p></blockquote></li><li><p>将公式写为波兰表达式、逆波兰表达式：$P\rightarrow Q\vee R\vee S$、$\neg\neg P\vee(W\wedge R)\vee\neg Q$、$P\wedge\neg R\leftrightarrow P\vee R$；</p><p><strong>错因：运算符优先级判断错误（$\neg\gt\wedge\gt\vee\gt\rightarrow\gt\leftrightarrow$）</strong></p><p>$\rightarrow P\vee\vee QRS$、$PQR\vee S\vee$、$\leftrightarrow \wedge P\space\neg R\vee P Q$（其他略）</p></li></ul><h2 id="Chapter-2-谓词逻辑（一阶）"><a href="#Chapter-2-谓词逻辑（一阶）" class="headerlink" title="Chapter 2 谓词逻辑（一阶）"></a>Chapter 2 谓词逻辑（一阶）</h2><blockquote><p>将原子命题进一步分析为<strong>个体</strong>和<strong>谓词</strong>；</p></blockquote><h3 id="2-1-重要概念集合"><a href="#2-1-重要概念集合" class="headerlink" title="2.1 重要概念集合"></a>2.1 重要概念集合</h3><ul><li><p>个体：可以指具体/抽象的独立存在的对象；</p><blockquote><p>如：字母R，XX公司，1，2，-1，张三等；</p></blockquote></li><li><p>个体域：由个体组成的集合；</p><p>全总个体域：所有个体聚合在一起所组成的集合；</p></li><li><p>个体变元：以某个个体域 I 中的个体为变域的变元，称为<strong>个体域 I 上的个体变元</strong>；</p></li><li><p>谓词：个体、命题所具有的性质，或者若干个体、若干命题之间的关系；</p><ul><li>一元谓词：指明个体/命题的性质；</li><li>二元谓词：指明两个个体/一个个体和一个命题间的关系；</li></ul><p><strong>谓词实际上是一个以个体/命题（目前仅讨论以个体为变域的一阶谓词）为变域、命题为值的函数</strong>；</p><blockquote><p>真值函数是个以命题为变目、命题为值的函数，所以也是谓词；（真值联结词同理）</p></blockquote><p>⚠<strong>注意：谓词与个体域紧密相关，例如一元谓词”是质数“相对于自然数域而言</strong>；</p></li><li><p>谓词变元：以谓词为变域的变元；</p><blockquote><p>约定：小写字母为（pqr）命题变元、大写字母（PQR）为命题、小写字母（abc）为个体变元、大写字母（ABC）为特定谓词、大写字母（XYZ）为谓词变元；</p></blockquote></li><li><p>谓词填式：将谓词后面填以<strong>个体变元</strong>所得的式子；</p><blockquote><p>谓词和谓词填式是两个完全不同的概念；</p></blockquote></li><li><p>命名变元：为了了解谓词的元数，一般在谓词后写<strong>命名变元</strong>来说明元数（类似函数形参）；</p></li><li><p>谓词命名式：谓词后填以<strong>命名变元</strong>的式子（类似函数声明）；</p><blockquote><p><strong>谓词命名式 等价于 谓词</strong>，所以谓词命名式和谓词填式完全不同；</p></blockquote></li><li><p>谓词的严格定义：以某个个体域 I 为定义域，以真假为值域的谓词，称为<strong>个体域 I 上的谓词</strong>；</p><p>谓词变元的严格定义：以个体域 I 上的谓词为变域的变元，称为<strong>个体域 I 上的谓词变元</strong>；</p><p><strong>结论：k 个个体组成的个体域 I 上的 m 元谓词共有 $2^{k^m}$ 个</strong>；</p></li><li><p>量词：仅有个体、谓词，还是无法描述一些问题—-&gt;<strong>措施：使用新的变元 + 约定新的变元的个体域 + 规定新的变元的性质 来处理</strong></p><p>新的变元：</p><ul><li>全称性变元：表示<strong>任意一个</strong>的变元，都称~；</li><li>存在性变元：表示<strong>确定的一个，但现在可能不知道/无需指明的一个</strong>，都称~；</li></ul><p>引入谓词约束新的个体域：</p><ul><li><p>谓词配合全称性量词+蕴含前件约束：</p><blockquote><p>所有实数，要么大于0，要么小于0，要么等于0</p><p>$Ay\rightarrow(y\gt0\vee y=0\vee y\lt 0)$，y是<strong>以全总个体域为变域的全称性变元</strong>，A表”是实数“；</p></blockquote></li><li><p>谓词配合存在性量词+合取约束：</p><blockquote><p>一个中国人来了（Ae表示e来了）</p><p>$Bu\wedge Au$，u是<strong>以全总个体域为变域的存在性变元</strong>，B表”是中国人“；</p></blockquote></li></ul><p>引入<strong>量词</strong>规定新的变元的性质：$\forall x$（全称量词）、$\exists x$（存在量词）；</p></li><li><p>细小概念：对两种公式：$\forall x\alpha(x),\space\exists x\alpha(x)$</p><ul><li>$\forall x、\exists x$ 中的 x 是相应量词的<strong>指导变元</strong>；</li><li>$\alpha(x)$ 为相应量词的<strong>作用域（或辖域）</strong>；</li><li>在作用域中，但不与指导变元同名的其他变元称为<strong>参数</strong>；</li></ul></li><li><p><strong>谓词演算公式（定义和主流教材不一样！有争议，应该不考定义，这里写主流教材的）</strong>：由命题变元、谓词填式利用真值联结词和量词作成的如下式子：</p><ul><li>命题公式是公式；</li><li>填以个体变元的谓词填式也是公式；</li><li>公式的否定是公式；</li><li>两个公式的合取、析取、蕴含、等价也是公式；</li><li>若 α 是公式，x 是个体变元，则 $\forall x\alpha,\space\exists x\alpha$ 也是公式；</li></ul><blockquote><p>提示，本教程中不主流，认为$\forall xF(x)\wedge G(x)$ 不是公式；</p></blockquote></li><li><p>自由出现和约束出现：设 α 为一个谓词演算公式，Qxβ是 α 的一个子公式（Q为量词的一种，x 为变元，β 为公式），则在Qxβ 中：变元 x 的一切出现都称为 x 在 α 中的<strong>约束出现</strong>；而 α 中的 x 除了约束出现以外的一切出现都称 x 在 α 中的<strong>自由出现</strong>；</p><blockquote><p>$\forall x((Xxy\wedge\exists yYy)\rightarrow\exists y(\overline{X}xy\leftrightarrow\exists y\overline{X}y))$中，</p><p>第一个 y 是公式中 y 的自由出现，第2、3、4、5、6、7都是公式中 y 的约束出现；</p></blockquote></li><li><p>约束关系：各个量词和变元的出现间的约束上的关系；</p><p>确定约束关系的过程：确定”公式中哪个变元的哪些出现受哪个量词的约束“的过程；</p></li><li><p>自由变元、约束变元；</p><p><strong>同一变元在一个公式中可能既是自由变元，又是约束变元</strong>；</p><p><strong>在一阶谓词逻辑中，认为命题变元、谓词变元都是自由变元，不受量词约束</strong>；</p></li><li><p>改名：将一个变元改为另一个变元，并要求改名后的式子与原来的式子语义相同</p><ul><li>改名<strong>针对约束变元</strong>而言，不能对自由变元改名；</li><li>改名必须同时对原式中该变元的一切受<strong>某个量词约束</strong>的约束出现<strong>均</strong>改名（<strong>同约束全替换</strong>）；</li><li>改名后的名字不允许和作用域中其他自由变元同名；（会改变约束关系）</li><li>改名后，<strong>一般</strong>不与作用域中约束变元同名，因为容易混；</li></ul></li><li><p>代入：将一个变元代以式子（式子的变域与变元变域要相同），要求代入后的式子是原式的特例；（不要求等值）</p><ul><li>代入<strong>针对自由变元</strong>而言，约束变元不允许代入；</li><li>代入式当中的变量名不能与原式作用域中的约束变量同名；</li><li>同一自由变元出现<strong>全部替换</strong>；</li></ul><blockquote><p>可以的：命题变元代入公式、个体变元代入项、谓词变元代入同元谓词；</p></blockquote></li></ul><p><strong>总结：1、只要没改变约束关系的、不引发歧义的改名、代入都行；</strong></p><p>​            <strong>2、要改全改，要代全代</strong>；</p><blockquote><p>$\forall y(p\rightarrow Ay)$ 可以将 p（命题变元）代入为 $\exists yBxy$，因为没有歧义、没有改变约束关系；</p></blockquote><p>​    <strong>一个公式的关系</strong></p><ul><li><p>谓词演算公式的永真性、可满足性</p><p>【POINT 1】<strong>谓词演算公式的真假与：个体域、自由变元（自由个体变元、谓词变元、命题变元）有关</strong>，和约束变元无关；</p><ul><li><p>谓词演算公式的成真指派、成假指派、有缺指派</p><p>一个一阶谓词演算公式 α，其自由个体变元 $x_1,x_2,…,x_h$，命题变元 $p_1,p_2,…,p_k$，谓词变元 $X_1,X_2,…,X_r$，则将 α 表示为：$\alpha(x_1,x_2,…,x_h;\space p_1,p_2,…,p_k;\space X_1,X_2,…,X_r)$；</p><p>若对其个体域 $I$ 的指派为 $I_0$（约束变元的全总个体域也变为 $I_0$），</p><p>对  $x_1,x_2,…,x_h$ 指派为： $\alpha_1,\alpha_2,…,\alpha_h$ 、对 $p_1,p_2,…,p_k$ 指派为 $p_1^0,p_2^0,…,p_k^0$、对  $X_1,X_2,…,X_r$ 指派为 $A_1,A_2,…,A_r$，则称对 α 作一个个体域 $I_0$ 上的指派 $(\alpha_1,\alpha_2,…,\alpha_h;\space p_1^0,p_2^0,…,p_k^0;\space A_1,A_2,…,A_r)$；</p><p><strong>在一个确定的个体域、自由个体变元、命题变元、谓词变元的指派下，公式 α 的真假值确定</strong>；</p><p>若该指派下公式的值为真，则称为成真指派，否则为成假指派；</p><p>若仅对 α 中的部分自由变元指派，则称该指派为 α 的一个有缺指派（有缺指派下公式不一定有确定的真假值）；</p></li></ul><p>【POINT 2】谓词演算公式的真假值确定的<strong>关键</strong>在于<strong>确定 $\forall x\alpha(x)$ 和 $\exists x \alpha(x)$ 的真假</strong>；</p><blockquote><p> $\forall x\alpha(x)$ 为真，当且仅当 I 中每个个体都使公式为真；</p><p> $\exists x \alpha(x)$ 为真，当且仅当 I 中至少有一个个体使公式为真；</p></blockquote><ul><li><p><strong>永真性（普遍有效性）、可满足性</strong>：若公式 α 对于个体域 I 中任何指派均取真值，则称 α 在 I 中永真；若 α 在每一个非空个体域中均永真，则称 α <strong>永真（普遍有效公式）</strong>；</p><blockquote><ol><li>可满足性的定义同理；</li><li>此处许多定理，例如 α、β 同真假 $\Longleftrightarrow$ α $\leftrightarrow$ β 永真，和命题逻辑类似，略去；</li></ol></blockquote><p><strong>重要定理：有限域上，公式的永真性、可满足性仅取决于个体域中的个体数</strong>；</p><blockquote><p>感性理解：如果公式的永真性取决于个体域中的不同个体的<strong>特征</strong>的话，那么就不是永真了；</p></blockquote><p>因此，将 $\{1,2,3,…,k\}$ 作为具有 k 个个体的个体域的代表（仅与数量有关，所以元素是啥都行），命名为 “k-域”，α 在 k 域上永真称为<strong>k-永真</strong>；</p></li><li><p>同永真性、同可满足性：α 永真当且仅当 β 永真，则称 α、β <strong>同永真性</strong>；</p></li></ul></li><li><p>有限域下的公式表示法：有限域 $D=\{1,2,3,…,k\}$ 不失一般性；</p></li></ul><script type="math/tex; mode=display">\begin{aligned}&\forall xP(x)=P(1)\wedge P(2)\wedge\cdots\wedge P(k)\\&\exists xP(x)=P(1)\vee P(2)\vee\cdots\vee P(k)\end{aligned}</script><blockquote><p><strong>当发现某些谓词演算公式难以理解时，尝试在 {1, 2} 域下展开</strong>；</p></blockquote><ul><li><p>全称封闭式、存在封闭式：将公式中的一切自由个体变元，构造出对应的全称量词并置于全式之前，则称得到的新公式为 α 的全称封闭式，记作$\Delta\alpha$；（存在封闭式同理）</p><p><strong>重要定理：α 与它的全称封闭式在每个域中同永真性、与它的存在封闭式在每个域中同可满足性</strong>；</p><blockquote><p>感性理解：一个公式一旦确定为永真，那么他的所有自由个体变元的所有取值都不影响它的真，所以它的全称封闭式也为真；</p></blockquote><p><strong>引入存在封闭式，可以将公理50 $\Delta(\forall x\alpha(x)\rightarrow\alpha(\xi))$、公理51 $\Delta(\alpha(\xi)\rightarrow\exists x\alpha(x))$ 没有歧义地表述，不容易造成误解和错用</strong>；</p></li></ul><p>​    <strong>两个公式的关系</strong></p><ul><li><p>谓词演算公式的同真假性、在 I 上同真假性（或者说<strong>等值</strong>）：设有公式 α、β，若对个体域 I 的每一指派，α、β 均取相同真假值，则称 α、β <strong>在 I 上同真假</strong>；若 α、β 在每个非空域上同真假，则称二者<strong>同真假</strong>；</p><p><strong>谓词演算公式同真假公式记忆：</strong></p><ul><li><p>$\overline{\forall}x\alpha(x)=\exists x\overline\alpha(x)$、$\overline{\exists}x\alpha(x)=\forall x\overline\alpha(x)$；（<strong>量词否定的同真假变换</strong>）</p></li><li><p>$\overline\forall x\exists y\alpha(x)=\exists x\forall y\overline\alpha(x)$（<strong>对多个量词的否定同真假变换，多少个量词都一样</strong>）</p></li><li><p>$\forall x(\alpha(x)\vee\gamma)=\forall x\alpha(x)\vee\gamma$、$\forall x(\alpha(x)\wedge\gamma)=\forall x\alpha(x)\wedge\gamma$</p><p>$\exists x(\alpha(x)\vee\gamma)=\exists x\alpha(x)\vee\gamma$、$\exists x(\alpha(x)\wedge\gamma)=\exists x\alpha(x)\wedge\gamma$；（<strong>量词与”自由公式“的结合律</strong>）</p><p>（γ 为<strong>不含自由变元 x </strong>的公式）</p><p><strong>请注意：如果涉及蕴含符号，请自行推导，结论是不同的！</strong></p></li></ul><p><strong>第二组重要的等值公式：相关约束分配律</strong></p><ul><li><p>$\forall x(P(x)\wedge Q(x))=\forall xP(x)\wedge\forall xQ(x)$</p><p>$\exists x(P(x)\vee Q(x))=\exists xP(x)\vee\exists xQ(x)$</p><p><strong>分开个体不必相同，原因在于：理解为有限域下公式表示，是否展开为连续的 $\wedge$ 和 $\vee$</strong>；</p></li><li><p>$(\forall x)P(x)\vee(\forall x)Q(x)=\forall x\forall y(P(x)\vee Q(y))$</p><p>$(\exists x)P(x)\wedge(\exists x)Q(x)=\exists x\exists y(P(x)\wedge Q(y))$</p><p><span id="diff"><strong>分开不一定相同，一般情况是 $(\forall x)P(x)\vee(\forall x)Q(x)$、$\exists x(P(x)\wedge Q(x))$ 更强一些：</strong></span></p><p>$\forall xP(x)\vee \forall xQ(x)\Rightarrow \forall x(P(x)\vee Q(x))$</p><p>$\exists x(P(x)\wedge Q(x))\Rightarrow\exists xP(x)\wedge\exists xQ(x)$</p><p>记忆方法可以采用<strong>“唱歌跳舞解释法”</strong>：例如，班里所有人都会唱歌 或 班里所有人都会跳舞 <strong>强于</strong> 班里所有人都会唱歌或跳舞（因为可能恰好一部分人只会唱歌、另一部分人只会跳舞，这样满足后者，却不满足前者）</p></li></ul></li></ul><ul><li><p>前束型公式、准前束型公式：一个公式的量词都在开头，它们的作用域延伸到全式的末尾，称这样的公式为<strong>前束型公式</strong>；由前束型公式利用真值联结词作成的公式称为<strong>准前束型公式</strong>；</p><blockquote><p>$\forall x\exists y\forall z(Xxy\rightarrow Yyz)$ 为前束型公式，$\forall x\exists yXxy\wedge\forall y\exists zYyz$ 为准前束型公式；</p></blockquote></li><li><p><strong>前束范式定理：任何一个谓词演算公式都与一个前束型公式同真假（称此前束型公式为前束范式）</strong></p><blockquote><p><strong>前束范式不唯一！</strong></p></blockquote><p>⚠<strong>完全不建议、甚至禁止将蕴含词、等价词留在式中，因为考虑否定深入，需要将这些属性的词展开，有时甚至不展开是错误的！因为量词在进出这些运算符时可能多了一层否定</strong></p><p><strong>将公式转化为前束范式的思路：</strong></p><p>step 1. 否定深入，将量词上的否定转移到作用域内部（利用前面两条同真假公式）；</p><p>step 2. 适当改名：规避将量词提出时的重名错误；（考虑约束关系会不会在提出后有歧义或改变）</p><p>step 3. 根据同真假公式，依此提出内层的量词开头的公式；</p></li><li><p>Skolem 标准型：一阶谓词逻辑的任一公式 α，若：</p><ol><li>其前束范式中所有的存在量词都在全称量词的左边（<strong>$\exists$ 前束范式</strong>），</li><li>或者，仅保留全称量词而消去存在量词（<strong>$\forall$ 前束范式</strong>）</li></ol><p>则得到的 α 的新公式称为 <strong>skolem 标准型</strong>；</p><p>⚠<strong>skolem 标准型一定无法像前束范式一样，与原式保持完全等值的关系，只能保持一定意义上的“关系”</strong></p><ul><li><p>$\exists$ 前束范式：$\exists x_1\exists x_2\cdots\exists x_i\forall x_{i+1}\cdots\forall x_nM(x_1,x_2,…,x_n)$，保证 i ≥ 1且 M 内<strong>不含量词和自由个体变元</strong>；</p><p><strong>$\exists$ 前束范式定理：FOL（一阶谓词逻辑）的任一公式 α 都能写成与之对应的（不一定等值）$\exists$ 前束范式，且 <u>α 和 其 $\exists$ 前束范式同永真性</u></strong></p><blockquote><p>所以 一般当 α 永真时，或者想要进行<strong>同永真转换</strong>时，才使用 $\exists$ 前束范式；</p></blockquote></li><li><p>$\forall$ 前束范式：仅保留全称量词的前束范式</p><p><strong>$\forall$ 前束范式定理：FOL 的任一公式 α 都能写成与之对应的（不一定等值）$\forall$ 前束范式，且 <u>α 和 其 $\forall$ 前束范式同可满足性</u></strong></p><blockquote><p>所以 一般当 α 永假时，或者想要进行<strong>同不可满足转换（通常是谓词演算公式的归结推理）</strong>时，才使用 $\forall$ 前束范式；</p></blockquote></li></ul></li></ul><h3 id="2-2-谓词演算公式的推理演算"><a href="#2-2-谓词演算公式的推理演算" class="headerlink" title="2.2 谓词演算公式的推理演算"></a>2.2 谓词演算公式的推理演算</h3><ul><li><p>较之命题演算新增 4 个规则：</p><ol><li><p>全称量词消去（公理50）${\forall xP(x)}\over{\therefore\space P(y)}$ 和 ${\forall xP(x)}\over{\therefore\space P(c)}$</p><ul><li>要求取代的自由变元不能在原式中约束出现（否则改变约束关系，这个一般不会违反）</li><li>必须取代所有的 该变元（消去全称量词的指导变元对应的变元，一般也不会违反）</li></ul><blockquote><p>提示：全称量词的消去有两种使用方法，一种是左边的消去为全域的自由变量 y，另一种是消去为个体常量 c； </p></blockquote></li><li><p>全称量词引入（全“0”规则）${P(y)}\over{\therefore\space\forall xP(x)}$</p><ul><li><p><strong>要求左式 $P(y)$ 中的 y 是使公式为真的<u>自由个体变元</u></strong></p><blockquote><p>具体是要求查找前面所有<strong>假设</strong>中，y 是否自由出现，如果是，一定<strong>不满足</strong>这个条件；</p></blockquote></li><li><p>取代 y 的 x 约束变元不能在 P(y) 中约束出现（否则改变约束关系，这个一般不违反）</p></li></ul></li><li><p>存在量词消去（<strong>存在假设</strong>）${\exists xP(x)}\over{\therefore\space P(e)}$</p><ul><li>要求右式的 e 必须是使公式为真的<strong>个体常项</strong>，不在 P 中出现；</li><li>要求 P <strong>不能有自由个体变元</strong>，会导致个体域混淆；</li></ul></li><li><p>存在量词引入（公理51）${P(c)}\over{\therefore\space\exists xP(x)}$</p><ul><li>要求个体常项 c 不在 P 中其他地方出现；</li></ul></li></ol></li><li><p>归结推理：在命题逻辑处理的基础上，将“同不可满足公式”转换为 $\forall$ 前束范式，略去全称量词、$\wedge$ 以逗号相连，构成子句集，归结方法：<strong>$R(x)\vee Q(x)$ 和 $\overline R(a)\vee P(y)$ 归结为 $Q(a)\vee P(y)$</strong>（不是x 的原因是：在子句集中，看起来是自由变元的都是全称变元），直至空子句；</p><p><strong>为了方便起见，一般不完全写出 $\forall$ 前束范式，而是对由合取联结的几个部分分别求子句集，最后求并集；</strong>虽然与原子句集不一样，但它们的可满足性是一致的；</p></li><li><p>推理小结论</p><ul><li><p><a href="#diff">相关约束分配律的大小关系🔗</a></p></li><li><p>$\forall x\forall yP(x,y)$ 强于 $\exists x\forall yP(x,y)$ 强于 $\forall x\exists yP(x,y)$ 强于 $\exists x\exists yP(x,y)$</p></li><li><p>一般情况下，量词<strong>一定不具备对于等价词的分配律</strong>：因为将等价词拆为双向蕴含词的合取，如果要分配，就意味着同时对 析取、合取 两种运算分配，这无论是全称量词还是存在量词都是不可接受的；</p><blockquote><p>例如：$\exists x(P(x)\leftrightarrow Q(x))\rightarrow(\exists xP(x)\leftrightarrow\exists xQ(x))$ 不是普遍有效的；</p><p>可以将 $P(x)\leftrightarrow Q(x)$ 拆开成 $(P(x)\rightarrow Q(x))\wedge(Q(x)\rightarrow P(x))$ 理解；</p></blockquote></li></ul></li></ul><h3 id="2-3-常见题型"><a href="#2-3-常见题型" class="headerlink" title="2.3 常见题型"></a>2.3 常见题型</h3><ul><li><p>自然语言的形式化</p><p><strong>注意：如果语句中含有“不”或者其他否定的字样，建议将其提出谓词的定义中，例如：</strong></p><blockquote><p>“Qe：e 溶于水” 的定义好于：“Qe：e 不溶于水”</p></blockquote></li><li><p>谓词演算公式的改名和代入</p></li><li><p>给定一个指派，求谓词演算公式的真假值</p><p>step 1. 初步代入指派（尽可能代入谓词变元、命题变元、自由个体变元）；</p><p>step 2. <strong>由内向外</strong>逐层求<strong>由量词带头的</strong>子公式的值；<strong>如果不能求出，则转化为同一语境下同真假的式子</strong></p><blockquote><p>在子公式内部，应该将与指导变元不同的变元暂时视作自由变元；</p></blockquote><p>step 3. 遇到多个量词和指导变元针对一个作用域时，按照<strong>从左至右</strong>的顺序理解，不能交换顺序；</p></li></ul><ul><li><p>判断公式的永真性（普遍有效性）、可满足性</p><blockquote><p>但凡公式需要确认自由变元 才能判断真假的，都是仅可满足的；</p></blockquote><p><strong>只要将公式写出，那么它必然处于：永真性、仅可满足、不可满足（矛盾式）这三者特性之一！</strong></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="rel.jpg" height="200px"></p><ul><li>想要证伪，则一般在 {1, 2} 域上列表格，“唱歌跳舞分析法”来查看，判断什么条件下能够生成反例，尤其对于蕴含式，设立一个前件正确、后件错误的才行；</li><li>想要证明，建议先看看证伪，发现无法证伪再来证明</li></ul><p>⚠易错点1：有些公式默认了自由变元的全总个体域：$\forall xP(x)\rightarrow P(y)$ 是普遍有效公式；</p><p>⚠易错点2：有些公式没有直接方法化简到 F/T，而且你记得它不是普遍有效公式，也不能直接判断，因为它可能在某些情况下成立，例如：$(\exists x P(x)\wedge\exists xQ(x))\rightarrow\exists x(P(x)\wedge Q(x))$ 是<strong>1-永真</strong>的，所以是可满足公式；</p></li></ul><ul><li>拓展：谓词演算公式的可判定性（<strong>针对一个演算系统而言，并非是对一个公式而言</strong>）</li></ul><ul><li><p>求公式对应的前束范式</p></li><li><p>求公式对应的 $\forall$ 前束范式 / $\exists$ 前束范式</p><blockquote><p>考试时注意：<strong>本教材（非主流）中除非强调，默认“skolem标准型”就是 $\forall$ 前束范式，不指 $\exists$ 前束范式</strong>；</p></blockquote><p><strong>转换为 $\exists$ 前束范式的基本思路：</strong></p><ol><li><p>将公式转换为前束范式；</p></li><li><p>以 $\exists x_1\exists x_2\cdots\exists x_i\forall x_{i+1}\exists x_{i+2}\cdots\exists x_nM(x_1,x_2,…,x_n)$ 为例（因为都可以转化为：存在量词中间夹一个全称量词的情况）：</p><p>引入 $\forall x_{i+1}$ 前的所有指导变元（<strong>默认从左到右消除全称量词</strong>），包括自己，作为新的谓词（没有出现过）的填式：$S(x_1,x_2,…,x_i,x_{i+1})$ ，其中 S 是自由变元，可以取个体域上所有谓词；这样：</p><script type="math/tex; mode=display">\begin{aligned}&\exists x_1\exists x_2\cdots\exists x_i\forall x_{i+1}\exists x_{i+2}\cdots\exists x_nM(x_1,x_2,...,x_n)\\=&\exists x_1\exists x_2\cdots\exists x_i\exists x_{i+1}\exists x_{i+2}\cdots\exists x_n(M(x_1,x_2,...,x_n)\wedge\overline S(x_1,x_2,...,x_{i+1})\vee\forall yS(x_1,x_2,...,x_i,y))\\=&\exists x_1\exists x_2\cdots\exists x_i\exists x_{i+1}\exists x_{i+2}\cdots\exists x_n\forall y(M(x_1,...,x_n)\wedge\overline S(x_1,...,x_{i+1})\vee S(x_1,...,x_i,y))\end{aligned}</script></li><li><p>如上面公式的最后一步，将任意的 y 利用结合律提出，循环此过程直至变为  $\exists$ 前束范式；</p></li></ol><p><strong>转换为 $\forall$ 前束范式的基本思路：</strong></p><ol><li>将公式转换为前束范式；</li><li>以 $\forall x_1\forall x_2\cdots\forall x_i\exists x_{i+1}\forall x_{i+2}\cdots\forall x_nM(x_1,x_2,…,x_n)$ 为例，因为都可以转化为：全称量词中间夹一个存在量词的情况）：<ul><li>如果 $x_{i+1}$ 左边没有（全称）量词（<strong>也默认从左到右消除</strong>），即 i = 0，那么只要在作用域中将所有 $x_{i+1}$ （一定是自由出现）代以一个从未出现的自由变元名，例如 y：$M(y,x_2,…,x_n)$，直接删除 $\exists x_{i+1}$ 即可；</li><li>如果 $x_{i+1}$ 左边有（全称）量词，则将 $x_{i+1}$ <strong>替换为</strong>左边出现的所有全称量词指导变元构成的自由变元-函词填式（从未出现过该名字，例如 f）：$f(x_1,x_2,…,x_i)$，构成：$M(x_1,x_2,…,x_i ,f(x_1,x_2,…,x_i),x_{i+2},…,x_n)$​，直接删除 $\exists x_{i+1}$ 即可；</li></ul></li><li>循环上面的过程直至变为  $\forall$ 前束范式；</li></ol></li></ul><ul><li><p>分析谓词演算公式证明的正确性</p></li><li><p>谓词演算公式的推理证明</p><blockquote><p>推理中如果使用到了推理结论，例如：$P(x)\wedge Q(x)\Rightarrow P(x)$，在原因一栏写“重言蕴含”，这对于<strong>命题逻辑</strong>的推理也是这样的！</p></blockquote></li></ul><h2 id="Chapter-3-集合论"><a href="#Chapter-3-集合论" class="headerlink" title="Chapter 3 集合论"></a>Chapter 3 集合论</h2><h3 id="3-1-重要概念集合"><a href="#3-1-重要概念集合" class="headerlink" title="3.1 重要概念集合"></a>3.1 重要概念集合</h3><ul><li><p>集合定义（确定性、互异性、无序性）、属于不属于定义；</p></li><li><p>⚠集合元素不能是其自身（罗素悖论）=&gt; 抽象公理错误，不能任给一个性质就能构造一个对应的集合；</p></li><li><p>集合表示法：字母约定、外延表示法（穷举）、内涵表示法（谓词描述性质）；</p></li><li><p>集合间的关系</p><ul><li><strong>外延公理：一个集合由它的元素完全确定</strong>；</li><li>相等关系：由外延公理可以写出定义，下略；</li><li><p>子集（包含关系）、否定包含关系、真子集（真包含关系）；</p><ul><li><strong>相等包含定理（证明两集合相等时常用）：$A=B\Longleftrightarrow(A\subseteq B)\wedge(B\subseteq A)$</strong>；</li><li>包含关系的三条性质：自反、反对称、传递；（属于关系没有传递的性质）</li></ul></li><li><p>相交关系：两集合是否有公共元素；没有称<strong>不相交的</strong>；</p></li></ul></li><li><p>特殊集合</p><ul><li>空集：不含任何元素的集合，记 $\phi$；<ul><li>性质1：包含于<strong>任意集合</strong>；</li><li>性质2：<strong>空集的唯一性</strong>（外延定理说明）；</li></ul></li><li>全集：在<strong>给定的问题</strong>中，所考虑所有事物的集合；</li></ul></li><li><p>集合运算</p><ul><li><p>并集、交集、差集（“差集”相对于“被差集”的相对补集）、余集（高中的“补集”）、对称差集（异或）；</p></li><li><p>广义交集、广义并集（<strong>针对集合的元素全是集合的集合</strong>）；</p><blockquote><p>规定 $\bigcup\phi=\phi$，$\bigcap\phi$ 没有意义；</p></blockquote></li><li><p>幂集：集合的幂集是该集合所有子集组成的集合，记 $P(A)$</p><ul><li>性质1：幂集的元素全部是集合，无论 A 有没有元素；</li><li>性质2：$\phi\in P(A)$、$A\in P(A)$；</li></ul></li><li><p>笛卡尔积</p><blockquote><p>定义“有序对”：两个元素 x、y（允许 x = y）按给定次序排列组成的二元组合称为一个~；</p><p><strong>有序对的集合定义：$\langle x,y\rangle=\{\{x\},\{x,y\}\}$</strong>；</p><p>有序对性质定理：</p><p>$x\ne y\space\Rightarrow\space\langle x,y\rangle\ne\langle y,x\rangle$</p><p>$\langle x,y\rangle=\langle u,v\rangle\space\Rightarrow\space x=u\wedge y=u$</p></blockquote><p>定义：集合 A 与 B 的笛卡尔积 $A\times B=\{z\space|\space x\in A\wedge y\in B\wedge z=\langle x,y\rangle\}$；</p><blockquote><p>A = B 时，可以写作：$A^2$；</p></blockquote><p>以上可以推广到 n 维空间；</p><p><strong>注意：无论多少阶，都不存在“一个集合中选多个元素作为 n 元组”的情况，参考坐标点</strong>；</p></li></ul></li><li><p>运算符优先级：大致是 <strong>集合运算符＞真值联结词＞逻辑关系符</strong>；</p></li><li><p>集合的图形表示法：韦恩图（交并补）、哈斯图（幂集）、笛卡尔坐标系图示法；</p></li><li><p><strong>集合重要运算性质（记忆）</strong></p><ul><li><p>运算律：基本运算由联结词定义，所以性质相似，此处仅补充少见的运算律</p><script type="math/tex; mode=display">A-(B\cup C)=(A-B)\cap(A-C)\\A-(B\cap C)=(A-B)\cup(A-C)</script></li><li><p>运算性质：以差集为例</p><script type="math/tex; mode=display">\begin{aligned}A-B&=A-(A\cap B)\\A\cap(B-C)&=(A\cap B)-C\\A-B&=A\cap-B\end{aligned}</script><p><strong>最后一条极其重要，常用于差集运算符消去</strong>；</p></li><li><p>基本关系运算性质</p><script type="math/tex; mode=display">A\cup B=B\Longleftrightarrow A\subseteq B\Longleftrightarrow A\cap B=A\Longleftrightarrow A-B=\phi</script><p><strong>最后一步启示我们：在证明式中含有 $\phi$ 时，建议将式中的差运算符留到最后</strong>；</p><p>例如证明：$(A-B)\oplus(A-C)=\phi\Longleftrightarrow A-B=A-C$ 的时候；</p></li><li><p>幂集性质</p><ul><li>$A\subseteq B\Longleftrightarrow P(A)\subseteq P(B)$；</li><li>$A=B\Longleftrightarrow P(A)=P(B)$；</li><li>$P(A)\in P(B)\Longrightarrow A\in B$，逆命题不成立（A={Φ}，B=）；</li><li>$P(A)\cap P(B)=P(A\cap B)$；</li><li>$P(A)\cup P(B)\subseteq P(A\cup B)$；</li><li>$P(A-B)\subseteq(P(A)-P(B))\cup\{\phi\}$；</li><li>$\bigcup P(A)=A$；（广义并集和幂集互为逆运算）</li></ul><blockquote><p>传递集合的通俗定义：满足以下 2 点的集合是传递集合</p><ol><li>A 的元素都是集合；</li><li>如果有的话，A 的元素的元素都是 A 的元素；</li></ol><p>外延定理的描述：$A为传递集合\Longleftrightarrow \forall x\forall y((x\in y\wedge y\in A)\rightarrow x\in A)$；</p><ul><li><strong>性质1：$A为传递集合\Longleftrightarrow A\subseteq P(A)$；</strong></li><li><strong>性质2：$A为传递集合\Longleftrightarrow P(A)也为传递集合$；</strong></li></ul></blockquote></li><li><p>笛卡尔积性质：不满足交换律、结合律，但满足对 $\cap$ 和 $\cup$ 的分配律；</p><ul><li>$x\in A,\space y\in A\Rightarrow\langle x,y\rangle\in PP(A)$</li><li>$A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C)\Leftrightarrow(C\times A\subseteq C\times B),\space where\space C\ne\phi$</li><li>$(A\times B\subseteq C\times D)\Leftrightarrow(A\subseteq C\wedge B\subseteq D),\space where\space A,B,C,D\ne\phi$</li></ul></li></ul></li><li><p>集合的基数（讨论有限集合）：规定 $|\phi|=0$</p></li></ul><h3 id="3-2-常见题型"><a href="#3-2-常见题型" class="headerlink" title="3.2 常见题型"></a>3.2 常见题型</h3><ul><li><p>写出给定集合的幂集</p></li><li><p>判断传递集合</p></li><li><p>给实际应用场景，求某个部分的基数</p><blockquote><p>例如：参加 A 的有 x 人，参加 B 的有 y 人……，有 z 个人同时参加了……，诸如此类；</p></blockquote><p><strong>思路：Venn 图，或者概率统计的加法公式（把求概率改成求基数即可）：$P(\bigcup\limits_{i=1}^n{A_i})=\sum\limits_{i=1}^nP(A_i)-\sum\limits_{1\le i\le j\le n}P(A_iA_j)+\cdots+(-1)^{n-1}P(A_1A_2\cdots A_n)$</strong>；</p></li><li><p>以谓词演算公式和集合定理，证明集合公式</p><p><strong>技巧总结</strong></p><ul><li><p>过于基本的式子，比如用三段论一步解决的：$A\in B\wedge B\subseteq C\Rightarrow A\in C$；</p><blockquote><p>建议直接推，如果需要改成谓词，就该，例如上面的题目的证明：</p><p>$A\in B\wedge B\subseteq C\Leftrightarrow A\in B\wedge\forall x(x\in B\rightarrow x\in C)\Rightarrow A\in C$；</p></blockquote></li><li><p>对于非定理式的、基本运算式的证明，一般采用：</p><ol><li><strong>等式证明：集合等值记忆式</strong>；</li><li>等价证明：集合常用等价关系（<strong>相等-包含关系、基本关系运算性质、幂集的性质</strong>）</li><li>重言蕴含证明：集合常用的推导方式（例如：等值运算、<strong>外延定理分解为谓词逻辑</strong>）</li></ol><p>e.g., 证明以下运算式</p><script type="math/tex; mode=display">\begin{aligned}&1.\space A\cap(B\oplus C)=(A\cap B)\oplus(A\cap C)\\&2.\space (A-B)\oplus(A-C)=\phi\Longleftrightarrow A-B=A-C\\&3.\space A\cup B=A\cup C\space且\space A\cap B=A\cap C\Longrightarrow B=C\\&4.\space P(A)\in P(B)\Longrightarrow A\in B\end{aligned}</script></li><li><p>对于定理式的证明（上一则技巧无法解决），一般采用：</p><ol><li>等式 / 重言蕴含的证明：使用外延定理分解为谓词逻辑，记得先声明 $\forall x$ ，从等式左边定义等价 / 重言蕴含推导，中途有必要可以引入新的约束变元，但量词要写在里面；（如果是关于笛卡尔积、二元组的证明，可以写 $\forall \langle x,y\rangle$）</li><li>等价证明：一般拆成双侧重言蕴含；如果是较为简单的、一眼看出的，可以一直等价到底；</li></ol><p>e.g., 证明下列各式：</p><script type="math/tex; mode=display">\begin{aligned}&1.\space A-B=A-(A\cap B)\\&2.\space A-B=A\cap-B\\&3.\space A\subseteq B\Longleftrightarrow P(A)\subseteq P(B)\\&4.\space A为传递集合\Longleftrightarrow P(A)为传递集合\end{aligned}</script></li><li><p>对于仅由集合运算符连接的式子的证明，要么一直使用等价变换，要么使用外延定理定义转化为谓词逻辑证明；</p><p>e.g., 证明以下式子：</p><script type="math/tex; mode=display">\begin{aligned}&1.\space P(A)\cup P(B)\subseteq P(A\cup B)\\&2.\space P(A-B)\subseteq(P(A)-P(B))\cup\{\phi\}\end{aligned}</script></li></ul></li></ul><h3 id="3-3-错题"><a href="#3-3-错题" class="headerlink" title="3.3 错题"></a>3.3 错题</h3><ul><li><p>证明：$A\subseteq P(\bigcup A)$</p><p><strong>错因：忘记考虑 $A=\phi$ 的情况需要分开讨论</strong>；</p></li></ul><h2 id="Chapter-4-关系"><a href="#Chapter-4-关系" class="headerlink" title="Chapter 4 关系"></a>Chapter 4 关系</h2><h3 id="4-1-重要概念集合"><a href="#4-1-重要概念集合" class="headerlink" title="4.1 重要概念集合"></a>4.1 重要概念集合</h3><ul><li><p>二元关系（<strong>有序对的集合</strong>）：若一个集合满足以下两个条件之一：</p><ol><li>集合非空，且它的元素均为有序对；</li><li>集合为空集；</li></ol><p>则称该集合为一个二元关系；记为 R，简称<strong>关系</strong>；</p></li><li><p>A 至 B 的二元关系：设 A，B 为集合，则 A × B 的<strong>任一子集</strong>所定义的二元关系，称为 <strong>A 到 B 的二元关系</strong>；</p><p>$R\subseteq\{\langle x,y\rangle|\space x\in A\wedge y\in A\}$（可以推广至 n 元关系）</p></li><li><p>特殊关系</p><ul><li>恒等关系：$I_A=\{\langle x,x\rangle|\space x\in A\}$</li><li>全域关系：$E_A=A\times A$</li><li>空关系：$\phi\subseteq A\times A$</li></ul></li><li><p>关系的定义域 $dom(R)$、值域 $ran(R)$、域 $fld(R)$（定义域和值域的并）</p></li><li><p>关系的表示</p><ul><li><p>关系矩阵：对于集合 $X=\{x_1,…,x_m\}$，$Y=\{y_1,…,y_n\}$，若 R 为从 X 到 Y 上的一个关系，则 R 的关系矩阵（bool 矩阵）为 $M(R)=(r_{ij})_{m\times n}$（如果有序对 $\langle x,y\rangle$ 在 $X\times Y$ 中，则 $r_{ij}=1$，否则为0）；</p><blockquote><p>起始集合元素为<strong>行</strong>，目的集合元素为<strong>列</strong>；</p></blockquote></li><li><p>关系图：使用<strong>有向边</strong>表示两个集合元素点的关系；</p></li></ul></li><li><p>关系的运算（设 R 为 X 到 Y 的关系，S 为 Y 到 Z 的关系）</p><ul><li><p>逆：$R^{-1}=\{\langle x,y\rangle|\space \langle y,x\rangle\in R\}$</p></li><li><p>合成：$S\circ R=\{\langle x,y\rangle|\space \exists z(\langle x,z\rangle\in R\space\wedge\langle z,y\rangle)\in S\}$</p><blockquote><p>遵循和函数复合一样的含义，内层先运算；</p></blockquote></li><li><p>A 在 R 下的象：$R[A]=\{y\space|\space\exists x(x\in A\space\wedge\langle x,y\rangle\in R)\}$</p></li><li><p>R 在 A 下的限制：$R\uparrow A=\{\langle x,y\rangle|\space \langle x,y\rangle\in R \wedge x\in A\}$</p><blockquote><p>象和限制可以理解为生物学上的“<strong>平板影印</strong>”，象是将 存在关系 R 中的元素影印在 A 上，限制是将 存在于 A 中的元素影印到 R 上；没有被影印到的元素就被抛弃；</p></blockquote></li></ul><p><strong>补充：关系矩阵和定义的联系：第一部分</strong></p><ol><li>关系的逆<strong>相当于关系矩阵的转置</strong>：$M(R^{-1})=M^T(R)$</li><li>关系的复合<strong>相当于关系矩阵逻辑乘法</strong>：$M(S\circ R)=M(R)\cdot M(S)$</li></ol></li><li><p>关系的运算性质</p><ul><li><p>逆的性质</p><ol><li>关系的逆会使定义域和值域对调；</li><li>$(R^{-1})^{-1}=R$</li><li>$(S\circ R)^{-1}=R^{-1}\circ S^{-1}$</li></ol></li><li><p>关系合成结合律：$(R\circ S)\circ Q=R\circ(S\circ Q)$</p><p><strong>关系合成不符合交换律：$R\circ S\ne S\circ R$</strong>；</p></li><li><p>关系合成对<strong>并运算</strong>满足分配律：</p><p>$R_1\circ(R_2\cup R_3)=R_1\circ R_2\cup R_1\circ R_3$</p><p>$(R_1\cup R_2)\circ R_3=R_1\circ R_3\cup R_2\circ R_3$</p><p><strong>关系合成对 交运算 不满足分配律：</strong></p><p>$R_1\circ(R_2\cap R_3)\subseteq R_1\circ R_2\cap R_1\circ R_3$</p><p>$(R_1\cap R_2)\circ R_3\subseteq  R_1\circ R_3\cap R_2\circ R_3$</p></li></ul></li><li><p>关系的性质（设 R 为集合 A 上的关系）</p><p><strong>第一组：自反性</strong></p><ul><li><p>自反性：$R在A上自反\Longleftrightarrow\forall x(x\in A\rightarrow\langle x,x\rangle\in R)$</p><p>反自反性（在有些教材里被称为非自反性）：$R在A上反自反\Longleftrightarrow \forall x(x\in A\rightarrow\langle x,x\rangle\notin R)$</p><p>非自反性（不常用）：<strong>即自反性的反面，“不自反的都算非自反”</strong>，下面将不再赘述；</p></li><li><p><strong>补充：关系矩阵和定义的关系</strong></p><ol><li>R 自反 当且仅当：M(R) <strong>全部对角线元素=1</strong>；</li><li>R 反自反 当且仅当：M(R)<strong>全部对角线元素=0</strong>；</li><li>R 非自反 当且仅当：M(R)对角线元素<strong>不全为1</strong>；</li></ol><blockquote><p>注：对于关系图而言，图上有自环；</p></blockquote></li><li><p><strong>自反性的重要结论</strong>：</p><ol><li><p>$R是自反的\Longleftrightarrow I_A\subseteq R$（反自反可以同理）</p></li><li><p>$R是自反的\Longleftrightarrow R^{-1}是自反的$</p><p>$R_1,\space R_2是自反的\Longleftrightarrow R_1\cup R_2和R_1\cap R_2是自反的$</p><p>（反自反完全相同）</p></li><li><p><strong>$R_1,R_2是自反的\Longleftrightarrow R_1\circ R_2$ </strong>（<strong>反自反不满足这个性质</strong>）</p></li></ol></li><li><p>自反关系的 Venn 图</p></li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="reflective.jpg" height="200px"></p><p><strong>第二组：对称性</strong></p><ul><li><p>对称性：$R在A上对称\Longleftrightarrow \forall x\forall y(x,y\in A\rightarrow(xRy\rightarrow yRx))$</p><p>反对称性：$R在A上反对称\Longleftrightarrow\forall x\forall y(x,y\in A\rightarrow(xRy\rightarrow\neg yRx))$</p><p>非对称性：略；</p><blockquote><p>反对称性根据题目证明的要求，还可以写成：</p><p>$\forall x\forall y(x,y\in A\wedge xRy\wedge yRx\rightarrow x=y)$</p><p>$\forall x\forall y(x,y\in A\wedge xRy\wedge x\ne y\rightarrow \neg yRx)$</p><p>等</p></blockquote></li><li><p><strong>补充：关系矩阵和定义的关系</strong></p><ul><li>R 对称 当且仅当：M(R)<strong>为对称阵</strong>；</li><li>R 反对称 当且仅当：<strong>M(R) 的所有对称位不同时为1</strong>；（可以同时为0）</li><li>R 非对称 当且仅当：M(R) <strong>不为对称阵</strong>；</li></ul></li><li><p><strong>对称性重要结论</strong>：</p><ol><li><p>$R为对称的\Longleftrightarrow R=R^{-1}$</p><p>$R_1,\space R_2是对称的\Longleftrightarrow R_1\cup R_2和R_1\cap R_2是对称的$</p></li><li><p><strong>反对称有特殊</strong>：$R_1\cup R_2不一定反对称$</p><p>$R为反对称\Longrightarrow R\cap R^{-1}\subseteq I_A$</p></li><li><p><strong>复合运算完全不行！</strong></p></li></ol></li><li><p>对称关系的 Venn 图</p></li></ul><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="symmetric.jpg" height="200px"></p><p><strong>第三组：传递性</strong></p><ul><li><p>传递性：$R在A上传递\Longleftrightarrow\forall x,y,z\in A(xRy\wedge yRz\rightarrow xRz)$</p><p>反传递性：$R在A上反传递\Longleftrightarrow\forall x,y,z\in A(xRy\wedge yRz\rightarrow\neg xRz)$</p><p>非传递性：略；</p></li><li><p><strong>传递性重要性质</strong>：</p><ol><li>传递性和自反性、对称性一样，满足性质的关系的<strong>逆、交</strong>都是传递的，<strong>但并运算不是</strong>；</li><li><strong>复合运算还是不行……</strong></li></ol></li></ul></li><li><p>关系性质的总结：如果 R 具有对应的关系那么……</p><table>    <tr>        <td>(是否具有？)</td>        <td>自反性</td>        <td>对称性</td>        <td>传递性</td>        <td>反自反性</td>        <td>反对称性</td>        <td>反传递性</td>    </tr>    <tr>        <td>R的逆关系</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>    </tr>    <tr>        <td>R的并关系</td>        <td>✔</td>        <td>✔</td>        <td>❌</td>        <td>✔</td>        <td>❌</td>        <td>❌</td>    </tr>    <tr>        <td>R的交关系</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>        <td>❌</td>    </tr>    <tr>        <td>R的复合关系</td>        <td>✔</td>        <td>❌</td>        <td>❌</td>        <td>❌</td>        <td>❌</td>        <td>❌</td>    </tr></table></li><li><p>关系的闭包：某些关系不满足一些性质，为了方便研究，向关系集合中加入<strong>尽可能少的</strong>元素生成一个<strong>满足该性质的超集合</strong>，称为闭包；</p><ul><li><p>前置性质</p><ol><li><p>$R^0=I_A$</p></li><li><p>$R^{n+1}=R^n\circ R,\space R^m\circ R^n=R^{m+n},\space (R^m)^n=R^{mn}$</p></li><li><p>有限集上关系幂序列的周期性：若存在自然数 s、t 使得：$R^s=R^t$，则：</p><p>$R^{s+k}=R^{t+k},\space R^{s+kp+i}=R^{s+i}$</p><p>$B=\{R^0,R^1,…,R^{t-1}\}\Rightarrow\forall q\in N,\space R^q\in B$（思考：为何是最大的t？）</p></li></ol></li><li><p>闭包定义：设 R 为非空集合 A 上的关系，若 A 上有另一关系 R‘，满足：</p><ol><li>$R\subseteq R^\prime$（<strong>扩展得来</strong>）</li><li>$R^\prime$ 是具有对应性质的（扩展集具有性质）</li><li>对 A 上任何具有同样性质的关系 $R^{\prime\prime}$ 有：$R^\prime\subseteq R^{\prime\prime}$（<strong>扩展集最小</strong>）</li></ol></li><li><p>自反闭包记为 $r(R)$，对称闭包记为 $s(R)$，传递闭包记为 $t(R)$</p></li><li><p>闭包的性质</p><ol><li><p><strong>已有即当前</strong>：$R为自反的\Longleftrightarrow r(R)=R$（其他同理，下面不再赘述）</p></li><li><p>不同的关系可能多出“不在扩展中的元素”：$R_1\subseteq R_2\Rightarrow r(R_1)\subseteq r(R_2)$</p></li><li><p><strong>仅对并运算 + 自反/对称成立分配律</strong>：</p><p>$r(R_1)\cup r(R_2)=r(R_1\cup R_2)$</p><p>$s(R_1)\cup s(R_2)=s(R_1\cup R_2)$</p><p>$t(R_1)\cup t(R_2)\subseteq t(R_1\cup R_2)$</p></li><li><p><strong>闭包叠加</strong>：自反性“不受影响、不影响别人”，对称性“自己不受影响，只是会影响传递”，传递性“不影响别人，但会被对称性影响”</p><p>$R自反\Longrightarrow s(R),\space t(R)自反$</p><p>$R对称\Longrightarrow r(R),\space t(R)对称$</p><p>$R传递\Longrightarrow r(R)传递$</p><p>因此我们知道了，想要求叠加闭包，传递性质最脆弱，需要最后求传递闭包</p><p>$rs(R)=sr(R),\space rt(R)=tr(R),\space st(R)\subseteq ts(R)$</p><p>求“等价闭包”：$tsr(R)$ </p></li></ol></li><li><p>闭包的构造：若 R 不满足对应的性质</p><ul><li><p>$r(R)=R\cup R^0$</p></li><li><p>$s(R)=R\cup R^{-1}$</p></li><li><p>$t(R)=\bigcup\limits_{i=1}^\infty{R^i}$，特别地，对于有限非空集 A，一定存在一个正整数 $k\le|A|$，使得：$t(R)=R^+=\bigcup\limits_{i=1}^kR^i$</p><blockquote><p>这样的操作联想到图论中的<strong>求两点间是否有路径</strong>的算法，所以这里也可以使用 <a href="#Warshell">Warshell 算法 🔗</a></p></blockquote></li></ul></li></ul></li></ul><ul><li><p>等价关系、等价类、商集、划分</p><p>这一部分定义很长，这里仅仅说明一下对概念的理解：</p><ul><li><p>等价关系：<strong>同时满足自反、对称、传递的关系</strong></p></li><li><p>等价类：$[x]_R=\{y\space|\space y\in A\wedge xRy\}$，<strong>A 中所有和元素 x（包含自身）满足 R 关系的元素组成的集合</strong>；</p><p><strong>等价类的所有性质也可以理解为：相互等价的元素一定在一个集合（等价类）里，不相互等价的一定不在一个等价类里</strong>；</p></li><li><p>商集：A 的所有等价类构成的集合（是集合的集合）</p></li><li><p>划分：数学家们通过证明发现，用元素等价区分的方式刚好能够划分一个集合，也就是说，<strong>一个等价类和一个划分一一对应</strong>。数学上称为<strong>诱导</strong>，等价关系可以诱导出一个对应的划分，一个划分又可以诱导出一个对应的等价类；</p><p><strong>划分的性质</strong>：（数学形式描述请查阅资料）</p><ol><li>分块全部来自 A、且每个分块不为空；</li><li>所有分块完全覆盖 A；</li><li><strong>每个分块不重叠</strong>；</li></ol></li></ul></li><li><p>相容关系、相容类、覆盖</p><ul><li>相容关系：<strong>同时满足自反、对称（比等价关系缺少传递）的关系</strong>；</li><li>最大相容类性质：对任意不在最大相容类中的一个元素，总能找到类中的一个元素和它不满足相容关系；</li></ul><p><strong>只要理解覆盖和划分的区别，覆盖是每个分块能够重叠</strong>；</p><p><strong>完全覆盖的唯一性；覆盖能够确定一个相容关系、相容关系能够确定一个完全覆盖</strong>；</p><blockquote><p>在关系图中，找相容关系相当于找 <strong>所有的极大完全子图</strong>（这个分块内每个元素都要有相互的关系），边可以重叠</p></blockquote><ul><li><strong>由覆盖构造相容关系</strong>：给定非空集 A 上的一个覆盖 $\Omega=\{A_1,A_2,…,A_n\}$，则由其确定的关系 $R=\bigcup\limits_{i=1}^nA_i\times A_i$ 是 A 上的一个相容关系（不一定是最大相容关系）；</li></ul></li></ul><ul><li><p>偏序关系：同时满足<strong>自反、反对称、传递</strong>性质的关系</p><p>拟序关系：同时满足<strong>反自反、传递</strong>性质的关系（由这两个性质能推出<strong>反对称性</strong>）</p><blockquote><p>偏序关系能理解为抽象的 “≤” 关系</p><p>拟序关系能理解为抽象的 “＜” 关系</p></blockquote><p><strong>偏序关系和拟序关系仅在自反性上有差别，拟序和偏序讨论一个即可</strong></p><p>e.g.1, 对集合 A，在 P(A) 上的包含关系是偏序关系；在 P(A) 上的真包含关系是拟序关系；</p><p>e.g.2, 可以通过增添/删减自反性来变换两者：$R\rightarrow R-R^0\space或\space R\rightarrow R\cup R^0$</p></li><li><p>结构、偏序集</p><p>结构：集合 A 及其上的关系 R 一起称为一个<strong>结构</strong>；</p><p>偏序集：若结构中的关系 R 是偏序关系，称这个结构为<strong>偏序集</strong>，记作$\langle A,R\rangle$；</p><blockquote><p>$\langle N,\le\rangle$、$\langle P(A),\subseteq\rangle$ 都是偏序集</p></blockquote></li><li><p>哈斯图：由于偏序关系自反（自环）、反对称（两顶点间最多一条有向边），所以表达偏序关系的图可以：①省略自环；②适当安排位置（默认偏序箭头向上）不画边的方向；③不画传递得到的边，这种图称为哈斯图（描述性定义）；</p><p><strong>预定义：盖住关系，对偏序关系 $\langle A,\preccurlyeq\rangle$，若 $x,y\in A,\space x\preccurlyeq y,\space x\ne y$，且不存在 $z\in A$ 使得 $x\preccurlyeq z\wedge z\preccurlyeq y$，则称 y 盖住 x</strong>；（理解为抽象的<strong>直接后继关系</strong>）</p><p><strong>定理：对所有偏序集$\langle A,\preccurlyeq\rangle$，A 上的盖住关系 cov A 唯一</strong>；</p><p>画法：① 每个顶点代表 A 的一个元素；② 如果 $x\preccurlyeq y\wedge x\ne y$，将 y 置于 x 上方（后继在上）；③ 仅在 cov A 中有的关系才能在哈斯图上连接无向边（这保证了不画传递的边）；</p></li><li><p>可比：对于偏序集 $\langle A,\preccurlyeq\rangle$，若$\forall x,y\in A\Rightarrow x\preccurlyeq y\vee y\preccurlyeq x$，则称 x 和 y 可比；</p><blockquote><p><strong>不可比不代表不能讨论 x 和 y 的关系，只是说两者双向的 $\preccurlyeq$ 都是假而已</strong>；</p></blockquote></li><li><p>偏序关系的上下界</p><p>最小元的感性理解：必须<strong>和其他所有元素构成偏序关系，且它是所有元素的“前驱”</strong>；（最大元同理）；<strong>因此最小/大元不一定存在（不一定与所有都可比），但如果存在一定唯一</strong>；</p><p>极小元的感性理解：<strong>不能是某一个元素的“后继”就行</strong>，可以与某些元素不可比；<strong>因此极小元必然存在，可能不唯一</strong>；</p><p>上下界和上下确界：比较明显，意会一下~</p></li><li><p>全序关系的感性理解：一个偏序集 $\langle A,\preccurlyeq\rangle$ 中，所有元素间都可比，就称这个集为<strong>全序集</strong>，这个 $\preccurlyeq$ 关系称为<strong>全序关系</strong>；</p><blockquote><p>很容易理解，有限的全序集一定是有最大、最小元的；</p><p>$\langle N,\le\rangle$ 是全序集，$\langle P(A),\subseteq\rangle$ 不是；<strong>因为自然数集上所有元素对于“小于等于”两两可比，但幂集的元素——集合可能两者都没有包含关系，即对于“包含关系”不可比</strong>；</p></blockquote></li><li><p>链的感性理解：将偏序集中相互可比的元素，构成一个子集，这个子集就是<strong>链</strong>，其中元素数称为<strong>链长</strong>；</p><blockquote><p>为什么叫链？<strong>因为如果一系列元素可比，那么在哈斯图上呈现的是一条链，不会出现分支</strong>；</p><p>这也是为什么全序关系又称为“线序关系”的原因；</p><p>找全序关系就是找贯穿所有元素的链；</p></blockquote></li><li><p>良序关系：一个偏序集 $\langle A,\preccurlyeq\rangle$，A 的任意非空子集都有最小元，那么 $\preccurlyeq$ 就叫做<strong>良序关系</strong>，这个偏序集叫做<strong>良序集</strong>；</p></li></ul><h3 id="4-2-常见题型"><a href="#4-2-常见题型" class="headerlink" title="4.2 常见题型"></a>4.2 常见题型</h3><ul><li><p>求集合划分的种类数</p><blockquote><p>结论：贝尔数 $B_n$；<a href="https://oi-wiki.org/math/combinatorics/bell/">知识链接🔗</a></p><p>$B_n=C_{n-1}^0B_{n-1}+C_{n-1}^1B_{n-2}+\cdots+C_{n-1}^{n-1}B_0$；</p><p>可以用贝尔三角形每行第一个数来计算；</p><p>考到就仰仗自己的数学吧😭</p><p>帮你算几个：$B_0=B_1=1,\space B_2=2,\space B_3=5,\space B_4=15,\space B_5=52,\space B_6=203$</p><p>考场上基数大于 6 的集合的划分数，如果出到，请好好地问候出题老师！</p></blockquote></li><li><p>求各种闭包</p></li><li><p>求划分/等价类的元素和关系、由覆盖求对应的相容关系</p><p><strong>按照定义和性质，按部就班地来即可</strong></p></li><li><p>证明某个关系的性质，证明关系符合的公式</p><p><strong>思路：一般情况下，关系的元素是有序对，所以证明时一般都先声明一个 $\forall\langle x,y\rangle$</strong>，然后依次向下推理即可；</p><p><strong>特别地，如果是已定义的关系，例如等价关系，那么按照定义来</strong></p><blockquote><p>e.g.1, 设 $R,S,T$ 是 A 上的关系，证明：$R\circ(S\cup T)=(R\circ S)\cup(R\circ T)$</p><p>e.g.2, 已知 $A=Z_+\times Z_+$ 和 A 上的关系 $R=\{\langle\langle x,y\rangle,\langle u,v\rangle\rangle\space|\space xv=yu\}$； 证明 R 是等价关系；</p><p>e.g.3, 设 $\langle A,R_1\rangle,\space\langle B,R_2\rangle$ 是两个偏序集，定义 $A\times B$ 上的关系 R：对 $\forall a_1,a_2\in A,b_1,b_2\in B$，有 $\langle a_1,b_1\rangle R\langle a_2,b_2\rangle\Longleftrightarrow a_1R_1a_2\wedge b_1R_2b_2$，证明 R 是 $A\times B$ 上的偏序关系；</p></blockquote></li><li><p>给某个关于关系的公式找出反例</p><p><strong>思路：对于自反、对称而言，一般只需要找二阶关系矩阵就能发现矛盾；对于传递而言，需要从三阶关系矩阵开始找，先为每个矩阵设定一个传递关系，其他空不填，假设是0，看是否能成为反例；如果不行，在对空白处进行值的给定；</strong></p></li><li><p>判断一个结构是不是偏序关系：按定义来</p></li><li><p>考察偏序关系最大/小元、极大/小元的定义</p></li><li><p>画出偏序关系的哈斯图</p><blockquote><p>e.g., 对下列集合上的整除关系画出哈斯图，并指出在这个关系下的极大元、极小元、最大元、最小元（如果有的话）</p><p><code>A = &#123;1, 2, 3, 4, 6, 8, 12, 24&#125;</code> 和 <code>B = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</code></p><p>思考：从哈斯图上，我们能够如何更快地看出极大极小元？</p></blockquote></li><li><p>找到某个特定集合的一个全序关系</p><blockquote><p>找全序关系就是找一条贯穿集合所有元素的链</p><p>e.g., 找出在集合 <code>&#123;0, 1, 2, 3&#125;</code> 上包含 $\langle0,3\rangle$ 和 $\langle2,1\rangle$ 的全序关系；</p><p><strong>思路：将所有元素排成一条链，转化为排队问题</strong>；</p><p>如果要求包含某个元素，等价于某个元素必须排在另一个元素的前面/后面；</p><p>提示：本例共有 $C_3^1+C_3^2=6$ 种满足条件的全序关系；</p></blockquote></li></ul><h2 id="Chapter-5-函数"><a href="#Chapter-5-函数" class="headerlink" title="Chapter 5 函数"></a>Chapter 5 函数</h2><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><p>函数这章掌握几个概念和结论就行</p><ul><li><p>定义：就是一种集合 A 到集合 B 间的特殊关系；</p><blockquote><p>注意：$dom(f)=A$，不然就不是函数了</p></blockquote></li><li><p>部分函数：$dom(f)\subset A$，例如 $f:R\rightarrow R$ 的函数 $f(x)=\dfrac{1}{x}$，只有减去定义域中的 $\{0\}$ 或者在 $x=0$ 处添加定义，才能变为函数；</p></li><li><p>所有函数的集合：$A_B=\{f\space|\space f:A\rightarrow B\}$，也写作 $B^A$，<strong>基数 $|A_B|=|B|^{|A|}$</strong>；</p><blockquote><p>总数小于总关系数 $2^{|A||B|}$，<strong>因为：$A\ne \phi,\space B=\phi$ 不是函数、$A=\phi,\space B\ne\phi$ 只对应一个函数：空函数</strong>；</p></blockquote></li><li><p>单射、满射、双射的定义</p></li><li><p>常用函数的定义：常函数、恒等函数、n 元运算、泛函、特征函数、典型映射；</p></li><li><p>函数的合成</p><p><strong>着重掌握特性</strong>：</p><p><strong>定理：若 $f,g$ 满射，则$f\circ g$ 满射（单射、双射同理）</strong></p><p>逆定理：$f\circ g$ 满射则 $f$ 满射；$f\circ g$ 单射则 $g$ 单射；$f\circ g$ 双射，则 $f$ 满射、$g$ 单射；</p><p><strong>逆定理记忆：全部都是“外层满、内层单”</strong></p></li><li><p>函数的逆</p><p><strong>着重掌握左逆、右逆的性质</strong>：</p><p>定理：f 既有左逆、又有右逆，等价于 f 双射且左右逆相等；f 有左逆 $(g\circ f)$ 等价于 f 单射；f 存在右逆 $(f\circ g)$ 等价于 f 满射；</p><p><strong>记忆：还是“外层满、内层单”，函数在什么位置有逆，就是什么侧的满/单</strong>；</p></li></ul><h3 id="5-2-常见题型"><a href="#5-2-常见题型" class="headerlink" title="5.2 常见题型"></a>5.2 常见题型</h3><ul><li><p>判断单/满/双射</p></li><li><p>给定集合，要求构造集合间的 单射/满射/双射函数；</p><p><strong>一般情况都比较简单，有些不好想的需要记忆一下，例如：构造从 $N\times N$ 到 $N$ 的双射函数；答案是在点阵中有序环绕：$f(\langle m,n\rangle)=\dfrac{1}{2}(m+n)(m+n+1)+m$</strong>；大部分其他的无穷集上的构造也多采用这种方法；</p></li></ul><h3 id="5-3-错题"><a href="#5-3-错题" class="headerlink" title="5.3 错题"></a>5.3 错题</h3><ul><li><p>关于 $A\rightarrow\phi$ 的函数,下列（）是正确的</p><p>A．不存在</p><p>B．有一个空函数 $\Phi$</p><p>C．仅当 A 非空时才能有函数</p><p>D．仅当 A 为空时才能有函数</p><p><strong>事实上，$A\ne\phi,\space B=\phi$ 的函数不存在，但如果 A、B 都为空，那么可以是空函数</strong>；</p></li></ul><h2 id="Chapter-6-图论"><a href="#Chapter-6-图论" class="headerlink" title="Chapter 6 图论"></a>Chapter 6 图论</h2><h3 id="6-1-图论中的重要定义Ⅰ"><a href="#6-1-图论中的重要定义Ⅰ" class="headerlink" title="6.1 图论中的重要定义Ⅰ"></a>6.1 图论中的重要定义Ⅰ</h3><blockquote><p>图的起源：人们关心一类问题，给定的两点间是否有一条或多条连线的关系，而连接方式无关紧要。这类问题在数学上的抽象是<strong>图</strong>；</p></blockquote><ul><li><p>图的数学定义：一个图指<strong>有序三元组$(V(G),E(G),\psi_G)$</strong>，<strong>$V(G)$</strong>为<strong>非空</strong>（空图特殊，不参与讨论）顶点集，<strong>$E(G)$</strong>是不与<strong>$V(G)$</strong>相交的边集，<strong>$\psi_G$</strong>为关联函数；</p><blockquote><p>约定：对于图 G，一般用符号 <strong>$V(G)$</strong> 表示顶点集、<strong>$E(G)$</strong> 表示边集、<strong>$\nu(G)$</strong> 表示顶点数，<strong>$\varepsilon(G)$</strong> 表示边数；若上下文仅有一个图，则省略 “(G)”；</p><p>注：无向图可以表示为二元组，即 V 和 E；</p></blockquote></li><li><p>顶点对的定义：<strong>$\psi_G$</strong> 使 G 的每条边对应于 G 的 无序的<strong>顶点对</strong>；</p></li><li><p>连接、端点的定义：若 e 为 G 的一条边，u、v 是使 <strong>$\psi_G(e)=(u,v)$</strong> 的顶点，则称：e <strong>连接</strong> u、v，顶点 u、v 称为 e 的<strong>端点</strong>；</p></li><li><p>关联、相邻、自环：一条边的端点与这条边<strong>关联</strong>；与同一条边关联的两个顶点称为<strong>相邻</strong>；端点重合为一点的边称为<strong>自环</strong>；</p></li><li><p>平面图、非平面图：边仅在端点相交的图称为<strong>平面图</strong>，反之为非平面图；</p></li><li><p>平凡图、非平凡图：仅有一个顶点的图称为<strong>平凡图</strong>；</p></li><li><p>有向边、无向边：可由端点 <strong>$v_i\space和\space v_j$</strong> 表示 <strong>$e_k=(v_i,v_j)$</strong> 的边称为<strong>无向边</strong>（vi、vj互为直接前驱、直接后继）；可由有序二元组 <strong>$e_k=\langle v_i,v_j\rangle$</strong> 表示的边是<strong>有向边</strong>（vi是vj的直接前驱、vj是vi的直接后继）；</p></li><li><p>有向图、无向图：所有边都是有向边的图是<strong>有向图</strong>，反之是<strong>无向图</strong>，否则是混合图；</p><blockquote><p>可以将无向边视作双向有向边，因此此后不讨论混合图；</p></blockquote></li><li><p>简单图、有向简单图：既没有<strong>自环</strong>，又没有<strong>重边</strong>的图，如果是无向图，称为<strong>简单图</strong>；如果是有向图，称为<strong>有向简单图</strong>；</p><blockquote><ol><li><p>重边的定义：有两条及以上条边连接同一对顶点，称这个边为重边；</p><p>⚠<strong>易错警示：对有向边，A—-&gt;B 和 B—-&gt;A 组合不算重边！A—-&gt;B 和 A—-&gt;B 组合才是</strong>；</p></li><li><p>如果不强调“有向”，一般情况下“图”指“无向图”；不过在定义中，如果发现只描述无向图的，大概率对有向图也适用，不然就单独拎出来了；</p></li></ol></blockquote></li><li><p>完全图、有向完全图：每对不同顶点都有一条边相连的<strong>简单</strong>图称为<strong>完全图</strong>；有向完全图同理；</p><p><strong>特别地，将 n 个结点的完全图记作 $K_n$，但有向完全图没有这种记法；</strong></p><blockquote><p><strong>定理1：$\varepsilon(K_n)=C^2_{n}$ 且对n 个结点的有向完全图G：$\varepsilon(G)=A^2_{n}$；</strong></p><p>（因为A—-&gt;B 和 B—-&gt;A 组合不算重边） </p></blockquote></li><li><p>偶图（或者称二部图）：一个图 G 的顶点集 <strong>$V(G)$</strong> 可以分解为两个子集 X、Y，使得：每条边都有一个顶点在 X 中，另一个顶点在 Y 中；这样的一种分类 (X, Y) 称为 G 的一个<strong>二分类</strong>；</p><blockquote><p>理解：按分解的两个点集“切一刀”，所有边都被砍断的图；</p></blockquote></li><li><p>子图：若 <strong>$V(H)\subseteq V(G),\space E(H)\subseteq E(G)$</strong>，<strong>$\psi_H$</strong> 为 <strong>$\psi_G$</strong> 在 <strong>$E(H)$</strong> 上的限制，则 <strong>$H$</strong> 为 <strong>$G$</strong> 的<strong>子图</strong>，记作：<strong>$H\subseteq G$</strong>；（真子图略）</p></li><li><p>母图：若 <strong>$H\subseteq G$</strong>，称 <strong>$G$</strong> 为 <strong>$H$</strong> 的<strong>母图</strong>；</p></li><li><p>生成子图（或称支撑子图，spanning sub-graph）：<strong>$H\subseteq G\space且\space V(H)=V(G)$</strong>，称 <strong>$H$</strong> 为 <strong>$G$</strong> 的<strong>生成子图</strong>；</p></li><li><p>导出子图：有点抽象，一般用不到定义，想要形象地了解见：<a href="#graphCalc">图的运算🔗</a>；</p></li><li><p>基础简单图：一个图 G 删去所有<strong>“多余”的边</strong>，使图中恰没有重边、自环，得到的这样的<strong>简单生成子图</strong>称为<strong>基础简单图</strong>；</p></li><li><p>赋权图（或称加权图）：若给图 G 的每条边都赋以实数 <strong>$w_k$</strong> 作为该边的权，称 G 为赋权图；</p></li><li><p>顶点的度：图 G 的顶点 v 的度记为 <strong>$d_G(v)$</strong>，指 G 中与 v 相关联的数目；</p><ul><li>约定：<strong>$\delta(G)、\Delta(G)$</strong> 表示 G 的所有顶点的最小度、最大度；</li><li>度为0的点称为<strong>孤立点</strong>；</li><li><strong>对于有向图，$d(v)=d_+(v)+d_-(v)$，$d_+$ 为正度/入度，$d_-$ 为负度/出度</strong>；</li><li><strong>自环贡献一个入度、一个出度</strong>；</li></ul><blockquote><p><strong>定理2：（握手定理）$\sum\limits_{v\in V}d(v)=2\varepsilon$（所有结点的度之和为边数的2倍，有向图也是）</strong>；</p><p>推论：对任何图，度为奇数的点（称<strong>奇点</strong>）的个数为偶数；</p><p><strong>定理3：有向图中，$\sum{d_-}=\sum{d_+}=\varepsilon$（入度和=出度和=边数，是入度出度平分的意思）</strong></p><p><strong>定理4：非空简单图（$\varepsilon\gt1$）一定存在度相同的结点</strong>；</p></blockquote></li></ul><h3 id="6-2-图的同构"><a href="#6-2-图的同构" class="headerlink" title="6.2 图的同构"></a>6.2 图的同构</h3><blockquote><p>注：图同构问题分为4类：精确图完全同构、精确子图同构、不精确图完全同构、不精确子图同构；现在学界已证明后三者是 NP 完全问题；计算机离散数学-图论、数据结构（包括下面的内容）讨论的是第一种问题；</p></blockquote><ul><li><p>恒等图的定义</p></li><li><p>同构图的定义：如果存在两个<strong>一一映射（双射）$\theta:\space V(G)\rightarrow V(H),\space\phi:\space E(G)\rightarrow E(H)$</strong>，使 <strong>$\psi_G(e)=(u,v)$</strong> 当且仅当 <strong>$\psi_H(\phi(e))=\theta(u)\theta(v)$</strong>，则将这样的映射对 <strong>$(\theta,\phi)$</strong> 称为 G 和 H 间的一个同构；将 G 与 H 同构关系记为 <strong>$G\cong H$</strong>；</p><blockquote><p>理解：边边和点点必须一一相应；</p><p>就是在不添加边和点、不删除边和点的基础上<strong>任意移动顶点的相对位置、为顶点和边改名</strong>，所产生的不同形态的图；</p></blockquote></li><li><p>关于同构的定理</p><blockquote><p><strong>定理5：（同构的必要条件）两个同构图的结点度的非增序列相同</strong></p><p><strong>定理6：（同构的必要条件）若 G1 与 G2 同构，则 G1 的任意<u>导出子图</u>都有 G2 的导出子图与其同构</strong>；</p><p>其实还有一个必要条件过于明显，不作为定理：两同构图的顶点数、边数相等；</p></blockquote></li><li><p>判断方法</p><ul><li><p>判断两图同构：<strong>按定义，找到两个一一映射</strong>；</p><blockquote><p>注：根据定义，可以得出一个显然的方法：<strong>一个图的邻接矩阵经历有限次的行互换、列互换，能变成另一个图的邻接矩阵，那么这两个图同构</strong>；</p></blockquote></li><li><p>判断两图不同构：使用定理5、6（必要条件），不满足必要条件的就不是；</p></li></ul></li></ul><h3 id="6-3-图的存储实现"><a href="#6-3-图的存储实现" class="headerlink" title="6.3 图的存储实现"></a>6.3 图的存储实现</h3><ul><li><p><span id="relM">图的关联矩阵（<strong>行是顶点，列是边</strong>）：因为空间原因，不做存储图的方法；</span></p><blockquote><p>虽然不做存储方法，但在讨论<strong>树、有向连通图、电路图的某些性质</strong>时比较有用，感兴趣戳<a href="#relMDetails">这里🔗</a>（不在初级数据结构要求范围内）；</p></blockquote><ul><li>无向图的关联矩阵：可以由 bool 矩阵表示，1是有关联，0是没有关联；</li><li>有向图的关联矩阵：+1表示该边离开该结点，即正度/出度；-1表示该边进入该结点，即负度/入度；0表示没有关联；</li></ul></li><li><p>图的邻接矩阵表示法：对任意的图 G，对应一个 <strong>$\nu\times\nu$</strong> 的邻接矩阵 <strong>$A(G)=[a_{ij}]$</strong>，其中 <strong>$a_{ij}$</strong> 为 <strong>$v_i、v_j$</strong> 的连接数目；（空间：<strong>$O(|V|^2)$</strong>）</p><p><strong>进一步，在数据结构中更常用的是“加权图的邻接矩阵”存储方法，可以兼顾非加权图：</strong></p><script type="math/tex; mode=display">A[i][j]=\begin{equation}\left\{\begin{aligned}&\omega,&<i,j,w>\in E\\&0,&i=j\\&\infty,&otherwise\\\end{aligned}\right.\end{equation}</script><p><strong>C++代码实现统一放置于附录中，有需要可以前去查看，下同；</strong></p></li><li><p>图的邻接表表示法：改进了邻接矩阵表示法在面对稀疏矩阵时浪费空间、不易维护的问题；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">结点集(结点数组)：node1 &#123;结点值，与该结点相邻的直接后继(有方向)结点索引链表头指针&#125;</span><br><span class="line"> |------------------------------------------------------------|</span><br><span class="line"> v</span><br><span class="line">边集(单链表)：node2 &#123;结点索引（不能放结点值，因为无法完成后面的遍历运算, 下一node2&#125;</span><br><span class="line"></span><br><span class="line">+ 保存边数、保存结点数</span><br><span class="line">空间：O(|V|+|E|)</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-4-图的运算实现"><a href="#6-4-图的运算实现" class="headerlink" title="6.4 图的运算实现"></a>6.4 图的运算实现</h3><ul><li><p><span id="graphCalc">图的基本运算</span></p><ul><li><p>差运算：<strong>（要求 $G_2$ 为 $G_1$ 子图）$G_1-G_2=(V_1,E_1-E_2)$</strong>；</p></li><li><p>补运算：<strong>$n$</strong> 个结点的简单图的补图 <strong>$\overline{G}=K_n-G$</strong>；</p></li><li><p>删去结点 <strong>$v$</strong> 及其关联的边：<strong>$G-v$</strong></p><blockquote><p><strong>$G-v$</strong> 为 <strong>$G$</strong> 的<strong>导出子图</strong>：有助于理解导出子图的意义；</p></blockquote></li><li><p>删去边 <strong>$e$</strong>：<strong>$G-e$</strong></p><blockquote><p><strong>$G-e$</strong> 为 <strong>$G$</strong> 的<strong>生成子图</strong>：有助于理解生成子图的意义；</p></blockquote></li><li><p>增加边 <strong>$e_{ij}=(v_i,v_j)$</strong>：<strong>$G+e_{ij}$</strong></p></li></ul></li><li><p>数据结构中图的基本运算：创建、判边、增删边、查点边数、遍历（后面分开讨论）；</p></li><li><p>图的运算实现：<strong>对于不同的存储方式，图的运算时间复杂度有所不同</strong></p><ul><li><p>邻接矩阵表示的运算实现</p></li><li><p>邻接表表示的运算实现</p></li></ul></li></ul><h3 id="6-5-图论中的重要定义Ⅱ"><a href="#6-5-图论中的重要定义Ⅱ" class="headerlink" title="6.5 图论中的重要定义Ⅱ"></a>6.5 图论中的重要定义Ⅱ</h3><ul><li><p>道路和回路：在无向图 <strong>$G=(V,E)$</strong> 中，若<u>边点交替序列</u> <strong>$P=(v_{i1},e_{i1},v_{i2},e_{i2},…,e_{iq-1},v_{iq})$</strong> 满足：<strong>$v_{ik}、v_{ik+1}$</strong> 为 <strong>$e_{ik}$</strong> 的两个端点，则称 P 为 G 的一条<strong>道路</strong>；特别地，如果 <strong>$v_{i1}=v_{iq}$</strong>，那么称道路 P 为 G 的一条<strong>回路</strong>；</p><ul><li>如果 P 序列中没有重复的边，则 P 称为<strong>简单道路（或称“迹”）、简单回路（或称“闭迹”）</strong>；</li><li>更特别地，如果 P 序列中结点也不重复（结点不重复是边不重复的充分不必要条件），则称 P 为 G 的<strong>初级道路、初级回路</strong>；</li></ul></li><li><p>有向道路和有向回路：在有向图 <strong>$G=(V,E,\psi_G)$</strong> 中，若<u>边序列</u> <strong>$P=(e_{i1},e_{i2},…,e_{iq})$</strong>，其中  <strong>$e_{ik}=(v_l, v_j)$</strong>，则称 P 为 G 的<strong>有向道路</strong>；若 <strong>$e_{iq}$</strong> 终点也是 <strong>$e_{i1}$</strong> 的始点，则称 P 为 G 的<strong>有向回路</strong>；</p><ul><li>同样有：简单有向道路、简单有向回路、初级有向道路、初级有向回路的概念；</li></ul><blockquote><p>⚠易错点：<strong>平凡图一定是道路，但一定不是回路！</strong></p></blockquote></li><li><p>连通性、强连通性、弱连通性、单向连通性</p><ul><li>无向图考虑“连通”：两结点间至少存在一条道路，则这两个结点间连通；</li><li>有向图考虑：<ol><li>两结点间存在一条从 <strong>$v_i$</strong> 到 <strong>$v_j$</strong> 的有向道路 <strong><u>且</u></strong> 存在另一条从 <strong>$v_j$</strong> 到 <strong>$v_i$</strong> 的有向道路，则称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>强连通</strong>；</li><li>两结点间<strong><u>仅</u></strong>存在一条从 <strong>$v_i$</strong> 到 <strong>$v_j$</strong> 的有向道路 <strong><u>或</u></strong> <strong><u>仅</u></strong>存在另一条从 <strong>$v_j$</strong> 到 <strong>$v_i$</strong> 的有向道路，则称称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>单向连通</strong>；</li><li>两结点间 <strong>不考虑所有道路的方向（称为“有向图的底图”）</strong>，若这两个结点连通，则称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>弱连通</strong>；</li></ol></li></ul></li><li><p>连通图、连通分量（或称“连通支”）</p><ul><li>无向图 G 中任意两结点间都是连通的，则 G 为<strong>连通图</strong>；</li><li>G 的连通子图（子图且连通）H 不是 G 的任何其他连通子图的真子图，称 H 为 G 的一个<strong>极大连通子图</strong>，也称<strong>连通分量</strong>；</li></ul><blockquote><p>有些不严谨的题问有向图“是不是连通图”，就将它看成一个无向图（忽略方向）；</p></blockquote></li><li><p>强连通图、强连通分量</p><ul><li>有向图 G 中任意两结点间都是强连通的，则 G 为<strong>强连通图</strong>；</li><li>G 的强连通子图 H 不是 G 的任何其他强连通子图的真子图，称 H 为 G 的一个<strong>极大的强连通子图</strong>，也称<strong>强连通分量</strong>；</li></ul><blockquote><p>⚠易错点1：<strong>平凡图也单独算一个连通分量 / 强连通分量！</strong></p><p>⚠易错点2：因为无向边看作“双向边”，所以连通的无向图一定是强连通的；</p><p><strong>推论：图 G 的每个连通分支都是其导出子图</strong>；</p><p><strong>小结论：图 G 对应关联矩阵记为 $M(G)$，则 G 的连通分支数为 $r(M(G))-1$</strong>；</p></blockquote></li><li><p>割边与非割边、割点与非割点：删去图中某个边 / 点，图的连通分支数（连通性）改变，则称该边 / 点为<strong>割边 / 割点</strong>；</p></li><li><p>欧拉道路、欧拉回路：<strong>无向连通图</strong> G 中的一条经过<u>所有边</u>的<strong>简单道路/回路</strong>称 G 的<strong>欧拉道路/回路</strong>；</p><ul><li><p>理解：不重复地遍历所有边，不管点的情况；</p></li><li><p>注意：<strong>有向图也能讨论欧拉回路的问题，不过要遵循有向的连通性</strong>；</p></li></ul><blockquote><p><strong>定理1：（欧拉回路充要条件）无向连通图 G 存在欧拉回路 $\Longleftrightarrow$ G 的各结点度数均为偶数</strong>；</p><p><strong>推论1-1：（欧拉道路充分条件）无向连通图 G 仅有2个奇点 $\Longrightarrow$ G 存在欧拉道路</strong>；</p><p><strong>推论1-2：（有向欧拉回路充分条件）有向连通图 G 的各结点的正、负度数相等 $\Longrightarrow$ G 存在有向欧拉回路</strong>（侧面说明有向可能严格一些，不仅结点度全为偶数，而且要进出相等）；</p><p>定理2：连通图 G 有 k 个奇点（由部分Ⅰ的定理可知，k为偶数），则 E(G) 可以划分为 <strong>$\dfrac{k}{2}$</strong> 条简单道路；</p></blockquote></li><li><p>哈密顿道路、哈密顿回路：<strong>无向图</strong> G 的一条<u>经过全部结点</u>的<strong>初级道路/回路</strong>称 G 的<strong>哈密顿道路/回路（简称H道路/H回路）</strong>；</p><ul><li>理解：“不重复地遍历所有点”；</li><li>注意：H 道路 / 回路一般针对简单图，因为重边和自环对它没有什么影响，可以转换为简单图的问题；</li></ul><blockquote><p><strong>很遗憾，目前 H 道路 / 回路的判定没有充要条件！一般遍历是 NP 问题……</strong></p><p><strong>定理3：（H 回路充分条件）完全图 $K_n$ 为 H 图</strong>；</p><p><strong>定理4：（H 回路充分条件）若简单图 G 每个结点度都大于 n/2，则 G 为 H 图</strong>；</p><p>说明：平均每个点的度越大，越有可能有H道路、H回路；</p><p><strong>推论4-1：（H 道路充分条件）若简单图 G 的任两结点 $v_i,v_j$ 恒有 $d(v_i)+d(v_j)\ge n-1$，则 G 存在 H 道路；</strong></p><p>证明提示：有 H 道路一定连通，可以先证连通性；</p><p><strong>推论4-2：（H 回路充分条件）若简单图 G 的任两结点 $v_i,v_j$ 恒有 $d(v_i)+d(v_j)\ge n$，则 G 为 H 图</strong>；</p><p><strong>推论4-3：（H 回路的闭包等价关系）向图 G 中满足 “ $d(v_i)+d(v_j)\ge n$”的不相邻两结点 $v_i,v_j$ 加边，直至无法找到这样的结点对为止，形成的新图称为 G 的闭包（记为$C(G)$）；那么有：$G\space为H图\Longleftrightarrow C(G)为H图$</strong>；</p><p><strong>推论4-4：（H回路闭包充分条件）若 $C(G)=K_n$，则 G 为 H 图</strong>；</p><p><strong>定理5：（可怜为数不多的 H 回路的必要条件）若 G 为 H 图，则对任意非空顶点集 S，有：$\omega(G-S)\le|S|$</strong>；</p></blockquote><ul><li><p>补充：欧拉图、H 图的定义：有欧拉回路 / H 回路的图才叫~（只有欧拉道路 / H 道路的不是）；</p></li><li><p>判断一个图是 H 图：使用上面的充分条件/等价条件；</p></li><li><p>判断一个图不是 H 图：使用上面的必要条件；</p><blockquote><p>举例：证明 Peterson 图是极大非 H 图（有 H 道路，但没有 H 回路）</p><p>【问题：它满足定理5，能否判断一下为什么在删去任意4个顶点时，连通分支数一定小于等于3？】</p><p><strong>定理6：（必要条件）若一个点在 H 回路中，那么必定有且仅有两个相连的相异道路</strong>；</p></blockquote></li></ul></li></ul><h3 id="6-6-图的简单应用"><a href="#6-6-图的简单应用" class="headerlink" title="6.6 图的简单应用"></a>6.6 图的简单应用</h3><ul><li>【普通图】有 3L、5L、8L的三个没有刻度的量杯，现在8L的量杯装满了水，其他两个是空的；问如何操作（不撒不漏）可以让8L水分为两个4L水？</li><li>【二部图】人、狼、羊、菜过河问题</li></ul><blockquote><p>解决思路：<strong>“状态转换图”：</strong>将每一个状态抽象为一个顶点，先列出所有可能状态作为顶点，再用“一次能直接转换的关系”作为边连接，最后只需判断在起点（初态）和终点（末态）是否单向连通即可；</p></blockquote><h3 id="6-7-图论中的重要定义Ⅲ"><a href="#6-7-图论中的重要定义Ⅲ" class="headerlink" title="6.7 图论中的重要定义Ⅲ"></a>6.7 图论中的重要定义Ⅲ</h3><blockquote><p>提示：本章节不在初级数据结构要求范围内；</p></blockquote><ul><li><p>割边与非割边、割点与非割点：删去图中某个边 / 点，图的连通分支数（连通性）改变，则称该边 / 点为<strong>割边 / 割点</strong>；</p><blockquote><p><strong>定理1：e 为割边，当且仅当 e 不属于 G 的任何回路</strong>；</p></blockquote></li><li><p>普通树的数学定义：不含任何回路的连通图称为<strong>树</strong>；</p><blockquote><p><strong>定理2：“连通”、“无回路”、“有 n-1 条边”三个条件任取两个都可以作为树的定义</strong>；</p><p>推论：“连通+全为割边”、“任意两点间有唯一道路”、“无回路+加一边就一回路” 这三个与树的定义等价；</p><p><strong>定理3：树中一定有树叶结点（离散数学中没有空树的说法！只有空图）</strong></p></blockquote></li><li><p>根树的定义：若树 T 是有向树，且 T 中存在某结点 $v_0$ 的入度为0、其他结点入度为1，则称 <strong>T 是以 $v_0$ 为根的根树</strong>（或外向树），用 $\overrightarrow{T}$ 表示；</p><blockquote><p><strong>根树才是数据结构中的“树”！</strong></p></blockquote></li><li><p>生成树（或称“支撑树”）：图 G 的一个符合树定义的生成子图称为图 G 的<strong>生成树</strong>；</p><blockquote><p>余树：给定图 G 的一棵生成树 T，定义余树 $\overline{T}=G-T$；一般情况下，余树不是树；</p></blockquote></li><li><p><span id="relMDetails">基本关联矩阵：<strong>上接“<a href="#relM">关联矩阵存储🔗</a>”，虽然关联矩阵一般不作为存储方法，但有些情况讨论它的性质，可以更方便地解决某些问题</strong>；</span></p><blockquote><p>友情提醒1：这里和<strong>电路理论的电路图研究</strong>结合比较紧密；</p><p>友情提醒2：这里的讨论对象是<strong>有向连通图</strong>；</p></blockquote><ul><li>定义：在<strong>有向连通图 $G=(V, E)$</strong> 的<strong>关联矩阵 $B$</strong> 中，划去任意任意结点 $v_k$所对应的一<strong>行</strong>，得到 <strong>$(\nu-1)\times\varepsilon$</strong> 的矩阵 $B_k$，称为 <strong>G 的一个基本关联矩阵</strong>；</li><li>相关定理</li></ul><blockquote><p><strong>定理1：有向连通图 G 的关联矩阵 B 满足：$r(B)=\nu-1$</strong>；</p><p><strong>定理2：有向连通图 G 的基本关联矩阵 $B_k$ 满足：$r(B_k)=\nu-1$</strong>；</p><p>推论：n个结点树 T 的基本关联矩阵的秩为 $\nu-1$；</p><p><strong>定理3：有向连通图 G 如果存在回路 C，则 C 中各边所对应基本关联矩阵 $B_k$ 的各列线性相关</strong>；</p><p><strong>定理4：有向连通图 G 的基本关联矩阵 $B_k$，有：$B_k任意n-1阶子式M_{n-1}\ne0\Longleftrightarrow M_{n-1}各列对应边构成G的一棵生成树$</strong>；</p><p>定理4说明了<strong>可以由 $B_k$ 的非零 n-1 阶子式的数目来代表 $G$ 生成树的数目<a href="#genTCount">🔗</a></strong>；</p></blockquote></li><li><p>回路矩阵和割集矩阵；</p><blockquote><p>不说了亲，这边建议您好好复习电路理论课呢:sweat_smile:</p></blockquote></li><li><p>Huffman树（最优二叉树），详见“数据结构复习-第二部分”；</p></li></ul><h3 id="6-8-图的经典算法"><a href="#6-8-图的经典算法" class="headerlink" title="6.8 图的经典算法"></a>6.8 图的经典算法</h3><h4 id="6-8-1-图的遍历算法"><a href="#6-8-1-图的遍历算法" class="headerlink" title="6.8.1 图的遍历算法"></a>6.8.1 图的遍历算法</h4><ul><li><p>DFS 算法：类似树的前序遍历</p><p>邻接表存储 $O(|V|+|E|)$</p><p>邻接矩阵存储 $O(|V|^2)$</p></li><li><p>BFS 算法：类似树的层次遍历</p><p>邻接表存储 $O(|V|+|E|)$ </p><p>邻接矩阵存储 $O(|V|^2)$</p></li></ul><h4 id="6-8-2-两点间道路判定算法"><a href="#6-8-2-两点间道路判定算法" class="headerlink" title="6.8.2 两点间道路判定算法"></a>6.8.2 两点间道路判定算法</h4><blockquote><p>这里介绍邻接矩阵表示的算法，比较常见；</p></blockquote><ul><li><p>引入：对于一个<strong>非加权图的邻接矩阵（0&amp;1）</strong>，有 $P=(p_{ij})_{n\times n}=\sum\limits_{k=1}^n{A^k}$，则 $p_{ij}$ 为从 $v_i$ 到 $v_j$ 的<strong>道路数</strong>；实际问题只关心<strong>是否有道路</strong>，所以可以改成逻辑运算提升速度：$P=(p_{ij})_{n\times n}=\bigvee\limits_{k=1}^n{A^k}$，时间复杂度 $O(\nu^4)$；</p></li><li><p><span id="Warshell">Warshell算法 $O(\nu^3)$</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P &lt;- A</span><br><span class="line">for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">    for (int j = 1; j &lt;= n; ++j)</span><br><span class="line">        for (int k = 1; k &lt;= n; ++k)</span><br><span class="line">            p_&#123;jk&#125; &lt;- p_&#123;jk&#125; V (p_&#123;ji&#125; Λ p_&#123;ik&#125;)</span><br></pre></td></tr></table></figure></li><li><p>DFS 和 BFS $O(\varepsilon)$：和图的遍历不一样的是，它比图的遍历更简单，只需从一个点出发（减少最外层循环），用visited数组和BFS/DFS整体寻找，如果遇到终点即停止并返回true，否则返回false；</p></li></ul><h4 id="6-8-3-有向图强连通分支判断算法"><a href="#6-8-3-有向图强连通分支判断算法" class="headerlink" title="6.8.3 有向图强连通分支判断算法"></a>6.8.3 有向图强连通分支判断算法</h4><blockquote><p>思路：先从图 G 任一点开始 DFS，如果 G 不是强连通图，则可能得到一个深度优先生成森林；对森林中的每棵树按照<strong>生成次序</strong>依此进行<strong>后序遍历</strong>，并按遍历顺序给每个结点编号（从小到大）；</p><p>然后使 G 的每条边逆向，得到 Gr，再从 Gr 编号最大的结点开始 DFS，得到新的深度优先遍历森林中的<strong>每一棵树</strong>就是 G 的一个强连通分量；</p></blockquote><h4 id="6-8-4-欧拉回路的构造算法"><a href="#6-8-4-欧拉回路的构造算法" class="headerlink" title="6.8.4 欧拉回路的构造算法"></a>6.8.4 欧拉回路的构造算法</h4><blockquote><p>欧拉回路有明确的、好判断的充要条件，所以算法设计相对容易；</p><p>无论啥算法，最好先利用充要条件排除没有欧拉回路的图，能大大提高时间性能；</p><p>下面讨论<strong>如果有欧拉回路，应该怎么找</strong>的算法：</p></blockquote><ul><li>拼接法：DFS寻找回路（经过即删除），如果回路结束却仍然有未遍历的结点，则从新的未访问的结点开始遍历回路，<strong>并拼接（“8”字原理）</strong>，循环直到所有边已被访问；</li><li>Floyd算法（非割边优先遍历）</li></ul><h4 id="6-8-5-欧拉回路的应用：中国邮递员问题（CPP）"><a href="#6-8-5-欧拉回路的应用：中国邮递员问题（CPP）" class="headerlink" title="6.8.5 欧拉回路的应用：中国邮递员问题（CPP）"></a>6.8.5 欧拉回路的应用：中国邮递员问题（CPP）</h4><blockquote><p>中国邮递员问题：<strong>走遍图中的所有边</strong>后返回返回起点，要求<strong>总路程最短</strong>；</p></blockquote><ul><li><p>对于无向图 G 的结论</p><ul><li><p>如果 G 中所有结点个数都是偶数：该图的任一欧拉回路都是解；</p></li><li><p>如果 G 中有且仅有 2 个奇点 $v_i\space和\space v_j$：找到 G 从  $v_i$ 到 $v_j$ <strong>欧拉道路 $E_{ij}$</strong>，再找从  $v_j$ 到 $v_i$ 的<strong>最短路径 $P_{ji}$</strong>，则回路 <strong>$E_{ij}+P_{ji}$</strong> 就是问题的解；</p></li><li><p>如果 G 中有两个以上，共2k个奇点（由前面图的性质推论，奇点必有偶数个）：</p><script type="math/tex; mode=display">图G有最佳邮路L\Longleftrightarrow\begin{equation}\left\{\begin{aligned}&1.\space L的任一边最多重复一次\\&2.\space对G中的任一回路C，L中在C上重复边的长度之和\\&\quad不超过C总长的一半\space(必须遍历所有包含重边的回路)\\\end{aligned}\right.\end{equation}</script><p><strong>实际做法是：找出所有奇点，两两配对并依此为奇点间添加重复边（长度和原边相等），为它们配对成偶点，得到新图，也即邮路 $L_x$；再检查 $L_x$ 是否满足以上两个条件；如果违反第一条则一次性删除两条多余重边，如果违反第二条则将 $L_x$ 的该段道路改成与 $C$ 互补的道路</strong>；</p></li></ul></li></ul><h4 id="6-8-6-H-回路的应用：旅行商问题（TSP）"><a href="#6-8-6-H-回路的应用：旅行商问题（TSP）" class="headerlink" title="6.8.6 H 回路的应用：旅行商问题（TSP）"></a>6.8.6 H 回路的应用：旅行商问题（TSP）</h4><ul><li>问题描述：给定一个正权完全图，求总权最小的 H 回路；</li></ul><blockquote><p>NP 完全问题，只能寻找近似解；这里不介绍算法，仅介绍问题；提示：不建议使用贪心法，误差很大；</p></blockquote><h4 id="6-8-7-有向无环图、AOV网与拓扑排序"><a href="#6-8-7-有向无环图、AOV网与拓扑排序" class="headerlink" title="6.8.7 有向无环图、AOV网与拓扑排序"></a>6.8.7 有向无环图、AOV网与拓扑排序</h4><ul><li><p>有向无环图（DAG）：不存在回路的有向图称为<strong>有向无环图</strong>；</p></li><li><p>AOV网：<strong>有向无环图</strong>中的顶点表示活动，边表示活动间的先后关系，这样的图称为<strong>AOV网</strong>；</p></li><li><p>拓扑排序：将AOV网中的活动发生的先后次序排成一个序列（如果有一条从 u 到 v 的道路，那么 v 必须出现在 u 之后），称为<strong>拓扑排序</strong>，这个序列称为<strong>拓扑序列</strong>；</p></li><li><p>拓扑排序实现思路：类似于图的 BFS，但是<strong>只有一个结点的所有直接前驱结点都已访问后，才能访问这个结点</strong>；<strong>$O(|V|+|E|)$</strong></p><ol><li><p>计算每个结点的入度，保存在数组中；</p></li><li><p>检查入度数组中<strong>入度为零（无依赖）</strong>的对应结点索引，并将其入队；</p></li><li><p>当队伍非空时，循环出队并输出这个结点，在假设将这个结点删除，修正这个结点的所有直接结点的入度（减1），如此重复2、3步骤；</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请自行实现私有函数 int _getInDegree(int) 获取入度；</span></span><br><span class="line"><span class="comment">// 使用到了之前的seqQueue类；</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span>* adjListGraph&lt;VType, EType&gt;::<span class="built_in">topoSortIdx</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ans = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;; <span class="type">int</span> ansIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* inDegrees = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; preRequests;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        inDegrees[i] = _getInDegree(i);</span><br><span class="line">        <span class="keyword">if</span> (!inDegrees[i]) preRequests.<span class="built_in">enQueue</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!preRequests.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = preRequests.<span class="built_in">deQueue</span>();</span><br><span class="line">        ans[ansIdx++] = cur;</span><br><span class="line">        eNode* curEdge = vertices[cur].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--inDegrees[curEdge-&gt;end] == <span class="number">0</span>)</span><br><span class="line">                preRequests.<span class="built_in">enQueue</span>(curEdge-&gt;end);</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[i]) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR] A non-DAG does not support topoSort().&quot;</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] ans; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">topoSort</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* seq = <span class="built_in">topoSortIdx</span>();</span><br><span class="line">    <span class="keyword">if</span> (!seq) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        std::cout &lt;&lt; vertices[seq[i]].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-8-8-AOE网与关键路径"><a href="#6-8-8-AOE网与关键路径" class="headerlink" title="6.8.8 AOE网与关键路径"></a>6.8.8 AOE网与关键路径</h4><ul><li><p>AOE网络：活动定义在边上（持续时间），事件定义在顶点上；</p></li><li><p>AOE网络的重要两点：源点（入度为0，工程“起点”）、汇点（出度为0，工程“终点”）；</p></li><li><p>AOE网络解决的问题：完成整项任务的最少时间、哪些活动是影响工程进度的关键;</p></li><li><p>关键路径：从源点到汇点的<strong>最长</strong>路径称为<strong>关键路径</strong>；</p></li><li><p>关键活动：关键路径上的活动。<strong>推迟关键活动必定影响项目进度</strong>；</p></li><li><p>最早发生时间：用“从源点到该结点的<strong>最长路径</strong>”（因为和拓扑排序一样，只有该结点的所有直接前驱结点都访问过后，才能算访问了这个结点）表征；</p></li><li><p>最迟发生时间：用“关键路径长(定值) - 从汇点到该结点的<strong>最短路径</strong>”表征（因为是最迟，距离汇点最近才符合定义）；</p></li><li><p>时间余量：最迟发生时间 - 最早发生时间。<strong>时间余量为0的活动是关键活动（第二定义）</strong>；</p></li><li><p>找关键路径的思路：（用第二定义）<strong>就是找每个顶点的最早、最迟发生时间，进而得到关键活动、关键路径</strong>；</p><ol><li><p>找出AOE网的任一拓扑序列；</p></li><li><p>从头至尾遍历一次拓扑序列，在遍历到 u 时，更新它的<strong>所有</strong>直接后继结点 v 的最早发生时间（如果当前ee值＜u 的值+路径长，那么更新v的ee值为更大的）；</p></li><li><p>再从尾至头遍历一次拓扑序列，在遍历到 u 时，更新它的<strong>所有</strong>直接后继结点 v 的最迟发生时间（如果后继结点le值＜v 的值+路径长，那么更新为u为更小的）；</p><blockquote><p>别问为啥不和第二步相对应，找直接前驱结点，问就是找前驱结点复杂度太大了；</p><p>⚠<strong>记得更新最迟发生时间之前，要用第二步得到的关键路径长度（就是拓扑序列最后一个结点的ee值）填充最迟发生时间数组</strong>；</p></blockquote></li><li><p>找出所有“最早发生时间=最迟发生时间”的结点，按照拓扑序列的顺序依此输出，即为关键路径；</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">criticalPath</span>(<span class="type">int</span>* early, <span class="type">int</span>* late) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* topoSeq = <span class="built_in">topoSortIdx</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) early[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        eNode* curEdge = vertices[topoSeq[i]].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (early[topoSeq[i]] + curEdge-&gt;weight &gt; early[curEdge-&gt;end])</span><br><span class="line">                early[curEdge-&gt;end] = early[topoSeq[i]] + curEdge-&gt;weight;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pLen = early[topoSeq[<span class="keyword">this</span>-&gt;vertixNum - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) late[i] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">this</span>-&gt;vertixNum - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        eNode* curEdge = vertices[topoSeq[i]].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (late[topoSeq[i]] &gt; late[curEdge-&gt;end] - curEdge-&gt;weight)</span><br><span class="line">                late[topoSeq[i]] = late[curEdge-&gt;end] - curEdge-&gt;weight;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">criticalPath</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ee = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="type">int</span>* le = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="type">int</span> pathLen = <span class="built_in">criticalPath</span>(ee, le);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[INFO] The length of the critical path: &quot;</span> &lt;&lt; pathLen &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[INFO] The critical path: \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ee[i] == le[i]) std::cout &lt;&lt; vertices[i].data &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[Fin]\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-8-9-生成树的计数算法"><a href="#6-8-9-生成树的计数算法" class="headerlink" title="6.8.9 生成树的计数算法"></a>6.8.9 生成树的计数算法</h4><blockquote><p>原理：Binet-Cauchy 定理：两个矩阵 $A_{m\times n},\space B_{n\times m}\space(m\le n)$，则 $det(AB)=\sum\limits_i{A_iB_i}$ 。其中$A_i$、$B_i$ 分别是从 $A$ 中任取 $m$ 列、$B$ 中任取 $m$ 行构成的行列式；</p><p>虽然这样计算行列式有些麻烦，但它揭示了乘积矩阵行列式和各矩阵的子式之间的关系；</p><p><span id="genTCount"><strong>定理1：（有向连通图的普通生成树计数）设 $B_k$ 为有向连通图 $G=(V,E)$ 的某一基本关联矩阵，则 $G$ 中不同树的数目为 $det(B_kB_k^T)$</strong>；</span></p><ul><li>解题提示：如果要求<strong>不含</strong>某个边的生成树数目，只要求将该边删去后的生成子图对应生成树的数目；如果要求<strong>必含</strong>某个边的生成树数目，只要该边的起点终点合并为一点，求新图对应生成树的数目；</li></ul><p><strong>如果想求无向连通图的生成树个数，需要将其每条边指定一个任意方向转化为有向连通图</strong>；</p><ul><li><p>推论证明：求证<strong>完全图 $K_n$ 的不同生成树的数目为 $n^{n-2}$</strong>；</p><script type="math/tex; mode=display">det(B_kB_k^T)=\begin{vmatrix}n-1&-1&\cdots&-1\\-1&n-1&\cdots&-1\\\vdots&\vdots&\ddots&\vdots\\-1&-1&\cdots&n-1\end{vmatrix}=n^{n-2}</script></li><li><p>⚠易错警示：如果是求<strong>完全图 $K_n$ 不同构的生成树的数目</strong>，和<strong>“不同生成树”</strong>不一样！和化学上<strong>求同分异构体的做法类似</strong>；例如 $K_5$ 的不同构生成树数目为 3，对应有机化学戊烷的正戊烷、异戊烷、新戊烷的构型；</p></li></ul><p><strong>定理2：（有向连通图的根树生成树计数）设 $\overrightarrow{B_k}$ 表示将有向连通图 $G$ 的<u>关于结点 k 的</u>关联矩阵 $B_k$ 中所有的 1 元素换成 0 之后的矩阵，则 $G$ 中<u>以 k 为根的</u>不同根树数目为 $det(\overrightarrow{B_k}B_k^T)$</strong>；</p><ul><li>解题提示：如果要求<strong>不含</strong>某个边的根树生成树数目，删去这个边再算；</li><li>⚠易错警示：和普通生成树不同，如果要求<strong>必含</strong>某个边的根树生成树数目，需要先计算以 v0 为根的总根树数目，再减去不含这个边的生成树数目；<strong>或者求 $G^\prime=G-\{(t,v)|t\ne u\}$</strong> 的根树生成树数目；</li></ul></blockquote><h4 id="6-8-10-生成树的生成算法"><a href="#6-8-10-生成树的生成算法" class="headerlink" title="6.8.10 生成树的生成算法"></a>6.8.10 生成树的生成算法</h4><blockquote><p>不作介绍，有兴趣请查阅相关资料，例如《图论与代数结构》清华大学出版社 第3章 3.5节 支撑树的生成；</p></blockquote><h4 id="6-8-11-最小生成树算法"><a href="#6-8-11-最小生成树算法" class="headerlink" title="6.8.11 最小生成树算法"></a>6.8.11 最小生成树算法</h4><ul><li><p>Kruskal 算法</p><blockquote><p>思路：不断向初始化为空的根结点中加入当前未加入过的最短边，如果构成回路，一定是回路中的最长边，删除它；如果不构成回路则继续，直至达到 n-1 条边为止，此时 T 一定不含任何回路、n-1条边、包含所有图的顶点、所有权最小，在贪心法上是最小生成树；</p><p><strong>如何证明这个贪心算法的正确性？</strong></p><p>可以证明定理：$T=(V,E’)$ 是赋权连通图 $G=(V,E)$ 的最短树，当且仅当对任意的余树边 $e\in E-E’$，回路 $C^e(C^e\subseteq E’+e)$ 满足：其边权 $w(e)\ge w(a),\space a\in C^e\space(a\ne e)$；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T &lt;- Φ    // 树根结点初始化为空</span><br><span class="line">while (|T| &lt; n - 1 &amp;&amp; E(G) != Φ) &#123;</span><br><span class="line">    e &lt;- E中最短边</span><br><span class="line">    E &lt;- E - e</span><br><span class="line">    if (T + e 无回路) T &lt;- T + e</span><br><span class="line">&#125;</span><br><span class="line">if (|T| &lt; n - 1) 输出非连通的信息</span><br><span class="line">else return T</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(\varepsilon+p\space log\space\varepsilon),\space其中p为迭代次数$；适用于稀疏图（当p不大时）；</p></li><li><p>Prim 算法</p><blockquote><p>思路：在结点集中任选一个结点 v0 构成集合 V’，从 V’ 和 V-V’ 中各选一个顶点 u（来自 V-V’）、v（来自V’）使得 (u, v) 是满足条件的u、v中最短的边，将此边加入树 T，令 V’+=u，直至 V’=V；</p><p>感兴趣可以找一找定理的正确性证明；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t &lt;- v0, T &lt;- Φ, U &lt;- &#123;t&#125;</span><br><span class="line">while (U != V) &#123;</span><br><span class="line">    w(t, u) = min&#123;w(t, v)&#125; where v in (V - U)</span><br><span class="line">    T &lt;- T + e(t, u)</span><br><span class="line">    U &lt;- U + u</span><br><span class="line">    for (v in V - U) w(t, v) &lt;- min&#123;w(t, v), w(u, v)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(\nu^2)$；适用于稠密图；</p></li></ul><h3 id="6-9-常见题型和易错点"><a href="#6-9-常见题型和易错点" class="headerlink" title="6.9 常见题型和易错点"></a>6.9 常见题型和易错点</h3><p>⚠易错点</p><ul><li><p>导航适合使用<strong>有向多重图</strong>表示；</p></li><li><p>简单道路/回路<strong>可以针对非简单图</strong>，意味着可以经过自环、重边，但仅能经过一次；</p></li><li><p>平凡图一定是简单道路、初级道路，一定不是回路；</p></li><li><p>一个点很重要，虽然不知道有啥用：<strong>每个格雷码对应 n-cube $Q_n$ 上的一条 H 回路</strong>；</p></li><li><p>n 个结点的<strong>连通的简单平面图</strong>的边数 $m\le 3n-6$；</p></li><li><p>另一点涉及群论的知识，n 个结点组成的简单无向图的数目为 $2^{n(n-1)/2}$；</p><p>这些图里面互不同构的图的数量又为 $|X/G|=\sum\limits_b\dfrac{2^k}{\prod(b_i)\prod(c_i!)}$，其中 $k=\sum\limits_{i=1}^K\lfloor\dfrac{b_i}{2}\rfloor+\sum\limits_{i=1}^K\sum\limits_{j=1}^{i-1}gcd(b_i,b_j)$，$K$ 为将置换群拆为循环的个数（DFS计数）；</p><p>参考：<a href="https://oeis.org/A000088">A000088🔗</a>，计算结论：1，2，4，11，34，156，1044，……</p></li></ul><p>ℹ常见题型</p><ul><li>根据图的所有定理，判断/证明一定数量的结点度、结点数、边数等数量间的关系；</li><li>根据原图指出生成子图、导出子图；</li><li>给定一个图，判断是否有欧拉道路/回路、哈密顿回路/道路；</li><li>给定一个图，判断道路/回路、简单道路/回路、初级道路/回路；</li><li>给定一个图，判断连通分量、强连通分量；</li><li>给定一个图，找出哈夫曼编码；</li><li>给定一个图，找出最小生成树；</li></ul><h2 id="附录A：部分C-代码实现"><a href="#附录A：部分C-代码实现" class="headerlink" title="附录A：部分C++代码实现"></a>附录A：部分C++代码实现</h2><h3 id="A-1-图的存储实现"><a href="#A-1-图的存储实现" class="headerlink" title="A.1 图的存储实现"></a>A.1 图的存储实现</h3><ol><li><p>邻接矩阵存储法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjMatrixGraph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VType* vertices;    <span class="comment">// store the data of each vertex.</span></span><br><span class="line">    EType** edges;      <span class="comment">// store the data of each edge (in adjacent matrix form).</span></span><br><span class="line">    EType noEdgeFlag;    <span class="comment">// represent the no-edge area.</span></span><br><span class="line">    <span class="type">int</span> vertixNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vertexIdx</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertixNum; ++i)</span><br><span class="line">            <span class="keyword">if</span> (vertices[i] == v) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">vertexNotExists</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">bool</span> visited[])</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">adjMatrixGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">const</span> EType&amp; noEdge);</span><br><span class="line">    <span class="built_in">adjMatrixGraph</span>(<span class="type">const</span> adjMatrixGraph&lt;VType, EType&gt;&amp; cp) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">adjMatrixGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjMatrix</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_nonRecur</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>邻接表存储法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjListGraph</span>: <span class="keyword">public</span> graph&lt;VType, EType&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        EType weight;</span><br><span class="line">        eNode* next;</span><br><span class="line">        <span class="built_in">eNode</span>(): <span class="built_in">end</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">eNode</span>(<span class="type">const</span> EType&amp; w, <span class="type">int</span> e=<span class="number">0</span>, eNode* nxt=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">weight</span>(w), <span class="built_in">end</span>(e), <span class="built_in">next</span>(nxt) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">vNode</span> &#123;</span><br><span class="line">        VType data;</span><br><span class="line">        eNode* edge;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EulerNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> nodeIdx;</span><br><span class="line">        EulerNode* next;</span><br><span class="line">        <span class="built_in">EulerNode</span>(<span class="type">int</span> idx=<span class="number">0</span>, EulerNode* n=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">nodeIdx</span>(idx), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vNode* vertices;</span><br><span class="line">    <span class="type">bool</span> directed;</span><br><span class="line">    <span class="type">int</span> vertixNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vertexIdx</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertixNum; ++i)</span><br><span class="line">            <span class="keyword">if</span> (vertices[i].data == v) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">vertexNotExists</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typename</span> adjListGraph&lt;VType, EType&gt;::<span class="function">vNode* <span class="title">cloneBase</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">bool</span> visited[])</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _insert(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">const</span> EType&amp; w);</span><br><span class="line">    <span class="type">void</span> _remove(<span class="type">int</span> v1, <span class="type">int</span> v2);</span><br><span class="line">    <span class="type">int</span> _getInDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> _getOutDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> _getDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">void</span> _EulerCircuit(<span class="type">int</span> start, EulerNode*&amp; begin, EulerNode*&amp; end);</span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">topoSortIdx</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">criticalPath</span><span class="params">(<span class="type">int</span>* early, <span class="type">int</span>* late)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> prev[])</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">adjListGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">bool</span> direct=<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">adjListGraph</span>(<span class="type">const</span> adjListGraph&lt;VType, EType&gt;&amp; cp);</span><br><span class="line">    <span class="built_in">adjListGraph</span>(adjListGraph&lt;VType, EType&gt;&amp;&amp; tmp);</span><br><span class="line">    ~<span class="built_in">adjListGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getInDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getOutDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjList</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_nonRecur</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_dfs_tree</span><span class="params">(<span class="type">const</span> VType&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_bfs_tree</span><span class="params">(<span class="type">const</span> VType&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EulerCircuit</span><span class="params">(<span class="type">const</span> VType&amp; start)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">criticalPath</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// The shortest path for the graph: O(n^3)</span></span><br><span class="line">    <span class="function">VType* <span class="title">dijkstra</span><span class="params">(<span class="type">const</span> VType&amp; start, <span class="type">const</span> EType&amp; noEdge, <span class="type">bool</span> prompt=<span class="literal">false</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">VType* <span class="title">SPFA</span><span class="params">(<span class="type">const</span> VType&amp; start, <span class="type">const</span> EType&amp; noEdge)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="A-2-图的运算实现"><a href="#A-2-图的运算实现" class="headerlink" title="A.2 图的运算实现"></a>A.2 图的运算实现</h3><ol><li><p>邻接矩阵表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">adjMatrixGraph</span>(</span><br><span class="line">    <span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">const</span> EType&amp; noEdge) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = vSize; <span class="keyword">this</span>-&gt;edgeNum = <span class="number">0</span>; noEdgeFlag = noEdge;</span><br><span class="line">    vertices = <span class="keyword">new</span> VType[vSize];</span><br><span class="line">    edges = <span class="keyword">new</span> EType*[vSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vSize; ++i) &#123;</span><br><span class="line">        vertices[i] = vers[i];</span><br><span class="line">        edges[i] = <span class="keyword">new</span> EType[vSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vSize; ++j)</span><br><span class="line">            edges[i][j] = noEdge;</span><br><span class="line">        edges[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjMatrixGraph&lt;VType, EType&gt;::~<span class="built_in">adjMatrixGraph</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] vertices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] edges[i];</span><br><span class="line">    <span class="keyword">delete</span>[] edges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">bool</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">exist</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">return</span> edges[u][v] != noEdgeFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">undirected_insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    <span class="keyword">if</span> (edges[v][u] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = edges[v][u] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">remove</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] != noEdgeFlag) --<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = noEdgeFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">printAdjMatrix</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j)</span><br><span class="line">            std::cout &lt;&lt; edges[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>邻接表表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">bool</span> direct) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = vSize; directed = direct;</span><br><span class="line">    <span class="keyword">this</span>-&gt;edgeNum = <span class="number">0</span>; vertices = <span class="keyword">new</span> vNode[vSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vSize; ++i) &#123;</span><br><span class="line">        vertices[i].data = vers[i];</span><br><span class="line">        vertices[i].edge = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::~<span class="built_in">adjListGraph</span>() &#123;</span><br><span class="line">    eNode* curEdge;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curEdge = vertices[i].edge) &#123;</span><br><span class="line">            vertices[i].edge = curEdge-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> curEdge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vertices) <span class="keyword">delete</span>[] vertices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> adjListGraph&lt;VType, EType&gt;::vNode* adjListGraph&lt;VType, EType&gt;::<span class="built_in">cloneBase</span>() <span class="type">const</span> &#123;</span><br><span class="line">    vNode* newVers = <span class="keyword">new</span> vNode[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        newVers[i].data = vertices[i].data;</span><br><span class="line">        newVers[i].edge = <span class="literal">nullptr</span>;</span><br><span class="line">        eNode** curEdgeDst = &amp;(newVers[i].edge);</span><br><span class="line">        eNode* curEdgeSrc = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdgeSrc) &#123;</span><br><span class="line">            *curEdgeDst = <span class="keyword">new</span> <span class="built_in">eNode</span>(curEdgeSrc-&gt;weight, curEdgeSrc-&gt;end, <span class="number">0</span>);</span><br><span class="line">            curEdgeDst = &amp;((*curEdgeDst)-&gt;next);</span><br><span class="line">            curEdgeSrc = curEdgeSrc-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newVers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(<span class="type">const</span> adjListGraph&lt;VType, EType&gt;&amp; cp) &#123;</span><br><span class="line">    vertices = cp.<span class="built_in">cloneBase</span>(); <span class="keyword">this</span>-&gt;edgeNum = cp.edgeNum;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = cp.vertixNum; directed = cp.directed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(adjListGraph&lt;VType, EType&gt;&amp;&amp; tmp) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;edgeNum = tmp.edgeNum; <span class="keyword">this</span>-&gt;vertixNum = tmp.vertixNum; directed = tmp.directed;</span><br><span class="line">    tmp.edgeNum = tmp.vertixNum = <span class="number">0</span>; vertices = tmp.vertices; tmp.vertices = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">bool</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">exist</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="type">const</span> eNode* cur = vertices[u].edge;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;end == v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::_insert(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    eNode** cur = &amp;(vertices[v1].edge);</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;end != v2) cur = &amp;((*cur)-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (!(*cur)) &#123; ++<span class="keyword">this</span>-&gt;edgeNum; *cur = <span class="keyword">new</span> <span class="built_in">eNode</span>(w, v2); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::_remove(<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">    eNode** cur = &amp;(vertices[v1].edge);</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;end != v2) cur = &amp;((*cur)-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (*cur) &#123;</span><br><span class="line">        eNode* tmp = *cur; *cur = (*cur)-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp; --<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    _insert(u, v, w);</span><br><span class="line">    <span class="keyword">if</span> (!directed) _insert(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">remove</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    _remove(u, v);</span><br><span class="line">    <span class="keyword">if</span> (!directed) _remove(v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getInDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == v) <span class="keyword">continue</span>;</span><br><span class="line">        eNode* curEdge = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEdge-&gt;end == v) ++ans;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getOutDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    eNode* target = vertices[v].edge;</span><br><span class="line">    <span class="keyword">while</span> (target) &#123; ++ans; target = target-&gt;next; &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (directed) <span class="keyword">return</span> _getInDegree(v) + _getOutDegree(v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> _getOutDegree(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getInDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getInDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getOutDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getOutDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">printAdjList</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; vertices[i].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">const</span> eNode* cur = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;|-w=&quot;</span> &lt;&lt; cur-&gt;weight</span><br><span class="line">                &lt;&lt; <span class="string">&quot;-&gt;(&quot;</span> &lt;&lt; cur-&gt;end &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="A-3-图的遍历算法"><a href="#A-3-图的遍历算法" class="headerlink" title="A.3 图的遍历算法"></a>A.3 图的遍历算法</h3><ol><li><p>DFS：邻接表表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>(<span class="type">int</span> start, <span class="type">bool</span> visited[]) <span class="type">const</span> &#123;</span><br><span class="line">    eNode* curEdge = vertices[start].edge;</span><br><span class="line">    std::cout &lt;&lt; vertices[start].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[curEdge-&gt;end]) <span class="built_in">dfs</span>(curEdge-&gt;end, visited);</span><br><span class="line">        curEdge = curEdge-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs_nonRecur</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; tasks;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// Necessary when doing non-recursive op.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            eNode* curEdge = vertices[tmp].edge;</span><br><span class="line">            <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[curEdge-&gt;end])</span><br><span class="line">                    tasks.<span class="built_in">push</span>(curEdge-&gt;end);</span><br><span class="line">                curEdge = curEdge-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>DFS：邻接矩阵表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>(<span class="type">int</span> start, <span class="type">bool</span> visited[]) <span class="type">const</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; vertices[start] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i] &amp;&amp; edges[start][i] != noEdgeFlag)</span><br><span class="line">            <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs_nonRecur</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; tasks;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;</span><br><span class="line">            std::cout &lt;&lt; vertices[tmp] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tmp + <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; edges[tmp][j] != noEdgeFlag)</span><br><span class="line">                    tasks.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>BFS：邻接表表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">bfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; taskQ;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        taskQ.<span class="built_in">enQueue</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!taskQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = taskQ.<span class="built_in">deQueue</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// necessary.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            eNode* curEdge = vertices[tmp].edge;</span><br><span class="line">            <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[curEdge-&gt;end])</span><br><span class="line">                    taskQ.<span class="built_in">enQueue</span>(curEdge-&gt;end);</span><br><span class="line">                curEdge = curEdge-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>BFS：邻接矩阵表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">bfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; taskQ;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        taskQ.<span class="built_in">enQueue</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!taskQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = taskQ.<span class="built_in">deQueue</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// necessary when doing no-recursive op.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tmp + <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; edges[tmp][j] != noEdgeFlag)</span><br><span class="line">                    taskQ.<span class="built_in">enQueue</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="本文的-PDF-文档下载"><a href="#本文的-PDF-文档下载" class="headerlink" title="本文的 PDF 文档下载"></a>本文的 PDF 文档下载</h2><p>遇到不习惯、网页观看体验不好的，可以下载本文的 <a href="DM.pdf">PDF 文档📎</a> 进行阅读，使用时请勿传播，感谢配合！</p><p>———————————-EOF——————————-</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;&lt;u&gt;本系列文章为作者复习离散数学过程中的知识点总结、速通，欢迎补充&lt;/u&gt;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: 清华大学出版社《数理逻辑与集合论（第二版）》《图论与代数结构》&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;提示：大段文字阅读，点击右侧齿轮图标，进入阅读模式体验更佳 ~ &lt;/i&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="review" scheme="https://sjtuxhw.top/categories/review/"/>
    
    
    <category term="Discrete-Math" scheme="https://sjtuxhw.top/tags/Discrete-Math/"/>
    
    <category term="Graph" scheme="https://sjtuxhw.top/tags/Graph/"/>
    
    <category term="Logic" scheme="https://sjtuxhw.top/tags/Logic/"/>
    
    <category term="Set-Theory" scheme="https://sjtuxhw.top/tags/Set-Theory/"/>
    
  </entry>
  
  <entry>
    <title>数据结构复习-第四部分</title>
    <link href="https://sjtuxhw.top/2023/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/"/>
    <id>https://sjtuxhw.top/2023/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/</id>
    <published>2023-05-27T08:29:15.000Z</published>
    <updated>2023-09-19T05:18:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><i><u>本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充</u></i></p><p><i>Written by SJTU-XHW</i></p><p><i>Reference: 张同珍老师 PPT | UNIkeEN</i></p><hr><span id="more"></span><h2 id="Chapter-8-外部查找和排序"><a href="#Chapter-8-外部查找和排序" class="headerlink" title="Chapter 8 外部查找和排序"></a>Chapter 8 外部查找和排序</h2><h3 id="8-1-零碎概念集合"><a href="#8-1-零碎概念集合" class="headerlink" title="8.1 零碎概念集合"></a>8.1 零碎概念集合</h3><ul><li><p>内存与外存的特性：外存读取访问速率 &lt;&lt; 内存访问速率；</p><p><strong>尽可能避免访问，宁可增加计算量……</strong></p></li><li><p>记录：外存上的<strong>一个数据元素</strong>通常被称为一条记录；</p></li><li><p>磁道：磁盘表面储存信息的同心圆轨道；</p></li><li><p>扇区：磁盘的磁道被分为若干段，每段被称为一个扇区；</p><blockquote><p>一个扇区相当于磁带上的一个数据块，也称<strong>磁盘块</strong>，是<strong>一次磁盘读写</strong>的单位；</p></blockquote></li></ul><h3 id="8-2-B-树"><a href="#8-2-B-树" class="headerlink" title="8.2 B 树"></a>8.2 B 树</h3><ul><li><p>定义：存储在<strong>外存</strong>上的动态查找表：</p><p>一棵 m 阶 B 树或者为空，或者满足：</p><ol><li><p>根结点的度 <strong>$d_r\in\{0\}\space\bigcup\space[2,\space m]$</strong>；</p></li><li><p>除了根结点和叶结点外，每个结点的度 <strong>$d\in[\space\lceil\dfrac{m}{2}\rceil,\space m\space]$</strong>；</p></li><li><p>度为s（s＞0）的结点具有 n = s-1 个关键字，信息存放方式： </p><script type="math/tex; mode=display">(n,\space A_0,\space(K_1, R_1),\space A_1,\space...,\space(K_n, R_n), A_n)</script><ul><li>已排序：$K_1\le K_2\le …\le K_n$</li><li><strong>$n$</strong>：关键字数；</li><li><strong>$A_i$</strong>：指向满足关键字 <strong>$K_i\lt K\lt K_{i+1}$</strong> 的后继结点 的<strong>地址（是磁盘地址编号，可以类比为为内存中的指针）</strong>；</li><li><strong>$(K_i, R_i)$</strong>：键值对，{关键字K、目标文件块的地址R}；</li></ul></li><li><p>所有叶结点在同一层，且深度相同、不存在信息（也称“失败结点”）；</p></li></ol></li><li><p>加速原理：已知访问次数 <strong>$\varpropto$</strong> 查找树高度；</p></li><li><p>运算实现</p><ul><li><p>查找：类似二叉查找树，只不过多了“在结点中查找区间的步骤”</p></li><li><p>插入</p><p><strong>step 1. 先查找，再插入：注意结点内关键字的有序性</strong></p><blockquote><p>可能违反B树定义1+2：<strong>结点的度可能会超过阶数m</strong>，因此进入第二步；</p></blockquote><p><strong>step 2. 判断当前插入位的关键字数n（在插入前的）</strong></p><ul><li><strong>$n\le m-1$</strong>，则不影响，插入结束；</li><li><strong>$n=m$</strong>，<strong>必须分裂结点，进入第三步</strong>；</li></ul><p><strong>step 3. 分裂结点</strong></p><blockquote><p>不能违反定义1：根结点的度 ≥ 2，和定义2：非根非叶结点度 <strong>$\ge\lceil\dfrac{m}{2}\rceil$</strong>；</p></blockquote><p>假设原结点<strong>插入后</strong>：</p><script type="math/tex; mode=display">(m,\space A_0,\space(K_1, R_1),\space A_1,\space...,\space(K_{m}, R_{m}), A_{m})</script><p>则<strong>对半分割结点</strong>：</p><script type="math/tex; mode=display">\begin{aligned}&(\lceil\dfrac{m}{2}\rceil-1,\space A_0,\space(K_1,\space R_1),...,(K_{\lceil\cfrac{m}{2}\rceil-1},R_{\lceil\cfrac{m}{2}\rceil-1}),\space A_{\lceil\cfrac{m}{2}\rceil-1}):\space共\lceil\dfrac{m}{2}\rceil-1个\\&(m-\lceil\dfrac{m}{2}\rceil,\space A_{\lceil\cfrac{m}{2}\rceil},\space(K_{\lceil\cfrac{m}{2}\rceil},\space R_{\lceil\cfrac{m}{2}\rceil}),...,(K_m,\space R_m),\space A_m):\space 共m-\lceil\dfrac{m}{2}\rceil个\\&注:数学上有\space m-\lceil\dfrac{m}{2}\rceil\ge\lceil\dfrac{m}{2}\rceil-1\end{aligned}</script><p>再将中间的结点：<strong>$(K_{\lceil\cfrac{m}{2}\rceil},\space R_{\lceil\cfrac{m}{2}\rceil})$</strong> 提到父结点上用以分开两个分裂结点；</p><p><strong>step 4. 提升到父结点后，对父结点递归第二步，检查是否违反定义，并及时修正</strong></p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="BTreeInsert.jpg"></p></li><li><p>删除</p><p><strong>step 1. 先查找关键字 $K_i$ 的位置，判断是否在底层（下一层为失败结点）</strong></p><blockquote><p>如果是，跳过第二步；</p></blockquote><p><strong>step 2. 找“替身”，使用右子树最左关键字（或左子树最右关键字，都位于底层）取代，然后转化为删除底层关键字</strong></p><p><strong>step 3. 删除底层结点（注意不是失败结点）</strong></p><blockquote><p>不能违反定义1、2：根节点度……非根非叶结点度……；</p></blockquote><ul><li><p>删除后，关键字个数 <strong>$n\in[\space\lceil\dfrac{m}{2}\rceil-1\space,m-1\space]$</strong>，符号定义，删除结束；</p></li><li><p>删除后，关键字个数 <strong>$n=\lceil\dfrac{m}{2}\rceil-2$</strong>，则需要向左 / 右兄弟节点借关键字；</p><blockquote><p>借的步骤（以左兄弟为例，如果左兄弟恰好<strong>$\lceil\dfrac{m}{2}\rceil-1$</strong>没法借，借右兄弟）：</p><p>将左兄弟的最大关键字上移至父结点，再将父结点中大于该关键字的最小关键字（连同左兄弟最右边的指针）下移给被删关键字所在结点的最左边。完成。</p></blockquote></li><li><p>删除后，左、右兄弟结点都是 <strong>$n^\prime=\lceil\dfrac{m}{2}\rceil-1$</strong>，没法借，那么需要<strong>合并结点</strong>；</p><blockquote><p>合并步骤（以合并左兄弟为例，右兄弟同理）：</p><p>将该结点与左兄弟合并，同时下移父结点位于这两个结点间的关键字；</p><p><strong>同时，这种情况必须递归检查父结点，如果父结点也因为减少一个关键字而不符定义，则也“先借，不行再合并”</strong></p></blockquote></li></ul></li><li><p>运算实现的形象记忆：<strong>膨胀直到分裂；太瘦吸收两侧结点；都瘦合并结点</strong></p></li></ul></li></ul><ul><li><p>常见疑问：B树的阶数怎么确定？B树的结点怎么组织？算法设计中怎么快速找父结点？</p><p>Answer：</p><ul><li><p>针对第一个问题，应该在实际应用中根据<strong>磁盘块大小、关键字长度、磁盘块地址长度</strong>共同确定B树的阶数；B树阶数的计算思路和B+树类似，可以参考后面<a href="#BPCalc">B+树的阶数计算🔗</a>；</p></li><li><p>针对第二个问题，和之前的数据结构不一样，B树存在外存上而非内存上，所以我们要定义先确定B树的阶数<strong>【没错，每棵B树的阶数在生命周期中是定值，不能变化】</strong>，然后事先在磁盘块的对应位置分配好各个结点、各个字段的空间位置，这样一棵B树就固定下来了！<strong>以后每访问B树的一个结点（在一个磁盘块大小中），就由 $A_i$ 的指引，在规定的空间完成就行</strong>；</p></li><li>针对第三个问题，在理解第二个问题后会发现，B树（包括B+树）的父结点的位置可以结合结点在磁盘上的分布（具体设计具体分析）计算出来（或者记录下来，因为存在外存的数据一定很大，一个地址的大小可以忽略不计），不用特意寻找浪费时间；</li></ul></li></ul><h3 id="8-3-B-树"><a href="#8-3-B-树" class="headerlink" title="8.3 B+ 树"></a>8.3 B+ 树</h3><blockquote><p>出现原因：B树支持快速查找某个记录，但如果要<strong>按关键字大小顺序访问文件的所有记录</strong>，那么时间效率低下；需要一个新型索引结构，来完成对于<strong>索引顺序文件（支持随机访问、按关键字顺序访问的文件）</strong>的访问；</p><ol><li><p>保证索引有序（像 B 树结点中关键字有序）</p></li><li><p>保证文件的记录有序</p></li></ol></blockquote><ul><li><p>定义：M 阶 B+ 树是满足如下条件的 M 叉树：</p><ul><li><p>根的度满足 <strong>$d_r\in\{0\}\space\bigcup\space[2,\space M]$</strong>；</p></li><li><p>除根以外的<strong>所有结点</strong>的度满足  <strong>$d\in[\space\lceil\dfrac{M}{2}\rceil,\space M\space]$</strong>；</p></li><li><p>度为 k 的结点保存 k - 1 个键来引导查找，<strong>第 i 个键代表第 i + 1 子树中的键的最小值</strong></p><blockquote><p>这意味着 B+ 树和 B 树不同，B+树中非底层（叶结点的上一层）结点存储的键都是出现在底层结点的！</p></blockquote></li><li><p>叶结点包含<strong>数据块（为了访问结点的效率，一个数据块的大小应该设计为一个磁盘块的大小，使得机器在一次 I/O 读写就能完全将内容读进内存）</strong>，其中存放若干记录（键-值对），同时叶结点按序连成单链表；</p><blockquote><p>这意味着 B+ 树的叶结点 和 非叶结点的<strong>类型不一样</strong>，即内含数据成员不一样；</p></blockquote></li><li><p>叶结点中的每个数据块至少 <strong>$\lceil\dfrac{L}{2}\rceil$</strong> 个记录，至多 L 个记录；</p></li></ul></li></ul><ul><li><p>B树、B+树重难点题</p><ul><li><p><span id="BPCalc">B+树阶数计算</span></p><blockquote><p>已知：一棵 B+ 树的一个非叶结点预分配：M-1个键、M个指针（记录磁盘地址）；叶结点预分配：L个记录、1个指针（构成单链表，但相对于L个记录可忽略不计）；</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="BPTreeS.jpg"></p></blockquote><p>假设：一个磁盘块 W Bytes、一个记录 R Bytes、一个关键字 K Bytes、一个磁盘地址大小 A Bytes，则：</p><script type="math/tex; mode=display">\begin{equation}\left\{  \begin{aligned}&K\cdot(M-1)+A\cdot M\le W\\  &L\cdot R\le W\quad(A\ll L\cdot R)\\  \end{aligned}  \right.\end{equation}  \qquad (一般都取等、取整作最优情况)</script></li><li><p>插入/删除某个元素后，B/B+树的结构变成什么样子；</p></li><li><p><strong>含有 n（n＞0）个非叶结点的 m 阶 B 树至少包含多少个关键字、至多包含多少个关键字？</strong>；</p><blockquote><p>分析：</p><p>最少关键字时，每个结点都取最少的度；根结点最小度为2（n＞0 保证根结点不是叶结点）、其他非叶结点最小度为 $\lceil \dfrac{m}{2}\rceil$，所以最小关键字为：$(n-1)(\lceil \dfrac{m}{2}\rceil-1)+1$ ；</p><p>最多关键字时，每个结点取最多的度，所有非叶结点的最大度都是 m，所以最多关键字是 $n(m - 1)$；</p></blockquote></li><li><p>一棵 m 阶 B 树有 N 个关键字，则这棵 B 树的最大高度、最小高度（高度含叶结点）分别是？</p><blockquote><p>分析：</p><p>最大高度在所有非叶结点都取最小度时取得（根度为2，非根非叶度为 m/2 向上取整），不妨假设此时高度为 h，非叶结点所占高度为 h - 1；由于 B 树的叶结点在同一层，各个结点非常整齐，那么反推总非叶结点数（包括根结点）：</p><script type="math/tex; mode=display">\begin{aligned}n_{NL}&=1+2+2\cdot\lceil \dfrac{m}{2}\rceil+\cdots+2\cdot(\lceil\dfrac{m}{2}\rceil)^{h-3}\\&=1+2\cdot\dfrac{(\lceil\cfrac{m}{2}\rceil)^{h-2}-1}{\lceil\cfrac{m}{2}\rceil-1}\end{aligned}</script><p>结合”非根非叶度为 m/2 向上取整”的结论，所有非叶结点的关键字数（包括根结点）：</p><script type="math/tex; mode=display">\begin{aligned}N&=(n_{NL}-1)\cdot(\lceil \dfrac{m}{2}\rceil-1)+1\\&=2(\lceil \dfrac{m}{2}\rceil)^{h-2}-1\end{aligned}</script><p>所以：$h\le2+log_{\lceil\cfrac{m}{2}\rceil}(\dfrac{N+1}{2})$；</p><p>最小高度同理:</p><script type="math/tex; mode=display">\begin{aligned}n_{NL}&=1+\sum\limits_{k=1}^{h-2}{m^k}=1+\dfrac{m(m^{h-2}-1)}{m-1}\\N&=(n_{NL}-1)\cdot(m-1)+m-1=m^{h-1}-1\end{aligned}</script><p>所以：$h\ge 1+log_m(N+1)$；</p></blockquote><p>综上，得到 B 树的高度结论（其中高度 h 包含叶结点）：</p><p><strong>含 N 个关键字的 m 阶 B 树的高度 $h\in[1+log_m(N+1),\space 2+log_{\lceil\cfrac{m}{2}\rceil}(\dfrac{N+1}{2})],\space h\in \mathbf{N^*}$</strong></p></li><li><p>什么？你问 B+ 树的关键字、高度的计算呢？B+ 树的关键字都在叶结点里，非叶结点中的只是对叶结点的重复、索引，讨论的意义不大；算 B+ 树的阶数才是重点；</p></li></ul></li></ul><ul><li><p>运算实现</p><ul><li><p>查找：略</p></li><li><p>插入</p><blockquote><p>和 B 树类似，但需要注意的是，B+ 树和 B 树不同，在非叶结点中的键一定存在记录中，并且表示第 i + 1棵子树的最小值，<strong>所以在分裂结点时，没有上移的说法</strong>；</p></blockquote></li><li><p>删除：和 B 树对应的解决方案，<strong>先领养，不行再合并</strong></p></li></ul></li></ul><h3 id="8-4-外排序"><a href="#8-4-外排序" class="headerlink" title="8.4 外排序"></a>8.4 外排序</h3><blockquote><p>一般都使用归并排序，这在外排序中极其优秀；</p></blockquote><p>⚠<strong>易错警示：如果题目说：”多阶段归并是为了最大限定地提高归并的路数“是正确的。不是说多阶段归并本身能提高归并路数，是因为多阶段归并能够提高”路“的利用率（对k路，总路数2k降为k+1），这样在同样大小的内存中，可以选取更大的k值。所以多阶段归并的目的也可以说成（在一定的资源条件下）为了最大限度地提高归并的路数</strong>；</p><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="ExSort.jpg"></p><p>█◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤图部分将结合离散数学-图论知识共同复习◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█</p><h2 id="Chapter-9-图"><a href="#Chapter-9-图" class="headerlink" title="Chapter 9 图"></a>Chapter 9 图</h2><h3 id="9-1-图论中的重要定义Ⅰ"><a href="#9-1-图论中的重要定义Ⅰ" class="headerlink" title="9.1 图论中的重要定义Ⅰ"></a>9.1 图论中的重要定义Ⅰ</h3><blockquote><p>图的起源：人们关心一类问题，给定的两点间是否有一条或多条连线的关系，而连接方式无关紧要。这类问题在数学上的抽象是<strong>图</strong>；</p></blockquote><ul><li><p>图的数学定义：一个图指<strong>有序三元组$(V(G),E(G),\psi_G)$</strong>，<strong>$V(G)$</strong>为<strong>非空</strong>（空图特殊，不参与讨论）顶点集，<strong>$E(G)$</strong>是不与<strong>$V(G)$</strong>相交的边集，<strong>$\psi_G$</strong>为关联函数；</p><blockquote><p>约定：对于图 G，一般用符号 <strong>$V(G)$</strong> 表示顶点集、<strong>$E(G)$</strong> 表示边集、<strong>$\nu(G)$</strong> 表示顶点数，<strong>$\varepsilon(G)$</strong> 表示边数；若上下文仅有一个图，则省略 “(G)”；</p><p>注：无向图可以表示为二元组，即 V 和 E；</p></blockquote></li><li><p>顶点对的定义：<strong>$\psi_G$</strong> 使 G 的每条边对应于 G 的 无序的<strong>顶点对</strong>；</p></li><li><p>连接、端点的定义：若 e 为 G 的一条边，u、v 是使 <strong>$\psi_G(e)=(u,v)$</strong> 的顶点，则称：e <strong>连接</strong> u、v，顶点 u、v 称为 e 的<strong>端点</strong>；</p></li><li><p>关联、相邻、自环：一条边的端点与这条边<strong>关联</strong>；与同一条边关联的两个顶点称为<strong>相邻</strong>；端点重合为一点的边称为<strong>自环</strong>；</p></li><li><p>平面图、非平面图：边仅在端点相交的图称为<strong>平面图</strong>，反之为非平面图；</p></li><li><p>平凡图、非平凡图：仅有一个顶点的图称为<strong>平凡图</strong>；</p></li><li><p>有向边、无向边：可由端点 <strong>$v_i\space和\space v_j$</strong> 表示 <strong>$e_k=(v_i,v_j)$</strong> 的边称为<strong>无向边</strong>（vi、vj互为直接前驱、直接后继）；可由有序二元组 <strong>$e_k=\lt v_i,v_j\gt$</strong> 表示的边是<strong>有向边</strong>（vi是vj的直接前驱、vj是vi的直接后继）；</p></li><li><p>有向图、无向图：所有边都是有向边的图是<strong>有向图</strong>，反之是<strong>无向图</strong>，否则是混合图；</p><blockquote><p>可以将无向边视作双向有向边，因此此后不讨论混合图；</p></blockquote></li><li><p>简单图、有向简单图：既没有<strong>自环</strong>，又没有<strong>重边</strong>的图，如果是无向图，称为<strong>简单图</strong>；如果是有向图，称为<strong>有向简单图</strong>；</p><blockquote><ol><li><p>重边的定义：有两条及以上条边连接同一对顶点，称这个边为重边；</p><p>⚠<strong>易错警示：对有向边，A—-&gt;B 和 B—-&gt;A 组合不算重边！A—-&gt;B 和 A—-&gt;B 组合才是</strong>；</p></li><li><p>如果不强调“有向”，一般情况下“图”指“无向图”；不过在定义中，如果发现只描述无向图的，大概率对有向图也适用，不然就单独拎出来了；</p></li></ol></blockquote></li><li><p>完全图、有向完全图：每对不同顶点都有一条边相连的<strong>简单</strong>图称为<strong>完全图</strong>；有向完全图同理；</p><p><strong>特别地，将 n 个结点的完全图记作 $K_n$，但有向完全图没有这种记法；</strong></p><blockquote><p><strong>定理1：$\varepsilon(K_n)=C^2_{n}$ 且对n 个结点的有向完全图G：$\varepsilon(G)=A^2_{n}$；</strong></p><p>（因为A—-&gt;B 和 B—-&gt;A 组合不算重边） </p></blockquote></li><li><p>偶图（或者称二部图）：一个图 G 的顶点集 <strong>$V(G)$</strong> 可以分解为两个子集 X、Y，使得：每条边都有一个顶点在 X 中，另一个顶点在 Y 中；这样的一种分类 (X, Y) 称为 G 的一个<strong>二分类</strong>；</p><blockquote><p>理解：按分解的两个点集“切一刀”，所有边都被砍断的图；</p></blockquote></li><li><p>子图：若 <strong>$V(H)\subseteq V(G),\space E(H)\subseteq E(G)$</strong>，<strong>$\psi_H$</strong> 为 <strong>$\psi_G$</strong> 在 <strong>$E(H)$</strong> 上的限制，则 <strong>$H$</strong> 为 <strong>$G$</strong> 的<strong>子图</strong>，记作：<strong>$H\subseteq G$</strong>；（真子图略）</p></li><li><p>母图：若 <strong>$H\subseteq G$</strong>，称 <strong>$G$</strong> 为 <strong>$H$</strong> 的<strong>母图</strong>；</p></li><li><p>生成子图（或称支撑子图，spanning sub-graph）：<strong>$H\subseteq G\space且\space V(H)=V(G)$</strong>，称 <strong>$H$</strong> 为 <strong>$G$</strong> 的<strong>生成子图</strong>；</p></li><li><p>导出子图：有点抽象，一般用不到定义，想要形象地了解见：<a href="#graphCalc">图的运算🔗</a>；</p></li><li><p>基础简单图：一个图 G 删去所有<strong>“多余”的边</strong>，使图中恰没有重边、自环，得到的这样的<strong>简单生成子图</strong>称为<strong>基础简单图</strong>；</p></li><li><p>赋权图（或称加权图）：若给图 G 的每条边都赋以实数 <strong>$w_k$</strong> 作为该边的权，称 G 为赋权图；</p></li><li><p>顶点的度：图 G 的顶点 v 的度记为 <strong>$d_G(v)$</strong>，指 G 中与 v 相关联的数目；</p><ul><li>约定：<strong>$\delta(G)、\Delta(G)$</strong> 表示 G 的所有顶点的最小度、最大度；</li><li>度为0的点称为<strong>孤立点</strong>；</li><li><strong>对于有向图，$d(v)=d_+(v)+d_-(v)$，$d_+$ 为正度/入度，$d_-$ 为负度/出度</strong>；</li><li><strong>自环贡献一个入度、一个出度</strong>；</li></ul><blockquote><p><strong>定理2：（握手定理）$\sum\limits_{v\in V}d(v)=2\varepsilon$（所有结点的度之和为边数的2倍，有向图也是）</strong>；</p><p>推论：对任何图，度为奇数的点（称<strong>奇点</strong>）的个数为偶数；</p><p><strong>定理3：有向图中，$\sum{d_-}=\sum{d_+}=\varepsilon$（入度和=出度和=边数，是入度出度平分的意思）</strong></p><p><strong>定理4：非空简单图（$\varepsilon\gt1$）一定存在度相同的结点</strong>；</p></blockquote></li></ul><h3 id="9-2-图的同构"><a href="#9-2-图的同构" class="headerlink" title="9.2 图的同构"></a>9.2 图的同构</h3><blockquote><p>注：图同构问题分为4类：精确图完全同构、精确子图同构、不精确图完全同构、不精确子图同构；现在学界已证明后三者是 NP 完全问题；计算机离散数学-图论、数据结构（包括下面的内容）讨论的是第一种问题；</p></blockquote><ul><li><p>恒等图的定义</p></li><li><p>同构图的定义：如果存在两个<strong>一一映射（双射）$\theta:\space V(G)\rightarrow V(H),\space\phi:\space E(G)\rightarrow E(H)$</strong>，使 <strong>$\psi_G(e)=(u,v)$</strong> 当且仅当 <strong>$\psi_H(\phi(e))=\theta(u)\theta(v)$</strong>，则将这样的映射对 <strong>$(\theta,\phi)$</strong> 称为 G 和 H 间的一个同构；将 G 与 H 同构关系记为 <strong>$G\cong H$</strong>；</p><blockquote><p>理解：边边和点点必须一一相应；</p><p>就是在不添加边和点、不删除边和点的基础上<strong>任意移动顶点的相对位置、为顶点和边改名</strong>，所产生的不同形态的图；</p></blockquote></li><li><p>关于同构的定理</p><blockquote><p><strong>定理5：（同构的必要条件）两个同构图的结点度的非增序列相同</strong></p><p><strong>定理6：（同构的必要条件）若 G1 与 G2 同构，则 G1 的任意<u>导出子图</u>都有 G2 的导出子图与其同构</strong>；</p><p>其实还有一个必要条件过于明显，不作为定理：两同构图的顶点数、边数相等；</p></blockquote></li><li><p>判断方法</p><ul><li><p>判断两图同构：<strong>按定义，找到两个一一映射</strong>；</p><blockquote><p>注：根据定义，可以得出一个显然的方法：<strong>一个图的邻接矩阵经历有限次的行互换、列互换，能变成另一个图的邻接矩阵，那么这两个图同构</strong>；</p></blockquote></li><li><p>判断两图不同构：使用定理5、6（必要条件），不满足必要条件的就不是；</p></li></ul></li></ul><h3 id="9-3-图的存储实现"><a href="#9-3-图的存储实现" class="headerlink" title="9.3 图的存储实现"></a>9.3 图的存储实现</h3><ul><li><p><span id="relM">图的关联矩阵（<strong>行是顶点，列是边</strong>）：因为空间原因，不做存储图的方法；</span></p><blockquote><p>虽然不做存储方法，但在讨论<strong>树、有向连通图、电路图的某些性质</strong>时比较有用，感兴趣戳<a href="#relMDetails">这里🔗</a>（不在初级数据结构要求范围内）；</p></blockquote><ul><li>无向图的关联矩阵：可以由 bool 矩阵表示，1是有关联，0是没有关联；</li><li>有向图的关联矩阵：+1表示该边离开该结点，即正度/出度；-1表示该边进入该结点，即负度/入度；0表示没有关联；</li></ul></li><li><p>图的邻接矩阵表示法：对任意的图 G，对应一个 <strong>$\nu\times\nu$</strong> 的邻接矩阵 <strong>$A(G)=[a_{ij}]$</strong>，其中 <strong>$a_{ij}$</strong> 为 <strong>$v_i、v_j$</strong> 的连接数目；（空间：<strong>$O(|V|^2)$</strong>）</p><p><strong>进一步，在数据结构中更常用的是“加权图的邻接矩阵”存储方法，可以兼顾非加权图：</strong></p><script type="math/tex; mode=display">A[i][j]=\begin{equation}\left\{\begin{aligned}&\omega,&<i,j,w>\in E\\&0,&i=j\\&\infty,&otherwise\\\end{aligned}\right.\end{equation}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjMatrixGraph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VType* vertices;    <span class="comment">// store the data of each vertex.</span></span><br><span class="line">    EType** edges;      <span class="comment">// store the data of each edge (in adjacent matrix form).</span></span><br><span class="line">    EType noEdgeFlag;    <span class="comment">// represent the no-edge area.</span></span><br><span class="line">    <span class="type">int</span> vertixNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vertexIdx</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertixNum; ++i)</span><br><span class="line">            <span class="keyword">if</span> (vertices[i] == v) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">vertexNotExists</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">bool</span> visited[])</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">adjMatrixGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">const</span> EType&amp; noEdge);</span><br><span class="line">    <span class="built_in">adjMatrixGraph</span>(<span class="type">const</span> adjMatrixGraph&lt;VType, EType&gt;&amp; cp) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">adjMatrixGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjMatrix</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_nonRecur</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>图的邻接表表示法：改进了邻接矩阵表示法在面对稀疏矩阵时浪费空间、不易维护的问题；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">结点集(结点数组)：node1 &#123;结点值，与该结点相邻的直接后继(有方向)结点索引链表头指针&#125;</span><br><span class="line"> |------------------------------------------------------------|</span><br><span class="line"> v</span><br><span class="line">边集(单链表)：node2 &#123;结点索引（不能放结点值，因为无法完成后面的遍历运算, 下一node2&#125;</span><br><span class="line"></span><br><span class="line">+ 保存边数、保存结点数</span><br><span class="line">空间：O(|V|+|E|)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjListGraph</span>: <span class="keyword">public</span> graph&lt;VType, EType&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        EType weight;</span><br><span class="line">        eNode* next;</span><br><span class="line">        <span class="built_in">eNode</span>(): <span class="built_in">end</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">eNode</span>(<span class="type">const</span> EType&amp; w, <span class="type">int</span> e=<span class="number">0</span>, eNode* nxt=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">weight</span>(w), <span class="built_in">end</span>(e), <span class="built_in">next</span>(nxt) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">vNode</span> &#123;</span><br><span class="line">        VType data;</span><br><span class="line">        eNode* edge;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EulerNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> nodeIdx;</span><br><span class="line">        EulerNode* next;</span><br><span class="line">        <span class="built_in">EulerNode</span>(<span class="type">int</span> idx=<span class="number">0</span>, EulerNode* n=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">nodeIdx</span>(idx), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vNode* vertices;</span><br><span class="line">    <span class="type">bool</span> directed;</span><br><span class="line">    <span class="type">int</span> vertixNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vertexIdx</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertixNum; ++i)</span><br><span class="line">            <span class="keyword">if</span> (vertices[i].data == v) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">vertexNotExists</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typename</span> adjListGraph&lt;VType, EType&gt;::<span class="function">vNode* <span class="title">cloneBase</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">bool</span> visited[])</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _insert(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">const</span> EType&amp; w);</span><br><span class="line">    <span class="type">void</span> _remove(<span class="type">int</span> v1, <span class="type">int</span> v2);</span><br><span class="line">    <span class="type">int</span> _getInDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> _getOutDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> _getDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">void</span> _EulerCircuit(<span class="type">int</span> start, EulerNode*&amp; begin, EulerNode*&amp; end);</span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">topoSortIdx</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">criticalPath</span><span class="params">(<span class="type">int</span>* early, <span class="type">int</span>* late)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> prev[])</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">adjListGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">bool</span> direct=<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">adjListGraph</span>(<span class="type">const</span> adjListGraph&lt;VType, EType&gt;&amp; cp);</span><br><span class="line">    <span class="built_in">adjListGraph</span>(adjListGraph&lt;VType, EType&gt;&amp;&amp; tmp);</span><br><span class="line">    ~<span class="built_in">adjListGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getInDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getOutDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjList</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_nonRecur</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_dfs_tree</span><span class="params">(<span class="type">const</span> VType&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_bfs_tree</span><span class="params">(<span class="type">const</span> VType&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EulerCircuit</span><span class="params">(<span class="type">const</span> VType&amp; start)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">criticalPath</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// The shortest path for the graph: O(n^3)</span></span><br><span class="line">    <span class="function">VType* <span class="title">dijkstra</span><span class="params">(<span class="type">const</span> VType&amp; start, <span class="type">const</span> EType&amp; noEdge, <span class="type">bool</span> prompt=<span class="literal">false</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">VType* <span class="title">SPFA</span><span class="params">(<span class="type">const</span> VType&amp; start, <span class="type">const</span> EType&amp; noEdge)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-4-图的运算实现（except-for-traverse）"><a href="#9-4-图的运算实现（except-for-traverse）" class="headerlink" title="9.4 图的运算实现（except for traverse）"></a>9.4 图的运算实现（except for traverse）</h3><ul><li><p><span id="graphCalc">图的基本运算</span></p><ul><li><p>差运算：<strong>（要求 $G_2$ 为 $G_1$ 子图）$G_1-G_2=(V_1,E_1-E_2)$</strong>；</p></li><li><p>补运算：<strong>$n$</strong> 个结点的简单图的补图 <strong>$\overline{G}=K_n-G$</strong>；</p></li><li><p>删去结点 <strong>$v$</strong> 及其关联的边：<strong>$G-v$</strong></p><blockquote><p><strong>$G-v$</strong> 为 <strong>$G$</strong> 的<strong>导出子图</strong>：有助于理解导出子图的意义；</p></blockquote></li><li><p>删去边 <strong>$e$</strong>：<strong>$G-e$</strong></p><blockquote><p><strong>$G-e$</strong> 为 <strong>$G$</strong> 的<strong>生成子图</strong>：有助于理解生成子图的意义；</p></blockquote></li><li><p>增加边 <strong>$e_{ij}=(v_i,v_j)$</strong>：<strong>$G+e_{ij}$</strong></p></li></ul></li><li><p>数据结构中图的基本运算：创建、判边、增删边、查点边数、遍历（后面分开讨论）；</p></li><li><p>图的运算实现：<strong>对于不同的存储方式，图的运算时间复杂度有所不同</strong></p><ul><li><p>邻接矩阵表示的运算实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">adjMatrixGraph</span>(</span><br><span class="line">    <span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">const</span> EType&amp; noEdge) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = vSize; <span class="keyword">this</span>-&gt;edgeNum = <span class="number">0</span>; noEdgeFlag = noEdge;</span><br><span class="line">    vertices = <span class="keyword">new</span> VType[vSize];</span><br><span class="line">    edges = <span class="keyword">new</span> EType*[vSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vSize; ++i) &#123;</span><br><span class="line">        vertices[i] = vers[i];</span><br><span class="line">        edges[i] = <span class="keyword">new</span> EType[vSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vSize; ++j)</span><br><span class="line">            edges[i][j] = noEdge;</span><br><span class="line">        edges[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjMatrixGraph&lt;VType, EType&gt;::~<span class="built_in">adjMatrixGraph</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] vertices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] edges[i];</span><br><span class="line">    <span class="keyword">delete</span>[] edges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">bool</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">exist</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">return</span> edges[u][v] != noEdgeFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">undirected_insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    <span class="keyword">if</span> (edges[v][u] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = edges[v][u] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">remove</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] != noEdgeFlag) --<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = noEdgeFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">printAdjMatrix</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j)</span><br><span class="line">            std::cout &lt;&lt; edges[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>邻接表表示的运算实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">bool</span> direct) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = vSize; directed = direct;</span><br><span class="line">    <span class="keyword">this</span>-&gt;edgeNum = <span class="number">0</span>; vertices = <span class="keyword">new</span> vNode[vSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vSize; ++i) &#123;</span><br><span class="line">        vertices[i].data = vers[i];</span><br><span class="line">        vertices[i].edge = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::~<span class="built_in">adjListGraph</span>() &#123;</span><br><span class="line">    eNode* curEdge;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curEdge = vertices[i].edge) &#123;</span><br><span class="line">            vertices[i].edge = curEdge-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> curEdge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vertices) <span class="keyword">delete</span>[] vertices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> adjListGraph&lt;VType, EType&gt;::vNode* adjListGraph&lt;VType, EType&gt;::<span class="built_in">cloneBase</span>() <span class="type">const</span> &#123;</span><br><span class="line">    vNode* newVers = <span class="keyword">new</span> vNode[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        newVers[i].data = vertices[i].data;</span><br><span class="line">        newVers[i].edge = <span class="literal">nullptr</span>;</span><br><span class="line">        eNode** curEdgeDst = &amp;(newVers[i].edge);</span><br><span class="line">        eNode* curEdgeSrc = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdgeSrc) &#123;</span><br><span class="line">            *curEdgeDst = <span class="keyword">new</span> <span class="built_in">eNode</span>(curEdgeSrc-&gt;weight, curEdgeSrc-&gt;end, <span class="number">0</span>);</span><br><span class="line">            curEdgeDst = &amp;((*curEdgeDst)-&gt;next);</span><br><span class="line">            curEdgeSrc = curEdgeSrc-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newVers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(<span class="type">const</span> adjListGraph&lt;VType, EType&gt;&amp; cp) &#123;</span><br><span class="line">    vertices = cp.<span class="built_in">cloneBase</span>(); <span class="keyword">this</span>-&gt;edgeNum = cp.edgeNum;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = cp.vertixNum; directed = cp.directed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(adjListGraph&lt;VType, EType&gt;&amp;&amp; tmp) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;edgeNum = tmp.edgeNum; <span class="keyword">this</span>-&gt;vertixNum = tmp.vertixNum; directed = tmp.directed;</span><br><span class="line">    tmp.edgeNum = tmp.vertixNum = <span class="number">0</span>; vertices = tmp.vertices; tmp.vertices = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">bool</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">exist</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="type">const</span> eNode* cur = vertices[u].edge;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;end == v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::_insert(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    eNode** cur = &amp;(vertices[v1].edge);</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;end != v2) cur = &amp;((*cur)-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (!(*cur)) &#123; ++<span class="keyword">this</span>-&gt;edgeNum; *cur = <span class="keyword">new</span> <span class="built_in">eNode</span>(w, v2); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::_remove(<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">    eNode** cur = &amp;(vertices[v1].edge);</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;end != v2) cur = &amp;((*cur)-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (*cur) &#123;</span><br><span class="line">        eNode* tmp = *cur; *cur = (*cur)-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp; --<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    _insert(u, v, w);</span><br><span class="line">    <span class="keyword">if</span> (!directed) _insert(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">remove</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    _remove(u, v);</span><br><span class="line">    <span class="keyword">if</span> (!directed) _remove(v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getInDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == v) <span class="keyword">continue</span>;</span><br><span class="line">        eNode* curEdge = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEdge-&gt;end == v) ++ans;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getOutDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    eNode* target = vertices[v].edge;</span><br><span class="line">    <span class="keyword">while</span> (target) &#123; ++ans; target = target-&gt;next; &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (directed) <span class="keyword">return</span> _getInDegree(v) + _getOutDegree(v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> _getOutDegree(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getInDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getInDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getOutDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getOutDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">printAdjList</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; vertices[i].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">const</span> eNode* cur = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;|-w=&quot;</span> &lt;&lt; cur-&gt;weight</span><br><span class="line">                &lt;&lt; <span class="string">&quot;-&gt;(&quot;</span> &lt;&lt; cur-&gt;end &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="9-5-图论中的重要定义Ⅱ"><a href="#9-5-图论中的重要定义Ⅱ" class="headerlink" title="9.5 图论中的重要定义Ⅱ"></a>9.5 图论中的重要定义Ⅱ</h3><ul><li><p>道路和回路：在无向图 <strong>$G=(V,E)$</strong> 中，若<u>边点交替序列</u> <strong>$P=(v_{i1},e_{i1},v_{i2},e_{i2},…,e_{iq-1},v_{iq})$</strong> 满足：<strong>$v_{ik}、v_{ik+1}$</strong> 为 <strong>$e_{ik}$</strong> 的两个端点，则称 P 为 G 的一条<strong>道路</strong>；特别地，如果 <strong>$v_{i1}=v_{iq}$</strong>，那么称道路 P 为 G 的一条<strong>回路</strong>；</p><ul><li>如果 P 序列中没有重复的边，则 P 称为<strong>简单道路（或称“迹”）、简单回路（或称“闭迹”）</strong>；</li><li>更特别地，如果 P 序列中结点也不重复（结点不重复是边不重复的充分不必要条件），则称 P 为 G 的<strong>初级道路、初级回路</strong>；</li></ul></li><li><p>有向道路和有向回路：在有向图 <strong>$G=(V,E,\psi_G)$</strong> 中，若<u>边序列</u> <strong>$P=(e_{i1},e_{i2},…,e_{iq})$</strong>，其中  <strong>$e_{ik}=(v_l, v_j)$</strong>，则称 P 为 G 的<strong>有向道路</strong>；若 <strong>$e_{iq}$</strong> 终点也是 <strong>$e_{i1}$</strong> 的始点，则称 P 为 G 的<strong>有向回路</strong>；</p><ul><li>同样有：简单有向道路、简单有向回路、初级有向道路、初级有向回路的概念；</li></ul><blockquote><p>⚠易错点：<strong>平凡图一定是道路，但一定不是回路！</strong></p></blockquote></li><li><p>连通性、强连通性、弱连通性、单向连通性</p><ul><li>无向图考虑“连通”：两结点间至少存在一条道路，则这两个结点间连通；</li><li>有向图考虑：<ol><li>两结点间存在一条从 <strong>$v_i$</strong> 到 <strong>$v_j$</strong> 的有向道路 <strong><u>且</u></strong> 存在另一条从 <strong>$v_j$</strong> 到 <strong>$v_i$</strong> 的有向道路，则称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>强连通</strong>；</li><li>两结点间<strong><u>仅</u></strong>存在一条从 <strong>$v_i$</strong> 到 <strong>$v_j$</strong> 的有向道路 <strong><u>或</u></strong> <strong><u>仅</u></strong>存在另一条从 <strong>$v_j$</strong> 到 <strong>$v_i$</strong> 的有向道路，则称称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>单向连通</strong>；</li><li>两结点间 <strong>不考虑所有道路的方向（称为“有向图的底图”）</strong>，若这两个结点连通，则称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>弱连通</strong>；</li></ol></li></ul></li><li><p>连通图、连通分量（或称“连通支”）</p><ul><li>无向图 G 中任意两结点间都是连通的，则 G 为<strong>连通图</strong>；</li><li>G 的连通子图（子图且连通）H 不是 G 的任何其他连通子图的真子图，称 H 为 G 的一个<strong>极大连通子图</strong>，也称<strong>连通分量</strong>；</li></ul><blockquote><p>有些不严谨的题问有向图“是不是连通图”，就将它看成一个无向图（忽略方向）；</p></blockquote></li><li><p>强连通图、强连通分量</p><ul><li>有向图 G 中任意两结点间都是强连通的，则 G 为<strong>强连通图</strong>；</li><li>G 的强连通子图 H 不是 G 的任何其他强连通子图的真子图，称 H 为 G 的一个<strong>极大的强连通子图</strong>，也称<strong>强连通分量</strong>；</li></ul><blockquote><p>⚠易错点1：<strong>平凡图也单独算一个连通分量 / 强连通分量！</strong></p><p>⚠易错点2：因为无向边看作“双向边”，所以连通的无向图一定是强连通的；</p><p><strong>推论：图 G 的每个连通分支都是其导出子图</strong>；</p><p><strong>小结论：图 G 对应关联矩阵记为 $M(G)$，则 G 的连通分支数为 $r(M(G))-1$</strong>；</p></blockquote></li><li><p>割边与非割边、割点与非割点：删去图中某个边 / 点，图的连通分支数（连通性）改变，则称该边 / 点为<strong>割边 / 割点</strong>；</p></li><li><p>欧拉道路、欧拉回路：<strong>无向连通图</strong> G 中的一条经过<u>所有边</u>的<strong>简单道路/回路</strong>称 G 的<strong>欧拉道路/回路</strong>；</p><ul><li><p>理解：不重复地遍历所有边，不管点的情况；</p></li><li><p>注意：<strong>有向图也能讨论欧拉回路的问题，不过要遵循有向的连通性</strong>；</p></li></ul><blockquote><p><strong>定理1：（欧拉回路充要条件）无向连通图 G 存在欧拉回路 $\Longleftrightarrow$ G 的各结点度数均为偶数</strong>；</p><p><strong>推论1-1：（欧拉道路充分条件）无向连通图 G 仅有2个奇点 $\Longrightarrow$ G 存在欧拉道路</strong>；</p><p><strong>推论1-2：（有向欧拉回路充分条件）有向连通图 G 的各结点的正、负度数相等 $\Longrightarrow$ G 存在有向欧拉回路</strong>（侧面说明有向可能严格一些，不仅结点度全为偶数，而且要进出相等）；</p><p>定理2：连通图 G 有 k 个奇点（由部分Ⅰ的定理可知，k为偶数），则 E(G) 可以划分为 <strong>$\dfrac{k}{2}$</strong> 条简单道路；</p></blockquote></li><li><p>哈密顿道路、哈密顿回路：<strong>无向图</strong> G 的一条<u>经过全部结点</u>的<strong>初级道路/回路</strong>称 G 的<strong>哈密顿道路/回路（简称H道路/H回路）</strong>；</p><ul><li>理解：“不重复地遍历所有点”；</li><li>注意：H 道路 / 回路一般针对简单图，因为重边和自环对它没有什么影响，可以转换为简单图的问题；</li></ul><blockquote><p><strong>很遗憾，目前 H 道路 / 回路的判定没有充要条件！一般遍历是 NP 问题……</strong></p><p><strong>定理3：（H 回路充分条件）完全图 $K_n$ 为 H 图</strong>；</p><p><strong>定理4：（H 回路充分条件）若简单图 G 每个结点度都大于 n/2，则 G 为 H 图</strong>；</p><p>说明：平均每个点的度越大，越有可能有H道路、H回路；</p><p><strong>推论4-1：（H 道路充分条件）若简单图 G 的任两结点 $v_i,v_j$ 恒有 $d(v_i)+d(v_j)\ge n-1$，则 G 存在 H 道路；</strong></p><p>证明提示：有 H 道路一定连通，可以先证连通性；</p><p><strong>推论4-2：（H 回路充分条件）若简单图 G 的任两结点 $v_i,v_j$ 恒有 $d(v_i)+d(v_j)\ge n$，则 G 为 H 图</strong>；</p><p><strong>推论4-3：（H 回路的闭包等价关系）向图 G 中满足 “ $d(v_i)+d(v_j)\ge n$”的不相邻两结点 $v_i,v_j$ 加边，直至无法找到这样的结点对为止，形成的新图称为 G 的闭包（记为$C(G)$）；那么有：$G\space为H图\Longleftrightarrow C(G)为H图$</strong>；</p><p><strong>推论4-4：（H回路闭包充分条件）若 $C(G)=K_n$，则 G 为 H 图</strong>；</p><p><strong>定理5：（可怜为数不多的 H 回路的必要条件）若 G 为 H 图，则对任意非空顶点集 S，有：$\omega(G-S)\le|S|$</strong>；</p></blockquote><ul><li><p>补充：欧拉图、H 图的定义：有欧拉回路 / H 回路的图才叫~（只有欧拉道路 / H 道路的不是）；</p></li><li><p>判断一个图是 H 图：使用上面的充分条件/等价条件；</p></li><li><p>判断一个图不是 H 图：使用上面的必要条件；</p><blockquote><p>举例：证明 Peterson 图是极大非 H 图（有 H 道路，但没有 H 回路）</p><p>【问题：它满足定理5，能否判断一下为什么在删去任意4个顶点时，连通分支数一定小于等于3？】</p><p><strong>定理6：（必要条件）若一个点在 H 回路中，那么必定有且仅有两个相连的相异道路</strong>；</p></blockquote></li></ul></li></ul><h3 id="9-6-图的简单应用"><a href="#9-6-图的简单应用" class="headerlink" title="9.6 图的简单应用"></a>9.6 图的简单应用</h3><ul><li>【普通图】有 3L、5L、8L的三个没有刻度的量杯，现在8L的量杯装满了水，其他两个是空的；问如何操作（不撒不漏）可以让8L水分为两个4L水？</li><li>【二部图】人、狼、羊、菜过河问题</li></ul><blockquote><p>解决思路：<strong>“状态转换图”：</strong>将每一个状态抽象为一个顶点，先列出所有可能状态作为顶点，再用“一次能直接转换的关系”作为边连接，最后只需判断在起点（初态）和终点（末态）是否单向连通即可；</p></blockquote><h3 id="9-7-图论中的重要定义Ⅲ"><a href="#9-7-图论中的重要定义Ⅲ" class="headerlink" title="9.7 图论中的重要定义Ⅲ"></a>9.7 图论中的重要定义Ⅲ</h3><blockquote><p>提示：本章节不在初级数据结构要求范围内；</p></blockquote><ul><li><p>割边与非割边、割点与非割点：删去图中某个边 / 点，图的连通分支数（连通性）改变，则称该边 / 点为<strong>割边 / 割点</strong>；</p><blockquote><p><strong>定理1：e 为割边，当且仅当 e 不属于 G 的任何回路</strong>；</p></blockquote></li><li><p>普通树的数学定义：不含任何回路的连通图称为<strong>树</strong>；</p><blockquote><p><strong>定理2：“连通”、“无回路”、“有 n-1 条边”三个条件任取两个都可以作为树的定义</strong>；</p><p>推论：“连通+全为割边”、“任意两点间有唯一道路”、“无回路+加一边就一回路” 这三个与树的定义等价；</p><p><strong>定理3：树中一定有树叶结点（离散数学中没有空树的说法！只有空图）</strong></p></blockquote></li><li><p>根树的定义：若树 T 是有向树，且 T 中存在某结点 $v_0$ 的入度为0、其他结点入度为1，则称 <strong>T 是以 $v_0$ 为根的根树</strong>（或外向树），用 $\overrightarrow{T}$ 表示；</p><blockquote><p><strong>根树才是数据结构中的“树”！</strong></p></blockquote></li><li><p>生成树（或称“支撑树”）：图 G 的一个符合树定义的生成子图称为图 G 的<strong>生成树</strong>；</p><blockquote><p>余树：给定图 G 的一棵生成树 T，定义余树 $\overline{T}=G-T$；一般情况下，余树不是树；</p></blockquote></li><li><p><span id="relMDetails">基本关联矩阵：<strong>上接“<a href="#relM">关联矩阵存储🔗</a>”，虽然关联矩阵一般不作为存储方法，但有些情况讨论它的性质，可以更方便地解决某些问题</strong>；</span></p><blockquote><p>友情提醒1：这里和<strong>电路理论的电路图研究</strong>结合比较紧密；</p><p>友情提醒2：这里的讨论对象是<strong>有向连通图</strong>；</p></blockquote><ul><li>定义：在<strong>有向连通图 $G=(V, E)$</strong> 的<strong>关联矩阵 $B$</strong> 中，划去任意任意结点 $v_k$所对应的一<strong>行</strong>，得到 <strong>$(\nu-1)\times\varepsilon$</strong> 的矩阵 $B_k$，称为 <strong>G 的一个基本关联矩阵</strong>；</li><li>相关定理</li></ul><blockquote><p><strong>定理1：有向连通图 G 的关联矩阵 B 满足：$r(B)=\nu-1$</strong>；</p><p><strong>定理2：有向连通图 G 的基本关联矩阵 $B_k$ 满足：$r(B_k)=\nu-1$</strong>；</p><p>推论：n个结点树 T 的基本关联矩阵的秩为 $\nu-1$；</p><p><strong>定理3：有向连通图 G 如果存在回路 C，则 C 中各边所对应基本关联矩阵 $B_k$ 的各列线性相关</strong>；</p><p><strong>定理4：有向连通图 G 的基本关联矩阵 $B_k$，有：$B_k任意n-1阶子式M_{n-1}\ne0\Longleftrightarrow M_{n-1}各列对应边构成G的一棵生成树$</strong>；</p><p>定理4说明了<strong>可以由 $B_k$ 的非零 n-1 阶子式的数目来代表 $G$ 生成树的数目<a href="#genTCount">🔗</a></strong>；</p></blockquote></li><li><p>回路矩阵和割集矩阵；</p><blockquote><p>不说了亲，这边建议您好好复习电路理论课呢:sweat_smile:</p></blockquote></li><li><p>Huffman树（最优二叉树），详见“数据结构复习-第二部分”；</p></li></ul><h3 id="9-8-图的经典算法"><a href="#9-8-图的经典算法" class="headerlink" title="9.8 图的经典算法"></a>9.8 图的经典算法</h3><h4 id="9-8-1-图的遍历算法"><a href="#9-8-1-图的遍历算法" class="headerlink" title="9.8.1 图的遍历算法"></a>9.8.1 图的遍历算法</h4><ul><li><p>DFS 算法：类似树的前序遍历</p><p>邻接表存储 $O(|V|+|E|)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>(<span class="type">int</span> start, <span class="type">bool</span> visited[]) <span class="type">const</span> &#123;</span><br><span class="line">    eNode* curEdge = vertices[start].edge;</span><br><span class="line">    std::cout &lt;&lt; vertices[start].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[curEdge-&gt;end]) <span class="built_in">dfs</span>(curEdge-&gt;end, visited);</span><br><span class="line">        curEdge = curEdge-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs_nonRecur</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; tasks;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// Necessary when doing non-recursive op.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            eNode* curEdge = vertices[tmp].edge;</span><br><span class="line">            <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[curEdge-&gt;end])</span><br><span class="line">                    tasks.<span class="built_in">push</span>(curEdge-&gt;end);</span><br><span class="line">                curEdge = curEdge-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻接矩阵存储 $O(|V|^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>(<span class="type">int</span> start, <span class="type">bool</span> visited[]) <span class="type">const</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; vertices[start] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i] &amp;&amp; edges[start][i] != noEdgeFlag)</span><br><span class="line">            <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs_nonRecur</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; tasks;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;</span><br><span class="line">            std::cout &lt;&lt; vertices[tmp] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tmp + <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; edges[tmp][j] != noEdgeFlag)</span><br><span class="line">                    tasks.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BFS 算法：类似树的层次遍历</p><p>邻接表存储 $O(|V|+|E|)$ </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">bfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; taskQ;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        taskQ.<span class="built_in">enQueue</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!taskQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = taskQ.<span class="built_in">deQueue</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// necessary.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            eNode* curEdge = vertices[tmp].edge;</span><br><span class="line">            <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[curEdge-&gt;end])</span><br><span class="line">                    taskQ.<span class="built_in">enQueue</span>(curEdge-&gt;end);</span><br><span class="line">                curEdge = curEdge-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻接矩阵存储 $O(|V|^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">bfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; taskQ;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        taskQ.<span class="built_in">enQueue</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!taskQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = taskQ.<span class="built_in">deQueue</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// necessary when doing no-recursive op.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tmp + <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; edges[tmp][j] != noEdgeFlag)</span><br><span class="line">                    taskQ.<span class="built_in">enQueue</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-8-2-两点间道路判定算法"><a href="#9-8-2-两点间道路判定算法" class="headerlink" title="9.8.2 两点间道路判定算法"></a>9.8.2 两点间道路判定算法</h4><blockquote><p>这里介绍邻接矩阵表示的算法，比较常见；</p></blockquote><ul><li><p>引入：对于一个<strong>非加权图的邻接矩阵（0&amp;1）</strong>，有 $P=(p_{ij})_{n\times n}=\sum\limits_{k=1}^n{A^k}$，则 $p_{ij}$ 为从 $v_i$ 到 $v_j$ 的<strong>道路数</strong>；实际问题只关心<strong>是否有道路</strong>，所以可以改成逻辑运算提升速度：$P=(p_{ij})_{n\times n}=\bigvee\limits_{k=1}^n{A^k}$，时间复杂度 $O(\nu^4)$；</p></li><li><p>Warshell算法 $O(\nu^3)$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P &lt;- A</span><br><span class="line">for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">    for (int j = 1; j &lt;= n; ++j)</span><br><span class="line">        for (int k = 1; k &lt;= n; ++k)</span><br><span class="line">            p_&#123;jk&#125; &lt;- p_&#123;jk&#125; V (p_&#123;ji&#125; Λ p_&#123;ik&#125;)</span><br></pre></td></tr></table></figure></li><li><p>DFS 和 BFS $O(\varepsilon)$：和图的遍历不一样的是，它比图的遍历更简单，只需从一个点出发（减少最外层循环），用visited数组和BFS/DFS整体寻找，如果遇到终点即停止并返回true，否则返回false；</p></li></ul><h4 id="9-8-3-有向图强连通分支判断算法"><a href="#9-8-3-有向图强连通分支判断算法" class="headerlink" title="9.8.3 有向图强连通分支判断算法"></a>9.8.3 有向图强连通分支判断算法</h4><blockquote><p>思路：先从图 G 任一点开始 DFS，如果 G 不是强连通图，则可能得到一个深度优先生成森林；对森林中的每棵树按照<strong>生成次序</strong>依此进行<strong>后序遍历</strong>，并按遍历顺序给每个结点编号（从小到大）；</p><p>然后使 G 的每条边逆向，得到 Gr，再从 Gr 编号最大的结点开始 DFS，得到新的深度优先遍历森林中的<strong>每一棵树</strong>就是 G 的一个强连通分量；</p></blockquote><h4 id="9-8-4-欧拉回路的构造算法"><a href="#9-8-4-欧拉回路的构造算法" class="headerlink" title="9.8.4 欧拉回路的构造算法"></a>9.8.4 欧拉回路的构造算法</h4><blockquote><p>欧拉回路有明确的、好判断的充要条件，所以算法设计相对容易；</p><p>无论啥算法，最好先利用充要条件排除没有欧拉回路的图，能大大提高时间性能；</p><p>下面讨论<strong>如果有欧拉回路，应该怎么找</strong>的算法：</p></blockquote><ul><li>拼接法：DFS寻找回路（经过即删除），如果回路结束却仍然有未遍历的结点，则从新的未访问的结点开始遍历回路，<strong>并拼接（“8”字原理）</strong>，循环直到所有边已被访问；</li><li>Floyd算法（非割边优先遍历）</li></ul><h4 id="9-8-5-欧拉回路的应用：中国邮递员问题（CPP）"><a href="#9-8-5-欧拉回路的应用：中国邮递员问题（CPP）" class="headerlink" title="9.8.5 欧拉回路的应用：中国邮递员问题（CPP）"></a>9.8.5 欧拉回路的应用：中国邮递员问题（CPP）</h4><blockquote><p>中国邮递员问题：<strong>走遍图中的所有边</strong>后返回返回起点，要求<strong>总路程最短</strong>；</p></blockquote><ul><li><p>对于无向图 G 的结论</p><ul><li><p>如果 G 中所有结点个数都是偶数：该图的任一欧拉回路都是解；</p></li><li><p>如果 G 中有且仅有 2 个奇点 $v_i\space和\space v_j$：找到 G 从  $v_i$ 到 $v_j$ <strong>欧拉道路 $E_{ij}$</strong>，再找从  $v_j$ 到 $v_i$ 的<strong>最短路径 $P_{ji}$</strong>，则回路 <strong>$E_{ij}+P_{ji}$</strong> 就是问题的解；</p></li><li><p>如果 G 中有两个以上，共2k个奇点（由前面图的性质推论，奇点必有偶数个）：</p><script type="math/tex; mode=display">图G有最佳邮路L\Longleftrightarrow\begin{equation}\left\{\begin{aligned}&1.\space L的任一边最多重复一次\\&2.\space对G中的任一回路C，L中在C上重复边的长度之和\\&\quad不超过C总长的一半\space(C必须包含所有重边)\\\end{aligned}\right.\end{equation}</script><p><strong>实际做法是：找出所有奇点，两两配对并依此为奇点间添加重复边（长度和原边相等），为它们配对成偶点，得到新图，也即邮路 $L_x$；再检查 $L_x$ 是否满足以上两个条件；如果违反第一条则一次性删除两条多余重边，如果违反第二条则将 $L_x$ 的该段道路改成与 $C$ 互补的道路</strong>；</p></li></ul></li></ul><h4 id="9-8-6-H-回路的应用：旅行商问题（TSP）"><a href="#9-8-6-H-回路的应用：旅行商问题（TSP）" class="headerlink" title="9.8.6 H 回路的应用：旅行商问题（TSP）"></a>9.8.6 H 回路的应用：旅行商问题（TSP）</h4><ul><li>问题描述：给定一个正权完全图，求总权最小的 H 回路；</li></ul><blockquote><p>NP 完全问题，只能寻找近似解；这里不介绍算法，仅介绍问题；提示：不建议使用贪心法，误差很大；</p></blockquote><h4 id="9-8-7-有向无环图、AOV网与拓扑排序"><a href="#9-8-7-有向无环图、AOV网与拓扑排序" class="headerlink" title="9.8.7 有向无环图、AOV网与拓扑排序"></a>9.8.7 有向无环图、AOV网与拓扑排序</h4><ul><li><p>有向无环图（DAG）：不存在回路的有向图称为<strong>有向无环图</strong>；</p></li><li><p>AOV网：<strong>有向无环图</strong>中的顶点表示活动，边表示活动间的先后关系，这样的图称为<strong>AOV网</strong>；</p></li><li><p>拓扑排序：将AOV网中的活动发生的先后次序排成一个序列（如果有一条从 u 到 v 的道路，那么 v 必须出现在 u 之后），称为<strong>拓扑排序</strong>，这个序列称为<strong>拓扑序列</strong>；</p></li><li><p>拓扑排序实现思路：类似于图的 BFS，但是<strong>只有一个结点的所有直接前驱结点都已访问后，才能访问这个结点</strong>；<strong>$O(|V|+|E|)$</strong></p><ol><li><p>计算每个结点的入度，保存在数组中；</p></li><li><p>检查入度数组中<strong>入度为零（无依赖）</strong>的对应结点索引，并将其入队；</p></li><li><p>当队伍非空时，循环出队并输出这个结点，在假设将这个结点删除，修正这个结点的所有直接结点的入度（减1），如此重复2、3步骤；</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请自行实现私有函数 int _getInDegree(int) 获取入度；</span></span><br><span class="line"><span class="comment">// 使用到了之前的seqQueue类；</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span>* adjListGraph&lt;VType, EType&gt;::<span class="built_in">topoSortIdx</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ans = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;; <span class="type">int</span> ansIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* inDegrees = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; preRequests;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        inDegrees[i] = _getInDegree(i);</span><br><span class="line">        <span class="keyword">if</span> (!inDegrees[i]) preRequests.<span class="built_in">enQueue</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!preRequests.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = preRequests.<span class="built_in">deQueue</span>();</span><br><span class="line">        ans[ansIdx++] = cur;</span><br><span class="line">        eNode* curEdge = vertices[cur].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--inDegrees[curEdge-&gt;end] == <span class="number">0</span>)</span><br><span class="line">                preRequests.<span class="built_in">enQueue</span>(curEdge-&gt;end);</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[i]) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR] A non-DAG does not support topoSort().&quot;</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] ans; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">topoSort</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* seq = <span class="built_in">topoSortIdx</span>();</span><br><span class="line">    <span class="keyword">if</span> (!seq) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        std::cout &lt;&lt; vertices[seq[i]].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-8-8-AOE网与关键路径"><a href="#9-8-8-AOE网与关键路径" class="headerlink" title="9.8.8 AOE网与关键路径"></a>9.8.8 AOE网与关键路径</h4><ul><li><p>AOE网络：活动定义在边上（持续时间），事件定义在顶点上；</p></li><li><p>AOE网络的重要两点：源点（入度为0，工程“起点”）、汇点（出度为0，工程“终点”）；</p></li><li><p>AOE网络解决的问题：完成整项任务的最少时间、哪些活动是影响工程进度的关键;</p></li><li><p>关键路径：从源点到汇点的<strong>最长</strong>路径称为<strong>关键路径</strong>；</p></li><li><p>关键活动：关键路径上的活动。<strong>推迟关键活动必定影响项目进度</strong>；</p></li><li><p>最早发生时间：用“从源点到该结点的<strong>最长路径</strong>”（因为和拓扑排序一样，只有该结点的所有直接前驱结点都访问过后，才能算访问了这个结点）表征；</p></li><li><p>最迟发生时间：用“关键路径长(定值) - 从汇点到该结点的<strong>最短路径</strong>”表征（因为是最迟，距离汇点最近才符合定义）；</p></li><li><p>时间余量：最迟发生时间 - 最早发生时间。<strong>时间余量为0的活动是关键活动（第二定义）</strong>；</p></li><li><p>找关键路径的思路：（用第二定义）<strong>就是找每个顶点的最早、最迟发生时间，进而得到关键活动、关键路径</strong>；</p><ol><li><p>找出AOE网的任一拓扑序列；</p></li><li><p>从头至尾遍历一次拓扑序列，在遍历到 u 时，更新它的<strong>所有</strong>直接后继结点 v 的最早发生时间（如果当前ee值＜u 的值+路径长，那么更新v的ee值为更大的）；</p></li><li><p>再从尾至头遍历一次拓扑序列，在遍历到 u 时，更新它的<strong>所有</strong>直接后继结点 v 的最迟发生时间（如果后继结点le值＜v 的值+路径长，那么更新为u为更小的）；</p><blockquote><p>别问为啥不和第二步相对应，找直接前驱结点，问就是找前驱结点复杂度太大了；</p><p>⚠<strong>记得更新最迟发生时间之前，要用第二步得到的关键路径长度（就是拓扑序列最后一个结点的ee值）填充最迟发生时间数组</strong>；</p></blockquote></li><li><p>找出所有“最早发生时间=最迟发生时间”的结点，按照拓扑序列的顺序依此输出，即为关键路径；</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">criticalPath</span>(<span class="type">int</span>* early, <span class="type">int</span>* late) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* topoSeq = <span class="built_in">topoSortIdx</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) early[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        eNode* curEdge = vertices[topoSeq[i]].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (early[topoSeq[i]] + curEdge-&gt;weight &gt; early[curEdge-&gt;end])</span><br><span class="line">                early[curEdge-&gt;end] = early[topoSeq[i]] + curEdge-&gt;weight;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pLen = early[topoSeq[<span class="keyword">this</span>-&gt;vertixNum - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) late[i] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">this</span>-&gt;vertixNum - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        eNode* curEdge = vertices[topoSeq[i]].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (late[topoSeq[i]] &gt; late[curEdge-&gt;end] - curEdge-&gt;weight)</span><br><span class="line">                late[topoSeq[i]] = late[curEdge-&gt;end] - curEdge-&gt;weight;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">criticalPath</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ee = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="type">int</span>* le = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="type">int</span> pathLen = <span class="built_in">criticalPath</span>(ee, le);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[INFO] The length of the critical path: &quot;</span> &lt;&lt; pathLen &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[INFO] The critical path: \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ee[i] == le[i]) std::cout &lt;&lt; vertices[i].data &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[Fin]\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-8-9-生成树的计数算法"><a href="#9-8-9-生成树的计数算法" class="headerlink" title="9.8.9 生成树的计数算法"></a>9.8.9 生成树的计数算法</h4><blockquote><p>原理：Binet-Cauchy 定理：两个矩阵 $A_{m\times n},\space B_{n\times m}\space(m\le n)$，则 $det(AB)=\sum\limits_i{A_iB_i}$ 。其中$A_i$、$B_i$ 分别是从 $A$ 中任取 $m$ 列、$B$ 中任取 $m$ 行构成的行列式；</p><p>虽然这样计算行列式有些麻烦，但它揭示了乘积矩阵行列式和各矩阵的子式之间的关系；</p><p><span id="genTCount"><strong>定理1：（有向连通图的普通生成树计数）设 $B_k$ 为有向连通图 $G=(V,E)$ 的某一基本关联矩阵，则 $G$ 中不同树的数目为 $det(B_kB_k^T)$</strong>；</span></p><ul><li>解题提示：如果要求<strong>不含</strong>某个边的生成树数目，只要求将该边删去后的生成子图对应生成树的数目；如果要求<strong>必含</strong>某个边的生成树数目，只要该边的起点终点合并为一点，求新图对应生成树的数目；</li></ul><p><strong>如果想求无向连通图的生成树个数，需要将其每条边指定一个任意方向转化为有向连通图</strong>；</p><ul><li><p>推论证明：求证<strong>完全图 $K_n$ 的不同生成树的数目为 $n^{n-2}$</strong>；</p><script type="math/tex; mode=display">det(B_kB_k^T)=\begin{vmatrix}n-1&-1&\cdots&-1\\-1&n-1&\cdots&-1\\\vdots&\vdots&\ddots&\vdots\\-1&-1&\cdots&n-1\end{vmatrix}=n^{n-2}</script></li><li><p>⚠易错警示：如果是求<strong>完全图 $K_n$ 不同构的生成树的数目</strong>，和<strong>“不同生成树”</strong>不一样！和化学上<strong>求同分异构体的做法类似</strong>；例如 $K_5$ 的不同构生成树数目为 3，对应有机化学戊烷的正戊烷、异戊烷、新戊烷的构型；</p></li></ul><p><strong>定理2：（有向连通图的根树生成树计数）设 $\overrightarrow{B_k}$ 表示将有向连通图 $G$ 的<u>关于结点 k 的</u>关联矩阵 $B_k$ 中所有的 1 元素换成 0 之后的矩阵，则 $G$ 中<u>以 k 为根的</u>不同根树数目为 $det(\overrightarrow{B_k}B_k^T)$</strong>；</p><ul><li>解题提示：如果要求<strong>不含</strong>某个边的根树生成树数目，删去这个边再算；</li><li>⚠易错警示：和普通生成树不同，如果要求<strong>必含</strong>某个边的根树生成树数目，需要先计算以 v0 为根的总根树数目，再减去不含这个边的生成树数目；<strong>或者求 $G^\prime=G-\{(t,v)|t\ne u\}$</strong> 的根树生成树数目；</li></ul></blockquote><h4 id="9-8-10-生成树的生成算法"><a href="#9-8-10-生成树的生成算法" class="headerlink" title="9.8.10 生成树的生成算法"></a>9.8.10 生成树的生成算法</h4><blockquote><p>不作介绍，有兴趣请查阅相关资料，例如《图论与代数结构》清华大学出版社 第3章 3.5节 支撑树的生成；</p></blockquote><h4 id="9-8-11-最小生成树算法"><a href="#9-8-11-最小生成树算法" class="headerlink" title="9.8.11 最小生成树算法"></a>9.8.11 最小生成树算法</h4><ul><li><p>Kruskal 算法</p><blockquote><p>思路：不断向初始化为空的根结点中加入当前未加入过的最短边，如果构成回路，一定是回路中的最长边，删除它；如果不构成回路则继续，直至达到 n-1 条边为止，此时 T 一定不含任何回路、n-1条边、包含所有图的顶点、所有权最小，在贪心法上是最小生成树；</p><p><strong>如何证明这个贪心算法的正确性？</strong></p><p>可以证明定理：$T=(V,E’)$ 是赋权连通图 $G=(V,E)$ 的最短树，当且仅当对任意的余树边 $e\in E-E’$，回路 $C^e(C^e\subseteq E’+e)$ 满足：其边权 $w(e)\ge w(a),\space a\in C^e\space(a\ne e)$；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T &lt;- Φ    // 树根结点初始化为空</span><br><span class="line">while (|T| &lt; n - 1 &amp;&amp; E(G) != Φ) &#123;</span><br><span class="line">    e &lt;- E中最短边</span><br><span class="line">    E &lt;- E - e</span><br><span class="line">    if (T + e 无回路) T &lt;- T + e</span><br><span class="line">&#125;</span><br><span class="line">if (|T| &lt; n - 1) 输出非连通的信息</span><br><span class="line">else return T</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(\varepsilon+p\space log\space\varepsilon),\space其中p为迭代次数$；适用于稀疏图（当p不大时）；</p></li><li><p>Prim 算法</p><blockquote><p>思路：在结点集中任选一个结点 v0 构成集合 V’，从 V 和 V-V’ 中各选一个顶点 u（来自V）、v（来自V-V’）使得 (u, v) 是满足条件的u、v中最短的边，将此边加入树 T，令 V’+=u，直至 V’=V；</p><p>感兴趣可以找一找定理的正确性证明；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t &lt;- v0, T &lt;- Φ, U &lt;- &#123;t&#125;</span><br><span class="line">while (U != V) &#123;</span><br><span class="line">    w(t, u) = min&#123;w(t, v)&#125; where v in (V - U)</span><br><span class="line">    T &lt;- T + e(t, u)</span><br><span class="line">    U &lt;- U + u</span><br><span class="line">    for (v in V - U) w(t, v) &lt;- min&#123;w(t, v), w(u, v)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(\nu^2)$；适用于稠密图；</p></li></ul><h4 id="9-8-12-最短路径算法"><a href="#9-8-12-最短路径算法" class="headerlink" title="9.8.12 最短路径算法"></a>9.8.12 最短路径算法</h4><p>正在更新中……———————————————————————</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;&lt;u&gt;本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充&lt;/u&gt;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: 张同珍老师 PPT | UNIkeEN&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="review" scheme="https://sjtuxhw.top/categories/review/"/>
    
    
    <category term="Data-Structure" scheme="https://sjtuxhw.top/tags/Data-Structure/"/>
    
    <category term="Discrete-Math" scheme="https://sjtuxhw.top/tags/Discrete-Math/"/>
    
    <category term="External-Search" scheme="https://sjtuxhw.top/tags/External-Search/"/>
    
    <category term="B+Tree" scheme="https://sjtuxhw.top/tags/B-Tree/"/>
    
    <category term="Graph" scheme="https://sjtuxhw.top/tags/Graph/"/>
    
  </entry>
  
</feed>
