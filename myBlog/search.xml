<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Algorithms in AI</title>
      <link href="//technical/algo-in-ai/"/>
      <url>//technical/algo-in-ai/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-0-Intro"><a href="#Chapter-0-Intro" class="headerlink" title="Chapter 0. Intro"></a>Chapter 0. Intro</h1><h2 id="0-1-The-definition-of-Artificial-Intelligence"><a href="#0-1-The-definition-of-Artificial-Intelligence" class="headerlink" title="0.1 The definition of Artificial Intelligence"></a>0.1 The definition of Artificial Intelligence</h2><ul><li><p>Think rationally -&gt; Think like people -&gt; Act like people -&gt; <strong>Act rationally</strong>.</p><blockquote><p>The system <strong>maximumly achieving predefined goals</strong>.</p><p>-&gt; <strong>Maximize the expected utility.</strong> (最大化预期效用)</p></blockquote></li><li><p>Brains and AI</p><ul><li><p>Why not reverse engineering the brains? -&gt; Not as modular as software.</p></li><li><p>But there are the lessons <strong>learned from the brain</strong> (interleave, 交织在一起):</p><ul><li><p><strong>Memory (data): Judge situations depending on the previous experiences (statistics)</strong>.</p><blockquote><p>e.g., Bayes’ nets, Decision theory, <strong>Machine learning</strong>,…</p></blockquote></li><li><p><strong>Simulation (computation): Predict the future depending on the models</strong>.</p><blockquote><p>e.g., Search, Satisfying constraints, Adversarial and uncertain search,… (<strong>Algorithms</strong>)</p></blockquote></li></ul></li></ul></li></ul><h2 id="0-2-The-History-of-AI"><a href="#0-2-The-History-of-AI" class="headerlink" title="0.2 The History of AI"></a>0.2 The History of AI</h2><h2 id="0-3-The-Applications-of-AI"><a href="#0-3-The-Applications-of-AI" class="headerlink" title="0.3 The Applications of AI"></a>0.3 The Applications of AI</h2><ul><li><strong>Natural language</strong>: speech technology (+context), language processing technologies (Q&amp;A / translation / web search …);</li><li><p><strong>Computer vision</strong> (perception)</p></li><li><p><strong>Game playing</strong>;</p></li><li><strong>Logic</strong>: Theorems provers, NASA fault diagnosis, …</li></ul><h2 id="0-4-Designing-Rational-Agents"><a href="#0-4-Designing-Rational-Agents" class="headerlink" title="0.4 Designing Rational Agents"></a>0.4 Designing Rational Agents</h2><ul><li>Agent: An agent is an entity that perceives and acts.</li><li><strong>Environment -&gt; sensors of an agent -&gt; agent functions -&gt; actuators -&gt; effect on environment</strong>.</li></ul><h1 id="Chapter-1-Search"><a href="#Chapter-1-Search" class="headerlink" title="Chapter 1. Search"></a>Chapter 1. Search</h1><blockquote><p>Discuss agents that <strong>plan ahead</strong> rather than just react to a current situation.</p><p><strong>将现实问题 formalize 为数学问题，并使用算法模拟搜索求解</strong>。</p></blockquote><h2 id="1-1-Reflex-Agents"><a href="#1-1-Reflex-Agents" class="headerlink" title="1.1 Reflex Agents"></a>1.1 Reflex Agents</h2><ul><li><p>They have a current percept, <strong>and maybe make decision based on these memory but <u>without consideration of the consequences of their actions</u>.</strong></p><blockquote><p>仅根据当前状态，直接进行当前最优动作；</p><p>例如，根据当前 successor 的结果谁更接近 goal 就进行什么操作。</p></blockquote></li><li><p>类似贪心算法，有时 rational，但有时并不是；</p></li></ul><h2 id="1-2-Planing-Agents"><a href="#1-2-Planing-Agents" class="headerlink" title="1.2 Planing Agents"></a>1.2 Planing Agents</h2><ul><li><p>They have the model of what the world works, and the goals. <strong>根据一系列动作，结合模型假设后果，并根据后果和目标的关系来决定是否进行这个操作</strong>。</p><blockquote><p>实现 1 (master-mind)：先遍历查找动作序列，再行动（时间花费很大）；</p><p>实现 2 (re-planning)：先遍历最近的动作序列，行动，然后再遍历下一段的动作序列，再行动，以此往复（类似结合了贪心法的动态规划）；</p></blockquote></li><li><p>Optimal Planning（最优计划） &amp; Complete Planning（能解决问题的存在性计划）</p></li></ul><h2 id="1-3-Search-Problem（Uninformed-Search）"><a href="#1-3-Search-Problem（Uninformed-Search）" class="headerlink" title="1.3 Search Problem（Uninformed Search）"></a>1.3 Search Problem（Uninformed Search）</h2><h3 id="1-3-1-Definitions"><a href="#1-3-1-Definitions" class="headerlink" title="1.3.1 Definitions"></a>1.3.1 Definitions</h3><blockquote><p>什么是计算机中的搜索问题？</p></blockquote><ul><li><p>一个搜索问题包含：</p><ul><li><p>状态空间（a state space，存放环境信息）；</p></li><li><p>后继函数（a successor function，包含动作、动作开销）；</p><blockquote><p><strong>有哪些可行的动作？动作执行后的结果状态如何？——这个函数编码了 “how the world works”</strong></p></blockquote></li><li><p>初始状态（a start state）和目标检查（a goal test）；</p></li></ul></li><li><p>搜索问题的解：<strong>就是一个从初始状态到目标状态的动作序列（a sequence of actions / a plan）</strong>.</p></li></ul><blockquote><p><strong>以上可以称为搜索问题的模板，可以看作接口（interface）</strong>，这意味着我们可以将现实生活中的问题抽象到上面的模板中（casting to search problem），再对照模板设计算法，就能解决实际问题。</p></blockquote><h3 id="1-3-2-Examples"><a href="#1-3-2-Examples" class="headerlink" title="1.3.2 Examples"></a>1.3.2 Examples</h3><blockquote><p>搜索问题本质上是一个模型。举例：</p></blockquote><ul><li>城市导航路线图<ul><li>state space: cities;</li><li>successor function: roads (go to adjacent cities with <strong>cost (可以是距离、交通情况等)</strong>);</li><li>start state: 位于起点的状态；</li><li>goal test: <strong>当前状态是否是位于终点的状态</strong>；</li><li>solution: 有向路径；</li></ul></li><li>pac-man 游戏（目标是走到指定位置）<ul><li>state space: (x, y) 实体的位置信息；action: NSEW；successor function: <strong>update location only</strong>；goal test: 是否有 (x,y)==DESTINATION；</li></ul></li><li>pac-man 游戏（目标是吃完所有豆子）<ul><li>state space: (x, y) 位置 + 是否有食物的布尔值；action: NSEW；successor function: <strong>更新位置和食物情况</strong>；goal test: 是否有所有食物布尔值都为 false；</li></ul></li></ul><h3 id="1-3-3-Mathematical-amp-Algorithmic-Representation"><a href="#1-3-3-Mathematical-amp-Algorithmic-Representation" class="headerlink" title="1.3.3 Mathematical &amp; Algorithmic Representation"></a>1.3.3 Mathematical &amp; Algorithmic Representation</h3><ul><li><p><strong>搜索问题的数学表示：状态图和搜索树</strong>（state space graphs &amp; search tree）</p><ul><li><strong>它们一般过于庞大，画不出来，只需要有这样的概念就行</strong>；</li><li>搜索树结点数一般远大于状态图，因为<strong>搜索树中可以有多个结点代表同一个状态</strong>；</li></ul></li><li><p>搜索树（General Tree Search）解决 <strong>等权 / 非等权搜索问题</strong></p><blockquote><p>本部分就是数据结构中图的相关算法。涉及解决<strong>等权图最短路</strong>、<strong>非等正权图最短路</strong>等问题的经典算法。但<strong>有所不同，因为是 Tree Search，所以不会记录 visited 结点——意味着会重复搜索（具体会在 1.5 中进行阐释和改进）</strong>；</p></blockquote><ul><li><p>Important Ideas:</p><ul><li><strong>Fringe (原义条纹 / 边缘，这里指的是 a set of leaf nodes that are waiting to be expanded，通常是存放等待处理的数据结点的结构，可以是栈、队列等)</strong>;</li><li>Expansion (查找过程中再向树中插入合法结点);</li><li>Exploration strategy (<strong>DFS / BFS / Uniform Cost Search</strong>)</li></ul></li><li><p>Pseudo Code:</p><p><img src="imgs/tree_search_pseudo_code.png"></p></li></ul></li><li><p>Search Algorithm Properties of General Tree Search（<strong>针对所有 “利用搜索树” 解决搜索问题的算法</strong>）</p><ul><li><p><strong>如果 expansion strategy 算法是 DFS</strong>：</p><ul><li>实现方式：<strong>栈</strong>；</li><li>时间复杂度为 $O(b^m)$，b 为每个结点的后继结点数量级，m 为搜索树中最大深度的数量级；空间复杂度为 $O(b\cdot m)$；</li><li><strong>算法是 complete 的（如果对于无限树，且存在解，则能够找到至少一个解）</strong>；</li><li><strong>算法不是 optimal 的（DFS 无法自动找到最优解，除非你一直找，再手动比较）</strong>；</li></ul></li><li><p><strong>如果算法是 BFS</strong>：</p><ul><li>实现方式：<strong>队列</strong>；</li><li>时间复杂度为 $O(b^s)$，b 为每个结点的后继结点数量级，s 为搜索到最近的 goal state 所在层数的数量级；空间复杂度也是 $O(b^s)$;</li><li><strong>算法是 complete 的</strong>（不遍历结束、得出结果，则不会退出）；</li><li><strong>如果 cost 是相等的——即等权图，则算法是 optimal 的，因为按照层级（tier）从近处向远处找</strong>；</li></ul></li><li><p>综合上面特点发现，DFS 空间性能更好，但 BFS 能够找到等权情况下的最短路；<strong>那么我们有没有一种算法综合它们的优点呢？有的！它就是 Iterative Deepening</strong>；</p><blockquote><p><strong>Iterative Deepening（迭代深搜）</strong>利用了 DFS 空间优势。在搜索开始后，先执行 DFS，<strong>以 depth=1 和 goal 为终止条件</strong>，如果找到，就结束；否则证明 depth=1 的深度无解，将 depth 结束条件放宽至 depth=2，继续 DFS，以此类推。</p><p>这就将 DFS 和 BFS 的优势结合了起来。</p><p>不用担心每次都把前几层重复检查，因为理论上搜索树每层结点指数增长，下一层结点数往往远大于前几层结点数之和，所以重复检查的部分微不足道。</p></blockquote></li><li><p>Uniform Cost Search（UCS，一致代价搜索） 解决 <strong>Cost-sensitive Search（非等权搜索问题）</strong></p><ul><li>实现方式：<strong>优先级队列</strong>；</li><li>时间复杂度 $O(b^{C^*/\varepsilon})$，b 为每个结点后继结点数量级，C* 为解的 cost 数量级，ε 为各个结点间（每一步）的最小 cost 数量级；空间复杂度与时间相同； </li><li>此算法借鉴了 BFS 的思路，在 expansion 的时候选取 cost 最小的；</li><li><strong>算法在<u>最小权为正数</u>的情况下是 complete 和 optimal 的</strong>。</li><li>优点很好，但缺点也很严重——<strong>一般情况下开销极大，因为遍历了一个正权下的所有状态结点</strong>（可以通过 goal 的信息进行优化，后面介绍，就是 <strong>informed search</strong>）；</li></ul></li></ul></li></ul><h2 id="1-4-Informed-Search"><a href="#1-4-Informed-Search" class="headerlink" title="1.4 Informed Search"></a>1.4 Informed Search</h2><blockquote><p>搜索问题的定义是相同的，只不过 informed search（有提示搜索）的 <strong>expanding strategy</strong> 会考虑到距离 goal 的远近程度（在 uninformed search 的基础上进行改进）而已。</p><p>所以下面仅比较不同的 expanding strategy。</p></blockquote><h3 id="1-4-1-Search-Heuristics"><a href="#1-4-1-Search-Heuristics" class="headerlink" title="1.4.1 Search Heuristics"></a>1.4.1 Search Heuristics</h3><blockquote><p>启发式搜索，<strong>即启发函数</strong>，是后面 informed search 算法的基础。</p></blockquote><ul><li><p>The definition for a heuristic</p><ul><li><p>A function that estimates <strong>how close a state is to a goal</strong>.</p></li><li><p>Designed for a particular search problem （<strong>因为距离判断因问题而异</strong>）；</p><blockquote><p>可以是 Manhattan distance，Euclidean distance……（for pathing）</p></blockquote></li></ul></li><li><p>Examples</p><ul><li>The pac-man game（去往特定的有食物的地点）：“距离”（heuristic function）可以是与终点的欧式距离、曼哈顿距离（因为上下左右移动）；</li><li>The pancake problem（完成从上到下饼依此增大的排列）：heuristics function 可以是<strong>位置正确的煎饼个数</strong>、<strong>位置不正确的最大煎饼编号（因为和汉诺塔类似，势必要先把最大煎饼先挪到底层）</strong>；</li></ul><blockquote><p>具体选择哪种 heuristic function，<strong>可以举几种固定情况（例如画一部分状态图），看谁的 heuristic function 的值在接近 goal 时表现更好</strong>。</p></blockquote></li></ul><h3 id="1-4-2-Expanding-Strategy-Greedy-Search（贪婪法）"><a href="#1-4-2-Expanding-Strategy-Greedy-Search（贪婪法）" class="headerlink" title="1.4.2 Expanding Strategy: Greedy Search（贪婪法）"></a>1.4.2 Expanding Strategy: <strong>Greedy Search（贪婪法）</strong></h3><ul><li>思路：选择 fringe 中 heuristic function 最接近 goal 的结点进行 expand；</li><li>优点：在某些情况下搜索非常迅速，并且开销很小；</li><li>缺陷：局部最优解不一定是全局最优解，即贪婪法不一定是正确的（<strong>算法不一定是 optimal 的</strong>），最坏情况是 <strong>badly-guided DFS</strong>，尤其是当 heuristics function 没选好的时候；</li></ul><h3 id="1-4-3-Expanding-Strategy-A-Search（A-搜索）"><a href="#1-4-3-Expanding-Strategy-A-Search（A-搜索）" class="headerlink" title="1.4.3 Expanding Strategy: A* Search（A* 搜索）"></a>1.4.3 Expanding Strategy: <strong>A* Search（A* 搜索）</strong></h3><blockquote><p>理解 A star Search 前，先以龟兔赛跑的寓言故事（fable）作比：<strong>Uniform Cost Search (uninformed)</strong> 就像 tortoise，虽然缓慢，但会搜索到同一权重下的所有状态情况，如果有的话确保一定找到最优解；<strong>Greedy Search</strong> 就像 hare，非常迅速，但容易走错方向，找不到最优解。</p><p><strong>所以 A star search 相当于是坐在乌龟上的兔子，既结合了 Uniform Cost Search 的稳妥，又具有 Greedy Search 部分的借助 heuristic function 迅速搜索的特点</strong>。现在看看是如何实现的：</p></blockquote><p>以一个例子来阐释：</p><p><img src="imgs/AStar.png" height="275"></p><p>对于这个正权有向图而言，Uniform Cost Search 的 expanding strategy 是按照<strong>当前步的累计 cost（理解为“深度”）<code>g(n)</code> 来评定的</strong>，而 Greedy Search 的 heuristic function 是按照<strong>距离 goal 的加权路径距离和 <code>h(n)</code> 来评定的</strong>。将 <strong>这两个标准相加得到 A* 的评价标准 <code>f(n)</code></strong>，这样既考虑到了下一步的 cost，又考虑到了距离终点的相对位置，达到了一个较好的效果。</p><blockquote><p>因为如果仅仅是 Uniform cost search，则要搜索 6 个结点才能找到 optimal solution；仅用 Greedy Search 只能找到非 optimal 的解；而用 A-star search 只需搜索 4 个结点就找到了 optimal solution.</p><p>有同学可能会问，为什么上面图中 <code>e</code> 结点的 h = 1 而不是 2？因为这和 heuristic function 的取法有关系。这里可能不是到达终点的路径长度和，而是直线距离。</p><p>思考：为什么只能在结点出队的时候才能检查它是不是 goal 然后再结束？进队的时候不行吗？</p><p>答案：不行。进队的时候，没法保证该结点一定比 fringe 内其他所有结点都要优；</p></blockquote><ul><li><p><strong>A* 算法不一定是 optimal 的</strong>，因为可以举出反例：</p><p><img src="imgs/AStar_counterExample.png" height="200px"></p><p>上面的反例可以看出，<strong>如果 heuristic function 函数没有选好，选的过于 pessimistic，那么很有可能会误导 agent，导致正确的 optimal solution 迟迟无法出队</strong>，这就是 A* 不一定 optimal 的原因——<strong>heuristic function 选取失误</strong>。</p></li><li><p>为了减少以上情况的出现，即优化这个算法，我们引入 <strong>Admissibility</strong> 来评价一个 heuristic function：</p><ul><li><p>如果 heuristic function 在<strong>任意</strong>结点的值 $h(n)$ 小于等于实际到 optimal solution 的加权路径长度 $h^<em>(n)$（<strong>我们在不知道结果前时无法得知，但它数学上客观存在</strong>），那么称为 <strong>optimistic heuristic function</strong>，这样的 A\</em> Search 会得到 optimal solution；</p><blockquote><p>即 optimistic (admissible) heuristic function 的定义为：</p><script type="math/tex; mode=display">\forall\space node\space n,\space 0\le h(n)\le h^*(n)\Longrightarrow h(n)\space is\space admissible</script></blockquote></li><li><p>如果 heuristic function 在某一结点的值大于实际到 optimal solution 的加权路径长度，则称为 <strong>pessimistic heuristic function</strong>，这样的 A* Search 很可能无法得到 optimal solution；</p></li></ul><p><strong>重要的是，虽然我们不知道 $h^*(n)$，但这已经足以我们判断一些情况下使用 A* Search 能否得到 optimal solution了</strong>：</p><p>例如在 pac-man game 的例子中，如果取到 goal 的 Manhattan distance 为 heuristic function，那么<strong>它一定是 optimistic 的，所以用 A* Search 一定能得到正确的 optimal solution</strong>（因为 Manhattan distance 考虑没有墙的情况下的距离，一定是乐观的）；</p><p>再例如在 pancake problem 的例子中，如果取 <strong>错位的薄饼的最大编号</strong> 为 heuristic function，那么 <strong>它也一定是 optimistic 的</strong>（因为你至少还要移动编号个数的薄饼次数才能达到 goal）；</p><p><strong>所以到目前为止，选取 heuristic function 的标准一个是举例子看看在某些结点上，$h(n)$ 是否接近 $g(n)$；另一个就是看看能否判断出 optimistic (admissible)，如果能，则能证明 A* Search 算法的 optimality，那么一定比 Uniform Cost Search 要好</strong>。</p></li></ul><h3 id="1-4-4-拓展：A-Search-的-optimality-证明"><a href="#1-4-4-拓展：A-Search-的-optimality-证明" class="headerlink" title="1.4.4 拓展：A* Search 的 optimality 证明"></a>1.4.4 拓展：A* Search 的 optimality 证明</h3><blockquote><p><strong>为啥取了 admissible 的 heuristic function，A* Search 就一定是 optimal 的？</strong></p></blockquote><p><strong>定义命题：</strong></p><script type="math/tex; mode=display">P:\quad h(n)\space is\space admissible\Longrightarrow A^*\space Search\space is\space optimal</script><p>下面证明命题 $P$：</p><ol><li><p>假设 A* Search tree 如下图所示，具有一个 optimal solution A 和 suboptimal solution B，由于二者的任意性，所以只要能证明 A 能在 B 之前出队并 expand，则就能证明 $P$；</p></li><li><p>再假设 B 在 fringe 中的情况（即 B 在搜索队列中），否则 $P$ 直接成立；</p></li><li><p>再假设 A 或 A 的祖先结点一定在 fringe 中，否则<strong>A 及其祖先节点一定都已经 expand 完毕了（因为 A，至少 A 的祖先节点，是 $f(n)$ 值小于 B 的 “候选结点”）</strong>，这个时候 $P$ 也直接成立；所以记在 fringe 中的 A 或其祖先结点为 n，如下图所示；</p></li><li><p>则可以证明 $f(n)\le f(A)$：由 $f(n)$ 的定义可知，$f(n)=g(n)+h(n)$，再由 admissibility 的定义可知，</p><script type="math/tex; mode=display">h(n)\space is\space admissible\Longrightarrow h(n)\le h^*(n)\Longrightarrow g(n)+h(n)\le g(n)+h^*(n)</script><p><strong>即 $f(n)\le g(A)$</strong>；再根据 heuristic function 的定义，$h(A)=0$，所以 $g(A)=f(A)$，进而得出 $f(n)\le f(A)$；</p></li><li><p>能够证明 $f(A)\lt f(B)$：由 suboptimal solution 的定义，$g(A)\lt g(B)$，由于 $h(A)=h(B)=0$，所以 $f(A)\lt f(B)$；</p></li><li><p>由第 4 条和第 5 条，能够证明 n 必然在 B 之前 expand，即 $f(n)\lt f(B)$（因为 $f(n)\le f(A)\lt f(B)$）；</p></li><li><p><strong>由于祖先结点 n 的任意性，所以 A 或 A 的祖先结点一定都在 B 之前 expand</strong>，所以 任意的 optimal solution A 一定在 suboptimal solution B 之前 expand，因此 A* Search 的 solution 必然是 optimal solution，$P$ 成立，原命题得证。</p></li></ol><p><img src="imgs/AStar_optimality_proof.png" height="200px"></p><blockquote><p>Q：为什么第 5 条 $f(A)\lt f(B)$ 不就能说明 A 在 B 前 expand 了吗？</p><p>A：其实不然，我们在第 5 条的时候还缺少一个条件——我们当时还不能证明 A 结点一定在 fringe 当中。我们只知道 A 的祖先结点在 fringe 当中。</p></blockquote><h3 id="1-4-5-How-to-Create-Admissible-Heuristic-Functions"><a href="#1-4-5-How-to-Create-Admissible-Heuristic-Functions" class="headerlink" title="1.4.5 How to Create Admissible Heuristic Functions ?"></a>1.4.5 How to Create Admissible Heuristic Functions ?</h3><ul><li><p>example: 8 puzzle（8 格华容道）</p><p><img src="imgs/8puzzles.png" height="275px"></p><ul><li>取法 1：状态结点 n 中，错位的数字数目定为 heuristic function $h(n)$，此时易得 $h(n)$ 是 admissible 的；</li><li><strong>结论 1</strong>：<strong>将原问题转化为 relaxed-problem heuristic 来讨论</strong>，例如在 8-puzzle 里面，如果能够直接把数字拆下来，直接安装到正确位置，那么这个问题就变简单了，action 数目一定变少了，而这个新问题就叫做 <strong>relaxed-problem</strong>；显然有：<strong>新问题的总步数（cost）小于原问题的 optimal solution 的步数（cost）</strong>；</li><li>取法 2：状态结点 n 中，所有数字距离正确位置的 Manhattan distance 的总和定为 $h(n)$，这个做法就是上述结论的应用。这种取法对应的 relaxed-problem 是 <strong>忽略数字方块之间的格挡限制</strong>，可以证明这种取法的 $h(n)$ 不仅是 admissible 的，而且<strong>比取法 1 更接近真实 optimal solution 的 cost</strong>；</li></ul></li><li><p><strong>总而言之，Heuristic function 的选取就在 <u>node expansion 的空间消耗</u> 和  $h(n)$ <u>计算的时间消耗</u> 之间抉择、权衡</strong>。但一般无论哪个方向，都<strong>必须要是 admissible 的（因为如果不是的话，就不能保证 A* Search 的 optimality，那还不如用 Greedy search）</strong>。</p><ul><li>要么 $h(n)$ 选取一些 admissible 且方便计算的函数，但平均需要更多的 node expansion 才能找到 optimal solution；</li><li>要么 $h(n)$ 选取一些 admissible 且更接近真实 optimal solution cost 的函数，但一般平均需要花费更长时间才能计算出 $h(n)$ 在某一结点的值；</li></ul></li><li><p><strong>结论 2</strong>：两个 admissible heuristic function 的最大值函数一定是更接近于真实 optimal solution cost 的 admissible heuristic function；如下图：</p><p><img src="imgs/h_semilattice.png" height="300px"></p><blockquote><p>注：如果 $\forall n,\space h(n)=0$，则 A* search 退化为 Uniform Cost Search（相当于提供 goal 的信息被 “磨平了”，各结点处都一样了）</p></blockquote></li></ul><h3 id="1-4-6-From-Tree-Search-to-Graph-Search"><a href="#1-4-6-From-Tree-Search-to-Graph-Search" class="headerlink" title="1.4.6 From Tree Search to Graph Search"></a>1.4.6 From Tree Search to Graph Search</h3><p>前面说的算法，从 uninformed search (DFS、BFS、Uniform Cost Search) 到 informed search (Greedy Search、A* Search)，都借助了 <strong>Tree Search</strong> 的思想，没有标注 visited 结点，导致大量重复冗余的 node expansion（同一状态结点入队多次）。</p><p>我们借鉴图算法的思想，只需要在前面 Tree Search 算法中 <strong>expansion strategy 前</strong> 加入 visited 判断，即可变成 Graph Search。具体实现方法可以借助 <strong>closed set</strong>（闭集，就是集合结构的数学名称）（别用列表，因为<strong>线性表查找元素是否存在的时间复杂度远大于集合结构</strong>）</p><p>易得，<strong>Tree Search 算法和同等的 Graph Search 算法的 complete 性质相同</strong>。因为它们理论上都能遍历完有限结点。</p><p>但！<strong>转换为 Graph Search 后，却不一定有同等的 optimality</strong>。因为在某些情况下，如果某些 admissible heuristic function 选的不好，很有可能导致 visited 会放弃掉 optimal solution，例如下面这种情况：</p><p><img src="imgs/AStarGraph_counterExample.png" height="270px"></p><p><strong>这是因为 heuristic function 选取的不一致性（inconsistency）导致的</strong>，通常是因为<strong>两个结点之间的 $h(n)$ 值之差大于它们间的 cost</strong>，导致其中一个结点<strong>需要第二次进队才有可能找到 optimal solution</strong>。这里结点 A 和 C 之间就存在这个问题，$h(A)-h(C)=3\gt cost(A,C)=1$，所以当 C 结点在 A* Tree Search 第二次进队时，才算 optimal solution。如果贸然转换为 Graph Search，就会丢失这个 optimal solution。</p><p>所以，考虑对于一个 admissible heuristic function，如果每两个结点之间的 $h(n)$ 值之差必然小于等于它们之间的 cost，<strong>所以称这个 admissible heuristic 为 consistent 的</strong>。</p><p>只有 heuristic function 是 consistent 的，<strong>越靠 fringe 后面弹出的 node，其 $f(n)$ 越大，越不可能是 optimal solution</strong>，否则不能满足这个特性。</p><p><img src="imgs/consistency_of_heuristics.png" height="275px"></p><ul><li>性质 1： <strong>Consistency 蕴含（implies）Admissibility</strong>（一个 consistent heuristic function 一定是 admissible heuristic function）；</li><li>性质 2：只有选取了 Consistent heuristic function，A* Graph Search 才能保证 optimality，但 A* Tree Search 只需要 Admissible heuristic function 就能保证 optimality；</li></ul><p>因此，<strong>如果选取的 heuristic 具备 consistency</strong>，那么将之前的所有 Tree Search 算法加上 visited 判断变成 Graph Search 算法，均不改变其 completion 和 optimality，并且可以减少 node expansion 的数目，实现算法的优化。</p><p><strong>值得庆幸的是，大部分自然得到的 admissible heuristic functions 都是 consistent 的，尤其是由 relaxed problems 取得的</strong>。所以大可以认为，用 relaxed problems 方法取得的 heuristic functions 都具有 consistency，而无需证明。</p><p>上面的 “一致性” 比较抽象，有位知乎网友 <code>@Hepta</code> 解释的好，截下来给大家参考：</p><p><img src="imgs/zhihu_explain.png" height="400px"></p><p>这可以认为，这个 heuristic function 取得确实是 admissible（每个结点的 $h(n)$ 总趋势都是越接近 goal 就越接近0，并且是<strong>乐观估计</strong>的），但是每个路线上的 “乐观估计程度不相同”，如果存在一种情况：<strong>一个实际更长（cost 更大）的路径比一个实际更短（cost 更小）路径的 $h(n)$ 更乐观——即虽然它们各自都正确反映了 goal 远近的性质（admissible），但相对远近反映不一致（inconsistent），这就是 heuristic function 的不一致性</strong>。</p><p>这种不一致就会影响搜索，导致<strong>suboptimal solution 的路径比 optimal solution 的路径更快到达 solution <u>附近停下来</u></strong>（但总体受到 admissible 的限制，suboptimal solution 不会先进队的），所以这个时候如果附近的结点又恰好唯一，并且还有 visited 不允许重复进队，那么 optimal solution 的路径就会被 suboptimal solution 的路径截断，造成错误地丢失正确最优解。</p><p>所以上面说 “relaxed problems 得到的 admissible heuristic function 都有 consistency” 是符合一般规律的，故意设计的 heuristic function 可能不满足 consistency、满足 admissible，但它一般不能从 relaxed problems 得出。</p><h3 id="1-4-7-补充：Dijkstra-Algorithm-amp-A-Algorithm"><a href="#1-4-7-补充：Dijkstra-Algorithm-amp-A-Algorithm" class="headerlink" title="1.4.7 补充：Dijkstra Algorithm &amp; A* Algorithm"></a>1.4.7 补充：<code>Dijkstra</code> Algorithm &amp; A* Algorithm</h3><p>其实细心的同学已经发现，<code>Dijkstra</code> 算法不就是 A* 算法的特殊情况嘛！当我们仅仅以当前步累计的 cost（去掉距离 goal 的 cost）作为 heuristic function 时，A* 算法就退化为了 <code>Dijkstra</code> 算法。</p><p>它们都只能解决非负边权值图的最短路径问题。</p><h2 id="1-5-Summary"><a href="#1-5-Summary" class="headerlink" title="1.5 Summary"></a>1.5 Summary</h2><p>本章讲述了 <strong>搜索问题</strong> 的基本定义和算法。我们可以总结出：</p><ul><li><p>搜索问题的使用场景：用于一类很特定的问题，它们满足搜索问题的模板。例如地图导航的最短路搜索、没有敌人并且是去往特定位置的 pac-man 游戏；</p></li><li><p>搜索问题中 Agent 的性质：<strong>Planning Agent</strong>，即先根据算法计算，得出一系列动作序列之后再行动，<strong>更关注 master-mind，即固定的动作序列解法来得到最优解</strong>；</p></li><li><p>搜索问题的前提假设：单个 Agent（<strong>没有其他 agent 做出不确定 (uncertain) 或者对抗性 (adversarial) 的 actions 对当前 agent 造成影响</strong>）、可决定的 Actions、完全可观测的 States、离散的 State space；</p></li><li><p>搜索问题的目标</p><ul><li><p><strong>获取路径</strong>：此时 Agent 的性质是 <strong>Planning Agent</strong>，即先根据算法计算，得出一系列动作序列之后再行动，<strong>更关注 master-mind，即固定的动作序列解法（即路径）来得到最优解</strong>；</p><blockquote><p>本章讲述的几乎所有内容都是关于这个方面的；</p></blockquote></li><li><p><strong>获得结果</strong>：此时动作序列并不重要，只关心这个动作序列能否达到 goal；通常这种目标下不会考虑 costs；</p></li></ul></li></ul><p>所以搜索问题的假设很多，在这个问题基础上，我们添加了一些信息，例如路径是否等权？权重大小多少？是否可以用 goal 信息来 inform 搜索的方法？</p><p>对应的算法常见的有：Tree Search 的 DFS、BFS、UCS（都是 uninformed）和 Greedy Search、A Star Search；进一步进行改进还有对应的 Graph Search。</p><p>以后几章，我们将一点点解除这些前提假设的限制，让问题发生变化，并探讨新问题的算法。</p><h1 id="Chapter-2-Constraint-Satisfaction-Problems-CSPs"><a href="#Chapter-2-Constraint-Satisfaction-Problems-CSPs" class="headerlink" title="Chapter 2. Constraint Satisfaction Problems (CSPs)"></a>Chapter 2. Constraint Satisfaction Problems (CSPs)</h1><h2 id="2-1-The-Introduction-to-CSP"><a href="#2-1-The-Introduction-to-CSP" class="headerlink" title="2.1 The Introduction to CSP"></a>2.1 The Introduction to CSP</h2><p>正如上一章总结所说，CSP 只是一种特殊的 “获取结果” 的 Search Problem，它对问题作了如下假设：</p><ul><li>状态空间是个<strong>黑盒</strong>，可以是任何数据结构，无法直接访问状态空间的信息；</li><li>目标测试也可以是任何形式的函数，也是黑盒，只能调用（即从结果上看是否达到目标）；</li><li>后继函数仍然是黑盒，你只能通过调用来取得可能的后继状态；</li></ul><p>因此我们可以问题抽象为新的数学表示：</p><ul><li>CSP 就是 Search Problem 的一个特殊子集，目标本质是找到 goal；</li><li>所有的<strong>状态</strong>可以被定义为一组变量：$X_i$，其值在定义域 $D$ 中变化（<strong>有的时候 $D$ 取决于 $i$</strong>）；</li><li><strong>后继函数</strong>的运作方法类似为这些状态变量赋值；</li><li><strong>目标测试</strong>就是一组<strong>限制条件（Constraints）</strong>，指明了最终的 goal，即可接受的<strong>状态序列（由可接受的一组 $X_i$ 的值组成）</strong>，这也是为什么这个问题被称为 “Constraint Satisfaction Problems”；</li></ul><p>它的应用相当广泛，生活中几乎都能见到。</p><h3 id="2-1-1-Example-1-地图上色"><a href="#2-1-1-Example-1-地图上色" class="headerlink" title="2.1.1 Example 1: 地图上色"></a>2.1.1 Example 1: 地图上色</h3><p>举一个例子，计算机证明 <strong>四色定理</strong> 时需要正确地为地图分配颜色。现在我们想要为地图上一片有划分的区域填色，要求<strong>相邻区域颜色不得相同</strong>。具体做法如下：</p><ol><li>首先把问题抽象为 CSP。很显然，问题的<strong>状态可以由一组区域变量表示</strong>，其定义域为各自不同颜色组成的集合，这里假设有 6 个区域，在 $x_1\sim x_6$；</li><li>这里可以把颜色定义域设置为 3 种颜色：<code>D = &#123; red, green, blue &#125;</code>；</li><li>目标测试（限制条件）<ul><li>Implicit（隐含）：adjacent regions must have different colors（体现在代码中就是每两个相邻区域变量不相等）；</li><li>Explicit（明确）： $(x_i,x_j)\in\{(red,green),(red,blue),\cdots\}$；</li></ul></li><li>解决方案（solution）：就是一组或多组符合限制条件的 $x_i$ 的赋值（assignments），<strong>CSP 问题的解只需要找到一个解即可</strong>；</li></ol><hr><p>除了使用变量 + 限制条件的方法，还有一种方法可以描述 CSP 问题：<strong>Constraint Graphs</strong>：</p><ul><li><p>每个变量由图中的一个结点代替；</p></li><li><p><strong>如果限制条件是 二元 的</strong>（是/否、有/无、等于/不等于，等等），那么可以用结点之间是否连接边来表示；</p><blockquote><p>注意：<strong>限制图的边只是表示哪里有限制，没有说明限制是什么</strong>，所以应该是二元的限制条件；</p></blockquote></li></ul><p>这种<strong>最多每两个变量之间</strong>具有<strong>二元限制条件</strong>的 CSP  问题被称为 Binary CSP，对应的限制图被称为 Binary Constraint Graph；</p><p>相对应的还有<strong>一元限制条件（Unary Constraint）</strong>，即指定变量必须为某特定值；后面会具体说。</p><h3 id="2-1-2-Example-2-N-Queens-问题"><a href="#2-1-2-Example-2-N-Queens-问题" class="headerlink" title="2.1.2 Example 2: N-Queens 问题"></a>2.1.2 Example 2: N-Queens 问题</h3><p>我们听过 “八皇后问题”，那么对于 N-皇后问题，除了使用递归+回溯的经典解法，还可以将其转化为 CSP 求解：</p><ul><li><p>表示方法 1：逐格表示</p><ul><li><p>状态：就是 N × N 的数组，用于保存其上是否存在 “皇后” 棋，定义域为 <code>&#123;0, 1&#125;</code>；</p></li><li><p>目标测试（限制条件）：</p><ol><li>$\forall i,j,k\space(X_{ij},X_{ik})\in\{(0,0),(0,1),(1,0)\}$（不能在同一行）</li><li>$\forall i,j,k\space(X_{ij},X_{kj})\in\{(0,0),(0,1),(1,0)\}$（不能在同一列）</li><li>$\forall i,j,k\space(X_{ij},X_{i+k,\space j+k})\in\{(0,0),(0,1),(1,0)\}$（不能在对角线下半部分）</li><li>$\forall i,j,k\space(X_{ij},X_{i+k,\space j-k})\in\{(0,0),(0,1),(1,0)\}$（不能在对角线上半部分）</li><li>$\sum_{i,j}X_{ij}=N$；</li></ol></li></ul></li><li><p>表示方法 2：列表示</p><ul><li>状态：第 $k$ 行的 queen 位于的列数 $Q_k$，定义域为 <code>&#123;1, 2, ..., N&#125;</code>；</li><li>限制条件：$(Q_1,Q_2)\in\{(1,3),\space(1,4),\cdots\}$ ……;</li></ul></li></ul><h3 id="2-1-3-Example-3-Cryptarithmetic-加密运算"><a href="#2-1-3-Example-3-Cryptarithmetic-加密运算" class="headerlink" title="2.1.3 Example 3: Cryptarithmetic 加密运算"></a>2.1.3 Example 3: Cryptarithmetic 加密运算</h3><p>例如对加法式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    T W O</span><br><span class="line">  + T W O</span><br><span class="line">-----------</span><br><span class="line">  F O U R</span><br></pre></td></tr></table></figure><p>解出每个字母所代表的数字（0 ~ 9）；可以抽象出如下 CSP 问题：</p><ul><li>变量 F、T、U、W、R、O、C1（第一位进位）、C2、C3；定义域 <code>&#123;0,1,...,9&#125;</code>；</li><li>限制条件<ul><li>alldiff(F, T, U, W, R, O)，字母各不相同；</li><li>O + O = R + 10 * C1, ……;</li></ul></li></ul><h3 id="2-1-4-Example-4-Sudoku"><a href="#2-1-4-Example-4-Sudoku" class="headerlink" title="2.1.4 Example 4: Sudoku"></a>2.1.4 Example 4: Sudoku</h3><p>对于数独而言，转化为 CSP 可以是：</p><ul><li>变量即每一个没有填数的方块，定义域 0 ~ 9 的整数；</li><li>限制条件<ul><li>每一行所有元素不得相同；</li><li>每一列所有元素不得相同；</li><li>每一小正方形区域所有元素不得相同；</li><li>本身填有数的方块为 Unary Constraint，要求必须为某个数字；</li></ul></li></ul><h3 id="2-1-5-Example-5-The-Waltz-Algorithm-Deprecated"><a href="#2-1-5-Example-5-The-Waltz-Algorithm-Deprecated" class="headerlink" title="2.1.5 Example 5: The Waltz Algorithm (Deprecated)"></a>2.1.5 Example 5: The Waltz Algorithm (Deprecated)</h3><p>早期计算机视觉使用这个算法来识别 3D 图形的顶点是向外凸，还是向内凹。基本原理是：将立体中的所有顶点作为一个变量，限制条件就是<strong>相邻两个点不能一个是凸顶点，一个是凹顶点</strong>；</p><h2 id="2-2-Varieties-of-CSPs"><a href="#2-2-Varieties-of-CSPs" class="headerlink" title="2.2 Varieties of CSPs"></a>2.2 Varieties of CSPs</h2><h3 id="2-2-1-Varieties-of-Variables"><a href="#2-2-1-Varieties-of-Variables" class="headerlink" title="2.2.1 Varieties of Variables"></a>2.2.1 Varieties of Variables</h3><p>研究 CSPs 算法前，先弄清楚 CSPs 的详细信息。首先 CSP 总的来说有两种变量类型：</p><ul><li>离散型变量（Discrete Variables）<ul><li>有穷定义域（$card(D)=d$）：存在 $O(d^n)$ 种完全指配；例如 二元 CSP，有些是 NP-完全 问题；</li><li>无穷定义域（整型、字符串等）：更加困难，例如工作安排问题（某些问题必须在另一些问题之前完成）；<strong>仅线性约束可解</strong>。</li></ul></li><li>连续型变量（Continuous Variables）<ul><li>例如与时间变化有关的问题，<strong>线性约束可解，并且是多项式时间内可以利用 LP 方法完成</strong>；</li></ul></li></ul><h3 id="2-2-2-Varieties-of-Constraints"><a href="#2-2-2-Varieties-of-Constraints" class="headerlink" title="2.2.2 Varieties of Constraints"></a>2.2.2 Varieties of Constraints</h3><ul><li><p>Unary Constraint：<strong>与单个变量有关，等价于减小定义域</strong>，例如：$x=1$、$y\ne2$；</p></li><li><p>Binary Constraint：<strong>仅与一对变量有关</strong>，例如：$x=y$、$a\ne b$；</p></li><li><p>Higher-order Constraint: involve 3 or more variables，例如 2.1.3 加密计算；</p></li><li><p>Soft Constraint: Preferences（非强制的倾向），实现方法是<strong>加权，并且转化为限制优化问题</strong>；</p><blockquote><p>本章会忽略这种情况，到 <strong>贝叶斯网络</strong> 再讨论这个问题。</p></blockquote></li></ul><h2 id="2-3-The-formulations-for-Binary-CSPs"><a href="#2-3-The-formulations-for-Binary-CSPs" class="headerlink" title="2.3 The formulations for Binary CSPs"></a>2.3 The formulations for Binary CSPs</h2><blockquote><p>本节仅讨论 <strong>Constraint 至多与 2 个变量有关</strong>的问题。</p></blockquote><h3 id="2-3-1-Standard-Search-Formulation"><a href="#2-3-1-Standard-Search-Formulation" class="headerlink" title="2.3.1 Standard Search Formulation"></a>2.3.1 Standard Search Formulation</h3><p>一种常用解决 CSP 问题的方法被称为 Standard Search Formulation，方法将 CSP 问题看作一种特殊的搜索问题，定义如下：</p><ul><li>状态：defined by the values assigned so far；</li><li>初始状态：空指派；</li><li>后继函数：为一个没有指派的变量从定义域种指派一个值；</li><li>目标测试：当前指配是否为完全指派，并且满足所有约束条件；</li></ul><p>现在讨论这种思路下的算法，从最原始的方法开始来一步步优化。</p><p>现在以上面任一个 Example 为例。</p><h4 id="BFS-遍历"><a href="#BFS-遍历" class="headerlink" title="BFS 遍历"></a>BFS 遍历</h4><p>我们考虑最原始的 BFS 遍历，发现这是最差的算法，没有之一。因为这个问题中，所有的解法都在搜索树的最底层。意味着 BFS 需要遍历几乎所有状态才能找到至少一个解。我们大可以直接放弃这个方法。</p><h4 id="DFS-遍历"><a href="#DFS-遍历" class="headerlink" title="DFS 遍历"></a>DFS 遍历</h4><p>在这个问题中，DFS 方法要比 BFS 好一些，<strong>所以这一节中接下来的优化算法都基于此</strong>。这和上一章解决普通 Search Problem 的思路不一样，那个时候的算法几乎都从 BFS 的思路出发（UCS / A Star）。</p><p>实现思路是先一步步沿搜索树向下指派变量，<strong>全部指派结束后，再检查目标测试</strong>，不满足则从栈中弹出最上面的赋值（最后一个赋值），换一个值，如此递归进行。</p><p>实现思路简单，但是非常繁琐，接下来进行优化。</p><h4 id="Backtracking-Search"><a href="#Backtracking-Search" class="headerlink" title="Backtracking Search"></a>Backtracking Search</h4><p>是一种解决 CSP 的 basic uninformed algorithm，思路如下：</p><ul><li><p>一次仅对一个变量进行操作</p><ul><li><strong>变量指派是可交换顺序的，所以首先定下顺序</strong>（例如先赋值 $x=1$，再赋值 $y=2$ 和 先赋值 $y=2$，再赋值 $x=1$ 是等价的），只要将定义域排序，并且按序指派就能实现；</li><li><strong>每一步只需要考虑一个单独变量的指派</strong>；</li></ul></li><li><p><strong>每一步都检查限制条件</strong>：一旦违反条件，立即更换当前最近一次的指派。</p><blockquote><p><strong>这主要因为 CSP 问题在前一步违反条件后，后面指派就没有机会弥补，或者说使状态重新符合条件</strong>。类似一种剪枝。</p></blockquote></li></ul><p>使用以上两个思路优化的 DFS 被称为 Backtracking Search（回溯搜索）；</p><p>这种算法在解决 Example 2 的 N-queens 时，能够解出在 N ≤ 25 范围的问题。</p><p><img src="imgs/backtracking_search_pseudo_code.png" height="300px"></p><p>现在考虑 backtracking 能否继续优化？从以下方面考虑：</p><ul><li>指派定义域排序：<strong>下一个先指派定义域中的谁？按什么顺序？</strong></li><li>中途过滤：<strong>能否在违反限制之前就检测到可能的风险，并且尽早规避？</strong>（使得递归深度减小）</li><li>数据结构：能否进一步改进问题的数据结构，使其更高效？</li></ul><p>先从方便下手的部分开始：中途过滤。</p><p><strong>优化方案 1: Forward Checking</strong></p><p>思路之一是 <strong>Forward Checking</strong>，在为一个变量指派时，同时根据限制<strong>缩小其他变量（必须仅仅是有限制联系的，no further）的定义域</strong>（排除不符合限制的取值）。一旦发现有变量的定义域为空，则提前检测到了违反限制的情况，所以提前排除这种指派，重新为当前变量指派。</p><blockquote><p>In general, forward checking is going to propagate information from assigned values to unassigned values, but <strong>doesn’t provide early detection for all failures</strong> (looming conflicts between unassigned and other unassigned variables).</p></blockquote><p><strong>优化方案 2: Rich Filtering Algorithm - Graph Arc Consistency Checking</strong></p><p>这种方法还可以继续向前预测，因为在地图上色例子中，当地图两个相邻区域定义域只有相同颜色时，也希望被提前检测到。这就需要 <strong>reason from constraint to constraint</strong>（从一个限制条件推广传递至另一个），用到的技术是 <strong>arc consistency</strong>（限制图有向边一致性，<strong>arc 和 edge 都可以指图的边</strong>）。</p><p>在 Forward Checking 中，我们让每一步都按照<strong>给定的限制条件检查并更新定义域</strong>，但是某些限制条件之间可以推出另外的限制条件，让违反限制的情况更早地被检查到。我们可以通过 <strong>arc consistency</strong> 来检查。</p><p>首先给出 arc consistency 的定义：<strong>在限制图中，对于一个 constraint 对应的有向边，如果对起始结点（tail）当前定义域中<u>任意</u>指派，终止结点（head）当前定义域中都<u>存在</u>一个指派，使得二者不违反 constraint，则称这条边是一致的</strong>。</p><p>因此，我们可以发现，前面的 forward checking <strong>只是保证了指向 new assignment（head）的任意有 constraint 结点（tail）的边具有 consistency，没有检查 “unassigned 结点之间边的 consistency”</strong>。</p><p>所以，新方法应该一开始把所有的边放在一个集合中等待遍历。每一轮检查限制条件、更新定义域时，同时对其他所有有 constraint 相连的结点也进行检查（对于 unassigned 结点，一般是双向的），<strong>如果不满足，那么从起始结点的定义域中移除违反限制的取值</strong>（正是因为从起始结点移除，所以 arc consistency 的定义是 ”起始结点任意指派 -&gt; 终止 结点存在指派“）。<strong>非常难过的一点是，如果我们正在遍历 arc 检查 consistency 时，对某个结点（tail）移除了一个 value，那么之前所有指向这个结点（这时作为 head）所建立的 consistency 都不一定成立了，需要重新检查所有指向这个结点的边的 consistency</strong>。</p><p>这个优化算法的名称叫做 <strong>Forward Checking + AC3</strong>，可以保证每次指派后，限制图都有 graph arc consistency。</p><p>这个时候，我们发现每指派一步所进行的 checking 步骤（即 Graph Arc Consistency Checking）过于复杂，以至于我们应该把这个步骤单独提出为一个函数，如下：</p><p><img src="imgs/AC3.png" height="350px"></p><p>每次我们递归地指派一个结点的值，我们在检查是否违反 constraint 的时候，都要调用一次 <code>AC3</code> 函数，进行如下检查：</p><ol><li>获取当前所有结点变量及其定义域，并将限制图中每条<strong>有向边</strong>（如果限制条件是无向的，就等价于放双向边）都放入一个队列中；</li><li>当队列非空时，从队列取出一条有向边（限制条件），检查边的一致性（使用定义），如果违反，那么删去起始结点定义域中导致冲突的值，并且将当前边的起始结点<strong>作为终止结点时的</strong>所有边放入队列，等待重新检查一致性（代码就是 <code>REMOVE-INCONSISTENT-VALUES</code>）；</li><li>重复第 2 步直至队列中没有边（所有边都通过了一致性检查，又或者至少有一条边的定义域为空，即当前指派无解）；</li></ol><p>这里大家会发现，虽然这个算法确实提前避免违反限制的情况，但是时间复杂度是肉眼可见的大（时间复杂度 $O(n^2d^3)$，通过数据结构优化可以达到 $O(n^2d^2)$，n 为结点数量级，d 为 每个结点变量的定义域大小数量级）。所以这里就需要在 <strong>详细的检查以在浅处避免违反限制</strong> 和 <strong>简单的检查但平均递归深度较大时才能发现违反限制并放弃</strong> 这两种情况抉择。</p><blockquote><p>如果数据结点相当多，不希望递归深度很大，那么 AC3 算法为优；如果限制条件相当多，结点数又相对较少，不希望在检查上浪费太多时间，那么 forward checking 算法为优。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Convex &amp; Optimizations</title>
      <link href="//review/convex-opt/"/>
      <url>//review/convex-opt/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-1-Overview"><a href="#Chapter-1-Overview" class="headerlink" title="Chapter 1. Overview"></a>Chapter 1. Overview</h1><p>进入本章前复习基础的数学知识：</p><ul><li><p>Vector Norms（范数）：对于向量 $x=(x_1,x_2,\ldots,x_n)$，$l_p$-norm 定义为：</p><script type="math/tex; mode=display">||x||_p={}^p\sqrt{|x|_1^p+|x|_2^p+\cdots+|x|_n^p}</script><p>正定性：$||x||_p\ge0,\space||x||_p=0\space\iff x=0$；</p><p>非线性性：$||tx||=|t|\space||x||,\space t\in\mathbf{R}$，$||x+y||\le||x||+||y||$（这个不等式并不好证。好证的三角不等式仅限于范数为 2 的特殊情况）；</p></li><li><p>正交阵 $A^TA=I$，因此一定满秩。此外正交阵列向量（或行）一定是相互正交的向量组，且模长为 1（单位正交向量，否则 $A^TA$ 就不是单位向量了）。</p><p>正交阵可以进行对角化 $A=P^{-1}BP$（$B$ 为对角阵，$P$ 为满秩矩阵）。所谓对角化可以感性理解为将这些正交向量组移动到与给定坐标轴的单位向量方向一致的方向上。</p><p>正交变换非常好的性质是 <strong>保范性</strong>。向量经过正交变换后，范数不变（形象理解为几何形状不变）。</p></li><li><p>实对称矩阵与实二次型一一对应。</p><p>实对称阵可以不满秩。但是一定有 $n$ 个实特征值（如果有 $k$ 个相等的特征值，称该特征值为 $k$ 重特征值），或者说 $r(A)$ 个不同的实特征值。</p><p>不相同的实特征值对应的特征向量 <strong>必定相互正交</strong>。</p><p>实对称阵可以进行谱分解（或称特征分解） $A=Q\Lambda Q^T$，可以证明 $Q$ 的每一列都是 $A$ 的一个特征向量（所以 $Q$ 是正交阵），$\Lambda$ 是对角阵，每个对角元对应一个 $A$ 的特征值。</p></li><li><p>Positive definite / positive semi-definite Matrices (正定阵和半正定阵)：若对于任意的 $n$ 维向量 $x\in\mathbf{R}^n$，都有 $x^TAx\ge0$，则称 $A$ 为半正定阵。<u>正定阵是特殊的实对称矩阵，它对应的二次型是正定二次型</u>。正定阵的判定方法如下：</p><ul><li><p>矩阵为对称矩阵，且特征值均为正；</p></li><li><p>矩阵为对称矩阵，且主元符号均为正；</p></li><li><p>矩阵为对称矩阵，其子行列式均为正；</p></li></ul></li></ul><h2 id="1-1-Mathematical-Optimization"><a href="#1-1-Mathematical-Optimization" class="headerlink" title="1.1 Mathematical Optimization"></a>1.1 Mathematical Optimization</h2><p>数学上对于优化问题的定义是：</p><script type="math/tex; mode=display">\begin{aligned}&minimize&f_0(x)&\\&subject\space to&f_i(x)&\le b_i,\quad i\in[1,m]\end{aligned}</script><p>其中</p><ul><li>$x=(x_1,\ldots,x_n)$ 被称为优化变量（optimization variables）;</li><li>$f_0:\mathbf{R}^n\rightarrow\mathbf{R}$ 被称为目标函数（objective function）;</li><li><p>$f_i:\mathbf{R}^n\rightarrow\mathbf{R},i\in[1,m]$ 被称为约束函数（constraint functions）；</p></li><li><p>将使得 $f_0$ 取得最小值，且满足约束条件的向量 $x^*$ 称为最优解（optimal solution）；</p></li></ul><p>常见的应用实例有：</p><ol><li><p>portfolio optimization（投资组合优化）：</p><ul><li>variables: 在不同 assets 上投资的数量；</li><li>constraints: budgets、每个 asset 所能分配的最大/最小金额、最小回报；</li><li>objective：总体风险，或者回报额；</li></ul></li><li><p>device sizing in electronic circuits（电路设计）：</p><ul><li>variables: device widths and lengths；</li><li>constraints: manufacturing limits, timing requirements, maximum area；</li><li>objective: power consumption；</li></ul></li><li><p>data fitting</p><ul><li>variables: model parameters；</li><li>constraints: prior information, parameter limits；</li><li>objective: measure of misfit or prediction error；</li></ul></li></ol><h2 id="1-2-Solving-Optimization-Problems"><a href="#1-2-Solving-Optimization-Problems" class="headerlink" title="1.2 Solving Optimization Problems"></a>1.2 Solving Optimization Problems</h2><p>数学上如何解决这些优化问题？实际上，对于一般的优化问题，相当难以求解，可能是 NP 问题，或者说不能在多项式时间内解决的问题。</p><p>但是我们其中有一类问题是特例，人们研究出了能够高效、可靠解决这类问题的方法，它们就是 <strong>凸优化问题</strong>（Convex Optimization Problem），包括但不限于最小二乘、线性规划、二次规划等等。</p><h3 id="1-2-1-Least-Squares"><a href="#1-2-1-Least-Squares" class="headerlink" title="1.2.1 Least-Squares"></a>1.2.1 Least-Squares</h3><p>最小二乘问题的目标是 $minimize\quad||Ax-b||_2^2$</p><p>目前有准确的解析解：$x^*=(A^TA)^{-1}A^Tb$，软件可以作出精确、高效地解析和运算（时间复杂度 $O(n^2k)$ 其中 $A\in\mathbf{R}^{k\times n}$）；</p><blockquote><p>注：软件层面并不是直接使用解析解运算。有些问题即便没有解析解，也能很简单地运算。解析解是在数学讨论的范围内。</p></blockquote><h3 id="1-2-2-Linear-Programming-LP"><a href="#1-2-2-Linear-Programming-LP" class="headerlink" title="1.2.2 Linear Programming (LP)"></a>1.2.2 Linear Programming (LP)</h3><p>此后会具体阐述的问题。线性规划的定义是：</p><script type="math/tex; mode=display">\begin{aligned}&maximize&c^Tx&\\&subject\space to&a_i^Tx&\le b_i,\quad i\in[1,m]\end{aligned}</script><p>这里一般性线性规划没有解析解，但是借助数学工具，可以以确定的算法步骤，高效可靠地得到答案，时间复杂度 $O(n^2m)$；</p><p>它不像 Least-Square 一样好识别，需要问题转换的技巧；</p><h3 id="1-2-3-Convex-Optimization-Problem"><a href="#1-2-3-Convex-Optimization-Problem" class="headerlink" title="1.2.3 Convex Optimization Problem"></a>1.2.3 Convex Optimization Problem</h3><script type="math/tex; mode=display">\begin{aligned}&minimize&f_0(x)&\\&subject\space to&f_i(x)&\le b_i,\quad i\in[1,m]\end{aligned}</script><p>其中目标函数、约束函数都是凸函数。凸函数定义为：</p><script type="math/tex; mode=display">f_i(\alpha x+\beta y)\le\alpha f_i(x)+\beta f_i(y)</script><p>其中 $\alpha+\beta=1,\space\alpha\ge0,\space\beta\ge0$；</p><blockquote><p>补充：仿射函数定义为 $f_i(\alpha x+\beta y)=\alpha f_i(x)+\beta f_i(y)$；</p></blockquote><ul><li>线性规划、最小二乘法都是 Convex Optimization Problem 的特例；</li><li>没有解析解，但有确定的算法步骤，高效可靠地得到答案，时间复杂度大致为 $\max\left\{n^3,n^2m,F\right\}$，其中 $F$ 为找到 $f_i$ 的一阶、二阶导数（偏导）所需的复杂度；</li><li>难以识别，需要一些技巧。</li></ul><h3 id="1-2-4-Nonlinear-Optimization-NLP-amp-Integer"><a href="#1-2-4-Nonlinear-Optimization-NLP-amp-Integer" class="headerlink" title="1.2.4 Nonlinear Optimization (NLP) &amp; Integer"></a>1.2.4 Nonlinear Optimization (NLP) &amp; Integer</h3><ul><li>Local Optimization Methods：<strong>选好 initial guess，在 feasible point 周围进行优化</strong>；</li><li>Global Optimization Methods：类似穷极法；</li></ul><h1 id="Chapter-2-Convex-Sets"><a href="#Chapter-2-Convex-Sets" class="headerlink" title="Chapter 2. Convex Sets"></a>Chapter 2. Convex Sets</h1><h2 id="2-1-Affine-Set"><a href="#2-1-Affine-Set" class="headerlink" title="2.1 Affine Set"></a>2.1 Affine Set</h2><p><img src="cimgs/affine-set.png"></p><p>仿射集的定义：如果一个仿射集同时包含了点 $x_1$ 和 $x_2$，且二者不相同，那么通过 $x_1$ 和 $x_2$ 直线上所有点的集合都在这个仿射集中。使用 $x=\theta x_1+(1-\theta)x_2$ 表示。</p><blockquote><p>注意，$x$ 是个向量（或者说坐标点）。随着 $\theta$ 的变动，表示的点在直线上滑动。</p></blockquote><p>举例：线性不等式的解集就是一种仿射集 $\left\{x|Ax=b\right\}$（相反地，所有仿射集都能表示为一个线性不等式的解集）；</p><blockquote><p>证明前者：若 $x_1$ 和 $x_2$ 为 $Ax=b$ 的两个不相等的解，那么 $Ax_1=b$，$Ax_2=b$，因此 $A(\theta x_1+(1-\theta)x_2)=\theta Ax_1+(1-\theta)Ax_2=\theta b+(1-\theta)b=b$；</p><p>（可以由 “线性性” 得到这个结论）</p></blockquote><h2 id="2-2-Convex-Set"><a href="#2-2-Convex-Set" class="headerlink" title="2.2 Convex Set"></a>2.2 Convex Set</h2><p>凸集的定义：如果 $x_1$ 和 $x_2$ 是凸集的相异两点，那么 $x_1$ 和 $x_2$ 组成的线段上的所有点也在该凸集内。</p><p>数学表示：$C$ 为凸集 $\Longleftrightarrow$ $\forall x_1,x_2\in C,\space x_1\ne x_2,\space 0\le\theta\le1\Rightarrow \theta x_1+(1-\theta)x_2\in C$；</p><blockquote><p>在 $x_1$ 到 $x_2$ 的线段上的所有点可以由 $x=\theta x_1+(1-\theta)x_2,\space0\le\theta\le1$ 表示。</p></blockquote><p><img src="cimgs/convex-set-def.png"></p><h2 id="2-3-Convex-Combination-Convex-Hull-amp-Convex-Cone"><a href="#2-3-Convex-Combination-Convex-Hull-amp-Convex-Cone" class="headerlink" title="2.3 Convex Combination, Convex Hull &amp; Convex Cone"></a>2.3 Convex Combination, Convex Hull &amp; Convex Cone</h2><p>凸组合的定义：对于一组点 $x_1,\ldots,x_k$，任何可以由 $x=\theta_1x_1+\theta_2x_2+\cdots+\theta_kx_k$ （$\sum\limits_{i=1}^{i=k}\theta_i=1$，$\theta_i\ge0$）表示的点，所构成的集合称为 $x_1,\ldots,x_k$ 的凸组合。</p><blockquote><p>凸组合的仿射系数和为 1.</p><p>一个凸集就是其任意相异两点 $x_1,x_2$ 的凸组合。所以凸集是一种凸组合。</p></blockquote><p>凸包（Convex Hull）的定义：对于一个点集 $S$，$S$ 中所有点的凸组合就称为 $S$ 的凸包，记作 $conv\space S$；</p><blockquote><p>形象的理解就是 <strong>用橡皮筋把最外围的点都包了起来，之后形成的图形，其内部所有的点都包含于凸包</strong>。</p><p>注意！凸包中的点的凸组合不唯一。一个点可以在其他若干个点的多种凸组合中。</p></blockquote><p><img src="cimgs/convex-hull-def.png" height="150px"></p><p>锥组合（Conic Combination）的定义：对于任意两个相异点 $x_1,x_2$，任何可以由 $x=\theta_1x_1+\theta_2x_2,\space \theta_1,\theta_2\ge0$ 表示的点，所构成的集合称为 $x_1,x_2$ 的锥组合。</p><blockquote><p>注意：<strong><u>锥组合没有要求仿射系数和为 1</u>，因此并不能说锥组合等同于凸集</strong>；</p></blockquote><p>凸锥（Convex Cone）的定义：对于一个点集 $S$，$S$ 中所有点的锥组合就称为 $S$ 的凸锥；</p><p><img src="cimgs/convex-cone-def.png" height="200px"></p><p>小小总结一下：</p><p>对于 $S=\left\{x|x=\theta_1x_1+\theta_2x_2\right\}$，其中 $x_1,x_2$ 为相异两点，</p><p>如果 $\theta_1,\theta_2$ 是普通的变量，那么称 $S$ 为 $x_1,x_2$ 的线性组合；</p><p>如果 $\theta_1,\theta_2\ge0$，那么称 $S$ 为 $x_1,x_2$ 的锥组合；</p><blockquote><p> 几何角度的锥组合：$S$ 所代表的区域内任意相异两点，满足原点到该两点连线方向的<u>射线</u>所包围区域中的点都在这个集合内；</p></blockquote><p>如果 $\theta_1+\theta_2=1$，那么称 $S$ 为包含 $x_1,x_2$ 的仿射集；</p><blockquote><p>几何角度的仿射集：$S$ 所代表的区域内任意相异两点所在的<u>直线</u>上的点都在这个集合内；</p></blockquote><p>如果 $\theta_1,\theta_2\ge0$ 且 $\theta_1+\theta_2=1$，那么称 $S$ 为 $x_1,x_2$ 的凸组合，或者说 $S$ 是一个包含 $x_1,x_2$ 的凸集（但没有“凸组合”准确，因为凸组合中的点可以只由 $x_1,x_2$ 凸组合而成）。</p><blockquote><p>几何角度的凸组合：$S$ 所代表的区域内任意相异两点所在的<u>线段</u>上的点都在这个集合内；</p></blockquote><h2 id="2-4-Hyperplanes-amp-Halfspaces"><a href="#2-4-Hyperplanes-amp-Halfspaces" class="headerlink" title="2.4 Hyperplanes &amp; Halfspaces"></a>2.4 Hyperplanes &amp; Halfspaces</h2><p>超平面的定义：$\left\{x|a^Tx=b\right\}$，其中 $a\ne0$（$a$ 为普通向量，0 代表零向量）；</p><p>半空间的定义：$\left\{x|a^Tx\le b\right\}$，其中 $a\ne0$；</p><p>从几何角度看，一个 N 元一次线性等式即可代表一个 N 维超平面，其中系数向量 $a$ 是该超平面的法向量（normal vector）。</p><p>一个 N 元一次线性不等式即可代表一个 N 维半空间，其中系数向量 $a$ 是指向该半空间界面的<u>外法线方向</u>的法向量。</p><p><img src='cimgs/hyperplane-halfspace-def.png' width="500px"></p><p><code>b</code> 向量的值影响的是垂直于 <code>a</code> 方向的超平面 / 半空间的位置；</p><hr><p>结论：</p><ul><li><p>hyperplane 既是仿射集，又是凸集；</p></li><li><p>halfspace 是凸集，但不是仿射集；</p><blockquote><p>回忆一下，仿射集要求集合内任意相异两点的仿射系数和为 1 所表示的点也在这个集合中。在几何角度理解，就是 <strong>区域内任意相异两点所在的直线上的点都在这个集合内</strong>。</p></blockquote></li></ul><p>如果不从几何角度理解，就通过数学语言证明。下面以证明 “halfspace 是凸集” 这一命题为例：</p><p>假设 $x_1,x_2$ 是 halfspace $S$ 上的任意相异两点。</p><p>要证 $S$ 是凸集，即证对 $\forall x=\theta x_1+(1-\theta)x_2,\space\theta\in[0,1]$，都有 $a^Tx\le b$ 成立。</p><p>则由条件 $x_1,x_2$ 是 $S$ 上相异两点可知，$a^Tx_1\le b,\space a^Tx_2\le b$；</p><p>故 $a^Tx=a^T\theta x_1+a^T(1-\theta)x_2\le \theta b+(1-\theta)b=b$，即 $a^Tx\le b$，原命题得证。</p><p>以后对于这类简单的证明不再作赘述。</p><h2 id="2-5-Euclidean-Balls-amp-Ellipsoids"><a href="#2-5-Euclidean-Balls-amp-Ellipsoids" class="headerlink" title="2.5 Euclidean Balls &amp; Ellipsoids"></a>2.5 Euclidean Balls &amp; Ellipsoids</h2><p>欧几里得球的定义：对于一个中心点 $x_c$ 和半径 $r$，定义点集：</p><script type="math/tex; mode=display">B(x_c,r)=\left\{x|\space||x-x||_2\le r\right\}=\left\{x_c+ru|\space||u||_2\le1\right\}</script><p> 为欧几里得球；</p><blockquote><p>注：式中的范数符号已定义在 Chapter 1 中，遗忘可以前往复习。</p></blockquote><p>椭球的定义：对于中心点 $x_c$，定义点集：</p><script type="math/tex; mode=display">\begin{equation}E=\left\{x|(x-x_c)^TP^{-1}(x-x_c)\le1\right\}\end{equation}</script><p>其中 $P\in\mathbf{S}^n_{++}$ （$P$ 为正定阵，正定阵一定是对称阵），上式也被称为二次不等式（quadratic inequality）。</p><p>注意：由解析几何的知识，<strong><u>椭球的半轴向量由 $P$ 的特征向量给出</u>，<u>椭球的半轴长由对应的特征值 $\sqrt{\lambda_i}$ 给出</u></strong>;</p><blockquote><p>因此，$P=r^2I$（$I$ 为单位矩阵）时，椭球就是一个欧几里得球；所以椭球是欧几里得球的泛化（generalization）；</p><p>另注：</p><p>$\mathbf{S}^n$ 表示 $n$ 阶对称阵组成的集合；</p><p>$\mathbf{S}^n_{++}=\left\{X\in S^n|X\succ0\right\}$ 表示所有 $n$ 阶正定阵组成的集合（概率学中的协方差矩阵就是一个正定阵）；</p><p>$\mathbf{S}^n_{+}=\left\{X\in S^n|X\succeq0\right\}$ 表示所有 $n$ 阶半正定阵组成的集合；</p></blockquote><p>当然椭球也可以表示为 $E=\left\{x_c+Au|\space||u||_2\le1\right\}$，其中 $A$ 为非奇异方阵。可以形象地理解为 $A$ “记录了椭球各个方向上的半径”。</p><blockquote><p>另外需要注意的是，$P$ 可以唯一表示一个椭球，这意味着 $P$ 与椭球点集<u>一一对应</u>。</p><p>但是 $A$ 却不能唯一表示一个椭球。因为对任意正交阵 $Q$（定义 $Q^TQ=I$），$AQ$ 表示的是一个椭球。</p><p>证明：</p><script type="math/tex; mode=display">\begin{aligned}&\left\{x_c+Au|\space||u||_2\le1\right\}\\=\space&\left\{x_c+AQQ^Tu|\space||u||_2\le1\right\}\\=\space&\left\{x_c+(AQ)(Q^Tu)|\space||Q^Tu||_2\le1\right\}\quad(||u||_2=||Q^Tu||_2)\\=\space&\left\{x_c+(AQ)u|\space||u||_2\le1\right\}\quad(\forall u)\end{aligned}</script><p>其中 $||u||_2=||Q^Tu||_2$ 由正交阵的保范性（$(Qu)^T(Qu)=u^TQ^TQu=u^Tu\Longrightarrow||Qu||=||u||$）得到。</p><p>再但！如果 $A$ 是个正定阵，那么这个表示又唯一了。</p></blockquote><hr><p>结论：欧几里得球、椭球是一个凸集。</p><h2 id="2-6-Norm-Balls-amp-Norm-Cones"><a href="#2-6-Norm-Balls-amp-Norm-Cones" class="headerlink" title="2.6 Norm Balls &amp; Norm Cones"></a>2.6 Norm Balls &amp; Norm Cones</h2><p>范式球的定义：对于中心点 $x_c$ 和半径 $r$，定义点集 $N_B=\left\{x|\space||x-x_c||\le r\right\}$ 为范式球；</p><blockquote><p>欧几里得球就是 2-范数下的范式球（或称 “二阶球”，second-order Euclidean ball）。</p></blockquote><p>范式锥的定义：定义图 $N_C=\left\{(x,t)|\space||x||\le t\right\},\space x\in\mathbf{R}^n，t\in\mathbf{R}$ 为范式锥；</p><blockquote><p>这里的 “图” 和计算机中 “图” 数据结构的概念不同。</p><p>这里的 “图” 是数学中的图，表示 “N 维坐标与值的二元组” 的集合，感性理解为：通常将 N 维坐标作为 “横轴”，对应的值为 “纵轴”，作出图形。例如 $\left\{(x,f(x))|x\in\mathbf{R}^n,f(x)\in\mathbf{R}\right\}$ 就是 $n$ 维实函数 $f(x)$ 的图。</p><p>这里范式锥的定义实际上是 <strong>上境图（epigraph）</strong>，因为 $t$ 和 $x$ 不是等号关系（函数关系），而是：$||x||\le t$；因此表示的是如下图锥（实心）；</p><p>另外，如果将小于等于改为大于等于，那么就是 亚图（hypograph）；</p></blockquote><p><img src="cimgs/norm-cone-def.png"></p><blockquote><p>范数为 2 时，范式锥又称为 circular cone（圆锥）；</p><p>此时可以写作 $N_C=\left\{(x,t)|\space x^Tx\le t^2\right\},\space x\in\mathbf{R}^n，t\in\mathbf{R}$</p></blockquote><hr><p>结论：范式球、范式锥都是凸集。</p><h2 id="2-7-Polyhedra-Polytopes"><a href="#2-7-Polyhedra-Polytopes" class="headerlink" title="2.7 Polyhedra (Polytopes)"></a>2.7 Polyhedra (Polytopes)</h2><blockquote><p>多面体 Polyhedron 的复数形式。</p><p>这里要讨论的是 polytopes（多胞形，多面体的特殊情况），也就是封闭的多面体。</p><p>但有些作者把这两个词含义颠倒了。所以建议使用时，固定一种说法，然后用 “封闭的” 形容词来区分这两种情况。</p></blockquote><p>多面体的定义：可以由一组有限个线性不等式和等式的解集所描述的集合。</p><script type="math/tex; mode=display">Ax\preceq b,\quad Cx=d</script><p>其中 $A\in\mathbf{R}^{m\times n},\space C\in\mathbf{R}^{p\times n}$，$\preceq$ 为 component-wise inequality，是逐分量不等号，对每个分量都有一个不等式。这强调的是：$A$ 的每一行的行向量 $a$ 与 $x$ 点积都小于等于向量 $b$ 的对于行的值，即 $ax\le b_i$；这个不等式描述了一个半空间，因此 $Ax\preceq b$ 就描述了一组半空间。</p><p><img src="cimgs/poly-def.png"></p><p>所以说，多面体可以由一组超平面和半空间的交集来表示。</p><h2 id="2-8-Positive-Semi-definite-Cone"><a href="#2-8-Positive-Semi-definite-Cone" class="headerlink" title="2.8 Positive Semi-definite Cone"></a>2.8 Positive Semi-definite Cone</h2><p>半正定锥的定义：对于所有半正定阵构成的集合 $\mathbf{S}^n_+$ 一定是凸锥（这里不再局限于之前讨论的 “点” 了，可以扩展到其他可以通过运算来验证定义的对象上）。这个锥被称为半正定锥。</p><blockquote><p>为什么 $\mathbf{S}^n_+$ 一定是凸锥？因为任意两个半正定阵的锥组合一定还是半正定的（回忆锥组合的定义）。</p></blockquote><h2 id="2-9-Operations-that-preserve-Convexity"><a href="#2-9-Operations-that-preserve-Convexity" class="headerlink" title="2.9 Operations that preserve Convexity"></a>2.9 Operations that preserve Convexity</h2><p>介绍不改变凸性的操作。这样做的意义是，可以将上面几种基本的凸形扩展出去，方便证明某些问题的凸性，方便以后转换问题为凸问题。</p><blockquote><p>就像做微积分中的积分问题，我们先讨论几个原子函数，然后通过一些不改变积分值的运算或变换，来得到更复杂函数的积分值。</p></blockquote><p>实际的应用例如，如何判断给定集合是否为凸集？方法如下：</p><ul><li><p>根据凸集的基本定义判断：$C$ is a convex $\Longleftrightarrow x_1,x_2\in C\Rightarrow \theta x_1+(1-\theta)x_2\in C,\space\theta\in[0,1]$；</p></li><li><p><u>根据不改变凸性的操作，将问题等价转换为以上基本凸形</u>。</p></li></ul><p>那么哪些操作不改变凸性？</p><ul><li>intersection：取交集。两个凸集的交集仍然是凸集；</li><li>affine functions：仿射变换。一个凸集经过仿射变换、仿射变换逆变换后仍然是凸集；</li><li>perspective functions：透视函数变换。</li><li>linear-fractional functions：线性分式函数变换。</li></ul><h3 id="2-9-1-Intersection"><a href="#2-9-1-Intersection" class="headerlink" title="2.9.1 Intersection"></a>2.9.1 Intersection</h3><p>我们如何利用交集不改变凸性的性质来解决一些问题呢？</p><p>举个例子，$S=\left\{x\in\mathbf{R}^m|\space|p(t)|\le1,\space |t|\le\dfrac{\pi}{3}\right\}$，其中 $p(t)=\sum\limits_{k=1}^mx_k\cos kt$（$p(t)$ 为三角多项式，trigonometric polynomial）就是一个凸集。</p><p>怎么证明？想识别这个集合的凸性有点困难，因为 $m\ge5$ 的情况下甚至不能表示出这个集合，所以我们肯定不能用凸集的定义了。</p><p>我们想要化简这个集合来方便操作。试想我们定义另一个集合 $S_t=S|_t=\left\{x\in\mathbf{R}^m|\space|p(t)|\le1\right\}$，如果固定 $t$ 为某个常数，情况是不是简单了点？</p><p>这个时候 $S$ 集合就是多个 $S_t$ 集合的<strong>交集</strong>：$S=\bigcap\limits_{|t|\le\pi/3}S_t$，因此我们看看能否证明 $S_t$ 的凸性，就能直接得到 $S$ 的凸性了。</p><blockquote><p>为什么 $S$ 集合是多个 $S_t$ 集合的<strong>交集</strong>？</p><p>可以这么理解，对某个 $t$ 的 $S_t$ 中，可能包含了满足对所有 $|t|\le\dfrac{\pi}{3},|p(t)|\le1$ 的点，也可能包含仅仅在当前的 $t$ 下才满足 $|p(t)|\le1$ 的点。作交集就筛除了不满足 $|t|\le\dfrac{\pi}{3}$ 下 $|p(t)|\le1$ 条件的点。</p><p>这就是性质：</p><script type="math/tex; mode=display">\left\{x|Pred(x,y),y\in A\cup B\right\}=\left\{x|Pred(x,y),y\in A\right\}\cap\left\{x|Pred(x,y),y\in B\right\}</script></blockquote><p>结果发现 $S_t$ 相当容易判断凸性，因为这个时候 $p(t)$ 退化为了关于向量 $x$ 的线性约束条件：</p><script type="math/tex; mode=display">\begin{aligned}S_t=&\left\{x\in\mathbf{R}^m|\space|p(t)|\le1\right\}\\=&\left\{x\in\mathbf{R}^m|-1\le\left[\begin{aligned}\cos t\\\cos 2t\\\cdots\\\cos mt\end{aligned}\right]x\le1\right\}\end{aligned}</script><p>这不就是两个半空间所夹成的区域的点集（取交集）吗！我们知道 halfspace 是凸集，两个 halfspce 的交集也是凸集，因此 $S_t$ 是凸集。</p><p>因为这里 $t$ 是任意的，所以对所有固定的 $t$ 都有 $S_t$ 是凸集，而 $S$ 是所有 $|t|\le\dfrac{\pi}{3}$ 情况的 $S_t$ 的交集，所以 $S$ 是凸集。</p><h3 id="2-9-2-Affine-Function"><a href="#2-9-2-Affine-Function" class="headerlink" title="2.9.2 Affine Function"></a>2.9.2 Affine Function</h3><p>仿射函数定义为：对定义域上任意两个值 $x,y$，对任意的 $\theta\in[0,1]$，都有 $f(\theta x+(1-\theta)y)=\theta f(x)+(1-\theta)f(y)$，因此也是一种非凸非凹的函数。</p><p>假设函数 $f:\mathbf{R}^n\rightarrow\mathbf{R}^m$ 是仿射函数（就是线性变换）；</p><blockquote><p>例如自变量为向量的仿射函数 $f(x)=Ax+b$，其中 $A\in\mathbf{R}^{m\times n},b\in\mathbf{R}^m$；</p></blockquote><p>那么凸集关于仿射函数函数的像（或者说凸集经过仿射变换后得到的集合）一定是凸集：</p><script type="math/tex; mode=display">S\subseteq \mathbf{R}^n\space convex\Longrightarrow f(S)=\left\{f(x)|x\in S\right\}\space convex</script><p>逆变换也是如此。如果一个集合经过仿射变换后的像是凸集，那么原先的集合也是凸集：</p><script type="math/tex; mode=display">C\subseteq\mathbf{R}^m\space convex\Longrightarrow f^{-1}(C)=\left\{x\in\mathbf{R}^n|f(x)\in C\right\}\space convex</script><blockquote><p>甚至这个 $f$ 不是个可逆函数（比如 $f$ 不是单射函数，但 $f$ 作为一个关系而言，是可逆的），上式也成立。</p></blockquote><p>常见的仿射函数有：缩放（scaling）、平移（translation）、投影（projection）等。</p><p>仿射函数可以用在哪些题型上？</p><p>例如线性矩阵不等式的解集 $\left\{x|x_1A_1+x_2A_2+\cdots+x_mA_m\preceq B\right\}$，其中 $A_i,B\in\mathbf{S}^p$ 。</p><p>这个时候，判断这个集合的凸性可以定义一个函数 $f:\mathbf{R}^m\rightarrow\mathbf{S}^p$（将 $m$ 维向量映射到 $p$ 阶对称矩阵上），这个函数定义为 $f(x)=B-\sum\limits_{i=1}^mx_iA_i$。很容易知道 $f$ 的像（集合）一定是一个 positive semi-definite cone（半正定锥，因为对任意的 $x$ 都有 $f(x)\succeq0$，$f(x)\in \mathbf{S}^p$），即凸集，因此原集合（$f(x)$ 的逆像）也是一个凸集。</p><p>再例如双曲锥面，$\left\{x|x^TPx\le(c^Tx)^2,\space c^Tx\ge0\right\}$，其中 $P\in\mathbf{S}^n_+$；</p><p>判断这个集合为凸集，也可以构造一个函数，$f:\mathbf{R}^n\rightarrow (\mathbf{R}^n,\mathbf{R})$，即 $f(x)=(P^{1/2}x,\space c^Tx)$，其中 $(P^{1/2})^2=P$；$f$ 就是个仿射函数（可以按仿射函数定义来测试），并且 $\left\{(x,t)|\space x^Tx\le t^2\right\},\space x\in\mathbf{R}^n，t\in\mathbf{R}$（二阶范式锥）正好是双曲锥面在 $f$ 上的像，因此双曲锥面是个凸集。</p><h3 id="2-9-3-Perspective-amp-Linear-Fractional-Function"><a href="#2-9-3-Perspective-amp-Linear-Fractional-Function" class="headerlink" title="2.9.3 Perspective &amp; Linear-Fractional Function"></a>2.9.3 Perspective &amp; Linear-Fractional Function</h3><p>透视函数定义为 $f:\mathbf{R}^{n+1}\rightarrow\mathbf{R}^n$（所有降低参数 1 个维度的函数）；</p><p>例如 $P(x,t)=\dfrac{x}{t}$，$dom\space P=\left\{(x,t)|t\gt0\right\}$；就是一个透视函数。</p><p>透视函数的像、逆像中有一个是凸集，那么另一个就是凸集。</p><hr><p>线性分式函数是 透视函数 和 仿射函数 的复合，定义为：$f(x)=\dfrac{Ax+b}{C^Tx+d}$，其中 $dom\space f=\left\{c^Tx+d\gt0\right\}$；</p><p>线性分式函数的像、逆像中有一个是凸集，那么另一个就是凸集。</p><h2 id="2-10-Generalized-Inequality"><a href="#2-10-Generalized-Inequality" class="headerlink" title="2.10 Generalized Inequality"></a>2.10 Generalized Inequality</h2><p>为了定义广义不等式（以便对凸优化进行处理、评价），人们引入了 proper cone（正常锥）的概念。</p><p>如果一个凸锥满足：</p><ul><li>K is closed (contains its boundary)</li><li>K is solid (has nonempty interior)</li><li>K is pointed (contains no line)</li></ul><p>那么这个凸锥就是正常锥。常见的正常锥有：</p><ul><li>非负实数集合 $R_+$；</li><li>非负象限 $R^n_+$；</li><li>半正定阵集合 $S^n_+$；</li></ul><p>简而言之，<u>正常锥是为了描述一种抽象的非负关系</u>（可以与离散数学中的偏序关系联系起来考虑），例如对向量而言的广义不等式可以在非负象限内考虑（感性理解：<u>两个向量之差在非负象限内才是广义大于关系</u>）：</p><script type="math/tex; mode=display">x\preceq_{\mathbf{R}^n_+}y\Longleftrightarrow x_i\le y_i</script><p>对于矩阵而言可以在半正定矩阵集合内考虑：</p><script type="math/tex; mode=display">X\preceq_{\mathbf{S}^n_+}Y\Longleftrightarrow Y-X\quad positive\space semidefinite</script><p>这样会发现（和偏序关系一样），广义不等式的许多性质（例如自反性、反对称性、传递性等）都和实数域上的不等关系一样。</p><p>但是，根据离散数学中的定义，广义不等关系不一定是线序关系（可以同时有 $x\npreceq_Ky$ 和 $y\npreceq_Kx$，即二者不可比）；</p><p>但我们仍然可以定义广义不等关系的 “最小元素”（为以后的凸优化做准备），但是因为 “不可比” 关系的存在，“最小” 的概念分裂成了最小元素（minimum，所有的元素都可与这个元素比较，并且是最小的）和 极小元素（minimal，可以与这个元素比较的所有元素都比它大）。它们的含义已经在离散数学的 “关系” 一章定义清楚了。</p><p><img src="cimgs/min-elements-def.png" height="400px"></p><p>如上图，在 $\mathbf{R}^n_+$ 中，凸集 $S_1$ 的最小元素是 $x_1$，因为它可以在 $R^n_+$ 上与其他任何元素比较（即凸集代表的图像全部包含在阴影部分区域内），并且它比所有元素都小；</p><p>凸集 $S_2$ 没有最小元素（因为发现 $\mathbf{R}^n_+$ 总是无法完全盖住这个凸集代表的图形，意味着有些元素间不可比），但它有无穷多个极小元素。其中一个极小元素 $x_2$，因为所有能比较的元素中，没有比它小的（即它的非正轴区域没有任何元素）。可以说 $x_2$ 所在的平边界上所有点都是 $S_2$ 关于 $\mathbf{R}^n_+$ 的极小元素。</p><h2 id="2-11-Seperating-amp-Supporting-Hyperplane-Theorem"><a href="#2-11-Seperating-amp-Supporting-Hyperplane-Theorem" class="headerlink" title="2.11 Seperating &amp; Supporting Hyperplane Theorem"></a>2.11 Seperating &amp; Supporting Hyperplane Theorem</h2><p>超平面分割定理。直觉上非常明显的定理。如果 $C$ 和 $D$ 是两个不相交凸集，那么必然存在向量 $a\ne0$ 和 $b$ 使得：$a^Tx\le b$ 对 $\forall x\in C$ 成立，$a^T x\ge b$ 对 $\forall x\in D$ 成立。感性理解如下图：</p><p><img src="cimgs/SHT.png" width="300px"></p><p>理解：一定存在一个超平面 $\left\{x|a^Tx=b\right\}$ 使得它能够完全划分两个不相交凸集。</p><blockquote><p>在机器学习中，将这个超平面称为 “线性分类器”。</p></blockquote><p>如果要 “严格划分”（去掉等号），还需要作出前提假设：例如 $C$ 是闭集等。</p><hr><p>超平面支持定理。直觉上也非常明显。对于一个凸集 $C$，一定能找到一个点 $x_0$ 以及一个超平面 $\left\{x|a^Tx=ax_0\right\}$ （$a\ne0$）使得 $a^Tx\le a^Tx_0$ 对 $\forall x\in C$ 成立。</p><p>感性理解如下：</p><p><img src="cimgs/SHT2.png" width="250px"></p><p>理解：对凸集边界上任意一点 $x_0$，一定存在一个超平面 $\left\{x|a^Tx=ax_0\right\}$ 使得它能够与凸集相切于该点，并且该点处外法线方向与 $a$ 同向（“移动” 超平面切到这个凸集的该点上）。</p><p>它可以由超平面分割定理证明出来。</p><h2 id="2-12-Dual-Cones"><a href="#2-12-Dual-Cones" class="headerlink" title="2.12 Dual Cones"></a>2.12 Dual Cones</h2><p>对偶锥的定义：对于一个凸锥 $K$，其对偶锥为 $K^*=\left\{y|y^Tx\ge0\space for\space all\space x\in K\right\}$；</p><p>形象理解：对偶锥的画法；</p><p><img src="cimgs/dual-cone-draw.png" height="200px"></p><p>（如果 $K$ 是尖的，那么 $K^*$ 就是钝的，二者是互补、对偶的）数学中有很多种类似的关系，例如共轭、转置等等。</p><p>其中 $\mathbf{R}_+^n$、 $\mathbf{S}^n_+$、二阶范式锥是自对偶的（self-dual）。一阶范式锥和无穷阶范式锥互为对偶锥。</p><p>注意，正常锥的对偶锥一定是正常锥。</p>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numeric Analysis for Beginners</title>
      <link href="//review/numeric-analysis/"/>
      <url>//review/numeric-analysis/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-1-Basic-Concepts"><a href="#Chapter-1-Basic-Concepts" class="headerlink" title="Chapter 1. Basic Concepts"></a>Chapter 1. Basic Concepts</h1><ul><li><p>相对误差与绝对误差；</p></li><li><p>求根问题：$\text{For }f:\mathbf{R}\rightarrow\mathbf{R},\text{ find }x^*\text{ such that }f(x^*)=0$；</p><p>假设有估计解 $x_{est}$，但是 $0\lt |f(x_{est})|\ll1$，那么我们也许不知道 $|x_{est}-x_0|$，但是我们一定知道 $|f(x_{est})-f(x_0)|\equiv|f(x_{est})|$；</p><ul><li><p>前向误差：估计解与实际解的差值（就是上面的 $|x_{est}-x_0|$，一般我们不知道）；</p></li><li><p>后向误差：使得估计值正确所要让 problem statement 改变的 delta（就是上面的 $|f(x_{est})-f(x_0)|\equiv|f(x_{est})|$，一般我们能算出来）；</p></li><li><p>Well-Conditioned（insensitive）：$\text{Small backward error}\Rightarrow\text{Small forward error}$；</p></li><li><p>Poor-Conditioned（sensitive/stiff）：$\text{Small backward error}\nRightarrow\text{Small forward error}$；</p></li><li><p>Condition Number：$CN=\dfrac{\text{Forword Error}}{\text{Backward Error}}$；</p><blockquote><p>在寻根问题中，很容易得到 $CN=\dfrac{1}{|f^\prime(x^*)|}$；</p></blockquote></li></ul></li><li><p>Carefully Implementation</p><ul><li>防止溢出的方法：Element Scaling（例如求 $||\vec{x}||_2$）；</li></ul></li></ul><h1 id="Chapter-2-Linear-System-and-LU"><a href="#Chapter-2-Linear-System-and-LU" class="headerlink" title="Chapter 2. Linear System and LU"></a>Chapter 2. Linear System and LU</h1><h2 id="2-1-Review"><a href="#2-1-Review" class="headerlink" title="2.1 Review"></a>2.1 Review</h2><ul><li><p>Over Determined / Under Determined / Completely Determined.</p><blockquote><p>“高” 的矩阵可能是 over determined（更多限制条件）；</p><p>“宽” 的矩阵可能是 under determined（解更可能有无限个）；</p></blockquote></li><li><p>线性方程组的结论复习：一个线性方程组 $A\vec{x}=\vec{b}$ 有两个不同解 $\vec{x_0},\vec{x_1}$，则它有无穷多解；</p><blockquote><p> $\vec{x_0},\vec{x_1}$ 都是线性方程组的解，则它们的线性组合都是该线性方程组的解；</p></blockquote></li><li><p>经验结论：解线性方程组 $A\vec{x}=\vec{b}$ 能不解 $A^{-1}$ 就不解它（计算量和准确性）；</p></li><li><p>初等行变换：左乘初等矩阵；</p><blockquote><p>初等矩阵是指由单位矩阵经过一次基本行/列变换得到的矩阵。基本行/列变换包括以下三种操作：</p><ul><li><p><strong>交换型初等矩阵</strong>：形式为单位矩阵的两行（或列）交换得到的矩阵。例如，在3阶方阵中，交换第一行和第二行的单位矩阵为：</p><script type="math/tex; mode=display">\left[\begin{matrix}0&1&0\\1&0&0\\0&0&1\end{matrix}\right]</script></li><li><p><strong>倍加型初等矩阵</strong>：单位矩阵的某一行（或列）乘以非零常数后加到另一行（或列）得到的矩阵。例如，在3阶方阵中，将第一行的两倍加到第三行的单位矩阵为：</p><script type="math/tex; mode=display">\left[\begin{matrix}1&0&0\\0&1&0\\2&0&1\end{matrix}\right]</script></li></ul><ul><li><strong>倍乘型初等矩阵</strong>：单位矩阵的某一行（或列）乘以非零常数得到的矩阵。例如，在3阶方阵中，将第三行的元素都乘以2的单位矩阵为：<script type="math/tex; mode=display">\left[\begin{matrix}1&0&0\\0&1&0\\0&0&2\end{matrix}\right]</script></li></ul><p>将一个矩阵左乘对应的初等矩阵就是在对行进行对应的变换；</p><p>将一个矩阵右乘对应的初等矩阵就是在对列进行对应的变换；</p></blockquote></li><li><p>高斯消元：先 forward substitution（将第 i 行的前 i - 1 个元素清零、第 i 个元素置 1），再 back substitution（向之前代入）；</p></li></ul><h2 id="2-2-LU-Factorization"><a href="#2-2-LU-Factorization" class="headerlink" title="2.2 LU Factorization"></a>2.2 LU Factorization</h2><p>LU 分解：当参数矩阵不变，只有 $\vec{b}$ 不同时，我们可以节省重复计算的步骤。这种方法就是 $LU$ 分解。</p><ul><li>我们先将 $A$ 矩阵使用高斯消元为 $A=LU$（$U$ 是高斯消元的 forward substitution 的结果）；</li><li>这样可以分开计算 $L\vec{y}=b$ 中的 $\vec{y}$、$U\vec{x}=\vec{y}$ 解得 $\vec{x}$，每一步都是 $O(n^2)$；并且得到上/下三角矩阵的逆要比一般的 $A$ 简单；</li></ul><p><img src="imgs2/LU.png"></p><h2 id="2-3-Linear-System"><a href="#2-3-Linear-System" class="headerlink" title="2.3 Linear System"></a>2.3 Linear System</h2><ul><li><p>线性回归预测</p></li><li><p>线性系统拟合曲线：n 次试验构建一个线性方程组；</p><p><img src="imgs2/linear-fit.png" height="150px"></p><blockquote><p>线性系统拟合非线性曲线：可以让 $f$ 是非线性的，构建一个非线性函数 $f_{ij}$ 的矩阵；</p><p><img src="imgs2/ffit.png" height="200px"></p><p>一个特殊的例子是范特蒙德系统 $f=a_0+a_1x+a_2x^2+\cdots$；</p><p>我们还可以借助傅里叶展开 $f=a\cos(x+\phi)$；</p></blockquote></li><li><p>$A\vec{x}=\vec{b}$ 无解情况如何接近？凸优化：$\min\limits_{\vec{x}}||A\vec{x}-\vec{b}||_2^2$；</p><p><img src="imgs2/ms.png" height="300px"></p></li><li><p>Tikhonov regularization：这种正则化可以向 under determined 的情况加入限制，有助于防止过拟合、数据抖动、减轻数据噪声影响（对高斯白噪声效果好）等问题：</p><script type="math/tex; mode=display">\min\limits_{\vec{x}}||A\vec{x}-\vec{b}||_2^2+\alpha||\vec{x}||_2^2\quad(0\lt\alpha\le1)\\\Longrightarrow0=2A^TA\vec{x}-2A^T\vec{b}+2\alpha\vec{x}\\\Longrightarrow(A^TA+\alpha I_{n\times n})\vec{x}=A^T\vec{b}</script></li><li></li><li><p>稀疏矩阵存储：变换为低维数据（压缩信息的相关性）；</p><ul><li>普通有规律的矩阵，可以通过一些变换转换为稀疏矩阵；</li></ul></li></ul><h2 id="2-5-Cholesky-Factorization"><a href="#2-5-Cholesky-Factorization" class="headerlink" title="2.5 Cholesky Factorization"></a>2.5 Cholesky Factorization</h2><p>注意到重要的矩阵 $A^TA$ 有如下性质：</p><ul><li>正定对称阵（Positive definite Matrix）其中 $A\ne0$；</li></ul><p>而我们又发现正定对称矩阵的 LU 分解非常特殊，$U=L^T$，所以所有正定对称阵可以分解为 $A=LL^T$，这就是 Cholesky 分解；</p><ul><li><p>在阶数较小的情况，直接可以使用待定系数法求解 $L$；</p></li><li><p>在阶数较大的情况，使用迭代法求解 $L$，算法如下：</p><ol><li><p>初始化 $L=0$（全零矩阵，同时是下三角矩阵）；</p></li><li><p>对矩阵的每一列 $j$：</p><ul><li><p>先计算该列上的对角元 $L_{jj}=\sqrt{A_{jj}-\sum\limits_{k=1}^{j-1}L_{jk}^2}$（$j\gt1$），其中 $L_{11}=\sqrt{A_{11}}$；</p><blockquote><p>不难发现，$L$ 每行对角元只与 $A_{jj}$ 和当前行排在 $L_{jj}$ 之前的元素平方和有关；</p><p>可以将 $A$ 分块，即可推出这个结论；</p></blockquote></li><li><p>在第 $j$ 列中，继续对第 $j$ 行之后的每一行 $i\gt j$，计算 $L_{ij}=\dfrac{1}{L_{jj}}(A_{ij}-\sum\limits_{k=1}^{j-1}L_{ik}L_{jk})$，</p><blockquote><p>结论，$L_{ij}$ 与 $A_{ij}$ 和：排在 $L_{jj}$ 前面的元素向量 与 排在 $L_{ij}$ 前面的元素向量的点积有关；</p></blockquote></li></ul><p>完成上面两个步骤后，矩阵的第 $j$ 列全部计算完成；</p></li></ol></li></ul><h1 id="Chapter-3-Norms-Sensitivity-amp-Conditioning-in-Matrix"><a href="#Chapter-3-Norms-Sensitivity-amp-Conditioning-in-Matrix" class="headerlink" title="Chapter 3. Norms, Sensitivity &amp; Conditioning in Matrix"></a>Chapter 3. Norms, Sensitivity &amp; Conditioning in Matrix</h1><h2 id="3-1-Definitions-of-Norms-in-Matrix"><a href="#3-1-Definitions-of-Norms-in-Matrix" class="headerlink" title="3.1 Definitions of Norms in Matrix"></a>3.1 Definitions of Norms in Matrix</h2><p>引入：在浮点数计算时，如果在处理 $||A\vec{x_0}-\vec{b}||$ 时，它距离 0 有多接近才能相信 $x_0$ 是解？</p><p>也就是说，如何衡量 $(A+\delta A)\vec{x}=\vec{b}+\delta\vec{b}$ 求解下 $\vec{x}$ 解的变换幅度？</p><p>我们再次引入向量的范数：$||\vec{x}||_p=(\sum\limits_{i=1}^nx_i^p)^{1/p}$；</p><blockquote><ul><li>注意到 $p\rightarrow\infty$ 是 $||\vec{x}||=\max\{|x_1|,|x_2|,\ldots,|x_n|\}$；</li><li>$||\vec{x}||=0\quad\text{iff}\quad \vec{x}=0$；</li><li>$||c\vec{x}||=|c|||\vec{x}||,\space c\in\mathbf{R},\vec{x}\in\mathbf{R^n}$；</li><li>$||\vec{x}+\vec{y}||\le||\vec{x}||+||\vec{y}||,\space\forall\vec{x},\vec{y}\in\mathbf{R}$；</li></ul></blockquote><p>我们定义两个范数等价（$||\cdot||_p\equiv||\cdot||_q$） 当且仅当 对于任意 $\vec{x}\in\mathbf{R^n}$，都存在 $c_{low}||\vec{x}||\le||\vec{x}||\le c_{high}||\vec{x}||$（同阶）；</p><blockquote><p>推论：$\mathbf{R^n}$ 上的任意范式等价；</p></blockquote><p>我们再定义矩阵的范数：</p><ul><li><p>定义方法 1，“unrolled construction”（元素形式范数，entrywise norm）：将矩阵 $A_{m\times n}$ 按列展开（第 $n+1$ 列排在第 $n$ 列下方），得到一个 $\vec{a}\in\mathbf{R^{mn}}$ 的向量，而向量 $\vec{a}$ 的范数就是 $A$ 的范数；</p><script type="math/tex; mode=display">||A_{m\times n}||_p=(\sum\limits_{i=1}^m\sum\limits_{j=1}^n|a_{ij}|^p)^{1/p}</script><ul><li>二维元素形式范数又称 “Frobenius Norm”，记作 $||A||_{Fro}$；注意到 $||A||_F=\sqrt{\text{tr}(AA^T)}$；</li></ul></li><li><p>定义方法 2，“induced construction”（诱导范数，又称算子范数，operator norm）：描述了矩阵代表的线性变换 $A$ 对 $\vec{x}$ 作用最长伸展的比例。即：</p><script type="math/tex; mode=display">||A||=\max_{\vec{x}\ne0}\dfrac{||A\vec{x}||}{||\vec{x}||}=\max\limits_{||\vec{x}||=1}||A\vec{x}||</script><p>诱导范数的常用结论如下：</p><ul><li><p>$||A||_1=\max\limits_{1\le j\le n}\sum\limits_{i=1}^m|a_{ij}|$（1-诱导范数就是一列中的元素模之和，再取最大值）；</p></li><li><p>$||A||_\infty=\max\limits_{1\le i\le m}\sum\limits_{j=1}^n|a_{ij}|$（$\infty$-诱导范数就是一行中的元素模之和，再取最大值）；</p></li><li><p>$||A||_2=\sqrt{\max\limits_{k}\lambda_k}$（2-诱导范数，又称谱范数，是 $A$ 的最大奇异值的开根号。也就是说，当 $A$ 不可逆时就是 $A^TA$ 的最大特征值开根号）；</p><blockquote><p>可以从图形方法理解：</p><p><img src="imgs2/matrix-norm2.png" width="400px"></p></blockquote></li></ul></li><li><p>定义方法 3，“eigenvalue construction”（schatten 范数，使用矩阵奇异值定义），具体定义较为复杂，不进一步了解；</p></li></ul><h2 id="3-2-Definition-of-Condition-Number-in-Matrix"><a href="#3-2-Definition-of-Condition-Number-in-Matrix" class="headerlink" title="3.2 Definition of Condition Number in Matrix"></a>3.2 Definition of Condition Number in Matrix</h2><p>我们还要定义一个矩阵的条件数。一般条件数想要看的是一个矩阵构成的线性方程组随误差的变化情况。于是我们需要构建建模一个公式：$(A+\varepsilon\delta A)\vec{x}(\varepsilon)=\vec{b}+\varepsilon\delta\vec{b}$，于是可以得到在误差 $\varepsilon$ 下，</p><ul><li><p>$\vec{x}(\varepsilon)$ 表示在误差 $\varepsilon$ 下的 $\vec{x}$ 测量值；</p></li><li><p>$\dfrac{d\vec{x}}{d\varepsilon}|_{\varepsilon=0}=A^{-1}(\delta\vec{b}-\delta A\vec{x}(0))$ 表示 $\vec{x}$ 随误差的变化率；</p></li><li><p>$||\vec{x}(\varepsilon)-\vec{x}(0)||$ 表示前向误差，$\dfrac{||\vec{x}(\varepsilon)-\vec{x}(0)||}{||\vec{x}(0)||}\le|\varepsilon|||A^{-1}||||A||(\dfrac{||\delta\vec{b}||}{||\vec{b}||}+\dfrac{||\delta A||}{||A||})+O(\varepsilon^2)$ 表示归一化的前向误差；</p><blockquote><p>泰勒展开证明上式；</p></blockquote></li><li><p>于是我们定义方阵 $A\in\mathbf{R^{n\times n}}$ 的条件数为：$\text{cond}\space A\equiv\kappa\equiv||A||||A^{-1}||$；</p><p>如果 $A$ <u>不可逆</u>，则条件数为 $\infty$；</p><blockquote><p>得出结论：$\dfrac{||\vec{x}(\varepsilon)-\vec{x}(0)||}{||\vec{x}(0)||}\le\varepsilon\cdot D\cdot\kappa+O(\varepsilon^2)$；</p></blockquote><p>可以知道，一个矩阵的条件数描述的性质和行列式不一样，条件数与常系数缩放无关；</p></li><li><p><strong>重要推论 1</strong>：$\text{cond}\space A=\dfrac{\max\limits_{\vec{x}\ne0}\frac{||A\vec{x}||}{||\vec{x}||}}{\min\limits_{\vec{y}\ne0}\frac{||A\vec{y}||}{||\vec{y}||}}$（可以使用诱导范数直接推得）；</p></li></ul><p>几何上这么理解：在 $A$ 代表的线性变换下，对任意 $\vec{x}$ 作用<u>伸长最长的比例 与 伸长最短的比例 之比</u>；</p><p><img src="imgs2/matrix-cond.png" height="200px"></p><p>由这个几何关系，我们可以推出第二个推论：</p><ul><li><strong>重要推论 2</strong>：$||A^{-1}\vec{x}||\le||A^{-1}||||\vec{x}||$，因为 $||A^{-1}||$ 就是所有向量拉伸最长的比例了；</li></ul><blockquote><p>注：</p><ul><li>可以知道，一个矩阵的条件数越大，它所构成的线性方程组代表的线性系统对微小扰动越敏感的（解周围小范围变化自变量，总体值变化很大）；而一个矩阵的条件数越接近 1，则这个线性系统对微小扰动越不敏感；</li><li>由于很难求一个矩阵的逆，因此一般对条件数的讨论是讨论其上下界；</li></ul></blockquote><h1 id="Chapter-4-Column-Spaces-amp-QR"><a href="#Chapter-4-Column-Spaces-amp-QR" class="headerlink" title="Chapter 4. Column Spaces &amp; QR"></a>Chapter 4. Column Spaces &amp; QR</h1><p>考虑特殊矩阵的条件数 $\text{cond}\space A^TA\approx(\text{cond}\space A)^2$（在 $A$ 可逆的情况下）；</p><script type="math/tex; mode=display">\begin{aligned}\text{cond}\space A^TA&=||A^TA||\space||(A^TA)^{-1}||\\&\approx||A^T||\space||A||\space||A^{-1}||\space||(A^T)^{-1}||\\&=||A||^2||A^{-1}||^2\\&=(\text{cond}\space A)^2\end{aligned}</script><p>所以，我们对于一般的矩阵可以认为 $A^TA$ 越接近单位矩阵 $I_{n\times n}$，$A\vec{x}=\vec{b}$ 更容易解；</p><p>此外，$A^TA$ 的计算可以这么理解：</p><p><img src="imgs2/AtA.png" height="200px"></p><p>所以等价于我们希望 $A$ 是正交矩阵（各个列向量正交归一），而且<u>恰好正交矩阵代表的变换不改变向量的长度（所以正交矩阵的条件数是 1）</u>；</p><p>现在再回来看 $A^TA\vec{x}=A^T\vec{b}$，我们知道这个线性方程组的解就是 $\min\limits_{\vec{x}}||A\vec{x}-\vec{b}||$ 的解，就相当于将 $A$ 拆成列向量 $(\alpha_1,\alpha_2,\ldots,\alpha_n)$，将 $x_1\alpha_1+x_2\alpha_2+\cdots+x_n\alpha_n$ 逼近 $\vec{b}$（将 $\vec{b}$ 投影到 $A$ 列向量做基向量的线性空间上）；</p><blockquote><p>回忆线性代数的性质：</p><p>对任何实矩阵 $A\in\mathbf{R^{m\times n}}$ 和可逆方阵 $B\in\mathbf{R^{n\times n}}$，有 $\text{col}\space A=\text{col}\space AB$，即<u>对任意矩阵进行初等行变换不影响矩阵的列空间</u>；</p></blockquote><p>那么有没有办法对 $A$ 一直进行初等行变换，使得 $A$ 变成正交阵？这样 $A$ 的列空间不变（即原问题的解不变），但是 $A$ 成正交阵后非常好求解。</p><p>这种方法就是 QR 分解。我们将一般矩阵分解为一个正交阵（$A$ 的一组正交基）和上三角矩阵的乘积（上三角矩阵 $R$ 可以理解为一系列初等行变换）。</p><blockquote><p>显然，对于任意一个 $A$，若 $r(A_{m\times n})=n$（$m\ge n$），则 $A$ 都能进行 QR 分解。</p></blockquote><p>一旦我们将 $A^TA\vec{x}=A^T\vec{b}$ 进行 QR 分解：$A=QR$，那么 $\vec{x}=R^{-1}Q^T\vec{b}$，我们发现 $R$ 上三角矩阵容易求逆，就不需要计算 $A^TA$ 的逆了。</p><p>现在，QR 分解有 2 种方法。</p><ul><li><p>一种是通过 施密特正交化。这很好理解：</p><p><strong>现在回忆线性代数的 施密特正交化。这就是得到 $A=QR$ 的一种方法：</strong></p><ol><li>先对 $A$ 施密特正交化，再归一化就能得到基向量相同的正交矩阵 $Q$；</li><li>反解出 $R$：因为正交矩阵 $Q^TQ=I$，因此 $R=Q^TA$；</li></ol><blockquote><p>那么怎么 Gram-Schmidt 正交化？</p><p>对 $A$ 拆成的一组基 $(\alpha_1,\alpha_2,\ldots,\alpha_n)$，可以这么取正交基：</p><ul><li>$v_1=\alpha_1$，第一个向量随便取；</li><li>$v_2=\alpha_2-\dfrac{\alpha_2\cdot v_1}{v_1\cdot v_1}v_1$，第二个向量取 $\alpha_2$ 的时候，需要剔除第一个取得的基向量相关方向的分量：$\dfrac{\alpha_2\cdot v_1}{v_1\cdot v_1}$ 就是 $\alpha_2$ 在 $v_1$ 上的<u>投影长度</u>！</li><li>$v_3=\alpha_3-\dfrac{\alpha_3\cdot v_2}{v_2\cdot v_2}v_2-\dfrac{\alpha_3\cdot v_1}{v_1\cdot v_1}v_1$，第三个向量就减去 $\alpha_3$ 在 $v_1,v_2$ 上的投影分量就行。</li><li>……（依此类推）</li></ul><p>最后别忘了归一化。</p><p>不难发现，这种操作实际上在不断地对 $A$ 右乘上三角矩阵 $R_i$（进行初等列变换），使得：$AR_1R_2\cdots R_n=Q$；</p><p>相对地，下面的 Householder 变换方法，就是不断地进行正交变换（特别地，镜像变换），调整某一列的其他元素为 0，即不断地对 $A$ 左乘 Householder 矩阵（一种正交阵）$H_i$，使得：$H_nH_{n-1}\cdots H_1=R$；</p></blockquote></li><li><p>另一种是通过 Householder 变换（这是一个著名的变换，它代表了镜像变换，显然是一种正交变换），它所对应的矩阵就是 Householder 矩阵。</p><p>如图：</p><p><img src="imgs2/householder.png" width="300px"></p><p>假设已知一个向量 $\eta$，想要关于某个法线方向 $l$ 对称。为了方便，我们记与 $l$ 正交的一个从 $\eta$ 一边指向另一边的<u>单位向量</u>为 $\omega$，则由几何关系可知对称后的向量 $\xi$ 满足：$\xi-\eta=2\omega(\omega^T\xi)$，其中 $\omega^T\xi$ 就是 $\omega$ 和 $\xi$ 的点积（投影长度）；</p><p>因此 $\eta=(I-2\omega\omega^T)\xi$，我们发现，这镜面变换的矩阵就是 $H=I-2\omega\omega^T$，左乘它会将列向量变换到 $\omega$ 对应法线的 $\omega$ 指向的另一侧。</p><p>紧接着，我们发现这个矩阵 $H$ 有这个性质：</p><p>若 $H$ 为 Householder 矩阵，则 $\left[\begin{matrix}I_r&amp;0\\0&amp;H\end{matrix}\right]$ 也是 Householder 矩阵；</p><p>于是我们可以这么进行迭代：</p><ul><li><p>写 $A$ 的基向量 $(\alpha_1,\alpha_2,\ldots,\alpha_n)$，做第一次 householder 变换，使得 $\omega_1=\dfrac{\alpha_1-||\alpha_1||_2\cdot e_1}{||\alpha_1-||\alpha_1||_2\cdot e_1||_2}$，得到第一个 householder 矩阵 $H_1=I-2\omega_1\omega_1^T$，这样 $H_1A$ 的第一列除了第一个元素全部归 0：</p><blockquote><p>$\omega_1$ 可以理解为 $\alpha_1$ 减去在 $e_1$ 的分量（要镜像的方向已经得到了），再归一化，得到单位的镜像向量；</p><p><strong>$H_1\alpha_1$ 的变换就将 $\alpha_1$ 变换到与 $e_1$ 同一个方向上了。</strong></p></blockquote><p><img src="imgs2/householder-step1.png" width="500px"></p></li><li><p>记 $H_1A$ （注意是变换后的矩阵）关于 $a_{11}$ 的余子式为 $B_1$，则写 $B$ 的基向量 $(\beta_1,\beta_2,\ldots,\beta_{n-1})$，那么同理 $\omega_2=\dfrac{\beta_2-||\beta_2||_2\cdot e_1}{||\beta_2-||\beta_2||_2\cdot e_1||_2}$，得到第二个 householder 矩阵 $H_2=I-2\omega_2\omega_2^T$，这样 $H_2H_1A$ 的第一列和 $H_1A$ 一样、第二列除了前两个元素，后面的元素全部归 0:</p><p><img src="imgs2/householder-step2.png" width="400px"></p><blockquote><p>注意，$e_1$ 总是第一个元素为 1、其他元素为 0 的单位向量；</p></blockquote></li><li><p>重复上面的操作，最后 $H_{n-1}H_{n-2}\cdots H_1A=R$，$R$ 是一个上三角矩阵：</p></li><li><p>这样，我们得到了 $A$ 分解出的 $R$，最后反代 $Q=H_1H_2\cdots H_{n-1}$（注意正交阵的性质）；</p></li></ul></li></ul><h1 id="Chapter-5-Eigenvalue-amp-Eigenvector"><a href="#Chapter-5-Eigenvalue-amp-Eigenvector" class="headerlink" title="Chapter 5. Eigenvalue &amp; Eigenvector"></a>Chapter 5. Eigenvalue &amp; Eigenvector</h1><h2 id="5-1-Overview"><a href="#5-1-Overview" class="headerlink" title="5.1 Overview"></a>5.1 Overview</h2><p>在采集多维数据时，需要考虑各个维度间的相关性，以降低数据的维度。</p><p>举个例子，假设有组（该组有 $m$ 个数据） $n$ 维数据 $(v_1,v_2,\ldots,v_m),\space v_i\in\mathbf{R^n}$。</p><p>如果我们只知道某些维度上的确切数据，于是我们就像想将任意一个 $n$ 维数据用某几个维度去拟合整体数据。这样可以非常方便地讨论数据的整体特性。</p><p>这样，数据矩阵的特征值就能派上用场了。</p><p>除了这个问题，还有其他一些问题可以借助特征值进行解决，例如：</p><ul><li>Optimize $||A\vec{x}||_2$，固定 $||\vec{x}||_2=1$；</li><li>ODE/PDE（常微分方程、偏微分方程）的近似解：$\vec{y}^\prime=B\vec{y}$；</li><li>Rayleigh quotient（瑞利商）：$\dfrac{\vec{x}^TA\vec{x}}{||\vec{x}||_2^2}$；</li></ul><p>回忆下线性代数中对于特征向量/特征值的重要结论：</p><ul><li>每个 $n$ 阶方阵至少有一个特征向量（复向量），最多有 $n$ 个不同的特征值；</li><li>对应不同特征值的特征向量是线性无关的；</li></ul><h2 id="5-2-Review-Diagonalizable-Matrix"><a href="#5-2-Review-Diagonalizable-Matrix" class="headerlink" title="5.2 Review: Diagonalizable Matrix"></a>5.2 Review: Diagonalizable Matrix</h2><p>这里再复习一下矩阵对角化的知识：</p><p><strong>矩阵对角化的意义？</strong></p><ul><li><p>可快速计算 $A^k$；</p></li><li><p>可计算 Markov 过程中的平稳分布 $\pi$；</p></li><li>可计算差分方程 $u_{k+1}=Au_k$ 描述的离散动力系统的长期行为；</li><li>……</li></ul><p><strong>矩阵对角化的方法？</strong></p><ol><li><p>求出矩阵 $A$ 的所有特征值 $\lambda_i$；</p></li><li><p>通过 $A$ 的每个特征值，以及特征值的代数重数，来判断 $A$ 是否可对角化。具体来说：</p><p>代数重数就是在判断特征值重复的次数、几何重数就是在描述特征向量重复的维数（就是零空间的维数）。注意<u>每个特征值的几何重数一定小于等于代数重数</u>（因为对应不同特征值的特征向量是线性无关的，而特征值可以重复）。</p><p>这里 $A$ 要可对角化，就必须满足下面两种情况之一：</p><ul><li><strong>$A$ 的所有 $n$ 个特征值互不相等（代数重数 $n$）</strong>。而由于对于不同特征值的特征向量必然线性无关，所以几何重数一定也为 $n$；</li><li><strong>$A$ 所有重根下，$k$ 重特征值是否有 $k$ 个线性无关的特征向量</strong>。这里就是在要求这个代数重数为 $k$ 的特征值的几何重数是不是也是 $k$；</li></ul><p>所以上面的两个要求总体在说：$A$ 的<u><strong>几何重数和代数重数是否相等</strong></u>？</p><p>如果相等，表示 $A$ 所代表的线性变换没有改变被变换方的维度，因此 $A$ 可以分解为 $n$ 个线性无关的正交基向量。也就是可以相似对角化。如果不满足，则无法相似对角化。</p></li><li><p>最后将特征向量与特征值对应起来：$\Lambda=\text{diag}(\lambda_1,\lambda_2,\ldots,\lambda_n)$，$P=(\alpha_1,\alpha_2,\ldots,\alpha_n)$，则 $P^{-1}AP=\Lambda$；</p></li></ol><h2 id="5-3-Definition-of-Spectrum-Radius-in-Matrix"><a href="#5-3-Definition-of-Spectrum-Radius-in-Matrix" class="headerlink" title="5.3 Definition of Spectrum Radius in Matrix"></a>5.3 Definition of Spectrum Radius in Matrix</h2><p>引入一个新的定义：矩阵的谱半径（或称 “矩阵的谱”）。</p><p><strong>谱半径的意义？</strong></p><ul><li>估计一个矩阵的特征值；</li><li>计算一个不可逆矩阵的广义逆矩阵；</li><li>……</li></ul><p><strong>谱半径的计算？</strong></p><p>$\rho(A)=\max\limits_i|\lambda_i|$（矩阵 $A$ 的谱半径等于其<u>所有特征值的模的最大值</u>。<strong>注意特征值包含复数！</strong>）；</p><p><strong>谱半径和范数的关系？</strong></p><p>谱半径和矩阵范数一样，都是矩阵的函数：$f:R^{m\times n}\rightarrow R$；</p><p>但是它们二者本质上真的不一样，一定要和 2-诱导范数（也就是谱范数）区分开。</p><p>二者间有一些重要结论：</p><ul><li><p>任意复数域上的矩阵 $A$，其谱半径 $\rho(A)$ 不大于 $A$ 的任何一种诱导范数，即：$\rho(A)\le||A||$；</p><blockquote><p>含义：<u>矩阵的谱半径是其任意一种范数的下界</u>；</p><p>作用：使用方便求解的范数对谱半径进行估算；</p></blockquote></li><li><p><code>Gelfand</code> 定理：$\rho(A)=\lim\limits_{k\rightarrow\infty}||A^k||^{1/k}$；</p><ul><li>矩阵序列 $I,A,A^2,\ldots,A^k,\ldots$ 收敛于 0 的充要条件：$\rho(A)\lt1$；</li><li>级数 $I+A+A^2+\cdots$ 收敛于 $(I-A)^{-1}$ 的充要条件：$\rho(A)\lt1$；</li></ul></li></ul><h2 id="5-4-Extend-to-mathbf-C-m-times-n"><a href="#5-4-Extend-to-mathbf-C-m-times-n" class="headerlink" title="5.4 Extend to $\mathbf{C^{m\times n}}$"></a>5.4 Extend to $\mathbf{C^{m\times n}}$</h2><p>现在将线性空间扩展到复数域，我们多出如下定义：</p><ul><li><p>共轭转置 $A^H$；</p></li><li><p>厄密矩阵（Hermitian Matrix）：$A^H=A$；</p><blockquote><p>注意和实对称矩阵不一样。</p><p>由量子力学的厄密算符可以得到如下所有结论（量子力学考题）：</p><ul><li>厄密矩阵所有特征值为实数；</li><li>厄密矩阵属于不同特征值的特征向量相互正交；</li><li>……</li></ul></blockquote><p>厄密矩阵因为是复数域上，和实数域上的实对称矩阵很相似（不如说实对称矩阵是厄密矩阵的特殊情况），所以厄密矩阵和实对称矩阵一样，二者一定可以相似对角化（几何重数一定等于代数重数，或者说一定有 $n$ 个线性无关的基向量）；</p><p>它们相似对角化很简单：$A=X^{-1}\Lambda X=X^T\Lambda X$（显然 $X$ 是正交矩阵）；</p></li></ul><p>再引入一些 “奇怪” 的运算：</p><p>对于一个 半正定/正定 的对称矩阵 $A\in S_{+}$，定义其平方根：$A^{1/2}$，因为一定能找到 $P$ 使得 $P^2=A$；</p><h2 id="5-5-Application-Use-Matrices-to-Solve-Problems"><a href="#5-5-Application-Use-Matrices-to-Solve-Problems" class="headerlink" title="5.5 Application: Use Matrices to Solve Problems"></a>5.5 Application: Use Matrices to Solve Problems</h2><ul><li><p>例如 $\vec{y}^\prime=\lambda\vec{y}$，可以看成一个求导变换 $D\vec{y}=\lambda\vec{y}$，求 $D$ 的特征向量就是 $\vec{y}$ 的解；</p></li><li><p>照片曝光的例子：数据集中有 $n$ 个数据，$\omega_{ij}\ge0$ 表示第 $i$ 和 $j$ 数据集之间的某个指标的相似性，$\omega_{ij}=\omega_{ji}$；我们想将这些数据集以这个指标 $x_i$ 衡量起来，要求相似性越高的数据，$x_i$ 的值也应该相近；</p><p>为了完成这个任务，可以定义一个目标函数 $\sum\limits_{ij}\omega_{ij}(x_i-x_j)^2$，对它最小化优化就行。</p><p>但是需要一些限制条件，防止 $x_i\equiv const$ 无意义的情况，例如 2-范数为 1 $||\vec{x}||_2^2=1$（归一化）、$\vec{1}\cdot\vec{x}=0$（指标 $x_i$ 均值为 0，方便统计）；</p><p>所以目标函数可以简化为：$2x^T(A-W)x$，其中 $W=(\omega_{ij})_{n\times n}$；找到 $A-W$ 的第二小特征值（最小特征值是 0，已经被限制条件排除了）对应的特征向量就是解。</p></li></ul><ul><li>计算 $A^k$：</li></ul><p>对一个实对称阵 $A$，假设其特征值 $\lambda_1,\ldots,\lambda_n$ 从大到小排列（$\lambda_{i+1}\ge\lambda_{i}$），那么它由实对称阵特征向量的完备性，我们可以用 $A$ 特征向量 $(x_1,\ldots,x_n)$ 来表示任意 $n$ 维向量：$A\vec{v}=c_1A\vec{x_1}+\cdots+c_nA\vec{x_n}=c_1\lambda_1\vec{x_1}+\cdots+c_n\lambda_n\vec{x_n}$（和量子力学将力学量使用它对应的算符的本征函数展开是一样的）；</p><p>因此我们发现，$A^k$ 对 $\vec{v}$ 作用的效果就取决于最大的特征值及其特征向量了：</p><p><img src="imgs2/spec.png" width="500px"></p><p>$A^k\vec{v}\approx c_1\lambda_1^k\vec{x_1},\space\text{assume that}\space c_1\ne0,\lambda_1\gt\lambda_2$（$k$ 要求足够大）；</p><blockquote><p>问题是，如果 $|\lambda_1|\gt1$ 时，$A^k\vec{v}\rightarrow\infty$，所以每次迭代都做一次归一化即可：</p><p>$\vec{\omega_k}=A\vec{v_{k-1}},\space\text{ where }\vec{\omega_{k}}=\dfrac{\vec{v_{k-1}}}{||\vec{v_{k-1}}||}$；</p><p>所以通过这个 power iteration 方法我们就能估计出 $A$ 的最大特征值；</p></blockquote><p>又注意到 $A$ 特征值的倒数，<strong>正好是</strong> $A^{-1}$ 对应的特征值：$A\vec{v}=\lambda\vec{v}\Rightarrow A^{-1}\vec{v}=\dfrac{1}{\lambda}\vec{v}$；</p><p>那么对 $A^{-1}$ 进行 power iteration，就能得到 $A$ 的最小特征值。</p><blockquote><p>$A^{-1}$ 的 power iteration 可以借助 $LU$ 分解加速。</p></blockquote><p>另外，由于正确结果收敛较慢，因此我们可以使用 “shifted inverse iteration”：</p><p>$A\vec{v}=\lambda\vec{v}\Rightarrow(A-\sigma I)\vec{v}=(\lambda-\sigma)\vec{v}$，可以得到如下的迭代过程（猜测 $\sigma_k\approx\lambda_k$）：</p><script type="math/tex; mode=display">\vec{\omega_k}=(A-\sigma_k I)^{-1}\vec{v_{k-1}},\space\vec{v_k}=\dfrac{\vec{\omega_k}}{||\vec{\omega_k}||},\space \sigma_{k+1}=\dfrac{\vec{v_{k}}^TA\vec{v_k}}{||\vec{v_k}||_2^2}</script><h2 id="5-6-Similarity-Transformations"><a href="#5-6-Similarity-Transformations" class="headerlink" title="5.6 Similarity Transformations"></a>5.6 Similarity Transformations</h2><ul><li><p>借助 QR 分解进行相似变换：$A=QR$，则 $Q^{-1}AQ=RQ$，所以可以迭代：$A_{k+1}=R_kQ_k,\space A_k=Q_kR_k$；</p><p>好的结论：$A_\infty=Q_\infty R_\infty=R_\infty Q_\infty$；</p></li></ul><h2 id="5-7-SVD-Singular-Value-Decomposition"><a href="#5-7-SVD-Singular-Value-Decomposition" class="headerlink" title="5.7 SVD (Singular Value Decomposition)"></a>5.7 SVD (Singular Value Decomposition)</h2><p>回忆一个矩阵的诱导范数：</p><script type="math/tex; mode=display">||A||=\max_{\vec{x}\ne0}\dfrac{||A\vec{x}||}{||\vec{x}||}=\max\limits_{||\vec{x}||=1}||A\vec{x}||</script><p>注意到 $||\vec{v}||=1$ 时，$||A||^2=||A\vec{v}||^2=\vec{v}A^TA\vec{v}$，因此只需要</p><p>特征值只有方阵才能讨论。有没有一种研究矩阵更普遍特征性质的分解呢？它就是奇异值分解。</p><p>可以证明，任何矩阵可以分解为：$A=U\Sigma V^{-1}$，其中 $U,V$ 为正交矩阵，$\Sigma$ 为对角矩阵（可以不是方阵）；</p><p>在物理上 $U,V$ 表示旋转变换（rotation），$\Sigma$ 表示伸缩变换（scale）；</p><p>那么 $U$、$V$ 代表什么？</p><p>我们发现：$A^TA=V(\Sigma^T\Sigma)V^T$，显然 $\Sigma^T\Sigma$ 是个对角方阵。而 $A^TA$ 有很好的性质：它是半正定、对称矩阵。</p><p>因此我们惊喜地发现，这就相当于对 $A^TA$ 完成了相似对角化。$\Sigma^T\Sigma$ 对角元存放的是 $A^TA$ 的特征值，$V$ 的列存放的是 $A^TA$ 对应的特征向量；</p><p>同理，$AA^T=U(\Sigma^T\Sigma)U^T$，所以，我们得出以下结论：</p><ul><li>$U$ 和 $V$ 分别是 $AA^T$ 和 $A^TA$ 的归一化特征向量组成的正定矩阵；</li><li>$U$ 和 $V$ 特征值<u>按序相同</u>（从大到小排列），对于实矩阵而言都大于等于 0；</li></ul><p>SVD 分解还可以写成一系列 $U,V$ 向量的外积线性组合：$A=\sum\sigma_i\vec{u_i}\vec{v_i}^T$；</p><p>SVD 可以有哪些用处？比如定义一个一般矩阵的 “伪逆”（pseudo inversion）：</p><script type="math/tex; mode=display">A^{+}=V\Sigma^{+}U^T</script><p>注意，对不一定为方阵的对角阵的伪逆：$\Sigma^{+}$ 就是将 $\Sigma$ 对角元的元素求倒数，放在对角位置，并且转置矩阵的长宽。</p><p>伪逆有一些很好的性质：</p><ul><li>当 $A$ 为可逆方阵时，$A^+=A^{-1}$；</li><li>当 $A$ 的行秩大于列秩时（overdetermined），$A^+\vec{b}$ 给出了最小二乘结果；</li><li>当 $A$ 的列秩大于行秩时（underdetermined），$A^+\vec{b}$ 给出了 $A\vec{x}\approx\vec{b}$ 的最小二乘结果；</li></ul><h3 id="5-7-1-Application-Orthogonal-Procrustes-Theorem"><a href="#5-7-1-Application-Orthogonal-Procrustes-Theorem" class="headerlink" title="5.7.1 Application: Orthogonal Procrustes Theorem"></a>5.7.1 Application: Orthogonal Procrustes Theorem</h3><p>考虑一个问题：将一组向量 $A$ 通过正交变换的方式映射到新的一组向量 $QA$，让这组新的向量与给定的一组向量 $B$ 的差异尽可能的小（使用 Frobenius 范数衡量）。这在图像处理领域比较常用。</p><p>用数学方法表达就是，求正交阵：$\hat{Q}=\arg\min\{||QA-B||_{F}\}$（易知，$A,B$ 规模相同）；</p><p>由于 Frobenius 范数可以表达为 $||C||_F=\sqrt{\mathrm{tr}(C^TC)}$，故上式可计算：</p><script type="math/tex; mode=display">\begin{aligned}\hat{Q}&=\arg\min\{\mathrm{tr}((QA-B)^T(QA-B))\}\\&=\arg\min\{\mathrm{tr}(((QA)^T-B^T)(QA-B))\}\\&=\arg\min\{\mathrm{tr}((A^TQ^T-B^T)(QA-B))\}\\&=\arg\min\{\mathrm{tr}(A^TQ^TQA-BA^TQ^T-B^TQA+B^TB)\}\\&=\arg\min\{\mathrm{tr}(A^TA+B^TB-A^TQ^TB-(A^TQ^TB)^T)\}\\&=\arg\min\{\mathrm{tr}(A^TA)+\mathrm{tr}(B^TB)-2\mathrm{tr}(A^TQ^TB)\}\\\end{aligned}</script><p>注意到前两项在确定问题时就已知，所以最小化问题直接转换为最大化问题：</p><script type="math/tex; mode=display">\begin{aligned}\hat{Q}&=\arg\max\{\mathrm{tr}(A^TQ^TB)\}\\&=\arg\max\{\mathrm{tr}(Q^TBA^T)\}\\\end{aligned}</script><p>（注意 $\mathrm{tr}(PQ)=\mathrm{tr}(QP)$）</p><p>下面利用 SVD 分解做一个巧妙变换（假设 $BA^T=U\Sigma V^T$）：</p><script type="math/tex; mode=display">\begin{aligned}\hat{Q}&=\arg\max\{\mathrm{tr}(Q^TBA^T)\}\\&=\arg\max\{\mathrm{tr}(Q^TU\Sigma V^T)\}\\&=\arg\max\{\mathrm{tr}(V^TQ^TU\Sigma)\}\\\end{aligned}</script><p>这样 $V,Q,U$ 都是正交阵，所以 $V^TQ^TU$ 也是正交阵。</p><p>可以简单地证明，$\mathrm{tr}(QA)$ 最大（$Q$ 正交阵）时，$Q=I$；</p><p>此时 $\hat{Q}^T=VU^T$，$\hat{Q}=UV^T$；</p><p>所以这里我们利用 SVD 解出了正交普鲁克定理：</p><p>当 $Q=UV^T$（其中 $BA^T=U\Sigma V^T$）时，$||QA-B||_F$ 有最小值。</p><h3 id="5-7-2-Application-Principal-Component-Analysis-PCA"><a href="#5-7-2-Application-Principal-Component-Analysis-PCA" class="headerlink" title="5.7.2 Application: Principal Component Analysis (PCA)"></a>5.7.2 Application: Principal Component Analysis (PCA)</h3><p>再考虑一个问题，对于相当大的一个数据集，它包含很多维度，我们基于以下目的需要降维：</p><ul><li>使得数据集更易使用；</li><li>降低算法的计算开销；</li><li>去除噪声；</li><li>使得结果容易理解；</li></ul><p>有一种降维方法就是主成分分析方法（PCA），其主要思想是将 $n$ 维特征映射到 $k$ 维上，这k维是全新的正交特征也被称为主成分，是在原有 $n$ 维特征的基础上重新构造出来的 $k$ 维特征；</p><p>可以证明：</p><p>最小化 $||X-CC^TX||_F$（其中 $C\in\mathbf{R^{n\times k}}$，$C^TC=I_{k\times k}$，$C$ 是 $U$ 的前 $k$ 列向量，$X=U\Sigma V^T$）取得的 $C$ 就是 $X$ 的主成分。</p><h1 id="Chapter-6-Non-linear-System"><a href="#Chapter-6-Non-linear-System" class="headerlink" title="Chapter 6. Non-linear System"></a>Chapter 6. Non-linear System</h1><h2 id="6-1-Root-Finding"><a href="#6-1-Root-Finding" class="headerlink" title="6.1 Root Finding"></a>6.1 Root Finding</h2><p>作出一些假设：</p><ul><li><p>连续性；</p><blockquote><p>连续函数满足的定理：中值定理；</p></blockquote></li><li><p>Lipschitz 特性：绝对值增长速率不快于一阶线性函数；</p></li><li><p>$k$ 阶导存在且连续；</p></li></ul><p><strong><u>方法一：二分法（bisection）</u></strong>，利用中值定理锁定根的区间（高中内容），直到根的区间小于一定范围就停止迭代。</p><ul><li><p>优点：无条件收敛（unconditionally converge）；</p><blockquote><p>收敛速度？指数速度减小。</p><p>$|x-x^*|\lt E_k$，其中 $E_k$ 为第 $k$ 轮迭代时的区间宽度（$E_k\le\dfrac{1}{2}E_{k-1},\space E_k=|r_k-l_k|$）；</p></blockquote></li><li><p>缺点：对函数性质要求严格。</p></li></ul><p><strong><u>方法二：不动点法（fixed point）</u></strong>，通过迭代求解 $g(x^<em>)=x^</em>$ 来得到 $f(x)=g(x)-x$ 的零点。</p><p>怎么迭代？方法比较多，但是常用的是最简单的策略：</p><p>simple strategy：将 $g(x_{k-1})$ 作为下一轮迭代的 $x_k$ 的值，直至 $|g(x_k)-x_k|$ 小于一定范围；</p><ul><li><p>优点：计算简单；</p></li><li><p>缺点：$g$ 必须满足 Lipschitz 特性，或者在根 $x^*$ 及迭代范围附近满足 Lipschitz 局部特性，否则迭代发散。</p><blockquote><p>对于满足 Lipschitz 特性的情况，$E_k\le cE_{k-1}$（linear）；</p><p>对于其他一般情况：$E_k=|x_k-x^<em>|=|g(x_{k-1})-g(x^</em>)|\le\dfrac{1}{2}(|g^{\prime\prime}(x^*)|+\varepsilon)E_{k-1}^2$（quadratic）； </p></blockquote></li></ul><p><strong><u>方法三：牛顿法（Newton’s method）</u></strong>，这个方法作出了一个假设，认为函数在零点附近近似线性，可以给出一个猜测值 $x_0$，求该点处切线 $l_0$，取得 $l_0$ 与 x 轴交点为 “更接近零点的点” $x_1$，重复迭代直至稳定。</p><script type="math/tex; mode=display">x_{k+1}=x_k-\dfrac{f(x_k)}{f^\prime(x_k)}</script><p>可以看作求 $g(x)=x-\dfrac{f(x_k)}{f^\prime(x_k)}$ 的不动点。</p><ul><li>优点：在简单情况下收敛很快；</li><li>缺点：<ol><li>$g$ 需要满足局部 Lipschitz 特性，否则不收敛（收敛速度和不动点法同理）；</li><li>$f^\prime(x^*)\ne0$，否则永远无法得到正确解；</li><li>某些函数难以求导数。</li></ol></li></ul><p><strong><u>方法四：割线法（secant method）</u></strong>，利用两相近点间的割线近似为切线的思想（$f^\prime(x)\approx\dfrac{f(x_1)-f(x_2)}{x_1-x_2},\space |x_1-x_2|\rightarrow0$），可以借助两次猜测的点的连线（割线）视作切线：$f^\prime(x_k)\approx\dfrac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$，结合牛顿法解决：</p><script type="math/tex; mode=display">x_{k+1}=x_k-\dfrac{f(x_k)}{f^\prime(x_k)}\approx x_k-\dfrac{f(x_k)(x_k-x_{k-1})}{f(x_k)-f(x_{k-1})}</script><ul><li>优点：计算稍微简单一点；</li><li>缺点：和牛顿法一样存在收敛问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to Rabbit MQ</title>
      <link href="//technical/rabbit-mq/"/>
      <url>//technical/rabbit-mq/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-0-背景"><a href="#Chapter-0-背景" class="headerlink" title="Chapter 0. 背景"></a>Chapter 0. 背景</h1><h2 id="0-1-同步消息和异步消息"><a href="#0-1-同步消息和异步消息" class="headerlink" title="0.1 同步消息和异步消息"></a>0.1 同步消息和异步消息</h2><p>微服务架构下存在很多服务间相互调用的情况。</p><p>我们知道可以通过 <code>OpenFeign</code> 的方式来获取远程服务的响应，但是 <code>OpenFeign</code> 的远程调用是同步的，其优点是同步调用时效强，等待结果返回。但同时会导致：</p><ul><li>代码可扩展性差。</li><li>性能堪忧。相较于相同项目实现的单体架构，同步的微服务调用方式会多出网络等待时间。</li></ul><p>于是我们需要异步调用的方式，这里使用到了<strong>发布-订阅者模式</strong>。</p><p>异步调用的优势是，</p><ul><li>模块间进一步解耦（发布者和订阅者间无需知道相互之间的信息）；</li><li>可拓展性强（scalable），添加实例无需更改代码；</li><li>异步性能有明显提升；</li><li>故障隔离（<strong><u>最终一致性保证</u></strong>）；</li><li>缓存消息，实现流量削峰填谷；</li></ul><p>但是缺点也很明显：</p><ul><li>异步实现无法立即得到结果，时效性差，可能导致数据不一致性；</li><li>不作额外措施，则不能保证最终一致性（下游业务是否成功）。所以业务安全依赖于 broker 的可靠性；</li></ul><h2 id="0-2-Message-Queue-选型"><a href="#0-2-Message-Queue-选型" class="headerlink" title="0.2 Message Queue 选型"></a>0.2 Message Queue 选型</h2><div class="table-container"><table><thead><tr><th>Opt</th><th>RabbitMQ</th><th>ActiveMQ</th><th>RocketMQ</th><th>Kafuka</th></tr></thead><tbody><tr><td>Company</td><td>Rabbit（专一，社区极活跃）</td><td>Apache（大厂支持）</td><td>Alibaba（开源冲业绩）</td><td>Apache</td></tr><tr><td>Language</td><td>Erlang（面向并发的语言）</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>Protocol Support</td><td>AMQP,XMPP,SMTP,STOMP</td><td>OpenWire,STOMP,REST,XMPP,AMQP</td><td>私有协议，只能被 Java 调用（微服务语言限制）</td><td>私有协议</td></tr><tr><td>Availability</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>Monolith Throughput（ops）</td><td>一般（数十万上下）</td><td>差</td><td>高（数十万）</td><td>极高（近数百万）</td></tr><tr><td>Latency</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>Reliability</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table></div><p>可以看出：</p><ul><li><p><code>Kafuka</code> 牺牲了部分可靠性（只确保最终一致性）、消息延迟，换取了极高的消息吞吐量。在对消息准确性要求不高（如日志传输）的情况下推荐；</p></li><li><p><code>RocketMQ</code> 虽然功能丰富，但是 <code>Alibaba</code> 的开源项目大多属于冲业绩，文档和社区支持不佳。</p><p>此外 <code>RocketMQ</code> 依赖于很多 <code>Alibaba</code> 技术栈，如果项目中不打算或者没有 <code>Alibaba</code> 的依赖，那么引入困难；</p><p>另外 <code>RocketMQ</code> 不支持主流协议，只支持他们自己的一套接口，微服务语言局限于 Java；</p></li><li><p><code>ActiveMQ</code> 是早期的项目，指标不如后辈；</p></li></ul><p>因此我们选择 <code>RabbitMQ</code>。</p><h1 id="Chapter-1-Introduction-to-RabbitMQ"><a href="#Chapter-1-Introduction-to-RabbitMQ" class="headerlink" title="Chapter 1. Introduction to RabbitMQ"></a>Chapter 1. Introduction to <code>RabbitMQ</code></h1><h2 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 架构</h2><p><img src="imgs/arch2.png"></p><ul><li><p><code>queue</code>：暂时存储消息的消息队列；队列有两类：</p><ul><li><p>durable queue：持久化队列，信息会被定期持久化到磁盘。这种队列可以提升可靠性，但是会降低性能；</p></li><li><p>non-durable queue：非持久化队列，信息总是保存在内存中。这种队列的速度会快于 durable queue，但是可靠性无法保证（例如不保证掉电不丢失数据）；</p></li></ul></li><li><p><code>virtual host</code>：虚拟主机，起到不同项目数据隔离作用；</p></li><li><p><code>exchange</code>：路由消息的交换机。其作用是接受发布者发送的消息，并将接收到的消息<strong><u>按照交换机的配置</u></strong>路由到所有与其绑定的队列中。本身不具备消息暂存能力；</p><p>交换机的配置（种类，或者说<strong>路由策略</strong>）大致有几种：</p><ul><li><p><code>Fanout</code>（广播）：<code>Fanout</code> 交换机。会将自身接受到的消息批量路由到<strong>所有与之关联的</strong>消息队列中；</p></li><li><p><code>Direct</code>（定向）：<code>Direct</code> 交换机。这种交换机 与 消息队列的关联时需要额外指定一个 <code>bindingKey</code>，并且发布者在向该种交换机发送消息时，必须指定 <code>routingKey</code>。</p><p>于是这种交换机只会将接受到的消息发送给 <code>bindingKey</code> 与这条消息的 <code>routingKey</code> 相同的消息队列中；</p><blockquote><p><code>bindingKey</code> 不要求对于交换机唯一。所以理论上 <code>Direct</code> 交换机的功能覆盖了 <code>Fanout</code> 交换机。</p></blockquote></li><li><p><code>Topic</code>（话题，类似 <code>Kafuka</code> 的按 Topic 订阅）：与 <code>Direct</code> 交换机类似，也以 <code>bindingKey</code> 和 <code>routingKey</code> 为路由依据，但：</p><ul><li><code>bindingKey</code> 这里是 topic，可以使用通配符：<code>#</code> 代表 0 到多个 topic，<code>*</code> 代表 1 个 topic；</li><li><code>routingKey</code> 可以是 topic 的组合，使用 <code>.</code>（period）隔开；</li></ul></li><li><p><code>Headers</code>（请求头）：<code>Headers</code> 交换机，</p></li></ul></li></ul><p>注意，交换机 和 消息队列间的关联需要显式声明 / 配置。</p><h2 id="1-2-Spring-AMQP"><a href="#1-2-Spring-AMQP" class="headerlink" title="1.2 Spring AMQP"></a>1.2 Spring <code>AMQP</code></h2><p><code>RabbitMQ</code> 支持多种协议，其中就包括 <code>AMQP</code>（Advanced Message Queuing Protocol），其他各种语言都有各自的 <code>AMQP</code> 的实现库。</p><p>为了方便起见，在 Spring 项目中常常使用 Spring 框架中实现好的 <code>AMQP</code> 协议接口来完成任务。</p><blockquote><p><code>spring-boot-starter-amqp</code> 依赖内部提供了针对 <code>AMQP</code> 协议的实现，只需引入该依赖即可操作 <code>RabbitMQ</code>；</p><p>引入后需要进行一些配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">virtual-host:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure></blockquote><ul><li>最简单使用：<code>RabbitTemplate.convertAndSend</code> &amp; <code>@RabbitListener</code>；</li></ul><h3 id="1-2-1-Working-Queues-模型"><a href="#1-2-1-Working-Queues-模型" class="headerlink" title="1.2.1 Working Queues 模型"></a>1.2.1 Working Queues 模型</h3><p>Working Queues 模型：多个消费者绑定到一个队列，共同消费队列中的消息；</p><ul><li>结论 1：队列中的消息<strong><u>最多只能被消费一次</u></strong>；所以多个 consumer 监听的情况下，一个消息被某个 consumer 消费后，不会存在于消费队列中被其他 consumer 消费（不存在消息重复）；</li><li>结论 2：队列传递给所有监听它的消费者的<strong><u>默认行为</u></strong>是绝对平均（<strong>轮询</strong>）的，没有考虑到各个机器消费消息的性能（可以用 <code>Thread.sleep</code> 测试）；</li></ul><p>为了改善这个模型下出现的问题，我们可以对这个默认的轮询机制调优：<u>规定每个消费者一次只能获取一条消息，处理完成后才能获取下一条消息</u>；</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在消费者（使用 `@RabbitListener` 注解）所在的模块中配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-Fanout-Exchange"><a href="#1-2-2-Fanout-Exchange" class="headerlink" title="1.2.2 Fanout Exchange"></a>1.2.2 <code>Fanout</code> Exchange</h3><p>为什么需要广播交换机？考虑一个问题，假设一个发布者发布消息后，我们的业务逻辑要求同时有多个其他服务需要接收这个消息并且执行相应逻辑。举个例子，<code>consumer1</code> 和 <code>consumer2</code> 需要在 <code>publisher</code> 发送消息后各自接收一次消息（也就是都执行一次业务逻辑）。</p><p>如果没有广播交换，那么发布者发布的消息在全局范围内只能被一个消费者消费，这就没法实现多个服务都接受到发布者消息的需求了。</p><p>在这种需求下，我们只需要为每个微服务建立一个消息队列，并且对应监听；将这些队列与一个公共的 <code>fanout</code> 交换机关联，就能完成上面的需求。如下图所示：</p><p><img src="imgs/fanout.png"></p><blockquote><p>代码中，如果使用了 <code>fanout</code> 交换机，那么 <code>routingKey</code> 可以指定为空字符串 / <code>null</code>；</p></blockquote><h3 id="1-2-3-Direct-Exchange"><a href="#1-2-3-Direct-Exchange" class="headerlink" title="1.2.3 Direct Exchange"></a>1.2.3 <code>Direct</code> Exchange</h3><ul><li>路由交换机需要与消息队列以 <code>bindingKey</code> 绑定；一个交换机和一个消息队列可以绑定多个 <code>bindingKey</code>；</li><li><p><code>bindingKey</code> 和 <code>routingKey</code> 不存在通配符；</p></li><li><p>路由直接发送到 <code>bindingKey == routingKey</code> 的消息队列中；</p></li></ul><h3 id="1-2-4-Topic-Exchange"><a href="#1-2-4-Topic-Exchange" class="headerlink" title="1.2.4 Topic Exchange"></a>1.2.4 <code>Topic</code> Exchange</h3><ul><li>路由交换机需要与消息队列以 <code>bindingKey</code> 绑定；</li><li><code>bindingKey</code> 允许通配符，<code>#</code> 表示任意 0 至多个 topic，<code>*</code> 表示任意一个；</li><li>路由发送到所有匹配的消息队列中；</li></ul><h3 id="1-2-5-Spring-AMQP-声明交换机-amp-队列"><a href="#1-2-5-Spring-AMQP-声明交换机-amp-队列" class="headerlink" title="1.2.5 Spring AMQP 声明交换机 &amp; 队列"></a>1.2.5 Spring <code>AMQP</code> 声明交换机 &amp; 队列</h3><ul><li><code>Queue</code> 声明队列的类，也可以使用 <code>QueueBuilder</code> 工厂类创建；</li><li><code>Exchange</code> 声明交换机的类，也可以使用 <code>ExchangeBuilder</code> 工厂类创建；</li><li><code>Binding</code> 声明队列和交换机的绑定关系，<code>BindingBuilder</code>（常用）；</li></ul><h4 id="Method-1-Spring-Bean-Configuration-式声明"><a href="#Method-1-Spring-Bean-Configuration-式声明" class="headerlink" title="Method 1. Spring Bean Configuration 式声明"></a>Method 1. Spring Bean Configuration 式声明</h4><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通常在 consumer 段声明，因为 consumer 更需要关注交换机和队列的生成 */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* 构造函数为名称 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;test.fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/* 等价于： */</span></span><br><span class="line">        <span class="comment">/* return ExchangeBuilder.fanoutExchange(&quot;test.fanout&quot;).build(); */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;test.queue1&quot;</span>);</span><br><span class="line">        <span class="comment">/* 等价于（默认 durable queue）： */</span></span><br><span class="line">        <span class="comment">/* return QueueBuilder.durable(&quot;test.queue1&quot;).build(); */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;test.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 自动注入 queue 和 exchange，从上面的 bean 寻找，采用 autowired-by-name 策略 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue</span><span class="params">(Queue fQueue1, FanoutExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fQueue1).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue</span><span class="params">(Queue fQueue2, FanoutExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fQueue2).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-2-Listener-注解式声明"><a href="#Method-2-Listener-注解式声明" class="headerlink" title="Method 2. Listener 注解式声明"></a>Method 2. Listener 注解式声明</h4><p>显然这种方法非常麻烦，主要有以下的问题：</p><ul><li><p>每个方法大同小异，大部分是 boilerplate code；</p></li><li><p>定义步骤相当繁琐每定义一个队列、交换机或者绑定关系，就要新建一个方法；</p></li><li>很多队列或者交换机的 bean，只能通过 <code>autowired-by-name</code> 的方法注入，降低了代码可读性和可维护性；</li></ul><p>于是可以使用另一种定义方式，直接使用 <code>@RabbitListener</code> 提供的 <code>bindings</code> 参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(</span></span><br><span class="line"><span class="meta">    bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &lt;Queue Name&gt;, [durable = &quot;true&quot; | &quot;false&quot;]),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &lt;Exchange Name&gt;, type = ExchangeTypes.?),</span></span><br><span class="line"><span class="meta">        key = &#123; /* bindingKeys [String Array] */ &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><p>只需要声明一个注解即可定义队列、交换机、绑定关系；</p><p>但是上面的 Method 2 可能还是有问题：</p><ul><li><p>配置散落在业务代码中，没有与业务逻辑解耦；</p></li><li><p>这么写可能存在 queue / exchange 重复定义的问题，而且需要保证每次声明同样对象的配置一致。降低了可维护性和可扩展性；</p></li><li>在每个方法前面写这么大段注解，降低代码可读性；</li></ul><p>有什么办法解决吗？可以综合 Method 1 使用 ~</p><h3 id="1-2-6-Spring-AMQP-消息转换器"><a href="#1-2-6-Spring-AMQP-消息转换器" class="headerlink" title="1.2.6 Spring AMQP 消息转换器"></a>1.2.6 Spring <code>AMQP</code> 消息转换器</h3><p>注意，到目前为止，我们没有讨论过队列传输的对象是 <code>POJO</code> 或者是更复杂的 Java 对象的情况。</p><p>我们知道如果传输的是简单的 Java String，则 <code>RabbitMQ</code> 直接在队列上传输字符串；但是对于一般的 Java 对象，<code>RabbitMQ</code> 会使用 Java 内置的序列化实现将对象转为 Java Serializable Object；</p><p>我们跟踪 Spring <code>RabbitTemplate</code> 源码发现，内部对 <code>Object</code>（传递的信息）执行了 <code>convertMessageIfNecessary</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">protected</span> Message <span class="title function_">covertMessageIfNecessary</span><span class="params">(<span class="keyword">final</span> Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Message) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Message) object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getRequiredMessageConverter().toMessage(object, <span class="keyword">new</span> <span class="title class_">MessageProperties</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure><p><code>Message</code> 类型是 <code>AMQP</code> 定义的接口，定义了帮助 <code>AMQP</code> 传输消息的方法。</p><p>我们进一步了解发现 <code>getRequiredMessageConverter()</code> 方法是获取 <code>RabbitTemplate</code> 的实例属性 <code>messageConverter</code>，<strong>其类型是 <code>MessageConverter</code>，默认实现是 <code>SimpleMessageConverter</code></strong>；</p><p>再查看 <code>MessageConverter</code> 的接口实现可以发现 Spring 中存在很多实现，例如 <code>Jackson2XmlMessageConverter / Jackson2JsonMessageConverter / ...</code>；</p><p>那么这些 converter 具体是如何将一般的 <code>Object</code> 转换为 <code>Message</code> 的呢？</p><p>我们找到 <code>MessageConverter</code> 接口的 <code>toMessage()</code> 方法，发现其在 <code>SimpleMessageConverter</code> 中的实现如下：</p><p><img src="imgs/smc-createMessage.png"></p><p>注意到，对于非空非 <code>byte[] / String</code> 类型的可序列化对象，<code>SimpleMessageConverter</code> 会直接将对象序列化（默认 Java 的对象流 <code>ObjectOutputStream</code>）。</p><p>这样做一般情况下没什么，但是在消息中间件中不建议使用，具体有以下几点原因：</p><ul><li><code>JDK</code> 的 <code>ObjectOutputStream</code> 本身存在安全风险（可以轻松反序列化并且进行代码注入）；</li><li><code>JDK</code> 的对象数据流大小往往很大，存放了一些并不需要传输的数据（几个 byte 的数据可能被序列化成几百个 byte 的数据，降低了传输性能，限制了消息吞吐量）；</li></ul><p>这里建议使用 <code>Jackson2JsonMessageConverter</code>。我们只需要在发送模块书写一个 <code>Bean</code> 配置类，然后让 Spring Boot 自动装配即可。</p><blockquote><p>确保引入依赖 <code>com.fasterxml.jackson.core:jackson-databind</code>；</p></blockquote><h2 id="1-3-Spring-AMQP-实战：消息中间件替换-OpenFeign-同步远程调用"><a href="#1-3-Spring-AMQP-实战：消息中间件替换-OpenFeign-同步远程调用" class="headerlink" title="1.3 Spring AMQP 实战：消息中间件替换 OpenFeign 同步远程调用"></a>1.3 Spring <code>AMQP</code> 实战：消息中间件替换 <code>OpenFeign</code> 同步远程调用</h2><blockquote><p>小贴士：如果设置了消费者确认机制并且使用 <code>auto</code> 模式，使用 <code>@RabbitListener</code> 注解的函数返回类型必须是 <code>void</code>。否则 RabbitMQ 会认为 consumer 执行错误。</p></blockquote><h1 id="Chapter-2-MQ-进阶：消息可靠性"><a href="#Chapter-2-MQ-进阶：消息可靠性" class="headerlink" title="Chapter 2. MQ 进阶：消息可靠性"></a>Chapter 2. MQ 进阶：消息可靠性</h1><p>使用 Spring <code>AMQP</code> 进行服务间异步通信可能存在一些问题：</p><ul><li>消息发布方网络丢包，导致消息丢失；</li><li>消息被 MQ 正确接受到后，MQ 宕机导致消息丢失；或者消费者速度较低，MQ 产生内存中的消息积压（内存占满的刷盘期间）可能造成消息丢失；</li><li>在 MQ 发送给消息消费方时，消费方宕机导致消息丢失；</li></ul><p>因为网络的不可靠性，即便我们针对上述问题进行保护措施，仍然可能出现一些问题。我们最终需要一些兜底的机制，至少需要确保消息的最终一致性。</p><p>接下来将会以 RabbitMQ 为例，从上面 4 个角度分析 MQ 如何保证消息的可靠性。</p><h2 id="2-1-消息发布方的可靠性：重连与确认机制"><a href="#2-1-消息发布方的可靠性：重连与确认机制" class="headerlink" title="2.1 消息发布方的可靠性：重连与确认机制"></a>2.1 消息发布方的可靠性：重连与确认机制</h2><h3 id="2-1-1-发送者重连-性能警告"><a href="#2-1-1-发送者重连-性能警告" class="headerlink" title="2.1.1 发送者重连 [性能警告]"></a>2.1.1 发送者重连 [性能警告]</h3><p>发送者重连，在 MQ 与消息发布方连接后，存在连接断开的情况，这可能导致发布方网络丢包；因此需要 MQ 和服务发布方在网络丢失后进行重连，特别地，在 RabbitMQ 中需要<strong><u>在消息发送方</u></strong>进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">connection-timeout:</span> <span class="string">1s</span><span class="comment"># MQ 连接超时时间（连接等待多长时间才算失败，失败后才进行重连）</span></span><br><span class="line">        <span class="attr">template:</span></span><br><span class="line">            <span class="attr">retry:</span></span><br><span class="line">                <span class="attr">enable:</span> <span class="literal">true</span><span class="comment"># 消息重连（默认 false）</span></span><br><span class="line">                <span class="attr">initial-interval:</span> <span class="string">1000ms</span><span class="comment"># 连接失败/断开后的初识等待时间（立即尝试的成功概率小）</span></span><br><span class="line">                <span class="attr">multiplier:</span> <span class="number">1</span><span class="comment"># 尝试等待时间倍数（下次等待时间为上次的倍数。第二次相对于 initial-interval）</span></span><br><span class="line">                <span class="attr">max-attempts:</span> <span class="number">3</span><span class="comment"># 最大尝试次数</span></span><br></pre></td></tr></table></figure><p>但是这种机制是<strong>阻塞式重连</strong>，对业务性能会造成影响，这也是为什么 <code>retry</code> 默认配置是禁用的。如果必须要使用，也需要合理设置超时、等待时长，以及尝试次数；</p><h3 id="2-1-2-发送者确认-性能警告"><a href="#2-1-2-发送者确认-性能警告" class="headerlink" title="2.1.2 发送者确认 [性能警告]"></a>2.1.2 发送者确认 [性能警告]</h3><p>发送者确认：Spring <code>AMQP</code> 提供了 Publish Confirm（消息确认反馈）和 Publisher Return（路由错误返回信息）两种机制。</p><p><strong>在发送者确认机制打开后，当消息发布方向 MQ 发送一条消息，MQ 会返回<u>确认结果</u>给发送方</strong>，确认结果分为以下几种情况：</p><ul><li><p>消息成功投递到 MQ 中，但是路由失败：MQ 通过 Publisher Return 返回路由错误原因，返回 <code>ACK</code> 告知投递成功；</p><blockquote><p>这种情况只可能是：exchange 没有绑定队列 / routing key 没有匹配队列，是开发者原因。与网络、发送方、MQ 都没有关系，所以认为投递成功。</p><p>这种情况重新发送消息是没有意义的，因为错误不会因为重试而修复。</p></blockquote></li><li><p><strong><u>临时消息</u></strong>投递到 MQ 中，且成功入队；MQ 反馈 <code>ACK</code> 告知投递成功；</p><blockquote><p>临时消息对于队列是否是 <code>durable</code> 的没有要求，只要投递到 MQ 中，并且进入队列内存，就算成功；</p></blockquote></li><li><p><strong><u>持久消息</u></strong>投递到 MQ 中，且成功入队，且成功持久化；MQ 反馈 <code>ACK</code> 告知投递成功；</p><blockquote><p>持久消息需要被 MQ 放入 durable 队列中，并且持久化才算投递成功，这样可以防止 MQ 宕机造成消息丢失。</p><p>同时这可能损失一部分性能，所以应该根据业务逻辑来选择持久消息或临时消息。</p></blockquote></li><li><p>其他任何情况都会反馈 <code>NACK</code>，表示投递失败。<strong><u>只有在这种情况下，进行消息重发是正确的、有意义的</u></strong>；</p></li></ul><p>以 RabbitMQ 为例，开启发送者确认机制需要<strong><u>在消息发送方</u></strong>进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span><span class="comment"># 开启 Publish Confirm 机制，指定模式类型</span></span><br><span class="line">        <span class="attr">publish-return:</span> <span class="literal">true</span><span class="comment"># 开启 Publish Return 机制</span></span><br></pre></td></tr></table></figure><p>所谓 Publish Confirm 只包含了 <code>ACK / NACK</code> 的消息，而 Publish Return 则<strong>回调上面第一种投递成功，但路由失败的失败信息</strong>。</p><p>Publish Confirm 的 3 种模式分别为：</p><ul><li><code>none</code>：关闭 Publish Confirm 机制；</li><li><code>simple</code>：同步阻塞等待 MQ 的确认；</li><li><code>correlated</code>：MQ 异步回调方式确认；</li></ul><p>那么如何配置 MQ 的异步回调（confirm callback 和 return callback）？</p><p>事实上，一个 <code>RabbitTemplate</code> 只能配置一个 Return Callback（<strong>需要启用 Publish Return 机制</strong>）。所以需要在 Spring 项目启动过程中配置一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在构造函数完成后执行一次 */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">            <span class="comment">/* RabbitTemplate.ReturnsCallback 是一个函数接口 */</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnMessage</span><span class="params">(ReturnedMessage msg)</span> &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Return callback triggered.&quot;</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                    log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                    log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                    log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                    log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于单条消息而言还有 Confirm Callback（<strong>需要启用 Publish Confirm 机制</strong>），这在每条消息发送前都需要配置一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 CorrelationData，包含消息的全局 ID（MQ 需要区别消息以发送 confirm 或 return）</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(</span><br><span class="line">        UUID.randomUUID().toString()<span class="comment">/* 注：UUID 可能存在性能问题和 MAC 地址安全问题 */</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 2.给 Future 添加 ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(</span><br><span class="line">        <span class="comment">/* ListenableFutureCallback 是一个含有 onFailure 和 onSuccess 的接口 */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">                <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">                log.error(<span class="string">&quot;handle message ack fail&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 请类比 JavaScript 的 Promise，思考为什么即便是投递失败也在 onSuccess 中 */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">                <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">                <span class="keyword">if</span> (result.isAck()) &#123;</span><br><span class="line">                    <span class="comment">// result.isAck()，boolean类型</span></span><br><span class="line">                    <span class="comment">// true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                    log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                    log.error(</span><br><span class="line">                        <span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason()</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;test.direct&quot;</span>, <span class="string">&quot;red1&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要提一点，发送确认也会对性能有较大影响。而且发送丢包的概率较低，所以只建议在亟需确保数据可靠性的极端情况下才需要如此配置。</p><h2 id="2-2-MQ-的可靠性"><a href="#2-2-MQ-的可靠性" class="headerlink" title="2.2 MQ 的可靠性"></a>2.2 MQ 的可靠性</h2><p>如上所述，MQ 可能丢失消息的场景有两类：</p><ul><li>消息被 MQ 正确接受到后，MQ 宕机导致消息丢失；</li><li>消费者速度很低，MQ 产生内存中的消息积压阻塞（内存占满的刷盘期间无法继续入队）可能造成消息丢失；</li></ul><p>具体有两种思路可以解决，一是数据持久化策略，二是 Lazy Queue；</p><h3 id="2-2-1-MQ-的数据持久化-默认"><a href="#2-2-1-MQ-的数据持久化-默认" class="headerlink" title="2.2.1 MQ 的数据持久化 [默认]"></a>2.2.1 MQ 的数据持久化 [默认]</h3><ul><li><p>交换机持久化、队列持久化（默认都是 durable）；</p><blockquote><p>交换机、队列的持久化，是指交换机 / 队列自身的信息也会持久化在磁盘中；</p></blockquote></li><li><p>消息持久化。我们在之前提到，临时消息不会被 MQ 保证持久化到磁盘中，意味着这类消息在掉电后可能丢失。所以如果对一类消息的正确性要求很高，需要将消息设置为持久消息：</p><p>由于 <code>RabbitTemplate</code> 默认的 <code>convertAndSend</code> 方法中的 message converter 都默认构建 Message 为持久的消息，因此我们需要手动构建才能得到临时消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">    .withBody(<span class="string">&quot;Hello, Spring AMQP&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">    .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>如果使用大量数据实验会发现，大量、快速发送临时消息（不会主动刷盘）会不断在内存中积压，其触发的 Page Out（泛指内存耗尽触发的被动刷盘操作）会像数据结构 LSM Tree 的 compaction 操作一样短时间内迅速降低 MQ 的吞吐量，形成一个个性能低谷，总体性能反而小于持久数据（一开始就进行刷盘操作）；</p></li></ul><h3 id="2-2-2-Lazy-Queue-默认"><a href="#2-2-2-Lazy-Queue-默认" class="headerlink" title="2.2.2 Lazy Queue [默认]"></a>2.2.2 Lazy Queue [默认]</h3><p>在 Rabbit MQ 3.12 以后，所有队列默认 Lazy Queue 且无法更改。</p><p>Lazy Queue 的特征是，</p><ul><li>接收到消息后直接存入磁盘，不再存储到内存；</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（可以提前缓存部分消息到内存，最多2048条）；</li></ul><h2 id="2-3-消费者的可靠性"><a href="#2-3-消费者的可靠性" class="headerlink" title="2.3 消费者的可靠性"></a>2.3 消费者的可靠性</h2><h3 id="2-3-1-消费者确认机制"><a href="#2-3-1-消费者确认机制" class="headerlink" title="2.3.1 消费者确认机制"></a>2.3.1 消费者确认机制</h3><p>Spring <code>AMQP</code> 同样存在一种机制，即消费者确认机制（Consumer Acknowledgement）。</p><p>它是为了确认消费者是否成功处理消息。当消费者处理消息结束后，应该向 Rabbit MQ 发送一个回执，告知 Rabbit MQ 自己消息处理状态：</p><ul><li><code>ACK</code>：成功处理消息，Rabbit MQ 从队列（内存以及磁盘）中删除该消息；</li><li><code>NACK</code>：消息处理失败，Rabbit MQ 需要再次投递消息；</li><li><code>REJECT</code>：消息处理失败并拒绝该消息，Rabbit MQ 从队列（内存以及磁盘）中删除该消息；</li></ul><p>这个回执应该在消费者关于该消息所有业务逻辑处理完成后，才能返回，防止出错后无法重试。</p><p>这样的操作非常类似 事务机制。</p><p>Spring <code>AMQP</code> 已经实现了消息确认功能。并允许我们通过配置文件选择ACK处理方式：</p><ul><li><p><code>none</code>：不处理。即消息投递给消费者后立刻 <code>ACK</code>，消息会立刻从 MQ 删除。非常不安全，不建议使用；</p></li><li><p><code>manual</code>：手动模式。需要自己在业务代码中调用 API，发送 <code>ACK</code> 或 <code>REJECT</code>，存在业务入侵，但更灵活；</p></li><li><p><code>auto</code>：自动模式。Spring <code>AMQP</code> 利用 <code>AOP</code> 对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回 <code>ACK</code>.  当业务出现异常时，根据异常判断返回不同结果：</p><ul><li><p>如果是业务异常，会自动返回 <code>NACK</code>，消息会重新进入 <code>Ready</code> 状态投递给对应消费者（重新处于 <code>Ready</code> 状态）；</p><blockquote><p>消费者宕机、抛出 <code>RuntimeException</code> / 其他自定义异常，都认为是 <code>NACK</code>；</p></blockquote></li><li><p>如果是消息处理或校验异常（需要抛出例如 <code>MessageConversionException</code>），自动返回 <code>REJECT</code>；</p><blockquote><p>这就提醒我们，遇到业务逻辑中的格式异常，请不要 throw <code>RuntimeException</code>，不然会被 Spring 认为是业务异常而重新发送！</p></blockquote></li></ul></li></ul><p>我们需要在消息消费方配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">acknowledge-mode:</span> <span class="string">none</span><span class="comment"># 默认不处理，</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2-消费者失败重试机制"><a href="#2-3-2-消费者失败重试机制" class="headerlink" title="2.3.2 消费者失败重试机制"></a>2.3.2 消费者失败重试机制</h3><p>在引入消费者确认机制后，还会出现一个问题：如果 MQ 中积压的消息量过大，导致消费方宕机，在消费者恢复后，没有进行请求热身，MQ 又重发了大量的消息，很有可能会再次导致消费方再次宕机。</p><p>这会给消费方和 MQ 都造成极大的压力。</p><p>为了应对这种情况，MQ 引入了另一种机制来保障消费方的消息可靠性：消费者失败重试机制。在消费者出现异常时按照配置重试，而不是无限的重复入队。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">retry:</span><span class="comment"># 注：发送方重试位于 template 下</span></span><br><span class="line">                    <span class="attr">enabled:</span> <span class="literal">true</span><span class="comment"># 默认 false</span></span><br><span class="line">                    <span class="attr">initial-interval:</span> <span class="string">1000ms</span><span class="comment"># 失败初始等待时间</span></span><br><span class="line">                    <span class="attr">multiplier:</span> <span class="number">1</span></span><br><span class="line">                    <span class="attr">max-attempts:</span> <span class="number">3</span></span><br><span class="line">                    <span class="attr">stateless:</span> <span class="literal">true</span><span class="comment"># 如果业务中含有事务，说明这种消息重递是有状态的，应该 false</span></span><br></pre></td></tr></table></figure><p>在重试超过 <code>max-attempts</code> 后，消息状态转变为 requeue-exhausted，进而转入 <code>MessageRecoverer</code> 中处理。</p><p>Spring <code>AMQP</code> <strong>默认的 <code>MessageRecoverer</code> 的实现是 <code>RejectAndDontRequeueRecoverer</code></strong>，其策略是直接丢弃这条消息，这样做有失消费者安全性。</p><p>除了默认的 recoverer，还有两种：</p><ul><li><p><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，仍然认为返回 <code>NACK</code>，重新入队；</p><blockquote><p>这种策略和不采取失败者重试的策略相比，性能影响会小一点；</p></blockquote></li><li><p><code>RepublishMessageRecoverer</code>：重试耗尽后，将消息（<strong>包括报错信息</strong>）投递到指定交换机，以供其他处理用途；</p><blockquote><p>这种策略也比较合理，认为反复投递无效就应该换一种处理方式。</p><p>但这种方法需要专门配置一个指定的交换机：</p><ul><li>定义接受失败队列、与其绑定的交换机；</li><li>定义 <code>RepublishMessageRecoverer</code> 的 Bean（传入 <code>RabbitTemplate</code>、交换机、队列名称）；</li></ul></blockquote></li></ul><p>这种机制虽然相较于原先确认机制而言，降低了可靠性，但是一定程度上提升了服务的可用性，降低多次/长时间宕机造成的资源浪费风险。</p><h2 id="2-4-业务幂等性保证"><a href="#2-4-业务幂等性保证" class="headerlink" title="2.4 业务幂等性保证"></a>2.4 业务幂等性保证</h2><p>在上面的过程中，有一种情况我们没有考虑：如果消费者的接口不是幂等的，就需要保证消息发送的不重复性。</p><p>也就是说，<strong>假设消费者收到消息后并且处理结束，要给 MQ 发送 <code>ACK</code> 时连接断开了（或者两方有一方宕机了），就可能会导致 MQ 消息重新发送</strong>。这个问题没办法借助 MQ 来解决，因为不是 MQ 本身的问题。</p><p>那么应该如何处理这种情况？</p><h3 id="2-4-1-唯一消息-ID"><a href="#2-4-1-唯一消息-ID" class="headerlink" title="2.4.1 唯一消息 ID"></a>2.4.1 唯一消息 ID</h3><p>第一种思路是唯一消息 ID：给每个消息都设置一个唯一 ID，利用 ID 区分是否是重复消息。</p><ul><li>每一条消息都生成一个唯一的 ID，与消息一起投递给消费者；</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息 ID 保存到数据库；</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ul><blockquote><p>Tips. 这和之前提到的发送者确认机制中创建的 <code>CorrelationData</code> 中的 ID 不一样，前者是作回执用的 ID，它和消费 ID 可以保持消费不一致；</p></blockquote><p>我们可以在定义消息转换器时显式声明让 MQ 创建全局唯一的 Message ID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageCoverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    jmc.setCreateMessageIds(<span class="literal">true</span>);    <span class="comment">/* 默认 false */</span></span><br><span class="line">    <span class="keyword">return</span> jmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Message ID 会存放在 Message 的 Properties 中（不是我们常用的 Payload 中），所以需要我们单独去取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 都需要转换，所以直接使用 Message 类型接收，就能收到 properties 数据 */</span></span><br><span class="line"><span class="meta">@RabbitListener(/* ... */)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    message.getBody();     <span class="comment">/* 返回 byte[] */</span></span><br><span class="line">    message.getMessageProperties();    <span class="comment">/* MessageProperties */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>byte[]</code> 中如果原来是字符串，则可以直接用字符串构造函数构造；</p><p>如果是 自定义的对象，并且使用了 <code>Jackson2JsonMessageConverter</code>，直接用配套的 <code>ObjectMapper</code> 解析就行；</p></li><li><p><code>MessageProperties.getMessageId()</code> 就能获取其中的 <code>message-id</code> 属性（如果有）；</p></li></ul><p>缺点：</p><ul><li><p>业务逻辑嵌入和耦合。给业务引入了原本不需要的逻辑，造成耦合；</p></li><li><p>数据库写影响原本业务性能；</p></li></ul><h3 id="2-4-2-业务逻辑本身判断"><a href="#2-4-2-业务逻辑本身判断" class="headerlink" title="2.4.2 业务逻辑本身判断"></a>2.4.2 业务逻辑本身判断</h3><p>上面的方法虽然通用，但是是侵入式的解决方案。如果业务逻辑允许，我们可以根据原有的业务逻辑判断这次消息是否被处理过。</p><blockquote><p>相当于做了非幂等业务的保护流程。</p><p>例如对于订单业务，如下图，如果在交易服务中的 “标记订单为已支付”，如果用户在支付成功后，“标记订单已支付” 以及完成，正在向 MQ 发送 <code>ACK</code> 时断开连接。此时 MQ 认为消费者未收到。</p><p>如果用户此时发起了退款，交易服务立即更改为退款中，此后 MQ 的连接又恢复了，如果不作处理，则 “已支付” 的状态会覆盖 “退款中” 的状态。</p><p><img src="imgs/pe-example.png" width="400px"></p><p>这种情况除了使用 Message ID 的方法，还可以直接检查 “标记订单已支付” 之前的订单状态，毕竟根据业务逻辑，只有未支付的订单才会需要标记成已支付：</p><p><img src="imgs/pe-example-sol.png" width="600px"></p></blockquote><p> 总结一下：</p><p>如何保证支付服务与交易服务之间的订单状态一致性？</p><ul><li><p>首先，支付服务会正在用户支付成功以后利用 MQ 消息通知交易服务，完成订单状态同步；</p></li><li><p>其次，为了保证 MQ 消息的可靠性，我们采用了发送者确认机制、消费者确认、消费者失败重试等策略，确保消息投递和处理的可靠性。同时也开启了 MQ 的持久化，避免因服务宕机导致消息丢失；</p><blockquote><p>保证消费者至少消费一次。</p></blockquote></li><li><p>最后，我们还在交易服务更新订单状态时做了业务幂等判断，避免因消息重复消费导致订单状态异常。</p></li></ul><p>上面的策略已经比较完善了，但是还是可能存在问题：我们的机制没有问题，但是网络原因，MQ 和消费者间真的一直都没办法建立连接，能否有个兜底机制，至少确保关键的业务（例如支付）数据一致性？</p><h2 id="2-5-延迟任务和延迟消息"><a href="#2-5-延迟任务和延迟消息" class="headerlink" title="2.5 延迟任务和延迟消息"></a>2.5 延迟任务和延迟消息</h2><p>延迟任务是消息一致性的一种兜底方案。</p><p>延迟消息：<strong><u>发送者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。</u></strong></p><p>以下单举例：</p><p><img src="imgs/delay-example.png" width="600px"></p><p>假设交易服务和支付服务间暂时一直无法连接，是否有机制确保二者间的消息一致？</p><p>我们可以引入超时时间的概念，一段时间后，再次向支付服务查询如果成功就改变状态；如果失败则取消。</p><p>在 Rabbit MQ 中可以借助插件来完成延迟任务（默认不支持）。</p><h3 id="2-5-1-死信交换机（dead-letter）"><a href="#2-5-1-死信交换机（dead-letter）" class="headerlink" title="2.5.1 死信交换机（dead-letter）"></a>2.5.1 死信交换机（dead-letter）</h3><p>当一个队列中的消息满足下列情况之一时，就会成为死信（dead letter）：</p><ul><li>消费者使用 <code>REJECT</code> 或 <code>NACK</code> 声明消费失败并且消息的 <code>requeue</code> 参数设置为 <code>false</code> / 使用失败重试机制的 Message Recoverer 是 <code>RejectAndDontRequeueRecoverer</code>；</li><li>消息是一个过期消息（达到了队列或消息本身设置的过期时间），超时无人消费；</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信；</li></ul><p>我们可以在声明交换机时，给定一个属性 <code>dead-letter-exchange</code>，并且与某个队列绑定，那么该队列中的死信就会自动投递到这个交换机中；</p><p>我们可以利用死信交换机的 “超时” 特性，实现延时任务：</p><p><img src="imgs/dead-letter-meme-delay.png"></p><p>我们可以对某个队列声明死信交换机，直接使用 <code>QueueBuilder</code> 的方式定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueueBuilder</span><br><span class="line">    .durable(&lt;queue name&gt;)</span><br><span class="line">    .deadLetterExchange(&lt;dlx exchange name&gt;)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure><p>最后，我们还有在发送消息时还需要指定消息的过期时间，确保最终以规定时间进入死信交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(&lt;normal direct&gt;, &lt;key&gt;, &lt;object&gt;, &lt;post process&gt;)</span><br></pre></td></tr></table></figure><p>在最后一个参数中，传入一个 <code>MessagePostProcessor</code> 函数接口的实现，即可在 object 转换为 <code>Message</code> 对象后再进行处理，以设置超时时间。因为<strong><u>超时时间也位于 Message 的 Properties 中</u></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">postProccessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">        message.getMessageProperties().setExpiration(<span class="string">&quot;10000&quot;</span> <span class="comment">/* 字符串表示的 ms */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 也可以换成 lambda 表达式 */</span></span><br></pre></td></tr></table></figure><h3 id="2-5-2-Rabbit-MQ-延时任务插件"><a href="#2-5-2-Rabbit-MQ-延时任务插件" class="headerlink" title="2.5.2 Rabbit MQ 延时任务插件"></a>2.5.2 Rabbit MQ 延时任务插件</h3><p>需要在 <code>mq-plugins/_data</code> 中加入插件，并且配置 <code>enabled_plugins</code> 文件，加入 <code>rabbitmq_delayed_message_exchange</code> 即可；</p><p>然后，我们需要设置某个交换机的属性为 <code>delayed</code>：</p><ul><li>如果使用 Bean 配置，那么就用 <code>ExchangeBuilder</code> 添加 <code>delayed()</code> 方法；</li><li>如果使用 <code>@RabbitListener(bindings)</code> 的配置，就在 <code>@Exchange</code> 中加入 <code>delayed = &quot;true&quot;</code>；</li></ul><p>最后给要发送的消息指定 properties <code>x-delay</code>，同样使用 post processor，此时对 Message Properties 调用 <code>setDelay(&lt;ms&gt;)</code> （不是 <code>setExpiration</code>）即可；</p><blockquote><p>注意：无论是延时消息，还是死信的生成，其计时依赖 CPU 时钟，所以是 CPU 密集型任务。</p><p>如果超时时间 / 过期时间设置过长，都会导致需要计时的消息大量积压，影响 MQ 性能。</p><p><strong><u>所以无论是死信交换机中的过期时间，还是延时任务的延时时间，都不宜设置过长。</u></strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> Web </tag>
            
            <tag> Microservice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务初探</title>
      <link href="//technical/micro-service-basic/"/>
      <url>//technical/micro-service-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-0-基本概念"><a href="#Chapter-0-基本概念" class="headerlink" title="Chapter 0. 基本概念"></a>Chapter 0. 基本概念</h1><ul><li>微服务是一种软件架构风格。专注于单一职责的小型业务为基础，组成复杂大型应用。</li><li>需要解决的问题：服务拆分、远程调用（RPC）、服务治理（可用性与调度）、请求路由、身份认证、配置管 理、分布式事务（一致性问题）、异步通信……</li><li>优点和特征：粒度小、单服务开发便捷，团队自治，服务自治，系统耦合性低；</li><li>缺点：跨模块开发难度大，运维成本高；</li></ul><blockquote><p>对比而言，单体架构：</p><ul><li>优点：架构简单、部署成本低（适用于开发功能相对简单、规模较小的项目）；</li><li>缺点：团队协作成本高，系统发布效率低、系统可用性差（软件可靠性差）；</li></ul></blockquote><ul><li>对应框架：Spring Cloud，全球范围广泛使用的微服务框架；<ul><li>服务注册发现组件：Eureka、Nacos、Consul……</li><li>服务远程调用（RPC）；OpenFeign、Dubbo……</li><li>服务链路监控：Zipkin、Sleuth……</li><li>统一配置管理：Spring Cloud Config、Nacos……</li><li>统一网关路由：Spring Cloud Gateway、Zuul……</li><li>流控、降级、保护：Hystix、Sentinel……</li></ul></li></ul><h1 id="Chapter-1-基于实践学习：将单体架构拆分"><a href="#Chapter-1-基于实践学习：将单体架构拆分" class="headerlink" title="Chapter 1. 基于实践学习：将单体架构拆分"></a>Chapter 1. 基于实践学习：将单体架构拆分</h1><h2 id="1-1-基本思路"><a href="#1-1-基本思路" class="headerlink" title="1.1 基本思路"></a>1.1 基本思路</h2><ul><li>拆分时机：<ul><li>创业项目：先使用单体架构，快速开发、试错；规模扩大后再拆分；</li><li>确定的大型项目：资金充足，目标明确，直接选择微服务架构；</li></ul></li><li>拆分原则：<ul><li>高内聚：每个微服务的职责尽量单一，包含的业务相互关联度高、<strong>完整度高</strong>；</li><li>低耦合：每个微服务的功能要相对独立，尽量减少对其他微服务的依赖；</li></ul></li><li>拆分方式：<ul><li>纵向拆分：按业务模块拆分（用户认证管理、订单管理……）；</li><li>横向拆分：抽取公共服务，提高复用性（用户登录、订单管理中有公共服务，例如风控、日志服务）；</li></ul></li></ul><blockquote><p>具体如何拆分何种模式？</p><ul><li><p>独立 Project：一个单体架构的项目拆分后，将每个 service 放在一个独立 Project 内；</p><p>优点：相当解耦，关联度更低；</p><p>缺点：对于小型项目而言仓库管理臃肿费力；</p><p>适用：大型项目，每个 service 的业务逻辑相当复杂；</p></li><li><p>Maven 聚合：一个单体项目拆分后，所有 service 都存放在一个 project 中，这个 project 专门用于管理依赖，每个 service 都是 project 的一个 module；</p><p>适用：中小型项目，敏捷开发；</p></li></ul></blockquote><h2 id="1-2-远程调用-RPC：以-Spring-RestTemplate-为例"><a href="#1-2-远程调用-RPC：以-Spring-RestTemplate-为例" class="headerlink" title="1.2 远程调用 RPC：以 Spring RestTemplate 为例"></a>1.2 远程调用 RPC：以 Spring <code>RestTemplate</code> 为例</h2><p>拆分的问题：经常会遇到一个服务依赖另一个服务的情况。这可以直接通过服务间远程调用（RPC）来完成。</p><blockquote><p>远程调用 RPC 更像是一种软件协议，能<strong><u>让一个程序和本地执行流程一样，在远端执行一段代码</u></strong>。</p><p>在软件工程原理的 23 个设计模式中，更像是利用了 Proxy 设计模式。调用者无需关心远程信息交互的具体细节，只需按照接口像调用本地服务一样即可完成目标。</p></blockquote><p>在 Spring 中，一种轻量级的远程调用的方法是，使用接口：<code>RestTemplate</code>，调用它就相当于在 Java 代码中向 RESTful API 发送网络请求并且获取回复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">exchange</span><span class="params">(</span></span><br><span class="line"><span class="params">    String url,</span></span><br><span class="line"><span class="params">    HttpMethod method,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> HttpEntity&lt;?&gt; requestEntity,    <span class="comment">/* request body */</span></span></span><br><span class="line"><span class="params">       Class&lt;T&gt; responseType,</span></span><br><span class="line"><span class="params">    Map&lt;String, ?&gt; uriVariables</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>规避类型擦除：<code>new ParameterizedTypeReference&lt;T&gt;() &#123;&#125;</code>；</p></blockquote><p>但是有一些不可避免的问题：</p><ul><li>若代码中写死 <code>url</code>，则 负载均衡、可用性轮换等等策略全部失效；</li><li>若业务逻辑中的远程调用的部分较多，则 <code>RestTemplate</code> 对象散落各处不方便维护；</li><li>……</li></ul><p>于是我们需要更严格、复杂的架构将服务间的远程调用管理起来。一种思路就是 “<strong><u>发布-订阅者模式</u></strong>”；</p><h2 id="1-3-微服务的注册与发现机制"><a href="#1-3-微服务的注册与发现机制" class="headerlink" title="1.3 微服务的注册与发现机制"></a>1.3 微服务的注册与发现机制</h2><h3 id="1-3-1-发布-订阅模式（架构）"><a href="#1-3-1-发布-订阅模式（架构）" class="headerlink" title="1.3.1 发布-订阅模式（架构）"></a>1.3.1 发布-订阅模式（架构）</h3><p>发布-订阅者模式（pub-sub pattern）；</p><p><img src="imgs/pub-sub.png"></p><p>The Pub/Sub (Publisher/Subscriber) model is a messaging pattern used in software architecture to facilitate asynchronous communication between different components or systems. In this model, publishers produce messages that are then consumed by subscribers.</p><p>发布-订阅模型，作为一种消息传递模式，用在一些软件架构中，来实现不同组件、系统间的<strong><u>异步通信</u></strong>。</p><ul><li><p>subscribers：消息的获取方，publishers：消息生产方；</p></li><li><p>topics：一种订阅频道 / 分类（channels / categories）；</p><p>发布者可以按照消息的业务含义为消息打上话题标签（并且无需知道订阅者的特性），而订阅者可以按照 topics 来订阅、获取部分感兴趣的消息（并且无需知道发布者的特性）；</p><p>Topics help categorize messages and enable targeted message delivery to interested subscribers.</p></li><li><p>message brokers：一种中间件/中间人（intermediaries），负责在 publishers 和 subscribers 间使用合适的策略传递消息（调度队列、延时……）；</p><ul><li>message brokers 可以按 topics 维护一些消息队列；</li><li>确保消息发送给正确的订阅者，并且提供额外的特性：<strong><u>消息持久化、可扩展性、可靠性</u></strong>；</li></ul></li><li><p>message：可以是任何形式的数据信息（text, JSON, binary, etc）；</p></li><li><p>subscription：订阅代表了 subscriber 和某个 topics 建立的一个关联。它定义了：</p><ul><li>订阅者订阅了什么 topic 的消息；</li><li>订阅设置，例如是否事务、是否有订阅内容保证（at-most-once / at-least-once）等等；</li></ul></li></ul><p>发布-订阅模型的理论过程：</p><ol><li>发布者创建并发送消息给 pub/sub system，并且根据消息内容类型放入指定 topic 或者说 channel 中；</li><li>订阅者向 pub/sub system 表达需要订阅某个/些 topic 的意愿，有信息就会收到；</li><li><p>message brokers 根据收到发布者的 topic 对收到的消息分类，再根据所有 topics 的订阅情况 forward 给所有订阅了这个 topic 的 subscribers；</p></li><li><p>以上过程全部异步，发布者不需要关心订阅者的状态即可发布；订阅者无需关心发布者的状态即可接受消息。</p></li></ol><p>发布-订阅模型的优势：</p><ul><li>decoupling &amp; scalability：将消息生产方和消息接受方解耦，不仅无需关心对方状态和交互细节，而且 scalable，便捷地增减 publishers 和 subscribers 的数量而无需影响现有组件；</li><li>asynchronous communication：异步通信能力；</li><li>event-driven architecture：发布者和订阅者互不耦合，但发布者的事件行为可以影响订阅者；</li><li>dynamic subscription：允许运行时动态更换订阅，去耦合，全面的灵活性；</li></ul><p>发布-订阅模型的适用场景：</p><ul><li>消息队列系统；</li><li>需要构建 scalable web app 的时候，尤其是在线文档、实时更新的场景；</li><li>微服务架构间的远程通信；</li><li>……</li></ul><p>发布-订阅模型不应该使用的场景：</p><ul><li>对交互时延有极强需求的场景，例如游戏；</li><li>低复杂度的交互场景，例如系统只有两个组件间的交互，贸然引入会增大不必要的复杂度；</li><li>……</li></ul><p>回到微服务远程调用的主题上。为了确保服务远程调用的灵活性、可用性，我们可以借鉴 发布-订阅者模式，通过注册、发现、订阅的流程，动态调度服务的访问方式。</p><p>这样既可以有效地、统一地管理远程访问，提升可维护性，又可以便捷地进行调度，充分利用服务资源。</p><h3 id="1-3-2-注册中心"><a href="#1-3-2-注册中心" class="headerlink" title="1.3.2 注册中心"></a>1.3.2 注册中心</h3><p>在微服务架构中，规避微服务间直接远程调用缺陷的一种方式就是引入注册中心机制，借鉴发布-订阅模式，引入注册中心后的主要步骤如下：</p><ol><li>服务发布者向注册中心注册服务信息（提供何种服务，即 topic，还有地址在哪里）；</li><li>服务订阅者向注册中心订阅感兴趣的服务。此时注册中心可以将<strong><u>当前可用的</u></strong>发布者信息告诉订阅者；</li><li>订阅者（或者注册中心）可以进行负载均衡，选择一个发布者向其请求服务（远程调用）。</li></ol><p>由于我们利用了发布-订阅模式，所以即便是已经获取服务列表的订阅者，也能从注册中心实时获取当前发布者的可用情况。例如：</p><blockquote><p>假设订阅者从注册中心获取了 3 个可能的服务发布者，但是一段时间后其中一个服务提供方 A 宕机。</p><p>这个时候 A 不再通过注册中心的 health check（heart beat），注册中心认为 A 不再有效，于是向所有订阅了 A 服务所在 topic 的所有订阅者推送变更。</p><p>这就保证了订阅者订阅列表的有效性。创建了新的服务实例也是如此！实现了 scalable service，随意增减服务实例数量、负载均衡。</p></blockquote><hr><p>在代码方面，我们知道在 Spring Cloud 中，注册中心有很多实现，例如 Alibaba 的 Nacos，Netflix 的 Eureka。我们就以其中的 Nacos 为例。我们只需要将注册中心部署在固定 IP 的服务器上即可。</p><p>配置好 Nacos，在注册服务客户端（也就是提供服务方）引入 nacos 注册发现服务，还需要对 Spring 进行配置，指定 registry server 的地址和需要的服务名。最后启动这个服务实例即可完成注册！</p><p>而在服务调用端，需要在项目中引入 Nacos Client，它实现了 Spring Cloud 的 <code>DiscoveryClient</code> 接口。</p><p>我们直接注入 <code>DiscoverClient</code>，使用如下方法：</p><ul><li><code>DiscoverClient.getInstances(String serviceName) -&gt; List&lt;ServiceInstance&gt;</code>，<code>serviceName</code> 是服务提供方在 Nacos 中注册的服务名；</li><li>而我们可以通过 <code>ServiceInstance</code> 获取 <code>uri / host / port</code> 信息，手动写负载均衡或其他处理工作。</li></ul><blockquote><p>注：Nacos 需要导入依赖 <code>spring-cloud-starter-alibaba-nacos-discovery</code>，并且进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">nacos.server-addr:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="1-3-3-更优雅的远程调用：OpenFeign"><a href="#1-3-3-更优雅的远程调用：OpenFeign" class="headerlink" title="1.3.3 更优雅的远程调用：OpenFeign"></a>1.3.3 更优雅的远程调用：OpenFeign</h3><h4 id="初步认识-OpenFeign"><a href="#初步认识-OpenFeign" class="headerlink" title="初步认识 OpenFeign"></a>初步认识 OpenFeign</h4><p>但是这里有个问题，我们通过 <code>DiscoverClient</code> 获取可用服务列表，然后再处理一系列可能的异常，然后还要手写 <code>RestTemplate</code> 进行远程调用，最后才能访问服务！</p><p>如此繁琐的远程调用，我们应该进行封装！好在同样有框架能够更轻松地帮助我们完成远程调用：OpenFeign；</p><blockquote><p>注：我们还要对负载均衡算法进行封装。使用 Spring cloud load balancer 就能解决问题。</p></blockquote><p>引入 OpenFeign 的方法如下：</p><ul><li><p>引入 OpenFeign 依赖；</p></li><li><p>在 Springboot Application 启动类注解 <code>@EnableFeignClients</code> 启用 OpenFeign 的特性；</p></li><li><p>定义接口，用于指定要远程调用的服务名、远程调用服务名的 endpoint。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;)</span>    <span class="comment">/* 需要向注册中心申请的服务名 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 告诉 OpenFeign 需要连接远程服务的 endpoint 相当于指定 RestTemplate 的 uri 和 HttpMethod */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    <span class="comment">/* 告诉 OpenFeign 的传入参数、请求体信息，以及服务返回 JSON 对应的类型，相当于指定 RestTemplate 的 RequestEntity，responseType，uriVariables */</span></span><br><span class="line">    List&lt;ItemDto&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样相当于实现了 proxy 设计模式（这个 interface 对应 Spring 生成的实例就是 proxy），在调用远程服务就像调用本地服务一样简单！</p><h4 id="OpenFeign-连接池优化"><a href="#OpenFeign-连接池优化" class="headerlink" title="OpenFeign 连接池优化"></a>OpenFeign 连接池优化</h4><p>OpenFeign 的底层实现非常类似我们手动使用 <code>DiscoverClient</code>，并且考虑负载均衡、服务异常的情况。</p><p>感兴趣的同学可以步进调试观察其底层行为。</p><p>值得注意的是，OpenFeign 底层默认的远程调用的方式是利用 <code>HttpURLConnection</code> 类（位于 <code>FeignBlockingLoadBalancerClient</code> 的 <code>delegate</code> 成员变量），而这个 Java 内置类比较底层，不支持连接池，不像 apache 的 <code>HttpClient</code> 和 <code>OkHttp</code>，可能造成资源利用率较低。</p><p>好在我们可以为 OpenFeign 的底层请求更换具有连接池的连接类，这样可以减小创建和销毁连接的开销，有助于提升程序性能。只需导入依赖相应依赖（例如 <code>feign-okhttp</code>），并且在 <code>application.yaml/properties</code> 中配置开启即可（例如 <code>feign.okhttp.enabled = true</code>）；</p><blockquote><p>注意，是在 OpenFeign 调用方模块设定才有效！</p></blockquote><h4 id="OpenFeign-最佳实践"><a href="#OpenFeign-最佳实践" class="headerlink" title="OpenFeign 最佳实践"></a>OpenFeign 最佳实践</h4><p>到这里仍然没有结束，我们还需要知道 OpenFeign 框架的最佳实践。</p><p>上面介绍引入 OpenFeign 的方法实际上是有严重问题的。我们发现，当单体架构的程序被拆成微服务后，有可能多个服务依赖同一个微服务，难不成所有用到的微服务都要定义一遍像 <code>ItemClient</code> 一样的接口？</p><p>我们知道，代码重复是大忌，这不仅降低了可维护性（增添维护人员心智负担）、可扩展性（修改繁琐，不对修改开发），还降低了代码可读性和正确性。</p><p>正确使用 OpenFeign 的方案有几种：</p><ul><li><p>直接交给服务提供方编写 Feign Client，将服务提供方拆成 3 个模块：</p><ul><li><code>DTO</code> 中包含向服务调用方返回的数据类型；</li><li><code>api</code> 中包含 <code>FeignClient</code> 接口以供调用；</li><li><code>blz</code> 中包含原先的代码业务逻辑；</li></ul><p>最后其他服务只需引用该服务为依赖即可。</p><p>优点：代码逻辑更合理，易于维护，耦合度更低；</p><p>缺点：项目结构更复杂、编写麻烦；</p></li><li><p>创建一个不属于任何一个微服务模块的、同级的 <code>api</code> module，专门管理 <code>FeignClient</code>，主要包含：</p><ul><li><code>client</code>：所有微服务想要向外暴露的 <code>FeignClient</code>；</li><li><code>config</code>：所有微服务的配置类；</li><li><code>dto</code>：所有微服务想要返回的数据类型；</li></ul><p>优点：项目结构清晰，无需改动原先微服务；</p><p>缺点：代码耦合度增加，每个微服务模块都需要引入该模块为依赖（而前一种方法只需引入需要用的模块就行），所有微服务都需要和 <code>api</code> 一起开发；</p><p>但是如果以这种方式创建 <code>FeignClient</code>，没法完成依赖注入（因为 Spring Application 没法自主扫描本包以外的 bean），就需要手动指定接口类型，并将其纳入 IoC Container 中。两种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 SpringApplication 启动类启用 FeignClient 时显示指定 bean 类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方法一：为 Spring 指定 bean 扫描的包名（精确到子包） */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &lt;package name&gt;)</span></span><br><span class="line"><span class="comment">/* 方法二：利用反射手动指定 bean 对应接口的 Class 类型 */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(clients = &#123; &lt;classname&gt;.class &#125;)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="OpenFeign-日志管理"><a href="#OpenFeign-日志管理" class="headerlink" title="OpenFeign 日志管理"></a>OpenFeign 日志管理</h4><p>OpenFeign 框架默认情况下仅在 <code>FeignClient</code> 所在包配置的日志级别为 <code>DEBUG</code> 时才会输出日志，并且自身的日志级别是 <code>NONE</code>（不输出），故需要我们手动配置。</p><blockquote><p>注：OpenFeign 自身的日志级别有 4 种：<code>NONE / BASIC / HEADERS / FULL</code>；</p></blockquote><p>定义 OpenFeign 的日志级别需要完成两件事：</p><ol><li><p>定义配置类，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 没有 @Configuration / @Service 等注解，该 @Bean 不会被纳入 IoC Container */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将配置类配置给指定 / 全局的 <code>FeignClient</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指定 FeignClient */</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;...&quot;, configuration = FeignConfig.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局 FeignClient 默认 */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = FeignConfig.class)</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="1-4-微服务网关"><a href="#1-4-微服务网关" class="headerlink" title="1.4 微服务网关"></a>1.4 微服务网关</h2><p>在大致拆好微服务后，有个问题就随之出现：前端应该如何访问后端服务？难道前端还需要动态获取各个服务的地址？</p><p>肯定不能这样，我们的期望是前后端的解耦，就是说单体架构和微服务架构下，前端是无需改变的，只需要向固定的地址发送不同请求就能得到对应的响应，这就需要一个中间层来完成这个任务。</p><p>这个能将不同服务转发给某个符合条件的微服务的中间层就是网关。网关不仅能完成前面的 forward 的功能，还能<strong><u>配合注册中心</u></strong>进行负载均衡。</p><blockquote><p>功能：</p><ul><li>请求路由（路径针对什么微服务？）；</li><li>转发（帮忙将 HTTP 请求 forward 给某个动态地址的实例）；</li><li>身份校验（检查请求的 <code>Authorization</code> 是否合法）；</li></ul></blockquote><p>这样，我们就不需要在每个微服务中进行身份校验等繁琐工作了。更安全的是，后端微服务甚至不需要向外暴露端口了，只需暴露网关，大大增强安全性。</p><p>此外，引入网关后，后端实现了封装和解耦，在前端看来这和单体架构别无二致。</p><h3 id="1-4-1-微服务网关框架：Spring-Cloud-Gateway"><a href="#1-4-1-微服务网关框架：Spring-Cloud-Gateway" class="headerlink" title="1.4.1 微服务网关框架：Spring Cloud Gateway"></a>1.4.1 微服务网关框架：Spring Cloud Gateway</h3><div class="table-container"><table><thead><tr><th>Spring Cloud Gateway</th><th>Netflix Zuul</th></tr></thead><tbody><tr><td>基于 <code>WebFlux</code> 响应式编程</td><td>基于 <code>Servlet</code> 阻塞式编程</td></tr><tr><td>无需调优即有很好性能</td><td>需要调优才有接近Spring Cloud Gateway 的性能</td></tr><tr><td>正常维护</td><td>更新较慢</td></tr></tbody></table></div><p>基于上述特点，我们以 Spring Cloud Gateway 为例。</p><p>它的使用很简单：导入依赖、编写启动类、编写配置。</p><h4 id="Spring-Cloud-Gateway-配置示例"><a href="#Spring-Cloud-Gateway-配置示例" class="headerlink" title="Spring Cloud Gateway 配置示例"></a>Spring Cloud Gateway 配置示例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">gateway:</span></span><br><span class="line">            <span class="attr">routes:</span><span class="comment"># 路由规则列表</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">&lt;Route</span> <span class="string">ID&gt;</span> <span class="comment"># 独一无二的路由 ID</span></span><br><span class="line">                  <span class="attr">uri:</span> <span class="string">lb://&lt;service</span> <span class="string">name&gt;</span> <span class="comment"># load balance，到指定服务</span></span><br><span class="line">                  <span class="attr">predicates:</span><span class="comment"># 筛选断言条件（列表）</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">Path=/xx/**</span><span class="comment"># 支持通配符</span></span><br><span class="line">                  <span class="attr">filters:</span></span><br><span class="line">                  <span class="bullet">-</span> [<span class="string">...</span>]<span class="string">=[...]</span></span><br><span class="line">            <span class="attr">default-filters:</span></span><br><span class="line">                <span class="bullet">-</span> [<span class="string">...</span>]<span class="string">=[...]</span></span><br></pre></td></tr></table></figure><p>众所周知，<code>application.yaml</code> 中的配置内容相当于 XML Bean，都在向 Spring 框架的类型中填写初始化属性罢了。这里 <code>spring.cloud.gateway.routes</code> 对应的是 <code>Collection&lt;RouteDefinition&gt;</code> 类型。</p><p>其中，<code>predicates</code> 属性可取以下值：</p><div class="table-container"><table><thead><tr><th>Name</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>Host=**.somehost.org,**.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>Query=name, Jack 或者 Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td><td>Weight=group1, 2</td></tr><tr><td>X-Forwarded Remote Addr</td><td>基于请求的来源IP做判断</td><td>XForwardedRemoteAddr=192.168.1.1/24</td></tr></tbody></table></div><p><code>filters</code> 可取以下值：</p><div class="table-container"><table><thead><tr><th>Name</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td><td>AddrequestHeader=headerName,headerValue</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td><td>RemoveRequestHeader=headerName</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td><td>AddResponseHeader=headerName,headerValue</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td><td>RemoveResponseHeader=headerName</td></tr><tr><td>RewritePath</td><td>请求路径重写（ant path 语法）</td><td>RewritePath=/red/?(?\&lt;segment\</td><td>.*), /\\{segment}</td></tr><tr><td>StripPrefix</td><td>去除请求路径中的N段前缀</td><td>StripPrefix=1，则路径/a/b转发时只保留/b</td></tr><tr><td>……</td><td>……</td><td>……</td></tr></tbody></table></div><blockquote><p>一共有 33 种，详见官网。</p></blockquote><p>值得注意的是，filter 是基于 router 生效的、作用于 router 的。Spring Cloud 中的 filter 分为两种：</p><ul><li>GlobalFilter：全局过滤器，作用于所有路由，在声明该过滤器后无需激活即可生效；</li><li>GatewayFilter：路由过滤器，共 33 种，作用于指定路由，默认不生效。上面的在<strong><u>配置文件</u></strong>中写的 <code>filters</code> 就是这个过滤器！</li></ul><h4 id="Spring-Cloud-Gateway-过滤机制-以及-Spring-Security-对比"><a href="#Spring-Cloud-Gateway-过滤机制-以及-Spring-Security-对比" class="headerlink" title="Spring Cloud Gateway 过滤机制 以及 Spring Security 对比"></a>Spring Cloud Gateway 过滤机制 以及 Spring Security 对比</h4><p>这里只介绍了网关 forward 的配置，那么如果想对网关做更进一步的配置（例如身份验证），应该怎么操作？</p><p>首先需要了解 Spring Cloud Gateway 的底层机制。</p><p><img src='imgs/gateway-filters.png'></p><p>这里的思路几乎和 Spring Security 的过滤器链一模一样（责任链模式）。</p><p>因此我们想加入身份验证功能，就需要在 Filter 的 <code>PRE</code> 部分定义检查逻辑。如果符合条件，则允许通过 <code>NettyRoutingFilter</code> 进行转发；否则抛出异常立即拒绝请求。</p><p>现在做身份验证的思路就非常清楚了：自定义一个 Filter 类，最好像 Spring Security 的 <code>OncePerRequestFilter</code> 一样每次请求仅通过一次，插入到 <code>NettyRoutingFilter</code> 之前，就能完成任务。</p><p><strong><u>但是有几点和之前的微服务架构截然不同</u></strong>！！！</p><p>考虑第一点：网关如何向微服务传递当前登录用户的信息？</p><p>注意到现在网关、各个微服务都是独立的服务了，和单体架构不同，我们<strong>不能</strong>通过保存在类似于 <code>SecurityContext</code> 这样的单线程上下文（<code>ThreadLocal</code>）中，把网关中检查的用户信息传给 forward 的目标服务了。</p><p>回忆一下，网关向微服务 forward 实际上已经是一次新的 HTTP 请求了，而且我们之前在 Gateway 的 filters 参数中看到，gateway 可以配置额外添加请求头信息。因此不难想到，我们可以通过在网关的自定义 filter 中加入关于用户信息的请求头就能解决这个问题！</p><p>但再考虑第二个问题：既然网关和微服务间通过传递请求头来完成用户信息传递，那微服务之间相互调用也很频繁，它们默认还是原来的请求方式（<code>Nacos + OpenFeign</code>），没有请求头，难道要更改原来的代码，每个微服务请求 Client Proxy 时还要主动记录和传递用户信息？</p><p>是的！不过幸好 <code>OpenFeign</code> 有另一套方法帮我们加上这个请求头，所以不必担心。</p><p>下面我们来认识一下如何自定义 filter，并且完成身份认证的功能。</p><h4 id="自定义-Global-Filter"><a href="#自定义-Global-Filter" class="headerlink" title="自定义 Global Filter"></a>自定义 Global Filter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义 PRE 部分的 Gateway Global Filter </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 经过该 filter 时，过滤器链的请求上下文，包括 request、response、前面的 filter 写入的信息；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 过滤器链中下一条要执行的 filter</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 类似 JavaScript 中的回调函数。采用了 WebFlux 的非阻塞的、响应式接口，因为 PRE 和 POST 间时间可能很长，所以实际上 POST 部分 filter 是通过定义这个回调的行为来完成的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">    <span class="comment">/* 合理的做法是，和 Spring Security 类似，返回 chain.filter(exchange)，将 filter 链委托给下一级 */</span></span><br><span class="line">    <span class="comment">/* 如果想要阻止请求（例如未认证），那么请拿到 response，set response code，并且返回一个 response.setComplete() 标识请求已经回复（拒绝） */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要注意的是：</p><ul><li>global filter 需要继承于 <code>Ordered</code> 接口；</li><li>并且重写 <code>int getOrder()</code> 方法，这样能为 filter 安排插入顺序。注意：返回的整型越小优先级越高，并且 <code>NettyRoutingFilter</code> 的 order 是最大整型，因此任意一个不是 <code>INT_MAX</code> 的 order 都会让 filter 排在它的前面；</li><li>最后需要使用 <code>@Component</code> 纳入 Spring IoC Container 管理；</li><li>最后还要选一个配置类，使用 <code>@Bean</code> 提供一个 <code>GlobalFilter</code> 实例！！</li></ul><h4 id="自定义-Gateway-Filter"><a href="#自定义-Gateway-Filter" class="headerlink" title="自定义 Gateway Filter"></a>自定义 Gateway Filter</h4><p>这就是我们自定义写在 <code>filters</code> 配置文件中的 filter。本部分为进阶功能，一般使用不到。</p><p>我们需要继承于 <code>AbstractGatewayFilterFactory&lt;Object&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title class_">AbtractGatewayFilterFactory</span>&lt;Config&gt; &#123;</span><br><span class="line">    <span class="comment">/* config 类型请使用你想要的，例如 List 或者自定义类型 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;<span class="keyword">void</span>&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">/* same as Global Filter */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 定义传给 config 的数据类型 */</span></span><br><span class="line">    <span class="meta">@Data</span>    <span class="comment">// lombok</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String a;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        <span class="keyword">private</span> String c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 定义配置参数缩写名（类似设定命令行参数缩写） */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用构造函数告诉 AbstractGatewayFilterFactory config 的配置类型 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintAnyGatewayFilterFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>Config</code> 类型可以换成任何的自定义类型，以完成参数配置需求。如果不需要任何参数，直接使用 <code>Object</code> 类型，后面 3 个函数也就没有必要了。</p><p>这样前缀 <code>PrintAny</code>（去除 <code>GatewayFilterFactory</code>）就是配置名，我们就能自定义 filters 参数了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">gateway:</span></span><br><span class="line">            <span class="attr">routes:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">...</span></span><br><span class="line">                  <span class="attr">uri:</span> <span class="string">...</span></span><br><span class="line">               <span class="attr">predicates:</span> <span class="string">...</span></span><br><span class="line">               <span class="attr">filters: PrintAny:</span> <span class="string">&lt;config&gt;</span><span class="comment"># 需要和自己定义的 config 类型匹配</span></span><br></pre></td></tr></table></figure><p>此外，对于 <code>GatewayFilter</code> 如果想指定顺序，请使用 <code>OrderedGatewayFilter</code> 包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedGatewayFilter</span>(<span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Mono&lt;<span class="keyword">void</span>&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">            <span class="comment">/* same as Global Filter */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="comment">/* order */</span> <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，<code>GatewayFilter</code> 的定义使用了抽象工厂模式，满足了多样化定制需求。</p><h4 id="Spring-Cloud-Gateway-传递用户信息"><a href="#Spring-Cloud-Gateway-传递用户信息" class="headerlink" title="Spring Cloud Gateway 传递用户信息"></a>Spring Cloud Gateway 传递用户信息</h4><p>现在我们来解决之前提到的两个问题：</p><ul><li>网关如何向微服务传递当前登录用户的信息？</li><li>微服务之间相互调用如何使用 <code>OpenFeign</code> 传递用户信息？</li></ul><p>对第一个问题，我们采用如下思路：</p><p><img src="imgs/g2m.png"></p><p>这样我们微服务中的业务在本微服务内就沿用之前的 context 方案，无需更改，只需要修改进入微服务的拦截器即可；</p><p>先看如何更改 <code>GlobalFilter</code> 的请求内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ServerWebExchange.mutate() 方法可以返回已初始化的对象的 builder 以供修改 */</span></span><br><span class="line">exchange.mutate()</span><br><span class="line">    <span class="comment">/* 传递修改 request 的 build 方法 */</span></span><br><span class="line">    .request(builder -&gt; builder.head(<span class="string">&quot;info&quot;</span>, info))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>对于新建拦截器，我们不必在每个微服务中都写一遍，只需在共同依赖的模块中写入即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 识别信息并保存到 context，不作拦截 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 请求结束后，请销毁 context */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得把 Interceptor 配置到 Spring 中，在每次请求前进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="comment">/* 拦截器实例 */</span>);</span><br><span class="line">            <span class="comment">/* .addPathPattern() 可以选择作用的 path pattern，不写就是作用全部 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是还需要注意，这里的 Bean 现在没法被其他用到的模块扫描到，我们需要在这个模块的 <code>resources/META_INF/spring.factories</code> 中，配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">    &lt;package name&gt;.MvcConfig</span></span><br></pre></td></tr></table></figure><p>这样使得在该项目中， Spring 默认会将这个类加入 IoC Container。</p><blockquote><p>注意：在 Spring 3.x 以后，已经全面取消 <code>spring.factories</code> 中的 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 键的作用了。</p><p>在 Spring 3.x 的项目中，上面的配置是无效的，Spring 是不会扫描并且自动装配你指定的类的。</p><p>你需要在 <code>META-INT/spring/</code> 目录下新建一个文件 ``</p></blockquote><p>但是需要注意，这里采用的 <code>WebMvcConfigurer</code> 只能在微服务中生效，不能在 Gateway 中生效（因为 Gateway 是 <code>WebFlux</code> 非阻塞式接口，不能引入 Spring MVC 的接口），所以我们需要条件装配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 MvcConfig 前面的加入注解 */</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span>    <span class="comment">/* 该类是 Spring MVC 的核心 API */</span></span><br></pre></td></tr></table></figure><p>对于第二个问题，我们只需要对 <code>OpenFeign</code> 的请求进行定义：让每次 <code>OpenFeign</code> 触发微服务间调用时，都带上一个自定义的请求头，就像网关传给微服务一样。这里使用 <code>OpenFeign</code> 给的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这同样要定义在所有微服务中都依赖的模块中（因为是配置，所以用 bean 注入）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在某个配置 Feign 的类中 */</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">            <span class="comment">/* 配置请求头 */</span></span><br><span class="line">            template.header(&lt;header name str&gt;, &lt;context&gt; <span class="comment">/* 位于同线程，可用 */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个配置类需要显式配置给 <code>OpenFeign</code>（就像之前配置 Feign 日志的全局配置一样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(value = ..., defaultConfiguration = 该类名)</span></span><br></pre></td></tr></table></figure><h1 id="Chapter-2-微服务理论"><a href="#Chapter-2-微服务理论" class="headerlink" title="Chapter 2. 微服务理论"></a>Chapter 2. 微服务理论</h1><h2 id="2-1-微服务雪崩"><a href="#2-1-微服务雪崩" class="headerlink" title="2.1 微服务雪崩"></a>2.1 微服务雪崩</h2><p>在微服务相互调用中，服务提供者出现故障或阻塞。并且：</p><ul><li>服务调用者没有做好异常处理，导致自身故障；</li><li>或者访问连接一直保持 / 请求速度大于处理速率，致使请求不断堆积在 tomcat 中导致资源耗尽；</li></ul><p>最终，调用链中的所有服务级联失败，导致整个集群故障。</p><p><img src='imgs/avalanche.png' width="500px"></p><p>解决微服务雪崩的思路主要如下：</p><ol><li>尝试避免出现故障 / 阻塞；<ul><li>保证代码的健壮性；</li><li>保证网络畅通；</li><li>能应对较高的并发请求；</li><li><strong>微服务保护</strong>：保护服务提供方；</li></ul></li><li>局部出现故障 / 阻塞后，及时做好预备方案（积极有效的错误处理）；<ul><li><strong>微服务保护</strong>：保护服务调用方；</li></ul></li></ol><h2 id="2-2-微服务保护"><a href="#2-2-微服务保护" class="headerlink" title="2.2 微服务保护"></a>2.2 微服务保护</h2><p>为了应对微服务雪崩，我们有许多解决方案。其中，微服务保护是在业务逻辑代码层面以外的一种重要方案。</p><p>微服务保护有以下一些思路：</p><ul><li><p>请求限流：保护服务提供方。限制访问微服务的请求的并发量，避免服务因流量激增出现故障（<strong>应对访问模式：spike 型</strong>）；</p></li><li><p>线程隔离（舱壁模式）：保护服务消费方。通过限定每个业务能使用的线程数量而将故障业务隔离，避免故障扩散；</p><p><img src="imgs/thread-isolation.png" width="400px"></p></li><li><p>快速失败 和 服务熔断：</p><ul><li>快速失败：给业务编写一个调用失败时的处理的逻辑，称为 <code>fallback</code>。当调用出现故障（比如无线程可用）时，按照失败处理逻辑执行业务并返回，而不是直接抛出异常；</li><li>由<strong>断路器</strong>统计请求的异常比例或慢调用比例，如果超出阈值，则认为<strong>某个微服务业务所对应的所有实例都不可用</strong>，熔断该业务，则拦截该接口的请求。熔断期间，所有请求均 <code>fallback</code> 为快速失败逻辑；</li></ul><p><img src="imgs/fuse.png" width="400px"></p></li></ul><p>以上微服务保护的策略可以使用 <code>Sentinel</code> / <code>Hystrix</code> 框架完成。</p><div class="table-container"><table><thead><tr><th>Metrics or Feature</th><th><code>Sentinel</code></th><th><code>Hystrix</code></th></tr></thead><tbody><tr><td>Belong to</td><td>Spring Cloud Alibaba</td><td>Spring Cloud Netflix</td></tr><tr><td>Thread Isolation</td><td>信号量隔离</td><td>线程池隔离/信号量隔离</td></tr><tr><td>Fuse Policy</td><td>基于慢调用比例或异常比例</td><td>基于异常比率</td></tr><tr><td>Traffic Limiting</td><td>基于 QPS，支持流量整形</td><td>支持</td></tr><tr><td>Fallback</td><td>支持</td><td>支持</td></tr><tr><td>Configuration Method</td><td>基于控制台，重启后失效</td><td>基于注解或配置文件，永久生效</td></tr></tbody></table></div><p>想了解微服务保护框架具体如何使用，请参见官网样例或官方文档。</p><h2 id="2-3-微服务分布式事务"><a href="#2-3-微服务分布式事务" class="headerlink" title="2.3 微服务分布式事务"></a>2.3 微服务分布式事务</h2><blockquote><p>在分布式系统中，如果一个业务需要多个服务合作完成，而且每一个服务都有事务，多个事务必须同时成功或失败，这样的事务就是<strong><u>分布式事务</u></strong>。其中的每个服务的事务就是一个<strong>分支事务</strong>。整个业务称为<strong>全局事务</strong>。</p></blockquote><p>除了微服务雪崩的问题外，微服务设计中还存在一个重难点：如何保证微服务数据 ACID 的性质（如何正确进行分布式事务）。</p><p>以一个商品订单服务为例：</p><p><img src="imgs/inconsistency.png" width="600px"></p><p>如果最终库存服务失败，那么虽然订单服务可能可以识别到错误并且回滚，但是购物车服务与库存服务间没有关系，极有可能不会回滚，造成数据的不一致性。这就是没有保证分布式事务一致性。</p><p>那么我们应该如何保证微服务流程的一致性？</p><p>这个时候需要引入一个分布式事务的协调组件，让各个子事务（分支事务）感知到彼此的事务状态，根据总体的事务状态进行判断，协调全局事务的提交或回滚，这样就能保证事务状态和数据的一致性。</p><p>这个分布式事务的协调组件被称为：<strong>事务协调者（Transaction Coordinator，TC）</strong>；</p><p>除了事务协调者，还需要有一个组件，用于定义单个全局事务的范围（从哪个子事务开始，到哪个子事务结束）。这个组件就被称为：<strong>事务管理器（Transaction Manager，TM）</strong>；</p><p>有了 TC 和 TM，就能准确地定义一个全局事务； </p><p>为了进一步从业务逻辑中解耦，我们额外增添一个组件用于说明某个子事务的事务状态。它的作用是，向 TC 注册子事务，并且报告子事务的事务状态。这就被称为：<strong>资源管理器（Resource Manager，RM</strong>）；</p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Microservice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Semaphore, Mutex, CV</title>
      <link href="//technical/semaphore-mutex-and-cv/"/>
      <url>//technical/semaphore-mutex-and-cv/</url>
      
        <content type="html"><![CDATA[<p>学习 ICS 的并行一章之后，笔者有些疑惑，semaphore（信号量）、mutex（互斥锁）、conditional variables（条件变量）这 3 者之间究竟该怎么区分它们的使用场景？</p><p>首先我们需要去阐述清楚它们各自的定义和效果。</p><p>学术界认为 mutex 是 semaphore 的特例，因此像著名的书籍 CSAPP 就先以 semaphore 为例讲了讲并发程序的资源控制问题。但是实际上有相当一部分实践派和语义派认为二者不应该混为一谈。像 Linus 本人在一次将 Linux 内核的一部分 semaphore 重构为 mutex 后，发现不仅改善了代码语义，还在一定程度上提升了性能。这件事也说明了，虽然在理论上一方可以替代另一方，但实践上它们各有所长。</p><h2 id="Semaphore-vs-Mutex"><a href="#Semaphore-vs-Mutex" class="headerlink" title="Semaphore vs Mutex"></a>Semaphore vs Mutex</h2><p>我们先讨论 semaphore。</p><p>CSAPP 中先从 “线程间变量共享” 的情况说起，它指出，程序对内存的更改并不直接在内存上完成，在汇编中可以看到，大致经历了 load（从内存到 CPU 寄存器）、update（在 CPU 寄存器内更新数据）、store（将 CPU 寄存器数据写回内存）这 3 步。</p><p>而根据程序的局部性原理、context switch 的随机性，出现脏读、不可重复读的情况几乎是必然的。这样的话两个线程甚至无法完成简单的累加计算。</p><p>为了解决这个问题，CSAPP 引入了 semaphore，这种做法就等价于建立了一个资源临界区，而 semaphore 的初始值则限制了 <u>能同时访问在 semaphore 保护下的代码 并发执行的线程数量</u>。</p><p>semaphore 中有一个特殊情况，也就是初值为 1 的情况，只允许一个线程并发执行受保护的代码。这种特殊的信号量就被称为 Binary Semaphore。</p><p>现在看 Mutex（互斥锁），我们发现，互斥锁的作用实际上要说明<u>任何线程对 mutex 包含的资源的访问都是互斥的（同一时间仅能有一个线程访问）</u>。</p><p>但是有人说，这不就是 binary semaphore 的定义吗！</p><p>实际上，Binary Semaphore 和  <strong>互斥锁</strong>（<code>mutex</code>）有些微妙的区别。</p><p>Mutex 相比 binary semaphore 增加了<strong>所有权的概念</strong>，<u>一只锁住的 Mutex 只能由给它上锁的线程解开</u>，只有系铃人才能解铃。Mutex 的功能也就因而限制在了构造 unsafe region 的 “围墙” 上。</p><p>Binary semaphore 则可以由任一线程解开。比如某进程读取磁盘并进入睡眠，等待中断读取盘块结束之后来唤醒它，而这种情况 Mutex 是解决不了的。</p><p>这是因为 semaphore 的语义有两个功能：<strong>保护资源 + 通知</strong>。除了限制资源并发数量，semaphore 的释放还能通知等待 semaphore 的线程。</p><p>Mutex 相较 semaphore 的优势在于，Mutex 职责更单一，语义更清晰，实现的效率稍微高一点。</p><h2 id="Semaphore-vs-Conditional-Variable"><a href="#Semaphore-vs-Conditional-Variable" class="headerlink" title="Semaphore vs Conditional Variable"></a>Semaphore vs Conditional Variable</h2><p>你可能会想，semaphore 有通知的语义，那条件变量不也有吗？它们俩又有什么区别呢？</p><p>实际上，你可以把条件变量理解成一个抽象层级更高的机制。</p><p>条件变量实际上是一种<strong>等待队列</strong>，<strong>提供了 “唤醒”（wake）和 “阻塞等待”（blocking-wait）两类操作</strong>，也就是入队时等待、出队时唤醒。不过这个出队条件由条件决定，唤醒和阻塞的机制交由 OS 的系统调用完成。</p><p>它们俩的共同点是，semaphore 和 CV 底层都可以用 Mutex（互斥锁在这里就是低层级同步原语，low-level synchronizing primitive）实现，它们共同的使用场景是<strong>对共享资源访问的同步机制（通知）</strong>。</p><p>然后我们再以使用场景来说明它们的不同点。</p><p>条件变量常常被用于避免资源的 Busy Waiting，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (!queue.empty()) &#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">/* do something */</span><br></pre></td></tr></table></figure><p>这种行为会浪费大量的处理器资源。那么为什么不能有个变量让线程等待在上面，直到 available 后自动提醒这个线程继续运行？</p><p>条件变量的作用就在这里。它可以<u>同步多个线程对于某个条件的判断，当该条件触发时（通常是另一个线程对这个条件变量执行了操作），会随机/全部唤醒正在等待条件的线程</u>。可以说条件变量是有条件的提醒机制。</p><blockquote><p>举个例子，比如并行计算中的 checkpoints 要求线程池中，之前一阶段分配过任务的所有线程都完成计算后，才进行下一阶段的计算任务。这就是多线程的条件，这个场合就适合使用条件变量。</p></blockquote><p>semaphore 虽然也有提醒的意思，但它的语义重点不在条件上，它的重点在于 “<strong>根据某个整数（常常是共享资源的数量）来限制和提醒某个共享资源是否可用</strong>”。</p><p>而这层含义就天然的让 semaphore 比 mutex 和 CV <strong>在语义上更适合解决生产者消费者模型（Consumer / Producer Model）有关的问题</strong>。</p><blockquote><p>因为它们在某些情况下都能解决这个问题，但是语义上有优劣之分。</p></blockquote><p>大家不妨再回想一下 读者/写者模型，在 CSAPP 书中是使用 semaphore 完成的，但是实际上这个模型在语义上更适合 Conditional Variables 完成。因为这需要资源有条件的提醒机制。使用 semaphore 虽然实现上更简单，但是破坏了一部分的语义，也可能出现额外的 “虚假唤醒” 的问题。</p><blockquote><ul><li><p>例如为什么一定要记录当前读者数、等待的写者数、写者数？我不关心呢？是不是增加了冗余复杂度？</p></li><li><p>semaphore 没有显式地提醒某一类等待的线程，而是通过可用数量的方式<strong>间接</strong>展示了资源的可用性。</p><p>这并不准确，在多核、很多线程等待的情况下可能<u>无法像 CV 一样，能控制同时唤醒多个线程，还是只唤醒一个等待的线程</u>。</p></li></ul></blockquote><p>相信在上面的分析中大家以已经看到了，conditional variable 和 semaphore 在实现上能相互替代，只不过有语义和实现复杂度的 trade off 罢了，它们的使用场景也存在重叠的情况。</p><h2 id="Application-Parallel-MST-Algorithm"><a href="#Application-Parallel-MST-Algorithm" class="headerlink" title="Application: Parallel MST Algorithm"></a>Application: Parallel MST Algorithm</h2><p>其中一个比较有名的多线程同步的应用场景是，<strong>并行最小生成树的计算</strong>。由于计算最小生成树是很多算法依赖的基本算法，因此优化这个算法曾是学界比较热门的话题。</p><p>以并行的 Kruskal 算法（基于最小边的贪婪算法）为例，其主体思想与非并行化的 Kruskal 算法大致相同。</p><p>通过对图的划分，将原图分为若干不相交的分区，交由不同的进程或线程计算最小边权，从而达到加速计算的效果。</p><p>整个算法分为由各并行线程完成的 “部分算法” 与由一个主线程完成的 “仲裁算法”。</p><p>在“部分算法”中，当各进程<strong>收到来自全局进程的计算通知</strong>后，选出本分区当中具有最小权重的边并发送给全局进程，并且等待，直到本分区没有待处理的边或收到全局进程的结束通知时结束进程。</p><p>在 “仲裁算法” 中：</p><ol><li>全局进程首先向所有并行进程发送消息获取各分区最小权重边构成队列 $Q_i$；</li><li>接下来循环取出 $Q_i$ 中权值最小的边 $e_j=\min\limits_{i}{e_i}$，并向提供边 $e$ 的进程 $j=\text{argmin }e_i$ 发送消息请求补充新的最小权重边至 $Q_j$ 中；</li><li>如果取出的边 $e_j$ 加入到结果集 $T$ 中不会构成环路则保留此边，若会构成环路则将其丢弃。</li><li>当 $T$ 中的边的数量为 $|V|-1$ 或队列 $Q_i$ 均为空时算法结束，同时通知各进程结束算法。</li></ol><p>这里我们发现有多次的信息的通知语义，而且是针对特定线程。因此这里没法采用 semaphore 和 mutex，采取条件变量控制是较为合适的。</p><h2 id="Extra-Recursive-Mutex-amp-Lock-in-C"><a href="#Extra-Recursive-Mutex-amp-Lock-in-C" class="headerlink" title="Extra: Recursive Mutex &amp; Lock in C++"></a>Extra: Recursive Mutex &amp; Lock in C++</h2><p>C++ STL 库中存在的 Recursive Mutex 就是一个进程加了几次锁，就要释放几次锁，才能解除对资源的锁定。这一般用在一些特殊的业务逻辑场景中。</p><p>Lock 是利用面向对象的方法对 Mutex 进行了包装。在 Lock 的构造函数中加锁、析构函数中解锁，起到在 Lock 生命周期作用域内保护资源的作用，减轻了编码人员的编码负担。</p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> CSAPP </tag>
            
            <tag> ICS </tag>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Spring Boot 入门</title>
      <link href="//technical/spring-boot-basic/"/>
      <url>//technical/spring-boot-basic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前置条件：WEB 基础（Socket，HTTP 整套规范），SQL 和数据库基础，Java 语言基础、前端基础（至少了解一种前端框架，本文以 React 为例）；</p></blockquote><h1 id="Chapter-0-Basic-Concepts"><a href="#Chapter-0-Basic-Concepts" class="headerlink" title="Chapter 0. Basic Concepts"></a>Chapter 0. Basic Concepts</h1><h2 id="0-1-Servlet-war-amp-jar"><a href="#0-1-Servlet-war-amp-jar" class="headerlink" title="0.1 Servlet, war &amp; jar"></a>0.1 Servlet, <code>war</code> &amp; <code>jar</code></h2><p>在接触 Web 框架时，你肯定能碰到一个绕不开的词：Servlet。它是什么？</p><p>Servlet 本质上就是一种规范，在 Java 的实现中就是一个 Web 规范接口。</p><p>所以，为什么要有这个规范？让我们回到最初的起点。</p><hr><p>假设你什么框架都不用，想要徒手写一个能提供服务的服务器，那需要做哪些工作？</p><p>其实原理比较简单，遵循当今互联网的 HTTP 协议发报文就行：</p><ul><li>先编写基于多线程的 TCP 服务（Web 3.0 准备改用 UDP 了）；</li><li>然后在一个 TCP 连接中读取 HTTP 请求，发送 HTTP 响应即可；</li></ul><p>但是其中还要考虑一些与网络协议相关、与业务逻辑无关的其他情况：</p><ul><li>识别正确和错误的 HTTP 请求；</li><li>识别正确和错误的 HTTP 头；</li><li>复用 TCP 连接；</li><li>复用线程；</li><li>IO 异常处理；</li><li>…</li></ul><p>说到这里头都大了🥹 这些 “基础工作” 需要耗费大量的时间，并且经过长期测试才能稳定运行。如果我们只需要输出一个简单的 HTML 页面，就不得不编写上千行底层代码，那就根本无法做到高效而可靠地开发！</p><p>人们为了简化这一过程，抽象出了一个中间层：Web Server。</p><p>这些共性的、与业务逻辑无关的东西，我们统统交给现成的轮子（web server）去做，我们只需要在 web server 上写自己的应用，与 web server 做沟通就行。</p><p>进一步地，人们为了统一 “应用程序与 Web Server” 的交互接口，进一步实现功能解耦（即如果换了另一个人写的 web server，上层的应用程序根本不需要变），在 Java 中就定义了一个 Web Server 的接口，称为 Servlet。</p><p>上层应用程序可以通过继承于这个接口创建一个适用于自己程序的、处理 Web Server 发来的信息的类，以便把信息传入自己的业务逻辑中。其关系如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                 ┌───────────┐</span><br><span class="line">                 │My Servlet │</span><br><span class="line">                 ├───────────┤</span><br><span class="line">                 │Servlet API│</span><br><span class="line">┌───────┐  HTTP  ├───────────┤</span><br><span class="line">│Browser│&lt;──────&gt;│Web Server │</span><br><span class="line">└───────┘        └───────────┘</span><br></pre></td></tr></table></figure><p>这里的 Web Server 又被称为 Servlet Container，它的作用就是，解析 client / browser 发起的 request，并组装出 HTTP Request、创建 HTTP Response，将二者交于内部自定义的 Servlet（My Servlet）处理和填充。</p><blockquote><p>像 Tomcat、Jetty、GlassFish 就是一些常见的 Web Server。</p></blockquote><p>现在还有一个问题没解决。如果由 Web Server 来帮助我们完成，那么我们写应用程序时，需要和 Web Server 一起编译打包吗？答案是不需要。</p><p>在 Java 中，我们需要将自己写的 Servlet 以及其他业务逻辑的程序打包成一个 <code>*.war</code> 的文件（和 <code>*.jar</code> 不一样，不能直接运行），然后必须由含有 Servlet API 的 Web Server 动态加载进去执行，所以 Web Server 又叫 Servlet Container。</p><p>那么具体自己如何编写 Servlet 呢？以 <code>javax.Servlet</code> 类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 初始化 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">    <span class="comment">/* 2. 获取配置 */</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/* 3. 发出服务 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line">    <span class="comment">/* 4. 获得信息 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/* 5. 销毁 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从原理上讲，Servlet 可以处理<strong>任何类型</strong>的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web Server。</p><h2 id="0-2-Spring-Spring-MVC-Spring-Boot"><a href="#0-2-Spring-Spring-MVC-Spring-Boot" class="headerlink" title="0.2 Spring, Spring MVC, Spring Boot"></a>0.2 Spring, Spring MVC, Spring Boot</h2><p>除了 Servlet，我们还要弄清楚 Spring 框架以及其中的各种常用术语。Spring MVC、Spring、Spring Boot 有什么关系？</p><p>首先尝试理解一下 Spring 框架。</p><blockquote><p>以下部分内容引用自 <a href="https://blog.csdn.net/codeSmart/article/details/106836336">CSDN Blog - 狂野弘仁</a>；</p></blockquote><p>Spring，一般指代的是 Spring Framework，<strong>它是一个开源的应用程序框架</strong>，提供了一个简易的开发方式，通过这种开发方式，将避免那些可能致使代码变得繁杂混乱的大量的业务/工具对象（由框架来帮你管理这些对象，包括它的创建，销毁等）。</p><p>Spring Framework 最重要也是最核心的特性是依赖注入。所有的 <strong>Spring 模块的核心就是 DI（依赖注入）或者 IoC（控制反转）</strong>。依赖注入或控制反转是 Spring Framework 最大的特性，当我们正确使用这二者时，可以开发出一个高内聚低耦合的应用程序，而这一一个低耦合的应用程序可以轻松的对其实施单元测试。这就是 Spring Framework 解决的最核心的问题。</p><blockquote><p>什么是控制反转？</p><p>是一种软件设计思想，也是 Spring 框架的核心概念之一。</p><p>假设类 <code>A</code> 需要类 <code>B</code> 作为组成部分，那么在传统设计理念下，类 <code>A</code> 初始化时，需要顺便创建 <code>B</code> 的对象，并且要在 <code>B</code> 的全部生命周期内维护它。这样做法虽然正确，但是有几个缺点：</p><ol><li>类型紧耦合。如果想要更换 <code>B</code>，那么需要找到类 <code>A</code> 中所有用到 <code>B</code> 的地方全部去改；</li><li>全盘管理外部对象，加重编写负担，模糊业务逻辑，使维护难以进行。</li></ol><p>于是，人们想出一种方法，将数据对象封装成一个 Java Bean，把这个 Bean 交给一个容器管理（被称为 IoC Container，在 Spring 中由框架代码帮忙完成），要用到它的时候写注解自动注入，提升了组件的重用性，实现组件解耦。</p><p>以 Spring 的两个注解为例：</p><p><code>@Component</code>: 该注解将会告诉 Spring Framework，被此注解标注的类需要纳入到 Bean 管理器（IoC Container）中。<br><code>@Autowired</code>: 告诉 Spring Framework 需要找到一与其类型匹配的对象，并将其自动引入到所需要的类中。</p><p>什么是依赖注入？</p><p>可以这么理解：它们是同一个概念的不同角度描述。通俗来说就是 <strong>IoC是设计思想，DI是实现方式</strong>。二者的终极作用是<u>去除 Java 类之间的依赖关系，实现松耦合</u>，以便于开发测试。例如对于这个类型设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;  </span><br><span class="line"> <span class="keyword">private</span> Weapon weapon;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">// weapon 注入</span></span><br><span class="line"> Player(Weapon weapon)&#123;  </span><br><span class="line">     <span class="built_in">this</span>.weapon = weapon;</span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">     weapon.attack();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeapon</span><span class="params">(Weapon weapon)</span>&#123;  </span><br><span class="line">     <span class="built_in">this</span>.weapon = weapon;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Spring Bean 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;player&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.demo.Player&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">construct-arg</span> <span class="attr">ref</span>=<span class="string">&quot;weapon&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;weapon&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.demo.Gun&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们对于 Weapon 的实例构造并不在 <code>Player</code> 内，而是放在配置文件中，依靠<strong>多态</strong>（<code>Gun</code> 继承于 <code>Weapon</code>）和<strong>反射</strong>（读配置、构造对象，外部设置类的行为）实现依赖注入，让两个业务类解耦合。</p><p>或者说，在依赖解耦合方面，<u>控制反转是设计思想，依赖注入是一个设计模式，配置文件只是形式，反射和多态是底层实施手段</u>。</p></blockquote><p>而 Spring Framework 的其他高级特性，例如：Spring AOP、Spring JDBC、Spring MVC、Spring ORM、Spring Test，它们<u>都不是一个全新的功能</u>。因为在不使用 Spring Framework 的情况下，我们依然能够使用 JDBC 连接数据库、依然能够对视图和数据模型进行控制、依然能够使用第三方的 ORM 框架。</p><p>Spring Framework 只是<u>对这些功能中的逻辑采用上述思想进行解耦合，以及进一步封装</u>。例如 Spring JDBC 与传统的 JDBC 相比，使用 JDBC Template 操作数据库，首先是代码量小了，其次是我们不需要再面对恐怖的 try-catch；</p><blockquote><p>如果你还使用过 C++ 配合 MySQL 原生驱动的组合的话，就完全明白这句话的分量……</p></blockquote><p>再比如 Spring Framework 的 MVC，提供了构建 Web 应用程序的全功能 MVC 模块，实现了 Web MVC 设计模式以及请求驱动类型的轻量级 Web 框架，即采用了 MVC 架构模式的思想，将 Web 层进行职责解耦。基于请求驱动指的是使用请求-响应模型，视图与数据模型分离：</p><ul><li>Dispatcher Servlet；</li><li>ModelAndView；</li><li>ViewResolver；</li></ul><p>这个功能模块是人们利用 Spring 解耦的组件进行进一步整合而得出的。</p><p>而 Spring Boot 就像整合了常用配置的“懒人包”，实现多种自动配置：</p><ul><li><p>如果Hibernate的依赖被放到了类路径上，Spring Boot会自动配置数据源；</p></li><li><p>如果Spring MVC的依赖被放到了类路径上，Spring Boot又会自动配置Dispatcher Servlet；</p></li><li><p>当Spring Boot检测到有新的依赖包添加到类路径上，Spring Boot会采用默认的配置对新的依赖包进行设置，如果我们想自己配置依赖包时，只需要手动覆盖默认的配置项即可；</p></li><li><p>Spring Boot 已经内置了多个 Web server，如 Undertow, jetty, tomcat，因此我们不需要再额外的配置服务器（比如前一节提到的打包为 <code>war</code>，然后部署），就可以完成应用程序的调试工作；</p></li></ul><p>所以，严格意义上讲，Spring Boot 并不是某种框架，它只是为开发人员提供了一个更好的更方便的使用 Spring Framework 的解决方案（相当于人家把环境都自动化配好了）。</p><p><img src="imgs/spring-frame.png"></p><h2 id="0-3-RESTful-API"><a href="#0-3-RESTful-API" class="headerlink" title="0.3 RESTful API"></a>0.3 RESTful API</h2><p>在开始前，还要了解一个概念，什么是 RESTful API（你们互联网事真多😅）。</p><p>在互联网并没有完全流行的初期，移动端也没有那么盛行，页面请求和并发量也不高，那时候人们对网络的接口的要求没那么高。只是写一些静态页面、偶尔用用一些动态页面（jsp，整个页面同时刷新）、然后按照 HTTP 等规范手动 DIY 发一发报文，就能满足绝大多数的使用需求。</p><p>但是随着互联网和移动设备的发展，人们对 Web 应用的使用需求也增加，传统的动态页面由于低效率而渐渐被 HTML + JavaScript (Ajax) 的前后端分离所取代，并且安卓、IOS、小程序等形式客户端层出不穷，客户端的种类出现多元化，<strong>而客户端和服务端就需要接口进行通信</strong>，但接口的<strong>规范性</strong>就又成了一个问题。</p><p>假设服务供应方 <code>A</code> 做了一套通信接口，另一个服务供应方 <code>B</code> 又搓了一套通信接口，那么我想同时用这两家服务，难不成还要应用开发者写两套访问逻辑？太不优雅了！</p><p>所以一套<strong>结构清晰、符合标准、易于理解、扩展方便</strong>让大部分人都能够理解接受的<u>接口风格</u>（或者说共同约定）就显得越来越重要。</p><p>2000 年的时候，有个人在他的博士论文中提出了一套软件架构的设计风格（不是标准，只是一组设计原则、共同约定），它主要用于客户端（或浏览器）和服务器交互类的软件。这个人就是 Roy Thomas Fielding。</p><p>基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>这个设计风格也被他命名为 “表述性状态转移”（Representational State Transfer，REST）的架构风格。满足这个架构风格的接口设计就被称为 RESTful API。</p><p>那么这个风格的特征是什么？或者说它的 “共同约定” 是什么？</p><p>REST 架构的 6 个限制条件，又称为 RESTful 6 大原则：</p><ul><li><p><strong>客户端-服务端分离</strong>（解耦）；</p></li><li><p><strong>无状态的（Stateless）</strong>：服务端不保存客户端状态，客户端保存状态信息每次请求携带状态信息；</p></li><li><p><strong>可缓存性（Cacheability）</strong> ：服务端需回复是否可以缓存以让客户端甄别是否缓存提高效率;</p></li><li><p><strong>统一接口（Uniform Interface）</strong>：通过一定原则设计接口降低耦合，简化系统架构，这是RESTful设计的基本出发点；</p><blockquote><p>这组接口就是针对资源的操作，包括获取、创建、修改、删除。</p><p>恰好对应了 HTTP 协议提供的 GET、POST、PUT 和 DELETE 方法。</p><p>注意，REST 原则强烈不建议接口动作与资源访问标识符混合使用。</p><p>REST 认为，<strong>URI指向资源</strong>、以资源为基础，应该以名词标识，真正的动作应该从 HTTP 的请求动作上识别。</p><p>注 1：Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。URI 包括 URL（Locator）和 URN（Navigator）；</p><p>注 2：一个资源可以是文本（通常以 JSON / HTML / XML 为载体）、二进制流等其他任何数据（一般从数据库中拿到的）；</p></blockquote></li><li><p><strong>分层系统（Layered System）</strong>：客户端对服务端的情况无感，无法直接知道连接的到终端还是中间设备，分层允许灵活地部署服务端项目；</p></li><li><strong>按需代码（Code-On-Demand，可选）</strong>：允许我们灵活的发送一些看似特殊的代码给客户端例如 JavaScript 代码。</li></ul><blockquote><p>当然，RESTful API 也是有缺陷的，例如过于重视资源的作用，导致一些与资源关系不大的场合（例如聊天服务器、通信服务器）如果使用 RESTful Web Service 则反而加重了开发负担。</p></blockquote><h3 id="补充：RESTful-API-设计规范"><a href="#补充：RESTful-API-设计规范" class="headerlink" title="补充：RESTful API 设计规范"></a>补充：RESTful API 设计规范</h3><blockquote><p>本部分摘自 <a href="https://zhuanlan.zhihu.com/p/334809573">知乎专栏</a>；</p></blockquote><p>如果想要自己设计一个 RESTful API（而不是使用各大框架中的办法），那么就要遵循以上的约定。具体来说：</p><p>URL 的 path 是需要认真考虑的，而 RESTful 对 path 的设计做了一些规范，通常一个 RESTful API 的 path 组成如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>version</code>：API 版本号，有些版本号放置在头信息中也可以，通过控制版本号有利于应用迭代；<br><code>resources</code>：资源，RESTful API 推荐用小写英文单词的复数形式；<br><code>resource_id</code>：资源的id，访问或操作该资源；</p></blockquote><p>当然，有时候可能资源级别较大，其下还可细分很多子资源也可以灵活设计 URL 的 path，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/&#123;subresources&#125;/&#123;subresource_id&#125;</span><br></pre></td></tr></table></figure><p>此外，有时可能增删改查无法满足业务要求，可以在 URL 末尾加上 action，例如</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/action</span><br></pre></td></tr></table></figure><p>其中 action 就是对资源的操作。</p><p>从大体样式了解 URL 路径组成之后，对于 RESTful API 的 URL 具体设计的规范如下：</p><ol><li>不用大写字母，所有单词使用英文且小写；</li><li>连字符用中杠 <code>&quot;-&quot;</code> 而不用下杠 <code>&quot;_&quot;</code>；</li><li>正确使用 <code>&quot;/&quot;</code> 表示层级关系,URL的层级不要过深，并且越靠前的层级应该相对越稳定；</li><li>结尾不要包含正斜杠分隔符 <code>&quot;/&quot;</code>；</li><li>URL中不出现动词，用请求方式表示动作；</li><li>资源表示用复数不要用单数；</li><li>不要使用文件扩展名；</li></ol><p>此外，在 RESTful API 中，不同的HTTP请求方法有各自的含义，这里就展示 GET,POST,PUT,DELETE 几种请求 API 的设计与含义分析。针对不同操作，具体的含义如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /collection： 从服务器查询资源的列表（数组）</span><br><span class="line">GET /collection/resource： 从服务器查询单个资源</span><br><span class="line">POST /collection： 在服务器创建新的资源</span><br><span class="line">PUT /collection/resource： 更新服务器资源</span><br><span class="line">DELETE /collection/resource： 从服务器删除资源</span><br></pre></td></tr></table></figure><p>在非 RESTful 风格的 API 中，我们通常使用 GET 请求和 POST 请求完成增删改查以及其他操作，查询和删除一般使用 GET 方式请求，更新和插入一般使用 POST 请求。从请求方式上无法知道 API 具体是干嘛的，所有在 URL 上都会有操作的动词来表示 API 进行的动作，例如：query，add，update，delete 等等。</p><p>而 RESTful 风格的 API 则要求在 URL 上都以名词的方式出现，从几种请求方式上就可以看出想要进行的操作，这点与非 RESTful 风格的 API 形成鲜明对比。</p><p>在谈及 GET,POST,PUT,DELETE 的时候，就必须提一下接口的<strong>安全性和幂等性</strong>，其中安全性是指方法不会修改资源状态，即读的为安全的，写的操作为非安全的。而幂等性的意思是操作一次和操作多次的最终效果相同，客户端重复调用也只返回同一个结果。</p><div class="table-container"><table><thead><tr><th>HTTP Method</th><th>安全性</th><th>幂等性</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>安全</td><td>幂等</td><td>读操作（安全），查询多次结果一致</td></tr><tr><td>POST</td><td>非安全</td><td>非幂等</td><td>写操作（非安全），每次插入后与上次的结果不一样</td></tr><tr><td>PUT</td><td>非安全</td><td>幂等</td><td>写操作（非安全），插入相同数据多次结果一致</td></tr><tr><td>DELETE</td><td>非安全</td><td>幂等</td><td>写操作（非安全），删除相同数据多次结果一致</td></tr></tbody></table></div><h3 id="Tips-调试数据请求时的类型选择"><a href="#Tips-调试数据请求时的类型选择" class="headerlink" title="Tips. 调试数据请求时的类型选择"></a>Tips. 调试数据请求时的类型选择</h3><p>在使用类似 Postman 的工具发送请求时，可能会遇到不同种类可选的数据类型：</p><ul><li><strong>form-data</strong>： 就是 form 表单中的 multipart/form-data，会将表单数据处理为一条信息，用特定标签符将一条条信息分割开，而这个文件类型通常用来上传二进制文件；</li><li><strong>x-www-form-urlencoded</strong>：就是application/x-www-form-urlencoded，是 form 表单默认的 encType，form 表单会将表单内的数据转换为键值对，这种格式不能上传文件；</li><li><strong>raw</strong>：可以上传任意格式的文本，可以上传 Text，JSON，XML 等，但目前大部分还是上传 JSON 格式数据。当后端需要接收 JSON 格式数据处理的时候，可以采用这种格式来测试。</li></ul><blockquote><p>这部分概念太多了，有些概念用到再说。</p></blockquote><h1 id="Chapter-1-Introduction-to-Spring-Boot"><a href="#Chapter-1-Introduction-to-Spring-Boot" class="headerlink" title="Chapter 1. Introduction to Spring Boot"></a>Chapter 1. Introduction to Spring Boot</h1><h2 id="1-1-First-Spring-Boot-Project-A-RESTful-Web-Service"><a href="#1-1-First-Spring-Boot-Project-A-RESTful-Web-Service" class="headerlink" title="1.1 First Spring Boot Project: A RESTful Web Service"></a>1.1 First Spring Boot Project: A RESTful Web Service</h2><p>在进入枯燥的概念和接口学习前，先用简单的方法构建一个简单的 RESTful Web Service 出来。</p><p>首先使用 gradle 构建管理工具创建一个项目，引入依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;3.2.4&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="string">&#x27;1.1.4&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包位置 priv.demo */</span></span><br><span class="line">group = <span class="string">&#x27;priv.demo&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">java &#123;                                                                                   sourceCompatibility = <span class="string">&#x27;21&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;                                                                           mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;                                                                           implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">   testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">tasks.named(<span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个 Java 记录类型作为存放数据的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Greeting</span><span class="params">(<span class="type">long</span> id, String content)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>创建一个资源控制器（相当于 Servlet 的处理逻辑）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">template</span> <span class="operator">=</span> <span class="string">&quot;Hello, %s!&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/greeting&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Greeting <span class="title function_">greeting</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>(counter.incrementAndGet(), String.format(template, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下 <code>@GetMapping(&lt;path&gt;)</code>：保证所以筛选到 <code>&lt;path&gt;</code> 路径的 GET 请求被框架统一转发给被修饰的方法（这里是 <code>greeting</code>）。</p><p>其中，如果要处理 HTTP 尾缀参数，那么被 <code>@GetMapping</code> 修饰的方法强烈建议使用 <code>@RequestParam(&lt;value&gt;, &lt;defaultValue&gt;)</code> 修饰参数，这样能清楚地知道处理参数的情况。</p><p>例如上面的例子中，Servlet 能识别 <code>GET /greeting</code> 的请求，并且调用后端程序的 <code>greeting</code> 方法。返回的 record 对象会被框架自动解析并以 JSON 形式响应客户端（浏览器）。</p><p>由于方法中写了 <code>@RequestParam</code>，因此可以接受任何 <code>/greeting?name=&lt;...&gt;</code> 的后缀参数信息。</p><blockquote><p>除了这里的 <code>@GetMapping</code>，还有 <code>@PostMapping</code>（对应 POST 请求）等等。</p><p>此外，<code>@RequestMapping(method=GET)</code> 等价于 <code>@GetMapping</code>，相当于是其他各种 Mapping 的综合体。</p></blockquote><p>另外，我们使用了 <code>AtomicLong</code> 类型，保证多线程情况下的安全性。<code>counter</code> 为当前运行时请求编号；</p><p>最后，还需要说明，这个类只有使用 <code>@RestController</code> 注解才能发挥作用。</p><p>它的作用是标识这个类作为一个 RESTful API 的资源接收和控制器，并且<u>其中的每个方法都会返回 domain object，而不是一个 view（视图，传统 MVC Controller 都会返回视图）</u>。这个注解等价于 <code>@Controller</code> 和 <code>@ResponseBody</code>（表示这里生成的是 HTTP 响应体）联合使用。</p><p>实际上，使用 <code>@RestController</code> 修饰的类中每个方法返回的 domain object 应该被转为 JSON（就是这里的 Greeting 对象应该转为 JSON）。但是因为有一个库 <code>Jackson 2</code> 的存在，Spring 会自动选择 <code>MappingJackson2HttpMessageConverter</code> 来将 record 实例转为 JSON。</p><p>最后，我们创建一个 <code>main</code> 函数来启动服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestServiceApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RestServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，<code>@SpringBootApplication</code> 相当于以下 3 个注解的结合：</p><ul><li><p><code>@Configuration</code>：将被修饰的类标记为当前 Application 上下文的 Bean 的定义方；</p><blockquote><p>回忆 DI（依赖注入），这里相当于产生 Bean（之前的 Record 类型）的类型。</p></blockquote></li><li><p><code>@EnableAutoConfiguration</code>: 告诉 Spring Boot 根据当前 classpath 中的设置来开始注入 beans，以及其他属性设置。例如，如果 <code>spring-webmvc</code> 在 classpath 中，那么这个注解的含义就是将这个类标记为 Web Application，并且激活一些重要的行为，例如设置启动 <code>DispatcherSevlet</code>；</p></li><li><p><code>@ComponentScan</code>：告诉 Sping 来查找其他的在 <code>priv/demo</code> 中的组件、设置和服务包，并且找到 Controller；</p></li></ul><h2 id="1-2-What-is-MVC"><a href="#1-2-What-is-MVC" class="headerlink" title="1.2 What is MVC?"></a>1.2 What is MVC?</h2><p>MVC 是一种软件设计架构模式，大多数时候应用在 Web Application 中，主要分为 3 层：</p><ul><li>Control Layer：软件控制层。如果用在 Web App 上，这层的职责是<u><strong>解析</strong>从 Web Server 传来的对特定 URL 的请求，并转发给服务程序的相应逻辑块</u>；</li><li>Model Layer：软件模型层。实际上的职责是<u>软件的数据表示</u>（就是对关系型数据库中存储的数据以及表单进行面向对象的表述），能让你轻松地从数据库中取出数据后放入对象中，并且轻松地展示在 Web 页面上；</li><li>View Layer：软件视图层。在传统的 Web 应用架构中，前端的程序主导了这个任务（比如 React、Anngular）。但是在 MVC 架构中，这部分位于后端，并且它的职责是<u>收到从数据库传来的数据，并将其组织在 Web 页面上</u>。</li></ul><h2 id="1-3-What-is-Dispatcher-Servlet"><a href="#1-3-What-is-Dispatcher-Servlet" class="headerlink" title="1.3 What is Dispatcher Servlet?"></a>1.3 What is Dispatcher Servlet?</h2><p>在 Spring MVC 中，有些东西不解释清楚就没法开始。比如一个 Spring MVC 中的概念 Dispatcher Servlet。</p><p>我们知道，Servlet 就是一种 Web Server 和 Web App 间的接口。在 Web App 软件层面只要按照 Servlet 接口实现一个 Servlet 就能与 Web Server 直接交互。</p><p>所谓的 Dispatcher Servlet 是一种编码模式（code pattern），也是 Servlet 的一种实现方式，在 MVC 架构中，作为 Control Layer 的一部分。</p><p>它在概念上主要完成了一件重要的事情：<strong>Request Handling &amp; Mapping</strong>。</p><p>Dispatcher Servlet 实现了 Servlet 接口，能给接收从 Web Server 传来的 HTTP 请求。当一个请求到达 Spring MVC Application 时，它会首先到达 Control Layer 的 Dispatcher Servlet。</p><p>Dispatcher Servlet 会根据 Spring Framework 对于请求的配置（底层配置在 <code>web.xml</code> 中，但 Spring MVC 已经包装在了像 <code>@ReuqestMapping</code> 一类的注解中了），映射（map）到相应的 Controller 中（通常被包装为一个方法）进行处理。</p><p>此后，收到 Dispatcher Servlet 请求的 controller 中会对传入的数据进行详细处理，例如处理请求参数、访问数据库、准备响应体等等。</p><p>再然后，Controller 会将处理好的数据交给指定的 view 进行组装。这里的 View Layer 会生成像 JSP / Thymeleaf templates / JSON 之类的数据结构，并且发送。</p><blockquote><p>Dispatcher Servlet 的这种职责实际上也是采用了一种编码模式，叫做 Front Controller。</p></blockquote><h2 id="1-4-What-does-Models-actually-do"><a href="#1-4-What-does-Models-actually-do" class="headerlink" title="1.4 What does Models actually do?"></a>1.4 What does Models actually do?</h2><p>在 Spring MVC 中，显然一个 Model 作为软件的数据表示，是一个至关重要的部分。但同时也是 Spring MVC 包装较好的部分、较简单的部分。</p><p>一个 Model 通常可以是一个 “POJO”（Plain Old Java Class / Object）；</p><blockquote><p>什么是 POJO？</p><p>Plain Old Java Object 特指那些 <strong>不用 extends / implements 其他外部框架的、不使用外部框架的 annotation 的 Java 类型</strong>。</p><p>简言之，你能不依赖框架写出的手写 Java 类型的实例都是 POJO。例如 Java Bean 就是典型的 POJO（允许 extends Java 原生接口，例如 <code>Serializable</code>）。</p><p>使用 POJO 的优势是，POJO 能够更加贴近、关注业务逻辑，不依赖外部框架代码（与外部框架解耦），不需要考虑外部代码对它的隐式影响。</p></blockquote><p>不过 Model 所包含的功能不止于用 POJO 保存信息，它还要完成一个重要的职责：<u>将 POJO 与关系型数据库表建立关联</u>（这个过程由 Spring JPA 模块完成）。</p><p>那么，接下来如何让 Spring Framework 知道这个 POJO 对应的类型是个 Model，并且如何将 POJO 由 JPA 映射为关系型数据库的表记录呢？</p><p>一般需要做 3 件事：</p><ol><li><p>确定描述 Model 的 POJO 类型。这件事就在告诉 Spring，这个类是个表示数据的类（即 Model），等会 JPA 可以按照这个类型创建关系型数据库的表单；</p><blockquote><p>这件事既可以由 <code>XML</code> 配置来做，也可以由 Spring Boot 包装好的注解 <code>@Entity</code> 来做。</p><p>但是如果加了注解，原来的类就不再是 POJO 类型。所以为了便捷性，需要在规范上作出一些取舍。</p></blockquote></li><li><p>确定 Model 中的哪个数据域为 POJO 的唯一识别符。这个表示建议 JPA 在创建数据库表时，将这个数据类型作为表的 <u>主键</u>；</p><blockquote><p>同样，这件事既可以由 <code>XML</code> 配置来做，也可以由 Spring Boot 包装好的注解 <code>@Id</code> 来做。</p></blockquote></li><li><p>决定 Model 中的哪些数据域是需要框架 / 驱动来生成的，而不是用户（Requests）传入的。这个告诉 JPA，这个数据域外部不会给定，应该由程序根据情况生成。</p><blockquote><p>举个例子，你可能在第二条中，想要为每个同类型的 POJO 维护一个全局唯一的 id，但这个 id 肯定不能由用户指定，通常是数据库的自增键来自动生成。</p><p>在 Spring Boot 中，提供了 <code>@GeneratedValue</code> 注解，相当于告诉 JPA，这个数据域应该生成而不是传入得到（通常是通过数据库当前的信息判断出来）。默认行为是在 JPA 生成数据库表时，将被修饰的数据域生成成为 “auto increment”（这种数据域被称为 database indentity）；</p></blockquote></li></ol><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.persistence.*;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.CreationTimestamp;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.UpdateTimestamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span>   <span class="comment">/* Equivalent to @Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode.  */</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span>    <span class="comment">/* Generate ClassBuilder static class */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;posts&quot;)</span>  <span class="comment">/* Tell JPA to generate data into named table &#x27;books&#x27;. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostInfo</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">/* Equivalent to: UNIQUE + NOT NULL + IMMUTABLE */</span></span><br><span class="line">    <span class="comment">/* It relies on an auto-incremented database column</span></span><br><span class="line"><span class="comment">     * and lets the database generate a new value with each insert operation.</span></span><br><span class="line"><span class="comment">     * But, this prevents it from using different optimization techniques like JDBC batching. */</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long postId;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreationTimestamp</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createdOn;</span><br><span class="line">    <span class="meta">@UpdateTimestamp</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updatedOn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-N-Tier-Architecture"><a href="#1-5-N-Tier-Architecture" class="headerlink" title="1.5 N-Tier Architecture"></a>1.5 N-Tier Architecture</h2><blockquote><p>前置知识：什么是 DTO？</p><p>在 MVC 架构中，有一种对象称数据转移对象（Data Transfer Object）。它的作用是在 Application 的不同层级 / 子系统间传输数据。</p><p>DTO 尤其常用在 N-Tiers 中使用，其好处是减少数据在各部分传输的量，使得程序信息能清晰地相互传输。具体的应用场景如下：</p><ul><li>假设数据库中原本抽象出的对象有很多属性，但是我在某些层级间传输时，只需要用到一部分。那么就没有必要把对象整体传来传去：我们可以定义一个 DTO 类型，属性是原类型的子集，使得功能清晰、传参无负担；</li><li>假设有个方法需要传入 4 个以上参数，那么写方法签名、手动传参就不现实。可以定义一个 DTO 类型来向其传参，语义更清晰；</li></ul><p>所以，DTO 就是一种普通的类型，提取了某个类型的一些属性。</p><p>例如，上一节定义的 <code>PostInfo</code> 中，有一些数据现在不需要在 App 中传输，那么可以这么定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long postId;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>在软件工程中有个非常有趣的事实是，90% 的时候都无需使用软件工程的设计原理（software engineering design patterns），但是应用在底层的架构设计是恰恰又需要用到。</p><p>有一种软件设计架构叫 N-Tier（或者说 N-Tier Repository Pattern，Multi-Tier Architecture），也是接下来我们想要实践的架构。它是一种 C/S 架构设计模式，最广泛的使用方法是将其分为 3 个部分：</p><ul><li><p>Data Tier（Repository）：以 Web 开发为例，通常在 Java 后端服务中，此层是管理数据库的部分（在 Java 中通常封装为一个类型）。它通常具有 CRUD 四种方法，并且充当了在数据库表结果 和 对象之间转换的桥梁；</p><blockquote><p>在 Spring JPA 中提供了一个接口 <code>JpaRepository&lt;EntityType, EntityIdType&gt;</code> 轻松定义 custom query method（这样我们可通过方法名判断出对应的 SQL 语句）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> priv.demo.models.PostInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PostRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;PostInfo, Long&gt; &#123;</span><br><span class="line"> Optional&lt;PostInfo&gt; <span class="title function_">findByPostId</span><span class="params">(Long postId)</span>;</span><br><span class="line"> List&lt;PostInfo&gt; <span class="title function_">findByTitle</span><span class="params">(String title)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>PostRepository</code> 又称 DAO（Data Access Object）类型。DAO 和 DTO 一样，也是一种编码模式（code pattern），它的作用是使用一组 API 将 application tier / bussiness logic 与 persistence layer 隔离开，达到模块解耦的作用。</p></blockquote></li><li><p>Application Tier（Bussiness Logic）：以 Web 开发为例，通常在 Java 后端服务中，此层是通常是 Spring 框架中处理数据的业务逻辑部分；</p><blockquote><p>在使用 Spring MVC 时，除了我们直接写 Controllers 外，还建议抽象出一层 “Service”（服务层），这样可以把处理特定的数据库操作与业务逻辑解耦（即可以表示处理特定业务逻辑所需的操作），这样项目功能改变时就不用担心大幅度改代码，只需要到实现功能的 service 中改动就行，不会有 ”这块代码是干什么“ 的担忧。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo.services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> priv.demo.dto.PostDto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PostService</span> &#123;</span><br><span class="line"> <span class="comment">/* Use predefined DTO in services */</span></span><br><span class="line"> List&lt;PostDto&gt; <span class="title function_">findAllPosts</span><span class="params">()</span>;</span><br><span class="line"> Optional&lt;PostDto&gt; <span class="title function_">findPostsById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们再实现这个接口，注意因为服务抽象肯定需要 repository 的数据库操作，因此需要与 <code>JpaRepository</code> 组合。这个时候就用到了 Spring 的依赖注入的特性，让模块解耦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo.services.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> priv.demo.dto.PostDto;</span><br><span class="line"><span class="keyword">import</span> priv.demo.models.Post;</span><br><span class="line"><span class="keyword">import</span> priv.demo.repositories.PostRepository;</span><br><span class="line"><span class="keyword">import</span> priv.demo.services.PostService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>    <span class="comment">/* provide Spring with PostSerivce Bean */</span></span><br><span class="line">            <span class="comment">/* (可以在写 Controller 时再回来添加)  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PostService</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Use Jpa Repository to achieve goals */</span></span><br><span class="line"> PostRepository postRepository;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Use Spring Dependency Injection: inject repo to de-couple dependencies. */</span></span><br><span class="line"> <span class="comment">/* Also, we need to provide repository from other area.</span></span><br><span class="line"><span class="comment">     * Here we provide Spring with repo in  */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PostServiceImpl</span><span class="params">(PostRepository repository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.postRepository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;PostDto&gt; <span class="title function_">findAllBooks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;PostInfo&gt; posts = postRepository.findAll();</span><br><span class="line">        <span class="keyword">return</span> posts.stream().map((post -&gt; mapToPostDto(post))).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;PostDto&gt; <span class="title function_">findPostsById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        Optional&lt;Post&gt; src = postRepository.findByPostId(id);</span><br><span class="line">        <span class="keyword">return</span> (src.map(PostServiceImpl::mapToPostDto));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@implNote</span> Private self-defined mapper.</span></span><br><span class="line"><span class="comment">     *  Covert model (database representation) to DTO (app representation).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PostDto <span class="title function_">mapToPostDto</span><span class="params">(PostInfo post)</span> &#123;</span><br><span class="line">        <span class="type">PostDto</span> <span class="variable">postDto</span> <span class="operator">=</span> postDto.builder()</span><br><span class="line">                .postId(post.getPostId())</span><br><span class="line">                .title(post.getTitle())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> postDto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，以上从 <code>PostInfo</code>（数据库表示，即 model）向 <code>PostDto</code>（应用程序传输表示，即 DTO）转换时，需要自定义 <code>mapToPostDto</code> 的方法。</p><p>此外，在数组元素处理时，我们还使用了 Java 中类似 JavaScript 的处理方法 <code>map</code>，对数组每个元素的处理方法就变简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt;.stream().map(&lt;mapFunc&gt;);    <span class="comment">/* 返回映射后的 Stream 对象 */</span></span><br><span class="line">Stream.collect(Collectors.toList());    <span class="comment">/* 将产生的 Stream 对象转换回 List&lt;T&gt; */</span></span><br></pre></td></tr></table></figure><p>再聊聊 Controllers 的部分。后面的数据布置都已清晰，剩下来还要布置 Controller 处理 Web Server 发来的请求。</p><p>除了在在 1.1 中见到的 <code>@RestController</code> 可以创建普通的 REST Controller 以外，还有普通的 Controller <code>@Controller</code>（少了将 Controller 方法组织成资源返回值的方法）；</p><p>此外，<code>@RequestMapping()</code> 可以使用、<code>@GetMapping/@PostMapping/@DeleteMapping/...</code> 注解也可以使用。</p></blockquote></li><li><p>Presentation Tier（Frontend）：以 Web 开发为例，通常在前端服务中，此层就是渲染 Web Page 页面的部分，可以由 React 等框架解决。</p></li></ul><h2 id="1-6-CRUD-Read-Data"><a href="#1-6-CRUD-Read-Data" class="headerlink" title="1.6 CRUD: Read Data"></a>1.6 CRUD: Read Data</h2><p>以上的所有知识已经足够我们将前端、后端连接起来。当然，后端如果要处理数据，还得把接下来几节学完。</p><p>现在让我们一起巩固所学，将前端和后端连接起来，先了解 “前端读取后端数据” 的效果如何达成。</p><p>首先，我们由上面的示例，已经能利用 JPA 从数据库中获取数据，并且呈现 JSON 结果了。因此我们只需要修改事先写好的前端，加入 <code>fetch</code> API，读取从后端传来的数据，再呈现在页面上即可。只要你完全了解了上面的理论，那么 read data 就是简单地在前端加上 <code>fetch</code> 获取资源，仅此而已。</p><p>值得注意的是，如果你做的项目也是前后端分离的（服务在不同端口上），那么 CORS 将会是一大问题。请自行查阅资料解决，笔者贴上自己的解决方案（Spring Boot）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configurations</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">corsMappingConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                        <span class="comment">/* Frontend server runs at localhost:3000 */</span></span><br><span class="line">                        .allowedOrigins(<span class="string">&quot;http://localhost:3000&quot;</span>)</span><br><span class="line">                        .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PATCH&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>, <span class="string">&quot;HEAD&quot;</span>)</span><br><span class="line">                        .maxAge(<span class="number">3600</span>)</span><br><span class="line">                        .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-Validation-in-Backend"><a href="#1-7-Validation-in-Backend" class="headerlink" title="1.7 Validation in Backend"></a>1.7 Validation in Backend</h2><p>在后端的 DTO 类型中，往往可以添加许多注解来代替我们完成繁琐且常见的数据校验操作，例如：</p><p><code>@NotNull</code>, <code>@NotBlank</code>, <code>@NotEmpty</code>, <code>@Email</code>, <code>@Min</code>, <code>@Max</code>, <code>@Size</code>, <code>@Pattern</code>, <code>@Phone</code>, <code>@Past</code>；</p><p>以上是库 <code>spring-boot-starter-validation</code> 的校验注解，需要自行安装。但由于它们注解在类的属性上，所以只有当你在 Controller 中获取表单参数时加入 <code>@Valid</code>，并配合 <code>BindingResult</code>（请添加第二参数）才会使这些注解生效。</p><h2 id="1-8-CRUD-Create-Data-Update-Data"><a href="#1-8-CRUD-Create-Data-Update-Data" class="headerlink" title="1.8 CRUD: Create Data / Update Data"></a>1.8 CRUD: Create Data / Update Data</h2><p>用户可能会通过表单向前端提交数据，这个过程通常会造成数据库的某些信息的修改。因此，我们有必要了解一下从前端传入数据，到后端修改数据的过程。</p><p>本节先对 “CRUD” 中的 Create 进行介绍，介绍在以上的 N-Tiers 架构设计中，Create 动作是如何完成的。</p><p>通常情况下，用户会在前端的 <code>&lt;form&gt; &gt; &lt;input&gt;</code> 中填写数据，再 submit，前端会使用 <code>fetch</code> API 向后端发送表单信息。</p><p>对于 Create Data 而言，常常不是幂等的，因此使用 <code>PostMapping</code>，而 Update Data 而言大多数情况下是幂等的，因此使用 <code>PutMapping</code>；</p><p>在 JPA 中，对于简单的数据表而言，一条 <code>repository.save(Entity)</code> 即可完成创建或者更新的操作。</p><h2 id="1-9-CRUD-Delete-Data"><a href="#1-9-CRUD-Delete-Data" class="headerlink" title="1.9 CRUD: Delete Data"></a>1.9 CRUD: Delete Data</h2><p>对于 JPA 的简单表而言，一条 <code>repository.delete(Entity)</code> 即可完成任务。</p><h2 id="1-10-JPQL-Search-Data"><a href="#1-10-JPQL-Search-Data" class="headerlink" title="1.10 JPQL: Search Data"></a>1.10 JPQL: Search Data</h2><p>除了前面的对于数据库的操作过于简单，我们无需写 SQL 语句以外，在用户的搜索场景中，由于搜索条件的复杂性，导致 Spring JPA 生成的 SQL 语句通常有性能问题。</p><p>所以自己写 SQL 语句查询往往是个好选择，开发者还可以根据自己写的 SQL 语句进行自行优化。</p><p>值得注意的是，在模糊搜索中 <code>CONTAINS</code> 和 <code>LIKE</code> 关键字的性能由数据库的类型决定，谨慎使用。</p><p>此外，有两种索引方式：name index、normal index。前者表示在代码中使用参数名嵌入 SQL 索引，后者表示使用类似 <code>?1</code> 指定参数位来嵌入 SQL 索引。</p><p>例如，查找 SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT post FROM posts WHERE post.title LIKE &quot;%hello%&quot;</span><br></pre></td></tr></table></figure><p>那么在 Spring JPA 中，提供了 <code>@Query</code> 方法可以在 <code>JpaRepository</code> 中使用，语法如下（以 name index 为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PostRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;PostInfo, Long&gt; &#123;</span><br><span class="line">    <span class="comment">/* Other methods... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query(&quot;SELECT post FROM Post post WHERE post.title LIKE CONCAT(&#x27;%&#x27;, :input, &#x27;%&#x27;) &quot;)</span></span><br><span class="line">    List&lt;PostInfo&gt; <span class="title function_">searchPost</span><span class="params">(String input)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Other methods... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到：</p><ul><li>在内嵌 SQL 语句中，name index 前使用 <code>:</code> 来标识；</li><li>由于插入了变量，因此字符串需要拼接而不是直接使用；</li></ul><h2 id="1-11-One-To-Many-Spring-Data"><a href="#1-11-One-To-Many-Spring-Data" class="headerlink" title="1.11 One-To-Many Spring Data"></a>1.11 One-To-Many Spring Data</h2><p>关系型数据库中，有一种关系是一对多的数据关系。例如，一个用户可以对应持有多个订单。</p><p>这种关系在 Spring JPA 中以 <code>@OneToMany</code> 来表示。值得注意的是，这种关系是有关联的，通常要求父数据（One）被删除时，与该父数据关联的子数据（Many）需要一并全部删除，这种删除关系被称为 Cascade（级联），更详细的信息请参见数据库教程。</p><p>此外，如果是一对多的关系，在关系型数据库中通常还要联接表的列，以便联接查询。在 Spring JPA 中还提供了 <code>@JoinColumn</code> 注解，可以注解到要存放关联列的表的列 field 中（通常位于 “Many” 子数据表中）。</p><h1 id="Chapter-2-Spring-Security"><a href="#Chapter-2-Spring-Security" class="headerlink" title="Chapter 2. Spring Security"></a>Chapter 2. Spring Security</h1><h2 id="2-1-Spring-Security-Overview-Servlet-App"><a href="#2-1-Spring-Security-Overview-Servlet-App" class="headerlink" title="2.1 Spring Security Overview (Servlet App)"></a>2.1 Spring Security Overview (Servlet App)</h2><p>强烈建议至少阅读 <a href="https://docs.spring.io/spring-security/reference/servlet/architecture.html">官方文档的 架构总览</a> 章节，以获得对于 Spring Security 在 Servlet 应用中的宏观上的认识。</p><p>总结下来，Spring Security 在 Servlet 应用上的架构有如下几个重要的点：</p><ul><li><p>以过滤器（filter）为核心。Spring Security 内置很多层 Filter：</p><p><img src="imgs/filterchain.png" width="200px"></p><p><img src="imgs/filterchain2.png" height="250px"></p><blockquote><p>Spring Security包含了众多的过滤器，这些过滤器形成了一条链，所有请求都必须通过这些过滤器后才能成功访问到资源。</p><ul><li><code>UsernamePasswordAuthenticationFilter</code> 过滤器用于处理基于表单方式的登录认证；</li><li><code>BasicAuthenticationFilter</code> 用于处理基于HTTP Basic方式的登录验证，后面还可能包含一系列别的过滤器（可以通过相应配置开启）；</li><li><code>FilterSecurityInterceptor</code> 用于判断当前请求身份认证是否成功，是否有相应的权限，当身份认证失败或者权限不足的时候便会抛出相应的异常；</li><li><code>ExceptionTranslationFilter</code> 能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常： <code>AuthenticationException</code> 和 <code>AccessDeniedException</code>，其它的异常它会继续抛出。</li></ul><p>另外，可以打印出内部的默认部署的 filters 情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.security.web.session.DisableEncodeUrlFilter@404db674,</span><br><span class="line">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@50f097b5,</span><br><span class="line">org.springframework.security.web.context.SecurityContextHolderFilter@6fc6deb7,</span><br><span class="line">org.springframework.security.web.header.HeaderWriterFilter@6f76c2cc,</span><br><span class="line">org.springframework.security.web.csrf.CsrfFilter@c29fe36,</span><br><span class="line">org.springframework.security.web.authentication.logout.LogoutFilter@ef60710,</span><br><span class="line">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@7c2dfa2,</span><br><span class="line">org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter@4397a639,</span><br><span class="line">org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@7add838c,</span><br><span class="line">org.springframework.security.web.authentication.www.BasicAuthenticationFilter@5cc9d3d0,</span><br><span class="line">org.springframework.security.web.savedrequest.RequestCacheAwareFilter@7da39774,</span><br><span class="line">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@32b0876c,</span><br><span class="line">org.springframework.security.web.authentication.AnonymousAuthenticationFilter@3662bdff,</span><br><span class="line">org.springframework.security.web.access.ExceptionTranslationFilter@77681ce4,</span><br><span class="line">org.springframework.security.web.access.intercept.AuthorizationFilter@169268a7]</span><br></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>Spring Security 认证、授权的大致原理就是，借助这些 filters 判断这个请求是否有效，无效则抛出异常拒绝访问；</p></li><li><p>对 Spring Security 的设置，可以说就是对这些 filters 的配置、自定义；</p><ul><li>配置：可以禁用、启用其中的 filters，为其中的 filters 设置参数等；</li><li>自定义：基于 Spring Security 提供的接口类，自定义 filters；</li></ul></li></ul><p>实际上，Spring Security 相当灵活，能够胜任：认证（像登录工作）、授权（像当前登录用户是否有权限）、外部授权服务器的认证和授权（像 OAuth2 协议）等任务。</p><p>其中，使用用户名-密码的方式认证、授权是最简单的一种，本章不作详细介绍。</p><p>最后，如果你发现自己写了一个配置，测试时却怎么都连不上，可以在 <code>application.properties</code> 内打开测试日志，帮助 debug：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.org.springframework.security</span>=<span class="string">TRACE</span></span><br></pre></td></tr></table></figure><h2 id="2-2-Spring-Security-OAuth2-0"><a href="#2-2-Spring-Security-OAuth2-0" class="headerlink" title="2.2 Spring Security: OAuth2.0"></a>2.2 Spring Security: OAuth2.0</h2><h3 id="2-2-1-OAuth2-0-Overview"><a href="#2-2-1-OAuth2-0-Overview" class="headerlink" title="2.2.1 OAuth2.0 Overview"></a>2.2.1 OAuth2.0 Overview</h3><p>Spring Security 除了普通的自定义用户名-密码验证，还支持 OAuth2.0 外部的授权服务器验证。</p><p>在了解 Spring Security 如何操作前，先了解 OAuth2.0 的协议是什么。</p><p>查看 <a href="https://www.rfc-editor.org/rfc/rfc6749">RFC 6749 标准</a>，其提供了抽象的协议流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--------+                               +---------------+</span><br><span class="line">|        |--(A)- Authorization Request -&gt;|   Resource    |</span><br><span class="line">|        |                               |     Owner     |</span><br><span class="line">|        |&lt;-(B)-- Authorization Grant ---|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(C)-- Authorization Grant --&gt;| Authorization |</span><br><span class="line">| Client |                               |     Server    |</span><br><span class="line">|        |&lt;-(D)----- Access Token -------|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(E)----- Access Token ------&gt;|    Resource   |</span><br><span class="line">|        |                               |     Server    |</span><br><span class="line">|        |&lt;-(F)--- Protected Resource ---|               |</span><br><span class="line">+--------+                               +---------------+</span><br></pre></td></tr></table></figure><p>简单来说，OAuth2.0 协议的过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(A) 用户（就是 resource owner）访问客户端，客户端将用户导向认证服务器。</span><br><span class="line"></span><br><span class="line">(B) 用户选择是否给予客户端授权。</span><br><span class="line"></span><br><span class="line">(C) 假设用户给予授权，认证服务器先生成一个授权码，并返回给用户，认证服务器将用户导向客户端事先指定的“重定向URI”（redirect uri），同时附上一个授权码（code）。</span><br><span class="line"></span><br><span class="line">(D) 客户端收到授权码，附上早先的“重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</span><br><span class="line"></span><br><span class="line">(E) 认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）或更新令牌（refresh token）。</span><br><span class="line"></span><br><span class="line">(F) 客户端验证身份令牌信息的完整性和正确性，并解析获取当前用户信息。</span><br></pre></td></tr></table></figure><p>这就是 OAuth2.0 协议最规范、最完整、最常用、最安全的使用方法：授权码模式。RFC 6749 标准还规定了其他 3 种获取令牌（token）的模式：</p><ul><li>简化模式；</li><li>密码模式；</li><li>客户端模式；</li></ul><p>这些方法的安全性和规范性依次递减。</p><p>此外，我们从上图可知，一个后端程序想要使用 OAuth2.0，我们至少需要搭建：</p><ul><li>一个 OAuth2.0 客户端（用于处理用户、授权服务器、资源服务器之间的交互）；</li><li>一个授权服务器（用户的认证信息存放位置）；</li><li>一个资源服务器（用户的资源存放位置）；</li></ul><p>如果你使用第三方的 OAuth2.0 认证服务，就是说，使用第三方的认证服务来获取这个用户的有限的身份信息，那么只需要开发自己的客户端（client）即可，<strong>授权服务器（Authorization Server）和资源服务器（Resource Server）都是由第三方提供的</strong>。</p><blockquote><p>举个例子，Github 第三方授权见过吧？很多网站都支持 QQ / 微信第三方登录吧？它们的底层都可以使用 OAuth2.0 来完成。</p><p>使用 OAuth2.0 可以验证当前的用户的身份，只不过是：在不需要知道用户的密钥的前提下，将用户的认证、授权委托给第三方（授权服务器）来完成，客户端（client）只要询问第三方，这个用户合不合法、用户的基本信息是什么（<u>有限的信息，给多少取决于第三方授权服务器，以及用户在弹出的授权框里自己指定</u>），就能证明这个用户的身份了。</p></blockquote><p>本章也不说 OAuth2.0 授权服务器、资源服务器的搭建，只说 OAuth2.0 客户端的搭建。</p><p>如果使用的是第三方授权服务器、资源服务器，一般第三方平台会给你接口说明（客户端怎么访问授权服务器和资源服务器），并要求你出示自己的身份，注册一对 <code>client_id</code>、<code>client_key</code>；</p><p>为什么需要你注册一个 <code>client_id/client_key</code> 呢？这是为了保护 App 使用者（最终用户）的合法权益，确保客户端是可信的，不是什么伪造的中间人都可以访问授权服务器、读取用户信息的。</p><p>有了这对 <code>client_id</code>、<code>client_key</code>，就可以认证应用开发者和客户端的身份，在与第三方授权服务器通信时携带，就可以确保客户端是合法的。</p><h3 id="2-2-2-OAuth2-0-Client-in-Spring-Security"><a href="#2-2-2-OAuth2-0-Client-in-Spring-Security" class="headerlink" title="2.2.2 OAuth2.0 Client in Spring Security"></a>2.2.2 OAuth2.0 Client in Spring Security</h3><blockquote><p>那么 Spring Security 是怎么支持 OAuth2.0 的呢？我们不妨先了解一下 Spring Security 的历史：</p><p>大约十年前，Spring 引入了一个社区驱动的开源项目 Spring Security OAuth， 并将其纳入 Spring 项目组合中。到今天为止，这个项目己经发展成为一个成熟的项目，可以支持大部分 OAuth 规范，包括资源服务器、 客户端和授权服务器等。</p><p>然而早期的项目存在一些问题，例如：</p><ul><li>OAuth 是在早期完成的，开发者无法预料未来的变化以及这些代码到底要被怎么使用， 这导致很多 Spring 项目提供了自己的 OAuth 支持，也就带来了 OAuth 支持的碎片化。</li><li>最早的OAuth项目同时支特 OAuth1.0 和 OAuth2.0，而现在 OAuth1.0 早已经不再使用， 可以放弃了。</li><li>现在我们有更多的库可以选择，可以在这些库的基础上去开发，以便更好地支持JWT等新技术。</li></ul><p>基于以上这些原因，官方决定重写 Spring Security OAuth，以便更好地协调 Spring 和 OAuth，并简化代码库，使 Spring 的 OAuth 支持更加灵活。然而，在重写的过程中，发生了不少波折。</p><p>2018年1月30日，Spring 官方发了一个通知，表示要逐渐停止现有的 OAuth2支持，然后在 Spring Security  5中构建下一代 OAuth2.0 支持。这么做的原因是因为当时 OAuth2 的落地方案比较混乱，在 Spring Security  OAuth、 Spring Cloud Security、Spring Boot 1.5.x 以及当时最新的Spring Security  5.x 中都提供了对 OAuth2 的实现。以至于当开发者需要使用 OAuth2 时，不得不问，到底选哪一个依赖合适呢？</p><p>所以 Spring 官方决定有必要将 OAuth2.0 的支持统一到一个项目中，以便为用户提供明确的选择，并避免任何潜在的混乱，同时 OAuth2.0 的开发文档也要重新编写，以方便开发人员学习。所有的决定将在 Spring Security 5 中开始，构建下一代 OAuth2.0 的支持。从那个时候起，Spring Security OAuth  项目就正式处于维护模式。官方将提供至少一年的错识/安全修复程序，并且会考虑添加次要功能，但不会添加主要功能。同时将 Spring Security OAuth 中的所有功能重构到 Spring Security 5.x 中。</p><p>到了2019年11月14日，Spring 官方又发布一个通知，这次的通知首先表示 Spring Security OAuth 在迁往  Spring Security 5.x 的过程非常顺利，大部分迁程工作已经完成了，剩下的将在 5.3 版本中完成迁移，在迁移的过程中还添加了许多新功能。包括对 OpenID Connect1.0 的支持。同时还宣布将不再支持授权服务器，不支持的原因有两个：</p><ol><li>在2019年，已经有大量的商业和开源授权服务器可用；</li><li>授权服务器是使用一个库来构建产品，而 Spring Security 作为框架，并不适合做这件事情。</li></ol><p>一石激起千层浪，许多开发者表示对此难以接受。这件事也在Spring 社区引发了激烈的讨论，好在 Spring 官方愿意倾听来自社区的声音。</p><p>到了2020年4月15日，Spring 官方宣布启动 Spring Authorization server 项目。这是一个由  Spring Security 团队领导的社区驱动的项目，致力于向 Spring 社区提供 Authorization  Server支持，也就是说，Spring 又重新支持授权服务器了。</p><p>于是在 2020年8月21日，Spring Authorization Server 0.0.1 正式发布。</p></blockquote><p>当前的 Spring Security 对于 OAuth2.0 的支持主要分为 2 个部分：</p><ul><li>OAuth2.0 Client（内置提供了强大的 OAuth2.0 登录功能）；</li><li>OAuth2.0 Resources Server；</li></ul><p>授权服务器的部分已经从 Spring Security 项目中独立出去了（Spring Authorization Server）。</p><p>这里就详细讨论 OAuth2.0 客户端的设计和使用。在 Gradle 中这么导入：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-oauth2-client&#x27;</span></span><br></pre></td></tr></table></figure><p>Spring Security OAuth2.0 Client 支持：</p><ul><li>认证：JWT Bearer 令牌的处理；</li><li>授权：授权码的保存、刷新令牌的操作、客户端认证信息的操作、用户认证信息的保存……</li></ul>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 学习笔记（二）</title>
      <link href="//technical/java-basic-2/"/>
      <url>//technical/java-basic-2/</url>
      
        <content type="html"><![CDATA[<p><i>Reference: Oracle Documentation</i></p><h1 id="Chapter-3-Java-Record-amp-Java-Bean"><a href="#Chapter-3-Java-Record-amp-Java-Bean" class="headerlink" title="Chapter 3. Java Record &amp; Java Bean"></a>Chapter 3. Java Record &amp; Java Bean</h1><h2 id="3-1-Java-Record"><a href="#3-1-Java-Record" class="headerlink" title="3.1 Java Record"></a>3.1 Java Record</h2><p>在 Java 14 以后，官方引入了新的 Java 关键字：<code>record</code>；</p><p>那么这个 <code>record</code> 关键字究竟有什么用处呢？它和我们熟知的 <code>class / interface / abstract class</code> 又有什么区别呢？其实在 Java 14 以前，有一种需求写起来非常的麻烦，正因为这种需求才产生出了 <code>record</code> 关键字。这个需求是什么呢？</p><p>举个例子，假如现在有个应用场景，想要定义一个数据类型，<strong>它只是用来存放一些数据</strong>（例如数据库查询的结果，或者是某个服务的返回信息）。</p><p>在很多实际情况下，我们希望使用这些数据就像 Java 内置基本类型一样，是不可变数据类型。这样做有几点好处：</p><ul><li><p>复制构造时，不是引用传递，因此是深拷贝。这样使用起来和基本类型一样方便，但是又不用担心改错源数据（非引用链接）；</p></li><li><p>确保数据在多线程情况下无需同步，线程安全！</p></li></ul><p>回忆下基础篇中的知识，要让 Java 类型（对象）behaves like 不可变数据类型，就必须确保：</p><ul><li>类型中的每个数据域都是 <u>私有的、常量的</u>（<code>private</code>，<code>final</code>）；</li><li>每个数据域都只能通过 <code>getter</code> 方法获取，不能有任何 <code>setter</code> 方法；</li><li>必须存在公有构造函数，并且构造函数内初始化各个数据域（常量只能这么做）；</li><li>Object 基类继承函数 <code>equals</code> 返回 <code>true</code> 当且仅当类中的每个数据域都相等；</li><li>Object 基类继承函数 <code>hashCode</code> 在类中的每个数据域都相等时，一定返回一样的值；</li><li>Object 基类继承函数 <code>toString</code> 最好包含 类名 和 每个数据域的名称和值； </li></ul><p>好了，假设我们现在想要保存一个 “联系人” 的信息，只包含一个名称、住址。我要定义这个类为不可变数据类型，那么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Persion</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, address);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">other</span> <span class="operator">=</span> (Person)obj;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(name, other.name) &amp;&amp; Objects.equals(address, other.address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, address=&quot;</span> + address + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* standard getters */</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    String <span class="title function_">getAddress</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.address; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……这很难评，仅仅为了将两个基本类型保存为不可变的数据类型，如此大费周章。具体来说，有几点坏处：</p><ul><li><p>许多代码都是和业务逻辑无关的 “模板代码”；</p></li><li><p>这种写法模糊了这个类原本的作用（语义模糊）：仅仅是按不可变数据类型保存两个基本类型而已！</p></li><li><p>很差的扩展性。</p><blockquote><p>现在还只有两个属性，那如果我要再加一个属性呢？</p><p>那么我要修改构造函数、修改<strong>所有的重载方法</strong>、为新的属性添加访问器。可谓麻烦。</p></blockquote></li></ul><hr><p>于是，在 Java 14 中，定义了新的关键字 <code>record</code>，它的含义就是告诉编译器，这是个保存数据的类型，要把它定义成不可变的样子！</p><p>经过上面的铺垫，你就能理解 <code>record</code> 关键字的意义，以及它的作用了。</p><h3 id="3-1-1-记录类型的构造函数"><a href="#3-1-1-记录类型的构造函数" class="headerlink" title="3.1.1 记录类型的构造函数"></a>3.1.1 记录类型的构造函数</h3><p>Java 规定，在使用 <code>record</code> 关键字定义类型时，<strong>默认构造函数存在参数，且与私有数据域一一对应</strong>。</p><p>允许特殊的定义方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, String address)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>你没有看错，上面一行等价于之前用 <code>class</code> 定义的一大堆代码……</p><p>除了简化了默认构造函数，你仍然在此基础上自定义构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 只需括号内声明数据记录类所有的私有数据成员即可 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">    <span class="comment">/* 简化的默认构造函数（被称为 compact constructor），不需要写形参列表、不需要手动对其初始化 */</span></span><br><span class="line">    <span class="keyword">public</span> Person &#123;</span><br><span class="line">        <span class="comment">/* 一般没啥事能做，你可以检查检查传入的参数是否为 null */</span></span><br><span class="line">        Objects.requireNotNull(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 可以重载构造函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">/* 允许委托构造 */</span></span><br><span class="line">        <span class="built_in">this</span>(name, <span class="string">&quot;UNKNOWN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-记录类型的访问器"><a href="#3-1-2-记录类型的访问器" class="headerlink" title="3.1.2 记录类型的访问器"></a>3.1.2 记录类型的访问器</h3><p>和一般的访问器命名法有些差别，记录类型默认的访问器不使用 <code>getXXX</code> 命名，而是使用 <strong>数据成员的名字</strong> 直接命名。</p><p>另外，一般真的不用改记录类型的访问器，如果需要改，那么说明这个类一定不是单纯的数据记录类，请用普通类型定义！</p><h3 id="3-1-3-记录类型的-Object-重写方法"><a href="#3-1-3-记录类型的-Object-重写方法" class="headerlink" title="3.1.3 记录类型的 Object 重写方法"></a>3.1.3 记录类型的 Object 重写方法</h3><p>根据定义，<code>equals</code>、<code>hashCode</code> 一般都不需要你再次重写。</p><p>在某些情况下，你可能想要自定义 <code>toString</code>，这没有问题，就和普通的类重写的方法一样。</p><h3 id="3-1-4-记录类型的静态变量和方法"><a href="#3-1-4-记录类型的静态变量和方法" class="headerlink" title="3.1.4 记录类型的静态变量和方法"></a>3.1.4 记录类型的静态变量和方法</h3><p>虽然不允许有公有可写的属性，但记录类型允许定义 <strong>静态变量、静态方法，它们都可以是公有的</strong>。</p><p>你可以把它们理解成对整个数据类型的配置，或者解释。</p><h2 id="3-2-Java-Bean"><a href="#3-2-Java-Bean" class="headerlink" title="3.2 Java Bean"></a>3.2 Java Bean</h2><p>嗯，实际上，还有一种约定和 Java Record 应用很像的 <strong>Java 类型定义规范</strong>，它的名字是 Java Bean（Java 豆？）。</p><p>没错，Java Bean 是 Java 的一种类型定义规范，和 record 类似，它们的共性是<u>用一个类来盛放一组数据</u>。</p><p>但是，record 追求的是不可变数据类型（数据域不可变性）、一条记录的不可变性和易操作性，而 bean 追求的是：</p><ol><li><p>数据的取出放入的接口不变，保证兼容性；</p></li><li><p>数据序列化（serializable）和<u>传输方便</u>（注：Java Bean 出现的原因就在于此，为了让一组相关数据传输方便）；</p><blockquote><p>不过 Record 也很简单，传输起来也方便，但是不可变，应该看业务需求选择。</p></blockquote></li></ol><p>所以，Java Bean 没有像 record 一样，它规定了一组类型定义方式：</p><ol><li>提供一个默认的无参构造函数；</li><li>需要被序列化并且实现了 Serializable 接口；</li><li>可能有一系列可读写属性，并且一般是 private 的；</li><li>有一系列的 getter 或 setter 方法；</li></ol><p>感性理解一下：想象一下存在这样一个箱子，其内部被分割成几个格子，每个格子用来存放特定的物品，工人取出或者放入物品后封箱，然后叫了个快递把箱子发出去了。这个箱子就是 Java Bean，取出、放入就是 getter、setter，物品就是属性，封箱发出就是序列化和传输。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String newName)</span> &#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> newAge)</span> &#123;</span><br><span class="line">        age = newAge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>Person</code> 类就是合格的 Java Bean（注：<code>Serializable</code> 接口已经在 Java 笔记1 中详细介绍）。</p><h2 id="3-3-Java-Record-与-Java-Bean-的对比"><a href="#3-3-Java-Record-与-Java-Bean-的对比" class="headerlink" title="3.3 Java Record 与 Java Bean 的对比"></a>3.3 Java Record 与 Java Bean 的对比</h2><div class="table-container"><table><thead><tr><th>Java Record</th><th>Java Bean</th></tr></thead><tbody><tr><td>追求不可变数据类型、数据结果表示</td><td>追求数据传输便捷性、数据访问接口规范性</td></tr><tr><td>Java 14+ 使用关键字 record 辅助定义</td><td>纯手工实现约定</td></tr><tr><td>final class，不可被继承，也没有被继承需求</td><td>普通 class，可以被继承</td></tr><tr><td>常用于存放、比较 和 展示数据结果</td><td>常用于完成如数据传输一类的业务逻辑</td></tr></tbody></table></div><h1 id="Chapter-4-反射"><a href="#Chapter-4-反射" class="headerlink" title="Chapter 4. 反射"></a>Chapter 4. 反射</h1><p>Java 中的反射机制是什么？</p><p><img src="imgs/CompileAndExplain.png"></p><p>复习一下 Java 的运行过程。我们知道，Java 虚拟机是一种解释器，是解释 Java 字节码（*.class）的一种程序。其大致运行过程如下：</p><p>运行<strong>类加载器</strong>（ClassLoader）将字节码加载到内存中 —-&gt; 运行<strong>字节码验证器</strong>强制检查 Java 程序合法性和安全性，不符合安全规范的不予运行 —-&gt; 读取内存中的字节码逐句解释为机器码执行；</p><p>可以说，在 Java 源文件编译为字节码之后，就形成了一个个 <code>*.class</code> 文件。这里的每个 <code>*.class</code> 文件都对应着这个类型的必要信息。在 Java 虚拟机中将这些字节码加载到内存中，构建了这个类对应的特殊的表示对象（称为 <code>Class</code> 对象）。这样在引用到这个类的位置就能正确地给出行为。</p><blockquote><p>注意，在 Java 中，<code>Class</code>（首字母大写，和关键字 <code>class</code> 是两回事）本身就是一个类型，是承载类的信息的类（元类，meta-class），它的实例对象就叫 <code>Class</code> 对象。</p></blockquote><p>而所谓的反射，可以说是上面的过程的运行时逆过程：</p><p><u><strong>Java 的反射就是从加载到内存中的 <code>Class</code> 对象，反向获取其中的信息</strong></u>（或者说，反向映射）。</p><h2 id="4-1-反射的意义使用场景"><a href="#4-1-反射的意义使用场景" class="headerlink" title="4.1 反射的意义使用场景"></a>4.1 反射的意义使用场景</h2><p>不过在介绍反射之前，首先谈谈它的坏处：</p><ul><li>破坏了类的封装性（因为反射是从 <code>Class</code> 对象反向获取信息，因此突破了类型可见性修饰符的约束，可以访问某个类的私有成员）；</li><li><p>运行时确定类型，性能肯定不好，丢掉了静态类型语言的性能优势；</p></li><li><p>运行安全问题。</p></li></ul><p>如此重要的缺点，已经注定了 Java 的反射机制不应该被随便使用，并且大部分场合下并不适合使用反射。</p><p>但是因为反射的重要功能，少数场合又不得不用。举几个例子：</p><ul><li>Java codelinter 静态类型代码检查。比如 IDEA 的 LSP Server 在探查某个对象的方法和属性的时候（你在 IDEA 里写个对象，后面加个点就能弹出一堆方法和属性提示），除了分析上下文定义的方法以外，一种重要的手段就是通过反射分析；</li><li>大型框架（例如 Springboot）很多都是配置化的（例如通过 XML 文件配置 Bean），为了保证框架的通用性，可能需要根据配置文件加载不同的类或者对象、调用不同的方法。这个时候就必须使用到反射了，它可以完成 “运行时动态加载需要的加载的对象” 的任务；</li><li>Java 加载某些数据库驱动的时候，需要运行时动态构建类型信息，使用时就要用反射机制；</li><li>某些注解的行为需要反射（下一章 “注解” 所需要了解的知识）。</li></ul><h2 id="4-2-反射-API"><a href="#4-2-反射-API" class="headerlink" title="4.2 反射 API"></a>4.2 反射 API</h2><p>了解它的地位后，在开始使用它。使用 Java 的反射就是使用 <code>java.lang.Class</code> 和 <code>java.lang.reflect.*</code> 的所有 API。</p><p>首先列出可能用到的类型：</p><div class="table-container"><table><thead><tr><th>Java 类型</th><th>类型说明</th></tr></thead><tbody><tr><td><code>Class</code></td><td>用来在内存中描述一个 Java 类（所有继承于 Object 的类）</td></tr><tr><td><code>Constructor</code></td><td>用来在内存中描述一个 Java 类的构造函数信息，包括访问权限和动态调用信息等</td></tr><tr><td><code>Field</code></td><td>用来在内存中描述一个 Java 类或者 Java 接口的数据成员（或者说属性）信息，包括访问权限和动态修改等</td></tr><tr><td><code>Method</code></td><td>用来在内存中描述一个 Java 类或者 Java 接口的成员函数（或者说方法）信息，包括包括访问权限和动态调用信息等</td></tr><tr><td><code>Modifier</code></td><td>用来在内存中描述一个 Java 类或者 Java 接口的所有成员（包括属性、方法）的修饰属性，例如 <code>public/private/static/final/synchronized/abstract</code> 等信息</td></tr></tbody></table></div><h3 id="4-2-1-Class-类型与-Class-实例"><a href="#4-2-1-Class-类型与-Class-实例" class="headerlink" title="4.2.1 Class 类型与 Class 实例"></a>4.2.1 <code>Class</code> 类型与 <code>Class</code> 实例</h3><p>我们知道了，反射需要根据内存中的 <code>Class</code> 对象进行操作，那么怎么得到一个普通类型所对应的 <code>Class</code> 对象呢？Java 提供了 3 种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;Object&gt; 表示任意类型，只要是 Object 的子类 */</span></span><br><span class="line"><span class="comment">/* &lt;Object Instance&gt; 表示任意类型对应的实例对象 */</span></span><br><span class="line">[Method]             &lt;Object Instance&gt;.getClass() -&gt; Class Instance;</span><br><span class="line">[Static Property]     &lt;Object&gt;.class -&gt; Class Instance;</span><br><span class="line">[Static Method]        Class.forName(String className) -&gt; Class Instance;</span><br></pre></td></tr></table></figure><p>下面以获取 <code>String</code> 类对应的 <code>Class</code> 对象为例。</p><ul><li><p>通过该类（一定继承于基类 <code>Object</code>）的实例 中的 <code>getter</code> 方法：<code>&lt;Object&gt;.getClass()</code>；</p><p>这个方法返回是这个对象所在的类型 的对应 <code>Class</code> 实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取的 stringClass 实例对象就是 String 类型在 JVM 内存中对应的 Class 对象 */</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> name.getClass();</span><br></pre></td></tr></table></figure></li><li><p>通过该类的<strong>静态属性</strong>获得这个类所对应的 <code>Class</code> 实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure></li><li><p>利用 <code>Class</code> 类型提供的静态方法，通过类名字符串查找当前内存中的 Class 对象；</p><blockquote><p>这种方法最常用，因为使用反射的时候，几乎都是不知道对象、不知道类型定义、只知道类型名的情况。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;String&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>知道类如何获取某个类型的 <code>Class</code> 对象，那么可以对这个 <code>Class</code> 对象进行哪些操作呢？</p><ul><li><p>判断任意对象是否是这个 <code>Class</code>  对象描述的类的实例，或者其他什么东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* obj 是否是这个 Class 对象描述的类型的实例 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Object obj)</span>;    <span class="comment">/* [Method] */</span></span><br><span class="line"><span class="comment">/* 这个 Class 对象描述的类型是否是 Interface 类型 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterface</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isArray</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isPrimitive</span><span class="params">()</span>;    <span class="comment">/* 判断基本类型 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isAnnotation</span><span class="params">()</span>;    <span class="comment">/* 判断注解 */</span></span><br></pre></td></tr></table></figure></li></ul><p>下面以这个 <code>Class</code> 类型存放的是普通 Java 类为例，叙述常见的方法。</p><blockquote><p>如果 <code>Class</code> 对象中描述的是注解，那么在下一章 “注解” 进行介绍。</p><p>如果 <code>Class</code> 对象中描述的是接口，那么只能获取一些成员信息，可能能调用一些静态方法或属性。</p></blockquote><ul><li><p>从 <code>Class</code> 对象创建实例（哪怕源码中没有这个类的定义也行，只要内存中有这个 <code>Class</code> 对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 按默认构造函数创建实例 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">newInstance</span><span class="params">()</span>;        <span class="comment">/* [Method] */</span></span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Class</code> 对象对应类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取 Class 对象描述的类型的：所有&quot;公有的&quot;构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> Constructor[] getConstructors();</span><br><span class="line"><span class="comment">/* 获取所有的构造方法(包括私有、受保护、默认、公有) */</span></span><br><span class="line"><span class="keyword">public</span> Constructor[] getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取指定的构造函数 */</span></span><br><span class="line"><span class="comment">/* 这里的参数列表是各个参数类型对应的 Class 对象！ */</span></span><br><span class="line"><span class="keyword">public</span> Constructor <span class="title function_">getConstructor</span><span class="params">(Class... parameterTypes)</span>;</span><br><span class="line"><span class="keyword">public</span> Constructor <span class="title function_">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Class</code> 对象对应类的数据成员（属性，静态修饰不作单独区分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取 Class 对象描述的类型的：所有&quot;公有的&quot;属性 */</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields();</span><br><span class="line"><span class="comment">/* 获取所有的属性(包括私有、受保护、默认、公有) */</span></span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取指定名称的属性 */</span></span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getField</span><span class="params">(String fieldName)</span>;</span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getDeclaredField</span><span class="params">(String fieldName)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Class</code> 对象对应类的成员函数（方法，静态修饰不作单独区分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取 Class 对象描述的类型的：所有&quot;公有的&quot;方法 */</span></span><br><span class="line"><span class="keyword">public</span> Method[] getMethods();</span><br><span class="line"><span class="comment">/* 获取所有的属性(包括私有、受保护、默认、公有) */</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取指定名称的属性 */</span></span><br><span class="line"><span class="comment">/* 和构造函数不一样，这里需要先给定方法名 */</span></span><br><span class="line"><span class="keyword">public</span> Method <span class="title function_">getMethod</span><span class="params">(String methodName, Class... parameterTypes)</span>;</span><br><span class="line"><span class="keyword">public</span> Method <span class="title function_">getDeclaredMethod</span><span class="params">(String methodName, Class... parameterTypes)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Class</code> 对象对应类的修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取类型自身的修饰符 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-2-Constructor-类型"><a href="#4-2-2-Constructor-类型" class="headerlink" title="4.2.2 Constructor 类型"></a>4.2.2 <code>Constructor</code> 类型</h3><p>在介绍 <code>Class</code> 类型时，我们了解了如何得到 <code>Constructor</code>（该类的构造函数信息）对象，那么应该如何操作它？</p><p>最常用的方法是 <strong>调用这个构造函数</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* T 为泛型 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> T <span class="title function_">newInstance</span><span class="params">(Object... parameterTypes)</span>;</span><br></pre></td></tr></table></figure><p>警告：这里的参数类型必须要和取得 <code>Constructor</code> 对象时传入的形参类型一致。否则运行时错误。</p><p>还可以获取 <code>Constructor</code> 的其他信息，具体请看官方文档。</p><h3 id="4-2-3-Field-类型"><a href="#4-2-3-Field-类型" class="headerlink" title="4.2.3 Field 类型"></a>4.2.3 <code>Field</code> 类型</h3><p>在介绍 <code>Class</code> 类型时，我们了解了如何得到 <code>Field</code>（该类的属性）对象，那么应该如何操作它？</p><p>常用的方法是，按查找到的属性信息设置对象属性、读取对象属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object target, Object value)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(Object target)</span>;</span><br></pre></td></tr></table></figure><p>这里为什么要给 <code>target</code> 参数呢？因为我们得到的 <code>Field</code> 对象只是保存了原来类型属性的一部分信息，不能指明这个属性是属于具体哪个对象的。所以取值和设置时需要给定对象。</p><p>警告：这里的 <code>value</code> 必须和取得 <code>Field</code> 对象时原本类型一致，否则运行时错误。</p><p>对于私有成员，想要访问它前需要强制越过可见性修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(<span class="type">boolean</span> available)</span>;</span><br></pre></td></tr></table></figure><p>可能产生的异常有 <code>FieldNotFoundException</code>，<code>IllegalAccessException</code> 等等；</p><p>还可以获取 <code>Field</code> 的其他信息，具体请看官方文档。</p><h3 id="4-2-4-Method-类型"><a href="#4-2-4-Method-类型" class="headerlink" title="4.2.4 Method 类型"></a>4.2.4 <code>Method</code> 类型</h3><p>在介绍 <code>Class</code> 类型时，我们也了解了如何得到 <code>Method</code>（该类的方法）对象，那么应该如何操作它？</p><p>常用的方法是，调用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> ObjectObject <span class="title function_">invoke</span><span class="params">(Object target, Object... parameters)</span>;</span><br></pre></td></tr></table></figure><p>如果是私有方法，也需要通过 <code>setAccessible</code> 调整访问可见性。</p><p>还可以获取 <code>Method</code> 的其他信息，具体请看官方文档。</p><h3 id="4-2-5-Modifier-类型"><a href="#4-2-5-Modifier-类型" class="headerlink" title="4.2.5 Modifier 类型"></a>4.2.5 <code>Modifier</code> 类型</h3><p>其实，除了 <code>Class</code> 类型，其他的 <code>Constructor/Field/Method</code> 类型都可以调用 <code>getModifiers()</code> 获取当前字段的修饰符。返回值是 <code>int</code>，但是可以通过 <code>Modifier</code> 静态方法转为可读的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>可以表示的修饰符不仅有可见性修饰符，还有各种像 <code>native / synchronized / transient / volatile / abstract / final / interface</code> 等等，都可以检查到，使用对应的 <code>isXXX()</code> 实例方法即可。</p><h3 id="4-2-6-反射的使用实例"><a href="#4-2-6-反射的使用实例" class="headerlink" title="4.2.6 反射的使用实例"></a>4.2.6 反射的使用实例</h3><ul><li>反射越过泛型检查；</li><li>大型框架（以 SpringMVC 为例）字段名一类的数据类型配置反射处理相当简洁清晰；</li><li>自定义注解（写 <code>RUNTIME</code> 注解逻辑，下一章详细叙述）；</li></ul><h1 id="Chapter-5-注解"><a href="#Chapter-5-注解" class="headerlink" title="Chapter 5. 注解"></a>Chapter 5. 注解</h1><p>Java 中一种语法称为注解，可能在大部分其他的语言中都有。在 Python / TypeScript 中，这种类似的做法称为 “装饰器”。</p><blockquote><p>严格来说，Java 的注解和 Python / TypeScript 的装饰器的机制不一样。因为前者只是改变了执行方式，而后者相当于是一种语法糖，处理后替换了被装饰的对象。但是它们的语法和最终作用真的很像。</p></blockquote><p>这种做法的特征是，在<u>不改变原代码内容和逻辑</u>的基础上，进行一些修饰和包装（就像给解释器注解这段代码的执行方式一样），使得解释执行（或者编译）这段代码时的方式有些许改变。</p><p>你没看错，“注解“ 这个东西本身，不会对原先的代码的逻辑有任何影响（<u>这段代码编译出的字节码不会变</u>），只是<u>做个标记，告诉即将要读取这个注解的对象（可能是编译器、加载器，或者是程序中的其他代码），用约定好的方式来执行这段代码</u>（比如执行之前、执行之后插入了一些其他流程）。</p><h2 id="5-1-注解的使用和分类"><a href="#5-1-注解的使用和分类" class="headerlink" title="5.1 注解的使用和分类"></a>5.1 注解的使用和分类</h2><p>你也许会在一些代码中见到这样的书写方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(<span class="meta">@Param</span> String name)</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Resource(&quot;Hello&quot;)</code> 是有参数的注解，<code>@PostConstruct / @Override</code> 是无参数的注解；</p><p><code>@Resource(&quot;Hello&quot;)</code> 在这个例子中是修饰类的注解，<code>@PostConstruct / @Override</code> 在这个例子中是修饰方法的注解，<code>@Param</code> 在这个例子中是修饰形参的注解。</p><p>注解的使用语法就这些，无非是无参数的 <code>@&lt;AnnotationName&gt;</code>，或者有参数的 <code>@&lt;AnnotationName&gt;(...)</code>，加在它们所指定的对象头部位置。</p><p>要掌握好注解的使用方法，就先把它们按使用特征分类。一般来说，注解是按处理阶段进行分类：</p><ul><li><p>写给编译器看的注解（称为 <strong>编译时注解，Compile-time Annotation</strong>）。</p><p><u>这类注解不会被编译进入 <code>.class</code> 字节码文件，它们在编译后就被编译器扔掉了</u>；举例：</p><ul><li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写（C++ <code>override</code> 关键字有同样的功能）；</li><li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li></ul></li><li><p>写给 <code>classLoader</code> 或者其他加载时 ~ 运行时的工具看的注解（称为 <strong>加载时注解，Load-time Annotation</strong>）。</p><p><u>这类注解会被编译进入 <code>.class</code> 文件，但加载结束后并不会存在于内存中</u>。这类注解只被一些底层库使用，一般我们不必自己处理。</p><p>比如有些工具会在加载 class 的时候，对 class 做动态修改，实现一些特殊的功能。</p></li><li><p>写给运行时某一部分代码看的注解（称为 <strong>运行时注解，Run-time Annotation</strong>）。</p><p>就算是运行时注解，JVM 也并不会通过注解主动进行一些操作。<u>只有部分代码通过 <strong>反射</strong> 读取指定的注解，进行业务逻辑的执行</u>。</p><p><u>这也是最常用的注解形式，在许多框架中都会出现</u>。</p></li></ul><h2 id="5-2-自定义注解"><a href="#5-2-自定义注解" class="headerlink" title="5.2 自定义注解"></a>5.2 自定义注解</h2><p>有些情况下（比如使用框架），你可能会用很多预先定义的注解，但是你很好奇这些注解是怎么运作的，于是你就要了解，一个注解是如何定义、如何生效（进行处理）的。</p><p>搞清楚一个东西的最好方法就是从头开始做一遍，于是你准备动手搓一个自定义的注解出来。</p><h3 id="5-2-1-注解的定义-和-实质"><a href="#5-2-1-注解的定义-和-实质" class="headerlink" title="5.2.1 注解的定义 和 实质"></a>5.2.1 注解的定义 和 实质</h3><p>Java 规定，注解使用 <code>@interface</code> 关键字定义注解。最基本的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFirstAnnotation &#123;</span><br><span class="line">    <span class="comment">/* 强烈建议为注解的每个数据域都设置一个默认值 */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">intData</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">stringData1</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">stringData2</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">/* 建议最常用的数据域名称设置为 value */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的定义和 Java 的记录类型一样简洁，<u>只需要声明要传给注解的参数即可（这些参数直接以访问器的形式定义，如上），不需要定义任何处理逻辑！</u></p><p>因为注解的处理交由某些特定的代码完成（下一节介绍），注解的定义本身 <strong>就仅仅是一个 “注解”，或者说等待处理的标识而已</strong>。</p><p>此外，还需要搞清楚一件事：注解的实质就是一个 Java 类型。所有的注解都继承于接口 <code>java.lang.annotation.Annotation</code>；因此，上面的定义方法只不过也是一种语法糖罢了。</p><p>但是，只有这个定义还不够描述这个注解，比如，<strong><u>这个注解是前面分类中的什么类型？应该在什么阶段、被谁处理（生命周期）？允许修饰谁？</u></strong></p><p>这些信息 <strong>可以交给描述注解的注解，也就是元注解（meta-annotation），来完成</strong>。</p><p>Java 标准库中定义了一大批实用的元注解，所以一般不需要我们自己定义元注解，只要知道怎么使用元注解来定义注解就可以了。常用的元注解如下：</p><ul><li><p><code>@Target(&lt;ElementType/ElementTypes[]&gt;)</code> 元注解：<strong>解释当前注解所能修饰的对象类型</strong>。</p><blockquote><p>参数取值：<code>ElementType.TYPE</code>（允许修饰类、接口），<code>ElementType.FIELD</code>（允许修饰属性），<code>ElementType.METHOD</code>（允许修饰方法），<code>ElementType.CONSTRUCTOR</code>（允许修饰构造函数），<code>ElementType.PARAMETER</code>（允许修饰方法的形式参数）；</p></blockquote></li><li><p><code>@Retention([RetentionPolicy])</code> 元注解：<strong>解释当前注解的声明周期（指定注解类型）</strong>。</p><blockquote><p>可选参数取值：<code>RetentionPolicy.SOURCE</code> 编译时注解、<code>RetentionPolicy.CLASS</code> 加载时注解（默认）、<code>RetentionPolicy.RUNTIME</code> 运行时注解；</p></blockquote></li><li><p><code>@Repeatable(&lt;Annotation Class Instance&gt;)</code> 元注解：<strong>解释当前注解是否可以重复注解同一对象</strong>。</p><blockquote><p>要用的话，直接在注解的定义头部加上 <code>@Repeatable(&lt;AnnotationName&gt;.class)</code>；</p><p>这里需要反射方法传入自定义注解类对应的 <code>Class</code> 对象。</p></blockquote></li><li><p><code>@Inherited</code> 元注解：<strong>解释当前注解是否可继承</strong>。当且仅当 <code>@Target</code> 参数为 <code>ElementType.TYPE</code> 时有效。</p><blockquote><p>这个元注解的意思是，当前注解能不能随着继承交给子类。</p></blockquote></li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个注解只能修饰方法 */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFirstAnnotation &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">intData</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">stringData1</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">stringData2</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个注解既能修饰方法，又能修饰属性 */</span></span><br><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFirstAnnotation2 &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">intData</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">stringData1</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">stringData2</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以注解方法和构造函数的 运行时注解 */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.CONSTRUCTOR</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFirstAnnotation1 &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">intData</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">stringData1</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">stringData2</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-运行时注解的处理"><a href="#5-2-2-运行时注解的处理" class="headerlink" title="5.2.2 运行时注解的处理"></a>5.2.2 运行时注解的处理</h3><p>由于其他两类注解一般用不到（编译时注解由编译器使用，因此我们一般只使用，不编写；加载时注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到），因此此处仅叙述运行时注解的处理。</p><p>从现在开始，下文中的所有 “注解” 都指代 “运行时注解”。</p><p>我们知道，注解本身只是个注解，<u>如果你不做任何处理，那么它将对原本的代码毫无影响，就像注释一样。</u></p><p>我们还知道，注解只是一个 Java 类而已，但是这个类只存放一些参数，不与外界代码有任何关联。</p><p>所以处理注解的方法一目了然：<u>使用上一章介绍的反射机制</u>，不仅能找到所有规定类型的注解，还能让注解发挥指定的效果。</p><p>上一章中，我们只介绍了关于类型、接口的反射 API，这里我们补充一下针对注解的反射 API：</p><ul><li><p>判断 <code>Class</code> 对象本身是否描述的是注解：<code>public boolean isAnnotation();</code>；</p></li><li><p>判断注解是否存在于指定对象上：<code>isAnnotationPresent(&lt;Class Object of Annotation&gt;)</code>；</p><blockquote><p>这个方法在 <code>Class / Field / Method / Constructor</code> 类型中都有。</p></blockquote></li><li><p>从指定对象上获取注解对象：<code>getAnnotation(&lt;Class Object of Annotation&gt;)</code>；</p><blockquote><p>这个方法在 <code>Class / Field / Method / Constructor</code> 类型中都有。</p><p>注意：<u>可能会返回 <code>null</code>，所以使用前请用 <code>isAnnotationPresent</code> 检查！</u></p></blockquote></li><li><p>从方法 / 构造函数中获得参数注解对象：<code>getParameterAnnotations() -&gt; Annotation[][]</code>；</p><blockquote><p>只有在 <code>Method / Constructor</code> 中存在。</p></blockquote></li></ul><p>再回想一下，注解是个类型，里面装的全是传入参数，并且直接提供各个传入参数的访问器方法。</p><p>有了以上的知识，就能写一个自定义的注解了。</p><h3 id="5-2-3-实战：自定义一个运行时注解"><a href="#5-2-3-实战：自定义一个运行时注解" class="headerlink" title="5.2.3 实战：自定义一个运行时注解"></a>5.2.3 实战：自定义一个运行时注解</h3><p>考虑一个需求，我想定义一个修饰属性的运行时注解，如果这个参数是整数，就限制这个参数的范围为注解参数给定的范围；如果这个参数是字符串，那么限制的是字符串长度。其中最大、最小值可选。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File: Range.java */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span>: <span class="keyword">default</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span>: <span class="keyword">default</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* File: RangeChecker.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RangeChecker</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(T obj)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        Class&lt;?&gt; objCls = obj.getClass();</span><br><span class="line">        <span class="keyword">for</span> (Field f: objCls.getFields()) &#123;</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (f.isAnnotationPresent(Range.class)) &#123;</span><br><span class="line">                <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> f.getAnnotation(Range.class);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">originVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    originVal = f.get(obj);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException err) &#123;</span><br><span class="line">                    <span class="comment">/* Controls never reaches here. */</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (originVal <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + f.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (originVal <span class="keyword">instanceof</span> Integer i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; range.min() || i &gt; range.max()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + f.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考一下，<code>RangeChecker</code> 应该什么时候被使用？没错，这取决于你的业务逻辑。注解是 “惰性的”，只有你显式调用注解处理方法，注解的处理才会开始。</p><h1 id="Chapter-6-Functional-Interface"><a href="#Chapter-6-Functional-Interface" class="headerlink" title="Chapter 6. Functional Interface"></a>Chapter 6. Functional Interface</h1><h2 id="6-1-Definitions-and-Examples"><a href="#6-1-Definitions-and-Examples" class="headerlink" title="6.1 Definitions and Examples"></a>6.1 Definitions and Examples</h2><p>Java 中的一个重要特性：函数式接口。实际上，它的规范定义是：</p><p><strong><u>任何一个只存在单一抽象方法（SAM）的接口，都称之为函数接口</u></strong>。</p><p>函数接口提供了和 TypeScript 类似的能力，它让我们可以不那么看重函数签名，仅仅从函数类型（参数、返回值类型）将函数归类。接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>这还可以让我们轻易地将一个函数作为一个参数 / 返回值，实现函数式编程。</p><p>例如，我们可以显式声明使用函数接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, String&gt; intToString = Object::toString;</span><br><span class="line">Function&lt;String, String&gt; quote = s -&gt; <span class="string">&quot;&#x27;&quot;</span> + s + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* compose 是函数接口的接口方法，可以将函数接口组合执行 */</span></span><br><span class="line">Function&lt;Integer, String&gt; quoteIntToString = quote.compose(intToString);</span><br><span class="line"><span class="comment">/* apply 是函数接口的接口方法，执行这个函数接口的实现 */</span></span><br><span class="line">assertEquals(<span class="string">&quot;&#x27;5&#x27;&quot;</span>, quoteIntToString.apply(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 再例如这段业务代码 */</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;EventDto&gt; <span class="title function_">findEventByUuid</span><span class="params">(Long uuid)</span> &#123;</span><br><span class="line">    Optional&lt;Event&gt; event = eventRepository.findByUuidAndNotDeleted(uuid);</span><br><span class="line">    <span class="comment">/* Optional.map 的参数就是一个函数接口，可以更方便、清晰地处理内容的映射关系 */</span></span><br><span class="line">    <span class="keyword">return</span> event.map(Event::mapToEventDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用 <code>new</code> 立即定义、实例化一个函数接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java 中创建一个线程，其中参数类型 Runnable 就是一个函数接口 */</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New thread created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这种原地重载实例化接口的方法，我们可以称为匿名的接口实现。</span></span><br><span class="line"><span class="comment"> * 缺点是接口实现不能复用，优点是代码简洁。</span></span><br><span class="line"><span class="comment"> * 这对于其他任何 interface 都是可行的（不是函数接口也行） */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* P.S. 如果你写了上面的函数接口的匿名实现，在 IDEA 中会提醒你换成匿名函数更简洁 */</span></span><br><span class="line"><span class="comment">/* 这样 Java 就越来越像 TypeScript 了（bushi */</span></span><br></pre></td></tr></table></figure><p>此外，我们所熟知的 Java Lambda 函数（匿名函数）就是一种函数接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; <span class="keyword">new</span> <span class="title class_">HelloClass</span>()</span><br></pre></td></tr></table></figure><p>除了匿名函数，一个类中的静态方法、在同一个类中使用的实例方法都能通过 <code>::</code> 作用域符来<strong><u>转换</u></strong>为函数接口，例如：</p><p>在任意一个类方法中使用 <code>Object::toString</code>（实例方法省略传递 <code>self</code>）、使用静态方法 <code>MyClass::aStaticMethod</code> 等等。</p><h2 id="6-2-Primitive-Function-Specializations"><a href="#6-2-Primitive-Function-Specializations" class="headerlink" title="6.2 Primitive Function Specializations"></a>6.2 Primitive Function Specializations</h2><p>对于 Java primitive types（基本类型），我们没法将它们作为 generic type argument（泛型参数），所以这个时候就必须这么定义基本类型的函数接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ShortToByteFunction</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="title function_">applyAsByte</span><span class="params">(<span class="type">short</span> s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就能操作含有基本类型的函数，作为函数接口了！也可以把它作为参数、返回值，进行便捷的函数式操作。</p><blockquote><p>是不是越看越像 C++ 的函数指针？</p></blockquote><h2 id="6-3-Cosumers-amp-Suppliers"><a href="#6-3-Cosumers-amp-Suppliers" class="headerlink" title="6.3 Cosumers &amp; Suppliers"></a>6.3 Cosumers &amp; Suppliers</h2><p>Suppliers 在 Java 中定义为 <strong><u>不含参数、只有返回值的 函数接口</u></strong>。它常被用在：</p><ul><li><p>数据计算 / 大型对象创建等需要 Lazy Load 的场景，只是先拿到 supplier，真正需要结果的时候才进行计算，实现过程的解耦；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 举例：提供创建对象的方法 */</span></span><br><span class="line">() -&gt; <span class="keyword">new</span> <span class="title class_">ComplicatedClass</span>()</span><br></pre></td></tr></table></figure></li><li><p>大型序列的 Lazy Generate 的场景，类似 Python 的生成器/迭代器，只有获取下一个元素时才进行计算，极大节省资源，例如一个 Fibbonacci 生成器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] fibs = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; fibonacci = Stream.generate(() -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> fibs[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">fib3</span> <span class="operator">=</span> fibs[<span class="number">0</span>] + fibs[<span class="number">1</span>];</span><br><span class="line">    fibs[<span class="number">0</span>] = fibs[<span class="number">1</span>];</span><br><span class="line">    fibs[<span class="number">1</span>] = fib3;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>Consumers 则与 Suppliers 相反，定义为 <strong><u>没有返回值、只含参数的 函数接口</u></strong>。它的应用场景比 Suppliers 更少，通常它隐含着 “side effect” 的含义。</p><p>我们也可以在日志逻辑中见到它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.forEach(name -&gt; log.debug(<span class="string">&quot;Hello, &quot;</span> + name));</span><br></pre></td></tr></table></figure><h2 id="6-4-Predicates-amp-Operators"><a href="#6-4-Predicates-amp-Operators" class="headerlink" title="6.4 Predicates &amp; Operators"></a>6.4 Predicates &amp; Operators</h2><p>在数学上有对应概念的函数接口分别是谓词断言函数 和 操作符。</p><p>谓词断言函数（predicates），可以定义为 参数是一个或多个值、返回值为 boolean 类型的函数接口。在数学上对应的概念：谓词。</p><p>我们常常在 <code>filter</code>、<code>find</code> 这样的接口中见到，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; namesWithA = names.stream()</span><br><span class="line">  .filter(name -&gt; name.startsWith(<span class="string">&quot;A&quot;</span>)    <span class="comment">/* predicates */</span>)</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>操作符（operators），可以定义为 参数（一个或多个）和返回值类型相同的函数接口。</p><p>我们经常在使用 Collection API 时能见到，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; values = Arrays.asList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> values.stream()</span><br><span class="line">  .reduce(<span class="number">0</span>, (i1, i2) -&gt; i1 + i2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;UserDto&gt; <span class="title function_">findUserByUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">    List&lt;User&gt; res = userRepository.findUserByUsername(username);</span><br><span class="line">    <span class="keyword">return</span> res.stream()</span><br><span class="line">        .map(UserService::mapToUserDto)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Notes: ECF &amp; I/O</title>
      <link href="//review/csapp-ecf-io/"/>
      <url>//review/csapp-ecf-io/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-13-Exceptional-Control-Flow"><a href="#Chapter-13-Exceptional-Control-Flow" class="headerlink" title="Chapter 13. Exceptional Control Flow"></a>Chapter 13. Exceptional Control Flow</h1><blockquote><p>对应书中第 8 章。</p></blockquote><p>异常控制流是现代计算机系统的一个相当重要的部分。</p><h2 id="13-1-Control-Flow"><a href="#13-1-Control-Flow" class="headerlink" title="13.1 Control Flow"></a>13.1 Control Flow</h2><ul><li><p>控制流：从机器打开到关闭的过程中，处理器只做一件事：<strong>读指令、执行指令，一个周期做一个指令</strong>。多核的机器则每个核心依次交替执行指令。这些<strong>指令序列</strong>被称为控制流。硬件正在执行的<strong>实际指令序列</strong>就被称为<strong>物理控制流</strong>。</p></li><li><p>改变内存中控制流的方法：<strong>分支 &amp; 跳转</strong>，<strong>过程调用 &amp; 返回</strong>（Branches &amp; Jumps &amp; Procedure call and return）；</p><blockquote><p><strong>都是对于程序状态变化的处理</strong>。</p></blockquote></li></ul><p>但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）；</p><p>什么是 “系统级别的状态变化”？</p><ul><li>数据从磁盘 / 网卡到达内存中；</li><li>I/O 设备输入 Ctrl+C；</li><li>系统分时复用的时钟到期了，接下来要打断当前执行的进程；</li><li>除零指令；</li><li>……</li></ul><p>这些事件不能指望应用程序的开发者来解决（应用程序的开发者只负责开发正常的程序控制流），而这应该是 OS 需要处理的事情。为了高效处理以上在执行程序中出现的或意外、或故意的系统级状态变更的情况，OS 有一套策略：<strong>异常控制流（Exception control flow，简称 ECF）</strong>来处理上述情况，这样很多事件就无需应用开发者来考虑了。</p><h2 id="13-2-Exception-Control-Flow-Overview"><a href="#13-2-Exception-Control-Flow-Overview" class="headerlink" title="13.2 Exception Control Flow: Overview"></a>13.2 Exception Control Flow: Overview</h2><p>异常控制流的重要特征之一在于，它们会改变系统级别的状态，<strong>而且存在于计算机系统的各个层级</strong>：</p><p>首先是底层级 ECF 的机制：</p><ol><li><strong>Exception</strong>（异常，又称 <strong>Hardware ECF（硬件异常控制流）</strong>，和我们平时编程的软件异常处理不是一个概念）<ul><li>作用：<strong>响应某些底层系统事件（A System Event）的控制流的变化</strong>；</li><li>实现方法：硬件与操作系统的配合；</li></ul></li></ol><p>再看高级别（既指抽象层面，又指逻辑层面，这意味着下面的机制可能利用到，或者包含了上面的 Exception）的 ECF 的机制：</p><ol><li><strong>Process Context Switch</strong>（进程上下文切换）<ul><li>作用：使操作系统在两个进程间无缝切换；</li><li>实现方法：硬件时钟和操作系统的配合；</li></ul></li><li><strong>Signals</strong>（信号）<ul><li>作用：应用、操作系统、硬件三者之间的异常（不是错误，而是指在上层应用程序正常控制流以外的部分）通信；</li><li>实现方法：操作系统控制；</li></ul></li><li><strong>Nonlocal Jumps</strong>（非本地跳转）<ul><li>作用：<strong>应用程序开发者层面（而非操作系统层面）主动更改程序正常控制流（上面介绍的分支跳转、调用返回），无视正常控制流的规则</strong>（例如不需要等到一个函数返回，就跳到另一个函数执行）；</li><li>实现方法：因为是用户级别，所以由 C library 提供：<code>setjmp()</code>、<code>longjmp()</code>；</li></ul></li></ol><p>了解完计算机中各个层面的 <strong>4 大类 ECF 机制</strong>，我们开始深入探讨各个机制的运作原理。</p><h2 id="13-3-Exception-Control-Flow-Exception"><a href="#13-3-Exception-Control-Flow-Exception" class="headerlink" title="13.3 Exception Control Flow: Exception"></a>13.3 Exception Control Flow: Exception</h2><h3 id="13-3-1-Definitions"><a href="#13-3-1-Definitions" class="headerlink" title="13.3.1 Definitions"></a>13.3.1 Definitions</h3><p>一个异常就是<strong>为了应对一些（软件 / 硬件的）事件，控制流由程序转移到 OS kernel 的过程</strong>。</p><blockquote><ol><li>什么是操作系统内核（OS Kernel）？</li></ol><p>内核是<strong>操作系统在内存中驻留的部分</strong>，你可以理解成当前加载到内存的、运行中的操作系统代码；</p><ol><li>Exception 定义中的 “事件” 具体有哪些？</li></ol><ul><li>除零、算数溢出、page fault（页错误）、I/O 请求完成、键盘设备输入 Ctrl + C；</li><li>……</li></ul></blockquote><h3 id="13-3-2-Process-Procedure"><a href="#13-3-2-Process-Procedure" class="headerlink" title="13.3.2 Process Procedure"></a>13.3.2 Process Procedure</h3><p>Exception 的处理过程如下：</p><p><img src="imgs/exception_flow.png" height="200px"></p><ol><li><p>如图所示，因为以上的事件（event）而改变了系统状态，执行到 $I_{current}$ 的用户代码被立即暂停，此时 exception 将控制权从用户代码转移到内核态代码。这部分内核代码被称为 <strong>exception handler（异常处理程序）</strong>；</p></li><li><p>接着，内核执行异常处理程序代码来处理这个事件，过程被称为 <strong>exception processing（异常处理）</strong>；</p></li><li><p>处理结束后，通常有 3 种情况：返回到原先被打断的指令位置（$I_{current}$，已执行）、返回到被打断的指令的下一条（$I_{next}$，未执行）、终止原用户程序执行。</p></li></ol><h3 id="13-3-3-Implementations-of-Exception"><a href="#13-3-3-Implementations-of-Exception" class="headerlink" title="13.3.3 Implementations of Exception"></a>13.3.3 Implementations of Exception</h3><p>前面介绍过，Exception 是由 OS 和硬件共同实现的，那么具体实现是什么？</p><p>事实上，控制流想要改变，必须依靠硬件改变程序计数器（PC，或者说前面提到的 <code>%rip</code>）。由于 Exception handler 的代码又位于 Kernel code 中，所以实现就很清楚了：</p><ol><li><p><strong>OS 负责组织 Exception Handler 的代码，来处理可能的 Exception</strong>；</p></li><li><p><strong>硬件负责在 Event 出现的时候改变 <code>%rip</code>，使控制流转向 Exception Handler</strong>；</p></li></ol><p>等等，还有一个问题，OS 会预先编写很多类 Exception Handler 以应对不同 Exception 的情况，那么硬件在 Event 发生时，怎么知道转向哪一个 Exception Handler？所以还有一条、再改正一条：</p><ol><li><p><strong>硬件负责在 Event 出现时按种类改变 Exception Table Base Register，通过这个寄存器取得 Exception Table 中存放的 Exception Handler 的地址（硬件规定是虚拟地址），把取得的地址置于 <code>%rip</code> 中，完成转向</strong>；</p></li><li><p>OS 负责在 Kernel 中组织 <strong>Exception Table（异常表）</strong>，告诉硬件何种 event 对应何种 Exception Handler 的地址；</p></li></ol><blockquote><p>什么是 异常表？</p><p>OS 为了将每种 Event 产生的 Exception 与 Exception Handler 对应起来，将每种类型的事件进行编号。<strong>每种类型的事件对应位于的 异常编号（Exception Number，又称为中断向量，Interrupt Vector）</strong>，这个编号被作为一个跳表的索引，而表中装的是各个对应的 Exception Handler 的地址。这个表就称为 <strong>异常表</strong>。</p><p><img src="imgs/exception_table.png" height="300px"></p></blockquote><h3 id="13-3-4-Types-of-Exceptions"><a href="#13-3-4-Types-of-Exceptions" class="headerlink" title="13.3.4 Types of Exceptions"></a>13.3.4 Types of Exceptions</h3><p>上面我们提到过，在 Exception 的处理过程中，最后可能会发生 3 种情况（$I_{current}$、$I_{next}$、abort），这是因为具体发生的 event 不同，其 Exception Handler 的处理方式也不同。所以，我们有必要了解一下 Exception（或者说对应的 event）有哪些种类，exception handler 的默认行为又有哪些。</p><p><strong>Asynchronous Exceptions（异步异常）：又称 Interrupt（中断）</strong></p><ul><li>引发的 Event 的种类：<strong>来自处理器外的事件。通常是 I/O 设备发出的</strong>；</li><li>例子：<ul><li>I/O 设备中断事件（数据从磁盘、网卡等外部设备已到达内存的通知，键盘 Ctrl+C 等）；</li><li>系统分时复用时钟中断（Timer Interrupt），OS 在硬件时钟中定时，要求从用户程序切换到内核中，以便让 OS 取得控制权（这个是<strong>为进程上下文切换提供条件</strong>，让系统决定是否要进行进程上下文切换）；</li></ul></li><li>触发方法 / 系统状态如何改变：电脉冲通知处理器的 <strong>中断引脚</strong>；</li><li>触发后默认行为：<ul><li>可能与当前运行程序无关事件，从 $I_{next}$ 继续向下运行（<strong>recoverable</strong>）；</li></ul></li></ul><p><strong>Synchronous Exceptions（同步异常）</strong></p><ul><li>引发的 Event 的种类：<strong>因为处理器执行某条指令而造成的事件</strong>；</li></ul><p>而同步异常又可以分为几个种类：</p><ol><li><p>Traps（陷阱）</p><ul><li><p>触发方法：<strong>执行程序故意触发系统级别 Exception</strong>；</p></li><li><p>例子：<strong>system calls（系统调用）、breakpoint traps（程序断点）、特殊指令</strong>；</p><blockquote><p><strong>什么是系统调用？</strong></p><p>应用程序的某些功能可能需要使用一些硬件设备，例如 I/O 设备。而这些驱动硬件的程序则嵌在 OS Kernel 中。</p><p>但另一方面，由于安全问题，人们在系统中划分了若干特权级：Ring 0 ~ Ring 3，数字越大，权限越低。应用程序运行在 Ring 3 级别，因此不能直接调用内核函数、无法访问内核数据（位于 Ring 0 级别），因此无法直接使用 I/O 设备。</p><p>那么应用程序为了完成一项使用 I/O 设备的工作，只能调用 OS 准备的专门的接口（称为系统服务）来通知 OS 协助完成。这个过程被称为 <strong>系统调用</strong>。</p><p><strong>系统调用的详细过程？</strong></p><p>首先，系统调用就是调用系统接口的过程，咱首先得了解 x86-64 架构下系统调用有哪些接口。以 x86-64 Linux 为例：</p><p><img src="imgs/system_calls.png" height="250px"></p><p>每一个系统调用接口都有一个唯一的编号，这个编号由 OS 分配，例如 <code>read</code> 是 0 号；</p><p>以打开文件这个 I/O 操作为例，应用程序想要将磁盘中的数据读到内存中，那么：</p><ol><li><p>程序先调用 C library 封装好的函数 <code>open/fopen</code>；</p></li><li><p>C library 的 <code>open/fopen</code> 经过几层包装，接着调用系统接口 <code>__open</code>（上面的 2 号系统调用），其汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000000e5d70 &lt;__open&gt;:</span><br><span class="line">...</span><br><span class="line">e5d79: b8 02 00 00 00         mov $0x2,%eax # openis syscall #2</span><br><span class="line">e5d7e: 0f 05                 syscall # Return value in %rax</span><br><span class="line">e5d80: 48 3d 01 f0 ff ff     cmp $0xfffffffffffff001,%rax</span><br><span class="line">...</span><br><span class="line">e5dfa: c3 retq</span><br></pre></td></tr></table></figure><p>我们可以看到，系统调用的 calling conventions 与普通函数不一样：</p><ul><li><strong>第一传入参数必须是 系统调用编号，并且存放在 <code>%rax</code> 中</strong>，这里是 2，表示 2 号系统调用；</li><li><strong>其他传入参数依此放在：<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%r10</code>、<code>%r8</code>、<code>%r9</code></strong>；</li><li><strong>返回值也放在 <code>%rax</code> 中</strong>；</li><li><strong>使用 <code>errno</code> 宏来记录系统调用的状态或错误情况</strong>；</li><li><strong><code>%rcx</code> 、<code>%r11</code> 可能被破坏：<code>%rcx</code> 存放 $I_{next}$ 地址方便返回，<code>%r11</code> 用于存放 <code>rflags</code>，也即当前程序的 conditional codes</strong>；</li></ul></li><li><p>当处理器执行到系统调用汇编指令时，触发 <code>Trap</code>（Exception），相应值传入 Exception Table Base Register；硬件通过该寄存器找到 Exception table 中的相应 Exception handler（x86-64 通常是 software interrupt exception handler），将 <code>%rip</code> 地址改为该 handler 的地址，于是控制流转向 OS Kernel；</p></li><li><p>OS Kernel 处理系统调用的 exception handler 会按之前的 conventions 读取各参数值，执行对应系统调用服务。完成后，先切换特权级等信息，再读取 <code>%rcx</code> 和 <code>%r11</code> 中的信息，将控制流转交给 user mode 中原程序的 $I_{next}$；</p></li><li><p>最终系统调用成功返回的话，open 返回一个 <strong>file descriptor（文件描述符，一个区别已打开文件的小整数编号）</strong>，以供后续读写调用使用。</p></li></ol></blockquote></li><li><p>触发后默认行为：从 $I_{next}$ 继续向下执行（<strong>recoverable</strong>）；</p></li></ul></li><li><p>Faults（错误）</p><ul><li><p>触发方法：程序执行了一条指令，<strong>无意引发了硬件或软件层面的问题</strong>，从而产生 Exception；</p></li><li><p>例子：<strong>page fault（页错误，possibly recoverable）</strong>、<strong>protection fault（访问权限错误，unrecoverable）</strong>，<strong>floating point exceptions（浮点异常，例如除零错，unrecoverable）</strong>；</p><blockquote><p><strong>什么是页错误 和 访问权限错误？</strong></p><p>首先计算机中存在两个部分物理内存和虚拟内存。操作系统为了将离散、有限的资源抽象为连续、近乎无限的资源给应用程序使用，并将各个程序隔离开，使用了复杂的策略。</p><p>在<strong>内存的使用</strong>层面，操作系统和硬件配合引入了 “虚拟内存” 的概念，操作系统维护了一个从物理内存（简称 PM）到虚拟内存（简称 VM）的映射（还记得 Memory Hierarchy 最后介绍的 TLB cache 吗？就是为这个准备的），<strong>将主存（main memory）上离散的空间映射到连续的虚拟内存空间上</strong>。</p><p>这个 “映射” 存在处理器芯片的 MMU（Memory Managing Unit） 中，这个映射的数据结构被称为 <strong>页表</strong>。为了充分利用主存（物理内存）的空间，页表将 PM 和 VM 切分为很小的块（大家能懂往瓶子里装石子、沙子、水的道理吧？），这些很小的数据块被称为 <strong>页</strong>，而页表就是将这些虚拟内存页映射到物理内存页，如下：</p><p><img src="imgs/page_table.png" height="300px"></p><p>那么这样能同时完成两个目标：</p><ul><li>充分利用有限物理空间，为应用程序提供连续的虚拟空间；</li><li>每个应用程序间的虚拟内存很容易实现隔离（页表数据不同就行，这样哪怕相同的虚拟地址，映射到的物理地址也不同），相互不影响对物理内存的访问。</li></ul><p>每个应用程序所能看到的就是完整的虚拟内存，其中有独立的运行时栈。运行在 CPU 上的应用程序也直接使用虚拟地址，因为 VMA 出 CPU 前会经过 MMU 转换为物理地址，再向硬件请求。</p><p>但是！为了节约空间，操作系统不会一次性将全部的虚拟内存（地址 0 ~ FFFFFFFF）全部用页表映射上物理内存（一来大小不够，二来浪费资源），只是先为虚拟内存的必要部分（例如程序栈的 data 段、code 段、shared libraries 段、stack 段等）分配物理内存、记录在页表上。其余部分被称为<strong>未被分配的段</strong>。这个有 2 种可能：</p><ul><li>应用程序没有权限（执行 kernel space 段，或执行了标记为不可执行的栈区），或这里确实不应该有数据；</li><li>应用程序确实向操作系统申请了大量空间，不过有些还没使用过，OS 自己还<strong>没有</strong>将这段区域通过页表建立与物理内存的映射。</li></ul><p>所以，当程序指令访问上述 2 种段的时候，硬件发现在页表中找不到对应的物理地址，于是发出一个 Synchronous Exception，其类型是 Page Fault。</p><p>如果是因为访问了上面第一种情况的 “未分配的段”，那么在进入 Exception Handler 后，操作系统发现程序确实不应该访问这里，那么操作系统向原进程<strong>发送 SIGSEGV 信号 / SIGGPF 信号（Segmentation Fault 软件信号，或者 Protection Fault 软件信号，前面介绍过，这些信号是另一种 ECF 机制，下下节讨论）</strong>，控制流直接离开原程序（abort），属于 <strong>unrecoverable</strong> 类型；</p><p>如果是因为访问了上面第二种情况的 “未分配的段”，那么操作系统发现是自己没分配，于是在 Exception Handler 中，OS 会将一段新的物理地址分配给虚拟内存，记录在页表中，<strong>回到 $I_{current}$ 的位置</strong>，属于 <strong>recoverable</strong> 类型；</p></blockquote></li><li><p>触发后默认的行为：回到 $I_{current}$（recoverable），或者终止（unrecoverable）；</p></li></ul></li><li><p>Aborts（终止）</p><ul><li><p>触发方法：程序执行了一条神奇的指令，硬件层面严重错误，操作系统对应的 Exception Handler  也没辙，默认行为就是终止程序；</p></li><li><p>例子：<strong>illegal instruction（非法指令，通常因为低特权程序执行了高特权指令，或者压根汇编指令就有问题）、parity error（硬件奇偶校验错误）、machine check（硬件检查未知错误）</strong>；</p><blockquote><p>后两种可能是机器被宇宙射线击中，发生了 bits flop，或者硬件电路出问题了；</p></blockquote></li><li><p>默认行为：<strong>abort（unrecoverable）</strong>；</p></li></ul></li></ol><h3 id="13-3-5-Summary-of-Exception"><a href="#13-3-5-Summary-of-Exception" class="headerlink" title="13.3.5 Summary of Exception"></a>13.3.5 Summary of Exception</h3><p>13.3 中，我们介绍了非常底层级的一种硬件 ECF 机制：Exceptions，请大家回忆：<strong>Exception 的 概念、处理过程、实现方法、种类以及各种类之间的处理模式</strong>。</p><p><img src="imgs/exception_taxonomy.png" height="200px"></p><table>    <tr>        <th>Exception Type</th>        <td>Interrupt</td>        <td>Traps</td>        <td>Faults</td>        <td>Aborts</td>    </tr>    <tr>        <th>Recoverable</th>        <td>✔</td>        <td>✔</td>        <td>Possibly</td>        <td>❌</td>    </tr>    <tr>        <th>Return to</th>        <td>I next</td>        <td>I next</td>        <td>I current / abort</td>        <td>abort</td>    </tr></table><p>这种低层级的控制转移可以由操作系统和硬件联合实现，也是其他高级 ECF 机制的基础。</p><h2 id="13-4-Exception-Control-Flow-Process-Context-Switch"><a href="#13-4-Exception-Control-Flow-Process-Context-Switch" class="headerlink" title="13.4 Exception Control Flow: Process Context Switch"></a>13.4 Exception Control Flow: Process Context Switch</h2><p>要了解进程上下文切换，首先要了解什么是进程。</p><h3 id="13-4-1-Process"><a href="#13-4-1-Process" class="headerlink" title="13.4.1 Process"></a>13.4.1 Process</h3><ul><li><p>定义：一个进程是一个正在运行的程序的实例。</p><blockquote><p>与程序（program）不同，程序可以看作存在于 <code>*.c</code> 文件中的、存在于二进制文件的 <code>.text</code> 区域的、存在于已加载内存的字节中。</p><p>进程是计算机科学中最为影响深远的思想之一。</p></blockquote></li><li><p>进程的 3 种状态：Running、Blocked（Stopped）、Terminated</p></li><li><p><strong>进程提供的 2 个关键抽象</strong>：</p><ol><li><p>Logical Control Flow：</p><ul><li>每个进程都感觉自己独占了 CPU 资源，不用担心寄存器、CPU 的重要数据被更改；</li><li>这种逻辑上的控制流的隔离机制来源于 <strong>OS 内核和硬件提供的重要 ECF —— Process  Contest Switching</strong>；</li></ul><blockquote><p>啥是 Logical Control Flow，在本节结束后你就会知道。</p></blockquote></li><li><p>Private Address Space：</p><ul><li>每个进程都感觉自己独占了主存资源，不用担心别的程序未经同意访问自己的资源；</li><li>这种隔离机制来源于 <strong>OS 和硬件提供的重要抽象：Virtual Memory</strong>（前面说过）；</li></ul></li></ol><p>以上的两个抽象为操作系统提供了<strong>多进程执行与并发（Multiprocessing &amp; Concurrency）的能力</strong>。</p></li><li><p>基于上面 2 条关键抽象，我们的进程满足：</p><ol><li>有整套独立的虚拟内存空间，互不干扰；</li><li>有看起来能够持续执行的 CPU 及稳定的寄存器资源；</li></ol></li></ul><h3 id="13-4-2-How-does-Multiprocessing-work-on-single-processor"><a href="#13-4-2-How-does-Multiprocessing-work-on-single-processor" class="headerlink" title="13.4.2 How does Multiprocessing work on single processor ?"></a>13.4.2 How does Multiprocessing work on single processor ?</h3><p>那么，操作系统是如何同时运行多个进程的呢？我们以仅有一个处理器核为例。</p><p>我们在 13.3.4 中曾经提到过 “系统时钟中断和分时复用”。操作系统想要随时能够取得控制权，就需要<strong>借助硬件时钟，每隔一段时间触发一次时钟中断（interrupt）的 exception，让程序从用户态回到内核态</strong>，由操作系统判断情况，是否要进行一些调度或者切换等处理操作。</p><p>为了充分利用 CPU 等资源，同时运行多个进程，操作系统对每个进程的单次执行时间设置较短（大约 1 ms 量级），<strong>一旦该进程执行时间片耗尽</strong>，那么操作系统会<strong>借助时钟中断的机会</strong>触发一种高级的 ECF: Process Context Switch，将处理器上下文数据切换到另一个进程继续执行。</p><p>这里 “进程的上下文数据” 就是 <strong>能够让系统处理器从其他进程回到当前进程所需额外的数据</strong>。由于每个进程独享一段虚拟内存，所以原本在虚拟内存中的上下文数据无需另外保存。所以，进程的上下文数据一般指 <strong>处理器芯片中的各个寄存器的值、内核数据结构（页表、进程表、文件表等，都放在 kernel space 中）以及各进程虚拟内存总体的物理位置</strong>。</p><p>那么这样也不难理解为什么 OS 和硬件能做到在各个进程之间的无缝切换了。我们小小总结一下：</p><ul><li><p>什么是 Process Context Switch？</p><p>进程上下文切换是指 OS 和硬件 控制处理器保存在当前进程的上下文数据，并切换到另一个进程继续执行的过程。这种交替执行的方式被称为 <strong>interleaving</strong>；</p></li><li><p>为什么需要 Process Context Switch？</p><p>这能够让操作系统利用有限的 CPU 执行多进程任务（multiprocessing），充分利用系统资源，也不至于让一个进程卡死就波及到其他进程的执行。也就是说，<strong>interleaving 可以实现 multiprocessing</strong>；</p></li><li><p>什么时候出现 Process Context Switch？</p><ol><li><strong>（必定）当 Hardware Timer 触发了时钟中断 Exception</strong>；</li><li><strong>（必定）当该进程出现耗时的系统调用时，这种系统调用被称为 “慢系统调用”</strong>（通常是类似 <code>read/write/sleep</code> 的系统调用），哪怕该进程时间片没耗尽，操作系统依然会 suspend 这个进程（进程转为 blocked 状态）；</li><li><strong>（可能）当该进程出现了普通的系统调用</strong>，控制权流转到 OS Kernel 中，操作系统会根据情况（例如优先级等情况，在操作系统课程中的 <code>scheduling</code> 一节介绍）选择是否进行进程上下文切换。</li></ol><blockquote><p>我们发现这三种原因全都是 <strong>Exception</strong>，因此说底层 Hardware ECF 为高级 ECF 提供了基础条件。</p></blockquote></li><li><p>底层的 Process Context Switch 如何实现 / 进行的？</p><p>step 1. 因为上面所述的 3 种原因之一，当前进程执行到某一位置时暂停，并暂时转移到内核态，控制流交给 OS；</p><p>step 2. OS 判断当前是否应该进行 Process Context Switch，如果不是，则退出内核态，恢复原程序执行。不过大部分情况是应该进行切换的，因此进入下一步；</p><p>step 3. 确认要进行进程切换后，操作系统会评估各个进程的<strong>优先级、进程状态等信息</strong>，按照评估结果决定切换到哪个进程上，这个做出决定的内核程序段被称为 <strong>scheduler</strong>；</p><p>step 4. 操作系统在切换前找到原进程的信息，将上下文的处理器中的各个寄存器值存入该进程的虚拟内存中，然后转到 scheduled process 中，从 scheduled process 的虚拟内存中读出处理器的上下文数据，继续执行 scheduled process，过程如下：</p><p><img src="imgs/context_switch.png" height="200px"></p></li><li><p>在 Context Switch 中需要注意的是：</p><ul><li>OS Kernel 并不是一个单独的进程，OS Kernel 的数据存在于每个进程中，作为它们的一部分。通常数据位于各进程虚拟内存 <strong>栈区的下层（用户态不可访问）</strong>；</li></ul></li></ul><h3 id="13-4-3-Concurrency-amp-Parallelism-amp-Interleaving"><a href="#13-4-3-Concurrency-amp-Parallelism-amp-Interleaving" class="headerlink" title="13.4.3 Concurrency &amp; Parallelism &amp; Interleaving"></a>13.4.3 Concurrency &amp; Parallelism &amp; Interleaving</h3><p>之前我们讨论的实现 multiprocessing 的方式是 interleaving，而计算机科学中还有两个概念叫 <strong>并发（concurrency）和 并行（parallelism）</strong>，它们之间的关系是什么？我们来对比一下：</p><ul><li>并发：指<strong>在一个较短的时间内同时执行多条任务或进程</strong>，它是一种<strong>执行策略</strong>，我们可以由多种方案来实现这个策略；</li><li>交织（interleaving）：指<strong>交替（在时间上 sequential）执行多条任务或进程，但 “appeals to”（看起来像是）同时在执行所有任务</strong>，这个名词通常被用作多任务或分时复用的系统中，表明<strong>处理器短时间内在不同任务间切换以达到同时执行的效果</strong>。</li><li>并行：指<strong>严格同时地执行多条任务或进程</strong>，主要的目标是利用<strong>多核 / 多处理器</strong>共同工作的杠杆作用来同时地执行任务，提升系统性能；</li></ul><p>我们将上面的概念解析成几个容易理解的观点：</p><ol><li>并发是一个很广的概念，它可以通过多种机制实现，比如 并行（simultaneous execution）、交织（sequential execution with rapid switching），所以说 <strong>并行和交织都是实现并发的途径</strong>；</li><li>交织则强调在一个处理器上，充分利用有限资源执行多个任务，而并行则强调在多个处理器相互协作，同时处理不同的任务，达到 1+1 &gt; 2 的效果；</li></ol><p>可能还有同学会问，那多进程（multiprocessing）和它们又有啥关系？</p><p>实际上，我们上面讨论的都是抽象层面的策略和方案，它们可以针对计算机系统中的进程，也可以针对其他的任务。所以<strong>并发、并行、交织都是实现多进程的思路之一</strong>。</p><h3 id="13-4-4-Concurrent-Process"><a href="#13-4-4-Concurrent-Process" class="headerlink" title="13.4.4 Concurrent Process"></a>13.4.4 Concurrent Process</h3><p>理解了并行、并发、交织的概念后，我们再来看<strong>进程的并发</strong>。进程的并发有以下重要的概念：</p><p>首先我们在 16.1 中介绍过，物理控制流（大家回忆一下）是指硬件上正在执行的实际指令序列。现在，我们将每一个进程都看作一个 <strong>Logical Control Flow</strong>（逻辑控制流），所谓逻辑控制流就是<strong>从这个进程的开始到最终 terminated 的全过程</strong>（包括中间 blocked 的部分）。画一对图大家就理解了：</p><p><img src="imgs/physical_control_flow.png" height="200px"></p><p>如上图，假设在一个处理器上，进程 A、B、C 的物理控制流如图所示。我们可以看到这采取了一种多进程交替执行的方式实现了进程的并发。所以它所对应的逻辑控制流是：</p><p><img src="imgs/logical_control_flow.png" height="200px"></p><p>我们可以形象地理解，进程逻辑控制流就是将它的物理控制流从头至尾连接起来。</p><blockquote><p>注意：如果 <code>graph 2</code> 是物理控制流，那么这个行为就是多核并行了。</p></blockquote><p>在这个基础上，我们做出如下定义：</p><ul><li>如果两个进程的逻辑控制流在时间上相互重叠（overlap in time），那么称这两个进程是<strong>并发执行</strong>（concurrently）的；</li><li>否则称这两个进程是<strong>顺序执行</strong>（sequentially）的；</li></ul><h3 id="13-4-5-Process-Control"><a href="#13-4-5-Process-Control" class="headerlink" title="13.4.5 Process Control"></a>13.4.5 Process Control</h3><p>在了解很多进程的理论后，我们需要转向实践层面的学习。现代 Linux 系统提供了很多控制进程的<strong>系统级函数</strong>（C library 中包装的系统调用接口），这些函数操作进程的过程称为 “<strong>进程控制</strong>”，而这些<strong>系统级函数最终大多数都会进行系统调用</strong>。</p><p>以 x86-64 Linux 为例，大多数系统函数的规范是：</p><ul><li><p>如果执行出错，则返回 <strong>-1</strong>，同时设定全局宏 <code>errno</code> 来提示出错的原因。</p><blockquote><p>因此在使用系统级函数时，有一个约定俗成的硬性规定（hard and fast rule）：<strong>当调用系统级函数后，必须检查其返回值，已确认其是否正确执行</strong>。</p><p>某些特别的系统级函数除外，例如 <code>exit</code>、<code>free</code> 返回 <code>void</code> 类型；</p></blockquote></li></ul><p>首先遇到的第一个进程控制的系统级函数，用于<strong>复制 / 创建进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>作用：复制一个与当前进程一模一样的进程。复制出的进程被称为原进程的<strong>子进程</strong>，父进程的含义不解释。</p></li><li><p><strong>注意，一模一样是进程的虚拟内存中的几乎所有数据都一致，但父进程和子进程虚拟内存相互独立（相当于 deep copy）</strong>；</p><ul><li>虚拟地址、进程总体程序栈数据都一样；</li><li>文件标识符直接可以继承使用，也就是可以访问任何父进程已打开的文件；</li><li>父、子进程间 PID、页表等信息不一致；</li></ul></li><li><p>返回值：<strong>在父、子进程中分别返回一次。</strong></p><ul><li>当创建进程失败后，返回 -1；</li><li>当进程创建成功，且当前进程为父进程时，返回<strong>子进程的 PID（正整数）</strong>；</li><li>当进程创建成功，且当前进程为子进程时，返回 <strong>0</strong>；</li></ul></li><li><p>⚠ 使用提示：</p><ol><li><p>此方法创建的新进程与原进程的<strong>运行的顺序和同步性完全不能保证</strong>（即在逻辑控制流中没有明确先后关系）。因此输出时序具有随机性，在编程时不应该假设二者的执行顺序；</p></li><li><p>适宜使用<strong>树状拓扑图的结构</strong>（这被称为 <strong>进程图，process graph</strong>）分析存在多个 fork 进程控制的情况；</p><blockquote><p><strong>进程图的使用方法</strong></p><p>一个进程图是分析<strong>并发程序</strong>的语句<strong>部分执行顺序</strong>的有力工具。</p><ul><li>进程图是一个有向无环图（DAG，没有自环、重边），图的每个顶点代表每条语句的执行情况；</li><li><code>a -&gt; b</code> 表示 a 语句发生在 b 语句之前，二者<strong>在逻辑控制流上有明确先后关系</strong>；</li><li>进程图的<strong>边</strong>可以标注当前情况下<strong>变量的值</strong>；</li><li>进程图的<strong>点</strong>可以标注当前语句的<strong>输出或其他信息</strong>；</li><li>进程图的<strong>任意一种拓扑排序与一种可能的执行顺序</strong><u><strong>一一对应</strong></u>（所有拓扑排序则代表所有所有可能的执行顺序）；</li></ul><p>这里一个常见考题：给出一个含有很多 <code>fork()</code> 的程序，要求写出输出情况；</p></blockquote></li></ol></li></ul><p>其次，我们还可以<strong>获取进程号（PID）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>二者作用：获取当前进程 / 获取父进程 PID；</li><li>返回值：当前进程 / 父进程 PID；</li></ul><p>系统级函数还可以<strong>终止一个进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><ul><li>作用：以 <code>status</code> 状态数终止这个进程；</li><li>约定：<code>status</code> 状态数 0 表示正常退出，非零代表异常退出；</li><li>返回值：不返回任何值，一个进程只会执行一次；</li></ul><p>系统级函数还可以<strong>让一个进程主动进入 stopped 状态并持续一段时间</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;    <span class="comment">/* in &lt;unistd.h&gt; */</span></span><br></pre></td></tr></table></figure><ul><li>作用：让当前进程进入 stopped 状态 suspend 起来，不接受 OS 调度，直到 <code>sec</code> 秒后恢复 running 状态；</li><li>返回值：进程实际<strong>还剩多少秒没有 sleep</strong>（因为中途可能会被信号等 ECF 机制打断）；</li></ul><p>系统级函数也可以<strong>让一个进程无限期进入 stopped 状态，直到向其传入任意信号</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>作用：当前进程进行系统调用，直接进入 stopped 状态；</li><li>返回值：如果控制流能回来，那么总是返回 -1；</li></ul><hr><p>此外，系统函数还提供了 <strong>回收子进程（Reaping Child Process）</strong> 的能力。</p><p>为了了解这是什么意思，我们有必要 recap 一下在 16.4.1 中介绍的 Process 的概念。从编程人员的角度来看，一个进程具有 3 种状态（运行、阻塞 和 终止）。现在我们结合之前了解到的 Process Context Switch 和进程调度的基础知识，再重新认识一下这 3 种状态：</p><ul><li><p>Running：处于该状态的进程<strong>可能正在被执行</strong>，<strong>也可能是退出了阻塞状态，等待被 OS 调度执行</strong>；</p></li><li><p>Stopped：处于该状态的进程<strong>已挂起（suspended），并且无法被 OS 调度，除非有信号通知</strong>；</p></li><li><p>Terminated：处于该状态的进程<strong>已经永久结束运行</strong>；</p><blockquote><p>进程终止的 3 点原因：</p><ol><li>收到一个<strong>默认行为是终止进程的信号</strong>；</li><li><code>main</code> 流程执行完毕；</li><li>进程种的程序主动调用 <code>exit</code> 函数；</li></ol></blockquote></li></ul><p>我们发现，改变进程状态的方法是<strong>操作系统与应用程序间的</strong>高级 ECF：<strong>信号</strong>；而信号的发出又需要 硬件 ECF（Exception）作为条件。</p><blockquote><p>下一节会提及高级 ECF 信号的机制，举个例子，Ctrl + C -&gt; Interrupt Exception -&gt; Kernel 发出 SIGINT -&gt; 信号提醒进程进行默认行为）。</p></blockquote><p>除此之外，我们还看到，进程的状态中有一个是 terminated，这说明<strong>操作系统在一个进程终止后，会一直保存这个进程的状态和部分数据（包括退出状态、多种 OS 表），直到它被 “回收（reaped）”</strong>。那么为什么进程结束了还需要等待回收？为何不直接清除这个进程的数据？</p><p>这是因为，我们通常需要知道<strong>进程退出的一些状态信息（正常退出，还是因为其他原因退出）</strong>，如果 OS 在进程结束后就直接清除数据，那么我们无从知晓其中的信息。</p><p>通常情况下，在一个进程从永久退出执行，直到被回收的时间段内，我们将这个进程称为 <strong>zombie</strong>（僵尸进程，在 <code>ps</code> 命令下显示 <code>&lt;defunct&gt;</code>）。</p><p>那么进程最终应该由谁回收？答案是<strong>父进程或者是系统根进程 <code>init</code> (PID = 1)</strong>。父进程如果想要等待在子进程退出后获取子进程的退出状态，那么就需要使用系统级函数 <code>wait</code> 和 <code>waitpid</code>。准确地说，它们并不是 wait 进程结束，而是 wait 进程状态的改变；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *child_status)</span>;    <span class="comment">/* Equivalent to waitpid(-1, &amp;s, 0); */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* child_status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><p>由于 <code>wait</code> 是对 <code>waitpid</code> 的默认包装，因此我们这里仅介绍 <code>waitpid</code>；</p><ul><li><p>第一参数 <code>pid</code> 指定父进程要等待的子进程的 PID；如果传入 <strong>-1</strong>，则表示<strong>等待任意一个子进程状态改变即返回</strong>；如果传入 <strong>0</strong>，则表示<strong>等待任意一个与调用进程同进程组的子进程状态改变即返回</strong>；</p><blockquote><p>“状态改变”，而不是永久终止（terminated）。</p></blockquote></li><li><p>第二参数 <code>child_status</code> 应该传入一个整型地址，函数返回时会将子进程的状态码（<strong>和退出码不一样，需要专门的宏进行读取</strong>）填写进去；如果传入 <strong>NULL</strong>，则表示不关心子进程的状态，只是等待指定的子进程状态改变；</p><blockquote><p>读取该参数的宏位于 <code>&lt;sys/wait.h&gt;</code> 头文件中：</p><p><code>WIFEXITED(child_status)</code>：返回子进程是否被正常终止（调用了 <code>_exit(2)/exit(3)</code> 或从 <code>main</code> 返回）；</p><p><code>WEXITSTATUS(child_status)</code>：返回子进程的退出状态（当且仅当 <code>WIFEXISTED</code> 为真的时候有效）；</p><p><code>WIFSIGNALED(child_status)</code>：返回子进程是否被信号终止；</p><p><code>WTERMSIG(child_status)</code>：返回终止子进程信号的编号（当且仅当 <code>WIFSIGNALED(child_status)</code> 为真时有效）；</p><p>还有 <code>WCOREDUMP(child_status)</code>、<code>WIFSTOPPED(child_status)</code>、<code>WSTOPSIG(child_status)</code>、<code>WIFCONTINUED(child_status)</code> 等，大家可以用到再查；</p></blockquote></li><li><p>第三参数 <code>options</code> 常用的参数有 4 个，可以由按位或运算符连接：</p><ul><li><p>0：指定 <code>waitpid</code> 函数<strong>阻塞</strong>，直到子进程状态改变、获取信息后才返回；</p></li><li><p><code>WNOHANG</code>：指定 <code>waitpid</code> 函数<strong>非阻塞</strong>，如果子进程状态还没改变，那么立即返回；</p></li><li><p><code>WUNTRACED</code>：指定 <code>waitpid</code> 在子进程<strong>不是因为 <code>ptrace</code> 而进入 stopped 状态时</strong>也直接返回；</p><blockquote><p>什么是 <code>ptrace</code> ?</p><p><code>ptrace</code> 是 Linux 的<strong>另一个系统调用</strong>，为一个进程提供了<strong>观察</strong>和<strong>控制</strong>另一个进程的执行过程的能力，同时也提供<strong>检查</strong>和<strong>改变</strong>另一个进程的内存值以及相关寄存器信息。</p><p>大名鼎鼎的 <code>gdb</code> 和系统工具 <code>strace</code> 都是基于 <code>ptrace</code> 完成调试工作 和 逆向工程的。</p><p>这里的 <code>ptrace</code> 的系统级函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span>       </span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid, <span class="type">void</span> *addr, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure><p>事实上，当 <code>ptrace</code> 被调用来 attach 一个进程时，首先进入 syscall（Exception），操作系统在 exception handler 中的默认行为是通过<strong>信号</strong>沟通 <code>ptrace</code> 所在进程 和 attach 的进程，最后该进程会进入 <strong><code>Traced</code> 状态</strong>（一个与 Stopped 状态几乎相同的状态，都是暂时中止进程执行和调度），等待 <code>ptrace</code> 所在进程的调试工作。</p></blockquote></li><li><p><code>WCONTINUED</code>：指定 <code>waitpid</code> 在子进程接受到信号 <code>SIGCONT</code> 而从 stopped 状态恢复为 running 状态时，也直接返回；</p></li></ul></li><li><p>返回值：如果成功执行，则返回状态改变的子进程 PID（<strong>如果指定了 <code>WNOHANG</code>，并且指定的子进程存在，但是子进程还没改变状态，那么直接返回 0</strong>）；如果执行错误，那么返回 -1，错误码位于 <code>errno</code>；</p></li></ul><p>这两个函数不仅可以查看子进程的退出状态，而且也告诉操作系统，“如果子进程结束，则可以直接回收该进程了”。</p><blockquote><p>测试发现，如果 <code>waitpid</code> 是<strong>非阻塞</strong>的话，子进程结束仍然不能直接被回收。</p></blockquote><p>如果父进程不想了解子进程的退出情况（<strong>没有调用上述两个函数</strong>），或者<strong>在子进程结束前就退出了（那么这时，子进程被称为孤儿进程，orphaned child process）</strong>，那么操作系统<strong>会自动将回收权交给 <code>init</code> 根进程，等待孤儿进程结束后直接回收</strong>。</p><p>这种回收的流程可以总结为：</p><p><img src="imgs/reap_process.png"></p><blockquote><p>⚠ 一种可能的内存泄漏的情形：</p><p>在一个长期运行的服务器上，系统可能运行了大量的进程。对于一些服务程序，<code>init</code> 根进程不会回收这些 zombie 进程，因为服务器是长期运行的，也等不到父进程结束的情况。如果父进程不显式回收子进程，那么会导致 zombie 进程堆积，内存溢出，甚至内核崩溃。</p></blockquote><p>⚠ <strong>另外，还有一个要点，即 <code>waitpid</code> 只能等待父进程的直接子进程（immediate child process），它无法等待子进程的子进程的结束并返回信息的</strong>。</p><hr><p>最后，系统级函数还提供了<strong>更改当前进程运行的程序</strong>的功能（毕竟之前只提供了 <code>fork()</code> 通过复制创建进程）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> _Nullable argv[],</span></span><br><span class="line"><span class="params">           <span class="type">char</span> *<span class="type">const</span> _Nullable envp[])</span>;</span><br></pre></td></tr></table></figure><p>这条系统级函数也是系统调用的接口，可以在<strong>当前进程中加载并运行指定程序</strong>。</p><ul><li><p>第一参数 <code>pathname</code>：可执行文件名，它可以是二进制文件，也可以是由 <code>#!interpreter</code> 开头的脚本（Linux 约定俗成，在脚本文件前注释解释器名，例如 <code>#!/bin/bash</code>）；</p></li><li><p>第二、参数 <code>argv[]</code> 和 <code>envp[]</code> 分别是参数列表和环境变量列表，可以为空；</p><p><code>envp</code> 的设置就是简单字符串：<code>&quot;&lt;name&gt;=&lt;value&gt; ...&quot;</code>，或者使用 <code>getenv</code>、<code>putenv</code>、<code>printenv</code> 进行解析和设置环境变量字符串；</p><blockquote><p>注：<code>envp[]</code> 会在执行前由 OS append 几个参数，参数就是系统环境变量；</p></blockquote></li><li><p>返回值：<strong>仅在执行错误（找不到指定文件）时返回 -1</strong>；</p></li></ul><p>⚠ 注意，在当前进程运行该指令后，<strong>如果正确执行，那么程序控制流永远不会回到该指令的下一行，程序整体会在虚拟内存中完全被替换为新运行的程序，即完全覆盖当前程序虚拟空间，包括 code 区、data 区、stack 区等等</strong>，仅保留 PID、file descriptor 和 signal context（信号上下文）。</p><p>这意味着，正确执行的情况下，<strong><code>execve</code> 不会有返回值</strong>。</p><p>这还意味着，如果你想开发一个 Linux shell，那么你使用 <code>execve</code> 时，应该 <code>fork</code> 一个子进程出来，然后在子进程中执行该命令。否则当前程序会被覆盖。</p><p>当新的程序被从可执行文件加载到虚拟内存后，程序的虚拟内存的结构应该是这样（不包括 kernel space）：</p><p><img src="imgs/new_user_stack.png" height="350px"></p><blockquote><p>有同学可能会问，为啥不做一个<strong>同时创建一个进程并运行指定程序的系统调用呢？</strong>实际上，设计者从实用性和冗余性两个方面考虑，<code>fork</code> 非常有用，例如对于一个并发服务器而言，想要创建多个副本来响应 client，那么只需要 fork 就行；</p><p>而且你可以在运行指定程序前、fork 之后的时间内可以做一些其他自定义的准备工作，非常灵活。</p></blockquote><h3 id="13-4-6-Summary-of-Process-amp-Process-Control"><a href="#13-4-6-Summary-of-Process-amp-Process-Control" class="headerlink" title="13.4.6 Summary of Process &amp; Process Control"></a>13.4.6 Summary of Process &amp; Process Control</h3><p>在本节中，我们学习了一种高级的 ECF 机制：Process Context Switch。为了深入讨论这个话题，我们首先了解了进程的概念（一个正在运行的程序的实例），以及进程重要的 2 个抽象——对 CPU（logical control flow 是连续的）和 主存（private address space 是独享的）的抽象。</p><p>另外，我们从 “系统如何充分利用有限资源实现多进程并发” 的问题入手，了解了当今 Linux 操作系统<strong>利用 Timer Interrupt Exception</strong>（分时复用和时间片轮转）<strong>和 系统调用</strong> 达到 Process Context Switch 的目的，进而实现多进程执行的 interleaving。于是 进程上下文切换的 <strong>What、Why、When、How</strong> 四个问题都得到了解答。</p><p>其中，我们还详细比较了 interleaving、parallelism、concurrency、multiprocessing 的概念的异同，分析了怎么看 Physical Control Flow、怎么画 Logical Control Flow、怎么判断进程是 concurrent 还是 sequential 执行的。</p><p>最后一部分，在实际编程层面，我们介绍了控制 process 的、包装了系统调用的<strong>系统级函数</strong>，它们分别有：<code>fork</code>、<code>getpid</code>、<code>getppid</code>、<code>exit</code>、<code>sleep</code>、<code>waitpid(wait)</code>、<code>execve</code>。我们重点分析了这些函数的参数、返回值的含义，以及调用时的注意事项和技巧。</p><p>例如分析多重 <code>fork</code> 的进程图，<code>fork</code> 和 <code>execve</code> 的独特返回方式，<code>waitpid</code> 的复杂参数，最重要的点之一还是 “<strong>为什么要有进程回收、怎么进行进程回收</strong>” 的问题。</p><p>不过，我们在这节多次提到信号的概念，足以说明信号在操作系统与应用程序间的 ECF 的重要性。下节我们就讨论高级 ECF 中的信号（signal）机制。</p><h2 id="13-5-Exception-Control-Flow-Signals"><a href="#13-5-Exception-Control-Flow-Signals" class="headerlink" title="13.5 Exception Control Flow: Signals"></a>13.5 Exception Control Flow: Signals</h2><p>信号是由 OS 进行管理的软件信号，信号的种类和规范都由 OS 制定，完成 OS 和应用程序间的通信，实现高级的 Exception Control Flow；因此，我们需要先了解一下 OS（以 x86-64 Linux 为例）进程的继承结构，这样有助于在分析信号的时候不至于晕头转向。</p><h3 id="13-5-1-Linux-Process-Hierarchy-amp-Shell-Example"><a href="#13-5-1-Linux-Process-Hierarchy-amp-Shell-Example" class="headerlink" title="13.5.1 Linux Process Hierarchy &amp; Shell Example"></a>13.5.1 Linux Process Hierarchy &amp; Shell Example</h3><p>在 Linux 中，只有一种方法创建新的进程 —— <code>fork</code>；而由 <code>fork</code> 创建的进程有明确的父子关系，因此，Linux 中的所有程序所在进程实际上形成了一个层次结构：<strong>进程树</strong>。</p><p>在 Linux 启动的第一个进程是 <code>init</code> 根进程（PID = 1），其后所有生成的进程均为 <code>init</code> 的子进程。<code>init</code> 进程一般会创建 2 类进程：</p><ul><li><p><code>Daemon</code>：守护进程，是一类长期运行的程序，用来提供服务（例如对于一个 web 服务器，那么可能运行的服务是 apache 服务 <code>httpd</code>）；</p></li><li><p><code>login shell</code>：登录进程，这个进程运行的是命令行程序，为用户提供命令行接口，这样用户在登录后，可以以特定用户的身份，通过输入命令的方式与程序进行交互；</p><blockquote><p>例如用户输入 <code>echo &quot;Hello, Linux.&quot;</code> 的指令并回车，发生的是如下情况：</p><p><img src="imgs/login_shell.png" height="200px"></p></blockquote></li></ul><p>知道了这个道理，再结合上一节我们接触到的 process control 的系统级函数，我们就可以开始自己尝试用 C 写一个系统命令行了。我们来看看这个小型的命令行程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Fgets</span><span class="params">(<span class="type">char</span>* dst, <span class="type">int</span> cnt, FILE* input)</span>;    <span class="comment">/* 定义略，就是对 fgets 的包装 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* line, <span class="type">char</span>* argv[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];    <span class="comment">/* command line */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* read */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* evaluate */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS];    <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];        <span class="comment">/* Holds modifiled command line */</span></span><br><span class="line">    <span class="type">int</span> bg;                    <span class="comment">/* Should the job run in bg or fg ? */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;        <span class="comment">/* Ignore empty lines */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123;    <span class="comment">/* Check if it is a builtin command */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;    <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, atgv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>细心的同学会发现，这个程序有个严重的 bug —— 它只对运行在 foreground（前台）的程序进行回收，对运行在 background（后台）的程序则仅仅是打印一条信息，就不再关心了。前一节我们讨论过，像 shell 这样长期运行的程序如果不回收其子进程，会导致 zombie 的堆积，引发内存泄漏的问题。</p><p>那么问题来了，对于运行在后台的子进程，我们不想等待，但该如何知道它何时结束，并且回收呢？这个问题的解决方案就是<strong>利用 Exception Control Flow</strong>，因为只有它能够不按照应用程序原先控制流，而是转向 OS Kernel，让 OS Kernel 配合通知我们的 shell 后台子进程的情况。这就是本节的主角，也是这类问题的解决方案 —— 信号（高级的 ECF 机制之一）。</p><h3 id="13-5-2-The-Features-of-Signals"><a href="#13-5-2-The-Features-of-Signals" class="headerlink" title="13.5.2 The Features of Signals"></a>13.5.2 The Features of Signals</h3><ul><li>定义：信号是一种软件产生的，<strong>用来通知进程，系统中某一种事件发生的小型信息</strong>。</li></ul><p>我们发现，信号的定义很像之前的 Hardware ECF（Exception），它们都是某种事件发生时触发的信息通知机制，但是后者是<strong>硬件和操作系统层面</strong>（包括 Asynchronous Exception 的硬件引脚 Interrupt 和 Synchronous Exception 的处理器触发进入 Exception table），前者则完全是<strong>由操作系统软件产生的软件层面的信息</strong>，抽象层级更高。</p><ul><li><p>发送方：通常是 <strong>OS Kernel</strong>，有时是<strong>一个 Process 请求内核（利用 <code>syscall</code> 这个 Exception）来向另一个进程发送</strong>（所以本质上<strong>只有</strong> OS Kernel 有权限发送信号）；</p></li><li><p>接收方：总是一个 Process；</p></li><li><p>发送时机：<strong>总是因为</strong>处理器触发了一个 Hardware ECF，进入某个 Exception Handler 中的行为，可能有以下两个原因：</p><ol><li>System call（<code>trap</code>）：有几种<strong>向另一个进程发送特定信号的系统调用</strong>：<code>kill</code>（不是专门 terminated 进程的系统调用，而是用来发信号的，名字起的不好！），和之前我们接触过的 <code>ptrace</code> 等；</li><li>其他 unintended hardware ECF（例如 Interrupt（典型是 <code>Ctrl+C/D/Z</code> 键盘 I/O）、Fault（常见是 Page Fault、Floating Point Exception）等等）；</li></ol></li><li><p>接收时机：？？？（<strong>我们在下一节介绍</strong>）</p></li><li><p>内容：它真的很小，<strong>仅仅是一个小整型 ID（1 ~ 30）</strong>，来代表信号的种类；</p><p>不过每个整型在 OS 中对应唯一的信号类型和含义。下面是常见的几个信号：</p><table>    <tr style="text-align: center;">        <th>ID</th>        <th>Name</th>        <th>Default Action</th>        <th>Corresponding Event</th>    </tr>    <tr>        <td>2</td>        <td>SIGINT</td>        <td>Terminate</td>        <td>User typed ctrl-c</td>    </tr>    <tr>        <td>9</td>        <td>SIGKILL</td>        <td>Terminate</td>        <td>Kill program (<b>cannot override or ignore</b>)</td>    </tr>    <tr>        <td>11</td>        <td>SIGSEGV</td>        <td>Terminate &amp; Core dump</td>        <td>Segmentation violation</td>    </tr>    <tr>        <td>14</td>        <td>SIGALRM</td>        <td>Terminate</td>        <td>Timer signal</td>    </tr>    <tr>        <td>17</td>        <td>SIGCHLD</td>        <td>Ignore</td>        <td>Child stopped or terminated</td>    </tr></table><p>我们解释一些上面的信号。</p><p>首先，<code>SIGINT</code> 就是我们对前台运行的程序触发 <code>Ctrl+C</code> 按键后，首先发生 Asynchronous Exception（Interrupt），通知处理器，处理器按照 Exception 处理流程转移到 OS Kernel 中处理 Keyboard Interrupt 的 Exception Handler 中，发现这是个 <code>Ctrl+C</code>，因此向目标进程发送一个 <code>SIGINT</code> 信号，然后把 Control Flow 交还 user mode 的 $I_{next}$；同时，目标进程收到信号会进行默认行为 —— terminated（可以 override，即自己设计接收信号的 procedure）；</p><p>对于 <code>SIGKILL</code> 过程类似上面的情况，但是它一般利用 <code>kill -9</code> 指令，进行了系统调用，通过 <code>trap</code> 来发送信号；</p><p>对于 <code>SIGSEGV</code>，一般是处理器访问非法地址后出现 <code>page fault</code>，可能发送这个信号；</p><p>对于 <code>SIGALRM</code>，一般可以用作自定义信号，利用硬件时钟进行一些任务（例如设置与超时相关的行为）；</p><p>对于 <code>SIGCHILD</code>，一般在<strong>一个进程的子进程的状态改变后</strong>，OS Kernel 会向该父进程发送这条信号，但默认行为是忽略。如果父进程是一个 long-run program 并且不使用阻塞的 <code>waitpid</code>，那么我们在父进程中应该主动捕获这个信号，防止发生子进程的内存泄漏；</p><blockquote><p>除此之外，我们在前面还见到过 <code>SIGFPE</code>、<code>SIGGPE</code> 等等信号，用到时再查也不迟；</p></blockquote></li></ul><h3 id="13-5-3-Implementations-of-Sending-a-Signal"><a href="#13-5-3-Implementations-of-Sending-a-Signal" class="headerlink" title="13.5.3 Implementations of Sending a Signal"></a>13.5.3 Implementations of Sending a Signal</h3><p>那么，通过上面的解释，我们大致知道了，OS Kernel 大多是借助 Exception（Hardware ECF）这个时机来实现信号的发送的，但具体是如何进行的呢？</p><p>实际上，OS Kernel 向某个进程发送信号是通过<strong>改变目标进程上下文的状态数据</strong>来实现的。</p><blockquote><p>Linux 官方文档原文：</p><p>Kernel sends a signal to a destination process by updating some state in the context of the destination process.</p></blockquote><p>对，仅仅是目标进程的上下文的某个数据改变了，仅此而已。</p><p>那么，目标进程的响应机制呢？主要有以下几种：</p><ul><li><p><strong>Ignore</strong>：忽略该信号；</p></li><li><p><strong>Terminate</strong>：该进程终止，或被迫终止（不是中止，stopped）；</p></li><li><p><strong>Catch</strong>：捕获信号并处理（这里捕获信号并处理的程序称为 <strong>Signal Handler</strong>，<strong>它与 Exception Handler 不一样，它位于用户态代码中——也就是说，咱可以自己在 C 程序中设计 Signal Handler</strong>）；</p><p>对于 catch 这个选项而言，我们还要了解一下 signals 到达目标进程后的过程：</p><p><img src="imgs/signal_procedure.png" height="200px"></p><p>但是，在<strong>信号到达后、进程 A 收到（就是感知到）并处理之前</strong>的一段时间内，由于<strong>某个给定的时刻，只能有一个类型的待处理信号</strong>（因为信号是一个整型，发送信号就是改变一个数据，没有队列这个数据结构，所以重复发就会覆盖，下面会看到这种数据结构）。所以有两个问题：</p><ol><li>我们不能继续给这个进程发送信号，那么 OS 应该怎么知道目标进程有没有收到？</li><li>进程 A 是按照普通控制流正常运行的，怎么让它去临时接收这个信号呢？</li></ol><p>实际上，这引入了信号的 2 个概念：<strong>Pending 和 Blocked</strong>；不仅如此，我们还要了解 <strong>进程组的概念</strong>，然后我们才能完整地解释信号的收发过程。</p></li></ul><hr><p>下面是 13.5.3 的知识补充：</p><h4 id="13-5-3-1-Signal-Concepts-Pending-amp-Blocked"><a href="#13-5-3-1-Signal-Concepts-Pending-amp-Blocked" class="headerlink" title="13.5.3.1 Signal Concepts: Pending &amp; Blocked"></a>13.5.3.1 Signal Concepts: Pending &amp; Blocked</h4><p>其实信号也存在状态，其中两个特殊的状态是 pending 和 blocked：</p><ul><li>如果一个信号被 OS Kernel 发送，但是还没有被目标进程接收（感知并处理），那么这个信号处于 Pending 状态；（<strong>重复一遍，没有队列数据结构</strong>）</li><li>如果一个信号被 OS Kernel 发送，但是目标进程显式地阻塞特定信号的接收（感知但保留信号不处理），那么这个信号处于 Blocked 状态，除非该进程主动 unblock；</li></ul><p>从这里我们可以知道，<strong>pending 状态的 signals 至多只会被目标进程接收一次，但 blocked 状态的 signals 可以接收多次</strong>；</p><p>我们说过，信号只是一个表示信号类型的小整型，存不了其他数据，因此<strong>信号的状态是由 OS Kernel 维护的</strong>。</p><p>OS Kernel 中<strong>保存了各进程的 Pending / Blocking bits 组成的 bit vectors</strong>，位于每个进程的上下文虚拟内存的 kernel space 中。维护方法如下。</p><p><strong>对于 Pending Signals</strong>；</p><ul><li>当一个另一个进程的 OS Kernel 向当前（目标）进程发送<strong>第 k 号</strong>信号，那么当前进程的 OS Kernel 会设置当前进程的 Signal Pending Vector 的<strong>第 k 位</strong>为有效位（假设是 1）；</li><li>当当前进程接收了这个信号 k，那么当前进程的 OS Kernel 会设置当前进程的 Signal Pending Vector 的第 k 位为无效位（对应是 0）；</li></ul><p><strong>对于 Blocked Signals</strong>：</p><blockquote><p>Signal Blocked Vector 相当于是对 Signal Pending Vector 的<strong>掩码</strong>（被称为 <strong>signal mask，信号掩码</strong>）。</p></blockquote><p>如果 block / unblock 特定信号，那么目标进程会使用 <strong><code>sigprocmask</code>（又一个系统调用）</strong>显式设置掩码位对应的 Pending Signal 是否有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> <span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> oldset)</span>;</span><br></pre></td></tr></table></figure><p>具体用法见 13.5.5 节；</p><h4 id="13-5-3-2-Process-Concept-Process-Groups"><a href="#13-5-3-2-Process-Concept-Process-Groups" class="headerlink" title="13.5.3.2 Process Concept: Process Groups"></a>13.5.3.2 Process Concept: Process Groups</h4><p>在 Linux 下，每个进程都明确属于一个进程组。那么如何为一个新产生的进程分配进程组？</p><p>实际上，进程组的分配有专门的系统调用（又来几个系统调用）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">/* Equivalent to getpgid(currentPID); */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">/* Equivalent to setpgid(currentPID, currentPID); */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>上述函数执行失败返回值均为 -1，均会设置 <code>errno</code>，注意检查。</p></blockquote><p>注意，进程组号 PGID 和进程 PID 是共用类型 <code>pid_t</code> 的。</p><p>此外，创建一个进程，<strong>默认的进程组号与父进程的进程组号相同</strong>。进程属于且仅能属于一个进程组；</p><p>这样的话，可以方便我们向<strong>在同一进程组中的所有进程都发送信号</strong>。例如，如果我们使用系统调用 <code>kill</code> 来给一个进程或进程组发送信号（以包装好的系统命令为例。当然，C library 也包装了一个系统级函数 <code>kill</code>，能够在 C 中向另一个进程发送信号）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 12345</span><br></pre></td></tr></table></figure><p>上面的指令就表示请求 bash 调用系统调用 <code>kill</code>，向<strong>进程号</strong>为 <code>12345</code> 的一个进程发送 9 号信号（<code>SIGKILL</code>）；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 -12344</span><br></pre></td></tr></table></figure><p>上面的指令由于进程号前加了一个短 dash，因此被解释为 <strong>进程组号</strong>，上面的行为是向<strong>进程组号</strong>为 <code>12344</code> 的所有进程发送 9 号信号。</p><p>然后我们回过头解释一下 <code>Ctrl+C/Z</code> 是如何发送信号的。如下图。</p><p><img src="imgs/process_group.png" height="300px"></p><p>首先，我们在 bash 中输入的指令和我们之前了解的一样，分为前台和后台任务；bash shell 在 <code>fork</code> + <code>execve</code> 一个指令的时候，会根据指令后面有没有 <code>&amp;</code> 来判断这是条前台还是后台任务。如果是前台任务，那么创建进程后还会进行系统调用，将前台任务放到<strong>前台进程组</strong>中。前台进程在一个 shell 主进程中只有一个，所以一般这个前台进程组由 shell 进程直接管理。</p><p>如果我们按下 Ctrl+C/Z，那么 Interrupt Exception Handler 的默认行为就是向 shell 进程发送 <code>SIGINT/SIGSTP</code> 信号；而 shell 定义了对于该信号的 Signal Handler，也就是<strong>向前台进程组中所有进程发送 <code>SIGINT/SIGSTP</code></strong>（不影响后台进程）。这就完成了一次键盘 I/O 信号的发送和传递。</p><blockquote><p>注：<code>SIGSTP</code> 信号的默认行为是让目标进程的状态 suspend 到 stopped 状态，直到接收到 <code>SIGCONT</code> 信号后才恢复。</p></blockquote><hr><h4 id="Back-to-13-5-3"><a href="#Back-to-13-5-3" class="headerlink" title="Back to 13.5.3"></a>Back to 13.5.3</h4><p>了解了信号的状态和管理的知识 和 进程组的知识，我们再回到 13.5.3，看看<strong>完整的信号处理过程</strong>应该是什么样子的。</p><p>考虑一个会经常出现的情形：某一个进程 A 正在执行，进程 B 的 OS Kernel 想向进程 A 发送一个第 k 号信号，怎么办？OS 是这么做的：</p><p><code>step 1.</code> 在某次 Process Context Switch 中，OS 的 scheduler 决定切换到 Process B，于是按照 Process Context Switch 的规范进行切换（保存当前进程上下文数据到当前进程的虚拟内存中，读 Process B 的进程上下文数据并加载到处理器中）；<strong>在运行 B 的代码前，OS Kernel 会按照想要发送给 A 的信号（k）来更改  A 的 Kernel space 中的 Pending Vector（将第 k bit 置为有效位 1）</strong> 然后转入用户态，正式运行 Process B 的代码；</p><p><code>step 2.</code> 在执行 Process B 一段时间后，处理器触发了 Exception（Interrupt、Trap、Recoverable Fault），于是控制流重新进入内核态。假如 scheduler 决定切换到另一个进程（也就是目标进程）A，<strong>那么在正式切换前，Kernel 会检查进程 A 的 signal 情况：使用 <code>pnb = pending &amp; ~blocked</code> 计算出上次 Kernel 发给这个进程的信号的集合，<code>pnb</code> 就是所有未被阻塞的信号的 bit vector</strong>；</p><ul><li>如果 <code>pnb == 0</code>，那么说明当前没有收到未阻塞的信号，OS Kernel 会继续进行 Context Switch 操作，切换到 Process A；</li><li>否则，OS Kernel 会选择 <code>pnb</code> 中最低非零位的 bit（假设第 k 位）作为信号接收。那么，OS Kernel 将 pending vector 第 k 位置为无效位（0），<strong>并且执行对应 k 号信号的 Signal Handler</strong>，<strong>此后重新回到 step 2 计算并检查 <code>pnb</code>，直至 <code>pnb == 0</code></strong>；</li></ul><p>这样信号的发送和接收的流程就形成了闭环：</p><ul><li><strong>信号接收时机：在 Process Context Switch 进入目标进程前统一检查并接收</strong>；</li></ul><p>于是我们可以说：</p><p><strong>信号的发送和接收依靠 Process Context Switch 实现，而 Process Context Switch 又是依靠 Hardware ECF（Exception）来实现的，三者抽象层级依次升高，密不可分，分别构成了硬件与操作系统、操作系统与应用程序间的 ECF 交互机制</strong>。</p><h3 id="13-5-4-Signal-Handlers-amp-Default-Action"><a href="#13-5-4-Signal-Handlers-amp-Default-Action" class="headerlink" title="13.5.4 Signal Handlers &amp; Default Action"></a>13.5.4 Signal Handlers &amp; Default Action</h3><p>好了，到目前为止，我们已经大致将信号机制的脉络捋清了。还有一点，我们之前就很想了解的：<strong>怎么自定义 signal handlers 呢？</strong> 这就需要我们更改一个进程收到某个信号的默认行为（Default Action）了。</p><p>提供修改信号 Default Action 的还是一个<strong>系统调用</strong>：<code>signal</code>（名字和 <code>kill</code> 一样有误导性。这里 <code>signal</code> 系统调用不是发送信号，而是设置进程对于信号的 default action）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">handler_t</span> *<span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注 ：<code>handler_t*</code> 类型被 <code>typedef</code> 为一个函数指针类型 <code>void(*)(int)</code>；</p></blockquote><ul><li><p>第一参数 <code>signum</code>：要修改该进程默认行为的信号编号（在 <code>&lt;signal.h&gt;</code> 中有宏定义可供使用）；</p></li><li><p>第二参数 <code>handler</code>：类型为 <code>void(*)(int)</code> 的函数指针，即为 signal handler（其参数也为信号编号）；</p><blockquote><p>如果是要设置 Ignore / Terminate 为默认行为，那么它们（函数指针）在 <code>&lt;signal.h&gt;</code> 还有特定的宏：<code>SIG_IGN</code>、<code>SIG_DFL</code>；</p></blockquote></li><li><p>返回值：如果执行成功，则返回传入的 signal handler 指针；否则返回宏 <code>SIG_ERR</code>（0）；</p></li></ul><p>可是问题又来了。我们知道，signal handler 会在 Process Context Switch 前被调用，调整程序的 control flow。因此，signal handler 用户态代码 和 普通代码一样，都可以作为<strong>并发流（concurrent flow）</strong>。以前我们接触的并发流都是不同进程间的 control flow。不同进程间资源不共享，它们间的切换依靠 Process Context Switch；</p><p>但是！一旦引入了 signal handler，<strong>signal handler 本身是和原进程并发的</strong>，而它又会共享原进程的一切资源，这可能出现问题（<strong>什么问题？在 16.5.6 节讨论</strong>）</p><p>我们结合 signal handler，顺便复习一下 16.5.3 中的内容，从另一个角度来看<strong>完整的信号收发过程和并发</strong>的情况：</p><p><img src="imgs/full_signal_procedure.png" height="300px"></p><ul><li>首先我们知道，如果有一个进程 B 想要想要给 Process A 发送信号，那么在某次从 Process A  Process Context  Switch 到 Process B <strong>前</strong>（置位操作不一定正好发生在 Process Context Switch 时，可以在此之前），Kernel 就为 Process A 的 Pending Vector 置了有效位（如上图最上面的箭头）；</li><li>随后通过 Process Context Switch 后，控制流进入 Process B；</li><li>一段时间后，如果再次出现了一个 Process Context Switch，决定向 Process A 跳转，那么在进入 A 正式执行前，会检查其 <code>pnb</code> 向量是否为 0（如上图下面的箭头），然后按 default action 进入位于 user code 中的 <code>handler</code>（signal handler）中；</li><li>当 <code>handler</code> 执行完成后，控制流再次进入 kernel code 进行一些准备（例如恢复 $I_{next}$ 数据）；</li><li>最后控制流真正回到 user code 的 $I_{next}$ 的位置继续执行；</li></ul><h3 id="13-5-5-Nested-Signal-Handlers"><a href="#13-5-5-Nested-Signal-Handlers" class="headerlink" title="13.5.5 Nested Signal Handlers"></a>13.5.5 Nested Signal Handlers</h3><p>⚠ 这会出现一种情况 “Nested Signal Handlers”，因为在运行在 signal handler 时，毕竟也是 user code，也有可能发生 process context switch：</p><p><img src="imgs/nested_signal_handlers.png" height="250px"></p><p>为啥要讨论这种情况？因为 <strong>OS Kernel 对已经正在处理同类型信号时（即位于该信号的 Signal Handler 时），会自动阻塞该进程对同类型信号的接收</strong>。这种信号阻塞方式称为 <strong>Implicit blocking（隐式阻塞）</strong>；</p><blockquote><p>例如上图，如果程序位于第（4）步，那么它既会阻塞 <code>S</code> 信号，又会阻塞 <code>T</code> 信号的接收。</p></blockquote><p>而我们之前 16.3.5.1 介绍过的 <code>sigprocmask</code> 系统调用，则是程序可以显式地修改对信号的阻塞情况。</p><p>我们再回顾一下它的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> <span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> oldset)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>sigset_t</code> 就是之前我们说的 Pending Bit Vector 的数据；</p></blockquote><ul><li>第一参数 <code>how</code> 可不是信号编号，因为信号编号应该是 <code>set</code> 的 bit 位；它是 <strong><code>sigprocmask</code> 要执行的行为</strong>，具体也是由宏定义的：<ul><li><code>SIG_BLOCK</code>：将指定参数 <code>set</code> 的有效位加入现在的 blocking bit vector，阻塞指定信号（<code>blocked |= set</code>）；</li><li><code>SIG_UNBLOCK</code>：将指定参数 <code>set</code> 中的有效位从现在的 blocking bit vector 移除，停止阻塞某种信号（<code>blocked ^= set</code>）；</li><li><code>SIG_SETMASK</code>：直接将参数 <code>set</code> 作为 blocking bit vector（<code>blocked = set</code>）；</li></ul></li><li>第二参数 <code>set</code> 是一个与 pending bit vector 格式相同的数据，作用在第一参数中能看到，具体我们怎么操作这个向量并且填上去，还有专门设置这个 vector 的函数：<ul><li><code>sigemptyset</code>：返回一个空的 pending bit vector 数据；</li><li><code>sigfillset</code>：返回一个每个信号位都有效的 pending bit vector 数据；</li><li><code>sigaddset</code>：返回一个在输出 pending bit vector 基础上置位指定信号位的新的 pending bit vector 数据；</li><li><code>sigdelset</code>：同理，删除；</li></ul></li><li>第三参数在接下来的例子中就能看到。</li></ul><p><strong>这个虽然很多，但很重要！！！在 Shell Lab 中会用到</strong>。</p><p>为什么我们要用到它们呢？直接交给 OS Kernel 隐式阻塞不好吗？<strong>我们不妨考虑一个场景，如果程序中有一串代码不希望被用户用 Ctrl+C 打断，那么我们就需要暂时显式地阻塞 <code>SIGINT</code> 信号</strong>，下面就是例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> mask, prev_mask;</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line">sigaddset(&amp;mask, SIGINT);</span><br><span class="line"><span class="comment">/* Block SIGINT and save previous blocked set */</span></span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Code region that will not be interrupted by SIGINT */</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Restore previous blocked set, unblocking SIGINT */</span></span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>看完这串代码你大概能明白 <code>sigprocmask</code> 的第三个参数的含义了：以指针传入，<strong>存储以前的信号掩码信息，便于之后的恢复工作</strong>。</p><h3 id="13-5-6-Safe-Signal-Handling-⚠IMPORTANT"><a href="#13-5-6-Safe-Signal-Handling-⚠IMPORTANT" class="headerlink" title="13.5.6 Safe Signal Handling [⚠IMPORTANT]"></a>13.5.6 Safe Signal Handling [⚠IMPORTANT]</h3><p>讨论完前面的知识，相信大家心里有点数了——信号非常难缠，不仅约定、机制和系统调用接口贼多，而且你必须小心再小心，否则会出大问题：</p><ul><li><p>不正确地处理信号会导致一些系统级问题，包括但不仅限于：</p><ul><li><p>内存泄漏（zombie 堆积等原因）；</p></li><li><p>共享内存访问冲突（<strong>死锁 dead lock、段错误 Segmentation fault 等问题都会出现</strong>。由于 signal handlers 与普通 user code 共享内存，但它们是并发的，很像一对<strong>并发的线程，thread</strong>），<strong>你要像写多线程程序一样小心，保证线程安全性</strong>；</p><blockquote><p>为什么？这还是因为 signal handlers 和 普通程序构成了<strong>并发流</strong>。</p><p>因为在 signal handler 执行前后，原程序都停留在 $I_{current}$ 的位置上，这样在 Logical Control Flow 上看，它们是并发的，<strong>几乎和两个线程的效果一样</strong>。</p><p>如果原程序正在改变一个诸如链表一样的数据结构，结果被 Exception 打断，进入了 signal handler；那么如果 signal handler 也改变了这个链表，当控制流回到原程序时，<strong>原程序并不知道自己的链表被改变了，因为从他的角度看，它还一步指令都没执行呢！</strong></p><p>⚠ 相信我，这种 Bug 非常难找，因为就算 <code>gdb</code> 也只能逐线程、逐进程地看。</p><p>所以在写 signal handlers 的时候，请<strong>一定注意访问全局 / 其他共享变量时的安全问题</strong>！！！</p></blockquote></li></ul></li><li><p>信号除了类型，没有其他语义。这是因为多个信号可能在接收时发生覆盖。<strong>因此我们不能用信号进行计数（即计信号发送了几次）</strong>！</p></li><li><p>不同版本的 Linux 中，<strong>信号的语义不同，难以移植</strong>；</p><ul><li>某些老旧系统在触发自定义的 signal handler 后，会重新变为 default action，需要重新设置。不过在 Linux 上不用担心；</li><li>某些系统根本不会在进程处理该类型信号时隐式阻塞；</li></ul><blockquote><p>为了解决这个问题，我们可以利用 <code>sigaction</code> 进行覆写处理。</p></blockquote></li><li><p>某些<strong>慢系统调用</strong>（类似 <code>read</code> 这样一定会触发 Process Context Switch 的）会使得 <code>errno</code> 变为 <code>EINTR</code>；</p><blockquote><p>因为如果触发慢系统调用的进程先于系统调用退出，那么系统调用会发生错误，并且设置 <code>errno</code> 为 <code>EINTR</code>；</p><p><strong>所以如果你在程序中发现这种错误，就重新进行这个系统调用</strong>；</p></blockquote></li></ul><p>那么怎样做是安全的呢？</p><ol><li><p>Signal Handlers 写的越简单越好，尽量能不往里面加代码，就不加；</p><blockquote><p>比如，你可以在一个信号函数中只是设置一个全局变量，然后立即返回；</p></blockquote></li><li><p>仅使用 <strong>异步信号安全（async-signal-safe）的</strong> 函数；</p><blockquote><p>什么是<strong>异步信号安全</strong>的函数？</p><p>它是指，一种函数是可重入（reentrant）的，也就是说，<strong>它访问的所有变量（包括指针的指向）都在自己的栈帧上</strong>。这样的函数在多线程、进程信号 handle 的时候，一定不会出现共享内存访问冲突，啥时候运行都不会改变语义。</p><p>事实上，POSIX 标准中保证了以下几种（共 117 种）函数一定是异步线程安全的：</p><p><code>_exit</code>（和 <code>exit</code> 不一样！它是系统调用接口，<code>exit</code> 是 C library 包装的系统级函数）、<code>write</code>、<code>wait</code>、<code>waitpid</code>、<code>sleep</code>、<code>kill</code>、……</p><p><strong>但不幸的是</strong>：</p><p><code>printf</code>、<code>sprintf</code>、<code>malloc</code>、<code>exit</code> 这些<strong>涉及 I/O 访问的、改变进程状态的系统调用或系统级函数</strong>大多都不是异步信号安全的，请谨慎在 signal handlers 里添加！</p><p>为什么它们不安全？因为它们会使用<strong>锁</strong>来对 I/O 设备或者变量进行读写，在 “多线程” 一章你会明白，这样很容易导致经典的死锁。</p><p><strong>所以……你一般没法在 signal handlers 里面打印输出内容……</strong>除非你能设计出一个能够对 signal handler 安全的 I/O 库。</p></blockquote></li><li><p>每次进入、退出 signal handlers 时<strong>应该保存、恢复 <code>errno</code> 变量，有助于系统错误追踪</strong>；</p><blockquote><p>因为在 signal handlers 被中断后，<strong>其他的 signal handlers 可能会更改掉 <code>errno</code></strong>；</p></blockquote></li><li><p><strong>在读写共享 / 全局变量时，请阻塞所有其他信号！！！</strong>这步操作保证当前 Signal Handler 不会被同进程的其他 signal handler 打断，<strong>相当于在多线程程序中加入读写锁</strong>；</p></li><li><p>如果你的 signal handlers 要用到一个全局变量，<strong>请将它声明为 <code>volatile</code></strong>。这一步也是在多线程编程中常见的。</p><blockquote><p>我们复习一下 C 中的关键字 <code>volatile</code>，这个关键字可以：<strong>阻止编译器优化由该关键字修饰的变量</strong>，即始终不将它放入寄存器中，<strong>每次读取都从内存中进行</strong>。这样做的好处是，多线程程序中的 <code>volatile</code> 变量不会发生值修改不同步的情况。</p><p>我们考虑以下情况：如果一个 signal handler 是修改某全局变量 <code>flag</code> 然后返回；该进程程序主体会定时检查这个 <code>flag</code>，做出相应动作。</p><p>如果我们在声明 <code>flag</code> 的时候，不加这个关键字，那么很有可能 <code>flag</code> 的值会被编译器解释成直接放到寄存器中，然后仅仅修改寄存器中的值。这样<strong>主程序可能永远也收不到 signal handler 更改的 <code>flag</code></strong>。</p></blockquote></li><li><p>如果你的全局变量是 <strong>仅读写的简单类型</strong>（数组、标准库中的容器是聚合类型，不是简单类型），除了加上 <code>volatile</code>，还建议使用 <code>sig_atomic_t</code> 类型。<strong>这就相当于多线程编程中的原子操作（<code>atomic&lt;&gt;</code>）</strong>；</p></li><li><p>对于一些慢系统调用，如果希望提升程序健壮性，应该在执行完检查是否 <code>errno == EINTR</code>，查看中途慢系统调用是否会被 Process Context Switch 阻断产生偶然错误；</p></li></ol><p>那么一个超级有难度的考题就来了——<strong>判断给定程序的异步信号安全性</strong>。来看下面一个程序：</p><p>这个 <code>fork14()</code> 想将自己创建的所有子进程通过信号的方式回收。这样做对吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ccount = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">child_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = wait(<span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">    ccount--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Handler reaped child &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>((<span class="type">long</span>)pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; \n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fork14</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid[N];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ccount = N;</span><br><span class="line">    signal(SIGCHLD, child_handler);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid[i] = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* Child exits */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ccount &gt; <span class="number">0</span>) <span class="comment">/* Parent spins */</span></span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很遗憾，这样写可以说没有一点异步信号安全性。能够成功回收应该是小概率事件。</p><p>我们从简入繁地分析一下：</p><ul><li>上面的信号处理程序没有保存和恢复 <code>errno</code>，这样会造成不必要的错误追踪的麻烦；</li><li>很显然，<code>printf</code> 不是信号安全的，极其容易发生死锁。要么不用，要么换成异步信号安全的函数；</li><li><code>ccount</code> 变量没有添加 <code>volatile</code> 关键字，可能被编译器优化，甚至在 <code>child_handler</code> 减少了 <code>ccount</code> 后，<code>main</code> 都无法感知；</li><li>最严重的一个问题是，<strong>任何时候，都不应该用收到信号的次数来作为真正发送信号的次数</strong>。因为前面介绍过信号的发送和接收的过程：从信号发送给进程，到进程真正接收，中间至少间隔 2 次 Process Context Switch。在此期间，<strong>由于没有队列数据结构，所有重复的相同信号都会被覆盖成一次信号</strong>。此外，在进程处理该信号的同时，还有隐式阻塞的问题，也会产生相同信号覆盖的情况。</li></ul><p>现在我们来改正。当我们收到一个 <code>SIGCHILD</code> 信号时，应该假设有多个子进程都结束了（因为无法计数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">child_handler2</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="type">int</span> oldErrno = errno;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">while</span> ((pid = wait(<span class="literal">NULL</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ccount--;    <span class="comment">/* 这里改成了回收子进程数，而不是依靠信号数来直接计数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)    <span class="comment">/* 说明上一个 wait 还没等完 */</span></span><br><span class="line">        sio_error(<span class="string">&quot;wait error&quot;</span>);    <span class="comment">/* 安全 I/O 库 */</span></span><br><span class="line">    errno = oldErrno;    <span class="comment">/* 用完 errno 后恢复它 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一个更难的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123; <span class="comment">/* Reap child */</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">        deletejob(pid); <span class="comment">/* Delete the child from the job list */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span> &amp;&amp; errno != ECHILD)</span><br><span class="line">        sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 5 */</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* Initialize the job list (a queue) */</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></span><br><span class="line">            execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); <span class="comment">/* Parent */</span></span><br><span class="line">        addjob(pid); <span class="comment">/* Add the child to the job list */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里的错误很难发现。在我们很早以前说 <code>fork</code> 的时候就讲过，<strong>不能保证父子进程的运行的时间顺序</strong>。这里可能会发生一个问题：<strong>在父进程 <code>addjob</code> 之前，<code>execve</code> 的子进程可能已经结束</strong>。这就意味着，父进程将一个已经结束的 job 加入 job list 中，这样任务队列永远不会为空。</p><p>如果要想 debug 找出，难点在于，你很难弄清楚各个父子进程间的 interleaving 的执行关系。所以在写信号的时候，一不留神就可能写出一个很恶心的 bug，还找不出来。</p><p>改正方法是，<strong>我们没法控制子进程和父进程执行的顺序，但我们可以控制 signal handler 执行的时机</strong>。我们在创建子进程前，阻塞所有信号（<strong>为什么？</strong>）。 在子进程中，在任务开始前，解除阻塞（<strong>又是为什么？</strong>）。</p><p>在创建子进程前阻塞所有信号，是为了<strong>让父进程在将任务添加到任务列表后，再考虑信号接收问题，防止 signal handler 在父进程还没加入任务列表时就被触发</strong>；</p><p>在创建子进程后，子进程开始后、<code>execve</code> 前解除阻塞，是因为要让 <code>SIGCHILD</code> 信号放出去，否则切换执行程序后就没有机会了。</p><p>于是改正后的程序长这样（<code>handler</code> 没有问题）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 5 */</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">    signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* Initialize the job list*/</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child process */</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">            execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>); <span class="comment">/* Parent process */</span></span><br><span class="line">        addjob(pid); <span class="comment">/* Add the child to the job list */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了这个方面的知识，我们可以明白一件事，我们在写一个这样的前后台程序的时候，如果不放心，可以用 <strong>进程图</strong> 模拟一下，确认自己的程序在各种极限情况下都能正常工作。</p><p>还有一个问题。在 shell lab 中，其实是不允许在 <code>main</code> 中写 <code>wait</code> 的，因为普通的 shell 程序都会将前台子进程的控制也交给信号，这样可以将前后台的处理方式大致统一。那么，<strong>怎么设计主程序能够显式的等待信号</strong>呢？别看这个好像很好办，实际要考虑的东西多得惊人。例如下面的一个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchild_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* Main is waiting for nonzero pid */</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">/* Do something */</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 10 */</span></span><br><span class="line">    signal(SIGCHLD, sigchild_handler);</span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="comment">/* Child: do somthing... */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">        <span class="comment">/* Wait for SIGCHLD to be received (wasteful!) */</span></span><br><span class="line">        <span class="keyword">while</span>(!pid)</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">/* Do some work after receiving SIGCHLD */</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能够写出上面的程序，那么前面的内容你都已经掌握了。这是个正确的程序，但是美中不足的是，父进程在等待子进程的时候，使用 <code>while (!pid);</code>，这样的做法比较低效，大部分 CPU 资源都浪费在无意义的 <code>while</code> 循环中了。</p><p>那么这个时候有同学可能会说，这简单，我可以在 <code>while(!pid)</code> 循环中加入一个 <code>pause</code> 系统调用，这样有 <code>SIGCHILD</code> 或者 <code>SIGINT</code> 触发后，程序可以自动从 <code>pause</code> 中退出，然后判断一遍 <code>pid</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!pid) pause();</span><br></pre></td></tr></table></figure><p>很可惜，这样<strong>可能会造成死锁</strong>。我们不妨画一个进程图，发现如果子进程向父进程发送信号，而且 Process Context Switch 的位置位于 <code>while (!pid)</code> 和 <code>pause()</code> 之间，那么，程序会先接收并处理 <code>SIGCHILD</code> / <code>SIGINT</code> 然后进入 <code>pause</code>。想象一下，如果这正好是最后一个给父进程发信号的进程呢？那么父进程会永远 stopped 在 <code>pause</code> 中。</p><p>同学还想了，那我换成 <code>sleep(1)</code> 不就不会死锁了吗？行是行，但是每隔一秒才检查一次子进程会严重拖慢程序运行速度。而设置为其他的固定时间，要么太慢（速度问题），要么太快（和没有 <code>sleep</code> 的效率一样低下）。</p><p>那么我们可不可以不那么快地恢复对 <code>SIGCHILD</code> 的响应（第 25 行）？让 “恢复 <code>SIGCHILD</code> 响应” 和 “<code>pause</code> 执行” 成为一对原子操作。那么答案就是新的系统调用：<strong><code>sigsuspend</code></strong>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure><p>它等价于以下 3 条指令的 <strong>整体原子操作</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>这样，我们只需要在阻塞 <code>SIGCHILD</code> 的时候，在 <code>while</code> 循环中调用 <code>sigsuspend(&amp;prev)</code>，这样  “取消 <code>SIGCHILD</code> 阻塞” 的行为 和 “<code>pause()</code> 执行” 的行为就原子化了，无需担心中间的死锁问题。这样如果有信号，并且交由 signal handlers 处理后，重新开始对 <code>SIGCHILD</code> 的阻塞，并检查 <code>pid</code>，完美实现要求。于是改进代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchild_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* Main is waiting for nonzero pid */</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">/* Do something */</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    <span class="type">int</span> n = N; <span class="comment">/* N = 10 */</span></span><br><span class="line">    signal(SIGCHLD, sigchild_handler);</span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="comment">/* Child: do somthing... */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Wait for SIGCHLD to be received */</span></span><br><span class="line">        <span class="comment">/* SIGCHILD is still blocked */</span></span><br><span class="line">        <span class="keyword">while</span>(!pid)</span><br><span class="line">            sigsuspend(&amp;prev);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Unblock SIGCHLD (optional) */</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* Do some work after receiving SIGCHLD */</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-5-7-Summary-of-Signals"><a href="#13-5-7-Summary-of-Signals" class="headerlink" title="13.5.7 Summary of Signals"></a>13.5.7 Summary of Signals</h3><p>在讨论信号有关概念之前，我们先认识了 Linux 中的 “进程树” 这种进程层次结构。我们了解到，Linux 一号进程是 <code>init</code> 进程，它是所有进程的父进程。<code>init</code> 进程则会启动两类进程，一种是 <code>Daemon</code> 守护进程，另一种是 <code>Login Shell</code> 命令行。</p><p>我们利用之前对于进程控制的知识尝试写了一个小的 Demo，却发现对于运行在后台的子进程，我们没有办法 handle 它们。为了解决这个问题，我们引入了 Linux 系统中的信号的概念。</p><p>信号是一个小整型，由 OS Kernel 发出，用来通知进程事件发生、要求处理的一种高级 ECF 机制。</p><p>信号的发送和接收的非同时性决定了信号必须在 OS Kernel 中以一种数据结构存储起来，以供目标进程对信号的接收。这种数据结构非常朴素，只是一个 Pending bit vector 和一个 Blocked bit vector，这样的存储方式注定了 <strong>信号在接收过程中可能被覆盖</strong>，因此接收信号的次数不能代表信号发送的次数；</p><p>信号机制运作的流程看起来很简单：</p><ol><li><p>某一时刻，位于某个进程的 OS Kernel 向 Process A 发送一个信号，于是改变了 Process A 的 Pending bit vector；</p></li><li><p>当某次 Process Context Switch 即将切换到 Process A 前，OS Kernel 检查 <code>pnb = pending &amp; ~blocking</code> 的情况；发现有信号，那么对每个信号都进行处理：进入对应的 signal handler 并重置该位 pending bit vector；</p><blockquote><p>由于 signal handler 位于用户态，共享了原程序的一切内存，因此 signal handler 和 原程序在 Logical Control Flow 上成为一对共享资源的<strong>并行流</strong>，这个情况与多线程等效，但<strong>给信号处理和数据访问带来了极大的不安全性</strong>。</p></blockquote></li><li><p>signal handler 执行中，由于是用户态代码，所以仍然可能会出现 Process Context Switch，因此免不了有 Nested Signals Handlers 的情况。不过，一般的 OS Kernel 会帮助我们将正在处理的相同信号阻塞起来（<strong>隐式阻塞</strong>），防止多次调用相同的 signal handler；</p></li><li><p>在 signal handlers 调用完成后，控制流先回到 OS Kernel 恢复 $I_{next}$ 等必需数据然后继续原程序 $I_{next}$ 执行。</p></li></ol><p>只是，别小看这个 <strong>同进程并行流的不安全性</strong>，如果在书写 signal handlers 时处理不当，那么可能造成相当大的危害。</p><p>我们从处理多线程程序安全性的同样思路出发，提出了以下几点避免<strong>异步信号冲突</strong>的解决方案：</p><ol><li>signal handlers 尽量保持简洁，使用 <strong>异步信号安全</strong> 的函数；</li><li>每次进入、退出 signal handler 时要及时保存、恢复 <code>errno</code>，因为 signal handler 内部可能有系统调用错误，为了防止系统错误难以追踪，我们最好这么做；</li><li>在同时被原程序、Signal Handler 使用的共享变量前应该声明 <code>volatile</code> 关键字，对于仅读写的简单类型最好使用 <code>sig_atomic_t</code> 类型；</li><li>在原程序、Signal Handler 操作共享变量时，应该阻塞其他所有信号，防止同进程的 interleaving 造成共享资源访问冲突；</li><li>不以信号接收次数来计信号发送次数；</li><li>对于含有 <code>fork</code> + 信号的程序设计，如果拿不准，建议画进程图，因为你不能假设父子进程的先后顺序，及时进行信号阻塞。这通常是造成共享资源访问冲突的常见点；</li><li>最后，对于显式等待信号的问题，我们可以使用 <code>sigsuspend</code> 系统调用，保证 <strong>取消阻塞和暂停等待两步操作的原子性</strong>。</li></ol><p>此外，我们还认识了进程组，一种关联多个进程，可以同时向进程组中所有进程发送信号的机制。</p><p>最后，列举一下我们在这一节中学习到了哪些系统调用（包括系统级函数）：<code>setpgrp</code>、<code>setpgid</code>、<code>getpgrp</code>、<code>getpgid</code>、<code>signal</code>、<code>sigprocmask</code>、<code>sigemptyset</code>、<code>sigfillset</code>、<code>sigaddset</code>、<code>sigdelset</code>、<code>sigsuspend</code>；</p><h2 id="13-6-Non-local-Jump"><a href="#13-6-Non-local-Jump" class="headerlink" title="13.6 Non-local Jump"></a>13.6 Non-local Jump</h2><blockquote><p>Powerful (but dangerous) user-level mechanism for transferring control to an arbitrary location.</p></blockquote><p>略</p><h1 id="Chapter-14-System-Level-I-O"><a href="#Chapter-14-System-Level-I-O" class="headerlink" title="Chapter 14 System Level I/O"></a>Chapter 14 System Level I/O</h1><p>本章将讨论操作系统较为底层的 I/O，在 Unix 和其他类型的操作系统上一样支持。</p><h2 id="14-1-Unix-I-O-Overview"><a href="#14-1-Unix-I-O-Overview" class="headerlink" title="14.1 Unix I/O Overview"></a>14.1 Unix I/O Overview</h2><p>我们先讨论 Unix 上的 I/O 的原因是，比起其他的操作系统，Unix 中的 I/O 更加简单并且一致。我们都知道在 Unix 类系统上，<strong>一切皆文件</strong>，而这些文件本质上上一个 m bytes 的<strong>字节序列（a sequence of bytes）</strong>，<strong>不去区分文件的类型</strong>，所以 Unix 操作系统实际上基本不了解文件内部的详细结构。它将文件看作存放在磁盘或外部存储介质上的某段数据，并且提供打开、写入、关闭等标准操作。</p><p>正因如此，即使是一些 I/O Device，甚至是操作系统内核也能抽象表示为具体的文件。</p><blockquote><p><code>/dev/sdaN</code>: Unix 的 N 号磁盘分区；</p><p><code>/dev/ttyN</code>：Unix 的 N 号终端（为何叫 TTY？因为早期人们多使用 “电传打字机（teletype）” 用于描述打字机与计算机的接口）；</p><p><code>/boot/vmlinuz-xxx-generic</code>：Unix 的内核镜像文件；</p><p><code>/proc</code>：Unix 的内核数据结构；</p><p><code>/var/run/*.sock</code>、<code>/run/*.sock</code>、<code>/dev/shm/*.sock</code>：Unix 的网络套接字文件；</p><p>补充：什么是套接字（socket）？</p><p>在网络一章会深入讨论。简单来说，就是在互联网规范中，当机器通过互联网通信时，消息是一段通过写入套接字这个数据结构来发送的，另一端通过读取套接字的内容来接收的。</p></blockquote><p>这样的简洁明了的抽象（elegant mapping of files to devices）就允许 Unix 类操作系统内核以一套简单的接口完成对文件和设备的访问。<strong>这套简单、核心的接口被成为 Unix I/O</strong>：</p><ul><li><p>打开、关闭文件：<code>open()</code>、<code>close()</code>；</p></li><li><p>读写文件：<code>read()</code>、<code>write()</code>；</p></li><li><p>当前文件位置（注意，<strong>不是当前文件路径</strong>：是 current file position，而不是 current file path）；</p><ul><li><p>作用：indicates next offset into file to read or write（<strong>提示下一次向文件中写或读的字节偏移量，即下次从哪里读写</strong>）；</p></li><li><p>接口：<code>lseek()</code>，改变当前文件指针的指向；</p></li><li><p>特征：<strong>只有某些文件有这个接口</strong>。因为对那些文件而言，没法移动、备份和恢复先前的已读入的数据，也无法提前接收未写入的数据。</p><blockquote><p>例如 socket 文件就是没有这种接口的，因为它无法在时间上进行跳转，只能在数据包进入时对其读写；</p></blockquote></li></ul></li></ul><p>由于这些文件本质上还是不同的具体事物，在客观上有内在差别（就像一些类都继承于一个公共类，但它们终究需要实现不同功能）。这些文件属性上的差别则可以抽象为<strong>文件类型</strong>。</p><p>Unix 中的文件类型有以下几种：</p><ul><li>Regular file：普通文件（存储于磁盘驱动器上）；</li><li>Directory：一组特定文件的索引文件，其中的条目描述了其他文件的位置和属性；</li><li>Socket：与另一台机器上的一个进程沟通的文件；</li><li>Named pipes（<strong>FIFOs</strong>，先入先出型数据结构）：管道流文件。Unix 上一些程序的输出，同时也是另外一些文件的输入；</li><li>Symbolic links：符号链接。Unix 上又称软链接（与硬链接相对）；</li><li>Character and block devices：字符设备与块设备。其抽象在操作系统的设备访问层，其名称与实际物理设备特性无必然联系。<ul><li>操作系统能够<strong>随机访问固定大小数据块（chunks）</strong>的设备称为块设备（例如磁盘、软盘、CD、flash memory 等）；</li><li>操作系统只能<strong>按照字符流的方式有序访问</strong>的设备称为字符设备（例如串口、键盘等）；</li></ul></li></ul><p>本章着重讨论前三种文件，因为它们比较常见。</p><h2 id="14-2-Unix’s-Files"><a href="#14-2-Unix’s-Files" class="headerlink" title="14.2 Unix’s Files"></a>14.2 Unix’s Files</h2><h3 id="14-2-1-Regular-Files"><a href="#14-2-1-Regular-Files" class="headerlink" title="14.2.1 Regular Files"></a>14.2.1 Regular Files</h3><p>普通文件可以包含任何类型的数据。一般情况下，操作系统并不会试图分析文件内部的细节，因此操作系统内核<strong>并不知道</strong>文本文件（plain text）和二进制文件（binary）之间的差别。</p><p>注意，区分文件内容是文本还是二进制数据通常发生在应用程序层级（更高级别）。</p><blockquote><p>文本文件和二进制文件的差别：<strong>仅含有代表 ASCII / Unicode 字符的数据的文件被称为文本文件，否则被称为二进制文件</strong>；</p><p>二进制文件可以是：actual object file、图片音视频文件等等，它们包含<strong>直接以某种形式编码的字节序列</strong>；</p></blockquote><p>文本文件有个重要特征，就是它们可以看作<strong>由一系列文本行（text lines）构成</strong>的文件。通常情况下，文本行是一个以 <strong>newline 字符</strong>结尾的字符（char）序列。</p><blockquote><p>事实上，newline 字符在不同操作系统平台上定义不同，例如 Unix 上将 <code>0xa</code>（<code>\n</code>）代表的字符 <strong>line feed（LF）character</strong> 作为换行符，而 Windows 则约定以两个字符 <code>0xd 0xa</code>（<code>\r\n</code>）代表的字符 Carriage Return &amp;&amp; Line Feed（CRLF）character 作为换行符。</p><p>二者的区别与历史中的 typewriter（打字机）有关，因为换行（垂直运动，即 Line Feed）和回车（水平复位运动，即 Carriage Return）是打字机作为机械设备在换到下一行必须要做的两个运动，Windows 保留了这层含义。</p></blockquote><h3 id="14-2-2-Directories"><a href="#14-2-2-Directories" class="headerlink" title="14.2.2 Directories"></a>14.2.2 Directories</h3><p>在 Unix 操作系统（或者说操作系统中的文件系统）中，每个目录文件包含了一个 “链接” 数组，每个 “链接” 建立了一个从文件名到文件的映射关系。</p><p>每一个目录文件包含<strong>至少两个 entries</strong>：<code>.</code>（a link to itself，链接到自身）和 <code>..</code>（a link to the parent directory in the directory hierarchy，链接到目录层次中的上层目录）；</p><p>Unix 的文件系统层次结构与 Linux 相近，因此 Unix 文件系统层次结构就不再赘述。</p><p>而 <strong>当前工作目录（current working directory，<code>cwd</code>）</strong>是由 OS Kernel 维护的数据，每个进程下的不一定一致。可以通过使用 <code>cd</code> 改变当前进程的该数据；</p><p>在 Unix 和其他多数操作系统中，<strong>Pathnames（路径名）</strong>是文件层次结构中导向某个特定文件的导航方式，可以由目录文件的链接名称组成。</p><h2 id="14-3-Basic-Operations"><a href="#14-3-Basic-Operations" class="headerlink" title="14.3 Basic Operations"></a>14.3 Basic Operations</h2><p>本节的系统级函数和宏大多在 <code>&lt;fcntl.h&gt;</code>（file control）中；</p><h3 id="14-3-1-Opening-Files"><a href="#14-3-1-Opening-Files" class="headerlink" title="14.3.1 Opening Files"></a>14.3.1 Opening Files</h3><p>针对各类文件的基本操作方式之一是打开文件。它的实质是<strong>提醒 OS Kernel 已经做好访问该文件的一切准备</strong>。对此 Unix 有一个系统级函数 <code>open</code>，常用声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>第一参数可以是绝对路径，也可以是相对路径；</p></li><li><p>第二参数是 2 的某次幂的标志量（flag），允许按位运算。说明文件的打开方式（结合一些头文件，可以得到相关宏定义，例如 <code>O_RDONLY</code> 只读等）；</p></li><li><p>第三参数是文件权限位，即读取 / 创建文件的权限，可取的参数见官方文档：</p><p><img src="imgs/perm_modes.png" height="500px"></p></li><li><p>返回值体现了一个非常重要的思想：<strong>文件描述符</strong>。如果文件打开错误，则返回 <strong>-1</strong>（I/O 操作的失败情况比普通情况多很多，一定在实际使用描述符前检查是否成功打开）；</p><blockquote><p>什么是文件描述符（file descriptor）？</p><p>文件标识符是<strong>用来标识当前程序正在操作的某个已打开文件的小整型（这个小整型只有 0 ~ 1024 的范围）</strong>。</p><p>它们是按照打开顺序依此编号（从运行程序开始编号），所以大部分机器有最大打开文件数量的限制。这意味着打开了超过限制数量的文件将会造成文件资源泄漏。其中机器各方面的限制可以由以下指令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a</span><br></pre></td></tr></table></figure><p>另外一个值得注意的点是，在<strong>每个进程一创建的时候就会有 3 个已创建的文件：0（<code>stdin</code>）、1（<code>stdout</code>）、2（<code>stderr</code>），它们都是由 Unix Shell 打开并创建的</strong>（请回忆前一章的进程树并考虑为什么）。</p><p>其他具体内容将在 <strong>17.5.2</strong> 中讨论。</p></blockquote></li></ul><p>注：本章的系统级函数都非常底层，有些函数直接使用整型文件描述符。为了使用规范，如果你想用 <code>stdin/stdout/stderr</code> 这类文件时，请不要直接使用 <code>0/1/2</code>，更建议使用宏 <code>STDIN_FILENO/STDOUT_FILENO/STDERR_FILENO</code>；</p><h3 id="14-3-2-Closing-Files"><a href="#14-3-2-Closing-Files" class="headerlink" title="14.3.2 Closing Files"></a>14.3.2 Closing Files</h3><p>关闭文件的系统级函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> file_descriptor)</span>;</span><br></pre></td></tr></table></figure><p>你可能会好奇，为什么这个也要有返回值，难道关闭一个文件也会报错？答案是肯定的。</p><p>在多线程编程中（就像之前提到的，它们会共享内存和数据结构），可能会出现关闭一个已经被关闭的文件的情况，这种情况也会发生问题。</p><h3 id="14-3-3-Reading-Files-amp-Writing-Files"><a href="#14-3-3-Reading-Files-amp-Writing-Files" class="headerlink" title="14.3.3 Reading Files &amp; Writing Files"></a>14.3.3 Reading Files &amp; Writing Files</h3><p>Unix 系统级函数提供了一种块读取和块写入的方式，即从当前文件指针位置开始，向后指定长度的空间的数据读入缓冲区 / 向文件写缓冲区内容，并且更新文件指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> file_descriptor, <span class="type">void</span> *buffer, <span class="type">size_t</span> buf_size)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> file_descriptor, <span class="type">void</span> *buffer, <span class="type">size_t</span> buf_size)</span>;</span><br></pre></td></tr></table></figure><p>值得注意的是，如果正确运行，那么 <code>read</code> / <code>write</code> 的返回值是<strong>实际读取 / 写入的字节数</strong>（因为从当前文件指针到最后不一定有 <code>buf_size</code> 大小的数据，这种情况称之为 <strong>short read / short write</strong>）；错误则返回 <strong>-1</strong>；而（对于 <code>read</code> 而言）如果返回 0，说明已经到达 <code>EOF</code>；</p><blockquote><p>这里介绍一个之前提到的非常有名的工具 <code>strace</code>；这个工具的功能非常强大，不过现在我们先介绍一些简单的使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace &lt;prog&gt;</span><br></pre></td></tr></table></figure><p>以上指令在运行指定程序的同时，会跟踪并向  <code>stdout</code> 打印程序使用到的<strong>所有系统调用（system call）情况</strong>；</p><p>有时候看到很乱的情况，可能是终端上 <code>stderr</code> 和 <code>stdout</code> 交织输出的原因。</p><p>如果加上参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=&lt;syscall_name[,...]&gt; &lt;prog&gt;</span><br></pre></td></tr></table></figure><p>那么就仅仅追踪指定名称的系统调用情况。</p></blockquote><p>那么，什么时候会出现 short read / short write？</p><ul><li>读文件时遇到 EOF；</li><li>从<strong>终端</strong>读一个文本行；</li><li>读写网络套接字；</li><li>……</li></ul><p>其实，short read / short write 一直是应用程序层面较为棘手的问题，所以我们一般看到很多涉及 I/O 的库几乎都将这个低层级的 I/O 接口封装起来。</p><blockquote><p>为什么棘手？</p><p>其实，short read / write 在普通程序中的问题还影响不大，因为大多数是向磁盘中写文件，而向磁盘写不会出现 EOF，因此没有 short write；从磁盘读发生 short read 只要跳出读循环就行，影响也不大）。</p><p>但是在网络套接字的读写方面影响很大。考虑一个场景，你要用 socket 发一个网络包，但是写不下的值还要判断，而且还有可能因为其他偶然原因触发 <code>EINTR</code>，并且在循环中重新拿出来再发一次。</p><p>不仅如此，网络向 socket 中发送可能是一部分一部分收到的，因此可能<u>短读后还能继续读</u>！</p></blockquote><h2 id="14-4-The-RIO-Package"><a href="#14-4-The-RIO-Package" class="headerlink" title="14.4 The RIO Package"></a>14.4 The RIO Package</h2><p>为了解决 short read / short write 对应用程序编程开发带来的麻烦，有一种对 I/O 接口的封装方式是 CMU 教授开发的 RIO Package. 这个包提供了对于底层的 Unix I/O 的包装，能够使得程序在处理 I/O 方面有较强的健壮性（robust）和较好的效率，尤其是后面章节要讨论的、受 short read / write 影响较大的网络编程。</p><p>RIO Package 提供了 2 种不同级别的 I/O 文件接口。</p><p>其中，较低级别的 I/O 接口只是对上面说到的低级 Unix I/O 进行了简单的封装，以应对 short read / write 的情况；函数 <code>rio_readn</code>  和 <code>rio_writen</code> 就是这样较低级别的封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rio_writen 永远不会 short count. */</span></span><br><span class="line"><span class="comment">/* rio_readn 当正常执行时，返回 num 代表实际读取的字节数（和 Unix I/O 不同，这是产生 short count 的唯一情况）；遇到 EOF 返回 0；*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二者遇到错误都返回 -1，errno 由系统级函数 read/write 设置 */</span></span><br></pre></td></tr></table></figure><p>这两个函数属于对二进制数据的非缓冲式的读入和输出（unbuffered input &amp; output of binary data），在未读够 / 未写够指定字节数的数据之前不会返回。对于 <code>rio_readn</code>，如果是处理具有很多数据的网络套接字，那么在当前套接字读完、总体数据未读完的情况下<strong>挂起并等待</strong>；如果是读到了与给定字节数不同的时候出现 EOF，那么会返回错误；</p><p>对于 <code>rio_writen</code>，<strong>对于使用者的情况会比 <code>rio_readn</code> 简单些，所以也只需要包装到这个层次即可</strong>，因为使用者只需担心网络问题，这个函数本身会在要求的字节数内通过循环发送套接字（因为一个 socket 规范只有 1500 bytes 左右，具体大小取决于它位于哪个协议层）；</p><p>另一类是带缓冲区的 I/O 接口（<code>rio_readinitb</code>、<code>rio_readlineb</code>、<code>rio_readnb</code>），比前一类封装更高级一些，也是很多库对于 Unix I/O 常见的包装形式。它们的做法是在用户代码空间创建一个小型缓冲区（mini-buffer），用来存放已读入但未被应用程序使用的 bytes，或者为程序创建一块空间以便未来输出到文件或网络中；</p><blockquote><p>这种<strong>缓冲区的思想</strong>也存在与计算机的相当多的方面。</p></blockquote><p>带缓冲区的 RIO 有两种，一种是基于文本的，另一种是基于字节（二进制数据）的。如下代码注释，可见，在网络套接字的文本行阅读方面，<code>rio_readlineb</code> 非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read a text line of up to `maxlen` bytes from file `fd` and store the line in `usrbuf`.</span></span><br><span class="line"><span class="comment"> * Stopping Conditions:</span></span><br><span class="line"><span class="comment"> * - `maxlen` bytes read;</span></span><br><span class="line"><span class="comment"> * - EOF encountered;</span></span><br><span class="line"><span class="comment"> * - Newline (`\n`) encountered</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read up to `n` bytes from file `fd` and store them in `usrbuf`.</span></span><br><span class="line"><span class="comment"> * Stopping Conditions:</span></span><br><span class="line"><span class="comment"> * - `maxlen` bytes read;</span></span><br><span class="line"><span class="comment"> * - EOF encountered;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当正常执行时，返回 num 代表实际读取的字节数（和 Unix I/O 不同，这是产生 short count 的唯一情况）；*/</span></span><br><span class="line"><span class="comment">/*遇到 EOF 返回 0；遇到错误返回 -1，errno 由系统级函数 read 设置 */</span></span><br></pre></td></tr></table></figure><p>这种 RIO 库的健壮性还在于，<code>rio_readlineb</code> 和 <code>rio_readnb</code> 允许对一个文件描述符进行交织运行（多线程中对一个文件描述符），但别和 <code>rio_readn</code> 连用；</p><p>至于含缓冲区的 RIO 的实现也不难，它的目标就是设计一个读取内容的缓冲地带，让重复的读取内容不至于每次访问 I/O 都使用系统调用；举个例子：</p><p><img src="imgs/rio_readnb.png" height="300px"></p><p>如上图，假设程序想要读取系统上的一个 Unix file，那么该文件从头至 current file position 就是我们想要的 buffered portion；在读取的时候，<code>rio_readnb/rio_readlineb</code> 会按 buffered portion 的大小在 user code space 中创建一个同等大小的缓冲区（上图 buffer），由 <code>rio_buf</code> 指针管理这片空间的起始地址，由 <code>rio_bufptr</code> 管理当前程序读到 buffer 的哪里；而 <code>rio_cnt</code> 则代表当前还有多少数据没有读入缓冲区；</p><p>因此，根据 <code>rio buffer</code> 的使用分析，我们发现维护 <code>rio_t</code> 的结构体应该是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;</span><br><span class="line">    <span class="type">int</span> rio_cnt;</span><br><span class="line">    <span class="type">char</span> *rio_bufptr;</span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE];</span><br><span class="line">&#125; <span class="type">rio_t</span>;</span><br></pre></td></tr></table></figure><p>更多的内容大家可以通过阅读 RIO Package 的源码获取，并且可以在此基础上包装属于自己的 routines；</p><h2 id="14-5-File-Metadata-Sharing-and-Redirection"><a href="#14-5-File-Metadata-Sharing-and-Redirection" class="headerlink" title="14.5 File Metadata, Sharing and Redirection"></a>14.5 File Metadata, Sharing and Redirection</h2><h3 id="14-5-1-Metadata"><a href="#14-5-1-Metadata" class="headerlink" title="14.5.1 Metadata"></a>14.5.1 Metadata</h3><p>几乎所有操作系统平台上，每个文件中都有一个非常重要的部分是文件元数据（file metadata）。所谓 metadata 就是文件中实际包含的数据的信息，例如<strong>应用层级的文件类型信息、文件权限信息（R/W/X）、文件所有权信息、创建/访问/修改时间……</strong></p><blockquote><p>什么？你说 Windows 上创建一个文本文件，然后把后缀名删了，好像就没有了？其实操作系统在创建文件、在显示到桌面之前就将文件元信息设置好了，不信你看看右击属性。</p></blockquote><p>在 Unix 系统中，这种 metadata 以一个结构体 <code>stat</code> 进行存储，这种结构体类型也是 C library 函数 <code>stat</code>、<code>fstat</code>（查看文件元数据的函数）的返回值类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Metadata returned by the stat and fstat functions */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>st_dev; <span class="comment">/* Device */</span></span><br><span class="line">    <span class="type">ino_t</span>st_ino; <span class="comment">/* inode */</span></span><br><span class="line">    <span class="type">mode_t</span>st_mode; <span class="comment">/* Protection and file type */</span></span><br><span class="line">    <span class="type">nlink_t</span>st_nlink; <span class="comment">/* Number of hard links */</span></span><br><span class="line">    <span class="type">uid_t</span>st_uid; <span class="comment">/* User ID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>st_gid; <span class="comment">/* Group ID of owner */</span></span><br><span class="line">    <span class="type">dev_t</span>st_rdev; <span class="comment">/* Device type (if inode device) */</span></span><br><span class="line">    <span class="type">off_t</span>st_size; <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blksize; <span class="comment">/* Blocksize for filesystem I/O */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blocks; <span class="comment">/* Number of blocks allocated */</span></span><br><span class="line">    <span class="type">time_t</span> st_atime; <span class="comment">/* Time of last access */</span></span><br><span class="line">    <span class="type">time_t</span> st_mtime; <span class="comment">/* Time of last modification */</span></span><br><span class="line">    <span class="type">time_t</span> st_ctime; <span class="comment">/* Time of last change */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *statbuf)</span>;    <span class="comment">/* `fd` should be a valid open file descriptor. */</span></span><br></pre></td></tr></table></figure><p>如何用这些数据？一般情况下，我们可以借助一些 C library 内置宏来检查数据的含义。这里不多赘述，以一个程序为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">char</span> *type, *readok;</span><br><span class="line">    </span><br><span class="line">    Stat(argv[<span class="number">1</span>], &amp;stat);</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(stat.st_mode))    <span class="comment">/* Determine file type. */</span></span><br><span class="line">        type = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(stat.st_mode))</span><br><span class="line">        type = <span class="string">&quot;directory&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> type = <span class="string">&quot;other&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (stat.st_mode &amp; S_IRUSER)    <span class="comment">/* Check read access. */</span></span><br><span class="line">        readok = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> readok = <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;type: %s, read: %s\n&quot;</span>, type, readok);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>知识补充：Unix 系统中的 man page 的正确使用方法。</p><p>我们都知道，Unix 中的 <code>man</code> 指令相当于一个帮助文档，通常情况下，<code>man &lt;fname&gt;</code> 会进入 <code>fname</code> 所添加的帮助文档的<strong>第一章</strong>中。你可以使用 <code>man &lt;chapterN&gt; &lt;fname&gt;</code> 来指定查看第几章的 <code>fname</code> 文档。</p><p>在 man 程序管理帮助文档的规范中，每章的内容有明确的使用范围：</p><p>man 的第一章通常介绍 <code>fname</code> 作为一个<strong>系统指令</strong>（编译为了一个二进制文件放在系统中）的使用方法，通常包含一些该命令的命令行技巧和参数；</p><p>man 的第二章通常介绍 <code>fname</code> 作为一个<strong>系统级函数/系统调用</strong>在源码中的使用方法，通常包含了一些该函数的 API 文档内容和声明；</p><p>有些 <code>fname</code> 既在 Unix 中包装成了二进制的程序供命令行使用，又在头文件和系统的链接库中存在，以供源码使用（例如 <code>kill</code>），所有会同时存在这两章。</p><p>man 还有更多的章节，一般到第 8 章，其中的含义可以自行搜寻。</p></blockquote><h3 id="14-5-2-File-Sharing-amp-File-Descriptor"><a href="#14-5-2-File-Sharing-amp-File-Descriptor" class="headerlink" title="14.5.2 File Sharing &amp; File Descriptor"></a>14.5.2 File Sharing &amp; File Descriptor</h3><p>之前我们用了很长时间的 “file descriptor” 这个名词，接下来将讨论一下所有的文件在程序中如何用 file descriptor 进行标识，或者说，背后的机制是怎样的。</p><blockquote><p>⚠ <strong>这里是考试的难点！！！光听老师讲、看这部分的信息，想把题目做对是不够的！需要自行研究习题和历年考题。</strong></p></blockquote><p>OS 内部很多内部数据结构都与具体执行中的进程有关，例如前面提到的页表、用户栈、OS Kernel 等等，它们都存放在这个进程对应的虚拟内存中。</p><p>文件描述符也不例外，<strong>每个进程都会在其虚拟内存中维护唯一一个描述符表（descriptor table）</strong>。</p><p>还有两种非常特殊的数据结构，一种是 <strong>文件表（open file table）</strong>，另一种是 <strong>虚拟结点表（v-node table）</strong>；<strong>它们被计算机中所有进程共享</strong>；</p><p>如图所示：</p><p><img src="imgs/fd.png"></p><p>很早之前我们就了解过，文件描述符为 0、1、2 的特殊含义，这里不再赘述。</p><p>我们需要注意以下几点：</p><ul><li><p>v-Node Table 就是 Unix files 的 <code>stat</code> 结构体的表，每个 v-Node Table 与物理存储器上的文件<strong>一一对应</strong>（双射），无论文件是否被打开；</p></li><li><p>Descriptor Table 各个 entry 的内容存放的是<strong>指向各个 Open File Table 的指针</strong>，也表示<strong>当前进程已打开但未关闭的文件</strong>。而描述符相当于是对 Descriptor Table 的<strong>索引</strong>；</p></li><li><p>Open File Tables 由 OS Kernel 维护。每个 Open File Table 的第一个字段即为指向 v-Node Table 的指针，与每个 v-Node Table 的关系<strong>必然是函数关系，但既不是单射也不是满射</strong>；</p><blockquote><p>即：</p><ol><li><p>对任意一个 Open File Table 而言，它必然指向一个唯一的 v-Node Table（即物理文件）；</p></li><li><p>存在两个 Open File Table 它们指向<strong>同一个物理文件（也就是同一个 v-Node Table）</strong>，但他们本身不一定完全相同，因为它们的字段 <strong><code>File pos</code> 是分别由各个打开进程维护的</strong>。</p><p><strong>这意味着程序调用了两次 <code>open</code>，但是参数是同一个 filename</strong>（再次强调：<strong>可能在不同的进程中，而且 <code>File pos</code> 不一定相同</strong>），如下图：</p></li></ol><p><img src="imgs/fd_same_open.png" height="300px"></p><ol><li><p>允许一个 v-Node Table 不被任何 Open File Table 指向。</p><p><strong>这意味着这个物理文件还没有被程序的任何进程打开过</strong>。</p></li></ol></blockquote></li><li><p>每个 Open File Table 的第二个字段是 <code>refcnt</code>（reference count，引用计数），这个字段表明这个 Open File Table 被描述符表中的多少个 entry 指向；</p><blockquote><p>为什么要有这项数据？</p><p>因为在程序中，可能出现多进程（尤其是 <code>fork()</code> 产生）共享文件资源的情况，这时 OS 需要追踪内存分配，如果程序结束时，OS 需要回收这些部分（引用次数为 0 时不会立即清除）。堆的内存管理也有这种机制，不过比这个复杂很多。</p></blockquote></li></ul><p>有个相当重要的点，回忆一下，之前讨论 <code>fork</code> 的时候提到，创建的子进程总是可以直接继承使用父进程的文件描述符，达到二者共享文件资源的目的。但是，之前说描述符表是由每个进程的 OS Kernel 单独维护的。</p><p>那么这样的情况下，父子进程共享的文件资源是如何实现的？如下图过程：</p><p><img src="imgs/file_sharing_before.png" height="300px"></p><p><img src="imgs/file_sharing_after.png" height="300px"></p><p>总结一下父子进程共享文件描述符的要点：</p><ul><li>子进程<strong>完全复制</strong>父进程的描述符表；</li><li>父进程描述符表中指向的所有文件表的引用计数各加 1；</li></ul><p>因此我们得知，<strong>父子进程共享的不是物理文件，而是 Open File Tables</strong>（共用了文件指针）；这意味着父子进程任意一方读写文件，二者的文件指针一起变化；</p><p>⚠ <strong>最重要的是，每个进程都必须显式调用 <code>close</code>（除了 0、1、2 号文件），才能最终使引用计数为 0，操作系统才能回收。</strong></p><h3 id="14-5-3-I-O-Redirection"><a href="#14-5-3-I-O-Redirection" class="headerlink" title="14.5.3 I/O Redirection"></a>14.5.3 I/O Redirection</h3><p>再思考一个问题，Unix Shell 是如何实现 I/O 管道流和重定向的功能的呢？实际上，这个功能的实现也与文件描述符表有关。我们以一个例子为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> &gt; foo.txt</span><br></pre></td></tr></table></figure><p>这个指令将 <code>ls</code> 命令输出的结果重定向到 <code>foo.txt</code> 文件中，实际在 shell 的源码中应该使用了一个特殊的系统级函数（再次提示，系统级函数是<strong>系统调用的封装</strong>）：<code>dup2</code>；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* More: */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;    <span class="comment">/* uses the lowest-numbered unused descriptor for the new descriptor. */</span></span><br></pre></td></tr></table></figure><ul><li>作用：<strong>先将描述符为 <code>newfd</code> 的文件关闭以释放资源，再将描述符为 <code>oldfd</code> 的 descriptor table entry 复制到指定描述符为 <code>newfd</code> 的 entry 中</strong>；<ul><li>⚠ 如果 <code>oldfd</code> 是无效的描述符（即 descriptor table 在该位置的 entry 不指向有效的 open file table），则 <code>dup2</code> 执行错误，<strong>这个时候 <code>newfd</code> 对应的资源不会关闭</strong>；</li><li>⚠ 如果 <code>oldfd</code> 是有效的描述符，但是 <code>newfd == oldfd</code>，<strong>那么 <code>dup2</code> 什么都不会做，直接返回 <code>newfd</code></strong>;</li></ul></li><li>返回值：如果正确执行，则返回更新后的 <code>newfd</code>；如果执行错误，则返回 <strong>-1</strong> 并且设置 <code>errno</code>；</li></ul><p>切记，这条指令相当危险，除非你是在设计与操作系统层级很近的应用程序（例如 shell），否则不用轻易使用它，因为它能轻易将你绕晕，不知道哪些文件还没有释放。</p><h3 id="14-5-4-Standard-I-O"><a href="#14-5-4-Standard-I-O" class="headerlink" title="14.5.4 Standard I/O"></a>14.5.4 Standard I/O</h3><p>这里的库是 C standard library 包装的一些更高层级的 I/O 接口，它和之前我们接触到的 Unix I/O、RIO 的关系如下：</p><p><img src="imgs/IO_interface.png"></p><p>这些标准 I/O 实际上是 C 的一部分。先归一归类，大家都比较熟悉了：</p><ul><li>Opening and closing files（<code>fopen</code>、<code>fclose</code>）；</li><li>Reading and writing files（<code>fread</code>、<code>fwrite</code>）；</li><li>Reading and writing text files（<code>fgets</code>、<code>fputs</code>）；</li><li>Formatted reading and writing（<code>fscanf</code>、<code>fprintf</code>）；</li></ul><p>不仅如此，你见到的很多 standard I/O 都带有 buffering，所以规避了很多低层级的操作。</p><p>那么 standard I/O 的 buffer 和 RIO 的 buffer 有什么不同呢？</p><p><strong>在功能上</strong>，standard I/O 对于终端文件（terminal）或普通文件的访问方面包装显然要远远优于 RIO；但是 standard I/O 没有考虑到一些网络套接字方面的细节和小问题，所以在<strong>网络套接字的读写方面</strong>用起来还是 RIO 更胜一筹。</p><p><strong>在 buffer 设计上</strong>，standard I/O buffer 有一套 <strong>flush 机制</strong>。</p><p>对于写的情况，standard I/O 的 buffer 仅当出现以下情况之一时，才将 buffer 整体写入 Unix file，这么做可以减少系统调用次数，提升程序性能：</p><ul><li>标准输出函数（<code>fprintf/sprintf/...</code>）的结尾含有 <code>\n</code> 换行（<strong>换行结尾</strong>）；</li><li>Standard I/O 内部的 buffer 已经写满（<strong>缓冲占满</strong>）；</li><li>执行标准输出函数的进程从 <code>main</code> 函数退出了（<strong>程序结束</strong>）；</li><li>程序显式地调用 <code>fflush(FILE*)</code> 刷新缓冲区（<strong>手动刷新</strong>）；</li></ul><p>而 RIO 设定了固定大小的 buffer，并根据用户输入的读取或写入的大小分次进行系统调用，二者各有利弊。</p><p>综上，RIO 比 standard I/O 更适宜用在网络套接字读写方面，而 standard I/O 则在其他大部分文件读写的情况下表现更加优秀。</p><h2 id="14-6-Summary-of-System-I-O"><a href="#14-6-Summary-of-System-I-O" class="headerlink" title="14.6 Summary of System I/O"></a>14.6 Summary of System I/O</h2><p>本章开始，我们介绍了 Unix File 的概念和常见类型。对于 Unix File 的基本操作，则被操作系统抽象成了 Unix I/O（有系统级函数、系统调用），这些操作非常底层，不过有优势也有劣势：</p><ul><li>Pros<ul><li>Unix I/O 是<strong>最通用、开销最小的 I/O 接口形式</strong>（其他所有 I/O 库都基于此）；</li><li>Unix I/O 提供了一系列访问文件 metadata 的函数（<code>stat</code>、<code>fstat</code>）；</li><li>⚠ <strong>重大优点：它们都是 异步信号安全 的，可以用在 signal handlers 中</strong>；</li></ul></li><li>Cons<ul><li>应对 short counts 的处理很麻烦（尤其是应对 <code>EINTR</code> 和网络传输时），容易出错；</li><li>想要按照文本行读取出一行也很麻烦，也易错；</li></ul></li></ul><p>Standard I/O 非常优秀，同样有它的优缺点：</p><ul><li>Pros<ul><li>使用特殊的 buffer 机制，减少了系统调用的访问次数；</li><li>自动解决 short counts 的异常问题；</li></ul></li><li>Cons<ul><li>不提供访问文件元信息的接口；</li><li>其中的函数几乎<strong>都不是</strong>异步信号安全的函数；</li><li>不适宜用在读写网络套接字上，很容易出错；</li></ul></li></ul><p>最后，根据各个 I/O 的封装特性和抽象层级，我们可以总结出这些 I/O 库的选择注意事项 和 推荐：</p><p><strong>⚠ 注意事项 ⚠</strong></p><ol><li><p><strong>在条件允许的情况下，尽可能使用抽象层级高的 I/O 库</strong>；</p><blockquote><p>这样可以避免一些诸如 <code>EINTR</code>（之前提到，这个系统错误码是因为运气不好，重新调用一次就能修复）等底层奇奇怪怪的信息或错误；</p></blockquote></li><li><p><strong>使用 I/O 库的接口前，一定弄清楚接口的具体作用和逻辑</strong>；</p><ul><li><p>例如<strong>读二进制文件不能用 识别文本信息 的接口</strong>（例如用 <code>rio_readlineb</code> 去读图片、用 <code>strlen/strcpy</code> 去操作 socket 数据）；</p><blockquote><p>因为大多数识别文本信息的接口，尤其是按行输入的，会识别文本中的换行符（<code>0xa</code> 或 <code>0xd 0xa</code>，即 <code>EOL</code>，end of line），并以此分割读入；</p><p>不仅如此，它们还会把 byte value 0 解释为文本结束（end of string），这样会导致读入操作提前结束。而 <code>0x0</code> 只不过是二进制数据中一个数据而已，只有字符串是以 0 结尾的。</p></blockquote></li></ul></li><li><p><strong>Standard I/O 和 RIO 不应该混合使用！因为二者内部维护的 buffer 不同，在运行中可能出现干扰和错误</strong>；</p></li></ol><p><strong>ℹ 使用建议 ℹ</strong></p><ol><li>当 I/O 操作的对象是 <strong>disk / terminal files</strong> 的时候，使用 Standard I/O 最佳；</li><li>当需要一些尽量底层的操作（例如写 signal handlers 时），或者极其需要程序性能的时候（少见），使用 raw I/O（Unix I/O）；</li><li>当 I/O 操作的对象是网络 socket 文件时，最好使用 RIO 来处理一些特殊的情况，例如 <code>EINTR</code> 和针对网络的 short counts 的处理；</li></ol><hr><p>补充知识：操作目录文件</p><p><strong>唯一推荐对 directory 的操作：打开、读取 entries</strong>；</p><p>看下面的这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *directory;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">de</span>;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">if</span> (!(directory = opendir(dir_name)))</span><br><span class="line">        error(<span class="string">&quot;Failed to open directory&quot;</span>);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != (de = readdir(directory))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found file: %s\n&quot;</span>, de-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    closedir(directory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> CSAPP </tag>
            
            <tag> ICS </tag>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt</title>
      <link href="//review/csapp-mm-cache/"/>
      <url>//review/csapp-mm-cache/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-10-The-Memory-Hierarchy"><a href="#Chapter-10-The-Memory-Hierarchy" class="headerlink" title="Chapter 10. The Memory Hierarchy"></a>Chapter 10. The Memory Hierarchy</h1><blockquote><p>本章将介绍系统的内存分层架构。</p></blockquote><p>之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。</p><p>正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。</p><h2 id="10-1-Storage-Technologies-amp-Trends"><a href="#10-1-Storage-Technologies-amp-Trends" class="headerlink" title="10.1 Storage Technologies &amp; Trends"></a>10.1 Storage Technologies &amp; Trends</h2><p>在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。</p><h3 id="10-1-1-Random-Access-Memory-RAM"><a href="#10-1-1-Random-Access-Memory-RAM" class="headerlink" title="10.1.1 Random-Access Memory (RAM)"></a>10.1.1 Random-Access Memory (RAM)</h3><p>当前大多数人所熟知的 “内存” 的一部分就是<strong>随机访问存储器（RAM）</strong>，它具有以下的特征：</p><ul><li><p>RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；</p></li><li><p>RAM 常常被打包放在 CPU 芯片中；</p></li><li><p>RAM 中每一个基本的存储单元被称为 <strong>单元胞</strong>（Cell），一个单元胞中存放 1 bit 数据；</p></li><li><p>很多个 RAM 芯片共同工作，组成了计算机的 <strong>主存</strong>（主存储器）。</p></li><li><p>RAM 分为 2 类，它们之间<strong>根据存储单元胞的实现方式来区分</strong>：</p><ul><li>SRAM（Static RAM），静态随机存储器；</li><li>DRAM（Dynamic RAM），动态随机存储器；</li></ul><table>    <tr>        <td></td>        <td>Trans. per bit</td>        <td>Access time</td>        <td>Needs refresh?</td>        <td>Needs EDC?</td>        <td>Cost</td>        <td>Applications</td>    </tr>    <tr>        <td>SRAM</td>        <td>4 or 6</td>        <td>1 ×</td>        <td>No</td>        <td>Maybe</td>        <td>100 ×</td>        <td>Cache Memories</td>    </tr>    <tr>        <td>DRAM</td>        <td>1</td>        <td>10 ×</td>        <td>Yes</td>        <td>Yes</td>        <td>1 ×</td>        <td>Main memories, frame buffers</td>    </tr></table><blockquote><p>注：<code>Trans. per bit</code> 表示每 bit 需要多少根晶体管，<code>EDC</code> 指电子数据捕获。</p><p>从上面这张表可以得知，SRAM 比 DRAM 成本高很多，因为 SRAM 的每个储存单元胞都更加复杂。正因如此，SRAM 的访问速度远远快于 DRAM，因此常被用在 Cache Memories（高速缓存器）中（成本也是高速缓存通常大小比较小的原因之一）。</p><p><strong>Needs EDC</strong> 的含义是指，必须用一定的电压作用在存储单元胞的两端，否则一断电就会丢失电荷，数据也会丢失（<strong>又称 Volatile Memories</strong>）。这也是 RAM 需要插电用的原因（当然，如果把它从电源上拔下后迅速扔进液氮中，可以保留其中数据，因为电荷散失速度可以忽略）。</p><p>DRAM 被广泛应用于主存、图形显卡的 <strong>帧缓存（frame buffer）</strong>中。</p></blockquote></li></ul><h3 id="10-1-2-Nonvolatile-Memories"><a href="#10-1-2-Nonvolatile-Memories" class="headerlink" title="10.1.2 Nonvolatile Memories"></a>10.1.2 Nonvolatile Memories</h3><p><strong>ROMs</strong></p><p>除了 RAM，计算机存储系统中另一类存储器是 <strong>非易失性存储器</strong>，它们在计算机断电后仍然能保存数据。请回忆数电中介绍的几种电子元件：</p><ul><li><strong>ROM</strong>（Read-Only Memory，只读存储器），出厂时就编程完成，通常电路烧在板子上不可更改；</li><li><strong>PROM</strong>（Programmable ROM，可编程只读存储器），只能对电路编程一遍；</li><li><strong>EPROM</strong>（Erasable PROM，可清除可编程只读存储器），可以被特殊作用清除电路信息（UV / X-rays）；</li><li><strong>EEPROM</strong>（Electrically Erasable PROM，电驱动可清除可编程只读存储器），可以使用电路、电子清除其中信息，但只能反复清除重写 100,000 次。</li></ul><blockquote><p>它们的电路结构想必各位脑海中都非常清楚对吧？</p></blockquote><p>其中，大家所熟知的 <strong>闪存（Flash Memory）</strong>，就是许多 EEPROM 元件组成的。</p><blockquote><p>Tips. 计算机存储系统中的<strong>主存</strong>包括了 <strong>ROM 和 RAM</strong>，但闪存作为 ROM 的一种，<strong>也是现代最常用的 ROM</strong>，也可以和机械硬盘一起被用在<strong>外存</strong>中。</p></blockquote><p>这些 ROM 的作用很广泛，主要有以下几个方面：</p><ul><li>普通 ROM <strong>常被用作重要的、不应该被更改的数据的存储</strong>，例如 BIOS（存储计算机系统启动时的指令 + boot 引导程序）、Controllers for disks（硬盘控制器）、Network Cards（网卡）、Graphics accelerator（图形加速器）、Security subsystem（安全子系统）；</li><li>它们（闪存）还会被用在 <strong>固态硬盘</strong>（SSD，Solid State Disk，代替转圈易坏的机械硬盘，用在笔记本电脑、手机、mp3 播放器、平板等设备，系统会把 SSD 看成机械硬盘）中；</li></ul><p><strong>机械硬盘</strong></p><p>除了 ROM 一类的非易失性存储器，还有 <strong>外存</strong>（外部存储器）也是非易失性存储器。我们这里介绍有代表性的机械硬盘：</p><ul><li><p>结构包括传动臂、SCSI 连接口、盘片、盘片轴……</p></li><li><p>硬盘中包含一系列盘片（platter），每个盘片有两个面，每个面上涂有磁性材料，并且存在一圈圈同心圆（concentric rings），被称为 <strong>磁道（tracks）</strong>，每个磁道包含若干 <strong>扇区（sectors）</strong>，扇区之间会有空隙间隔（gaps），<strong>一个扇区通常的大小是 512 bytes</strong>；</p><p><img src="imgs/disk_geometry.png" height="240px"></p><p>盘片轴（spindle）连接一系列盘片，<strong>每个盘片相同位置对齐的磁道称为 Aligned tracks，在垂直方向组成一个圆柱</strong>，这个相同位置的磁道所组成的元素称为 <strong>柱面</strong>，数据按照不同柱面进行存储，同一柱面的数据连续（为啥按柱面存？因为方便机械臂访问）。</p><p><img src="imgs/disk_geometry_multi_platter.png" height="240px"></p></li><li><p>传动臂悬浮在盘片上方，隔着一层薄薄的空气。其末端读写头可以感知编码位的磁场变化；</p></li><li><p>机械磁盘内置电子设备，用于控制传动臂的移动等操作，其驱动程序一般存于 ROM 中；</p></li><li><p>机械性质决定了机械硬盘的读写速率慢于 RAM 和 ROM；</p></li><li><p>硬盘承载量取决于 <strong>数据记录密度（recording density，1 inch 磁道段中能存放多少 bit 信息）、磁道密度（track density）、面密度（Areal density，前面二者的乘积）</strong>；</p></li></ul><blockquote><p>⚠ 易错点警告：对于硬盘来说，它的承载量单位 GB 是特殊的：<strong>1 GB = $10^9$ Bytes</strong>，这与之前我们见到的衡量二进制数据大小的单位 GiB（<strong>其简称也叫 GB，1 GiB = $2^{30}$ Bytes</strong>）是不一样的。</p><p>这么说就明白了：<strong>承载量单位应该分开来看</strong>：1 G | B，1 吉 (Giga) = $10^9$；</p><p>而<strong>衡量二进制数据大小的单位是个整体</strong>： 1 | GiB，GiB 本身是 gibibyte（giga-binary byte），是 byte 单位的 $2^{30}$ 倍；</p><p>最常见的是计网的考题：<strong>1 MB/s 在 1 s 内传输的数据量略小于 1 MB</strong>，因为承载量速率单位 1 MB/s 是 $10^6$ Bytes / s，而数据大小 1 MiB 是 $2^{20}=1024^2$ Bytes；</p></blockquote><ul><li><p>在很早以前的机械硬盘中，每个磁道的扇区数目固定，这会导致大量的空间浪费。所以现代的机械磁盘<strong>将许多磁道划分为一个个不相交子集，称为记录区（recording zones）</strong>：</p><ul><li>每个处于同一记录区中的磁道含有相同的扇区数，它取决于最内侧磁道；</li><li>每个记录区中的磁道的扇区数不同，越靠近内圈的记录区中磁道的扇区数越少；</li><li><strong>因此我们使用平均扇区数 / 磁道数来计算承载量</strong>；</li></ul><p>如下图，阴影部分为一个记录区，含有许多扇区数相同的磁道：</p><p><img src="imgs/recording_zone.png" height="200px"></p><blockquote><p>题型：计算磁盘承载量</p><p><strong>承载量 = 每个扇区的 byte 数（通常 512 bytes）× 一个磁道中平均扇区数 × 一个盘面中的磁道数 × 一个盘片上表面数目（对三维生物来说=2）× 每个磁盘的盘片数</strong>；</p></blockquote></li><li><p>机械硬盘借助悬浮在盘面上方的传动臂进行读取，许多传动臂在磁盘同一半径处读写，其搜索读取读取速度取决于三个因素：<strong>寻道时间（一般最长，大约 3~9 ms）、旋转延迟、传输时间</strong>。</p><p><img src="imgs/disk_op.png" height="200px"><img src="imgs/disk_access_time.png" height="200px"></p></li><li><p>关于数据访问的耗时，有一些数字可以了解一下：</p><ul><li><p>一般情况下机械硬盘的 <strong>寻道时间 &gt; 旋转延迟 ≈ 4 ms &gt;&gt; 传输时间</strong>；</p><blockquote><p>机械硬盘访问扇区的第一个 bit 耗时最多，其他几乎不耗时；</p></blockquote></li><li><p>SRAM 访问 8 bytes 数据平均需要 4 ns，DRAM 需要 60 ns，<strong>而机械磁盘比 SRAM 慢 40000 倍，比 DRAM 慢 2500 倍</strong>；</p></li></ul></li><li><p>硬盘（机械 / SSD）的<strong>逻辑块（Logical Disk Blocks）</strong>：现代硬盘提供了一个面向 CPU 的更简单的抽象。硬盘的可用扇区被抽象为一组 b-sized 的逻辑块（编号从 0 开始）；</p><ul><li><p>每个逻辑块是<strong>扇区大小的整数倍</strong>（跳过 gaps），最简单的情况下，一个逻辑块就是一个扇区；</p></li><li><p>磁盘控制器来保持从物理扇区到逻辑块之间的<strong>映射</strong>（间接层面、抽象层面）；</p><blockquote><p>这允许磁盘控制器保留一部分 <strong>柱面</strong>（前面提到的存储信息按照同心磁道组成的柱面） 不进行映射，作为 <strong>备用柱面</strong>。</p><p>当某一柱面上的一个扇区损坏，那么磁盘控制器可以直接将数据复制到备用柱面，然后磁盘就能继续正常工作。</p><p><strong>这就是为什么磁盘的 “格式容量”（formatted capacity）比实际容量小</strong>。</p></blockquote></li></ul></li></ul><p><strong>固态硬盘</strong></p><p>固态硬盘作为一种更新的、用来代替机械磁盘的外存形式，其控制器接口和机械磁盘一样，所以 CPU 一视同仁，不过它的速度介于 DRAM 和 机械硬盘之间。</p><p>其内部<strong>全部由闪存构建</strong>，并且由一个固件（firmware）称为闪存翻译层（<strong>flash translation layer</strong>）充当控制器（其作用和机械硬盘的磁盘控制器相当）；</p><p>数据在 SSD 中是以 <strong>页（page）</strong> 为单位从闪存中读取和写入的。页的大小 512 KB ~ 4 KB，块（block，和之前提到的 CPU 所认为的逻辑块<strong>不同</strong>，下面解释）一般包含 32 ~ 128 页，<strong>取决于 SSD 实现的技术</strong>；</p><blockquote><p>这里所说的 “块” 为啥和之前的 “逻辑块” 不同？</p><p>首先明确，这是个术语重叠的现象。这里的 SSD 中的 “块” 是闪存的性质导致的。目前技术下闪存的数据擦除是<strong>成块成块擦除</strong>，这意味着一次会同时擦除多个页。因此，人们把<strong>闪存一次擦除的一组页集合称为 “块”</strong>。</p><p>因此，想要修改某个块中的某个页，需要 <strong>将该块全部擦除（之前应该复制到其他位置）</strong> / <strong>找到一个已被擦除的块</strong> 才能写入；</p><p>现代的闪存翻译层中实现了很多专有算法，能够延长 SSD 的使用寿命，例如缓存技术。</p></blockquote><p><img src="imgs/ssd_struct.png" height=240></p><p>固态硬盘的读写效率大致是 <strong>随机访问 300 MB/s 左右，顺序访问 500 MB/s 左右</strong>（Intel SSD 730 的数据），可以说<strong>在计算机的存储系统的层次结构中，随机访问总是比顺序访问更耗时</strong>。其中 SSD 写入速度都略低于读取速度，这是因为闪存写入前需要擦除原先数据。总的来说，SSD 的访问速度大约比机械硬盘快 10 倍左右。</p><p>其实，SSD 和机械硬盘各有优劣，相较于机械硬盘，SSD 具有以下特征：</p><ul><li>（优势）没有机械移动，更快、耗能更低、更结实（较不易摔坏），适合用在便携设备中；</li><li>（劣势）可能磨损，但问题不大，一般生命周期中可以写 100 PB+ 的数据（足够用多年）；</li></ul><p>最后看一下各种存储介质和 CPU 时钟频率的关系：</p><p><img src="imgs/CPU_memory_gap.png" height="400px"></p><blockquote><p>2003 年，CPU 设计达到性能能源瓶颈，其发展从增大时钟频率转向增大 CPU 内核数。</p></blockquote><h3 id="10-1-3-Traditional-Bus-Structure-Connecting-CPU-and-Memory"><a href="#10-1-3-Traditional-Bus-Structure-Connecting-CPU-and-Memory" class="headerlink" title="10.1.3 Traditional Bus Structure Connecting CPU and Memory"></a>10.1.3 Traditional Bus Structure Connecting CPU and Memory</h3><p>说完计算机存储系统的硬件，那么它们是怎么与 CPU 建立连接，进而抽象出 “内存空间” 和 “存储空间” 的呢？</p><p><img src="imgs/io_bus.png" width="600px"></p><blockquote><p>其中 I/O 桥是另外的一些芯片组，另一些芯片的集合。</p></blockquote><p><strong>CPU 访问主存</strong></p><p>上面的图仅仅是比较简单粗略的抽象，不要较真。在比较老的计算机架构中（因为现代系统有专有的总线设计，非常复杂），采用 <strong>总线（bus）</strong>来连接 CPU 和主存的，数据通过总线在主存和 CPU 间来回传输。<strong>并且总线通常与其他多种设备共享</strong>。</p><p>正常情况下，CPU 中的 ALU 根据汇编机器指令只需访问最近的寄存器就行；如果指令要求它访问内存，那么 ALU 会交由总线接口（Bus Interface）去从主存中取出相应位置的数据。</p><p>大家可以思考一下，在上面这幅图中，<code>movq %rax, $A</code> （A 为内存地址）和 <code>movq $A, %rax</code> 应该如何形象表示？</p><p>大家不难发现，<strong>寄存器离 CPU 很近，所以访问速度很快</strong>，通常在 3 个时钟周期左右就能读写到值。但是内存（图中 Memory Devices 芯片组）离 CPU 相当远，中间的步骤相当多，所以<strong>对内存读写所消耗的时间大约是对寄存器读写耗时的 100 倍左右</strong>。这就是计算机内存系统引入所发现的其中一个性能损耗。</p><p><strong>CPU 访问外部设备（以外存: 磁盘为例）</strong></p><p>再来看 I/O 总线（I/O Bus），它将各个设备与 I/O 桥连接，<strong>使得外部设备能和主存一样被 CPU 访问</strong>。I/O Bus 看起来是一条线，可实际不是如此。因为在老式的计算机中，它被称为 PCI 总线（广播总线），主干连接到各个设备，任何设备只要更改其上的数据，其他设备就能发现。</p><p>但现代的 I/O 总线并不是一条线了，它采用了 PCI Express 的总线结构，并不像上面画的一样，它是 <strong>点对点地连接两个设备</strong>，实现不同（我们不会深入讨论），但提供的功能就像图上画的一样。所以可以把 I/O Bus 看作一组电子线路即可。</p><p>其中 Disk、Mouse、Keyboard、Monitor 等设备使用细双箭头，表示它们不是焊在主板上，而是插入主板上的控制器（adapter、controller）来连接。</p><p>考虑如果 CPU 想要访问某个磁盘设备的某个扇区，那么会进行如下步骤：</p><ul><li>CPU 生成一个三元组（triple）：<strong>指令</strong>（read / write）、<strong>逻辑块编号</strong>、该块中的数据要放到哪个<strong>内存地址</strong>中（CPU 先从磁盘读入内存，再从内存读入 CPU 寄存器，反方向亦然），并且当前线程的程序暂停执行（如果是 I/O 阻塞的话），等待数据传输；</li><li>三元组通过总线接口、I / O 桥、I / O 总线传给磁盘控制器；</li><li>磁盘控制器通过读取与该逻辑块对应的任何扇区（一个逻辑块可能包含很多扇区）读入磁盘缓存；</li><li>磁盘控制器取得总线控制权，并且<strong>将数据通过 I/O 总线、I/O 桥和内存总线直接送往指定内存地址，而无需将数据传给 CPU</strong>；</li><li>数据传输结束后，磁盘控制器借助 “I/O 总线 - I/O 桥” 从<strong>新的通路</strong>（不经过总线接口）直接用电信号触发 CPU 的某个<strong>引脚</strong>，这个信号代表一种<strong>中断（interrupt）</strong>，通知 CPU 该扇区已被复制，此时暂停的程序继续执行；</li></ul><h2 id="10-2-Locality"><a href="#10-2-Locality" class="headerlink" title="10.2 Locality"></a>10.2 Locality</h2><p>无论是 8.1.2 中介绍的各自存储介质在物理层面上的性能约束，还是 8.1.3 中介绍的数据读取流程上的性能限制，都是计算机存储系统需要解决的重要问题，否则，在硬件上计算机就难以继续提升运行速度了。</p><p>其实，弥补 CPU 和内外存读写速率之间差距的机制之一就是<strong>程序的基本属性之一：局部性（locality）</strong>。</p><p>局部性原则：程序倾向于使用 “<strong>内存地址接近或等于最近使用过的数据/指令地址的</strong>” 那些数据和指令。</p><blockquote><p>原文：Programs tend to use data and instructions with addresses near or equal to those they have used recently.</p></blockquote><p>这个原则来源于程序编写的逻辑——<strong>当程序访问到某个内存地址上的数据，那么在不久的将来，有很大的可能程序会访问该数据项或者附近的数据项</strong>。</p><p>这种局部性有两种表现形式：</p><ul><li><p>时间局部性（Temporal Locality）：最近引用的存储器位置可能在不久的将来再次被引用；</p></li><li><p>空间局部性（Spatial Locality）：如果访问了一个存储器的位置，那么有很大可能在将来会访问一个临近的位置；</p></li></ul><blockquote><p>例子：识别代码中的局部性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> sum += a[i];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure><p>这串代码中，有对<strong>数据的引用</strong>（Data references，转为汇编后会引用数据，通常只要有变量就有数据的引用）。</p><p>例如上面的数组 <code>a</code>，其元素在内存上连续，索引 i 每自增一个单位就访问一下（称为 stride-1 reference pattern），属于空间局部性；上面的变量 <code>sum</code> 在循环的每次迭代中都会被引用，属于时间局部性；</p><p>还有对<strong>指令的引用（Instruction references）</strong>，例如循环中每一次都会执行循环体的内容，属于时间局部性；再比如程序代码顺序执行，本身就属于空间局部性。</p></blockquote><p>不同编写方法的代码，其局部性不同。这就需要开发者训练观看的能力。举一个很简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array1</span><span class="params">(<span class="type">int</span> a[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_array2</span><span class="params">(<span class="type">int</span> a[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们考虑对数据的引用，<strong>回忆 6.1 中对于 Nested Array 的内存排列的知识</strong>，数组数据连续排列且<strong>行优先</strong>，所以我们发现，使用 <code>sum_array2</code> 方式遍历数组，其<strong>数据相距距离很远</strong>，这意味着程序的局部性差于 <code>sum_array1</code>。而事实上，<code>sum_array2</code> 也真的会比 <code>sum_array1</code> 慢一个数量级；</p><blockquote><p>例题：请修改以下代码，使得它满足 stride-1 reference pattern（即更优的程序局部性）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array_3d</span><span class="params">(<span class="type">int</span> a[M][N][N])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i, j, k, sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">     <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">         <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">             sum += a[k][i][j];</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="10-3-Conclusions-for-10-1-amp-10-2"><a href="#10-3-Conclusions-for-10-1-amp-10-2" class="headerlink" title="10.3 Conclusions for 10.1 &amp; 10.2"></a>10.3 Conclusions for 10.1 &amp; 10.2</h2><p>没错，前面两节全部在为存储系统的层次结构<strong>做准备</strong>，之后我们才开始正式讨论 Memory Hierarchy。在此之前，我们先小总结一下前面的内容。</p><p>在本章开始，我们认识了计算机存储系统在硬件层面的两大组成：主存和外存。主存由 RAM（又分为 SRAM 和 DRAM）组成；外存则是硬盘（又分为机械硬盘、SSD）、可移动磁盘为主。</p><blockquote><p>广义的内存包括：主存（RAM）、全部 ROM、Cache（高速缓存存储器）；</p></blockquote><p>我们紧接着比较了 SRAM 和 DRAM 的特征、异同，以及它们所使用的场合；对于 ROM，我们了解了不同的 ROM 类型，还有闪存的定义。</p><p>在外存方面，我们详细介绍了机械磁盘的物理结构（磁盘控制器、盘面、柱面、磁道、扇区、记录区、承载量计算、访问耗时分析、逻辑块），并类比出功能相同、实现不同的固态硬盘物理结构（闪存翻译层、页、块）。</p><p>于是，我们从上面存储介质的物理结构中分析并得出 <strong>其数据访问模式的性能限制和优劣</strong>。</p><p>最后，我们分析了 <strong>CPU 访问主存</strong> 和 <strong>CPU 访问外存</strong> 的情况和流程，从中我们得知了在内存读取的流程中也存在着性能的限制或者说损失。</p><p>基于这些物理结构的限制，我们讨论出代码结构层面能够在一定程度上弥补这些性能鸿沟的性质：<strong>局部性</strong>。我们根据 <strong>存储设备的物理结构</strong> 和 <strong>数据存放的方式</strong>，可以设计写出更符合程序局部性的代码，这在一定程度上可以缓解 CPU 和内存之间访问的性能差距。</p><p>而观察代码的局部性，就需要对数据在内存中的 layout，还有储存设备的工作原理有一个很好的认识，这就是前几章、前几节的内容。</p><p><strong>这些存储介质的物理特性，和程序的局部性相辅相成，相得益彰，为人们提供一种 “怎样设计存储系统” 的建议和信息。</strong></p><p>接下来，我们将基于这些存储介质的物理性质，讨论在其上所建立的层次结构，和这些层次结构是如何抽象硬件，尽可能地为上层的计算机软件提供更连续完整的资源的。</p><h2 id="10-4-Memory-Hierarchy-amp-Idea-of-Caching"><a href="#10-4-Memory-Hierarchy-amp-Idea-of-Caching" class="headerlink" title="10.4 Memory Hierarchy &amp; Idea of Caching"></a>10.4 Memory Hierarchy &amp; Idea of Caching</h2><p>下图是计算机存储系统的一个层次结构图。</p><p>其中，寄存器是访问速度最快的存储结构，它在每个 CPU 时钟周期内都可以直接访问到（大小最小、数量很少、价格最贵、速度最快）；</p><p>接下来的是由 SRAM 组成的高速缓存存储器（Cache Memory），也处于 CPU 芯片内部，既不是主存，也不是寄存器；大小虽然是 MB 级，但已经比寄存器大多了。其中 3 层 Cache Memory 的具体结构将在下一章进行深入讨论；</p><p>再向下是 DRAM 组成的计算机的主存，一般你能看到的 “内存条” 就是它的组合结构，也是普通人经常说的 “内存”（狭义内存），一般从几个 G 到 几十 G 不等，程序运行内存（或者说后面要提到的<strong>虚拟内存</strong>）就是它的一部分；</p><p>最底层的像本地硬盘结构，甚至云端存储结构，空间一般都很大，但访问效率低下。</p><p><img src="imgs/memory_hierarchy_example.png" height="400px"></p><p><strong>设计的核心：在 Memory Hierarchy 中，每一层都包含着从下一层所检索的数据</strong>（例如 CPU 寄存器保存着从 L1 高速缓存中取出的数据，依此类推）；</p><p>这样设计的原因是为了充分利用各个层级资源的特征，将整体数据访问效率最大化（<strong>底层是极大的数据池，却能够以极快的速度进行访问</strong>）。</p><p>这么做之所以有效，是因为 <strong>缓存思想（Caching）的存在</strong>。</p><p>这里所说的缓存，<strong>不是高速缓存存储器（Cache memories），而是一种思想</strong>。<strong>作为一个更小、更快的存储设备，充当更慢设备中数据的暂存区域、能更快访问的数据子集</strong>。例如，主存 可以看成是本地硬盘的 缓存，这样一旦从磁盘获取数据，就无需在磁盘上访问它，在上一个层级内存中访问，速度得到提升。依此类推，<strong>缓存的思想在 Memory Hierarchy 中逐级传播</strong>。</p><blockquote><p>第 k 层更快、更小的存储设备，就是第 k+1 层更慢、更大存储设备的 缓存。</p></blockquote><p>在真实场景中，每当程序访问一个不在缓存设备（第 k 层）中的数据，都会从第 k+1 层检索，并复制到第 k 层缓存起来。这是因为，<strong>根据程序的局部性</strong>，相较于第 k+1 层的设备，会更经常访问第 k 层设备中的数据，这就是 Memory Hierarchy 能最大化数据访问效率的原因。</p><hr><p>在详细介绍高速缓存存储器（狭义的 Cache）前，我们简单介绍一下<strong>缓存的实现</strong>，因为缓存思想存在于存储层次结构的每一层。</p><p><img src="imgs/general_cache_concept.png" height="240px"></p><p>储存数据的下层设备的空间（k+1 层）通常被分为一个个固定大小的块（blocks），缓存设备和下层设备间传输的数据以块为单位进行。</p><blockquote><p>如果第 k+1 层是 Web 云端存储介质，那么 blocks 通常以文件形式传给磁盘（第 k 层，缓存设备）；</p><p>如果第 k+1 层是主存，那么 blocks 可能是以某个特定大小的数据块传给高速缓存存储器（第 k 层，缓存设备）；</p><p>……</p></blockquote><p>在任意时间点，第 k 层的缓存设备中的数据都是第 k+1 层设备数据的一个子集。</p><p>对于 CPU 请求一个位于第 k+1 层的某个位置的数据这种情况，则 CPU 会先去层级最高的设备中寻找（假设找到第 k 层），则有两种情况：</p><ul><li><p>如果恰好找到了（假设请求如下图绿色块 14 的数据），那么 CPU 就直接从缓存（第 k 层）中读走这个数据，无需向下请求数据，总体提升了效率。这种情况称为 <strong>Cache Hit</strong>（缓存命中）；</p><p><img src="imgs/cache_hit.png" height="240px"></p></li><li><p>如果没有找到，那么 CPU 就需要从更下一层取得此数据块，并<strong>将它存放在缓存设备中</strong>。这种情况称为 <strong>Cache Miss</strong>（缓存不命中）；其本身又分为 3 个类型：</p><ul><li><p>Cold（compulsory）Miss：缓存为空，所以 Miss，不可避免；</p></li><li><p>Capacity Miss：由于较小的缓存空间而导致的不命中，通常是因为程序的工作集大于缓存空间所致。可以由增大缓存空间而减少；</p><blockquote><p>工作集（working set）：当前不断被程序访问的块，也即活跃的缓存块（active cache block）；</p></blockquote></li><li><p>Conflict Miss：由于大部分缓存设备（尤其硬件缓存）必须设计的比较简单，它限制了缓存块的放置位置（例如第 i 块必须放在 <code>i mod sizeof(Cache)</code> 的位置，很类似 hash table 的碰撞），这与缓存实现方式有关，也在下一章进一步讨论；</p></li></ul><p><img src="imgs/cache_miss.png" height="240px"></p></li></ul><p>最后，我们总结一下缓存在存储系统各层级的实现情况：</p><p><img src="imgs/caching_in_hierarchy.png" height="400px"></p><blockquote><p>注：TLB（Translation Lookaside Buffer，后备缓冲）是一个在虚拟内存中使用的缓存，<strong>是虚拟地址翻译为物理地址的翻译过程的缓存</strong>；</p></blockquote><p>需要注意的是，<strong>各个层级的缓存究竟是由谁实现和管理的</strong>，这是缓存思想的一个重点，也能解释早在第 3 章的疑问——<strong>汇编代码中找不到管理高速缓存存储器的代码</strong> 的原因。</p><p>例如，当寄存器看作缓存设备时，是编译器决定用哪个寄存器、用多少个寄存器（怎么用的 conventions 是 ABI 决定的）；</p><p>综上，缓存思想存在于计算机系统的几乎每个用到数据 I/O 的地方。</p><p>下一章将讨论 Memory Hierarchy 中一个具体的部分 <strong>高速缓存存储器</strong>，来深入了解缓存思想。</p><h1 id="Chapter-11-Cache-Memories"><a href="#Chapter-11-Cache-Memories" class="headerlink" title="Chapter 11. Cache Memories"></a>Chapter 11. Cache Memories</h1><blockquote><p>本章讲述 Memory Hierarchy 缓存思想中的重要一个体现：高速缓存存储器（Cache memories），它介于寄存器和内存之间，充当缓存设备的角色。</p></blockquote><p>回忆上一章的内容，高速缓存器本质上是一种由 SRAM 组成的、由硬件直接管理的小型缓存存储设备：<strong>Cache memories are small, fast SRAM-based memories managed automatically in hardware</strong>.</p><p>它一般封装于 CPU 芯片中，几乎和寄存器距离 CPU 核心同样近（只是由于电路存取特性导致其慢于寄存器），存储主存中被频繁引用的数据块。</p><h2 id="11-1-General-Cache-Organization"><a href="#11-1-General-Cache-Organization" class="headerlink" title="11.1 General Cache Organization"></a>11.1 General Cache Organization</h2><p>那么硬件是如何管理高速缓存存储器中的数据，在 CPU 需要的时候进行寻找呢？我们首先需要借鉴<strong>层次架构中一般的缓存模型</strong>，它们共同有一种缓存的管理方式和 layout；</p><p>首先，缓存本身就需要极速，这意味着设计缓存机制必须<strong>以非常严格且简单的方式去组织缓存模型</strong>，便于各个设备层级间进行查找。于是人们设计了下面的缓存数据组织形式：</p><p><img src="imgs/general_cache_organization.png" height="350px"></p><p>缓存空间中一般包含 $S=2^s$ 个数据组（set），每一组又包含 $E=2^e$ 个数据行（line，图中<strong>横着排列</strong>），每一数据行由大小为 $B=2^b$ bytes（B binary digits）的数据区块和一个 tag 区、一个 valid bit 组成；现在解释一下目前可能有的疑惑：</p><ul><li>valid bit 指示当前缓存数据行中的数据实际上也真实存在于下层的存储介质中，可以直接使用（例如第一次打开机器的时候，这些数据区块位置上是随机 bits，因此这些 valid bit 会提示数据区块无效）；</li><li>tag 位（标记位）编码了这串数据位于下层存储介质的位置，在 CPU 搜索时有用；</li><li>为何无论是组数、数据行数还是每个数据行中的字节数都是 2 的幂次呢？<strong>这是一个非常重要的点。因为，缓存空间按照 内存地址的数码的各个位 来直接对应该内存数据应该存放的位置</strong>。这个比较抽象，后面的例子就会慢慢理解。</li></ul><p>其中高速缓存块的大小 <u>不包含 Tag 和 valid 部分</u>，也就是说，高速缓存的大小 $C=S\times E\times B$；</p><h2 id="11-2-Read-Cache"><a href="#11-2-Read-Cache" class="headerlink" title="11.2 Read Cache"></a>11.2 Read Cache</h2><p>那么缓存是如何被读取的？详细数据结构（和具体存储设备有关）又是什么样子的？</p><p>实际上，程序在运行中可能请求了下层存储介质中某个位置的数据，我们<strong>以高速缓存存储器和主存间查找数据的关系为例</strong>。步骤如下：</p><ul><li>假设程序指令要求引用主存中虚拟内存的某个地址（设为 <code>X</code>）的数据，那么 CPU 会向高速缓存存储器请求 <code>X</code> 地址下的值；</li><li>这个请求的地址会被 高速缓存存储器 <strong>直接用来查找缓存存放的位置（即这个地址的数据存放在）</strong>。其中 <code>X</code> 会被 高速缓存存储器 <strong>解析成</strong>如下图所示的结构（<strong>这就是为什么上面的 <code>S</code>、<code>E</code>、<code>B</code> 都是 2 的幂</strong>。看着这张图你能想明白吗？还不能明白的话，后面会有更具体的例子）：</li></ul><p><img src="imgs/addr_B.png" height="125px"></p><ul><li>高速缓存存储器 <strong>首先 extract <code>X</code> 中 s bits 的 <code>set index</code></strong>（缓存组索引）看作为 unsigned int，用它找到缓存空间中特定的组（和数组索引很像）；</li><li>高速缓存存储器 接着<strong>并行检查（依赖于硬件电路的检查机制）</strong>该组中所有的数据行，将 tag 字段与每个数据行中的 tag 进行比较。如果找到了相同的 tag，那么再检查 valid bit 是否指示有效。所以会出现以下情况：<ul><li><strong>情况一</strong>：该组的数据行中不存在 tag 与 <code>X</code> 一致的行，<strong>说明请求的数据块不在缓存中（Cache miss）</strong>；</li><li><strong>情况二</strong>：该组的数据行找到了 tag 与 <code>X</code> 一致的行，但 valid bit 指示无效，<strong>说明请求的数据块无效，当前也不在缓存中（Cache miss）</strong>；</li><li><strong>情况三</strong>：该组的数据行找到了 tag 与 <code>X</code> 一致的行，并且 valid bit 指示有效，<strong>Cache hit</strong>！</li></ul></li><li>如果是 cache hit，那么<strong>extract</strong> <code>X</code> 中 b bits 的 <code>block offset</code>，从该数据行的数据区块开头地址加上这个 offset，将得到的地址再数据行中剩余部分规定大小读出，直接传给 CPU，结束查找过程；</li><li>如果是 cache miss，那么高速缓存存储器会放弃查找，将原本的请求地址 <code>X</code> 传给下一级存储设备（主存），那么查找工作交给主存（重复上面类似的步骤）。<strong>注意，当主存找到数据向上提交时，再次给到高速缓存存储器</strong>，将数据放在高速缓存存储器的应该是 <code>X</code> 的位置<strong>缓存起来</strong>（通常会覆盖相同位置的其他数据），然后高速缓存存储器再将数据向上提交给 CPU；</li></ul><p>总体呈现出 <strong>“逐层向上缓存数据，逐层向下查找数据”</strong> 的形式。</p><h3 id="11-2-1-Direct-Mapped-Cache-Simulation"><a href="#11-2-1-Direct-Mapped-Cache-Simulation" class="headerlink" title="11.2.1 Direct-Mapped Cache Simulation"></a>11.2.1 Direct-Mapped Cache Simulation</h3><p>下面详细解释上面的步骤。为了便于理解，我们首先从简单的情况讨论，<strong>当每一个缓存组只包含一个数据行的情况，这种情况被称为 “直接映射”（Direct-Mapped Cache Simulation）</strong>：</p><p>假设某个机器的内存空间大小 M = 16 bytes（可以用 4-bit digit 代表地址），缓存空间中含有 4 个组（S = 4），每个组含有一个数据行（E = 1），每个数据行含有 2 bytes 的数据区块（B = 2）。</p><p>在数据区块中，block offset 的长度为 1 byte（b = 1，因为数据区块只有 2 bytes，一般有 $B=2^b$），set index 的长度为 2 bytes（s = 2，因为缓冲区只有 4 组数据组，有 $S=2^s$）；</p><p>现在程序开始运行的时候，分别请求内存地址（$X$）为 0、1、7、8、0 的 1 byte 数据；</p><p>现在，高速缓存存储器中的所有数据行的 valid bit 都是 0（假设 0 代表无效，1 代表有效），并且开始接受 CPU 请求内存地址 $X = 0 = 0000_2$ 的数据 的请求。</p><p>首先，$X$ 的 block offset <strong>就是中间 2 bit</strong>，<code>00</code>，所以在 <code>set 0</code>（第 0 组）中寻找；然后，将 $X$ 的 tag 位（即最左边的 1 bit，0）与 <code>set 0</code> 的 tag 比较（是随机数），再看 valid bit 是 0，所以 cache miss（cold miss），如下动画（本人不会 Acrobat Animate，比较粗糙）：</p><p><img src="imgs/directMappedCacheSimulation_part1.gif"></p><p>思考两个问题，第一个，为什这里的 tag 是 0 ？这是因为，我们在给定的 set offset 下（组相同），前面的 t bit（t=1）的 tag 位<strong>只是用来区分数据行</strong>的，<strong>借助了原内存地址 <code>X</code> 的前 t bits 数据</strong>而已，没有实际意义。</p><p>第二个，为什么这里要从 main memories 中同时读入 0、1 地址的数据？也就是说，为什么设定 <code>B == 2</code> 呢？<strong>这是因为，除去 set offset 的 2 bits、tag 的 1 bit，剩下内存地址 <code>X</code> 数码还有 1 bit 留给 block offset</strong>，因此 <code>X</code> 只能在该组的数据行中索引 2 bytes 的数据。</p><p>细细体会上面的话，你会发现这就是缓存空间如此设置、<code>X</code> 如此解析的原因（这里设计的和 IEEE 浮点数表示法一样巧妙，不容易用语言描述）。</p><hr><p>好了，又有同学会好奇了，既然这些索引本身没有意义，只是借助了原地址的数码，<strong>那为什么设计缓存索引的人一定要 <code>set index</code> 在中间、tag 在最前面、block index 在最后面呢</strong>？</p><p>这个问题非常有水平，这和<strong>二进制数码的变化方式有关</strong>。我们这里就分析对比 2 种解释 <code>X</code> 地址的方式：</p><ul><li>Middle Bits Indexing：就是上面的 <code>X</code> 的结构，Tag 在前、<code>Set index</code> 在中间、<code>Block index</code> 在最后；</li><li>High Bits Indexing：<code>Set index</code> 在前、Tag 在中间、<code>Block index</code> 在最后；</li></ul><p>我们接下来<strong>将缓存空间的组标为不同颜色，再把内存中将要分配到哪一组的数据块填上相同的颜色</strong>，发现结果如下：</p><p><img src="imgs/middle_bits_indexing.png" width="360px"><img src="imgs/high_bits_indexing.png" width="360px"></p><p>我们发现，<strong>如果用 high bits indexing，那么内存地址相近的内存区域很容易被分配到相同的缓存组中，根据<u>空间局部性</u>，这样做会导致发生 conflict miss 的概率大大增加</strong>。所以，在缓存效率上，middle bits indexing 是优于 high bits indexing 的。其他情况同理。</p><p>这就是设计者们为什么要如此设计内存地址 <code>X</code> 在缓存中的这种解析方法。</p><hr><p>继续看接下来的过程动画：</p><p><img src="imgs/directMappedCacheSimulation_part2.gif"></p><p>我们发现，5 次访问中，有<strong>高达 4 次的 cache miss</strong>。后面 2 次的 cache miss 都是 conflict miss，完全能够由 提高每组的数据行数（<code>E</code> 的大小）来避免。<strong>因此，缓存结构中 <code>E</code> 的大小越大越好（也就是每组中的数据行越多越好）</strong>。但是我们前面提到，一个组中各个数据行<strong>使用并行比较</strong>，这个操作依赖硬件的多路判断——<strong>也就是说，<code>E</code> 越大，硬件电路越复杂，硬件越贵</strong>。所以真实计算机硬件中会进行取舍，选择一个特定的 <code>E</code> 值。</p><blockquote><p>当代（21 世纪初）市面上的常见的单组中数据行数目取值 <code>E = 8</code>，最大有 <code>E = 16</code>，是 Intel 的 16 路相联 L3 三级缓存。</p></blockquote><p>事实上，<code>B</code>（数据区块的大小，block size）也是越大越好，因为越大越可以利用局部性，提升缓存命中概率。但 <code>B</code> 受限于<strong>两个因素</strong>：一是<strong>硬件成本</strong>（例如 Cache memories 由 昂贵的 SRAM 组成），二是<strong>块复制的时间代价</strong>，因为如果想要把很大的数据区块从内存挪至缓存中，也是一个不小的开销。</p><p>综合上面的考虑，设计者真正确定缓存空间各个参数的步骤如下：</p><ol><li><strong>确定合适的数据区块（就是在数据行中的那个字段）大小 <code>B</code></strong>（通常被称为<strong>固定的缓存高级设计参数</strong>。Intel 一般 64 bytes）；</li><li>根据实际应用场景和硬件成本情况<strong>确定大致的缓存空间总大小</strong>（也是固定的缓存高级设计参数之一）；</li><li>根据硬件和实际情况<strong>确定数据组的关联性（associativity，即一个数据组中有多少数据行）<code>E</code></strong>；</li><li>由 1、2、3 就能计算出大致的<strong>缓存数据组数（<code>S</code>）</strong>。</li></ol><blockquote><p>最极端的情况是 <strong>全相关联高速缓存（Fully Associative Caches）</strong>，缓存空间中只有一个组（<code>S = 1</code>，所有数据行在一个组中），这个时候如果能够并行比较，那么缓存效率是极高的。但是通常由于上述原因，我们大多数时候只能在<strong>软件级别的缓存 或者 在主存和硬盘之间的缓存模式（因为硬盘读取时间开销很大，值得我们使用复杂算法来获得更高的缓存效率，我们在“虚拟内存”一章会讨论）</strong>中找到这种组织形式。</p></blockquote><h3 id="11-2-2-E-Way-Set-Associative-Cache-Simulation"><a href="#11-2-2-E-Way-Set-Associative-Cache-Simulation" class="headerlink" title="11.2.2 E-Way Set Associative Cache Simulation"></a>11.2.2 E-Way Set Associative Cache Simulation</h3><p>除了直接映射，还有一个稍微复杂点的例子，<strong>当不改变上面例子中的缓存空间大小，讨论每个缓存组包含 2 个数据行的情况，这也被称为 “2-Way Set Associative Cache（2 路相连高速缓存）Simulation”</strong>。</p><p>这个时候 tag 变为 2-bit，set index 变为 1-bit，block index 还是 1-bit；</p><p>我们有类似上面 Directed-Mapped Cache Simulation 相近的步骤，如下图：</p><p><img src="imgs/2_way_associative_cache_sim.png" height="300px"></p><blockquote><p>注意到一点，当关联性大于 1 的时候，同一个数据组中可能不同的数据行的 tag 可能是相同的，那么当我们想要覆盖数据的时候，就涉及到了<strong>选择覆盖</strong>的问题，它可以通过设计算法来完成。</p><p>根据<strong>局部性原理的逆定理（通常成立）</strong>，如果一个数据长时间不被引用，那么它在未来的某个时间也不太可能被引用。所以，最常见的算法是 <strong>“最近最少使用” 策略（Least Recently Used Strategy）</strong>，这种算法一般不需要额外的 bit 存储数据，只是从硬件层面跟踪在缓存中数据的使用频率（如按序保存虚拟时间戳），确保无效的数据行最先被覆盖，然后是使用频次更低的数据先被覆盖。</p></blockquote><p>助记：</p><ul><li><code>b</code> 位不同，<code>s</code>，<code>t</code> 位相同，也位于同一个组中；</li><li>每 $2^{b+s}$ bytes 就排在同一个组内；</li></ul><h2 id="11-3-Write-Cache"><a href="#11-3-Write-Cache" class="headerlink" title="11.3 Write Cache"></a>11.3 Write Cache</h2><p>事实上，真正要更改某些数据恐怕比读数据更难，因为我们的缓存机制通常会产生多份数据的复制品。例如层级从低到高：硬盘、主存、L1 / L2 / L3 高速缓存，其中可能包含了同一份数据的副本。</p><p>于是在程序要求修改内存（仍然以 高速缓存存储器 和 内存 这对存储同样有 2 种情况 <strong>write-hit</strong> 和 <strong>write-miss</strong>：</p><p>如果遇到 <strong>write-hit</strong>（要写的内存数据就在缓存设备中）的情况，由于数据分布特殊性，那么有两种处理方法：</p><ul><li><p><strong>Write-through</strong>：立即将数据写入缓存（即覆盖当前行）并主动刷新（flush）到内存；</p><ul><li>优势：内存始终是缓存的镜像，二者数据同步；</li><li>劣势：从 CPU 到 内存，时间开销必然很大；</li></ul></li><li><p><strong>Write-back</strong>：先把数据写入缓存，但不立即刷新，直到下一个数据要覆盖这个数据行的时候，才更新到内存中（defer write to memory until replacement of line，<strong>只是尽可能推迟了写入内存的时间</strong>）；</p><ul><li><p>优点：如果数据的 dirty bit 指示没有被污染时，那么覆盖这一行就不用执行 write 操作；</p></li><li><p>特点：<strong>这种方法需要一个标记（dirty bit），用来指示当前数据和内存中是否相同，即是否有被修改过</strong>；</p><p><img src="imgs/dirty_bit.png" height="100px"></p></li><li><p>劣势：必然存在 <strong>write-miss</strong> 现象，因为如果修改的内存数据不在缓存中，那么就需要与内存交互；</p></li></ul></li></ul><p>如果遇到的是 <strong>write-miss</strong>，那么也有 2 种方法（<strong>和 write-hint 是对称的操作</strong>）：</p><ul><li><strong>Write-allocate</strong>：写分配，在 write-miss 后，<strong>先将原数据从内存读入缓存，转换为 write-hit 的情况，再 write-back（仅修改缓存 + dirty bit）</strong>；</li><li><strong>No-write-allocate</strong>：直接写入内存，不加载到缓存（缓存中没有这个数据所在的数据行，因为本来就是 write-miss）；</li></ul><p>一般情况下，由于对称性，人们一般选择 “<strong>write-back + write-allocate</strong>” 或 “write-through + no-write-allocate” 的策略中的其中一对（根据实际情况）；</p><h2 id="11-4-The-Hierarchy-of-Cache-Memories"><a href="#11-4-The-Hierarchy-of-Cache-Memories" class="headerlink" title="11.4 The Hierarchy of Cache Memories"></a>11.4 The Hierarchy of Cache Memories</h2><p>讨论完了缓存读写的具体的逻辑实现，我们再来看看实际上硬件是如何对应这些实现的。同样以 高速缓存存储器 为例。<strong>到目前为止，我们都假设计算机系统中只有一个高速缓存存储器的缓存空间</strong>，但是实际上，早在前面第 8 章中就介绍了，一般计算机中有 L1、L2、L3 3 类 Cache memories。它们在硬件上是如何设置和协调的呢？</p><p>以 Intel Core i7 芯片为例，它的高速缓存层次结构如下：</p><p><img src="imgs/intel_i7_cache_hierarchy.png" height="300px"></p><p>如图，一般情况下，现代 CPU 有 4（桌面系统）/ 8 ~ 12（服务器类系统）个核，<strong>每个核可以各自并行，独立执行各自的指令流</strong>，每个处理器内核可以包含<strong>各自的</strong>通用寄存器（位于存储系统层次结构 L0）.</p><p>在其中，每个核还会有 2 种 L1 Cache。其中一种是 <strong>d-cache（data cache，1 级数据高速缓存器）</strong>，另一种是 <strong>i-cache（instruction cache，1 级指令高速缓存器</strong>）。它们的读取时延（4 个时钟周期）仅次于寄存器，正因速度和成本的关系，它们的大小非常小，只有约 32 KB；它们的关联性一般是 8 路（一个缓存组中有 8 个数据行）；</p><p>在 L1 Cache 的下一层是 L2 Cache（L1 和），只有一种联合的高速缓存器（unified cache，同时包含某个核的数据和指令的缓存），读取速度稍慢（10 个时钟周期）于 L1 Cache，也是 8 路关联性，不过大小稍微大一点，有 256 KB；</p><p>再下层的 L3 Cache 不在 CPU 的核内，是被所有核心所共享的联合高速缓存存储器。8 bytes 大小、16 路关联性，但访问时延长达 40 ~ 75 个时钟周期；</p><p><strong>它们间的关系和之前所说的各个层级的缓存设备一模一样，都是 “逐层向上缓存数据，逐层向下查找数据”</strong>。</p><p>根据这些实际的物理结构，我们考虑一下高速缓存存储器的性能和损耗情况。我们建立如下的衡量指标（Cache Performance Metrics）：</p><ul><li>Miss Rate:  cache memories 不可避免的会发生 cache miss，这就是 cache memories 性能可能产生损耗的原因之一；<ul><li>定义：缓存未命中次数 / 总访问次数（ = <strong>1 - hit rate</strong>）；</li><li>一般情况下，L1 Cache 的 未命中率在 3 ~ 10%，L2 Cache 在 1% 左右，<strong>和缓存大小紧密相关</strong>（<strong>如此低的 Miss Rate 得益于 程序局部性</strong>）；</li></ul></li><li>Hit Time：虽然有时缓存成功命中，但从缓存的数据行中传输到处理器中仍然需要时间。<ul><li>定义：从检查标志位，到 hit 直接返回 block 中的缓存数据所需时间；</li></ul></li><li>Miss Penalty：由于 Miss Rate，从内存传输到缓存和 CPU 中通常会花费更多时间；<ul><li>定义：从检查标志位，到 miss、从内存读取数据，直到数据传回 CPU 所需时间；</li><li>一般情况下从主存中读取数据大约花费 50 ~ 200 个时钟周期（如果在其他的存储系统的层次中，花费可能大得多）；</li></ul></li></ul><p><strong>事实上，这些一次两次看似影响不大的 Cache miss 和 hit，对系统性能影响相当大！数学证明表明，99% 的 hit rate 的系统性能比 97% 的 hit rate 对应的系统性能迅速 2 倍</strong>！</p><blockquote><p>主要是因为 miss penalty 很大，miss rate 的权重远大于 hit rate 的权重。因此我们通常看 miss rate 而不是 hit rate；</p></blockquote><p>那么我们分析之前的 cache 参数对性能的影响：</p><ul><li>cache 总大小影响：增大同时 <strong>提高命中率，但增加 hit time</strong>;</li><li><p>block size ($B$) 大小影响：增大同时 <strong>更能利用程序空间局部性（提升 space locality 好的程序的 hit rate），但数据行数 $E$ 会变少（temporal locality 好的程序的 hit rate 会降低），并且会提高 miss penalty</strong>；</p></li><li><p>associativity ($E$) 大小影响：<strong>降低了 conflict miss 的可能性，但是提升了比较数据行的硬件成本、增加了命中时间、增加了 miss penalty（因为 replacement 的选择也更复杂）</strong>；</p></li></ul><h2 id="11-5-Performance-Impact-of-Cache"><a href="#11-5-Performance-Impact-of-Cache" class="headerlink" title="11.5 Performance Impact of Cache"></a>11.5 Performance Impact of Cache</h2><h3 id="11-5-1-Writing-Cache-Friendly-Code-Ⅰ"><a href="#11-5-1-Writing-Cache-Friendly-Code-Ⅰ" class="headerlink" title="11.5.1 Writing Cache Friendly Code Ⅰ"></a>11.5.1 Writing Cache Friendly Code Ⅰ</h3><p>考虑上一节惊人的缓存性能的情况，我们确实应该写出一些 Cache Friendly 的代码，<strong>这是优化代码性能的一个重要方面</strong>。在分析了缓存的特性和程序局部性之后，我们可以这样来充分利用高速缓存带给程序的性能提升：</p><ul><li><p>关注<strong>经常被调用的</strong>函数中<strong>执行次数最多的内层循环</strong>的性质，积极对它进行算法层面优化；</p></li><li><p>尽量使用重复的变量引用，而不是很多的全局变量（利用了时间局部性，减少 cache miss 的可能）；</p><blockquote><p>它和 第 15. 章的 CSE 优化不冲突，后者是尽量避免 Memory Alias；</p></blockquote></li><li><p>尽量使用 stride-1 reference patterns（或者说<strong>程序循环的步长尽量小</strong>，尤其是逐个访问数组元素，这就将 cache block 的优点发挥了出来，利用了空间局部性，减小 cache miss 的可能）；</p></li></ul><p><strong>总结：我们分析缓存的组织原理和特性，是进一步定量地（如上面的指标）去体现、印证程序局部性的概念</strong>。</p><h3 id="11-5-2-The-Memory-Mountain"><a href="#11-5-2-The-Memory-Mountain" class="headerlink" title="11.5.2 The Memory Mountain"></a>11.5.2 The Memory Mountain</h3><p>之前简单地对缓存组成的分析，让我们看到了关注缓存能够对程序带来较显著地性能影响。那么这节我们更深入地去探究缓存对程序性能的影响。</p><p>首先引入一个概念：</p><ul><li>Read throughput（吞吐量，或者说 read bandwidth，读带宽）：<strong>单位时间内从内存中读取数据的最大字节数</strong>，单位 MB/s；</li></ul><p>于是，我们可以绘制一个 <strong>时间局部性、空间局部性 关于 机器吞吐量的三维坐标图（存储器山）</strong>，以此展示缓存对程序性能的重要影响。</p><p>其中，我们以访问数组的程序为例。我们将遍历数组的步长作为衡量程序空间局部性的指标（步长越大，空间局部性越小），将一次读取数组元素数量作为衡量程序时间局部性的指标（一次取出的数据越多，访问到相同地址数据的机会越小，时间局部性越小）；</p><p>如图：</p><p><img src="imgs/memory_mountain.png" height="350px"></p><p>我们<strong>从读取数据量 size 的方向</strong>看图，会发现 memory mountain 有一个个像山脊一样的结构，这恰好对应了从 L1 到 Memories 的数据引用的平均性能（小的数据量更有可能在每次遍历时放在同一个缓存的 block 中，发生 cache miss 的机会就更小，只需要依靠更接近寄存器层级的缓存设备就能得到答案）；</p><p><img src="imgs/space-loc-stat.png" height="350px"></p><p>而<strong>从数组访问步长 stride 的方向</strong>看图，会发现随着步长的增加，整体有一个负向的斜率。而随着步长大到一定程度，负向的斜率趋于平缓，这是因为<strong>步长大过了缓存 block size，导致几乎每次都会存在 Cache miss，就很难得到缓存的增益了</strong>。</p><p><img src="imgs/temporal-loc-stat.png" height="350px"></p><h3 id="11-5-3-Writing-Cache-Friendly-Code-Ⅱ-Rearranging-loops-to-improve-spacial-locality"><a href="#11-5-3-Writing-Cache-Friendly-Code-Ⅱ-Rearranging-loops-to-improve-spacial-locality" class="headerlink" title="11.5.3 Writing Cache Friendly Code Ⅱ - Rearranging loops to improve spacial locality"></a>11.5.3 Writing Cache Friendly Code Ⅱ - Rearranging loops to improve spacial locality</h3><p>借助上面对于 memory mountain 的进一步分析，我们还可以想到更多的具体<strong>利用缓存来优化程序性能的方法</strong>。</p><p>例如，我们<strong>以矩阵乘法运算为例</strong>，我们假定以下的条件：</p><ul><li>N × N 方阵，元素为 double（8 bytes）类型；</li></ul><p>那么按照正确的一般矩阵相乘的方法，总单位运算次数 $O(N^3)$；</p><p>事实上，计算的一般方法有许多种（但都是 结果矩阵 $C=(c_{ij})_{N\times N}$ 的元素 $c_{ij}=a_{ik}\cdot b_{kj}$），我们<strong>这里着重讨论缓存的效率受代码安排的影响，也即，什么样的矩阵乘法最能充分利用缓存</strong>。</p><p>首先来对不同策略的矩阵乘法分析 Miss Rate：</p><ul><li>前提假设<ul><li>机器缓存空间的 <strong>块大小（<code>B</code>）为 32 Bytes（能够一次性放下 4 个 double 数据）</strong>；</li><li>矩阵维度 <code>N</code> 非常大（$\dfrac{1}{N}\approx0$）;</li><li>缓存空间的总大小不足以装下矩阵的多个行；</li></ul></li><li>分析方法：<strong>检查内层循环的函数访问模式</strong>（因为外层循环次数不可避免）；</li></ul><p>由于运算的方式固定，我们可以通过更换内外层循环顺序（共 $3!=6$ 种）来看究竟哪种方法最好。</p><p>在分析前，先再次回顾一下 C 中数组的 memory layout：</p><ul><li>二维数组的<strong>至少每一行的数据空间是 contiguous 的</strong>，并且<strong>行优先（row major）</strong>；</li><li>stride-1 逐个访问数组行的方法最能利用 spacial locality，它的 $miss\space rate=\dfrac{sizeof(a_{ij})}{B}$，其中 $B$ 是缓存空间的块大小；</li><li>stride-1 逐个访问较大数组列的方法完全无法利用 spacial locality，因为 每一列同一行的元素一定不在同一个缓存数据块中（之前已经假设 “缓存空间的总大小不足以装下矩阵的多个行”），因此 miss rate = 1（100% cache miss）；</li></ul><p><strong>情况 1：先固定 i（A 的行），再固定 j（B 的列），最后遍历 k（A 第 i 行每一列、B 第 j 列每一行）</strong></p><p><img src="imgs/cache_analysis_matrix_multiply_ijk.png" height="200px"></p><p>这种情况下，<strong>对每一个最内层循环</strong>：</p><ul><li>每次要求从内存中取出 A 矩阵的同行相邻元素，<strong>miss rate = 8 / 32 = 0.25</strong>；</li><li>每次要求从内存中取出 B 矩阵的同列相邻元素，<strong>miss rate = 1</strong>；</li><li>每次要求从内存中取出 C 矩阵的一个元素，所以对单个元素而言 <strong>miss rate 近似为 0</strong>；</li></ul><p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 0 次，cache miss 次数 1.25 次</strong>；</p><p>这种情况与 <strong><code>jik</code></strong> 顺序的情况相同；</p><p> <strong>情况 2：先固定 k（B 的行），再固定 i（A 固定位置 第 i 行 第 k 列），最后遍历 j（C 的第 i 行每一列）</strong></p><p><img src="imgs/cache_analysis_matrix_multiply_kij.png" height="175px"></p><p>这种情况下，<strong>对每一个最内层循环</strong>：</p><table>    <tr>        <th>Op Matrix</th>        <td>A</td>        <td>B</td>        <td>C</td>    </tr>    <tr>        <th>Miss Rate</th>        <td>0.0</td>        <td>0.25</td>        <td>0.25</td>    </tr></table><p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 1 次，cache miss 次数 0.5 次</strong>；</p><p>这种情况与 <strong><code>ikj</code></strong> 顺序的情况相同；</p><p><strong>情况 3：先固定 j（C 的第 j 列每一行），再固定 k（A 的第 k 列），最后遍历 i（固定 B 遍历 C 的 列）</strong></p><p><img src="imgs/cache_analysis_matrix_multiply_jki.png" height="175px"></p><p>这种情况下，<strong>对每一个最内层循环</strong>：</p><table>    <tr>        <th>Op Matrix</th>        <td>A</td>        <td>B</td>        <td>C</td>    </tr>    <tr>        <th>Miss Rate</th>        <td>1.0</td>        <td>0.0</td>        <td>1.0</td>    </tr></table><p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 1 次，cache miss 次数 2.0 次</strong>；</p><p>这种情况与 <strong><code>kji</code></strong> 顺序的情况相同；</p><hr><p>综合上面的三种情况，我们进行实际的测试，发现结果如我们所料：</p><p><img src="imgs/core_i7_matrix_multiply_perf.png" height="300px"></p><p>事实证明，<strong><code>kij/ikj</code> 遍历方法（固定 A / B 的位置，遍历剩下一个运算矩阵的行，来得到结果矩阵的行）是最能利用 cache memories 的优势的方法</strong>，而我们最常用的 <code>ijk</code> 方法却不是最好的方法。</p><h3 id="11-5-4-Writing-Cache-Friendly-Code-Ⅲ-Using-blocking-to-improve-temporal-locality"><a href="#11-5-4-Writing-Cache-Friendly-Code-Ⅲ-Using-blocking-to-improve-temporal-locality" class="headerlink" title="11.5.4 Writing Cache Friendly Code Ⅲ - Using blocking to improve temporal locality"></a>11.5.4 Writing Cache Friendly Code Ⅲ - Using blocking to improve temporal locality</h3><p>上一节的例子主要以矩阵乘法为例，从提升<strong>空间局部性</strong>的层面来充分利用缓存、提示程序缓存效率。本节将从另一个角度——提升程序<strong>时间局部性</strong>来讨论如何写出缓存友好的代码。</p><p>再举一个针对矩阵乘法的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="type">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmm</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                c[i*n + j] += a[i*n + k] * b[k*n + j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的乘法而言，我们作如下假设：</p><ul><li>机器缓存空间的 <strong>块大小（<code>B</code>）为 64 Bytes（能够一次性放下 8 个 double 数据）</strong>；</li><li>矩阵维度 <code>N</code> 非常大（$\dfrac{1}{N}\approx0$）;</li><li>缓存空间的总大小不足以装下矩阵的多个行；</li></ul><p>在这种情况下，最内层的循环中，每一个循环的 cache miss 平均次数为：$\dfrac{n}{8}+n=\dfrac{9}{8}n$，于是总的 cache miss 的数量在 $\dfrac{9n^3}{8}$ 左右，显然，这样的 cache miss 数量会显著影响程序性能和对缓存的利用。于是，一种利用时间局部性的方法就出现了：</p><p><strong>我们在每次内存循环取矩阵乘法的 $C$ 的单元的时候，将单独取一个改为选取一个 block（小型块），如图所示，block 的宽度为 $B$：</strong></p><p><img src="imgs/multi_simple.png" height="150px"></p><p>改为：</p><p><img src="imgs/multi_block.png" height="150px"></p><p>即计算代码改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="type">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmm</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i+=B)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j+=B)</span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k+=B)</span><br><span class="line">                    <span class="comment">/* B x B mini matrix multiplications */</span></span><br><span class="line">                    <span class="keyword">for</span> (i1 = i; i1 &lt; i+B; i1++)</span><br><span class="line">                        <span class="keyword">for</span> (j1 = j; j1 &lt; j+B; j1++)</span><br><span class="line">                            <span class="keyword">for</span> (k1 = k; k1 &lt; k+B; k1++)</span><br><span class="line">                                c[i1*n+j1] += a[i1*n + k1]*b[k1*n + j1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们再次分析 cache miss 的情况。</p><p>假设选取的 $B$ 的大小能够被缓存利用：$3B^2\lt C$，那么：</p><ul><li><p>每一个 sub-block（子块）内部的 cache miss 数量：$\dfrac{B^2}{8}$；</p></li><li><p>每一次行循环的 cache miss 数：$\dfrac{2n}{B}\cdot\dfrac{B^2}{8}=\dfrac{nB}{4}\sim O(nB)$；</p></li><li>总的 cache miss 数：$\dfrac{nB}{4}\cdot(\dfrac{n}{B})^2=\dfrac{n^3}{4B}$；</li></ul><p>总而言之，这样的改进并没有根本上提升算法的时间复杂度，但是它却能确确实实地减少常数级别的 cache miss 数量（$\dfrac{9}{8}n^3\rightarrow\dfrac{1}{4B}n^3$），在一定程度上达到提升时间局部性的效果。这样，只要我们选择满足 $3B^3\lt C$ 的最大的 $B$ 的取值，就能找到这种思路的最优计算方法。</p><p>为什么能够引起如此大的常数优化呢？主要是以下原因：</p><ul><li>我们在选取 block 的时候，相当于加载了一个地址上更相邻的、之后能被反复使用的变量，因为我们缩小了矩阵乘法的 $N$，逐个 block 攻破，这样的矩阵乘法更能利用时间局部性；<ul><li>输入数据 $3n^2$，计算 $2n^3$，而每个元素需要被使用 $O(n)$ 次；</li></ul></li></ul><h3 id="11-5-5-Cache-Performance-Summary"><a href="#11-5-5-Cache-Performance-Summary" class="headerlink" title="11.5.5 Cache Performance Summary"></a>11.5.5 Cache Performance Summary</h3><p>在 11.5 节中，我们通过几个例子了解到，<strong>虽然我们无法显式控制 cache 的存储方式，但是通过对于程序局部性的分析，我们可以更高效地利用 cache，从而提升程序允许效率。</strong>这主要可以从两个方面下手：</p><ul><li>使用 stride-1 reference pattern、关注内层循环的步长和方式，以提升程序的空间局部性；</li><li>多次使用相同的局部变量、分块访问，以提升程序的时间局部性；</li></ul><h1 id="Chapter-12-Program-Optimization"><a href="#Chapter-12-Program-Optimization" class="headerlink" title="Chapter 12. Program Optimization"></a>Chapter 12. Program Optimization</h1><blockquote><p>One of the themes for this chapter: </p><ul><li>去除程序不必要的工作、编写编译器友好代码、提升运行速度；</li><li>利用机器代码特性，针对特定机器对程序优化；</li></ul></blockquote><p>编译器无法理解一些内容，例如 int 数据类型可能只用到相当小的范围、procedure call 究竟是什么意思，等待。编译器只是针对一些特定情况，对照 “cookbook” 进行有选择地优化。其遇到复杂或者特殊情况的 “保底” 方案是不对代码进行优化。</p><p>初始思路：查看程序汇编代码哪些地方没被优化，找到对应的源码部分进行重写，直至重构成编译器友好代码（只要不过度牺牲程序可读性就行）。</p><h2 id="12-1-Goals-of-Optimization"><a href="#12-1-Goals-of-Optimization" class="headerlink" title="12.1 Goals of Optimization"></a>12.1 Goals of Optimization</h2><ul><li>Minimize number of instructions<ul><li>避免重复计算；</li><li>避免不必要的计算；</li><li>避免较大计算量的操作（例如乘、除）；</li></ul></li><li>Avoid waiting for memory<ul><li>尽量将数据和运算过程放在 register 中，而非内存中；</li><li>使用 cache-friendly 的方式访问内存；</li><li>尽早从内存加载数据，并且加载次数越少越好；</li></ul></li><li>Avoid branching<ul><li>不要写出不必要的判断结构；</li><li>写成让 CPU 容易预测分支的代码（流水线）；</li><li>尽量解开循环，分摊分支的开销；</li></ul></li><li>Make good use of locality &amp; cache: 写出程序局部性良好的代码、充分利用缓存机制（10.2 &amp; 11.X）；</li></ul><h2 id="12-2-Limits-to-Compiler-Optimization"><a href="#12-2-Limits-to-Compiler-Optimization" class="headerlink" title="12.2 Limits to Compiler Optimization"></a>12.2 Limits to Compiler Optimization</h2><ul><li><p>无法优化算法的渐进时间复杂度；</p></li><li><p>绝不会改变程序语义、行为；</p></li><li><p>编译时仅仅分析每个函数一次（inline 函数除外）；</p><blockquote><p>目前 Whole-program analysis (“LTO”) 比较受欢迎，尽管开销很大；</p></blockquote></li><li><p>无法很好地针对运行时的输入内容进行优化</p><ul><li>可能出现最坏情况，尤其是面对非法输入的时候；</li></ul></li></ul><h2 id="12-3-Generally-Useful-Optimizations"><a href="#12-3-Generally-Useful-Optimizations" class="headerlink" title="12.3 Generally Useful Optimizations"></a>12.3 Generally Useful Optimizations</h2><blockquote><p>本部分的优化技巧不针对特定的编译器或者处理器，具有普适性。</p><p>绝大多数编译器在一定的优化等级下，都能优化本节的情况，但是我们应该学习这些方法。</p><p>注：一个能看到优化过程的网站：<a href="https://godbolt.org/z/Es5s8qsvj">COMPILER EXPLORER</a></p></blockquote><p>根据 12.1 中的目标，我们可以整理出一些常见的情况，这些情况下编译器能够优化，或者说具有普适性的优化策略，主要有以下两类：</p><ul><li>Local Optimizations (<strong>work inside a single basic block</strong>)<ul><li>Constant folding（常数折叠）</li><li>Strength reduction（计算强度削减）</li><li>Dead code elimination（死代码剔除）</li><li>Local CSE（Local Common Subexpression Elimination，局部的相似子表达式复用）</li><li>……</li></ul></li><li>Global Optimizations (<strong>process the entire control flow graph of a function</strong>)<ul><li>Loop transformations（循环结构转换）</li><li>Code motion（代码移动）</li><li>Inlining（内联化）</li><li>Global CSE（全局的相似子表达式复用）</li></ul></li></ul><p>这章仅仅叙述它们的思路，不涉及具体实现，因为具体实现就涉及到编译原理（AST 语法树等知识）；</p><h3 id="12-3-1-Constant-Folding"><a href="#12-3-1-Constant-Folding" class="headerlink" title="12.3.1 Constant Folding"></a>12.3.1 Constant Folding</h3><p>常数折叠的方法主要有以下几个方面：</p><ul><li><p>直接运算代码中的常数表达式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> mask = <span class="number">0xFF</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 优化为：</span></span><br><span class="line"><span class="type">long</span> mask = <span class="number">0xFF00</span>;</span><br></pre></td></tr></table></figure></li><li><p>直接运算一切可以常量化的表达式，例如针对常量调用的库函数、常量输入等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> namelen = <span class="built_in">strlen</span>(<span class="string">&quot;Harry Bovik&quot;</span>);</span><br><span class="line"><span class="comment">// 优化为：</span></span><br><span class="line"><span class="type">size_t</span> namelen = <span class="number">11</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-3-2-Dead-Code-Elimination"><a href="#12-3-2-Dead-Code-Elimination" class="headerlink" title="12.3.2 Dead Code Elimination"></a>12.3.2 Dead Code Elimination</h3><p>死代码删除方法的思路主要来源于 12.1 中的 “Avoid Branching” 和 “Minimize number of instructions”，分为以下几种情况：</p><ul><li><p>删除语义上不可能执行到的代码（无效代码）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Hello, 0&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Hello, 1&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Hello, 1&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除结果被覆盖的代码（也是无效代码）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">23</span>; x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">x = <span class="number">42</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这类优化方式看起来很蠢，但也很重要，因为有时候这些死代码不容易被肉眼识别，或者在编译器进行其他优化过程中，在语义树上出现了，那么就需要这种方法来清理。</p><h3 id="12-3-3-Common-Subexpression-Elimination"><a href="#12-3-3-Common-Subexpression-Elimination" class="headerlink" title="12.3.3 Common Subexpression Elimination"></a>12.3.3 Common Subexpression Elimination</h3><p>CSE 的思路就是根据 AST 树的特征，约去<strong>重复计算</strong>，从而降低运算量，例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处展示的是 Local CSE */</span></span><br><span class="line"></span><br><span class="line">up = val[(i<span class="number">-1</span>)*n + j];</span><br><span class="line">down = val[(i+<span class="number">1</span>)*n + j];</span><br><span class="line">left = val[i*n + j - <span class="number">1</span>];</span><br><span class="line">right = val[i*n + j + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以改为：</span></span><br><span class="line"><span class="type">long</span> inj = i*n + j;</span><br><span class="line">up = val[inj - n];</span><br><span class="line">down = val[inj + n];</span><br><span class="line">left = val[inj - <span class="number">1</span>];</span><br><span class="line">right = val[inj + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">norm[i] = v[i].x * v[i].x + v[i].y * v[i].y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">elt = &amp;v[i];</span><br><span class="line">x = elt-&gt;x;</span><br><span class="line">y = elt-&gt;y;</span><br><span class="line">norm[i] = x * x + y * y;</span><br></pre></td></tr></table></figure><h3 id="12-3-4-Code-Motion"><a href="#12-3-4-Code-Motion" class="headerlink" title="12.3.4 Code Motion"></a>12.3.4 Code Motion</h3><p>I.e., reduce frequency with which computation performed（也是降低代码重复运算频率，不过是在 global 范围进行）</p><ul><li><p>If it will always produce same result（这种改动<strong>语义不变</strong>）；</p></li><li><p>Especially moving code out of loop（常见于将代码移出循环结构，但为了保持语义，要求移动的代码在每次循环中的结果不变）；</p></li><li><p>Example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_row</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> i, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        a[n*i + j] = b[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为（将 n*i 这个与循环无关的变量提出循环，避免重复运算）：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_row</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> i, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">int</span> ni = n * i;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        a[ni + j] = b[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-3-5-Inlining"><a href="#12-3-5-Inlining" class="headerlink" title="12.3.5 Inlining"></a>12.3.5 Inlining</h3><p>I.e., copy body of a function into its caller(s);</p><p>对于一些短的、计算开销小的非递归函数，即便编程人员不指定 <code>inline</code> 关键字，编译器也应该识别到并且内联操作。这样做的好处有两点：</p><ul><li>消除函数调用的栈帧分配开销；</li><li>为其他许多优化方法<strong>创造条件</strong>。例如，对代码中的一些函数内联，可以被编译器找到例如 dead code elimination、constant fold 的机会；</li></ul><p>这是个例子：</p><p><img src="imgs/inlining_example1.png"></p><p>缺点：</p><ul><li>这种优化方法在某些情况下（内联函数很长、开销很大）会导致整体代码空间占用变大、速度降低；</li><li>对调试工具、profiling 工具不友好；</li></ul><h3 id="12-3-6-Strength-Reduction"><a href="#12-3-6-Strength-Reduction" class="headerlink" title="12.3.6 Strength Reduction"></a>12.3.6 Strength Reduction</h3><p>I.e., replace costly operation with simpler one.（计算量减小）</p><ul><li>可以用移位、加法尽量代替乘法、除法（优化的比例取决于不同的机器）；</li></ul><h2 id="12-4-Obstacles-for-Compiler-to-Optimization"><a href="#12-4-Obstacles-for-Compiler-to-Optimization" class="headerlink" title="12.4 Obstacles for Compiler to Optimization"></a>12.4 Obstacles for Compiler to Optimization</h2><p>现在反过来看，有哪些操作会阻碍编译器优化？</p><p>阻碍编译器优化的原因之一就是期间调用了其他函数，这样 gcc 可能就无法识别到优化方法。还有一个主要原因就是 “内存别名” 的存在。</p><h3 id="12-4-1-Optimization-Blocker-1-Procedure-Calls"><a href="#12-4-1-Optimization-Blocker-1-Procedure-Calls" class="headerlink" title="12.4.1 Optimization Blocker #1: Procedure Calls"></a>12.4.1 Optimization Blocker #1: Procedure Calls</h3><p>典型例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，循环判断条件中有一个函数 <code>strlen(s)</code>，我们都知道这是计算字符串长度的函数。但是<strong>编译器不知道</strong>，它认为<strong>这个函数有可能在每次循环中，返回值可能改变</strong>，所以不会把它优化为一个常数，而是保持<strong>每次循环判断时，都重新调用 <code>strlen(s)</code></strong>。</p><p>可是，<code>strlen(s)</code> 的复杂度是  $O(n)$ 啊！这样好端端的 $O(n)$ 能实现的函数被硬生生干成了 $O(n^2)$ ……</p><p>所以，正确的做法是，先把 <code>strlen(s)</code> 算出来。更好的主意是，<strong>干脆不使用 <code>strlen()</code>，因为判断字符串结束原本就是能在循环中发现的情况</strong>，并且把数组索引改成指针取值，这样还能再节省常数时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *s &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            *s -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回过头来，为什么绝大多数的编译器没法优化这种 procedure calls 的情况？主要有几点原因：</p><ul><li>Procedure may have side effects; 就像前面说的，编译器不知道运行这个 procedure 会不会改变当前环境中其他变量的值，所以不敢贸然改变 procedure 运行顺序；</li><li>Procedure 会出现重载、重写的情况，这些函数有不同版本，可能分布在不 同文件中，只有编译结束，链接的时候才知道最终用的函数是谁。对于虚函数而言，甚至要在运行时才知道调用的是哪一个同名函数；所以更不敢随意判断某个 procedure 的作用，也就无法解决上面的问题；</li><li>如果全面分析所有同名 procedure，并且找到它们的含义、作用，那么编译开销过大，非常不现实；</li></ul><p>综上，编译器一般的做法是<strong>将 procedure 看作一个黑盒，行为不确定，所以一般不会优化它的执行顺序</strong>。因此，开发者应该清楚意识到函数的作用，并且重视它执行的位置对代码性能的影响。</p><h3 id="12-4-2-Optimization-Blocker-2-Memory-Aliasing"><a href="#12-4-2-Optimization-Blocker-2-Memory-Aliasing" class="headerlink" title="12.4.2 Optimization Blocker #2: Memory Aliasing"></a>12.4.2 Optimization Blocker #2: Memory Aliasing</h3><p>先看示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sum rows is of n x n matrix a and store in vector b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum_rows1</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        b[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">               b[i] += a[i*n + j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看起来性能上没什么问题，大多数人都会如此实现代码。但是我们看看对应的 x86-64 汇编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># sum_rows1 inner loop</span><br><span class="line">.L4:</span><br><span class="line">    movsd(%rsi,%rax,8), %xmm0# FP load</span><br><span class="line">    addsd(%rdi), %xmm0# FP add</span><br><span class="line">    movsd%xmm0, (%rsi, %rax, 8)# FP store</span><br><span class="line">    addq$8, %rdi</span><br><span class="line">    cmpq%rcx, %rdi</span><br><span class="line">    jne.L4</span><br></pre></td></tr></table></figure><p>我们发现，小小的 <code>b[i] += a[i*n + j]</code> 竟然有两次对内存的操作（从内存读到寄存器，计算后再写回内存），为什么会这样？为什么不直接在内存中计算？</p><p>这是因为 <strong>Memory Alias（内存别名）在 C 中是允许的</strong>。比如，如果我这么调用 <code>sum_rows1</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> A[<span class="number">9</span>] =</span><br><span class="line">    &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">          <span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,</span><br><span class="line">         <span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* B = A+<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">sum_rows1(A, B, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>那么，第二参数 <code>B</code> 就是 <code>A</code> 的一部分的<strong>内存别名</strong>，也就是说，程序有两个指针指向一块内存地址，这样的话，在每次 <code>B[i] = 0</code> 后，就会改变 <code>A</code> 的内容，从而改变求和的值。因此编译器仍然不敢直接优化。</p><p>问题在于，我们知道这个函数的作用是数组列求和，我们不会传入两个内存别名。但是编译器不知道——因为要检查所有的 memory alias 开销也非常大，所以编译器默认程序中都存在内存别名。</p><p><strong>所以解决方法是</strong>，我们暗示编译器这里不会有内存别名导致循环中数组值的更改：<strong>在求和时不直接加到 <code>b</code> 中，而是以临时局部变量存储，求和循环结束后同一赋值给 <code>b</code></strong>，这样在一次求和循环中编译器就不会重复从内存读取信息了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sum rows is of n x n matrix a and store in vector b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum_rows1</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">double</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">               val += a[i*n + j];</span><br><span class="line">        b[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样内层求和循环的汇编码就变得简单了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># sum_rows1 inner loop</span><br><span class="line">.L10:</span><br><span class="line">    addsd(%rdi), %xmm0# FP load + add</span><br><span class="line">    addq$8, %rdi</span><br><span class="line">    cmpq%rax, %rdi</span><br><span class="line">    jne.L10</span><br></pre></td></tr></table></figure><blockquote><p>实际上，内存读写仍然是耗时大头，所以改写后性能提升不会非常明显。</p></blockquote><p>对开发者而言，应该习惯于在循环前引入一些局部变量（<strong>Accumulate in temporary</strong>），尤其是含有数组索引的循环，这样能够暗示编译器按照没有内存别名的情况处理。</p><p>总结一下就是：</p><ul><li>多使用临时局部变量来存放中间值，尤其是在循环中；</li><li>使用更严格的关键字，例如 <code>int[]</code> 好过 <code>int*</code> 来让编译器知道不会有 memory alias；</li></ul><p>上面的几种优化技巧都是比较简单和零碎的，不宜死记硬背，应该贯通在实践当中。下面从另一个角度考虑优化问题。</p><h2 id="12-5-Machine-Dependent-Optimization"><a href="#12-5-Machine-Dependent-Optimization" class="headerlink" title="12.5 Machine-Dependent Optimization"></a>12.5 Machine-Dependent Optimization</h2><blockquote><p>这类优化取决于处理器机器和系统，根据汇编处理方式进行优化。</p></blockquote><p>表面上与机器无关的优化方法都考虑得差不多了，但在机器层面还有一些优化的方法。为了考虑这些方法，我们需要先了解机器的简单组成和基本运作原理。下面是上个世纪末的处理器的大概的设计样式：</p><p><img src="imgs/modern_CPU_design.png" height="400px"></p><p>底层机制过于复杂，一般人短时间内几乎不可能理解，所以这里仅仅浅浅介绍一下。</p><p>CPU 执行代码时，借助了多种方法和技术，构建了健全的硬件设施，使得其执行指令的速度远远快于一条一条读取执行的速度。其中一种技术被称为 “超标量乱序执行” 技术（super-scalar out of order execution），它的思路可以理解为：CPU 一次性读入大量机器指令，再将顺序的指令拆开，发现逻辑上某两句间不相互依赖，于是 CPU 可以不按顺序、尽可能多地同时执行这些代码。</p><blockquote><p>Superscalar（超标量）</p><ul><li>每个时钟周期执行多个操作；</li><li>指令级并行（CPU 自主发现指令间依赖关系，并行执行没有依赖关系的指令）；</li></ul><p>Out-of-order execution（乱序执行）</p><ul><li><strong>Instruction Control Unit (ICU)</strong>: Fetch / Decode / Write Back; <strong>Execution Unit (EU)</strong>: Execute / Memory;</li><li>Fetch Control: Branch Prediction（比 Y86-64 的更高级） + Speculative Execution;</li><li>Instruction Decode</li></ul></blockquote><p>指令的这种特性被称为 <strong>指令级并行性（instruction level parallelism）</strong>；</p><p>上图的 Instruction Control 展示了 CPU 如何从高速缓存中抓取指令，并放入运算单元的。<strong>注意，这里所有的操作都使用缓存和寄存器</strong>，因为其他储存介质（包括内存）都太慢了。</p><p>上面<strong>在一个时钟周期中处理、执行多条指令的处理器</strong>被称为 Super-scalar Processor，它们通常一次性获取一串指令流，并动态地进行调度和执行。它的好处是 <strong>充分利用了代码中的指令级并行性</strong>，所以大多数现代 CPU 都是超标量的，并且现代 CPU 的执行模型也几乎都是乱序执行的模型。</p><p>现代 CPU 的策略是乱序执行，固然非常复杂，比之前讨论过的按序执行的<strong>流水线（pipelining）</strong> 更复杂。</p><p>流水线的基本思想是，<strong>处理器将每个计算分解为一系列不同阶段，每个阶段都有一个专用硬件可以独立完成。于是，当一个计算阶段的硬件空闲下来时，就可以接受下一个数据的计算工作</strong>。</p><p>其中，除法运算无法被分解在流水线上进行，一次操作 3 ~ 30 个时钟周期，所以是一个昂贵的操作。</p><blockquote><p>这些并行性都是单个 CPU 的单核的并行性，不涉及多核并行。</p></blockquote><p>总的来说，在机器层面上，程序的优化上限有两点：</p><ol><li><p>Latency Bound: 当 一系列指令被执行时必须按照严格的顺序进行 时，也就是说后一条指令依赖前一条的结果，此时程序的性能会受到限制。<strong>这种瓶颈（data dependency）限制了指令级别的并行性</strong>（没有 Y86-64 的 data forwarding）；</p><blockquote><p>其计算方法就是，<strong>一条指令 / 操作 最原本的 latency 时延，与承载量无关</strong>；</p></blockquote></li><li><p>Throughout Bound：处理器的运算单元所能达到的最大承载量（computing capacity，通常与对应运算单元数目、运算单元种类有关），这也是程序性能的最终上界。</p></li></ol><hr><p>接下来，借助流水线的知识，我们再分析一下现代处理器内部各个模块是如何进行协作的，以便我们针对特定机器进行优化。</p><p>对于现代处理器，主要就分为以上的两个部分：Instruction Control Unit &amp; Execution Unit。其中  Instruction Control Unit 的主要结构如下：</p><p><img src="imgs/ICU.png" height="200px"></p><ul><li><p>对于 Fetch Control Logic，采用的技术就类似在流水线中介绍的 Branch Prediction + Speculative Execution；</p><blockquote><p>前者（branch mis-prediction）表示一种预测下一条指令位置的技术（是否选择分支的策略、预测目标分支的策略）；后者（speculative execution）表示在分支预测后，还没有确定是否正确就立即取出预测位置的指令进行执行。如果后面检查出现错误，则恢复到原先的状态；</p></blockquote></li><li><p>对于 Instruction Decoding Logic，它的工作就有些不一样。为了充分利用指令集并行资源，该逻辑块：</p><ul><li><p>将传入的指令数据继续分解为 primitive instructions，每个 primitive instruction 都存在更简单的算术、加载、存储的任务，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addq %rax, 8(%rdx)</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">load 8(%rdx) -&gt; t1</span><br><span class="line">addq %rax, t1 -&gt; t2</span><br><span class="line">store t2, 8(%rdx)</span><br></pre></td></tr></table></figure><p>下一步，为了方便交给下面的 Execution Unit 进行并行运算，中间存在一个 <strong>寄存器重命名</strong> 的步骤（后面再描述具体原因），根据原本一条指令所对应的 primitive instructions 用到的临时寄存器，<strong>按使用依赖关系对版本进行编号</strong>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">    .L25:         # Loop:</span><br><span class="line">    vmulsd (%rdx),%xmm0,%xmm0     # t *= data[i]</span><br><span class="line">    addq $8, %rdx         # Increment data+i</span><br><span class="line">    cmpq %rax,%rdx         # Comp to data+len</span><br><span class="line">    jne .L25         # if !=, goto Loop</span><br><span class="line">            |</span><br><span class="line">            v</span><br><span class="line">    load (%rdx.0)       -&gt; t.1</span><br><span class="line">    mulq t.1, %xmm0.0   -&gt; %xmm0.1</span><br><span class="line">    addq $8, %rdx.0     -&gt; %rdx.1</span><br><span class="line">    cmpq %rax, %rdx.1   -&gt; cc.1</span><br><span class="line">    jne-taken cc.1</span><br><span class="line"></span><br><span class="line">而 Execution Unit 部分的主要结构如下图所示：</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;imgs/EU.png&quot; height=&quot;200px&quot;&gt;</span><br><span class="line"></span><br><span class="line">我们发现这里存在很多单独的运算单元，可以从 ICU 部分接收更多指令（$\mu$ code，即上面的 primitive instructions），并行进行不同种类 $\mu$ code 的运算。</span><br><span class="line"></span><br><span class="line">Data Cache 是存放最近访问的 / 临时的数据的地方。遵循 Memory Hierarchy，支持 EU 运算单元的快速存取，稍晚些时候会根据情况向 ICU 的 register files  以及 memory 写入数据。</span><br><span class="line"></span><br><span class="line">此外，Branch 模块不是用来运算某个分支是否应该跳转，而是用来计算分支预测是否正确。若预测错误，则 Branch 会通知丢弃该分支中执行得到的所有数据（利用 ICU 中的 Retirement Unit 不允许错误数据写入，并通知 Data Cache 标记无效数据），否则保留数据并写入；</span><br><span class="line"></span><br><span class="line">同时，ICU 中的 Retirement Unit 跟踪当前过程所有正在执行的指令，确保数据存取符合 sequential 语义。大致逻辑如下：</span><br><span class="line"></span><br><span class="line">当一个指令被 decode，它的信息会被放入一个 FIFO 队列中，直到两种情况之一才会从队头出队：</span><br><span class="line"></span><br><span class="line">1. Retirement Unit 发现该指令的所有 primitive instructions 被执行完，并且所有涉及通向该指令的 branch prediction 都是正确的，这条指令才会被 “retired”，结果写入程序寄存器中；</span><br><span class="line">2. 如果 Retirement Unit 发现该指令途中某个 prediction 是错误的，那么这个指令会被 “flushed”，计算结果会被抛弃，不会写入寄存器中。</span><br><span class="line"></span><br><span class="line">&gt; 注：上图所描述的 “Arithmetic Operation” 单元是被特化来执行整型、浮点型的不同组合的运算的（就是说，这些单元能执行多种不同操作，例如既能整型运算又能浮点型运算）。这样不致于程序对硬件资源的利用率不好。</span><br><span class="line"></span><br><span class="line">那么，“乱序执行” 技术如何实现？很简单，在 ICU 的 Instruction Decode Logic 给出 $\mu$ code 后，由于 $\mu$ code 的临时寄存器只需要记住版本，可以随意选取，因此设计了一个类似任务队列的指派单元，将上面发出的 $\mu$ code 根据**当前 EU 硬件空余情况**分发下去执行。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;imgs/ICU-dispatch.png&quot; height=&quot;200px&quot;&gt;</span><br><span class="line"></span><br><span class="line">**为了加速一条指令到另一条指令的结果传送，处理器引入了一个机制，就是提到的 “寄存器重命名”。这些信息被共享在 renaming table 中（如上图下方的一条长横线）。当运算单元接到 $\mu$ code 后，会立即进行运算（非依赖地并行），将寄存器名、版本号组成的 二元组 $(u,t)$ 写入这个列表中**。</span><br><span class="line"></span><br><span class="line">&gt; 注：这个表维护每个寄存器 $u$ 与更新的重命名版本标记 $t$ 之间的关系。</span><br><span class="line">&gt;</span><br><span class="line">&gt; &lt;u&gt;这个表只包含未 “退役” 的寄存器条目。如果指令在表中没找到某个寄存器，那么说明值在寄存器文件中&lt;/u&gt;，需要的指令这时才会向寄存器文件请求查找。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 每当 Branch 确定了分支结果后，才会通知 retirement unit 将正确的分支上运行的结果写入寄存器。这个时候也会重整 renaming table；</span><br><span class="line"></span><br><span class="line">等待某个版本 $t$ 的指令可以在表中得到数据，这种方式就是一种形式的 “数据转发”（比 Y86-64 的 data forwarding 更快）。&lt;u&gt;通过这种机制，能让依赖前一操作的操作尽快开始，而不需要存入寄存器文件再读出来。&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">&gt; 这个 renaming table 就避开了 Y86-64 中的 control hazard，即便 branch prediction 还没有验证、不能更改程序寄存器，也依然能临时存放一些计算好的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最后，为了定性分析其中的运算效率，我们定义：</span><br><span class="line"></span><br><span class="line">- Issue Time（发送时延）：一个 $\mu$ code 从 ICU 发向 EU 的一个运算单元后，下一条 $\mu$ code 被发送到同一运算单元的时间间隔（硬件限制）；</span><br><span class="line"></span><br><span class="line">- Latency（延迟）：在一个 $\mu$ code 被发送到指定运算单元后，该运算单元需要多长时间来运算；</span><br><span class="line"></span><br><span class="line">  &gt; latency 的计算与 capacity 无关，只与这个指令运算本身的时间有关。</span><br><span class="line"></span><br><span class="line">- Capacity（硬件承载量）：一个处理器对于某种运算，运算单元的数量。</span><br><span class="line"></span><br><span class="line">- Max Throughput（最大吞吐量）：$T=\dfrac&#123;Capacity&#125;&#123;Issue\space Time&#125;$；</span><br><span class="line"></span><br><span class="line">- Throughput Bound（吞吐量界限）：最大吞吐量的倒数，描述了 **执行一条指令在吞吐量的限制下，需要的时间界限**；</span><br><span class="line"></span><br><span class="line">- Latency Bound（延迟界限）：等于延迟本身。描述了 **顺序执行一条指令（就是延迟的限制下）的时间界限**。</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;imgs/intel-instr-metrics.png&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  &gt; 如上图，我们从 `Intel Core i7 Haswell` 处理器的指标可以发现，Add / Multi 在 Latency &gt;= 1 的情况下，仍然有 Issue Time = 1，说明内置了流水线技术。并且，可以通过 Latency 反推流水线有多少个 stages。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 我们还发现，divider 没有内置流水线，因为 Issue Time = Latency Time，**这说明了一个除法运算不能被分割成多个 stages，必须等待前一个计算完成才能继续计算下一个**；</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 同时，不同种类的除法运算（如数据类型）耗时不同，相同点是耗时很长。</span><br><span class="line">  </span><br><span class="line">  &lt;img src=&quot;imgs/ops-CPE.png&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  这个图的数据就是由上一个图的信息得到的。所有运算的 latency 对应上面硬件限制的 latency time；Throughput 则是由 Capacity / Issue Time 得到的。</span><br><span class="line">  </span><br><span class="line">  **但是，虽然整型加法有 4 个运算单元，但是 Throughput 只有 0.5，主要是因为处理器最多只有 2 个 load 单元**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 12.5.0 Data-Flow Representation: Machine-level Profiling</span><br><span class="line"></span><br><span class="line">在利用我们已有对于 Modern Processor 的认识来 tuning 程序前，我们还要掌握一种分析机器指令级运算效率的图：Data-Flow 图。</span><br><span class="line"></span><br><span class="line">**它展现了不同操作间数据的 dependency 是如何限制执行顺序，并形成关键路径的**。这个关键路径就是该组机器指令的执行时间下界。</span><br><span class="line"></span><br><span class="line">以一个结构体数据类型为例：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">/* data structure for vectors */</span><br><span class="line">/* we can use different declarations for data_t */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    size_t len;</span><br><span class="line">    data_t *data;</span><br><span class="line">&#125; vec;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>其中的一个函数是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retrieve vector element and store at val. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_vec_element</span><span class="params">(vec* v, <span class="type">size_t</span>, idx, <span class="type">data_t</span>* val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= v-&gt;len) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">/* Out of range. */</span></span><br><span class="line">    *val = v-&gt;data[idx];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个函数进行<strong>基准测试（Benchmark Computation）</strong>：</p><ul><li><p>测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;        <span class="comment">/* 将可能重复计算的部分提出循环 */</span></span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)    <span class="comment">/* 不使用额外的 procedure 来重复检查 v-&gt;len */</span></span><br><span class="line">        t = t OP d[i];</span><br><span class="line">    *dest = t;                    <span class="comment">/* 不直接在循环内给数组赋值，使用 local variable */</span></span><br><span class="line">&#125;                                <span class="comment">/* 暗示编译器没有 memory alias */</span></span><br></pre></td></tr></table></figure><p>我们将使用不同数据类型（<code>data_t</code> 分别是 <code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>），针对不同运算和值（<code>OP</code> 分别是 <code>+</code>、<code>*</code>，<code>IDENT</code> 分别是 0、1）；</p></li><li><p>测试指标：<strong>CPE (Cycle Per Element)</strong></p><ul><li>Convenient way to express performance of program that operates on vectors or lists.</li><li><strong>在这里，CPE 就是一个时钟周期中的进行 <code>OP</code> 运算的次数，总时长指标 <code>T = CPE * n + Overhead</code></strong>（这里 overhead 就是 n = 0 时的基础开销）；</li><li>tips: 在检查代码性能时，不应该以真实时间做单位（例如 nanosecond），应该使用处理器内部时钟周期作为单位更有用。因为开发者无法控制处理器频率，但是可以控制并衡量操作的时钟周期。</li></ul></li></ul><p>生成的机器指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L25:                                 # Loop:</span><br><span class="line">    vmulsd (%rdx), %xmm0, %xmm0# Multiply acc by data[i]</span><br><span class="line">    addq $8, %rdx # Increment data+i</span><br><span class="line">    cmpq%rax, %rdx # Compare to data+length</span><br><span class="line">    jne.L25 # If !=, goto Loop</span><br></pre></td></tr></table></figure><p>其对应的 primitive instructions 及 data-flow diagram 如下：</p><p><img src="imgs/data-flow-example.png"></p><p>我们能将这个 loop 中使用到的寄存器进行分类：</p><ul><li>read-only：只作为这个 iteration 的源值，例如这里是 <code>%rax</code>；</li><li>write-only：只作为这个 iteration 的目的地，这里没有；</li><li>local：这个 iteration 内部使用的寄存器（运算单元随取随用），比如这里的 <code>CC</code>；</li><li>loop：既作为这个 iteration 的写目的地，又作为下个 iteration 的源值，例如这里的 <code>%rdx</code>、<code>%xmm0</code>；</li></ul><p><strong>我们发现，<u>loop 类寄存器的操作链决定了这个 data-flow 的关键路径</u></strong>（因为循环不依赖的寄存器可以并在其他步骤同时执行）。</p><p>由此可以将 loop 类寄存器涉及的路径抽取出，根据依赖关系画出新的 data-flow：</p><p><img src="imgs/data-flow-example-critical.png" height="400px"></p><p>结合实验数据可知，这条链就是限制程序性能的关键。</p><p>现在我们尝试一些措施将循环 “展开”（unrolling loop），例如每个循环进行两个数组操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine5</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>)</span><br><span class="line">        t = (t OP d[i]) OP d[i+<span class="number">1</span>];        <span class="comment">/* Loop Unrolling (2x1). */</span></span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现性能结果更加接近 Latency Bound：</p><p><img src="imgs/comb5.png"></p><p>分析编译器生成的汇编代码可知，原来在一个周期中的两条运算指令的 Load 被提到前面的位置上，相当于右图：</p><p><img src="imgs/comb5-explain.png" width="450px"><img src="imgs/seq1.png" width="350px"></p><p>由于这些乘法运算仍然前后依赖，所以尽管我们进行 unrolling loop 来减小每个 iteration 造成的开销，仍然无法超过 latency bound。</p><p>那么，如果我们使用 <strong>多个循环累计变量</strong>（Separate Accumulator，奇偶元素分开计算，最后合并），就能手动提高并行性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine6</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> x0 = IDENT;</span><br><span class="line">    <span class="type">data_t</span> x1 = IDENT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Combine 2 elements at a time. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        x0 = x0 OP d[i];</span><br><span class="line">        x1 = x1 OP d[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Finish any remaining elements. */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)</span><br><span class="line">        x0 = x0 OP d[i];</span><br><span class="line">    *dest = x0 OP x1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次绘制 data-flow 图会发现，关键路径变为 2 条，意味着关键路径长度被缩短，解释如右图：</p><p><img src="imgs/comb6-explain.png" width="450px"><img src="imgs/seq3.png" width="350px"></p><p>再换一种方法，如果我们更换运算结合的顺序（被称为 <strong>Re-association Transformation</strong>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine7</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>)</span><br><span class="line">        t = t OP (d[i] OP d[i+<span class="number">1</span>]);        <span class="comment">/* re-association */</span></span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也能发现，两条乘法指令的依赖关系改变了：每两条乘法指令只有一条在关键路径上：</p><p><img src="imgs/comb7-explain.png" width="450px"><img src="imgs/seq2.png" width=350px></p><p>这两种方式（separate accumulator、re-association）都能大幅度缩短关键路径，让程序性能突破 latency 瓶颈，接近吞吐量：</p><p><img src="imgs/combs-comp.png"></p><p>如果 separate accumulator 展开 10 次，就能更大限度利用机器资源。</p><p>但是，无论是 unrolling loop，还是 separate accumulator，都有一个界限：register spilling（寄存器溢出）。如果中间步骤展开过多，超过了已有寄存器数量，<strong>这时处理器会用内存来代替，反而会降低运行效率</strong>。</p><p>此外，之前我们提到了尽管整数加法有 4 个器件，但 throughput 不会超过 0.5，是因为 load/store 的约束。而我们之前看到的例子中，load 似乎不在关键路径上（因为之前的 load 只依赖于索引 i）。其实，load/store 操作也会和之前的 multiply 一样成为某些程序的关键路径，例如链表程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">long</span> data;</span><br><span class="line">&#125; list_ele, *list_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">list_len</span><span class="params">(list_ptr ls)</span> &#123;</span><br><span class="line">    <span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L3:</span><br><span class="line">    addq$1, %rax</span><br><span class="line">    movq(%rdi), %rdi</span><br><span class="line">    testq%rdi, %rdi</span><br><span class="line">    jne.L3</span><br></pre></td></tr></table></figure><p>这个时候加载的结果决定下一条操作的地址时，load 指令（<code>movq</code> 的其中一个 $\mu$ code）就是关键路径上的一环了。我们发现这种循环的 CPE 约 4.00，说明：<u><strong>load 的 latency 约 4.00</strong></u>。</p><p>除了 load，store 也会成为关键路径的一环。来看两个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_array</span><span class="params">(<span class="type">long</span>* dest, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dest[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_read</span><span class="params">(<span class="type">long</span> *src, <span class="type">long</span> *dst, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> cnt = n;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cnt) &#123;</span><br><span class="line">        *dst = val;</span><br><span class="line">        val = (*src) + <span class="number">1</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>func1</code> 的 CPE 能达到 1.0，很好解释，是因为 store <strong>暂时不影响寄存器值（前面提到 pending write 到 renaming table）</strong>，不会产生数据依赖，因此可以完全流水线化，这也是最佳情况（throughput bound）。</p><p>但是 <code>func2</code>，如果 <code>src != dst</code>，那么 CPE 约为 1.3；但是如果 <code>src == dst</code>，那么 CPE 上升到 7.3（下降了 6 个 cycles）！这可以用 data-flow 分析出。</p><p>先写出汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.L3:</span><br><span class="line">    movq%rax, (%rsi)</span><br><span class="line">    movq(%rdi), %rax</span><br><span class="line">    addq$1, %rax</span><br><span class="line">    subq$1, %rdx</span><br><span class="line">    jne.L3</span><br></pre></td></tr></table></figure><p><code>movq %rax, (%rsi)</code> 会被分解为两条 primitive instruction：<code>s_addr</code>（计算目标内存地址，由单独的运算单元完成）、<code>s_data</code>（数据 store）。</p><p>如果 store 的数据依赖于前一步的 load（read-write dependency），那么根据汇编代码可以画出：</p><blockquote><p>其中 <code>movq</code></p></blockquote><p><img src="imgs/data-flow-load-store.png"></p><p>如果 <code>src != dst</code>，那么箭头 3 不存在，关键路径将是 <code>sub</code>（CPE 约 1.3）；</p><p>如果 <code>src == dst</code>，那么箭头 3 的依赖关系就存在，关键路径就是 <code>s_data -&gt; load -&gt; add</code>（CPE 约 7.3）。</p><p>此外，还有一些在机器层面影响性能的其他因素：</p><h3 id="12-5-1-Branch-Misprediction-Recovery"><a href="#12-5-1-Branch-Misprediction-Recovery" class="headerlink" title="12.5.1 Branch Misprediction Recovery"></a>12.5.1 Branch Misprediction Recovery</h3><p>我们在 4.2.2 中提到过，机器层面的分支预测技术（Branch Prediction）就是为了让 CPU 流水线的效率得到充分利用而诞生的。在很多情况下，如果我们不使用条件移动的话，那么在分支预测错误的时候，很有可能整个流水线的指令和数据全部需要重新载入，这将耗费大量的运算资源和时间。</p><p>所以第一个思路就是从降低 <strong>Branch Misprediction Penalty</strong> 方面着手。首先了解一下分支预测技术的大概原理是啥。分支预测技术在早期使用的是简单的 heuristic：向后分支（backwards branches）经常是判断（if），向前分支（forwards branches）经常是循环（loop）。我们可以通过一些算法<strong>跟踪这些分支（尤其是循环）的历史行为，如果它经常通过某一分支，那么以后预测该分支的可能性会大一点</strong>。</p><p>这种预测方法在有些代码中效果显著，但是另一些代码（<strong>例如强数据依赖、强随机数据</strong>）中效果极差，甚至导致更多的 Branch Misprediction Penalty；</p><p>因此接近这个方面问题的可能途径如下：</p><ul><li>减少分支结构的数量：<ul><li>Transform loops（尽量转换、消除不必要的循环）</li><li>Unroll loops（下面介绍）</li><li>Use Conditional Moves（4.2.2）</li></ul></li><li>使得分支<strong>更容易被分支预测器预测</strong><ul><li>为循环中的数据排序（需要权衡）</li><li>尽量避免间接的分支结构（因为间接分支基本上都没有预测依据）<ul><li>函数指针判断跳转</li><li>虚函数运行时判断跳转</li></ul></li></ul></li></ul><p>这里介绍一下 unroll loops 的思路。unroll loops 就是<strong>将循环中的代码成倍数展开，达到均摊 Branch Misprediction Penalty 的目的</strong>。同时，这种方法还能为其他的优化方法创造条件（例如 CSE、Code Motion、Scheduling 等）。方法的示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts; i++)</span><br><span class="line">    A[i] = B[i]*k + C[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    A[i  ] = B[i  ]*k + C[i  ];</span><br><span class="line">    A[i+<span class="number">1</span>] = B[i+<span class="number">1</span>]*k + C[i+<span class="number">1</span>];</span><br><span class="line">    A[i+<span class="number">2</span>] = B[i+<span class="number">2</span>]*k + C[i+<span class="number">2</span>];</span><br><span class="line">    A[i+<span class="number">3</span>] = B[i+<span class="number">3</span>]*k + C[i+<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方法有两个明显的缺陷，一是如果过度展开，会增长代码长度，同样会影响性能。所以需要根据数据量进行权衡；二是在某些循环中，依赖 i 进行判断的场合，这种展开就不适用了。</p><h3 id="12-5-2-Scheduling"><a href="#12-5-2-Scheduling" class="headerlink" title="12.5.2 Scheduling"></a>12.5.2 Scheduling</h3><p>在上面的流程中，除了 Branch Misprediction Penalty，还有一种会影响 CPU 运算性能的情况——数据读取和写入。I/O 操作的开销一直是处理器设计者头疼的地方，尽管现在有高速缓存器来进行弥补，但数据的存取在运算过程中还是尽量能少就少。</p><p>因此，<strong>将源代码中读取、写入的部分和运算的部分分开（最好在运算前就读入所有必需的数据、在所有运算后才写入必要的数据），能够让处理器的性能发挥到最大</strong>（这个优化也可以由编译器完成）。这种方法就称为代码调度（Scheduling）。</p><p>例如 12.5.1 中的代码还可以继续优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    B0 = B[i]; B1 = B[i + <span class="number">1</span>]; B2 = B[i + <span class="number">2</span>]; B3 = B[i + <span class="number">3</span>];</span><br><span class="line">    C0 = C[i]; C1 = C[i + <span class="number">1</span>]; C2 = C[i + <span class="number">2</span>]; C3 = C[i + <span class="number">3</span>];</span><br><span class="line">    A[i  ] = B0*k + C0;</span><br><span class="line">    A[i+<span class="number">1</span>] = B1*k + C1;</span><br><span class="line">    A[i+<span class="number">2</span>] = B2*k + C2;</span><br><span class="line">    A[i+<span class="number">3</span>] = B3*k + C3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，这样的操作对于有些情况也不适用，比如在一些业务逻辑下，读取操作必须在一群算数运算之间出现。</p><h2 id="12-6-Summary"><a href="#12-6-Summary" class="headerlink" title="12.6 Summary"></a>12.6 Summary</h2><p>本章讲述了一些程序优化的基本思路，主要从两个方向描述。</p><p>一个是与机器无关方向的优化小技巧，而这些技巧也常常会内置在编译器中，成为编译工作的一个部分。它们大致可以分为以下几类：</p><ul><li>局部的优化：例如 <strong>常数折叠、计算强度减小（通过更换运算符实现）、死代码剔除、局部的相近表达式复用消除</strong>；</li><li>全局的优化：例如 <strong>循环结构转换、代码移动（减少不必要的运算）、内联化、全局的相近表达式复用消除</strong>；</li></ul><p>在这个方面，我们考虑了相反的情况——什么样的编码会阻碍编译器帮助我们进行上面的优化。</p><ul><li>Procedure Calls：我们应该在代码设计时，充分考虑函数调用的位置对于性能影响；</li><li>Memory Alias：尤其是在循环结构中，多使用局部变量暂存中间结果，或者使用更严格的关键字；</li></ul><p>这都在提醒我们编码时，能尽早确定的定值，尽量存在局部变量中，以防编译器认为中间存在变数，而不敢于进行优化。</p><p>另一个是与具体机器有关方向的优化技巧（但是目前世界上的机器种类就这些，所以理论上也有一定的普适性，例如 ARM 架构和 x86 架构都能使用这种优化来提升性能），编译器不一定会帮你做这些优化，这是因为这些方法有着各自的局限性。</p><p>我们分析了现代 CPU 的结构特性，找到了 3 处可以进行优化的地方，一个是分支预测的部分，一个是代码中的 I/O 调度，另一个是运算顺序和方法。</p><p>首先我们了解了分支预测器的原理和性质，我们发现想要弥补 Branch Misprediction Penalty，就需要从两个方面入手：</p><ol><li>让它少预测点，就少错一点（减少分支结构）。这方面的方法大致有 <strong>循环转换、unrolling loops 和 conditional moves（回想之前的 General Condition Translation）</strong>；</li><li>提升它预测的正确率。依从分支预测器的原理，我们可以让每次产生的分支判断的结果有迹可循。总的来说，我们可以通过<strong>为需要的判断数据排序</strong>（局限性强）、<strong>减少编码一些难以预测的结构</strong>（例如函数指针判断、虚函数）。</li></ol><p>在 I/O 调度方面我们发现，CPU 频繁地从高速缓存器中读入和写出数据也会降低程序性能，因此在编码过程中写出能够让汇编码中读内存次数越少的源码越好。因此，这里的重要建议是<strong>将源代码中读取、写入的部分和运算的部分分开（最好在运算前就读入所有必需的数据、在所有运算后才写入必要的数据）</strong>。</p><p>本章最后以一个计算例子说明，通过<strong>分析关键路径</strong>，使用 Re-association Transformation、Separate Accumulator 来让更多的乘法运算并行起来。</p><p>当然，当我们利用以上技术（例如 loop unrolling）优化到一定程度后，其他方面的问题就变成了关键路径上的问题。例如 unrolling 过多时，发生 register spilling（寄存器用完了，开始使用内存）影响性能。</p><p><img src="imgs/ch15-summary.png" height="250px"></p><p>最后介绍一个优化的规则：Amdahl‘s Law</p><script type="math/tex; mode=display">S=\dfrac{T_{old}}{T_{new}}=\dfrac{1}{(1-\alpha)+\dfrac{\alpha}{K}}\Longrightarrow S_{\infty}=\dfrac{1}{1-\alpha}</script><p>$(1-\alpha)$ 代表不能被优化的部分，$K$ 代表能被优化的部分最快被优化多少倍。</p><p>当能优化的部分优化到极限后，加速比极限为 $S_\infty$。<strong>表达式说明一个通俗的道理：选择优化时间占比更大的部分（$\alpha$ 更大），优化的效果、优化的极限就更好（$S_\infty$ 更大）</strong>。</p><p>也就是说，我们应该在优化时找关键路径、找 hot spot（热点位置）。这就是 profiling。</p><p>当今的 profiling 工具有哪些？Unix 上有 <code>gprof</code>、<code>perf</code>，它们的思路是 <strong>random sampling</strong>，间隔一定时间进行指令中断，统计函数执行的次数、统计当前调用栈（可以发现调用关系、递归情况），用频率代表出现总时长占比。</p>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> CSAPP </tag>
            
            <tag> ICS </tag>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript笔记</title>
      <link href="//technical/typescript-basic/"/>
      <url>//technical/typescript-basic/</url>
      
        <content type="html"><![CDATA[<p><i>Written by SJTU-XHW</i></p><p><i>Reference: </i> MDN Doc &amp;&amp; TypeScript Doc</p><p><i>本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h1 id="Chapter-1-与-JS-比较：类型声明-与-作用域"><a href="#Chapter-1-与-JS-比较：类型声明-与-作用域" class="headerlink" title="Chapter 1. 与 JS 比较：类型声明 与 作用域"></a>Chapter 1. 与 JS 比较：类型声明 与 作用域</h1><p>TypeScript 是个静态类型语言，<strong>变量类型/对象成员/函数签名 在定义后就不能更改！</strong></p><ul><li><p>定义变量时，请使用规范的类型声明定义方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Variable */</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">bar</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, TypeScript!&quot;</span>;</span><br><span class="line"><span class="comment">/* Function */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>天大的福音：<strong>只声明变量、不赋值就使用会报错！这下不用担心讨厌的 <code>undefined</code> 了</strong>；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>而且开启了编译选项 <code>strictNullChecks</code> 后，<code>undefined</code> 也是个独立的类型，不能赋给除了 <code>undefined</code> 类型以外的其他类型！</p></li><li><p>不允许给变量中途赋予不同类型的值；</p></li></ul><p>此外，<strong>比 JavaScript 更加暖心的操作是：TypeScript 全面支持 <u>块级作用域</u>！</strong>定义在块级作用域内的变量、类型等等不再能被外界读到了！</p><h1 id="Chapter-2-TypeScript-编译"><a href="#Chapter-2-TypeScript-编译" class="headerlink" title="Chapter 2. TypeScript 编译"></a>Chapter 2. TypeScript 编译</h1><p>TypeScript 不提供运行环境，全部交给 JavaScript，自己只提供转换为 JavaScript 的编译器 <code>tsc</code>，甚至这个编译器也是 JavaScript 的一个库，可以用 <code>npm</code> 安装。</p><p>编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。</p><p>因此，TypeScript 的类型检查只是编译时的类型检查，而不是运行时的类型检查。一旦代码编译为 JavaScript，运行时就不再检查类型了。</p><p>TypeScript 的编译器 <code>tsc</code> 的简单使用如下：</p><ul><li><p>安装：<code>npm install -g typescript</code>；</p></li><li><p>编译单个 TS 文件，或多个没有层次依赖关系的 TS 文件：<code>tsc a.ts[, b.ts, ...]</code>；</p><blockquote><p>分别生成 <code>a.js, b.js, ...</code>；</p></blockquote></li><li><p><code>--outFile</code> 编译为一个指定的 JavaScript：<code>tsc a.ts[, b.ts, ...] --outFile XXX.js</code>；</p></li><li><p><code>--outDir</code> 指定输出目录；</p></li><li><p><code>--target</code> 指定编译 JavaScript 标准（建议 <code>es2015</code> 及以上）；</p></li></ul><p>如果项目更复杂一点，就需要 <code>tsconfig.json</code> 管理编译过程（考虑 Java 的 Gradle 和 C++ 的 CMakeLists）。其简单结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;file1.ts&quot;</span><span class="punctuation">,</span> <span class="string">&quot;file2.ts&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/app.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这时候直接运行 <code>tsc</code> 等价于原来的 <code>tsc file1.ts file2.ts --outFile dist/app.js</code>；</p><p>更复杂的使用以后介绍。</p><h1 id="Chapter-3-TypeScript-类型系统"><a href="#Chapter-3-TypeScript-类型系统" class="headerlink" title="Chapter 3. TypeScript 类型系统"></a>Chapter 3. TypeScript 类型系统</h1><h2 id="3-1-新的辅助类型"><a href="#3-1-新的辅助类型" class="headerlink" title="3.1 新的辅助类型"></a>3.1 新的辅助类型</h2><p>和 JavaScript 不一样的是，TypeScript 提供了 3 种特殊类型：<code>any</code>、<code>unknown</code>、<code>never</code>，它们是为了配合静态类型系统更好的发挥功能而创造出来的。</p><h3 id="3-1-1-Any-类型"><a href="#3-1-1-Any-类型" class="headerlink" title="3.1.1 Any 类型"></a>3.1.1 Any 类型</h3><p>当给变量声明 <code>any</code> 类型时，<strong>TypeScript 会关闭这个变量的类型检查，这个变量单独变为 “动态类型”</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">x</span>(<span class="number">1</span>); <span class="comment">// OK</span></span><br><span class="line">x.<span class="property">foo</span> = <span class="number">100</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="string">&quot;foo&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>如你所见，肯定要避免使用 <code>any</code> 类型，不然你为什么不用 JavaScript？</p><p>频繁使用 <code>any</code> 会导致 TypeScript 丧失静态类型的优势，具体来说有几个坏处：</p><ul><li><p>干扰类型推断和编译前错误检查：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">any</span>, y: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></li><li><p>静态类型污染：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 不报错</span></span><br><span class="line"></span><br><span class="line">y * <span class="number">123</span>; <span class="comment">// 不报错</span></span><br><span class="line">y.<span class="title function_">toFixed</span>(); <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure></li></ul><p>即使你不使用 <code>any</code> 类型，也要注意编译器可能<strong>自动推断 <code>any</code> 类型</strong>，这通常是因为开发者不良开发习惯所导致的 —— <strong>声明、定义变量 / 定义函数 时，不进行类型标注</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">let</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上变量、函数声明全部会被编译器推断为 <code>any</code>，从而干扰类型检查！</p><p>总之，<u>对于 TypeScript 的 <code>any</code> 类型，请敬而远之！自己不写 <code>any</code>，也别让编译器推断出 <code>any</code></u>。这是编译器实在没法进行类型检查时候的下下策。</p><blockquote><p>还是那句话，不然你为什么不直接用 JavaScript？</p></blockquote><h3 id="3-1-2-Unknown-类型"><a href="#3-1-2-Unknown-类型" class="headerlink" title="3.1.2 Unknown 类型"></a>3.1.2 Unknown 类型</h3><p>为了防止 <code>any</code> 的类型污染等问题，人们定义了一种比 <code>any</code> 类型严格的辅助类型 <code>unknown</code>，规则如下：</p><ul><li>允许给 <code>unknown</code> 类型变量赋予任何类型的值；</li><li><strong>不允许将 <code>unknown</code> 类型变量赋予其他确定类型（即除了 <code>any</code> 和 <code>unknown</code>）的值</strong>；</li><li><strong>不允许使用 <code>unknown</code> 类型的方法、属性</strong>；</li><li>只能对 <code>unknown</code> 类型进行有限的运算：逻辑运算、判断相等运算、<code>typeof</code>、<code>instanceof</code>，其他运算均不可以；</li></ul><p>违反以上规则，编译器会抛出错误。</p><p>但是 <code>unknown</code> <strong>允许<u>类型缩窄</u></strong>（比如一开始没法确定这个数据的类型，但是后面要处理时确定了，这种情况就不需要使用 <code>any</code> 了），如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: <span class="built_in">unknown</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> s === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">  s.<span class="property">length</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在作用域中，<code>s</code> 类型被缩窄为 <code>string</code>，变成了确定类型，就可以使用确定类型的一切方法和属性了。</p><p>总之，<strong>某些逻辑下，实在无法确定类型，应该优先使用 <code>unknown</code> 类型，避免 <code>any</code> 出现</strong>。</p><h3 id="3-1-3-Never-类型"><a href="#3-1-3-Never-类型" class="headerlink" title="3.1.3 Never 类型"></a>3.1.3 Never 类型</h3><p>从集合论的角度，人们定义了这个类型，含义是 <strong>空类型</strong>，可以赋给任何类型的变量。</p><p>你可能会好奇，那被赋予 <code>never</code> 类型的变量内部的值怎么办？</p><p>问出这个问题说明你还没有明白 <code>never</code> 的使用场景：<strong>在函数中，它标识控制流永远无法到达函数返回的时候；在变量中，它标识永远都不会用到该变量</strong>。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, TypeScript!&quot;</span>);    <span class="comment">// 编译器会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是错误的，因为函数能够执行到最后，返回的是 <code>undefined</code> 类型的对象，而不是空。</p><blockquote><p>如果你只是想标识函数不返回值，请使用 <code>undefined</code> / <code>void</code> 作为返回类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, TypeScript!&quot;</span>);  <span class="comment">// Correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>这样才是正确使用方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    <span class="comment">/* Control Never Reaches Here! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-新的基本类型-和-引用类型"><a href="#3-2-新的基本类型-和-引用类型" class="headerlink" title="3.2 新的基本类型 和 引用类型"></a>3.2 新的基本类型 和 引用类型</h2><p>复习一下 JavaScript 中有几种基本类型和引用类型：</p><p><code>boolean</code>、<code>string</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>、<code>object</code>（狭义对象类型也是个基本类型，和广义对象类型 <code>Object</code> 不同，仅包含所有引用类型，如 Array 等内置引用类型）、<code>undefined</code>、<code>null</code>；</p><blockquote><p>补充 JavaScript 不常用的类型使用方法：</p><ul><li><code>bigint</code>：<strong>在 JavaScript 中，使用 <code>bigint</code> 需要数字尾缀 <code>n</code></strong>，例如 <code>123n</code>；</li></ul></blockquote><h3 id="3-2-1-TypeScript-的对象"><a href="#3-2-1-TypeScript-的对象" class="headerlink" title="3.2.1 TypeScript 的对象"></a>3.2.1 TypeScript 的对象</h3><p>这里得说明一下，对象（引用类型）的定义和 JavaScript <strong>显著不同</strong>。</p><p>因为 TypeScript 作为一种静态类型语言，不允许定以后更改数据成员。因此你这么写，编译器会报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">o1</span>: <span class="title class_">Object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">o2</span>: <span class="built_in">object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">o1.<span class="property">foo</span>; <span class="comment">// TypeError</span></span><br><span class="line">o2.<span class="property">foo</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>因为你定义的 <code>o1/o2</code> 类型是原生的 <code>object/Object</code>，都只有原生的属性和方法，<code>foo</code> 属性在赋值时就被抛弃了。</p><p><strong>要想自定义对象的属性和方法，要么定义对象类型，要么定义 <code>class</code>（TypeScript 的类，后面讲）</strong>；</p><h3 id="3-2-2-TypeScript-值类型"><a href="#3-2-2-TypeScript-值类型" class="headerlink" title="3.2.2 TypeScript 值类型"></a>3.2.2 TypeScript 值类型</h3><p>TypeScript 规定，单个值也是一种类型，称为“值类型”，不常用，它常常用在联合 / 交叉类型中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">name</span>: <span class="string">&quot;Hello&quot;</span>;    <span class="comment">// 只能被赋予 &quot;Hello&quot;，其他内容都会报错。</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-TypeScript-常量类型"><a href="#3-2-3-TypeScript-常量类型" class="headerlink" title="3.2.3 TypeScript 常量类型"></a>3.2.3 TypeScript 常量类型</h3><p>所有使用 <code>const</code> 关键字修饰的 TypeScript 的变量都是常量，它们不能被更改。</p><p>你可以把这个变量理解为 <strong>以初次赋予的值为值类型的变量</strong>。</p><h3 id="3-2-4-TypeScript-对象类型"><a href="#3-2-4-TypeScript-对象类型" class="headerlink" title="3.2.4 TypeScript 对象类型"></a>3.2.4 TypeScript 对象类型</h3><h4 id="3-2-4-1-使用方法"><a href="#3-2-4-1-使用方法" class="headerlink" title="3.2.4.1 使用方法"></a>3.2.4.1 使用方法</h4><p>而 “对象类型” 则<strong>可以很方便地（无需定义接口 interface、类型 class）定义对象并指定临时类型</strong>，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">testFunc1</span>(<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">testFunc2</span>: <span class="function">(<span class="params">c: <span class="built_in">string</span>, d: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">boolean</span>;    <span class="comment">// 箭头函数式声明</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    <span class="title function_">testFunc1</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? a.<span class="title function_">toString</span>() : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    testFunc2 = <span class="keyword">function</span>(<span class="params">c, d</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c === d.<span class="built_in">parseInt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-2-对象类型的特性"><a href="#3-2-4-2-对象类型的特性" class="headerlink" title="3.2.4.2 对象类型的特性"></a>3.2.4.2 对象类型的特性</h4><p>一旦声明某个对象的对象类型后，赋值一定要分毫不差地按照类型来，否则编译器不会接受，即<u><strong>不允许</strong></u>以下行为：</p><ul><li>增添对象类型中不存在的字段、删除对象类型中已有的字段；</li><li>定义+赋值时，少给一个成员赋值，或者给不存在的成员赋值；</li></ul><p>但是它也允许一些特性以在合理的范围内支持灵活性：</p><ul><li><p>允许数据域添加 可选修饰符 <code>?</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span> | <span class="literal">undefined</span>; <span class="comment">// 注意进行类型缩窄</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>允许数据域添加 只读修饰符 <code>readonly</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">resident</span>: &#123;<span class="comment">// 只读数据域如果是对象，则允许更改数据域，不允许更改对象引用</span></span><br><span class="line">        <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">        <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只读数据域和普通数据域间传递，与 C 的 <code>const</code> 修饰类型和普通类型的方法一样，不再赘述。</p></li><li><p>允许 <u><strong>数据域索引</strong></u>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TestObjT</span> = &#123;</span><br><span class="line">    [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>TestObjT</code> 的含义是，<strong>不管这个对象有多少属性，只要属性名为字符串，且属性值也是字符串，就符合这个类型声明</strong>，比如可以这么定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">tobj</span>: <span class="title class_">TestObjT</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="attr">baz</span>: <span class="string">&quot;3&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，对象类型的数据域索引中 property 类型允许 <code>string</code>、<code>number</code>、<code>symbol</code>；</p><p>不过这个特性不建议使用，因为对类型的约束过于宽泛。</p></li></ul><h4 id="3-2-4-3-解构赋值-与-对象类型"><a href="#3-2-4-3-解构赋值-与-对象类型" class="headerlink" title="3.2.4.3 解构赋值 与 对象类型"></a>3.2.4.3 解构赋值 与 对象类型</h4><p>和 python 的解构语法类似，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, axe = matplotlib.pyplot.subplots()</span><br><span class="line">[a, _] = curStr.split(<span class="string">&#x27;/&#x27;</span>)</span><br></pre></td></tr></table></figure><p>TypeScript 的解构要求指定 <strong>对象类型</strong>，其实有两种语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 obj **按序**解构到指定的变量，必须声明成对象的对象类型（type of obj）</span></span><br><span class="line">&lt;qualifiers&gt; &#123;var1, var2, ...&#125;: &lt;type of obj&gt; = obj;</span><br><span class="line">// 自定义解构顺序</span><br><span class="line">&lt;qualifiers&gt; &#123;objProp1: var1, objProp2: var2, ...&#125;: &lt;type of obj&gt; = obj；</span><br></pre></td></tr></table></figure><p>第一种语法很好理解，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  id,</span><br><span class="line">  name,</span><br><span class="line">  price,</span><br><span class="line">&#125;: &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = product;</span><br></pre></td></tr></table></figure><p>但我们发现 “自定义解构顺序” 的写法非常迷惑，因为大括号内的冒号不再指类型，而是指数据域的映射关系，例如很多新手会这么写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">shape</span>: <span class="title class_">Shape</span>;</span><br><span class="line">    <span class="attr">xpos</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">shape</span>: &#123;<span class="attr">width</span>: <span class="number">1</span>, <span class="attr">height</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="attr">xpos</span>: <span class="number">0.0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">shape</span>: <span class="title class_">Shape</span>, <span class="attr">xpos</span>: <span class="built_in">number</span>&#125; = obj;</span><br></pre></td></tr></table></figure><p>最后一句话的含义是什么？如果你认为这是第一种语法，按序把 <code>obj</code> 的 <code>shape</code> 和 <code>xpos</code> 属性赋给了外部的 <code>shape</code>、<code>xpos</code> 变量，<strong>那么就大错特错了！</strong></p><p>因为要牢记：<u><strong>解构语法中的冒号不再作为类型尾缀，而是作为数据域映射的含义</strong></u>，在这里，解构语法一旦出现冒号，就一定是第二条语法。</p><p>上面的最后一条语句的真正含义是，<strong>将 <code>obj</code> 的 <code>shape</code> 数据域赋给外围以 “Shape” 为变量名的变量，它的类型名也是 <code>Shape</code>！</strong>（number 同理）</p><h4 id="3-2-4-4-对象类型的结构类型原则（Structual-Typing-Principle）"><a href="#3-2-4-4-对象类型的结构类型原则（Structual-Typing-Principle）" class="headerlink" title="3.2.4.4 对象类型的结构类型原则（Structual Typing Principle）"></a>3.2.4.4 对象类型的结构类型原则（Structual Typing Principle）</h4><p>只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structual typing）。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">A</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">B</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对象 B 满足 A 的结构特征，说明 B 的对象类型 <strong>兼容</strong> A 的对象类型，因此 B 可以直接赋给 A，但反过来不行。</p><h4 id="3-2-4-5-对象类型的最小可选属性规则"><a href="#3-2-4-5-对象类型的最小可选属性规则" class="headerlink" title="3.2.4.5 对象类型的最小可选属性规则"></a>3.2.4.5 对象类型的最小可选属性规则</h4><p>如果一个对象类型所有属性都由 可选修饰符 修饰，按语义理解的话，所有对象都会符合这个定义。</p><p>TypeScript 为了防止类型模糊，规定：</p><p>当一个对象类型所有属性都由 可选修饰符 修饰，那么要定义一个该类型的对象，<strong>至少要含有一个可选属性</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Options</span> = &#123;</span><br><span class="line">    a?: <span class="built_in">number</span>;</span><br><span class="line">    b?: <span class="built_in">number</span>;</span><br><span class="line">    c?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">Options</span> = &#123;</span><br><span class="line">    <span class="attr">d</span>: <span class="number">123</span>, <span class="comment">// TypeError</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: <span class="title class_">Options</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>;    <span class="comment">// Correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-5-TypeScript-的联合类型-与-交叉类型"><a href="#3-2-5-TypeScript-的联合类型-与-交叉类型" class="headerlink" title="3.2.5 TypeScript 的联合类型 与 交叉类型"></a>3.2.5 TypeScript 的联合类型 与 交叉类型</h3><p>联合类型 <code>var x: A | B</code> 表示 <code>x</code> 既可以是 <code>A</code> 类型，又可以是 <code>B</code> 类型；</p><p>这其实是暂时无法判断类型的最正确的处理方法。</p><p>它仅允许使用二者类型共同的属性或方法，否则编译器会抛出错误。必须使用 <strong>缩窄类型</strong> 才可以针对性地使用属性和方法。</p><p>交叉类型 <code>var y: A &amp; B</code> 表示 <code>x</code> 必须既是 <code>A</code> 类型，又是 <code>B</code> 类型，<strong>最常见用作对象属性的临时合成</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span> &amp; <span class="built_in">string</span>;    <span class="comment">// 编译器认为无法取得，是 never 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123; <span class="attr">foo</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">bar</span>: <span class="built_in">string</span> &#125;;    <span class="comment">// 具有 foo, bar 两个数据成员的对象类型</span></span><br></pre></td></tr></table></figure><h3 id="3-2-6-TypeScript-类型别名"><a href="#3-2-6-TypeScript-类型别名" class="headerlink" title="3.2.6 TypeScript 类型别名"></a>3.2.6 TypeScript 类型别名</h3><p>TypeScript 中的关键字 <code>type</code>，现在完全可以理解为 C 的 <code>typedef</code>，就是<strong>定义一个类型（值类型、对象类型、联合类型、交叉类型，等等）的别名</strong>，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">TA</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">testFunc1</span>(<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">testFunc2</span>: <span class="function">(<span class="params">c: <span class="built_in">string</span>, d: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">TB</span> = <span class="variable constant_">TA</span> &amp; &#123; <span class="attr">z</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="variable constant_">TB</span> = &#123;</span><br><span class="line">    <span class="comment">/* Definitions */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p><strong>别名不允许重名！</strong></p></li><li><p>别名的有效范围是当前的块级作用域（例如定义在大括号内、函数内，在外面就没有效用了）；</p></li><li><p>别名支持使用表达式定义，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">World</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="string">`hello <span class="subst">$&#123;World&#125;</span>`</span>;</span><br></pre></td></tr></table></figure></li><li><p>别名是类型相关代码，因此在编译为 JavaScript 后会被完全清除。</p></li></ul><h3 id="3-2-7-TypeScript-typeof-运算符"><a href="#3-2-7-TypeScript-typeof-运算符" class="headerlink" title="3.2.7 TypeScript typeof 运算符"></a>3.2.7 TypeScript <code>typeof</code> 运算符</h3><p>JavaScript 的 <code>typeof</code> 返回的是对应类型的字符串；</p><p>实际上，在 TypeScript 中保留了 JavaScript 的 <code>typeof</code>，又增添了一个新的 <code>typeof</code> 运算符，返回的是 <strong>TypeScript 类型（比如基本类型、值类型、对象类型等等）</strong>，由于是类型，因此这种运算符不能用于值运算，只能放在类型推导中。</p><p>举个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="keyword">typeof</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个 <code>typeof</code> 是 TypeScript 新增的返回类型的 <code>typeof</code>，只能用于类型推导，参数不能是<strong>表达式</strong>（前面的类型别名可以）。在编译后会被完全清除；</p><p>第二个 <code>typeof</code> 是 JavaScript 原生的 <code>typeof</code>，返回的是字符串，可以用于值运算。</p><h2 id="3-3-TypeScript-中的数组：基本类型和内置引用类型"><a href="#3-3-TypeScript-中的数组：基本类型和内置引用类型" class="headerlink" title="3.3 TypeScript 中的数组：基本类型和内置引用类型"></a>3.3 TypeScript 中的数组：基本类型和内置引用类型</h2><h3 id="3-3-1-定义和使用"><a href="#3-3-1-定义和使用" class="headerlink" title="3.3.1 定义和使用"></a>3.3.1 定义和使用</h3><p>这里和 JavaScript 动态类型语言不像，而是更接近 Java 的静态类型。</p><p><strong>TypeScript 数组所有成员的类型必须相同，但是成员数量是不确定的</strong>，<u>不论是基本类型数组 <code>type[]</code> 还是 内置类型 <code>Array&lt;Type&gt;</code></u>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">arr</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>内置类型 Array 被改成了更像 Java 的泛型，方法和 JavaScript 原生都是一样的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">arr</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>和 JavaScript 一样，可以通过修改 <code>length</code> 属性直接增减成员。</p><p>由于长度不定，因此 <strong>TypeScript 的数组越界也不会报错</strong>，只会返回 <code>undefined</code>；</p><p><code>Array</code> 内置类型和 JavaScript 原生用法几乎一致，方法不再赘述。</p><h3 id="3-3-2-只读数组"><a href="#3-3-2-只读数组" class="headerlink" title="3.3.2 只读数组"></a>3.3.2 只读数组</h3><p>不仅是 JavaScript，大多数语言都认为数组及其他形式的对象都是 <strong>可变数据类型</strong>，因此把数组本身定义为 <code>const</code> 是不会阻止数组被修改的。我们以 C++ 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">size_t</span> s): <span class="built_in">arrSize</span>(s), <span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[s] &#123;<span class="number">0</span>&#125;) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;<span class="keyword">delete</span>[] arr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> arrSize;</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setter</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        arr[idx] = val;    <span class="comment">// OK！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>setter</code> 函数使用 <code>const</code> 修饰，也没能阻止数组被修改。</p><p>为了限制可变数据类型的修改问题，C++ 采用的是常量指针的方法，声明不允许修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 上面的 arr 声明改成： */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> <span class="type">const</span>* arr;</span><br></pre></td></tr></table></figure><p>这样数组就不再可以被修改，上面的 <code>setter</code> 也会让编译器报错。</p><p>那么 TypeScript 是怎么做的？答案是加 <code>readonly</code> 关键字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">0</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这样无论是使用删除、修改、新增数组成员的方法都会报错。我们可以将 <code>readonly number[]</code> 和 <code>number[]</code> 视为两个类型。</p><p>为此，TypeScript 设计了泛型 <code>Readonly&lt;T&gt;</code> 和 <code>ReadonlyArray&lt;T&gt;</code>，效果类似。</p><h3 id="3-3-3-多维数组"><a href="#3-3-3-多维数组" class="headerlink" title="3.3.3 多维数组"></a>3.3.3 多维数组</h3><p>和 Java 定义很像，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">multi</span>: <span class="built_in">number</span>[][] = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><blockquote><p>Java 写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] multi = &#123;</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="type">int</span>[][] multi = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-4-TypeScript-元组"><a href="#3-4-TypeScript-元组" class="headerlink" title="3.4 TypeScript 元组"></a>3.4 TypeScript 元组</h2><p>和 Python 的思想一样，允许在一个组内放入不同类型的数据。</p><p>一般情况下，<strong><u>元组的长度是确定的、每个元素的类型必须明确指定</u>，因此越界访问、不按定义的类型来赋值都会报错</strong>。</p><p>其类型定义的方法和数组不一样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];    <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>] = [<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="literal">true</span>];    <span class="comment">// 元组</span></span><br></pre></td></tr></table></figure><p>有时候不能省略类型定义，特别是只有一个元素的时候，因为可能会被编译器误判为数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>];    <span class="comment">// 编译器认为是数组</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">b</span>: [<span class="built_in">number</span>] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><strong>不过 “元组长度是确定的”，而不是 “固定的”</strong>，是因为有 2 个例外：</p><ul><li><p>可选类型修饰符 <code>?</code>（<strong>只能位于元组类型列表尾部</strong>）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>?] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li><li><p>扩展运算符（又称 REST 运算符），表示不限制数量的同类元素，可以不位于类型列表尾部，在一个类型声明中只能使用一次：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]];    <span class="comment">// 注意，这不是数组。数组请用 ...&lt;T&gt;[][]</span></span><br><span class="line"><span class="keyword">type</span> t2 = [<span class="built_in">string</span>, ...<span class="built_in">boolean</span>[], <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> t3 = [...<span class="built_in">boolean</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure></li></ul><p>如果没有使用扩展运算符，那么元组的长度就能确定，<strong>可以使用 <code>length</code> 进行长度推断</strong>：</p><p>如果使用了扩展运算符，<code>length</code> 推断就会被看作数组。</p><h2 id="3-5-TypeScript-函数"><a href="#3-5-TypeScript-函数" class="headerlink" title="3.5 TypeScript 函数"></a>3.5 TypeScript 函数</h2><h3 id="3-5-1-定义与使用"><a href="#3-5-1-定义与使用" class="headerlink" title="3.5.1 定义与使用"></a>3.5.1 定义与使用</h3><p>定义方法和 JavaScript 一样，但是类型声明是有讲究的。</p><p>普通定义方法这么加类型声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">txt: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>赋值函数表达式这么加：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">hello</span>: <span class="function">(<span class="params">txt: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> = <span class="keyword">function</span>(<span class="params">txt</span>) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="keyword">var</span> hello = <span class="keyword">function</span>(<span class="params">txt: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>技巧：想要套用其他函数的签名，就用 <code>typeof</code> 运算符，如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">myAdd</span>: <span class="keyword">typeof</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>箭头函数这么加：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = (<span class="attr">txt</span>: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>由于函数也是一个对象，所以我们可以这么自定义函数的类型（在想要给函数加属性的时候有用）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line">f.<span class="property">version</span> = <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   (参数列表): 返回值</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">add</span>: &#123;</span><br><span class="line">  (<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125; = f;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-可选参数-与-默认值"><a href="#3-5-2-可选参数-与-默认值" class="headerlink" title="3.5.2 可选参数 与 默认值"></a>3.5.2 可选参数 与 默认值</h3><p>TypeScript 在静态类型的同时允许参数可选、默认值（它们肯定不能同时使用）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFunc</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">myFunc = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y === <span class="literal">undefined</span>) &#123;    <span class="comment">// 用到可选参数时请判断</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params">x: <span class="built_in">number</span> = <span class="number">0</span>, y: <span class="built_in">number</span> = <span class="number">0</span></span>): [<span class="built_in">number</span>, <span class="built_in">number</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，传入 <code>undefined</code> 参数就能触发默认值（如果有的话）。</p><h3 id="3-5-3-参数解构-解包"><a href="#3-5-3-参数解构-解包" class="headerlink" title="3.5.3 参数解构 (解包)"></a>3.5.3 参数解构 (解包)</h3><p>JavaScript 原生支持参数解构。在 TypeScript 中则需要声明类型才能使用。</p><p>要解构的参数大多数情况下，要么是对象，要么是数组 / 元组，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[x, y]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">s</span>(<span class="params">&#123; a, b, c &#125;: &#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; c: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法请类比 “对象类型” 一节的解构赋值，也要注意两类语法的区别。</p><h3 id="3-5-4-剩余参数-args"><a href="#3-5-4-剩余参数-args" class="headerlink" title="3.5.4 剩余参数 (args)"></a>3.5.4 剩余参数 (args)</h3><p>使用之前在元组一节提到的 REST 运算符即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rest 参数被包装成数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">joinNumbers</span>(<span class="params">...nums: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest 参数被包装成元组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">...args: [<span class="built_in">boolean</span>, <span class="built_in">number</span>?]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 rest 参数被包装成元组，其中的元素也可以是可选参数。</p><h3 id="3-5-5-只读参数"><a href="#3-5-5-只读参数" class="headerlink" title="3.5.5 只读参数"></a>3.5.5 只读参数</h3><p>和 C++ 的 <code>const</code> 修饰参数一模一样。不多赘述：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arraySum</span>(<span class="params">arr: <span class="keyword">readonly</span> <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-6-函数重载"><a href="#3-5-6-函数重载" class="headerlink" title="3.5.6 函数重载"></a>3.5.6 函数重载</h3><p>TypeScript 因为有类型，所以支持了 JavaScript 所不支持的 重载。</p><p>使用方法很简单，要注意的点和其他静态类型语言一样（避免签名模糊等问题）。</p><p>不过 TypeScript 中，如果能用联合类型避免重载，就用联合类型。</p><h2 id="3-6-TypeScript-的类"><a href="#3-6-TypeScript-的类" class="headerlink" title="3.6 TypeScript 的类"></a>3.6 TypeScript 的类</h2><p>TypeScript 作为真正的静态类型语言，和 JavaScript 相比，最大的差异是引入了真正的开发者可定义的类。</p><h3 id="3-6-1-定义"><a href="#3-6-1-定义" class="headerlink" title="3.6.1 定义"></a>3.6.1 定义</h3><p>下面的示例概括了 TypeScript 类基本的使用方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">string</span> = <span class="string">&quot;abc&quot;</span>;        <span class="comment">// 允许类内初始化</span></span><br><span class="line">    p!: <span class="built_in">number</span>;                <span class="comment">// ！修饰符告诉编译器该类型不为空，可以不在类内、构造函数内初始化</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">q</span>: <span class="built_in">number</span>;        <span class="comment">// 和 Java 的 const 一样，仅允许初始化一次</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类的构造函数名只能是 construtor，允许可选、默认参数</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">_x: <span class="built_in">number</span>, _y: <span class="built_in">number</span>, _q: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="comment">// 类内的 this 对象就和其他面向对象的静态语言一样含义。具体含义见章末</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = _x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = _y;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">q</span> = _q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类中的方法不需要 function 修饰。但方法一定需要定义在类内</span></span><br><span class="line">    <span class="comment">// 如果要定义在类外，就是在初始化为对象后再进行赋值了</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">a</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类中的构造函数、其他方法都允许重载</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">r</span>: <span class="built_in">number</span>, <span class="attr">s</span>: <span class="built_in">number</span>, ...<span class="attr">args</span>: <span class="built_in">number</span>[]): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="attr">init</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span> + r + s + args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, init);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-2-类的可见性修饰符"><a href="#3-6-2-类的可见性修饰符" class="headerlink" title="3.6.2 类的可见性修饰符"></a>3.6.2 类的可见性修饰符</h3><p>TypeScript 的类更像 C++ 的结构体，<strong>不加可见性修饰符，默认 <code>public</code></strong>。</p><p>使用方法同其他面向对象的静态类型语言，略。</p><h3 id="3-6-3-类的访问器"><a href="#3-6-3-类的访问器" class="headerlink" title="3.6.3 类的访问器"></a>3.6.3 类的访问器</h3><p>如果你学过 Python，那么恭喜，TypeScript 的访问器 <code>set</code>、<code>get</code> 可以<strong>完全按照</strong> Python 的装饰器 <code>@setter</code>、<code>@getter</code> 理解。</p><p>定义方法如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> _name!: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问器前加入 get / set 关键字</span></span><br><span class="line">    <span class="comment">// 访问器的名字必须与要定义的属性名相同</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="title class_">String</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外访问，直接当作普通属性使用，但会调用 get 实时计算</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">test</span>: T = <span class="keyword">new</span> T;</span><br><span class="line">test.<span class="property">name</span> = <span class="string">&quot;Hello&quot;</span>;    <span class="comment">// 调用了 set 访问器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">name</span>);    <span class="comment">// 调用了 get 访问器</span></span><br></pre></td></tr></table></figure><p>根据它们的用途，可以很显然地知道：</p><ul><li><code>get</code> 访问器不能有参数；</li><li>如果一个属性不存在 <code>set</code> 访问器，那么这个参数只读，等价于被 <code>readonly</code> 修饰；</li></ul><h3 id="3-6-4-类的静态成员"><a href="#3-6-4-类的静态成员" class="headerlink" title="3.6.4 类的静态成员"></a>3.6.4 类的静态成员</h3><p>和 Java、C++ 一样，使用 <code>static</code> 关键字修饰静态变量。</p><p>但是！和其他语言不太一样，TypeScript 的静态成员（属性和方法）不能由实例调用，只能由类名调用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">printX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">t</span>: <span class="title class_">MyClass</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>;</span><br><span class="line">t.<span class="title function_">printX</span>();    <span class="comment">// TypeError</span></span><br><span class="line">t.<span class="property">x</span>;        <span class="comment">// TypeError</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">printX</span>();    <span class="comment">// Correct</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">x</span>;            <span class="comment">// Correct</span></span><br></pre></td></tr></table></figure><h3 id="3-6-5-类的继承"><a href="#3-6-5-类的继承" class="headerlink" title="3.6.5 类的继承"></a>3.6.5 类的继承</h3><p>和 Java 一样，TypeScript 使用 <code>extend</code> 关键字进行类的继承。</p><p>还是和 Java 一样，TypeScript 也有 <code>super</code> 关键字，可以 <strong>用来调用父类构造函数、调用父类中已被重写的方法等等</strong>。</p><p>类继承时，不同可见性修饰符下对应数据域的继承原则与 Java、C++ 类似，但是有差别：</p><ul><li><p>父类 protected 的数据成员，子类 <strong>可以转为 public，但不能转为 private</strong>；</p></li><li><p>子类可以定义与父类同名不同类型的属性，但是如果希望它们的赋值关联，则需要 <code>declare</code> 关键字修饰；</p></li></ul><h3 id="3-6-6-抽象类"><a href="#3-6-6-抽象类" class="headerlink" title="3.6.6 抽象类"></a>3.6.6 抽象类</h3><p>和 C++ / Java 一样，TypeScript 中的抽象类关键字也是 <code>abstract</code>、也不允许实例化、不允许 <code>private</code> 修饰、抽象成员不允许有实现。</p><p>同时，TypeScript 允许使用 <code>abstract</code> 修饰抽象类的<strong>数据成员（Java 和 C++ 做不到）</strong>、成员函数，强制要求子类（非抽象类）实现。</p><p>值得注意的是，<strong>一个类最多只能继承于一个抽象类（再多就应该用接口 interface 了）</strong>。</p><h3 id="3-6-7-FAQ-类中的-this-在-TypeScript-里究竟是什么"><a href="#3-6-7-FAQ-类中的-this-在-TypeScript-里究竟是什么" class="headerlink" title="3.6.7 FAQ: 类中的 this 在 TypeScript 里究竟是什么"></a>3.6.7 FAQ: 类中的 <code>this</code> 在 TypeScript 里究竟是什么</h3><p>我们知道，在 JavaScript 中，<code>this</code> 含义丰富：</p><ul><li><p>在方法中，this 表示该方法所属的对象；</p></li><li><p>如果单独使用，this 表示全局对象；</p></li><li><p>在函数中，this 表示全局对象（严格模式下为 <code>undefined</code>）；</p></li></ul><p>那么在 TypeScript 的类中，含义就和其他面向对象语言类似，是指 “该方法所在类的当前对象”。</p><p>实际上，这里还有几个问题没有解决：</p><ol><li>在 JavaScript 中允许定义一个原型，充当面向对象编程的工具。它允许将一个对象的方法赋给另一个变量，<strong>赋予后，<code>this</code> 将跟随新的变量脱离原来的作用域</strong>。在 TypeScript 中，这种行为是怎样的？</li><li>如果在 JavaScript 的原型中使用闭包/箭头函数，那么在其中的 <code>this</code> 将不再指代当前对象，除非手动传递 <code>this</code> 的值。在 TypeScript 中的行为是怎样的？</li></ol><p>针对第一个问题，TypeScript 为了防止改变函数语义（本来的 <code>this</code> 是类中对象，如果将函数赋给其他变量后 <code>this</code> 就成为了新变量作用域中的 <code>this</code>），<strong>允许类中方法第一参数声明 <code>this</code> 类型（就像 Python 的 <code>self</code>）</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> tt = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">test</span>(<span class="attr">this</span>: <span class="title class_">Test</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">tt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论在哪里，只要 typescript 检测到第一个参数是 this，就会自动将当前环境 this 填充进去，并且不会在 JavaScript 中展现出来。</p></blockquote><p>这样，如果赋给其他变量后，一旦涉及改变了 <code>this</code> 的函数调用，编译器会指出错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="title class_">Test</span>.<span class="property">test</span>;</span><br><span class="line"></span><br><span class="line">b.();    <span class="comment">// TypeError, 因为此时的 this 是全局对象</span></span><br></pre></td></tr></table></figure><blockquote><p>该参数可以省略（但省略后会回到 JavaScript 的行为）。</p></blockquote><p>当然，你可以在构造函数中，使用 JavaScript 原生方法 <code>bind</code> 将方法与类的 <code>this</code> 环境绑定，这样无论怎么赋值，都是那个对象对应的方法了 —— 这也是最稳妥的做法。</p><p>对第二个问题，TypeScript 也需要担心语义问题，因此如果你打开了 <code>noImplicitThis</code> 编译选项，那么 TypeScript 编译器会直接报错。否则其行为和 JavaScript 一致。</p><hr><p>最后补充一个 TypeScript 的小特性：</p><p>TypeScript 中的类能作为类型使用，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="attr">value</span>: <span class="built_in">string</span>): <span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-TypeScript-的接口"><a href="#3-7-TypeScript-的接口" class="headerlink" title="3.7 TypeScript 的接口"></a>3.7 TypeScript 的接口</h2><h3 id="3-7-1-定义和使用"><a href="#3-7-1-定义和使用" class="headerlink" title="3.7.1 定义和使用"></a>3.7.1 定义和使用</h3><p>TypeScript 的接口和 Java 非常类似：接口和抽象类一样抽象，<strong>方法全是抽象方法（不能有实现）</strong>、可省略所有的 <code>abstract</code> 关键字。但是属性不是常量属性（只读）而是抽象属性（不允许赋值），因为在 TypeScript 中 <code>abstract</code> 可以修饰数据成员。</p><p>如下由于接口算是个抽象类，因此接口间可以继承，和 Java 的接口继承一样，要注意冲突问题。</p><p>此外，接口还可以继承于 <code>type</code>（类型别名，它和接口的区别是什么？接下来再讨论）。</p><p>甚至接口还能继承于普通的 <code>class</code>。此时 <code>class</code> 中所有的属性、方法全部保持类型，变成对应的抽象属性、抽象方法。<strong>这里我们可以知道，被接口继承的类不能有 <code>private</code>/<code>protected</code> 修饰的成员，因为这样会导致 “无法实现的抽象成员” 的出现</strong>。</p><h3 id="3-7-2-接口合并"><a href="#3-7-2-接口合并" class="headerlink" title="3.7.2 接口合并"></a>3.7.2 接口合并</h3><p>这只是个特性，并不希望你为了使用它而使用，只是在必须的时候才使用。因为这样会降低你的代码可读性。</p><ul><li><p>情况 1：如果你重复定义了接口，那么这两次定义的内容会合并：</p><ul><li>同名函数 -&gt; 重载，同名属性 -&gt; 联合类型，不同名的直接并列；</li><li><strong>如果有不能联合/重载的部分</strong>，编译器会抛出错误；</li></ul></li><li><p>情况 2：如果你对某几个不同名的接口使用了类型联合运算符，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">s</span>: <span class="title class_">Inter1</span> | <span class="title class_">Inter2</span>;</span><br></pre></td></tr></table></figure><p>这就相当于显示将不同名的接口合并为一个接口 <code>s</code>，合并规则和同名接口合并相同；</p></li></ul><h3 id="3-7-3-接口-Interface-和类型别名-type-的异同"><a href="#3-7-3-接口-Interface-和类型别名-type-的异同" class="headerlink" title="3.7.3 接口 (Interface) 和类型别名 (type) 的异同"></a>3.7.3 接口 (Interface) 和类型别名 (type) 的异同</h3><p>相同点：都能创建一个类型、定义方式极其类似。</p><p>不同点：</p><ul><li><code>type</code> 可以定义非对象类型，而 <code>interface</code> 只能定义对象类型；</li><li><p><code>interface</code> <strong>可以继承、合并</strong>，而 <code>type</code> 不行，重复定义同名 <code>type</code> 会报错；</p></li><li><p><code>type</code> 内部不能使用 <code>this</code> 指代当前对象，<code>interface</code> 则可以；</p></li></ul><p>总结：除去一些复杂的类型运算，其他情况优先使用 <code>interface</code>；</p><h2 id="3-8-TypeScript-的泛型"><a href="#3-8-TypeScript-的泛型" class="headerlink" title="3.8 TypeScript 的泛型"></a>3.8 TypeScript 的泛型</h2><p>TypeScript 的泛型定义、使用方法与 Java 相同，可以用在类、函数、接口、类型别名、对象上，并且<strong>可以指定默认类型</strong>，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;<span class="title class_">NumType</span> = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  value!: <span class="title class_">NumType</span>;</span><br><span class="line">  add!: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> <span class="title class_">NumType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"></span><br><span class="line">foo.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">foo.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TypeScript 中，<strong>泛型的另一种常用方式是：作为类型参数的约束条件</strong>。</p><p>如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> comp&lt;T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: T) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样约束了 <strong>传入的类型必须是具有 <code>length: number</code> 字段的对象</strong>，减少了代码犯错的概率。</p><p>我们可以总结为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">TypeParam</span> <span class="keyword">extends</span> <span class="title class_">ConstraintType</span>&gt;</span><br></pre></td></tr></table></figure><p>表示类型参数必须是 <code>ConstraintType</code> 的子类型。</p><p>不过为了代码可读性，还是提出以下建议：</p><ul><li>尽量少用泛型：降低了代码可读性；</li><li>泛型的类型参数越少越好；</li></ul><h2 id="3-9-TypeScript-Enum-类型"><a href="#3-9-TypeScript-Enum-类型" class="headerlink" title="3.9 TypeScript Enum 类型"></a>3.9 TypeScript Enum 类型</h2><h3 id="3-9-1-定义与使用"><a href="#3-9-1-定义与使用" class="headerlink" title="3.9.1 定义与使用"></a>3.9.1 定义与使用</h3><p>和其他大多数静态语言一样，TypeScript 也有枚举类型。它的枚举类型更像 C++ 11 的 <code>enum Class</code>，定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title class_">Red</span>,</span><br><span class="line">    <span class="title class_">Green</span>,</span><br><span class="line">    <span class="title class_">Blue</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>值从 0 递增，但值不重要；</li><li>是个类型也是值（变量不能和枚举类型同名），因此可以 <code>Color.Red</code> 这样调用，增强代码可读性；</li><li>枚举值只读，可以是自身类型（<code>Color</code>）也可以是 <code>number</code>（因此枚举类型做参数时，传入一切 <code>number</code> 都不报错）；</li></ul><p>通常建议枚举类型前加 <code>const</code> 修饰，这样可以帮助编译器优化代码，提升性能：<code>const enum</code>；</p><h3 id="3-9-2-特性"><a href="#3-9-2-特性" class="headerlink" title="3.9.2 特性"></a>3.9.2 特性</h3><ul><li><p>同名枚举类型会像同名接口的行为一样合并；</p></li><li><p>允许字符串做枚举类型的值，要设置，则全员都设置，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">MediaTypes</span> &#123;</span><br><span class="line">    <span class="title class_">JSON</span> = <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="variable constant_">XML</span> = <span class="string">&quot;application/xml&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="title class_">Accept</span>: <span class="title class_">MediaTypes</span>.<span class="property">JSON</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>字符串枚举可以由联合类型代表：<code>function move(where: &quot;Up&quot; | &quot;Down&quot; | &quot;Left&quot; | &quot;Right&quot;);</code></p></li><li><p>在 C++ 的枚举类型中，有很多人抱怨不方便通过枚举值打印出枚举成员的字符串名。在 TypeScript 中就有方法：<strong>反向映射</strong>，我们调用 <code>EnumClass[n]</code> 就能得到索引为 <code>n</code> 的枚举成员的字符串名。</p><blockquote><p>这与 TypeScript 编译器将 <code>enum</code> 翻译成 JavaScript 的方式有关：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="title class_">Apple</span>,</span><br><span class="line"> <span class="title class_">Banana</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Test</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Test</span>) &#123;</span><br><span class="line"> <span class="comment">// 相当于两句赋值：Test[&quot;Apple&quot;] = 0, Test[0] = &quot;Apple&quot;;</span></span><br><span class="line"> <span class="title class_">Test</span>[<span class="title class_">Test</span>[<span class="string">&quot;Apple&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"> <span class="title class_">Test</span>[<span class="title class_">Test</span>[<span class="string">&quot;Banana&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Test</span> || <span class="title class_">Test</span> = &#123;&#125;);</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="3-9-3-keyof-关键字与枚举类型"><a href="#3-9-3-keyof-关键字与枚举类型" class="headerlink" title="3.9.3 keyof 关键字与枚举类型"></a>3.9.3 <code>keyof</code> 关键字与枚举类型</h3><p>在 TypeScript 中，<code>keyof</code> 关键字有点类似 Python 的 <code>__dict__</code> 属性，<strong>针对对象 / 类，返回对应类型的所有属性、方法名</strong>，不过 TypeScript 的返回是 “<strong>属性/方法名字符串组成的联合类型</strong>”（就是个字符串枚举类型！），而 Python 返回的是对象数组。</p><p>还有一点值得注意，TypeScript 枚举类型想要使用 <code>keyof</code> 获取成员名字符串联合类型，必须加 <code>typeof</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  B = <span class="string">&quot;b&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;A&#x27;|&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="keyword">typeof</span> <span class="title class_">MyEnum</span>;</span><br></pre></td></tr></table></figure><p>否则会被编译器当作 <code>number</code> 类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot; |</span></span><br><span class="line"><span class="comment">// &quot;toPrecision&quot; | &quot;valueOf&quot; | &quot;toLocaleString&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="title class_">MyEnum</span>;</span><br></pre></td></tr></table></figure><h2 id="3-10-TypeScript-的类型断言"><a href="#3-10-TypeScript-的类型断言" class="headerlink" title="3.10 TypeScript 的类型断言"></a>3.10 TypeScript 的类型断言</h2><p>类型断言的存在，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型（而不是改变这个值的类型）。<u>TypeScript 一旦发现存在类型断言，<strong>并且 原类型 兼容 断言的类型</strong>，就不再对该值进行类型推断，而是直接采用断言给出的类型</u>。</p><blockquote><p>再次强调：<strong>断言的前提是 原类型 兼容 断言的类型</strong>！</p></blockquote><p>由于 TypeScript 新版本支持了 React 的 JSX 语法，因此如果你要使用 JSX，则不能用旧语法（<code>&lt;assertType&gt;value</code>，这里的尖括号是真的尖括号），应该使用新语法：<code>value as assertType</code>；</p><p>那么你可能会问，TypeScript 编译器的类型推断不是已经足够了吗？虽然它增强了语言灵活性，但让人来控制类型推断不会导致出错可能性增加？</p><p><strong>确实！它不能乱用，否则会出大问题。</strong></p><p>但是只要在适当的场合使用就能发挥它的优势。以下是常用场景：</p><h3 id="3-10-1-代替明确的类型缩窄"><a href="#3-10-1-代替明确的类型缩窄" class="headerlink" title="3.10.1 代替明确的类型缩窄"></a>3.10.1 代替明确的类型缩窄</h3><p>早在 3.2.5 节中就提到，对于一些联合类型，我们必须使用类型缩窄，才能使用某个特定类型的方法，以此避免运行时的类型错误，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>): <span class="built_in">string</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 可能返回 null，也可能返回 string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">test</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="title function_">doSomething</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型缩窄</span></span><br><span class="line"><span class="keyword">if</span> (test !== <span class="literal">null</span>)</span><br><span class="line">    test.<span class="title function_">toUpperCase</span>();</span><br></pre></td></tr></table></figure><p>现在，假设 <strong>我们根据代码逻辑，<u>明确知道</u> <code>test</code> 肯定不会为 <code>null</code>，但是编译器不知道</strong>，还以为可能是 <code>null</code>。</p><p>这个时候我们可以明确告诉编译器，它不可能为 <code>null</code>，于是这么用就无需使用类型缩窄了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">test</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="title function_">doSomething</span>();</span><br><span class="line"></span><br><span class="line">(test <span class="keyword">as</span> <span class="built_in">string</span>).<span class="title function_">toUpperCase</span>();</span><br></pre></td></tr></table></figure><h3 id="3-10-2-直接量的常量断言"><a href="#3-10-2-直接量的常量断言" class="headerlink" title="3.10.2 直接量的常量断言"></a>3.10.2 直接量的常量断言</h3><h4 id="基本类型直接量"><a href="#基本类型直接量" class="headerlink" title="基本类型直接量"></a>基本类型直接量</h4><p>我们知道，TypeScript 的常量是不能被改变的量，那么常量声明语法 <code>as const</code> 就可以<strong>将基本类型直接量变为对应的值类型</strong>，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;TypeScript&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>这样在编译时，TypeScript 编译器会将 <code>s</code> 看作 <code>&quot;TypeScript&quot;</code> 值类型。这样有什么用呢？<strong>对 直接量 的常量断言，是<u>看作对应的值类型</u></strong>。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;JavaScript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lang</span> = <span class="string">&quot;JavaScript&quot;</span> | <span class="string">&quot;TypeScript&quot;</span> | <span class="string">&quot;Python&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setLang</span>(<span class="params">language: Lang</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setLang</span>(s); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>这里 <code>Lang</code> 类型是等价于枚举类型，如果传入普通字符串，即便值和枚举量一致，但编译器没法保证类型正确性。</p><p>所以我们可以这么做：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;JavaScript&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>这样编译器会将 <code>s</code> 看作 <code>&quot;JavaScript&quot;</code> 值类型，保证以后也不会更改，因此修复了这个问题。当然也与直接用 <code>const</code> 等价：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&quot;JavaScript&quot;</span>;</span><br></pre></td></tr></table></figure><p>不过值得注意的是：<strong>常量断言不能用于 已被赋值（定义）的变量！</strong>因为 TypeScript 不允许中途更改变量的读写性质。</p><h4 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h4><p>如果将 <code>as const</code> 类型断言修饰对象，那么和修饰基本类型直接量的行为就有些不同了。</p><p><u><strong>也就是说，这个时候 <code>const</code> 修饰符和 <code>as const</code> 断言就有区别了！</strong></u></p><ul><li><code>const</code> 修饰对象直接量时，只是不允许更改对象引用，但其中数据可更改（因为是可变数据类型）；</li><li><code>as const</code> 断言对象直接量时，<strong>其中所有数据域 / 成员都改为只读属性</strong>。</li></ul><p>例如：</p><ul><li><p>数组 / 元组直接量 -&gt; <u><strong>只读元组</strong></u>（同时确定了长度、类型 和值）；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a1 的类型推断为 number[]</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a2 的类型推断为 readonly [1, 2, 3] （元组）</span></span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure></li><li><p>对象直接量 -&gt; 数据域全部只读；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: number; y: number; &#125;，普通对象常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: 1; y: number; &#125;，数据域直接量常量断言 的 对象常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v3 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 类型是 &#123; readonly x: 1; readonly y: 2; &#125;，常量断言 的 对象常量</span></span><br></pre></td></tr></table></figure></li></ul><p>那么这样做有什么用？举个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">nums</span>: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">add</span>(...nums);        <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>如果我想<strong>将已知长度的数组解构传给函数</strong>，但 <code>const</code> 修饰，甚至是 <code>readonly</code> 修饰，也并不能说明这是个定长度为 2、定内容的数组，只能说明这个数组对象引用不会变，所以编译器认为不行。</p><p>这个时候使用 <code>as const</code> 断言就能提示编译器这个数组是<strong>只读元组</strong>，并且长度为 2，每个位置上的类型都是值类型，能作为参数传递而不出问题。</p><h3 id="3-10-3-非空断言"><a href="#3-10-3-非空断言" class="headerlink" title="3.10.3 非空断言"></a>3.10.3 非空断言</h3><p>和 “明确缩窄类型” 的作用很像，但非空断言只针对 “空类型的类型缩窄”。就是根据代码逻辑，明确知道某些对象的类型不可能为 <code>null / undefined</code>，<strong>在节省不必要的判断的同时，让编译器不报错</strong>。</p><p>但请注意！<strong>一定要确定 “肯定非空” 的逻辑！</strong>否则会出现运行时问题。</p><p><strong>如果不能确保，就请通过手动检查来缩窄类型！</strong></p><p>使用非空断言的语法就是前面提到的：尾缀非空断言运算符 <code>!</code>；</p><p>举个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)!;</span><br></pre></td></tr></table></figure><p>表示 <code>document</code> 中肯定有 ID 为 <code>root</code> 的元素，不用考虑空的情况了。</p><p>还有种场景是在之前提到过的，如果类中有些属性要在类外、构造函数外初始化，需要给该属性加非空断言，不然编译器认为没有初始化实例属性（如果你的属性定义没有 <code>null</code> 类型的话）而报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>; <span class="comment">// TypeError</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Empty</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x!: <span class="built_in">number</span>; <span class="comment">// Correct</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Empty</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-4-类型断言函数"><a href="#3-10-4-类型断言函数" class="headerlink" title="3.10.4 类型断言函数"></a>3.10.4 类型断言函数</h3><p>一类函数，如果它的作用是：“保证参数符合某种类型，不符合就抛出错误，符合就什么都不做”，那么就将这类函数称为 “类型断言函数”。</p><p>由于断言函数要么不返回（<code>void</code>），要么抛出错误（<code>never</code>），因此为了断言函数的语义清晰性，TypeScript 3.7 引入了断言函数声明写法，以判断字符串类型为例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value: <span class="built_in">unknown</span></span>): asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;string&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Not a string&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果断言函数返回结果（不符合断言函数标准的行为），也会报错。</p><p>如果是判断真值（不为 <code>false</code>、<code>undefined</code>、<code>null</code>）的话，断言函数还能更简单地书写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">condition: <span class="built_in">unknown</span>, message: <span class="built_in">string</span></span>): asserts condition &#123;</span><br><span class="line">    <span class="keyword">if</span> (!condition) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样这个函数就和 Python 的 <code>assert</code> 关键字行为类似了。</p><hr><p>补充：TypeScript 的 <code>is</code> 关键字</p><p>TypeScript 中，<code>is</code> 除了充当类型断言函数的尾缀关系，还能作为<strong>类型判断函数（用于判断参数类型，返回值一定为 <code>boolean</code> 类型）</strong>的尾缀关系，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">pet: Fish | Bird</span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但 <code>is</code> 关键字也<strong>仅限于</strong>这两类判断函数的尾缀，以此更清晰地表示这类函数的逻辑。</p><h1 id="Chapter-4-TypeScript-模块与命名空间"><a href="#Chapter-4-TypeScript-模块与命名空间" class="headerlink" title="Chapter 4. TypeScript 模块与命名空间"></a>Chapter 4. TypeScript 模块与命名空间</h1><h2 id="4-1-模块"><a href="#4-1-模块" class="headerlink" title="4.1 模块"></a>4.1 模块</h2><h3 id="4-1-1-定义"><a href="#4-1-1-定义" class="headerlink" title="4.1.1 定义"></a>4.1.1 定义</h3><p>TypeScript 文件有 2 类：</p><ul><li>一种是全局的脚本文件。<strong>类似 <code>shell</code> 脚本，其中的变量、函数等等内容可以直接被其他接下来调用的所有文件访问到</strong>；</li><li>另一种是 TypeScript 模块。模块内部的变量、函数、类只在内部可见，对于模块外部是不可见的，这就相当于 C++ 这类语言的普通文件。</li></ul><p>Q: 这两种文件如何区分？</p><p>A: <strong>任何包含 import 或 export 语句的文件，就是一个模块（module）。相应地，如果文件不包含 export 语句，就是一个全局的脚本文件。</strong></p><p>Q: 既然模块对外部具有封装性，那么它们间如何相互调用？</p><p>A: 答案很简单，模块暴露给外部的接口，必须用 <code>export</code> 命令声明；如果其他文件要使用模块的接口，必须用 <code>import</code> 命令来输入。</p><h3 id="4-1-2-特性"><a href="#4-1-2-特性" class="headerlink" title="4.1.2 特性"></a>4.1.2 特性</h3><ul><li><code>export &#123;&#125;;</code> 语句不会进行任何操作，但是这个文件的内部变量对外不再可见；</li><li>TypeScript 允许导入导出 <code>type</code>（类型别名），需要 <code>export type &lt;typename&gt;</code>；</li><li>TypeScript 也允许 <strong>默认导出、命名导出</strong>，用法和 JavaScript 类似；<ul><li><strong>但是导入类型别名时，需要加 <code>type</code> 关键字前缀</strong>；</li><li>导入接口、类时，和 JavaScript 普通对象的导入方法相同；</li></ul></li></ul><h3 id="4-1-3-CommonJS-模块支持"><a href="#4-1-3-CommonJS-模块支持" class="headerlink" title="4.1.3 CommonJS 模块支持"></a>4.1.3 CommonJS 模块支持</h3><p>众所周知，NodeJS 有专门的模块格式，与 ECMAScript 原生脚本不兼容。但是 TypeScript 兼容了 CommonJS 模块的导入：</p><ul><li><code>import &lt;name&gt; = require(&quot;&lt;moduleName&gt;&quot;);</code></li><li><code>export = &lt;exportObj&gt;</code>；</li></ul><h3 id="4-1-4-编译时模块定位-Module-Resolution"><a href="#4-1-4-编译时模块定位-Module-Resolution" class="headerlink" title="4.1.4 编译时模块定位 (Module Resolution)"></a>4.1.4 编译时模块定位 (Module Resolution)</h3><p>几乎所有要编译的语言，其源文件的编译都要考虑一个问题：如何组织模块间相互位置关系、如何找模块 / 库的位置。</p><p>C++ 中，要么你把源文件全部放在固定目录中，然后用相对路径手动引用。<strong>缺点是一改文件位置就要重写，非常麻烦</strong>；另一种方法是 使用 CMake/Makefile 之类的项目管理工具指定编译操作的过程。</p><p>在 TypeScript 中，也有两种方法。</p><h4 id="引用时手动指定模块路径"><a href="#引用时手动指定模块路径" class="headerlink" title="引用时手动指定模块路径"></a>引用时手动指定模块路径</h4><p>我们在引用模块时可能会这么写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TypeA</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;    <span class="comment">// 省略后缀名，则可查找 *.ts / *.d.ts / *.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;/mod&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br></pre></td></tr></table></figure><p>前两种利用相对路径指定模块位置的方法是 <strong>相对模块表示法</strong>；</p><p>后两种不带有路径信息地指定模块地方法是 <strong>非相对模块表示法</strong>。</p><p>那么 TypeScript 如何查找以上手动指定的模块？由于 NodeJS 引入的 CommonJS 模块，因此有两种查找方式：一种称为 Classic 方法，另一种称为 Node 方法。可以使用编译参数 <code>moduleResolution</code>，指定使用哪一种方法。</p><p>对于 Classic 方法（原生 JavaScript、TypeScript 默认的方法），步骤就非常简单：</p><ul><li><p>对于相对模块表示法，<strong>按照当前模块的位置为基准路径计算相对路径</strong>；</p><blockquote><p>例如 <code>import &#123; t &#125; from &quot;../t&quot;</code> 就从当前脚本，找上个目录里的 <code>t.ts</code>；</p></blockquote></li><li><p>对于非相对模块表示法，<strong>会以当前模块位置为起点，层层向上查找目录</strong>；</p></li></ul><p>对于 Node 方法就有些复杂：</p><ul><li>对于相对模块表示法，例如 <code>let x = require(&quot;./b&quot;)</code>，会进行以下查找步骤：<ol><li>找当前目录的 <code>b.ts</code>、<code>b.tsx</code>、<code>b.d.ts</code>；</li><li>找当前目录的子目录是否有 <code>package.json</code>，这个文件中有无 <code>types</code> 字段，如果有则递归查找；</li><li>找当前目录的 名为 <code>b</code> 的子目录是否包括 <code>index.ts/.tsx/.d.ts</code>；</li></ol></li><li>对于非相对模块表示法，例如 <code>let x = require(&quot;b&quot;)</code>，会进行以下查找步骤：<ol><li>子目录 <code>node_modules</code> 是否包含 <code>b.ts/.tsx/.d.ts</code>；</li><li>子目录 <code>node_modules</code> 中是否存在 <code>package.json</code>，是否有 <code>types</code> 字段，如果有则递归查找；</li><li>子目录 <code>node_modules</code> 中是否存在子目录 <code>@types</code>，如有，则查找其中的 <code>b.d.ts</code>；</li><li>子目录 <code>node_modules</code> 中是否存在子目录 <code>b</code>，其中是否包括  <code>index.ts/.tsx/.d.ts</code>；</li><li>进入上层目录，充分上述步骤，直至找到。</li></ol></li></ul><h4 id="tsconfig-json-配置模块路径"><a href="#tsconfig-json-配置模块路径" class="headerlink" title="tsconfig.json 配置模块路径"></a><code>tsconfig.json</code> 配置模块路径</h4><p>TypeScript 允许开发者在<code>tsconfig.json</code>文件里面，手动指定脚本模块的路径，这样做在一些大型的、依赖关系复杂的项目中就比较方便。</p><p>有如下配置字段可以设置编译器的查找过程：</p><ul><li><p><code>compilerOptions.baseUrl</code>：指定脚本模块的基准目录（<u>该项目的所有源文件的基准位置都被设置在此</u>）。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>表示将 <code>tsconfig.json</code> 所在的目录为基准目录；</p></li><li><p><code>compilerOptions.paths</code>：<strong>指定<u>非相对路径表示法的模块与实际路径的映射</u></strong>。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;jquery&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;node_modules/jquery/dist/jquery&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>上例的 <code>jquery</code> 属性的值是一个数组，可以指定多个路径。如果第一个脚本路径不存在，那么就加载第二个路径，以此类推。</p></li><li><p><code>compilerOptions.rootDirs</code>：<strong>指定无论查找什么模块，必须要额外查找的其他目录</strong>。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rootDirs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/zh&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/de&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/#&#123;locale&#125;&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>此外，如果你发现自己指定了一些路径，编译器就是找不到。那么你可以使用 <code>--traceResolution</code> 编译器选项，让编译器在命令行中打印搜索的路径，相当于一种调试。</p><h2 id="4-2-命名空间"><a href="#4-2-命名空间" class="headerlink" title="4.2 命名空间"></a>4.2 命名空间</h2><p>评价是和 C++ 的 <code>namespace</code> 很类似。使用也很像：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  <span class="title function_">isString</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Utils</span>.<span class="title function_">isString</span>(<span class="string">&quot;no&quot;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>哪怕在一个文件中，也必须 <code>export</code> 才能被外部使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="title class_">Utility</span>.<span class="title function_">log</span>(<span class="string">&quot;Call me&quot;</span>);</span><br><span class="line"><span class="title class_">Utility</span>.<span class="title function_">error</span>(<span class="string">&quot;maybe!&quot;</span>);</span><br></pre></td></tr></table></figure><p>命名空间本身能被 <code>export</code>、也允许合并（行为类似 interface）；</p><h1 id="Chapter-5-TypeScript-装饰器"><a href="#Chapter-5-TypeScript-装饰器" class="headerlink" title="Chapter 5. TypeScript 装饰器"></a>Chapter 5. TypeScript 装饰器</h1><blockquote><p>TypeScript 曾有旧式语法，这里不再作介绍。本章只介绍 TypeScript 5.0 以后的新式装饰器。</p><p>如果你想使用旧式语法，请向编译器传递 <code>--experimentalDecorators</code> 参数。</p></blockquote><h2 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h2><p>TypeScript 的装饰器的定义 和 Python 的装饰器的定义一致，和 Java 的装饰器类似。或者说，“装饰器” 的概念是跨语言的、抽象概念。主要内容是：</p><ul><li>前缀是 <code>@</code>，后面必须是一种特殊表达式。这个表达式要求：<strong>要么就是个函数名，要么表达式执行后返回一个函数</strong>；</li><li>这个通过后面表达式所得到的函数称为<u><strong>装饰器函数</strong></u>。装饰器函数可以接受所修饰对象的一些相关值作为参数，<strong>并且要么不返回值（装饰过程），要么返回新对象用来替换原来的目标对象（装饰对象）</strong>。</li></ul><p>装饰器的作用是，<u><strong>通过类似 “外部注入” 的方式，改变被装饰对象的行为</strong></u>。</p><p>比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样使用类 <code>A</code> 的时候，其行为就会被装饰器 <code>Injectable</code> 所改变。</p><h2 id="5-2-源码定义"><a href="#5-2-源码定义" class="headerlink" title="5.2 源码定义"></a>5.2 源码定义</h2><p>我们从概念中可知，要了解 TypeScript 装饰器怎么用、机制是什么，最主要看装饰器函数。它在 TypeScript 中的定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Decorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="built_in">string</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer?(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      get?(): <span class="built_in">unknown</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">      set?(value: <span class="built_in">unknown</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span> | <span class="title class_">ReplacementValue</span>;</span><br></pre></td></tr></table></figure><p>可以看到，<code>Decorator</code> 是一个函数类型，它接收两个参数：</p><ul><li><p><code>value</code>：<strong>所装饰的对象</strong>，在使用 <code>@Decorator</code> 时，相当于语法糖，<strong>自动将修饰对象传递到此参数</strong>；</p></li><li><p><code>context</code>：上下文对象，看起来有很多内容，实际上是为了适应多种装饰器的类别而定义的（很多可选参数，只需要记住几种常用的装饰器类别就行）；</p><blockquote><p>在 TypeScript 中，定义了一个原生接口 <code>ClassXXXDecoratorContext</code>，描述的就是 <code>typeof Decorator.context</code>；</p></blockquote><ul><li><code>kind</code>：装饰器类别，<strong>只有 6 种，分别对应了 6 种装饰器</strong>：<code>&quot;class&quot;</code>（类装饰器）、<code>&quot;method&quot;</code>（方法装饰器）、<code>&quot;getter&quot;</code>（读装饰器）、<code>&quot;setter&quot;</code>（写装饰器）、<code>&quot;field&quot;</code>（属性装饰器）、<code>&quot;accessor&quot;</code>（访问装饰器）；</li><li><code>name</code>：所装饰对象的名称（例如类名、函数名、属性名等等）；</li><li><code>addInitializer()</code>：<strong>添加被修饰对象初始化后的逻辑</strong>；</li><li><code>private</code>：<strong>所装饰对象是不是一个类的私有成员</strong>；</li><li><code>static</code>：<strong>所装饰对象是不是一个类的静态成员</strong>；</li><li><code>access</code>：<strong>包含所修饰对象的访问器 <code>get</code> 和 <code>set</code></strong>；</li></ul></li></ul><h3 id="5-2-1-类装饰器"><a href="#5-2-1-类装饰器" class="headerlink" title="5.2.1 类装饰器"></a>5.2.1 类装饰器</h3><p>类装饰器是 <code>context.kind</code> 字段为 <code>&quot;class&quot;</code> 的装饰器，<strong>用来装饰 TypeScript 类</strong>。</p><p><u><strong>它只需定义装饰器 <code>context</code> 可选成员的 <code>addInitializer()</code></strong></u>，用在类上就是 <strong>类完全定义后、构造函数前执行的 <code>initializer</code> 函数</strong>。</p><p>如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;class&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>常见的使用场景有：</p><ol><li><p>向类中添加一个外部方法；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&quot;class&quot;</span>) &#123;</span><br><span class="line">        value.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Greeter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">u.<span class="title function_">greet</span>();    <span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure><p><strong>作用原理是，向传入其中的类调用 <code>prototype</code> 获取类的原型，添加方法 <code>greet</code></strong>；</p></li><li><p>替换被修饰类的构造函数（例如添加一些 side effects）/ 直接替换被修饰的类；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params">value: <span class="built_in">any</span>, context: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> wrapper = <span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    instanceCount++;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">value</span>(...args);</span><br><span class="line">    instance.<span class="property">count</span> = instanceCount;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">MyClass</span>;</span><br><span class="line"></span><br><span class="line">  wrapper.<span class="property"><span class="keyword">prototype</span></span> = value.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// A</span></span><br><span class="line">  <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@countInstances</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">inst1 <span class="keyword">instanceof</span> <span class="title class_">MyClass</span>; <span class="comment">// true</span></span><br><span class="line">inst1.<span class="property">count</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>解释一下，因为 JavaScript 和 TypeScript 中的类型 <code>class</code>，只要<strong>是个构造函数就能用 <code>class</code> 声明</strong>。借助这个特性，我们能更换被修饰类的构造函数。</p><p>在装饰器内定义一个闭包（新的构造函数，<code>new</code> 调用了原来构造函数），最后将函数的 <code>prototype</code> 属性统一，再返回就是新的构造函数了。</p><p>这个时候，返回的构造函数就替换了原来的构造函数（也就是替换了类）。按这种思想，<strong>如果你不想用 <code>prototype</code> 这种原生 JavaScript 的内容，你还可以直接返回一个临时子类，来实现同样效果</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params">value: <span class="built_in">any</span>, context: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> value &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(...args);</span><br><span class="line">      instanceCount++;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = instanceCount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更改被修饰类的创建行为（修改 <code>new</code> 的行为）；</p><p>我们注意到，JavaScript 的构造函数中，有 <code>new</code> 对象可供使用，<code>new.target</code> 表示使用 <code>new</code> 调用这个构造函数的目标对象。我们可以借此控制 <code>new</code> 的行为，例如禁止 <code>new</code> 新建实例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionCallable</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value <span class="keyword">as</span> <span class="built_in">any</span>, &#123;kind&#125; <span class="keyword">as</span> <span class="built_in">any</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&#x27;class&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;This function can’t be new-invoked&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">value</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@functionCallable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> robin = <span class="title class_">Person</span>(<span class="string">&#x27;Robin&#x27;</span>);</span><br><span class="line">robin.<span class="property">name</span> <span class="comment">// &#x27;Robin&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>在类的定义后、类实例初始化前追加行为；</p><p>这里就需要使用到装饰器 <code>addInitializer</code>，<strong>这个函数将在 类的定义结束后（不是实例的定义结束后！） 执行</strong>，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addInitializeWrapper</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params">value: <span class="built_in">any</span>, context: ClassDecoratorContext</span>) &#123;</span><br><span class="line">        context.<span class="title function_">addInitializer</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addInitializeWrapper</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="keyword">var</span> t2 = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br></pre></td></tr></table></figure><p>会在 <code>Test</code> 定义结束后打印一次 <code>Hello</code>；</p></li></ol><h3 id="5-2-2-方法装饰器"><a href="#5-2-2-方法装饰器" class="headerlink" title="5.2.2 方法装饰器"></a>5.2.2 方法装饰器</h3><p>方法装饰器是 <code>context.kind</code> 字段为 <code>&quot;method&quot;</code> 的装饰器，用来装饰 TypeScript 类中的方法。</p><p>需要指定 <code>static</code>（该方法是否在类中为静态方法）、<code>private</code>（该方法是否在类中为私有方法）、<code>access.get</code>（该方法的读访问器）、<code>addInitializer</code>（该方法定义后的初始化逻辑），如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassMethodDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;method&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>常见使用场景有：</p><ol><li><p>直接替换被修饰的方法；</p><p>这种使用方法很简单，就是装饰器函数返回一个新的函数/方法就行，这就算替换了原来的方法，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceWithHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">n: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@replaceWithHello</span></span><br><span class="line">    <span class="title function_">echoName</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给被修饰的方法添加额外逻辑（例如打印日志、延时执行、计时、绑定 <code>this</code> 环境等等）；</p><p>这里就举这 3 个例子。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给被装饰方法添加日志</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addLog</span>(<span class="params">originMethod: <span class="built_in">Function</span>, context: ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> methodName = <span class="title class_">String</span>(context.<span class="property">name</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DEBUG] Entering method: <span class="subst">$&#123;methodName&#125;</span>`</span>);</span><br><span class="line">        <span class="comment">// 在原有作用域 this 下执行</span></span><br><span class="line">        <span class="keyword">const</span> result = originMethod.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DEBUG] Exiting method: <span class="subst">$&#123;methodName&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给被装饰方法延迟执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">millisecond: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 无论在哪里，只要 typescript 检测到第一个参数是 this，就会自动将当前环境 this 填充进去，不在 JavaScript 中展现出来。</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, value: <span class="built_in">Function</span>, context: ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&#x27;method&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 和 call 一样，在指定作用域下执行</span></span><br><span class="line">                    value.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">                &#125;, millisecond);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给被装饰方法自动绑定 this 环境，可以解决 “实例方法被赋给其他变量后语义改变 / 报错” 的问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">boundThis</span>(<span class="params">value: <span class="built_in">Function</span>, context: ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> methodName = context.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">private</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`不能绑定私有方法 <span class="subst">$&#123;methodName <span class="keyword">as</span> <span class="built_in">string</span>&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context.<span class="title function_">addInitializer</span>(<span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[methodName] = <span class="variable language_">this</span>[methodName].<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-2-3-属性装饰器"><a href="#5-2-3-属性装饰器" class="headerlink" title="5.2.3 属性装饰器"></a>5.2.3 属性装饰器</h3><p>属性装饰器是 <code>context.kind</code> 字段为 <code>&quot;field&quot;</code> 的装饰器，用来装饰定义在类中的属性。</p><p>它需要指定 <code>static</code>、<code>private</code>、<code>addInitializer</code>、<code>access.get</code> 和 <code>access.set</code>（比方法装饰器多了写访问器）；</p><p>另外它还有一个与其他装饰器不同点是，它要么不返回值，要么返回一个函数，该函数会自动执行，用来对所装饰属性进行初始化。该函数的参数是所装饰属性的初始值，该函数的返回值是该属性的最终值。</p><p>所以，这下你能明白属性装饰器的作用了吗？在初始化该属性时会触发一次属性装饰器。定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassFieldDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;field&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span>; set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="function">(<span class="params">initialValue: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">unknown</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>我们还注意到，<code>value</code> 是 <code>undefined</code> 类型，这意味着 <strong>属性装饰器不会自动将属性传给内部（因为没有必要，考虑赋给该属性的值 <code>initialValue</code> 即可）</strong>。</p><p>常见的使用场景和类的访问器类似，不再赘述，只是介绍一个样例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logged</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; kind, name &#125; = context;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&quot;field&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">initialValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DEBUG] initializing <span class="subst">$&#123;name&#125;</span> with value <span class="subst">$&#123;initialValue&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> initialValue;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="meta">@logged</span> name = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line"><span class="comment">// &quot;[DEBUG] initializing name with value green&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-4-getter-装饰器、setter-装饰器"><a href="#5-2-4-getter-装饰器、setter-装饰器" class="headerlink" title="5.2.4 getter 装饰器、setter 装饰器"></a>5.2.4 getter 装饰器、setter 装饰器</h3><p>它们是 <code>context.kind</code> 字段为 <code>&quot;getter&quot;/&quot;setter&quot;</code> 的装饰器，是<strong>专门用来装饰类访问器</strong>的装饰器。</p><p>描述如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassGetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;getter&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ClassSetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;setter&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>这两个装饰器要么不返回值，要么返回一个函数，取代原来的取值器或存值器。</p><p>为什么要对访问器进行装饰？比如懒加载的特性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@lazy</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Time Consuming Result&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lazy</span>(<span class="params">value: <span class="built_in">any</span>, &#123; kind, name &#125;: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&quot;getter&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = value.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, name, &#123;</span><br><span class="line">        <span class="attr">value</span>: result,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">inst.<span class="property">value</span>;</span><br><span class="line"><span class="comment">// Calculating...</span></span><br><span class="line"><span class="comment">// &#x27;Time Consuming Result&#x27;</span></span><br><span class="line">inst.<span class="property">value</span>;</span><br><span class="line"><span class="comment">// &#x27;Time Consuming Result&#x27;</span></span><br></pre></td></tr></table></figure><hr><p>还有一个 <code>accessor</code> 装饰器不常用，在这里不再赘述，有兴趣请查看官方文档。</p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> JavaScript </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React框架速通</title>
      <link href="//technical/react-quick-start/"/>
      <url>//technical/react-quick-start/</url>
      
        <content type="html"><![CDATA[<p><i>Written by SJTU-XHW</i></p><p><i>Reference: </i> MDN Doc &amp;&amp; React Doc</p><p><i>本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h1 id="Chapter-0-5-分钟速通-React-框架"><a href="#Chapter-0-5-分钟速通-React-框架" class="headerlink" title="Chapter 0. 5 分钟速通 React 框架"></a>Chapter 0. 5 分钟速通 React 框架</h1><blockquote><p>如果你只有 5 分钟时间，则只需阅读这一章；否则<strong>请从 Chapter 1 开始</strong>。</p><p>建议有一定的原生 JavaScript 基础，至少包括：<strong>JS 基本类型、内置引用类型、函数表达式的各种操作，简单 DOM 操作，JavaScript 事件，JavaScript 异步（Promise）</strong>。</p></blockquote><h2 id="0-1-基本概念"><a href="#0-1-基本概念" class="headerlink" title="0.1 基本概念"></a>0.1 基本概念</h2><ul><li><p>React 应用程序是由 <strong>组件</strong> 组成的。</p><blockquote><p>一个组件是 UI 的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。</p></blockquote></li><li><p>React 组件是<strong>返回标签的 JavaScript 函数</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function MyButton() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;button&gt;I&#x27;m a button&lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>React 组件的使用方法就是直接使用 “React 特殊标签”，React 组件的标签必须以大写字母开头，而 HTML 标签则必须是小写字母：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default function MyApp() &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Welcome to my app&lt;/h1&gt;</span><br><span class="line">        &lt;MyButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="0-2-JSX-使用规范"><a href="#0-2-JSX-使用规范" class="headerlink" title="0.2 JSX 使用规范"></a>0.2 JSX 使用规范</h2><ul><li><p>大多数 React 项目会使用 JSX，主要是它很方便；</p></li><li><p>JSX 比 HTML 更加严格。你必须闭合标签（尤其是单标签），如 <code>&lt;br /&gt;</code>，而不能写 <code>&lt;br&gt;</code>；</p></li><li><p>React 组件不允许返回多个 JSX 标签。如果需要，必须将它们包裹到一个共享的父级中，比如 <code>&lt;div&gt;...&lt;/div&gt;</code> 或使用空的 <code>&lt;&gt;...&lt;/&gt;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function AboutPage() &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">        &lt;h1&gt;About&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;Hello there.&lt;br/&gt;How do you do?&lt;/p&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>为组件自定义样式：和 HTML 一样，在标签里写 <code>className</code>，再使用 CSS / JavaScript 选择更改；</p></li><li><p>使用 JavaScript 变量：<code>&#123;variableName&#125;</code>；</p><blockquote><p>可以在其中写 JavaScript 语法、JSON 对象；</p></blockquote></li></ul><h2 id="0-3-与-JavaScript-组合起来"><a href="#0-3-与-JavaScript-组合起来" class="headerlink" title="0.3 与 JavaScript 组合起来"></a>0.3 与 JavaScript 组合起来</h2><p>举几个例子来进一步了解如何使用：</p><ul><li><p>根据条件选择渲染组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 三目表达式 */</span><br><span class="line">return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;login ? (</span><br><span class="line">            &lt;AdminPanel/&gt;</span><br><span class="line">        ) : (</span><br><span class="line">            &lt;LoginForm/&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>快速渲染列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const listItem = pList.map((item) =&gt; &#123;</span><br><span class="line">    &lt;li key=&#123;item.id&#125;&gt;&#123;item.title&#125;&lt;/li&gt;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return (&lt;ul&gt;&#123;listItem&#125;&lt;/ul&gt;);</span><br></pre></td></tr></table></figure></li><li><p><strong>在 react 中使用事件处理函数</strong>：</p><ul><li><p>方法 1：内联事件处理函数（纯 JavaScript 不建议）；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function MyButton() &#123;</span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    alert(&#x27;You clicked me!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法 2：手动绑定事件处理函数（react 中不方便使用）；</p></li></ul></li><li><p>记忆组件：在 React 中，一般<strong>存储组件状态信息</strong>的方法是引入 React 内置的 Hook（后面介绍），这里以 <code>useState</code> 为例；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function MyButton() &#123;</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line">    /* 得到有记忆性的 count 数据 和 改变该数据的 setCount 函数 */</span><br><span class="line">    function handleClick() &#123;</span><br><span class="line">        setCount(count + 1);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return (</span><br><span class="line">        &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">              Clicked &#123;count&#125; times</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function MyApp() &#123;</span><br><span class="line">    // 在每个组件内部定义的 `count` 只对当前组件有效；</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;MyButton/&gt;</span><br><span class="line">            &lt;MyButton/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Hook</code> 在 react 内置库中是 <strong>以 <code>use</code> 开头的函数</strong>；它比普通函数更为严格，<strong>只能在组件（或其他 Hook）的 顶层</strong> 调用 Hook；</p><p>⚠⚠<strong>特别地，如果你想要组件间共享某个 hook 的值，可以将 hook 定义在组件共同的环境中。</strong>⚠⚠</p></li><li><p>React 为组件自定义属性（具体表现为 HTML 上传入的属性）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 组件传入的参数使用 &#123;&#125; 括起 */</span><br><span class="line">function MyButton(&#123; count, onClick &#125;) &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;</span><br><span class="line">            Clicked &#123;count&#125; times</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Chapter-1-React-描述-UI"><a href="#Chapter-1-React-描述-UI" class="headerlink" title="Chapter 1. React 描述 UI"></a>Chapter 1. React 描述 UI</h1><h2 id="1-1-React-组件"><a href="#1-1-React-组件" class="headerlink" title="1.1 React 组件"></a>1.1 React 组件</h2><ul><li><p>React 应用程序是由 <strong>组件</strong> 组成的。</p><blockquote><p>一个组件是 UI 的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。</p></blockquote></li><li><p>React 组件是<strong>返回标签的 JavaScript 函数</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function MyButton() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;button&gt;I&#x27;m a button&lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>React 组件的使用方法就是直接使用 “React 特殊标签”，React 组件的标签必须以大写字母开头，而 HTML 标签则必须是小写字母：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default function MyApp() &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Welcome to my app&lt;/h1&gt;</span><br><span class="line">        &lt;MyButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>export default</code> 指定了文件中的主要组件。而这种 “React 特殊标签” 被称为 <code>JSX</code>；</p><blockquote><p>JavaScript 中，<code>export</code> 关键字用于从模块中导出实时绑定的函数、对象或原始值，以便其他程序可以通过 <code>import</code> 语句使用它们。</p><p>导出有两种方式：<strong>命名导出（一个模块中可以有任意个）、默认导出（每个模块仅一个）</strong>；</p><p>命名导出可以导出 var, let, const, function, class；不过另一个模块导入时 <strong>必须同名，或者使用重命名命名导出</strong>；</p><p>默认导出在 <code>export</code> 后加 <code>default</code> 关键字，这样 <code>import XX from &quot;&lt;this script&gt;&quot;</code> 中的 <code>XX</code> 可以随意取名；</p></blockquote></li></ul><p>注意要点：</p><ul><li><p>不应该在组件中<u><strong>定义</strong></u>组件（但是可以嵌套使用）：性能降低、引发 Bug；</p></li><li><p>合理地将组件拆分为不同文件，利用 “默认导出”、“命名导出” 等方法进行组件的导入导出，提高代码的可读性和可维护性；</p></li></ul><h2 id="1-2-JSX-的逻辑-和-规则"><a href="#1-2-JSX-的逻辑-和-规则" class="headerlink" title="1.2 JSX 的逻辑 和 规则"></a>1.2 JSX 的逻辑 和 规则</h2><p>为什么要有 JSX ？有些人说它把 HTML 和 JavaScript 混在了一起。我们在之前 Chapter 0 中看到，就事件处理器而言，原本 JavaScript 因为和 HTML 分离而不建议使用内联事件处理器，到了 JSX 中就建议使用了，这就是组件定义的位置的变化。</p><p>因为随着 Web 的交互性越来越强，逻辑越来越决定页面中的内容。JavaScript 开始负责 HTML 的内容，这也是为什么 <strong>在 React 中，渲染逻辑和标签共同存在于同一个地方——组件。</strong></p><blockquote><p>要注意的是，JSX 和 React 相互独立，前者是语法扩展，后者是 JavaScript 的库。</p></blockquote><p>JSX 用在 JavaScript 中，比 HTML 语言更为严格，具体有下面的要求：</p><ol><li><p><strong>只能返回一个根元素</strong>。如果想要在一个组件中包含多个元素，<strong>需要用一个父标签把它们包裹起来</strong>；</p></li><li><p>标签必须闭合，单标签必须尾缀 <code>/</code> 以示结束；</p></li><li><p>标签属性必须以驼峰命名法命名（HTML 原生属性中含有 <code>a-b</code> 的在 JSX 以 <code>aB</code> 代替）；</p><ul><li><p><strong>JSX 中，考虑到 JavaScript 有关键字 <code>class</code>，因此 JSX 中的 <code>class</code> 属性名使用 <code>className</code> 代替</strong>；</p></li><li><p>JSX 中，如果传入内联样式 <code>style</code> 属性，那么其中的键值也应该使用驼峰命名法，因为它仍然是 JSX；</p><blockquote><p>例如在 HTML 中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;test-type&quot;</span>, <span class="attr">style</span>=<span class="string">&quot;&#123;background-color: black&#125;;&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 JSX 中应该写成：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul className=<span class="string">&quot;test-type&quot;</span>, style=&#123;&#123;<span class="attr">backgroundColor</span>: <span class="string">&#x27;black&#x27;</span>&#125;&#125;&gt;&lt;/ul&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul></li></ol><h2 id="1-3-JSX-中使用-JavaScript"><a href="#1-3-JSX-中使用-JavaScript" class="headerlink" title="1.3 JSX 中使用 JavaScript"></a>1.3 JSX 中使用 JavaScript</h2><p><strong>一言以蔽之：JSX 的 <code>&#123;&#125;</code> 中可以运行任何 JavaScript 合法表达式</strong>。</p><p>那么在 JSX 中只能什么时候用呢？</p><ul><li><p>用作 JSX 标签内的<strong>文本</strong>：<code>&lt;h1&gt;&#123;name&#125;&#39;s To Do List&lt;/h1&gt;</code> 是有效的；</p><blockquote><p>但是 <code>&lt;&#123;tag&#125;&gt;Gregorio Y. Zara&#39;s To Do List&lt;/&#123;tag&#125;&gt;</code> 无效；</p></blockquote></li><li><p>用作紧跟在 <code>=</code> 符号后的 <strong>属性</strong>：<code>src=&#123;avatar&#125;</code> 会读取 <code>avatar</code> 变量；</p><blockquote><p>但是 <code>src=&quot;&#123;avatar&#125;&quot;</code> 只会传一个字符串 <code>&#123;avatar&#125;</code>；</p></blockquote></li></ul><h2 id="1-4-React-自定义组件传入属性"><a href="#1-4-React-自定义组件传入属性" class="headerlink" title="1.4 React 自定义组件传入属性"></a>1.4 React 自定义组件传入属性</h2><p>React 通过允许自定义组件传入的属性，实现了 “父组件向子组件传递数据” 的需求。</p><p>你可能会想，既然 React 组件就是一个返回标签的 JavaScript 函数嘛，那不直接给函数加几个参数就行？</p><p>可惜事与愿违，你还要在参数外面包一层 <code>&#123;&#125;</code>。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Avatar(&#123; person, size &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img</span><br><span class="line">      className=&quot;avatar&quot;</span><br><span class="line">      src=&#123;getImageUrl(person)&#125;</span><br><span class="line">      alt=&#123;person.name&#125;</span><br><span class="line">      width=&#123;size&#125;</span><br><span class="line">      height=&#123;size&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是为什么？因为在 HTML 中，这些都是定义在元素内的属性。在经过 React 库的包装之后，相当于 “对象解包” 的过程（类比 Python 的 <code>arg</code> 形参要加 <code>*</code> 的原因）。</p><p>你也可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Avatar(prop) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img</span><br><span class="line">      className=&quot;avatar&quot;</span><br><span class="line">      src=&#123;getImageUrl(prop.person)&#125;</span><br><span class="line">      alt=&#123;prop.person.name&#125;</span><br><span class="line">      width=&#123;prop.size&#125;</span><br><span class="line">      height=&#123;prop.size&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个语法很自由，允许指定默认值：</p><p><code>function Avatar(&#123; person, size = 100&#125;) &#123; ... &#125;</code></p></blockquote><p>⚠⚠<strong>有种特殊情况，当组件的形参是 <code>children</code> 时，就是该组件内部的子组件</strong>。⚠⚠</p><p>这说明了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Widget1&gt;</span><br><span class="line">    &lt;Widget2/&gt;</span><br><span class="line">&lt;/Widget1&gt;</span><br></pre></td></tr></table></figure><p><code>Widget1.children</code> 就是 <code>Widget2</code>；</p><hr><p>还有一个点需要注意：<strong>不能在组件内更改传入的 <code>prop</code> 属性！！</strong> 为什么？</p><p>我们知道，通过传入 <code>prop</code> 可以给子组件以数据。但是，<code>prop</code> 永远是不可变数据类型，下一次渲染时如果父组件传递的数据改变，那么传入的 <code>prop</code> 将是个新的对象，旧的对象将在合适时机被 JavaScript 引擎回收。</p><h2 id="1-5-条件渲染"><a href="#1-5-条件渲染" class="headerlink" title="1.5 条件渲染"></a>1.5 条件渲染</h2><p>很简单，在组件定义函数中加入条件判断，根据条件返回对应的元素即可。</p><p>同时，我们可以充分利用 JavaScript 的<strong>三目运算符、逻辑运算符</strong>的特点来简化代码。</p><p>有一点需要注意，<strong>允许返回 <code>null / false</code>，这相当于告诉渲染器此处什么都不要渲染</strong>。</p><h2 id="1-6-从数据渲染列表"><a href="#1-6-从数据渲染列表" class="headerlink" title="1.6 从数据渲染列表"></a>1.6 从数据渲染列表</h2><p>注意几件事情：</p><ul><li><p>生成列表时，应该为每个项准备全局唯一的 Key，因为这些 key 会告诉 React，每个组件对应着数组里的哪一项，所以 React 可以把它们匹配起来。这在数组项进行移动（例如排序）、插入或删除等操作时非常重要。一个合适的 <code>key</code> 可以帮助 React 推断发生了什么，从而得以正确地更新 DOM 树。</p></li><li><p>用作 key 的值应该在数据中提前就准备好，<strong>并且和数据绑定不作变化</strong>，而不是在运行时才随手生成；</p></li></ul><p><strong>这里的 “列表” 是广义上的列表，只要你利用了 <code>map</code>、手动构建数组等方法生成了一个重复的表状结构</strong>。</p><h2 id="1-7-React-组件渲染函数的幂等性"><a href="#1-7-React-组件渲染函数的幂等性" class="headerlink" title="1.7 React 组件渲染函数的幂等性"></a>1.7 React 组件渲染函数的幂等性</h2><p>按照 React 规范，定义组件的渲染函数（<strong>不是事件处理函数！</strong>）对于相同的输入（即属性），表现应该始终相同。即 React 组件需要有对外的幂等性。</p><p>这意味着每个 React 组件渲染函数只应该完成自己 JSX 的计算，并且不应该更改在组件外的变量 / 对象，尤其是数组（例如定义在组件外的变量、传入组件的 <code>props</code>、<code>state</code>、<code>context</code> 等等）；</p><p>这一点与我们在 JavaScript 中遇到的情况就很不一样了。比如：</p><p>假设页面上有一个组件 <code>&lt;h1&gt;</code>，希望它在午夜 0 时到清晨 6 时的时间内将 <code>class</code> 属性设置为 <code>night</code>，其余时间设置为 <code>day</code>；那么 JavaScript 实现的思路就很简单：</p><ul><li>定义处理函数，通过 <code>querySelector</code> 获取元素 DOM 对象；</li><li><p>计算时间，在对应时间内按要求设置 <code>class</code> 属性内容；</p></li><li><p>最后使用 <code>setInterval</code> 设置渲染；</p></li></ul><p>但是在 React 中，如果使用 <code>document</code> 更改了外部元素，这就是违反规范的行为。正确的做法是 <strong>计算然后利用结果返回指定组件</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function Cock(&#123; time &#125;) &#123; /* 外部传入时间 */</span><br><span class="line">    var hour = time.getHours();</span><br><span class="line">    var cln = (hour &gt;= 0 &amp;&amp; hour &lt;= 6 ? &#x27;night&#x27; : &#x27;day&#x27;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;h1 className=&#123;cln&#125;&gt;</span><br><span class="line">            &#123;time.toLocaleString()&#125;</span><br><span class="line">        &lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter-2-React-交互与事件"><a href="#Chapter-2-React-交互与事件" class="headerlink" title="Chapter 2. React 交互与事件"></a>Chapter 2. React 交互与事件</h1><h2 id="2-1-React-中的事件处理函数"><a href="#2-1-React-中的事件处理函数" class="headerlink" title="2.1 React 中的事件处理函数"></a>2.1 React 中的事件处理函数</h2><p>在原生 JavaScript 中，我们使用 <strong>事件处理函数</strong> 来管理用户与界面元素的事件。通常的做法是，先找到需要处理的元素，使用 <code>addEventListener</code> 添加事先定义的事件处理器，这样就能起到监听事件并在适当时机调用回调函数的作用。</p><p>而在 React 中，根据规范应该使用闭包定义 + 内联事件处理器的方法。</p><p>例如为一个按钮设置点击事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default function MyButton() &#123;</span><br><span class="line">    function handleClick() &#123;</span><br><span class="line">        alert(&quot;Clicked!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (</span><br><span class="line">        &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，在原生 JavaScript 中，我们了解到了 “事件传播”，在 React 中，事件传播完全与原生 JavaScript 相同，<strong>包括阻止事件传播 <code>event.stopPropagation()</code>、阻止默认事件处理函数 <code>event.preventDefault()</code></strong> 都与 JavaScript 一致。</p><p>我们一般想要阻止事件向父组件传递，就需要修改事件处理函数，“先阻止事件传播，再调用目标事件处理函数”。</p><p>还有重要的一点，<strong>事件处理函数可以不是幂等的</strong>，因为组件可能需要有个应对用户操作的状态机，因此它可以更改一些其他变量。</p><p>⚠⚠<strong>注意：如果要用 <code>event</code>，使用前一定要记住给函数声明一个参数！</strong>⚠⚠</p><h2 id="2-2-React-中的状态机：useState"><a href="#2-2-React-中的状态机：useState" class="headerlink" title="2.2 React 中的状态机：useState"></a>2.2 React 中的状态机：<code>useState</code></h2><p>通常情况下，如果我们只是单独使用原生的事件处理函数，那么可能并不能满足我们的需求。即 “事件处理函数 和 渲染函数 到目前为止都是幂等的”。我们想要 Web 程序跟随用户的操作进行一系列的变化。</p><p>有人也许会说，那么在事件处理函数中修改外部的变量，让外部变量保存一些状态不就行了？就像原生 JavaScript 一样。</p><p>很遗憾，这样不行，这主要是因为 React 的渲染机制造成的。原生 JavaScript 的页面渲染大部分都交给 HTML，自己则按照事件和对象驱动地修改一部分内容，并立即渲染。但是在 React 中，HTML 和 JavaScript 的工作全部交由 JSX，这会引发几个问题：</p><ul><li>组件函数内的局部变量<strong>无法在多次渲染中持久保存。</strong> 当 React 再次渲染这个组件时，它会从头开始渲染，不会考虑之前对局部变量的任何更改；</li><li><strong>更改局部变量不会触发渲染。</strong> React 没有意识到它需要使用新数据再次渲染组件；</li></ul><blockquote><p>提醒：你不应该将变量定义到组件函数外面。因为它们不会被导出。</p></blockquote><p>所以，真正想要实现最初的功能，必须完成两件事：</p><ol><li>把操作中产生的状态数据保存起来，不被渲染过程影响；</li><li>在修改这些状态数据后，触发重新渲染的机制；</li></ol><p>在 React 框架内，就有这样定义好的对象 <code>useState</code>，它是一种 Hook，提供了：</p><ol><li>state 变量保存状态数据；</li><li>state setter 函数更新 state 变量的同时<strong>触发 React 再次渲染组件</strong>；</li></ol><blockquote><p>这里介绍一下 React 的 Hook 机制。在 React 中，任何以 <code>use</code> 开头的函数都被称为 Hook。</p><p>Hook <u><strong>是一种特殊的函数，只在 React 渲染时有效</strong></u>。</p></blockquote><p>它的使用方法超级简单，就是<u><strong>在组件渲染函数最开头</strong></u>调用一次 <code>useState(&lt;initVal&gt;)</code>，返回一个包含 <code>state</code> 变量（以 <code>initVal</code> 为初值）、<code>state setter</code> 函数的数组；</p><p>使用多少状态变量，就调用多少次 <code>useState()</code>。</p><p><u><strong>因此，React 中几乎一切需要更新、记忆状态的的过程，都可以交由 <code>useState</code> 完成</strong></u>。</p><p>⚠⚠<strong>最最重要的是，如果 <code>useState</code> 在某个组件内被定义，那么这个属性对于该组件其他所有实例、其他所有组件（包括父组件、子组件）都是<u>互不影响、相互独立</u>的，这为一些复杂的状态设计提供了可能</strong>。⚠⚠</p><h2 id="2-3-React-的渲染机制"><a href="#2-3-React-的渲染机制" class="headerlink" title="2.3 React 的渲染机制"></a>2.3 React 的渲染机制</h2><h3 id="2-3-1-渲染流程"><a href="#2-3-1-渲染流程" class="headerlink" title="2.3.1 渲染流程"></a>2.3.1 渲染流程</h3><p>到现在为止，我们有必要接触一些关于 React 渲染的更加详细的知识。</p><p>渲染的步骤很简单：</p><ol><li>用户或者 Hook 调用一些函数 <strong>触发</strong> 一次渲染过程；</li><li>React 库渲染组件；</li><li>React 库将更改提交给 DOM；</li></ol><p>我们作为用户只知道有 2 种情况会触发渲染，一是在 React 应用启动时。如果你使用 <code>create-react-app</code> 来创建项目的话，你能在 <code>App.js</code> 中看到类似这样的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createRoot &#125; from &#x27;react-dom/client&#x27;;</span><br><span class="line"></span><br><span class="line">const root = createRoot(document.getElementById(&#x27;root&#x27;));</span><br><span class="line">root.render(&lt;App /&gt;);</span><br></pre></td></tr></table></figure><blockquote><p>第一句 <code>createRoot</code> 相当于使用原生 JavaScript 在页面上查找并创建一个根结点对象；</p><p>第二句就使用 <code>render()</code> 将指定组件在根结点上渲染。</p></blockquote><p>而另一种情况就是使用了 Hook 的 setter 函数更新了组件状态，这个做法在 React 库内部会<strong>在恰当的时机</strong>触发一次重新渲染的流程。</p><hr><p><strong>进行一次渲染所做的工作可能有所不同</strong>。</p><p>因为对于初次渲染而言，这个过程是递归的，从调用渲染根组件，在渲染函数（也就是我们定义的组件函数）内返回了子组件，那么接下来继续渲染子组件，直到没有更多的组件需要渲染为止。渲染每个组件的每个元素标签时，React 都会为它们创建一个 DOM 结点。</p><p>初次渲染完成后，React 会将创建好的 DOM 结点利用 DOM API <code>appendChild()</code> 将结点放在 DOM 树上，交给浏览器做 “浏览器渲染”，为了避免混淆，将 “浏览器渲染” 称为 <strong>“绘制”</strong>。</p><p>而在重渲染中，React 会判断哪些属性从上次渲染以来没有更改，对没有更改的部分不会进行任何操作（增量渲染）。并且 React <u>不会为</u>已经存在的、修改了属性的的结点重新创建 DOM 结点。</p><p>重渲染完成后，React 仅将改动的结点进行设置，<strong>不会影响没有修改的结点</strong>。最终还是将 DOM 交由浏览器绘制。</p><p><strong>这也是为什么之前提到 “渲染函数必须是幂等的，唯一能使渲染函数改变输出的，只有 外部 或 事件处理器 更改了渲染函数的输入参数”</strong>，因为如果不这么做，渲染的行为将无法预测；</p><h3 id="2-3-2-useState-与渲染的关系"><a href="#2-3-2-useState-与渲染的关系" class="headerlink" title="2.3.2 useState 与渲染的关系"></a>2.3.2 <code>useState</code> 与渲染的关系</h3><p>了解了上一节的知识，你可能已经认为对 React 渲染的机制掌握透彻了。但是请看下面的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Counter() &#123;</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;number&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">      &#125;&#125;&gt;+3&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能认为每次点击按钮，数字会 + 3，对吗？很遗憾，其实数字在每次点击后始终 + 1。这个行为与 <code>useState</code> 触发重渲染的方式有关。</p><p><strong>我们在前一节只知道 <code>useState</code> 这类 Hook 会内部触发重渲染，但是这是怎么触发，我们也要知道，否则就会出现上面的错误</strong>。</p><p>像 <code>useState</code> 这类 Hook 一般出现在各种事件处理器中，它们执行的机制 <strong>不是立即更新，而是标记更新</strong>。准确地说，它们本身不会调用重新渲染的函数，更像是 Cache 的 Set dirty，提醒 React 在结束事件处理函数之后进行为这个组件进行重渲染。</p><p><u><strong>也就是说，setter 并不会直接更改 state（本次保持不变），而是告诉 React 下次渲染时将 state 改成什么</strong></u>。</p><blockquote><p>为什么 React 要这么设计？引用官方文档的一句话：</p><p>这让你可以更新多个 state 变量——甚至来自多个组件的 state 变量——而不会触发太多的重渲染。但这也意味着只有在你的事件处理函数及其中任何代码执行完成 <strong>之后</strong>，UI 才会更新。这种特性也就是 <strong>批处理</strong>，它会使你的 React 应用运行得更快。它还会帮你避免处理只更新了一部分 state 变量的令人困惑的“半成品”渲染。</p><p>就像餐厅里帮你点菜的服务员。服务员不会在你说第一道菜的时候就跑到厨房。相反，他们会让你把菜点完，让你修改菜品，甚至会帮桌上的其他人点菜。</p></blockquote><p>这样就能解释上面的行为：<code>setNumber(number + 1)</code> 只是<strong>重复地</strong>告诉 React 下次渲染时，该组件的 <code>number</code> 状态为 <strong>当前的 <code>number</code> + 1</strong>，等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 设 0 为 number 本次的值</span><br><span class="line">setNumber(0 + 1);</span><br><span class="line">setNumber(0 + 1);</span><br><span class="line">setNumber(0 + 1);</span><br></pre></td></tr></table></figure><p><u><strong>更让人惊奇的是，访问 <code>number</code> 得到的绝不是它的引用，而总是它的值</strong></u>！在 JavaScript 这个遍地是引用的语言中，这就相当于是相当少见的 “<strong>值捕获</strong>”（类比 C++11 的匿名函数表达式中有值、引用两种方式捕获变量）！</p><p>看下面的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Counter() &#123;</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;number&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setNumber(number + 5);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          alert(number);</span><br><span class="line">        &#125;, 3000);</span><br><span class="line">      &#125;&#125;&gt;+5&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们让 <code>number</code> 等待 5 秒后再传给 <code>alert</code>，你会发现输出的 <code>number</code> 就是在重渲染前的值。</p><p>了解了这些你可能会问，这种做法有好有坏。好处是在<strong>执行渲染函数时无需担心 <code>state</code> 突然被更改</strong>，但坏处是，我们在一次渲染中没法立即读取改变后的 <code>state</code>，这应该怎么办？下一节就是解决方案。</p><h3 id="2-3-3-useState-更新队列"><a href="#2-3-3-useState-更新队列" class="headerlink" title="2.3.3 useState 更新队列"></a>2.3.3 <code>useState</code> 更新队列</h3><p>正如前面介绍的，在下一次渲染开始前，你无法实现多次更改状态的需求，因为 state setter 只是提醒下一次渲染要改变的内容。但 React 也给开发者提供了一种 “批处理队列” 的方法，明确让 React 逐步设置一些状态。</p><p>我们对 2.3.2 中一开始 + 3 的示例进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Counter() &#123;</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;number&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setNumber(n =&gt; n + 1);</span><br><span class="line">        setNumber(n =&gt; n + 1);</span><br><span class="line">        setNumber(n =&gt; n + 1);</span><br><span class="line">      &#125;&#125;&gt;+3&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 React 就能够按照我们想要的动作进行 + 3 的操作了。</p><p>我们注意到这次传入 <code>setNumber</code> 的是一个函数（<code>(n) =&gt; &#123; return n + 1; &#125;</code>），这就相当于<strong>向 React 状态修改队列中加入了一个执行函数</strong>，在 React 下一次渲染时，会依次运行队列中的函数，以指定的方式修改状态。</p><p>到这里，我们可以从另一角度理解 <code>setNumber(number + 1)</code> 的含义了，它其实等效于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setNumber(x =&gt; number + 1)</span><br></pre></td></tr></table></figure><p>由于 <code>x</code> 参数与结果无关，当然最后也就不会累加计算啦。</p><p>以此类推，下面的行为也就不难理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 每次 + 6 */</span><br><span class="line">&lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">  setNumber(number + 5);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">&#125;&#125;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">/* 变为 42 后不会改变 */</span><br><span class="line">&lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">  setNumber(number + 5);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">  setNumber(42);</span><br><span class="line">&#125;&#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-useState-与-JavaScript-原生异步结合"><a href="#2-3-4-useState-与-JavaScript-原生异步结合" class="headerlink" title="2.3.4 useState 与 JavaScript 原生异步结合"></a>2.3.4 <code>useState</code> 与 JavaScript 原生异步结合</h3><p>众所周知，原生 JavaScript 的异步大多依靠 Promise 实现。那么，如果把异步操作与 <code>useState</code> 结合，又有哪些需要注意的地方呢？</p><p>首先明确异步操作对 <code>useState</code> 没啥影响，并不妨碍正常使用，<strong>只是需要明白它的含义</strong>。</p><p>下面是个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function RequestTracker() &#123;</span><br><span class="line">  const [pending, setPending] = useState(0);</span><br><span class="line">  const [completed, setCompleted] = useState(0);</span><br><span class="line"></span><br><span class="line">  async function handleClick() &#123;</span><br><span class="line">    setPending(pending + 1);</span><br><span class="line">    await delay(3000);</span><br><span class="line">    setPending(pending - 1);</span><br><span class="line">    setCompleted(completed + 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h3&gt;</span><br><span class="line">        等待：&#123;pending&#125;</span><br><span class="line">      &lt;/h3&gt;</span><br><span class="line">      &lt;h3&gt;</span><br><span class="line">        完成：&#123;completed&#125;</span><br><span class="line">      &lt;/h3&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        购买</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function delay(ms) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想在事件处理函数中改变状态的同时加上一些异步等待的行为。</p><p>这样做是可行的，你可以认为异步的等待能在状态设置的时机被触发。如上例，在两次 <code>setter</code> 操作之间加一个异步 <code>await</code> 依然是能够等待的。</p><p>结论是，<strong>尽管 <code>setter</code> 只是标记改变，但能完全按照代码执行顺序，依次改变状态。</strong></p><h3 id="2-3-5-useState-存储可变数据类型"><a href="#2-3-5-useState-存储可变数据类型" class="headerlink" title="2.3.5 useState 存储可变数据类型"></a>2.3.5 <code>useState</code> 存储可变数据类型</h3><p>继续考虑 <code>useState</code> 的使用细节。我们之前接触到的、用于表征状态的量都是基本类型。如果状态是 <strong>引用类型（JavaScript 对象）</strong>，情况有没有变化呢？</p><p>答案是有的。因为 JavaScript 原生引用类型都是 <strong>可变数据类型</strong>，和基本类型这种不可变数据类型相比有些尤其需要注意的点。</p><p>最重要的原因是，如果开发者将可变数据类型作为状态存储，那么在修改状态时，<strong>如果仅仅修改其中的属性，那么内存地址是不会发生变化的，<u>换言之，React 无法发现这个变量被修改了</u>，那么也就无法发挥 Hook 重渲染的作用</strong>。</p><p>所以注意的问题很简单：<u><strong>想要将可变类型（如对象）作为状态，那么在修改状态时应该直接传入新的对象，而不是修改原来对象的属性。</strong></u></p><p>这里看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">export default function MovingDot() &#123;</span><br><span class="line">  const [position, setPosition] = useState(&#123;</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div</span><br><span class="line">      onPointerMove=&#123;e =&gt; &#123;</span><br><span class="line">        setPosition(&#123;</span><br><span class="line">          x: e.clientX,</span><br><span class="line">          y: e.clientY</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      style=&#123;&#123;</span><br><span class="line">        position: &#x27;relative&#x27;,</span><br><span class="line">        width: &#x27;100vw&#x27;,</span><br><span class="line">        height: &#x27;100vh&#x27;,</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">      &lt;div style=&#123;&#123;</span><br><span class="line">        position: &#x27;absolute&#x27;,</span><br><span class="line">        backgroundColor: &#x27;red&#x27;,</span><br><span class="line">        borderRadius: &#x27;50%&#x27;,</span><br><span class="line">        transform: `translate($&#123;position.x&#125;px, $&#123;position.y&#125;px)`,</span><br><span class="line">        left: -10,</span><br><span class="line">        top: -10,</span><br><span class="line">        width: 20,</span><br><span class="line">        height: 20,</span><br><span class="line">      &#125;&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面提到 “创建新对象” 的要点外，我们还了解到了 JSX 中另一个可以内联事件处理器的属性：<code>onPointerMove</code>，这个属性对应的事件处理器在用户鼠标移过该元素时就会被触发，<strong>重要的参数有 <code>event.clientX</code>、<code>event.clientY</code></strong>。</p><hr><p>另外，还有几个使用技巧，每次创建新的对象可能有点麻烦，尤其是这个对象属性很多，而我们只想改变一个属性的时候。我们可以使用 <strong>对象展开语法</strong>，类似 Python 的数组解包。比如，<code>person</code> 有 3 个属性，而我们只需要改 <code>firstName</code>，老方法写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setPerson(&#123;</span><br><span class="line">  firstName: e.target.value, // 从 input 中获取新的 first name</span><br><span class="line">  lastName: person.lastName,</span><br><span class="line">  email: person.email</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>新方法就可以写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setPerson(&#123;</span><br><span class="line">    ...person,    // 复制上一个 person 中的所有字段</span><br><span class="line">    firstName: e.target.value // 覆盖 firstName 字段</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>很遗憾的是，这种解包的方式也是引用，所以如果你解包的内容中含有可变数据类型，那么直接这么做也不行。</strong></p><p>例如对于多个的对象，你只能把它们拆开，<u>直到不含有可变数据类型为止</u>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var tmpArt = &#123;</span><br><span class="line">    ...person.artwork,</span><br><span class="line">    city: &#x27;New Delhi&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">setPerson(&#123;</span><br><span class="line">    ...person</span><br><span class="line">    artwork: tmpArt</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>知识补充</strong></p><p>我们对目前遇到的能够内联事件处理器的属性进行总结，主要有下面几个：</p><ul><li><code>onClick</code>；</li><li><code>onFocus</code>；</li><li><code>onPointerMove</code>；</li><li><code>onPointerDown</code>；</li><li><code>onPointerUp</code>；</li><li><code>onChange</code>（特定元素才有，例如 <code>&lt;select&gt;</code>）；</li></ul></blockquote><hr><p>上面的例子所介绍的可变类型大多是 object 对象，如果是数组，那么方法更多一点。因为原生 JavaScript 操作数组的方法本身就多一点。要注意的点是相同的，一定要传入新的对象。</p><p>在使用数组方法时，要注意 <code>map</code>、<code>filter</code>、<code>concat</code>、<code>slice</code> 这类函数都会创建新的数组对象，而 <code>splice</code>、<code>push/pop</code>、<code>shift/unshift</code>、<code>sort</code>、<code>reverse</code> 则只会修改原先的对象。<strong>要善于使用这些函数！能让你处理数组更方便！</strong></p><p><u>也要注意数组元素中含有可变数据类型，那就要单独处理</u>。</p><p>数组还有一点与普通对象有差别的：<strong>它们可能有顺序。在创建新数组时不应该改变元素顺序！！</strong></p><p>我们尝试一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const initialProducts = [&#123;</span><br><span class="line">  id: 0,</span><br><span class="line">  name: &#x27;Baklava&#x27;,</span><br><span class="line">  count: 1,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  name: &#x27;Cheese&#x27;,</span><br><span class="line">  count: 5,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  id: 2,</span><br><span class="line">  name: &#x27;Spaghetti&#x27;,</span><br><span class="line">  count: 2,</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">export default function ShoppingCart() &#123;</span><br><span class="line">  const [</span><br><span class="line">    products,</span><br><span class="line">    setProducts</span><br><span class="line">  ] = useState(initialProducts)</span><br><span class="line"></span><br><span class="line">  function handleIncreaseClick(productId) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;products.map(product =&gt; (</span><br><span class="line">        &lt;li key=&#123;product.id&#125;&gt;</span><br><span class="line">          &#123;product.name&#125;</span><br><span class="line">          &#123;&#x27; &#x27;&#125;</span><br><span class="line">          (&lt;b&gt;&#123;product.count&#125;&lt;/b&gt;)</span><br><span class="line">          &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">            handleIncreaseClick(product.id);</span><br><span class="line">          &#125;&#125;&gt;</span><br><span class="line">            +</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实现 <code>handleIncreaseClick</code>，使得对应 <code>product.id</code> 的按钮一点击，该 product 的 <code>count</code> 数据就 +1 ？</p><p>其实最简单的方法是用 <code>Array.map</code>，而且它恰好能创建一个新数组对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function handleIncreaseClick(productId) &#123;</span><br><span class="line">    var newProdList = products.map((elem)=&gt;&#123;</span><br><span class="line">        if (elem.id === productId) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                ...elem,</span><br><span class="line">                count: elem.count + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else return item;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter-3-React-状态管理"><a href="#Chapter-3-React-状态管理" class="headerlink" title="Chapter 3. React 状态管理"></a>Chapter 3. React 状态管理</h1><p>本章旨在介绍一种更好的组织 React 组件的 state 的思路，让项目写起来更加规范、容易维护。</p><h2 id="3-1-声明式-UI-与-命令式-UI"><a href="#3-1-声明式-UI-与-命令式-UI" class="headerlink" title="3.1 声明式 UI 与 命令式 UI"></a>3.1 声明式 UI 与 命令式 UI</h2><p>命令式 UI 的编程方法通常非常繁琐，你必须去根据要发生的事情写一些明确的命令去操作 UI。</p><p>就像你坐在车里的某个人旁边，然后一步一步地告诉他该去哪。他并不知道你想去哪，只想跟着命令行动。（并且如果你发出了错误的命令，那么你就会到达错误的地方）正因为你必须从加载动画到按钮地“命令”每个元素，所以这种告诉计算机<strong>如何</strong>去更新 UI 的编程方式被称为<strong>命令式 UI 编程</strong>。</p><p>原生 JavaScript + HTML，以及 C++ 的 Qt 框架，采用都是命令式 UI 编程。Qt 为了规避命令式 UI 编程的麻烦，将部分工作转移给 Qt Designer + <code>uic</code>（用户界面编译器）来做。</p><p>JavaScript 的框架 React 则采用了 <strong>声明式 UI 编程</strong>，也就是说，我们不必直接去操作 UI —— 不必直接启用、关闭、显示或隐藏组件。相反，我们只需要 <strong>声明你想要显示的内容，</strong> React 就会<u>通过计算</u>得出该如何去更新 UI。</p><p>就像上了一辆出租车并且告诉司机你想去哪，而不是事无巨细地告诉他该如何走。将你带到目的地是司机的工作，他们甚至可能知道一些你没有想过并且不知道的捷径（即更高效的渲染方式，例如之前的增量渲染技术）。</p><p>在 声明式 UI 编程中，我们不用直接修改 UI 组件，而是采用以下的几个步骤：</p><ol><li><p><strong>定位</strong>你的组件中不同的视图状态（<strong>设计界面状态机</strong>）；</p></li><li><p><strong>确定</strong>是什么触发了这些 state 的改变；</p><p>根据前两个步骤，你应该能够绘制出组件的状态转换图，类似这个，这是个表单的状态转换图：</p><p><img src="/home/xhw/Desktop/web/imgs/state-machine-form.png" height="300px"></p></li><li><p><strong>定义使用</strong>内存中的 state（<code>useState</code>）；</p><p>根据状态图，我们应该设计尽量少的 state，众所周知，程序越复杂越不方便维护；</p></li><li><p><strong>删除</strong>任何不必要的 state 变量；</p><p><strong>这一步是有技巧的，还是以一个表单为例</strong>：</p><ul><li><strong>这个 state 是否会导致矛盾</strong>？例如，<code>isTyping</code> 与 <code>isSubmitting</code> 的状态不能同时为 <code>true</code>。矛盾的产生通常说明了这个 state 没有足够的约束条件；</li><li><strong>相同的信息是否已经在另一个 state 变量中存在</strong>？另一个矛盾：<code>isEmpty</code> 和 <code>isTyping</code> 不能同时为 <code>true</code>。通过使它们成为独立的 state 变量，可能会导致它们不同步并导致 bug；</li><li><strong>你是否可以通过另一个 state 变量的相反值得到相同的信息</strong>？<code>isError</code> 是多余的，因为你可以检查 <code>error !== null</code>。</li></ul></li><li><p><strong>连接</strong>事件处理函数去设置 state；</p></li></ol><h2 id="3-2-State-设计的最佳实践"><a href="#3-2-State-设计的最佳实践" class="headerlink" title="3.2 State 设计的最佳实践"></a>3.2 State 设计的最佳实践</h2><p>前人总结过如下的经验，采集自官方文档 + 笔者自己总结：</p><ul><li><p><strong>合并关联的 state</strong>。如果你总是同时更新两个或更多的 state 变量，请考虑将它们合并为一个单独的 state 变量。</p><blockquote><p>例如位置信息，x 和 y 是建议绑定在一个对象中，因为它们通常同时变化；</p></blockquote></li><li><p><strong>避免互相矛盾 / 冗余的 state</strong>。当 state 结构中存在多个相互矛盾 / “不一致” / 可以互相推理出信息的 state 时，你就可能为此会留下隐患（例如不及时同步、错误地维护）。应尽量避免这种情况；</p></li><li><p><strong>避免深度嵌套的 state</strong>。深度分层的 state 更新起来不是很方便，而且降低代码可读性。如果可能的话，最好以扁平化方式构建 state；</p></li><li><p><u><strong>避免与其他 State 共享引用对象</strong></u>：⚠⚠<strong>这点请一定要注意！！！是笔者自己加的。笔者曾犯过这个错，调试半天都没找出来</strong>。⚠⚠如果你共享了，那么在更新一个 State 的时候，会不经意间影响到另一个 State 的呈现，使程序出现意外的行为。</p><blockquote><p>替代方案是，共享基本类型（不可变数据类型）；</p></blockquote></li></ul><h2 id="3-3-组件间共享-State"><a href="#3-3-组件间共享-State" class="headerlink" title="3.3 组件间共享 State"></a>3.3 组件间共享 State</h2><p>非常简单，就一句话：<strong>把 state 放入父组件，然后用参数传给子组件，即可完成共享</strong>。</p><h2 id="3-4-State-的保留与重置"><a href="#3-4-State-的保留与重置" class="headerlink" title="3.4 State 的保留与重置"></a>3.4 State 的保留与重置</h2><p>为什么要讨论 State 的保留和重置？考虑一个问题。假如你移除了一个组件，之后又添加上去，State 能否保留？如果没法保留，是否有一些手段能保留它的值？</p><h3 id="3-4-1-保留"><a href="#3-4-1-保留" class="headerlink" title="3.4.1 保留"></a>3.4.1 保留</h3><p>首先，React 组件的 State 与组件在渲染树的位置有关。这句话说明了几点：</p><ol><li><p><strong>即便两个组件是同一个对象的引用，只要它们在渲染树上的位置不同，State 就相互独立</strong>。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function App() &#123;</span><br><span class="line">  const counter = &lt;Counter /&gt;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;counter&#125;</span><br><span class="line">      &#123;counter&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const [score, setScore] = useState(0);</span><br><span class="line">  const [hover, setHover] = useState(false);</span><br><span class="line"></span><br><span class="line">  let className = &#x27;counter&#x27;;</span><br><span class="line">  if (hover) &#123;</span><br><span class="line">    className += &#x27; hover&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div</span><br><span class="line">      className=&#123;className&#125;</span><br><span class="line">      onPointerEnter=&#123;() =&gt; setHover(true)&#125;</span><br><span class="line">      onPointerLeave=&#123;() =&gt; setHover(false)&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;h1&gt;&#123;score&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setScore(score + 1)&#125;&gt;</span><br><span class="line">        +1</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个 counter 指向同一个对象，但是它们在 DOM 树上被渲染成两个结点，因此它们的 State 是不会共享的。</p></li><li><p>被移除的组件，state 会被立即删除。所以哪怕在渲染树的相同位置，state 也无法保存；</p><blockquote><p>什么是 “被移除”？</p><p>就是组件在某次返回的 JSX 中，某元素完全消失，该元素对应的组件就被移除了。</p><p>下次即便生成在同一位置，组件也是新渲染的（<strong>不是重渲染</strong>）。</p><p>像这种就不叫删除，叫属性的改变：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;isFancy ? (</span><br><span class="line">    &lt;Counter isFancy=&#123;true&#125; /&gt; </span><br><span class="line">) : (</span><br><span class="line">    &lt;Counter isFancy=&#123;false&#125; /&gt; </span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>选择渲染也不会使其他组件被移除。因为其他的组件的 DOM 树没有变动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;(showHint) ? &lt;p&gt;&lt;i&gt;提示：你最喜欢的城市？&lt;/i&gt;&lt;/p&gt; : null&#125;</span><br><span class="line"> &lt;Form /&gt;</span><br><span class="line"> &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">   setShowHint(!showHint);</span><br><span class="line"> &#125;&#125;&gt;&#123;(showHint) ? &quot;隐藏提示&quot; : &quot;显示提示&quot;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这种就叫删除，因为换成了新的组件，React 会进行首次渲染：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;isPaused ? (</span><br><span class="line">    &lt;p&gt;待会见！&lt;/p&gt; </span><br><span class="line">) : (</span><br><span class="line">    &lt;Counter /&gt; </span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>注意，如果某组件的父元素改变了，由于 DOM 会重新生成，对 React 来说，也是首次绘制，这也算删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;isFancy ? (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;Counter isFancy=&#123;true&#125; /&gt; </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">) : (</span><br><span class="line">&lt;section&gt;</span><br><span class="line">&lt;Counter isFancy=&#123;false&#125; /&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><p>以上两点就告诉我们如何保存 State：<strong>如果你想在重新渲染时保留 state，几次渲染中的树形结构就应该相互“匹配”</strong>，属性的变化则不会影响 state。</p><p>到这里就能解释早在 1.1 中的约定：<strong>组件不可嵌套定义</strong>。因为如果嵌套定义，例如下面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function MyComponent &#123;</span><br><span class="line">    const [counter, setCounter] = useState(0);</span><br><span class="line">    </span><br><span class="line">    function MyTextField() &#123;</span><br><span class="line">        const [text, setText] = useState(&#x27;&#x27;);</span><br><span class="line">        </span><br><span class="line">        return (</span><br><span class="line">            &lt;input</span><br><span class="line">                value=&#123;text&#125;</span><br><span class="line">                onChange=&#123;e=&gt;setText(e.target.value)&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;MyTextField/&gt;</span><br><span class="line">            &lt;button onCLick=&#123;()=&gt;&#123;</span><br><span class="line">                setCounter(counter + 1)</span><br><span class="line">            &#125;&#125;&gt;Clicked &#123;counter&#125; times&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么每次渲染时，<code>MyTextField</code> 函数<strong>本身的内存地址每次都不一样</strong>，那么相当于每次渲染 <code>MyTextField</code> 组件都会被移除，从头开始渲染，这就直接导致 state <strong>丢失</strong>。</p><h3 id="3-4-2-重置"><a href="#3-4-2-重置" class="headerlink" title="3.4.2 重置"></a>3.4.2 重置</h3><p>上面讨论 state 的保留的情况。考虑实际应用时的另一种情况：<br>假设有一个组件收集用户输入。但是你需要实现 “切换用户” 的功能。在不销毁组件的情况下，组件的 state 会被保存。那么我们如何在 DOM 树的同一位置上重置组件的 state？</p><p>有两种思路：<strong>要么把组件渲染在不同位置，要么使用 <code>key</code> 在指定组件身份，确保切换 <code>key</code> 时 React 会移除并重新生成组件</strong>。</p><ol><li><p>不同位置渲染：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;isPlayerA &amp;&amp;</span><br><span class="line">    &lt;Counter person=&quot;Taylor&quot; /&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#123;!isPlayerA &amp;&amp;</span><br><span class="line">    &lt;Counter person=&quot;Sarah&quot; /&gt;</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">    setIsPlayerA(!isPlayerA);</span><br><span class="line">&#125;&#125;&gt;</span><br></pre></td></tr></table></figure><p>如上，注意和 3.4.1 的例子的区别。我们在多个用户的情况可以通过列表组织。</p></li><li><p>使用 <code>key</code> 重置 state：我们不仅在列表中使用 <code>key</code> 来帮助 React 更好地管理 entries，在普通的组件 / 元素中也能使用，React 会根据 <code>key</code> 来区分组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;isPlayerA ? (</span><br><span class="line">  &lt;Counter key=&quot;Taylor&quot; person=&quot;Taylor&quot; /&gt;</span><br><span class="line">) : (</span><br><span class="line">  &lt;Counter key=&quot;Sarah&quot; person=&quot;Sarah&quot; /&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p><strong>值得注意的是，<code>key</code> 不是全局唯一的。它只能指定在同一父组件间的区别</strong>。</p></li></ol><hr><p>到这里，state 的保存和重置机制的利用，我们已经很清楚了。但是如果我们就想<strong>在一个组件被移除后，仍然保留它的 state，直到它下次被创建呢</strong>？</p><p>还有几种思路：</p><ol><li>利用 CSS 隐藏不需要的组件，这样它实际上不会被移除；</li><li>使用不会被移除的父组件来保存信息；</li><li>使用 原生 JavaScript 中定义的 <code>localStorage</code>，即使用 cookie 来保存。这样即使关闭了页面也能恢复。</li></ol><h2 id="3-5-Reducer-统一状态管理"><a href="#3-5-Reducer-统一状态管理" class="headerlink" title="3.5 Reducer 统一状态管理"></a>3.5 Reducer 统一状态管理</h2><p>本节将遇到 <strong>第二个 React Hook</strong>，它的作用非常重要：<strong>统一管理 React 事件处理器</strong>。</p><p>要知道，在 React 中使用闭包 + 内联事件处理器，这样的定义在事件处理器的数量少的时候非常方便书写。但是如果事件处理器的数量过多，那么代码可读性和可维护性将大大降低。这主要是因为 JSX 将页面布局和事件处理逻辑放在一起了。</p><p>而 React 库提供了一个新的 Hook，它允许你<strong>将事件处理器从 UI 声明中抽离出来，使得项目的事件处理系统<u>更容易调试、更可读、更有可维护性</u></strong>。</p><p>它就是 <code>useReducer</code>。Reducer 是处理状态的另一种方式，它相当于将我们的 <strong>事件处理函数 和 状态 打包了起来</strong>。</p><h3 id="3-5-1-useReducer-的基本使用"><a href="#3-5-1-useReducer-的基本使用" class="headerlink" title="3.5.1 useReducer 的基本使用"></a>3.5.1 <code>useReducer</code> 的基本使用</h3><p>使用 reducers 管理状态与直接设置状态略有不同。它不是通过设置状态来告诉 React “要做什么”，而是通过事件处理程序 dispatch 一个 “action” 来指明 “用户刚刚做了什么”，而状态更新逻辑则保存在<strong>其他地方</strong>，实现了状态管理逻辑和 UI 的抽离。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useReduce &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// `yourReducer` 是等会需要定义的总的事件管理的函数（你可以自己命名），所有事件处理函数 dispatch 都会到这里</span><br><span class="line">// `initialState` 是 `state`（你也可以自己命名）的初值</span><br><span class="line">const [state, dispatch] = useReducer(yourReducer, initialState);</span><br></pre></td></tr></table></figure><p>事件处理函数只需要调用 <code>dispatch</code>，传入 <code>action</code> 对象，告诉之后的 <code>yourReducer</code> 发生了什么。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispath(</span><br><span class="line">    // action 对象（普通的 JS Object），可以自己定义，但要保证你在 yourReducer 能知道发生了什么</span><br><span class="line">    &#123;</span><br><span class="line">        /* 描述发生事件的类别 */</span><br><span class="line">        type: &#x27;what_happened&#x27;,</span><br><span class="line">        /* 其他字段描述改变的信息 */</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>另一边的事件管理函数 <code>yourReducer</code> 则处理调用 <code>dispatch</code> 的动作，要求声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function yourReducer(state, action) =&gt; newState</span><br></pre></td></tr></table></figure><p>该函数会被 <code>dispatch</code> 触发（内部触发），React 库自动添加第一个参数 <code>state</code> 即当前组件的当前状态，<code>action</code> 等同于之前传入 <code>dispatch</code> 的对象。</p><p>React 会将组件的 state 设置为状态管理函数 <code>yourReducer</code> 的返回值 <code>newState</code>；</p><p>这样，我们可以把 <code>yourReducer</code> 定义在 UI 组件以外的文件中，提升代码可读性和可维护性。</p><h3 id="3-5-2-Reducer-设计规范"><a href="#3-5-2-Reducer-设计规范" class="headerlink" title="3.5.2 Reducer 设计规范"></a>3.5.2 Reducer 设计规范</h3><ul><li><p>值得注意的是，<strong>Reducer 和 渲染函数一样，都在<u>渲染时运行</u>（包括你 dispatch 的 actions 也会等待到下一次渲染时进行）</strong>，因此在 <strong>异步方面和 <code>useState</code> 不一样 —— reducers 内部不允许使用异步操作、定时器等</strong>；</p><blockquote><p><code>alert</code> 等函数也不能使用。因为严格模式下，React 会重复执行 2 次渲染函数，确保渲染函数具有幂等性。在 reducers 内部写 <code>alert</code> 极有可能会被调用 2 次。</p></blockquote></li><li><p>和 <code>useState</code> 一致的是，允许修改状态，并且应该使用新的可变数据类型，或者不可变数据类型；</p></li><li><p>每个 action 只应该对应一个用户交互动作，方便代码调试；</p></li></ul><blockquote><p>JavaScript JSON 对象操作小技巧：</p><p>当 JSON 中的键恰好是某个变量中的值，那么可以使用 <code>[var]</code> 计算出值，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">messages</span>: &#123;</span><br><span class="line">  ...state.<span class="property">messages</span>,</span><br><span class="line">  [state.<span class="property">selectedId</span>]: action.<span class="property">message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-6-Context-自定义参数传播"><a href="#3-6-Context-自定义参数传播" class="headerlink" title="3.6 Context: 自定义参数传播"></a>3.6 Context: 自定义参数传播</h2><p>在某些场景下，例如为深层的组件传递参数，如果采用 1.4 的普通 <code>props</code> 的参数传递，那么实际操作起来会非常麻烦，并且不易维护。</p><p>我们可以使用新的 Hook <code>useContext</code> 来实现数据在组件树上的传递。</p><h3 id="3-6-1-useContext-基本使用"><a href="#3-6-1-useContext-基本使用" class="headerlink" title="3.6.1 useContext 基本使用"></a>3.6.1 <code>useContext</code> 基本使用</h3><p>使用主要分成 3 步：</p><ol><li><p>使用如下方法创建 context 上下文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createContext &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export const LevelContext = createContext(&lt;defaultValue&gt;);</span><br></pre></td></tr></table></figure></li><li><p>读取 context 值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useContext &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; LevelContext &#125; from &#x27;./XXX.js&#x27;;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">export default function Widget() &#123;</span><br><span class="line">    const level = useContext(LevelContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过现在只能读到默认值，我能否由父组件向子组件传递一定的 context 值？</p></li><li><p>父控件提供 context 值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;LevelContext.Provider value=&#123;level&#125;&gt;</span><br><span class="line">&lt;/LevelContext.Provider&gt;</span><br></pre></td></tr></table></figure><p><strong>这告诉 React：“如果在该组件中的任何子组件请求 <code>LevelContext</code>，给他们这个 <code>level</code>。”组件会使用 UI 树中在它上层最近的那个 <code>&lt;LevelContext.Provider&gt;</code> 传递过来的值。</strong></p></li></ol><h3 id="3-6-2-Context-的使用场景"><a href="#3-6-2-Context-的使用场景" class="headerlink" title="3.6.2 Context 的使用场景"></a>3.6.2 Context 的使用场景</h3><ul><li><strong>主题：</strong> 如果你的应用允许用户更改其外观（例如暗夜模式），你可以在应用顶层放一个 context provider，并在需要调整其外观的组件中使用该 context。</li><li><strong>当前账户：</strong> 许多组件可能需要知道当前登录的用户信息。将它放到 context  中可以方便地在树中的任何位置读取它。某些应用还允许你同时操作多个账户（例如，以不同用户的身份发表评论）。在这些情况下，将 UI  的一部分包裹到具有不同账户数据的 provider 中会很方便。</li><li><strong>路由：</strong> 大多数路由解决方案在其内部使用 context 来保存当前路由。这就是每个链接“知道”它是否处于活动状态的方式。如果你创建自己的路由库，你可能也会这么做。</li><li><strong>状态管理：</strong> 随着你的应用的增长，最终在靠近应用顶部的位置可能会有很多 state。许多遥远的下层组件可能想要修改它们。通常将 reducer 与 context 搭配使用来管理复杂的状态并将其传递给深层的组件来避免过多的麻烦。</li></ul><p>对于最后一条，也是最难的一条，我们将单独描述。</p><p>Context 不仅可以存放不可变数据类型，还能放 <strong>state + dispatch</strong>，这样能够实现组件树下的各个子组件都可以直接读取 states 和 dispatch，无需担心引用问题。</p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript入门笔记-(2)</title>
      <link href="//technical/js-basic-2/"/>
      <url>//technical/js-basic-2/</url>
      
        <content type="html"><![CDATA[<p><i>Written by SJTU-XHW</i></p><p><i>Reference: </i>《Professional JavaScript for Web Developers》 3rd Edition</p><p><i>本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h2 id="Chapter-7-简单使用-DOM"><a href="#Chapter-7-简单使用-DOM" class="headerlink" title="Chapter 7. 简单使用 DOM"></a>Chapter 7. 简单使用 DOM</h2><p>假设你学习了初级数据结构，那么把 HTML 页面想象成一个以元素为结点的一般树。JavaScript DOM 操作就是操作这个文档树，达到改变前端页面的目的。</p><p>在浏览器运行的 JavaScript 引擎中，全局运行环境中会自动设置一个变量 <code>document</code>（DOM 对象），操作它就是在动态操作 HTML 页面。</p><h3 id="7-1-基本操作"><a href="#7-1-基本操作" class="headerlink" title="7.1 基本操作"></a>7.1 基本操作</h3><blockquote><p>假设你学习了 CSS 的基础用法。</p></blockquote><ul><li><p><code>document.querySelector(&lt;selectorStr&gt;)</code>：JavaScript DOM 中的重要方法，document 对象的 按选择器查找 HTML 中的元素（CSS 中有效的所有选择器，除了伪类选择器都行）；</p><blockquote><p>如果有多个符合选择器的对象，那么只会返回一个。想要返回全部，请使用 <code>querySelectorAll() -&gt; NodeList (or Array)</code>；</p><p>注：还有一些老方法 <code>getElementById</code>、<code>getElementByTagName</code> 不建议使用，因为太多太繁了，有这个方法足够了。</p></blockquote></li><li><p><code>&lt;Node&gt;.textContent</code>：很多元素，例如 <code>div</code>、<code>button</code>、<code>p</code>、<code>a</code> 等等，可以通过对 DOM 结点设置这个属性来达到更改文本的目的。前提是这个元素能够显示文本；</p></li><li><p><code>&lt;Node&gt;.href</code>：很多含有 <code>href</code> 属性的元素可以用这种方法更改链接，类似地，<code>src</code> 等属性也可以如此更改；</p></li><li><p><code>&lt;Node&gt;.classList</code>：获取结点的 <code>class</code> 属性列表，相当于 <code>&lt;Node&gt;.className.split(&quot; &quot;)</code> 再转为 <code>DOMTokenList</code>；</p><blockquote><p>对于 <code>DOMTokenList</code>，与 JavaScript 原生数组不一样，它有自己的属性、方法：</p><ul><li><code>DOMTokenList.length</code>（<strong>只读</strong>）；</li><li><code>DOMTokenList.item(idx)</code>；</li><li><code>DOMTokenList.contains(token)</code>；</li><li><code>DOMTokenList.add(token[, token2, ...])</code>；</li><li><code>DOMTokenList.remove(...)</code>；</li><li><code>DOMTokenList.toggle(token)</code>：<strong>修改属性非常方便的选择！！</strong>，若 <code>token</code> 存在其中，则删除并返回 false；若不存在，则添加并返回 true；</li><li><code>DOMTokenList.forEach(&lt;callback&gt;)</code>；</li></ul></blockquote></li><li><p>网页刷新：<code>document.location.reload()</code>；</p></li></ul><h3 id="7-2-创建新结点"><a href="#7-2-创建新结点" class="headerlink" title="7.2 创建新结点"></a>7.2 创建新结点</h3><p>一般分三步走：</p><ol><li>创建结点 DOM 对象：<code>document.createElement(&lt;element-type&gt;)</code>；</li><li>设置结点对象属性：<code>&lt;Node&gt;.attr = ...</code>；</li><li>向指定结点对象追加新的对象：<code>&lt;Node&gt;.appendChild(&lt;Node&gt;)</code>；</li></ol><h3 id="7-3-移动、删除结点"><a href="#7-3-移动、删除结点" class="headerlink" title="7.3 移动、删除结点"></a>7.3 移动、删除结点</h3><p>注意一个问题：<strong>DOM 对象引用与 HTML 元素一一对应</strong>。因此除非你使用 <code>&lt;Node&gt;.cloneNode()</code>，否则，之前新建的结点对象如果再一次 <code>appendChild</code>，那么它会移动到父结点的底部，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sect = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;section&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> para = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">para.<span class="property">textContent</span> = <span class="string">&quot;We hope you enjoyed the ride.&quot;</span>;</span><br><span class="line">sect.<span class="title function_">appendChild</span>(para);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间添加了一些结点</span></span><br><span class="line"></span><br><span class="line">sect.<span class="title function_">appendChild</span>(para); <span class="comment">// para 会被移动到 sect 的底部，而非出现副本</span></span><br></pre></td></tr></table></figure><p>删除结点就使用：<code>&lt;parentNode&gt;.removeChild(&lt;Node&gt;)</code>，如果不知道父元素，那么可以借助 <code>parentNode</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Node</span>&gt;.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(&lt;<span class="title class_">Node</span>&gt;);</span><br></pre></td></tr></table></figure><h3 id="7-4-改变结点样式"><a href="#7-4-改变结点样式" class="headerlink" title="7.4 改变结点样式"></a>7.4 改变结点样式</h3><p>JavaScript 可以通过修改 DOM 对象的属性来修改其 CSS 样式。</p><p>有两种方法可以实现：</p><ul><li><p><code>&lt;Node&gt;.style</code> 属性本身是个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">para.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&quot;white&quot;</span>;</span><br><span class="line">para.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;black&quot;</span>;</span><br><span class="line">para.<span class="property">style</span>.<span class="property">padding</span> = <span class="string">&quot;10px&quot;</span>;</span><br><span class="line">para.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&quot;250px&quot;</span>;</span><br><span class="line">para.<span class="property">style</span>.<span class="property">textAlign</span> = <span class="string">&quot;center&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;Node&gt;.setAttribute(&lt;attrName&gt;, &lt;attrValue&gt;)</code>；</p><blockquote><p>对应有 <code>getAttribute</code>；它们不止能改 CSS 样式（<code>style</code> 属性），其他属性也能改；</p></blockquote></li></ul><p><strong>个人建议使用后一种，因为不需要额外记忆内置变量名</strong>。</p><h2 id="Chapter-8-事件"><a href="#Chapter-8-事件" class="headerlink" title="Chapter 8. 事件"></a>Chapter 8. 事件</h2><p>事件是 JavaScript 能够响应用户行为的重要手段之一。</p><p>事件可能有以下几种：</p><ul><li>用户选择、点击或将光标悬停在某一元素上。</li><li>用户在键盘中按下某个按键。</li><li>用户调整浏览器窗口的大小或者关闭浏览器窗口。</li><li>网页结束加载。</li><li>表单提交。</li><li>视频播放、暂停或结束。</li><li>发生错误。</li></ul><p>为了对一个事件做出反应，就要在 JavaScript 中附加一个<strong>事件处理器</strong>。它通常是自己创建的、<strong>已注册的</strong>一个函数。具体使用方法举个例子：</p><h3 id="8-1-注册、移除事件处理器"><a href="#8-1-注册、移除事件处理器" class="headerlink" title="8.1 注册、移除事件处理器"></a>8.1 注册、移除事件处理器</h3><p>假设 HTML 上有个按钮：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;sbtn groupt&quot;</span>&gt;</span></span><br><span class="line">    Click Me</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button.sBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">random</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &amp; (num + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* JavaScript 中注册事件处理器的方法。下次如果该对象有动作，则立即调用这个函数。 */</span></span><br><span class="line"><span class="comment">/* 事件类型：click，回调函数：匿名 */</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> randCtl = <span class="string">`rgb(<span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>)`</span>;</span><br><span class="line">    <span class="comment">/* document 对象 body 元素 -&gt; style 属性 -&gt; backgroundColor */</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = randCtl;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>知识补充</strong>: JavaScript 模板字符串（反引号引起的字符串）</p><ul><li><p>相当于 shell 中的单引号字符串、python 的 <code>f</code> 格式化字符串。</p></li><li><p>可以向其中嵌入变量（<code>$&#123;js_variable&#125;</code>）而无需加法运算符；</p></li></ul></blockquote><p>于是我们认识了注册事件处理器的函数：<code>&lt;DOMObj&gt;.addEventListener(&lt;event-type&gt;, &lt;func&gt;)</code>；</p><p>除了上面提到的 <code>click</code> 事件，<code>button</code> 元素常用的还有：</p><ul><li><code>&quot;mouseover&quot; / &quot;mouseout&quot;</code>（即 hover in / hover out）；</li><li><code>&quot;focus&quot; / &quot;blur&quot;</code>（即按钮聚焦、失焦，常见用 tab 的情况）；</li><li><code>&quot;dblclick&quot;</code>（即双击）；</li><li><code>&quot;submit&quot;</code>（对表单中的按钮而言，触发了 <code>&quot;click&quot;</code> 就接连触发了 <code>&quot;submit&quot;</code>）；</li></ul><p>其实 <code>&quot;click&quot;</code> 事件几乎对其他所有元素都可用；</p><p>还有一些事件只有特定元素有，例如 <code>&quot;play&quot;</code> 事件只有 <code>&lt;video&gt;</code>、<code>&lt;audio&gt;</code> 元素有；</p><hr><p>相对地，我们可以移除指定的事件处理器：<code>removeEventListener(&lt;event-type&gt;, &lt;func&gt;)</code>；</p><p>这就像 Qt 的信号-槽机制中的 <code>connect</code> 和 <code>disconnect</code>，就连 “一对多”、“多对一”、“一对一” 等原则也与 Qt 一致，不再赘述。</p><p>⚠⚠ <strong>友情提醒</strong> ⚠⚠</p><p>不要使用内联事件处理器（写在 HTML 中的事件处理器），它们已经被 deprecated 了，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;It was deprecated!&#x27;);&quot;</span>&gt;</span></span><br><span class="line">  click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-2-事件对象"><a href="#8-2-事件对象" class="headerlink" title="8.2 事件对象"></a>8.2 事件对象</h3><p>JavaScript 解释器在回调某个事件处理器时，会自动向参数列表中传入 <code>event / evt / e</code>（三个都行，开发时为了可读性请选择一个），</p><p>事件对象有个常用属性：</p><ul><li><code>event.target</code>：相当于 Qt 中信号-槽机制的 <code>event.sender</code>，返回发送方对象；</li><li><code>event.key</code>：相当于 Qt <code>QKeyEvent::key()</code>，就是触发键击信号的键；</li></ul><blockquote><p>对常见的 DOM 元素，例如 <code>div</code>、<code>p</code>，可以设置 <code>&lt;DOMObj&gt;.textContent</code> 改变文本值；</p></blockquote><p>那么我们使用事件对象有什么用？</p><p>和 Qt 一样，答案是自定义默认的事件处理。有些默认的事件处理器（例如表单按钮的 <code>&quot;submit&quot;</code> 动作），开发者不好取消，我们可以通过事件对象的方法 <code>event.preventDefault()</code> 来阻止默认动作、进行自定义：</p><p>例如对这个表单，我们想让用户必须填写 <code>First name</code> 和 <code>Last name</code>，缺一不可，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;fname&quot;</span>&gt;</span>First name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;fname&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;lname&quot;</span>&gt;</span>Last name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;lname&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们就能这样阻止表单的默认提交动作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;form&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fname = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> lname = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;lname&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> para = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"></span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断字符串为空也可以用 String.length（但要确保不是 null） */</span></span><br><span class="line">  <span class="keyword">if</span> (fname.<span class="property">value</span> === <span class="string">&quot;&quot;</span> || lname.<span class="property">value</span> === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    para.<span class="property">textContent</span> = <span class="string">&quot;You need to fill in both names!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="8-3-事件传递"><a href="#8-3-事件传递" class="headerlink" title="8.3 事件传递"></a>8.3 事件传递</h3><p>我们类比 Qt 的信号-槽机制，在 Qt 中，一个事件 / 信号被捕获后，进入事件 / 信号处理函数，我们以 <code>bool eventFilter(QEvent* event, QObject* obj)</code> 为例，如果该函数返回 <code>true</code>，表示事件处理结束，事件不会再向父控件传递，反之则会。</p><p>在 JavaScript 中，<strong>事件传递行为和 Qt 相近</strong>，只是<strong>收到并处理后，开发者无法自定义事件的传递行为，一定会继续向父元素传递</strong>。</p><p>在一些情况下，由于父子元素需要控制事件比较复杂，如果不控制事件的传递，很有可能引发一些问题，例如我们想做个页面包含一个视频，最初它为隐藏状态；还有一个标记为“显示视频”的按钮。我们希望有如下交互：</p><ul><li>当用户单击“显示视频”按钮时，显示包含视频的盒子，但不要开始播放视频。</li><li>当用户在视频上单击时，开始播放视频。</li><li>当用户单击盒子内视频以外的任何区域时，隐藏盒子。</li></ul><p>如果这么写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">    显示视频</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span>    <span class="comment">&lt;!-- 使用 CSS 的 class 属性标记隐藏内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">&quot;XXX.webm&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            您的浏览器不支持 webm 格式视频！</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;video&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DOM 对象的另一个重要属性 classList */</span></span><br><span class="line"><span class="comment">/* 可以得到对应的 HTML 元素的 class 属性列表（空格间隔），返回对象是 Array */</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> box.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;hidden&quot;</span>));</span><br><span class="line"><span class="comment">/* video 元素的 BOM 方法： play() */</span></span><br><span class="line">video.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> video.<span class="title function_">play</span>());</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> box.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;hidden&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p><strong>知识补充 1</strong>: JavaScript DOM 对象 <code>classList</code> 属性；</p><p><strong>知识补充 2</strong>: JavaScript <code>video / audio</code> 元素对应的 BOM 方法 <code>play()</code>；</p></blockquote><p>我们点击显示视频是没问题的，但是有个问题是，当我们点击视频开始播放的时候，容器会被隐藏！这是因为 <code>video</code> 空间在 <code>div</code> 内部，点击操作会传递到 <code>div</code> 中，相当于同时触发了两个事件处理器。</p><p>所以 JavaScript 中的解决方案是 <code>event.stopPropagation()</code>，在事件处理器中，可以停止事件自动地向父元素传播。</p><p>上面的 JavaScript 改成这样就能实现目的了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;video&quot;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> box.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;hidden&quot;</span>));</span><br><span class="line"></span><br><span class="line">video.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  video.<span class="title function_">play</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> box.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;hidden&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>⚠⚠注意：<code>event.target</code> 在事件传递中保持不变，始终代表最内层的元素（事件传递的第一个收到的元素、事件捕获的最后一个捕获到的元素）⚠⚠</strong></p><h3 id="8-4-JavaScript-中的-“事件捕获”"><a href="#8-4-JavaScript-中的-“事件捕获”" class="headerlink" title="8.4 JavaScript 中的 “事件捕获”"></a>8.4 JavaScript 中的 “事件捕获”</h3><p>JavaScript 中，除了事件传递，还有一种术语叫 “事件捕获”，它和事件传递 <strong>唯一区别</strong> 是，“事件捕获” 的事件传递方向是从父元素到子元素，与一般事件传递方向正好相反。</p><p>你只有在 <code>addEventListener</code> 注册事件处理器时加上第三参数 <code>&#123; capture: true &#125;</code> 才会启用。</p><blockquote><p>你问为什么有这两种传递方式？唉，早期厂商的浏览器互不兼容（Netscape 只使用事件捕捉，而 Internet Explorer 只使用事件冒泡）。</p><p>现在的 W3C 指定标准后，将这两种方式都保留下来了，不过默认都是普通的事件传递。</p></blockquote><p><strong>因此这里强烈建议，在编写代码时，尽量使用一种传递方式，增强可读性和可维护性</strong>。</p><h2 id="Chapter-9-JavaScript-异步"><a href="#Chapter-9-JavaScript-异步" class="headerlink" title="Chapter 9. JavaScript 异步"></a>Chapter 9. JavaScript 异步</h2><p>网页端程序的响应速度极其重要，因此网页端应用采用异步的重要性不言而喻。</p><h3 id="9-1-认识旧式异步实现：基于事件处理器-和-回调函数"><a href="#9-1-认识旧式异步实现：基于事件处理器-和-回调函数" class="headerlink" title="9.1 认识旧式异步实现：基于事件处理器 和 回调函数"></a>9.1 认识旧式异步实现：基于事件处理器 和 回调函数</h3><p>上一章我们已经接触到了 JavaScript 异步编程的一种形式：事件处理器。它不会立即被调用，而是在事件发生时才被调用。只要我们把事件换成某个对象的状态变化，那么就变成了异步程序。</p><p>于是 <strong>早期的异步 API 就是采用这种方式</strong>：通过给 <code>XMLHttpRequest</code> 对象附加事件监听器来让程序在请求进展和最终完成时获得通知。</p><blockquote><p><code>XMLHttpRequest</code> 有 <code>loadend</code> 事件；</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;xhr&quot;</span>&gt;</span>click to send request<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;reload&quot;</span>&gt;</span>reload<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">readonly</span> <span class="attr">class</span>=<span class="string">&quot;event-log&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.event-log&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#xhr&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  log.<span class="property">textContent</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">addEventListener</span>(<span class="string">&quot;loadend&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    log.<span class="property">textContent</span> = <span class="string">`<span class="subst">$&#123;log.textContent&#125;</span> finished! Status Code:<span class="subst">$&#123;xhr.status&#125;</span>`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  xhr.<span class="title function_">open</span>(</span><br><span class="line">    <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json&quot;</span>,</span><br><span class="line">  );</span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line">  log.<span class="property">textContent</span> = <span class="string">`<span class="subst">$&#123;log.textContent&#125;</span> request was sent\n`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#reload&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  log.<span class="property">textContent</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span>.<span class="title function_">reload</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还有一种异步实现的方式：回调函数。它是一个<u>被传递到另一个函数中的、会在适当的时候被调用的</u>函数。</p><p>我们看到之前很多参数名 <code>&lt;callback&gt;</code> 都是回调函数。</p><p>那么为什么这种方法被舍弃了呢？考虑这样的场景：<strong>假设有 N 个独立的步骤，需要异步执行，它们必须按照一定的执行次序执行。那么当使用回调函数的方式实现的时候，它们就会深度嵌套。</strong>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doStep1</span>(<span class="params">init, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// DO SOMETHING</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStep2</span>(<span class="params">init, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// DO SOMETHING</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStep3</span>(<span class="params">init, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// DO SOMETHING</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doOperation</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">doStep1</span>(params, <span class="function">(<span class="params">result1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">doStep2</span>(result1, <span class="function">(<span class="params">result2</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">doStep3</span>(result2, <span class="function">(<span class="params">result3</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Result: <span class="subst">$&#123;result3&#125;</span>`</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doOperation</span>();</span><br></pre></td></tr></table></figure><p>这样不仅不美观，而且极大影响代码可读性、可维护性（尤其是 JavaScript 语言本身就难以调试）；</p><p>所以，大多数现代的异步 API 都不使用上述的方法。现在的 JavaScript 异步编程的基础是 Promise；</p><h3 id="9-2-新式异步：JavaScript-Promise"><a href="#9-2-新式异步：JavaScript-Promise" class="headerlink" title="9.2 新式异步：JavaScript Promise"></a>9.2 新式异步：JavaScript Promise</h3><p>JavaScript 的 Promise 对象是 <strong>一个由异步函数返回的、可以向我们指示当前操作所处的状态的</strong> 对象。</p><p>JavaScript 中有很多异步 API 都是基于 Promise 的，它们在被调用后会进行一些操作并立即返回 Promise 对象。开发者可以通过将处理函数附加到返回的 Promise 对象上实现回调。</p><h4 id="9-2-1-API-fetch"><a href="#9-2-1-API-fetch" class="headerlink" title="9.2.1 API fetch()"></a>9.2.1 API <code>fetch()</code></h4><p><code>[global.]fetch()</code> 方法就是一个基于 Promise 的、替代 <code>XMLHttpRequest</code> 的 API，我们直接看一个使用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fetchPromise);</span><br><span class="line"></span><br><span class="line">fetchPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Respond received: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Request sent...&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的程序分成几个步骤：</p><ol><li>使用 <code>fetch</code>（默认）向指定网页发送 GET 请求，返回 Promise 对象存放在 <code>fetchPromise</code> 中；</li><li>输出 Promise 对象，能看到 <code>Promise &#123; &lt;state&gt;: &quot;pending&quot; &#125;</code>，说明 Promise 对象有属性 <code>state</code> 来查看异步任务是否完成；</li><li>使用 <strong><code>Promise.then(&lt;callback&gt;)</code></strong> 向 Promise 对象加入回调函数，<code>callback</code> 函数传入参数就是之前使用 <code>fetch</code> API 规定的返回内容（<code>Response</code> 对象）；</li></ol><blockquote><p>总结：<code>fetch(&lt;url&gt;, &lt;options&gt;) -&gt; Promise -&gt;&gt; Response</code>；</p></blockquote><h4 id="9-2-1-Ex-知识补充：Response-对象"><a href="#9-2-1-Ex-知识补充：Response-对象" class="headerlink" title="9.2.1-Ex 知识补充：Response 对象"></a>9.2.1-Ex 知识补充：Response 对象</h4><p>常见实例属性（几乎都是只读，想要自定义请从构造函数传入）：<code>body</code>、<code>headers</code>、<code>status</code>、<code>url</code>（响应的 URL）、<code>redirected</code>（可以在 <code>fetch</code> 第二参数中禁止重定向：<code>&#123;redirect: &quot;error&quot;&#125;</code>）等；</p><p>常见的<strong>实例方法</strong>：</p><ul><li><code>Response.blob() -&gt; Promise -&gt;&gt; stream</code>：<strong>这是个异步 API，可以读取响应体中的二进制数据</strong>；</li><li><code>Response.clone()</code>：完全复制 Response 对象，唯一区别是内存地址和引用不同；</li><li><code>Response.formData() -&gt; Promise -&gt;&gt; FormData</code>：<strong>以表单数据的方式读取响应体，最终返回 <code>FormData</code> 对象</strong>（和之前的 <code>Array</code>、<code>DOMTokenList</code> 又不一样，自己查 API）；</li><li><code>Response.json() -&gt; Promise -&gt;&gt; JSON</code>：<strong>以 JSON 数据的方式读取响应体，最终返回原生 <code>JSON</code> 对象</strong>；</li><li><code>Response.text() -&gt; Promise -&gt;&gt; USVString</code>：<strong>以字符串的方式读取响应体，最终返回类似 <code>String</code> 的对象，总是 UTF-8</strong>；</li></ul><h4 id="9-2-2-链式-Promise"><a href="#9-2-2-链式-Promise" class="headerlink" title="9.2.2 链式 Promise"></a>9.2.2 链式 Promise</h4><p>Promise 更加优雅的原因是，它的 <code>then</code> 实例方法也会返回 Promise 对象，不过这个对象指示 <code>then</code> 回调函数执行的情况。这样，我们就可以链式地使用 Promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fetchPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> jsonPromise = response.<span class="title function_">json</span>();</span><br><span class="line">  jsonPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但我们在上一节中，回调实现遇到 “深层嵌套” 的问题，Promise 好像没有解决？它只不过换成了 <code>then</code> 的嵌套？</p><p>实际上不是这样，我们可以借助返回 Promise 的机制多返回几次，把上面的代码改写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fetchPromise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="9-2-3-Promise-异常处理"><a href="#9-2-3-Promise-异常处理" class="headerlink" title="9.2.3 Promise 异常处理"></a>9.2.3 Promise 异常处理</h4><p>众所周知，网络就是不稳定的，不可避免会出现一些问题。Promise 作为异步的基石，必然要进行异常处理。</p><p>以 <code>fetch()</code> 为例，它本身可能因为各种原因出现错误（如没有网络连接、或 URL 本身存在问题），而我们也需要自己在特定的业务逻辑中主动抛出错误。</p><p>对此，<code>Promise.catch(&lt;callback&gt;)</code> 就能解决问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fetchPromise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP Request error: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Failed to fetch product list: <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>⚠⚠<strong>请注意，只要异步操作中接收到了服务器的响应（不管是什么，例如服务器返回的 404），除非开发者自己抛出错误，否则 Promise 认为 fulfilled</strong>⚠⚠</p><h4 id="9-2-4-Promise-state"><a href="#9-2-4-Promise-state" class="headerlink" title="9.2.4 Promise state"></a>9.2.4 Promise state</h4><p>之前我们在 9.2.1 中看到 Promise 对象有个属性 <code>state</code> 指示异步任务的完成情况。</p><p>它有 3 种状态：</p><ul><li>pending：挂起等待，异步任务进行中；</li><li>fulfilled：异步任务成功完成，此时会执行 <code>then</code> 传入的回调函数；</li><li>rejected：异步任务执行失败，此时会执行 <code>catch</code> 传入的回调函数，如果没有就向上抛出错误；</li></ul><p>fulfilled 和 rejected 统称 settled；</p><h4 id="9-2-5-合并-Promise"><a href="#9-2-5-合并-Promise" class="headerlink" title="9.2.5 合并 Promise"></a>9.2.5 合并 Promise</h4><p>除了上面提到的链式使用 Promise，可能还会遇到一些情况，需要合并使用多个 Promise。</p><ul><li><code>Promise.all(Array[Promise]) -&gt; Promise -&gt;&gt; Array[...]</code> ，等待所有的 Promise 全部 settled，并且只有全部的 Promise 都 fulfilled，这个 Promise 才会 fulfilled，否则 rejected；</li><li><code>Promise.any(Array[Promise]) -&gt; Promise -&gt;&gt; ...</code>，等待<strong>任意一个 Promise settled</strong>，该 Promise 最终状态取决于这个等到的 Promise；</li></ul><h4 id="9-2-6-显式等待-Promise"><a href="#9-2-6-显式等待-Promise" class="headerlink" title="9.2.6 显式等待 Promise"></a>9.2.6 显式等待 Promise</h4><p>如果在一些业务逻辑中必须使用同步编程（例如没有最终返回值就进行不下去），那么就可以对 Promise 进行等待处理。对 Promise 的等待必须放在 <strong>异步函数（用关键字 <code>async</code> 修饰，箭头函数也是这样）</strong> 中，在返回 Promise 的 API 前加上 <code>await</code> 关键字，这样程序能够等待在这里并且返回最终对象；同时错误也会成为普通的 JavaScript 异常向上抛出。</p><p>⚠⚠<strong>请注意，异步函数只能返回 Promise 对象。</strong>⚠⚠</p><p>为什么必须要在异步函数中？因为异步函数有等待，也允许开发者在外面等待 / 继续使用 Promise 处理这个异步函数。</p><p><code>await</code> 和 Promise 链一样，强制异步操作串行完成（一般应用在 “前一个步骤是后一个步骤的参数“ 的情况）。如果不需要串行，<code>Promise.all</code> 可以有更好的性能。</p><h4 id="9-2-7-自定义基于-Promise-的异步-API"><a href="#9-2-7-自定义基于-Promise-的异步-API" class="headerlink" title="9.2.7 自定义基于 Promise 的异步 API"></a>9.2.7 自定义基于 Promise 的异步 API</h4><p>这里需要了解 Promise 的构造函数 <code>Promise(&lt;executor&gt;)</code>，<code>executor</code> 的需求参数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">resolve, reject</span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure><p><code>resolve</code>、<code>reject</code> 都是函数，<strong>分别对应传入 <code>then</code>、<code>catch</code> 中的函数</strong>。</p><p>当一个新的 Promise 对象被创建（<code>new</code>）后，它立即执行 <code>executor</code> 中的内容（通常是耗时任务）。</p><p>如果 <code>executor</code> 内调用了 <code>resolve</code>（也就是 <code>then</code> 传入的函数），那么 Promise 对象自动进入 fulfilled 状态；反之如果调用了 <code>reject</code> 或者<strong>抛出错误（自动调用 <code>reject</code>）</strong>，就相当于调用了 catch 传入的函数，或向上抛出了错误。</p><h4 id="9-2-8-异步的补充：JavaScript-多线程"><a href="#9-2-8-异步的补充：JavaScript-多线程" class="headerlink" title="9.2.8 异步的补充：JavaScript 多线程"></a>9.2.8 异步的补充：JavaScript 多线程</h4><p>这里只是介绍一下，JavaScript 中存在 <code>workers</code> 机制，例如 <code>dedicated workers</code>，创建线程，但不能访问 DOM 等等。有需要的话自行查询文档。</p><h2 id="Chapter-10-JavaScript-简单保存会话状态"><a href="#Chapter-10-JavaScript-简单保存会话状态" class="headerlink" title="Chapter 10. JavaScript 简单保存会话状态"></a>Chapter 10. JavaScript 简单保存会话状态</h2><p>基本上有 2 种简单的方法：<code>localStorage</code>、<code>sessionStorage</code>。</p><p>二者唯一的区别是，<strong>前者是 cookie，可以在用户关闭页面后，仍然保留数据，直到下一次打开就能还原数据；后者是 session，数据只保留到用户关闭此会话（即浏览器的标签页）</strong>。</p><p>使用方法是一样的：</p><ul><li>定义对象：直接赋值。<code>myStorage = [window.]localStorage;</code></li><li><strong>异常：<code>SecurityError</code>，用户拒绝使用 cookie / session</strong>；</li><li>设置键值：<code>localStorage.setItem(&quot;&lt;key&gt;&quot;, &quot;&lt;value&gt;&quot;);</code></li><li>获取键值：<code>localStorage.getItem(&quot;&lt;key&gt;&quot;, &quot;&lt;value&gt;&quot;);</code></li><li>移除键值：<code>localStorage.removeItem(&quot;&lt;key&gt;&quot;);</code></li><li>清空：<code>locaStorage.clear();</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript入门笔记</title>
      <link href="//technical/js-basic/"/>
      <url>//technical/js-basic/</url>
      
        <content type="html"><![CDATA[<p><i>Written by SJTU-XHW</i></p><p><i>Reference: </i>《Professional JavaScript for Web Developers》 3rd Edition</p><p><i>本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h2 id="Chapter-0-JavaScript-起源"><a href="#Chapter-0-JavaScript-起源" class="headerlink" title="Chapter 0. JavaScript 起源"></a>Chapter 0. JavaScript 起源</h2><h3 id="0-1-历史"><a href="#0-1-历史" class="headerlink" title="0.1 历史"></a>0.1 历史</h3><ul><li><p>Web 流行早期（上世纪末），Internet 用户上网速度 28.8 KB/s，但网页的大小和复杂性却不断增加。为完成简单的表单验证而频繁地与服务器交换数据只会加重用户的负担。于是，为了<strong>开发一种客户端语言，仅用来处理表单的简单验证工作</strong>，Netscape 公司在其发布的应用 Netscape Navigator 2 上加入一种脚本语言 <code>LiveScript</code>，认为是 JavaScript 的前身<strong>之一</strong>；</p></li><li><p>1995 年 2 月，Netscape 与 Sun 合作，为了搭上媒体热炒 Java 的顺风车，临时把 <code>LiveScript</code> 改名为 <code>JavaScript</code>，这就是 JavaScript 1.0；</p></li><li><p>其后不久，微软在自家作品 IE 3 中加入 <code>JScript</code>（是 JavaScript 的另一种实现） ，标志着 JavaScript 作为一门语言，其开发向前迈进了一大步。</p><blockquote><p>同时也有个严重问题：此时世界上有了两个不同的 JavaScript 版本：Netscape Navigator 中的 <code>JavaScript</code>、Internet Explorer 中的 <code>JScript</code>。与 C 及其他编程语言不同，当时还没有标准规定 JavaScript 的语法和特性。</p></blockquote></li><li><p>1997 年，欧洲计算机制造商协会（ECMA）制定了新脚本语言标准，称为 <code>ECMA-262</code>，即 <code>ECMAScript</code>。此后，各个浏览器开发厂商以此标准作为各自 JavaScript 实现的基础，衍生出一系列的版本和生态。</p><blockquote><p>注：此后因为各种复杂的历史原因，JavaScript 和 JScript 相当久之后才渐渐兼容 ECMAScript；</p></blockquote></li><li><p>此后 Mozilla 公司继承了 Netscape 的项目，继续开发 JavaScript 和 Netscape/Mozilla 浏览器；而如今，含 IE 内核的浏览器仍使用的是 JScript，不过现在它们都 ECMAScript 兼容了。</p></li></ul><h3 id="0-2-JavaScript-实现"><a href="#0-2-JavaScript-实现" class="headerlink" title="0.2 JavaScript 实现"></a>0.2 JavaScript 实现</h3><p>虽然 JavaScript 和 ECMAScript 通常都被人们用来表达相同的含义，但 JavaScript 的含义却比 ECMA-262 中规定的要多得多（<strong>JavaScript 的 3 个主要组成部分</strong>）：</p><p><img src="imgs/js_struct.png" height="150px"></p><h4 id="0-2-1-ECMAScript：JavaScript-的标准和核心"><a href="#0-2-1-ECMAScript：JavaScript-的标准和核心" class="headerlink" title="0.2.1 ECMAScript：JavaScript 的标准和核心"></a>0.2.1 ECMAScript：JavaScript 的标准和核心</h4><ul><li><strong>与浏览器没有依赖关系，不包含输入输出定义</strong>；</li><li>规定内容包括：<strong>语法、类型、语句、关键字、保留字、操作符、对象</strong>；</li><li>提供此语言解释器的环境称为 <strong>宿主环境</strong>；</li><li><strong>ECMAScript 兼容</strong>：指满足以下几点的宿主环境：<ul><li>支持 ECMA-262 描述的所有“类型、值、对象、属性、函数以及程序句法和语义”；</li><li>支持 Unicode 字符标准；</li><li>添加 ECMA-262 没有描述的“更多类型、值、对象、属性和函数”；</li><li>支持 ECMA-262 没有定义的“程序和正则表达式语法”（也就是说，<strong>可以修改和扩展内置的正则表达式语法</strong>）；</li></ul></li></ul><h4 id="0-2-2-DOM：文档对象模型"><a href="#0-2-2-DOM：文档对象模型" class="headerlink" title="0.2.2 DOM：文档对象模型"></a>0.2.2 DOM：文档对象模型</h4><ul><li><p><strong>DOM 是一种针对 XML 但经过扩展用于 HTML 的 <u>API（应用程序编程接口）</u>，并不只是针对 JavaScript，很多其他语言也实现了</strong>；</p><blockquote><p>知识补充：XML 格式</p><p>一种和 HTML 类似的<strong>多层节点文档结构</strong>，结构中每个组分都是某种类型的节点，这些节点又包含不同类型数据。</p></blockquote></li><li><p><strong>ECMAScript 的扩展实现之一</strong>，依赖于 HTML / XML 页面；</p></li><li><p>功能：核心规定的是<strong>如何映射基于 XML 的文档结构，以便简化对文档中任意部分的访问和操作</strong>；</p><blockquote><p>DOM 的这个功能比较抽象，具体来说就是将：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在编程层面抽象为：</p><p><img src="imgs/dom_example1.png" height="240px"></p><p>提供了一些方便的接口函数，让开发人员可以轻松自如地删除、添加、替换或修改任何节点。</p></blockquote></li><li><p>DOM 级别：DOM API 的标准历史版本；</p><ul><li><p>DOM 1 级：由 <strong>DOM Core</strong> 和 <strong>DOM HTML</strong> 两个模块 API 构成。前者<strong>规定如何映射基于 XML 的文档结构（操作函数声明）</strong>，后者<strong>添加了针对 HTML 的对象和方法</strong>；</p></li><li><p>DOM 2 级：在 DOM 1 级基础上<strong>扩充了鼠标 及 GUI Events、Ranges、Iteration（迭代 DOM 文档的方法）等模块，增加对 CSS 的操作接口支持</strong>；</p><blockquote><ol><li>DOM Views，DOM 视图接口；</li><li>DOM Events，事件处理接口；</li><li>DOM Style，基于 CSS <strong>为指定元素应用样式</strong>的接口；</li><li>DOM Traversal and Range：遍历和操作文档树的接口；</li></ol></blockquote></li><li><p>DOM 3 级：在 DOM 2 基础上，<strong>引入了以统一方式加载和保存文档的方法（DOM Save &amp; Load）</strong>、<strong>新增了验证文档的方法（DOM Validator）</strong>、扩展了 DOM Core（支持 XML 1.0 规范，涉及 XML Infoset、XPath 和 XML Base）；</p></li></ul></li><li><p>其他 DOM 标准 API：</p><ul><li>SVG（可伸缩矢量图）；</li><li>MathML（数学标记语言）；</li><li>SMIL（同步多媒体集成语言）；</li></ul></li></ul><h4 id="0-2-3-BOM：浏览器对象模型"><a href="#0-2-3-BOM：浏览器对象模型" class="headerlink" title="0.2.3 BOM：浏览器对象模型"></a>0.2.3 BOM：浏览器对象模型</h4><ul><li><p>定义：一组支持访问和操作浏览器窗口的 API；</p></li><li><p><strong>ECMAScript 的扩展实现之一</strong>，依赖于浏览器；</p><blockquote><p>早期漏洞出现频繁，兼容性不强，因为没有相关标准。</p><p>HTML 5 出现后，BOM 的框架才列入正式规范；但目前各个浏览器实现方式几乎都不同；</p></blockquote></li><li><p>功能：</p><ul><li>弹出新浏览器窗口的功能；</li><li>移动、缩放和关闭浏览器窗口的功能；</li><li>提供浏览器详细信息的 navigator 对象；</li><li>提供浏览器所加载页面的详细信息的 location 对象；</li><li>提供用户显示器分辨率详细信息的 screen 对象；</li><li>对 cookies 的支持；</li><li>像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象；</li></ul></li></ul><h4 id="0-3-总结"><a href="#0-3-总结" class="headerlink" title="0.3 总结"></a>0.3 总结</h4><p>JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成：</p><ul><li>ECMAScript，由 ECMA-262 定义，提供核心语言功能；</li><li>文档对象模型（DOM），提供访问和操作 XML 文档 和 HTML 页面内容的方法和接口；</li><li>浏览器对象模型（BOM），提供与浏览器交互的方法和接口。</li></ul><p>JavaScript 的这三个组成部分，在当前五个主要浏览器（IE、Firefox、Chrome、Safari 和 Opera）中 都得到了不同程度的支持。</p><p>其中，所有浏览器对 ECMAScript 第 3 版的支持大体上都还不错，而对 ECMAScript 5 的支持程度越来越高，但对 DOM 的支持则彼此相差比较多。对已经正式纳入 HTML5 标准的 BOM 来说，尽管各浏览器都实现了某些众所周知的共同特性，但其他特性还是会因浏览器而异。</p><blockquote><p>接下来开始加速，请做好准备。</p></blockquote><h2 id="Chapter-1-在-HTML-中使用-JavaScript"><a href="#Chapter-1-在-HTML-中使用-JavaScript" class="headerlink" title="Chapter 1. 在 HTML 中使用 JavaScript"></a>Chapter 1. 在 HTML 中使用 JavaScript</h2><h3 id="1-1-lt-script-gt-元素"><a href="#1-1-lt-script-gt-元素" class="headerlink" title="1.1 &lt;script&gt; 元素"></a>1.1 <code>&lt;script&gt;</code> 元素</h3><p>使用 <code>&lt;script&gt;</code> 元素将 javascript 加入 HTML：最早由 Netscape 实现，后来作为 HTML 4.01 的规范；</p><p><code>&lt;script&gt;</code> 元素的属性：</p><ul><li><code>async</code>：可选，表示<strong>立即下载这个脚本，但是异步（不妨碍其他内容加载和运行）</strong>，仅对外部脚本有效，内嵌无效；</li><li><code>defer</code>：可选，表示<strong>当前脚本可以延迟到文档完全解析、显示后再执行</strong>，仅对外部脚本有效；</li><li><code>src</code>：可选，表示<strong>这个脚本是外部脚本，并指定位置</strong>；</li></ul><p>还有两种可以不掌握：</p><ul><li><code>type</code>：可选，脚本语言类型，一般没啥用，默认值就是 <code>text/javascript</code>；</li><li><code>charset</code>：可选，指定字符集（由于大多数浏览器会忽略这个属性，所以很少有人用）；</li></ul><blockquote><p><code>&lt;script&gt;</code> 元素的位置：</p><p>过去经典做法是将所有脚本标签放在 HTML 的 <code>&lt;head&gt;</code> 元素中，这意味着需要等所有脚本加载完毕才会开始解析页面，这对 JS 代码很多的页面而言，延迟明显；</p><p>现代的 Web 应用将 JS 放在 <code>&lt;body&gt;</code> 元素最后的部分，在用户看来提升了页面加载速度；</p></blockquote><h3 id="1-2-内联脚本-和-外部脚本"><a href="#1-2-内联脚本-和-外部脚本" class="headerlink" title="1.2 内联脚本 和 外部脚本"></a>1.2 内联脚本 和 外部脚本</h3><p>内联的方法很简单，只有一种可能的写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>内联 js 脚本需要注意几点</strong>：</p><ul><li><p>内联 js 脚本会在  HTML 中<strong>顺序解释（同步）</strong>，即不执行完不向下解释 HTML；</p></li><li><p>不允许在内联脚本中<strong>以任何形式出现 <code>&lt;/script&gt;</code>，除非有转义符</strong>，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sayScript</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;&lt;\/script&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>外部 js 脚本必须有 <code>src</code> 属性，<code>defer</code> 和 <code>async</code> 可选；</p><p>注意，外部 js 脚本也会在 HTML 中顺序解释，<strong>但 <code>defer</code> 和 <code>async</code> 可能改变这个行为</strong>；</p><p>在 HTML 中嵌入 JavaScript 代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含 JavaScript 代码。不过，并不存在必须使用外部文件的硬性规定，但支持使用外部文件的人多会强调如下优点：</p><ul><li>可维护性：遍及不同 HTML 页面的 JavaScript 会造成维护问题。但把所有 JavaScript 文件都放在 一个文件夹中，维护起来就轻松多了。而且开发人员因此也能够在不触及 HTML 标记的情况下， 集中精力编辑 JavaScript 代码；</li><li>可缓存性：浏览器能够根据具体的设置缓存链接的所有外部 JavaScript 文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度；</li><li>适应性：通过外部文件来包含 JavaScript 无须使用 XHTML 或注释 hack。HTML 和 XHTML 包含外部文件的语法是相同的；</li></ul><h3 id="1-3-lt-noscript-gt-元素"><a href="#1-3-lt-noscript-gt-元素" class="headerlink" title="1.3 &lt;noscript&gt; 元素"></a>1.3 <code>&lt;noscript&gt;</code> 元素</h3><p>在不支持 Javascript 的浏览器 / 浏览器禁用 Javascript 的情况下，<strong>才会</strong>显示 <code>&lt;noscript&gt;</code> 中的元素。</p><h2 id="Chapter-2-Javascipt-基本语法"><a href="#Chapter-2-Javascipt-基本语法" class="headerlink" title="Chapter 2. Javascipt 基本语法"></a>Chapter 2. Javascipt 基本语法</h2><blockquote><p>本章的语法标准以 ECMA-262 实现的 ECMAScript 为基础。</p></blockquote><h3 id="2-1-细节"><a href="#2-1-细节" class="headerlink" title="2.1 细节"></a>2.1 细节</h3><ul><li><p><strong>区分大小写</strong>；</p></li><li><p><strong>变量标识符命名规范</strong>：与 C / C++ 等一般语言不同的是，ECMAScript 允许美元符号（<code>$</code>）存在于变量名的任何位置，包括开头。其他都与普通语言相同，例如不用关键字、不用数字开头、建议驼峰命名等；</p><blockquote><p><script type="math/tex">abc`、`a$b`、`ab</script> 都是合法的变量标识符；</p></blockquote></li><li><p>注释：同 C / C++；</p></li><li><p><strong>严格模式</strong>：在<strong>脚本全文开头（作用于全文）</strong> / <strong>某函数体中（作用于该函数）</strong>使用 <code>&quot;use strict&quot;;</code>，代表编译指示（pragma），启用 Javascript 的严格模式；</p><blockquote><p>本质上为 Javascript 定义了一种不同的解释和执行模型，对 ECMAScript 3 中的 UB 也能得到处理，但是对某些不安全的行为会抛出错误，执行结果也可能与普通模式不同。这个区别会在以后的讨论时及时指出。</p></blockquote></li><li><p>语句建议<strong>使用分号结尾</strong>（虽然没有分号解释器一般也可以识别，但还是规范点好），语句块的模式和 C / C++ 都一样，以花括号表示语句块；</p></li></ul><h3 id="2-2-关键字和保留字"><a href="#2-2-关键字和保留字" class="headerlink" title="2.2 关键字和保留字"></a>2.2 关键字和保留字</h3><p><img src="imgs/keywords.png" width="500px"></p><p><img src="imgs/reserved.png" width="500px"></p><p>此外，ECMAScript 5 中新增 <code>let</code> 和 <code>yield</code> 为保留字；</p><p><strong>在严格模式下，不允许使用 <code>eval</code> 和 <code>arguments</code> 作为标识符或属性名</strong>；</p><h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h3><p>ECMAScript 定义的变量是<strong>松散类型</strong>，即<strong>变量只是一个占位符，本身可以用来保存任何类型</strong>。</p><ul><li><p>变量声明：使用 <code>var</code> 关键字；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br></pre></td></tr></table></figure><p>像这样<strong>未初始化的值会保存一个特殊的值：<code>undefined</code></strong>（之后讨论这是什么）；</p></li><li><p>变量定义（声明 + 初始化）；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">// 允许多个定义，与 C / C++ 类似</span></span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">&quot;world&quot;</span>,</span><br><span class="line">    age = <span class="number">100</span>,</span><br><span class="line">    cdn = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>变量的定义或声明不建议忽略 <code>var</code>，因为在严格模式下会抛出错误</strong>；</p><h3 id="2-5-数据类型"><a href="#2-5-数据类型" class="headerlink" title="2.5 数据类型"></a>2.5 数据类型</h3><p>ECMAScript 中的基本数据类型有 5 种：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>；另外有一种<strong>复杂数据类型：<code>Object</code>，本质上由一组无序键值对构成，相当于小型的 “类” 的概念</strong>；</p><p>因为 ECMAScript 的类型动态性，就没有必要定义其他数据类型了。</p><h4 id="2-5-1-typeof-保留字：数据类型检查"><a href="#2-5-1-typeof-保留字：数据类型检查" class="headerlink" title="2.5.1 typeof 保留字：数据类型检查"></a>2.5.1 <code>typeof</code> 保留字：数据类型检查</h4><p>使用 <code>typeof &lt;anything&gt;</code> （也允许用括号括起来）可以返回这几种字符串：<code>&quot;undefined&quot;</code>、<code>&quot;boolean&quot;</code>、<code>&quot;string&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;object&quot;</code>、<code>&quot;function&quot;</code>；</p><ul><li>注 1：<code>Null</code> 类型实际上是一个<strong>空的 <code>Object</code> 引用</strong>，因此 <code>typeof null</code> 返回 <code>&quot;object&quot;</code>；</li><li>注 2：函数实际上也是一类 <code>Object</code>，但有一些特殊的属性，因此 ECMAScript 有必要在 <code>typeof</code> 输出中单独区分开；</li></ul><h4 id="2-5-2-Undefined-类型"><a href="#2-5-2-Undefined-类型" class="headerlink" title="2.5.2 Undefined 类型"></a>2.5.2 Undefined 类型</h4><p>此类型<strong>只有一个值</strong>：<code>undefined</code>，常常在访问未初始化变量时出现。可以用等号操作符（<code>==</code>）判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br><span class="line"><span class="title function_">alert</span>(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>也可自行给定 <code>undefined</code> 值（不过没必要）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="literal">undefined</span>;</span><br><span class="line"><span class="title function_">alert</span>(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>未定义 / 声明的变量</strong> 和 <strong>声明了却 undefined 的变量</strong> 不一样。前者直接使用是错误的，这和大多数语言一样。</p><p>但是，对未声明的变量可以用 <code>typeof</code>，并且返回的也是 <code>&quot;undefined&quot;</code>，尽管它们不能使用；<strong>因此尽量初始化是个好习惯，这样我们就能知道哪些值是没声明的，而不是没初始化</strong>。</p><h4 id="2-5-3-Null-类型"><a href="#2-5-3-Null-类型" class="headerlink" title="2.5.3 Null 类型"></a>2.5.3 Null 类型</h4><p>此类型<strong>也只有一个值</strong>：<code>null</code>，表示空的对象的引用；</p><p><strong>建议总是为 将来要存储 <code>object</code> 的变量赋予该值，一方面体现了 <code>null</code> 的意义，另一方面有助于区分 <code>null</code> 和 <code>undefined</code></strong>。</p><p>很奇怪的是，我们没法用相等运算符区分 <code>null</code> 和 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="literal">null</span> == <span class="literal">undefined</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是，这不妨碍我们在操作一个变量前检查它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;    <span class="comment">// 同时拦截 null 和 undefined</span></span><br><span class="line">    <span class="comment">// 对 obj 对象操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-4-Boolean-类型"><a href="#2-5-4-Boolean-类型" class="headerlink" title="2.5.4 Boolean 类型"></a>2.5.4 Boolean 类型</h4><p>此类型<strong>只有两个值</strong>：<code>true</code>（真值）、<code>false</code>（假值）；</p><p>其他任何类型都可以通过<strong>类型转换函数（<code>Boolean()</code>）</strong>或者<strong>条件语句自动类型转换</strong>转为 Boolean 值：</p><ul><li>会转换为 <strong>假值</strong> 的值：String 类型<strong>空字符串</strong>、Number 类型 <strong>0 和 <code>NaN</code></strong>、Object 类型 <strong><code>null</code></strong>、Undefined 类型 <strong><code>undefined</code></strong>；</li><li>其余所有值都会转为 <strong>真值</strong>（包括后面提到的 <code>Infinity</code> 等等）；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Boolean</span>(message));    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (msg) &#123;    <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-5-Number-类型"><a href="#2-5-5-Number-类型" class="headerlink" title="2.5.5 Number 类型"></a>2.5.5 Number 类型</h4><h5 id="数值运算-和-数值范围"><a href="#数值运算-和-数值范围" class="headerlink" title="数值运算 和 数值范围"></a>数值运算 和 数值范围</h5><p>声明相当于 C/C++ 中的整型 + 浮点数；使用方法（如 8 进制、10 进制、16 进制表示方法、浮点数科学计数法等）、注意事项（不用浮点数作比较等等）与 C/C++ 也相同；</p><p>数值范围：<code>Number.MIN_VALUE(5e-324) ~ Number.MAX_VALUE(1.8e+308)</code>，超出范围的值会被转为特殊的正数 <code>Infinity</code> 或负数 <code>-Infinity</code>（均无法继续运算）；</p><p>一般计算很难出现正负无穷的情况，真正进行大数计算时，可以用 <code>isFinite()</code> 检查；</p><h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><p>此外，还有一个 <code>NaN</code>（Not a Number），是个特殊数值，用来表示<strong>一个本该返回数值的操作数未返回的情况（这样省去抛出错误的情况）</strong>；</p><p><code>NaN</code> 也不能使用相等运算符比较：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="title class_">NaN</span> == <span class="title class_">NaN</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>ECMAScript 提供了专门的判断函数 <code>isNaN()</code>，<strong>工作原理是对传入参数转为 <code>Number</code> 类型运算，如果不能运算，那么返回 <code>true</code></strong>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="number">10</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="literal">true</span>));    <span class="comment">// 可转为数值 1，false</span></span><br></pre></td></tr></table></figure><p><strong>不可思议的是，<code>isNaN()</code> 可以作用于对象 <code>Object</code>，先调用 <code>valueOf()</code> 方法确定返回值是否能转换，然后调用 <code>toString()</code> 再看结果是否能转换</strong>；</p><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><ul><li><code>Number()</code>：将任何数据类型转为数值；</li><li><code>parseInt(String)/parseFloat(String)</code>：将字符串转为相应数值；</li></ul><p>无法转换的返回 <code>NaN</code>，这就解释了 <code>isNaN()</code> 的工作原理；</p><p><strong>但是 <code>null</code> 可以转换为 0</strong>；</p><h4 id="2-5-6-String-类型"><a href="#2-5-6-String-类型" class="headerlink" title="2.5.6 String 类型"></a>2.5.6 String 类型</h4><h5 id="字符串直接量"><a href="#字符串直接量" class="headerlink" title="字符串直接量"></a>字符串直接量</h5><p>可以使用单引号或双引号完成，和 PHP 不同，这两种引号没区别；</p><h5 id="常用属性-方法"><a href="#常用属性-方法" class="headerlink" title="常用属性 / 方法"></a>常用属性 / 方法</h5><p>对一个 String 类型，它具有以下几种常用属性：</p><ul><li><code>length</code>；</li></ul><p>和以下的常用方法：</p><ul><li><p>加法拼接运算；</p><blockquote><p>注意，对于运算过程有个处理机制，例如下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;</span><br></pre></td></tr></table></figure><p>首先创建一个能容纳 10 个字符的新字符串，</p><p>然后在这个字符串中填充”Java”和”Script”，</p><p>最后一步是销毁原来的字符串”Java”和字符串”Script”（二者其后的引用数为 0）；</p></blockquote></li><li><p><code>at</code>、<code>indexOf</code>、<code>substr</code>、<code>endsWith</code>…… 等其他一切和 Java String 很接近的函数；</p></li></ul><h5 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h5><p>除了 <code>Null</code> 和 <code>Undefined</code> 类（它们直接返回），其他所有类型都有 <code>toString()</code>；</p><p>此外，可以通过 <code>+</code> 运算符隐式转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ageStr = <span class="string">&quot;&quot;</span> + <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h4 id="2-5-7-Object-类型"><a href="#2-5-7-Object-类型" class="headerlink" title="2.5.7 Object 类型"></a>2.5.7 Object 类型</h4><h5 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h5><p>和 Java 语言一样，使用 <code>new</code> 关键字申请创建新对象，但是回收无需开发者操心：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>同样和 <code>java.lang.Object</code> 一样的是，<code>Object</code> 也是所有 object 的父类，它也有如下的抽象方法：</p><ul><li><p>constructor：构造函数，前面的 <code>Object()</code> 就是 <code>Object</code> 类的构造函数；</p></li><li><p><code>hasOwnProperty(propertyName: String)</code>：检验当前对象中是否存在自定义的属性名；</p><blockquote><p>类似 Python <code>hasattr</code>；</p></blockquote></li><li><p><code>isPrototypeOf(object: Object)</code>：检验当前 object 对象是否是传入的 <code>object</code> 的<strong>原型（Prototype）</strong>；</p></li><li><p><code>propertyIsEnumerable(propertyName: String)</code>：检验当前 object 对象的属性是否能使用 <code>for-in</code> 循环进行迭代遍历；</p></li><li><p><code>toLocaleString/toString()</code>：转字符串；</p></li><li><p><code>valueOf()</code>：默认返回自身；</p></li></ul><p><strong>值得注意的是， ECMAScript 中没有定义如 BOM、DOM 中的对象，因为它们是 宿主对象，所以某些宿主对象可能不继承于 <code>Object</code></strong>；</p><p><strong>属性键值对添加方法</strong></p><p>直接使用作用域运算符（<code>.</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">test</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p><strong>属性键值对删除方法</strong></p><p>使用关键字 <code>delete</code>：<strong>对于几乎所有对象、简单类型都能这么做，解释器立即删除为该变量分配的空间，相当于回到未声明前</strong>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">test</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">age</span>;    <span class="comment">// obj.age -&gt; undefined</span></span><br></pre></td></tr></table></figure><h3 id="2-6-操作符"><a href="#2-6-操作符" class="headerlink" title="2.6 操作符"></a>2.6 操作符</h3><p>自增、自减、一元加减、位运算、普通四则运算、取模、复合赋值运算符、三目运算符几乎全部与 C/C++ 相同；</p><p>有几个点需要注意：</p><ul><li><p><strong>逻辑操作和 C/C++ 不一样，返回的值不一定是 Boolean：只要有一个 operand 不是 Boolean 类型，那么返回的就是真值的数据类型</strong>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">0</span> || <span class="number">123</span>;    <span class="comment">// test == 123</span></span><br></pre></td></tr></table></figure></li><li><p><code>Infinity</code> 与普通数的四则运算关系、<code>+0</code> 和 <code>-0</code> 的运算关系，与 C++ 浮点数相同；</p></li><li><p><strong>数据加法运算 和 字符串拼接运算</strong> 在某些情况需要开发者手动明确语义，防止发生意想不到的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">5</span> + <span class="string">&quot;5&quot;</span>;    <span class="comment">// 字符串拼接，test == &quot;55&quot;</span></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="number">5</span> + <span class="built_in">parseInt</span>(<span class="string">&quot;5&quot;</span>, <span class="number">8</span>);    <span class="comment">// Number 运算，test == 10</span></span><br></pre></td></tr></table></figure></li><li><p><strong>比较运算符在应用在两个 operand 都是 String 的方面，会将 String 的每一位字符拿出 ASCII / Unicode 进行比较</strong>；如果有一个是 Number 类型，解释器都会尝试将另一个转为 Number，转换不成就变成 NaN，而 <strong>NaN 参与比较运算永远是 false</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="string">&quot;23&quot;</span> &lt; <span class="number">3</span>;        <span class="comment">// false, 23 &gt; 3</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&quot;23&quot;</span> &lt; <span class="string">&quot;3&quot;</span>;    <span class="comment">// true, u&#x27;2&#x27; &lt; u&#x27;3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res1 = <span class="title class_">NaN</span> &lt; <span class="number">3</span>;        <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> res2 = <span class="title class_">NaN</span> &gt;= <span class="number">3</span>;     <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>⚠ <strong>在比较运算时，如果一个是 number 另一个是 string，则统一换为 number；而在加法运算时，如果一个是 number 另一个是 string，则统一换为 string</strong>（都不论前后顺序）；</p></li><li><p>逗号操作符：<strong>和 C / C++ 一样，用于声明多个变量。但是 ECMAScript 还能用于赋值，但只返回表达式最后一项</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>);    <span class="comment">// num == 0</span></span><br></pre></td></tr></table></figure></li></ul><p>ECMAScript 中还引入了几种不同的运算符：</p><ul><li><strong>在比较运算符中，除了相等运算符（<code>==</code>），还有全等运算符（<code>===</code>）</strong>；这是因为相等运算符比较<strong>会发生自动类型转换，例如 <code>&quot;5&quot; == 5</code> 是 true</strong>，而全等运算符不会转换数据类型。所以必要时，<strong>建议使用全等运算符</strong>；</li><li><strong>ECMAScript 中存在无符号右移 <code>&gt;&gt;&gt;</code> 和无符号右移赋值 <code>&gt;&gt;&gt;=</code></strong>；</li></ul><h3 id="2-7-语句"><a href="#2-7-语句" class="headerlink" title="2.7 语句"></a>2.7 语句</h3><p><code>if-else</code> 语句、<code>while</code> 语句、<code>do-while</code> 语句、<code>for</code> 语句、标签语句、<code>break/continue</code> 语句、<code>switch</code> 语句使用与 C/C++ 相同，但是！</p><p>ECMAScript 中<strong>不存在块级作用域</strong>，这意味着代码块中定义的，在外面也能访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(i);    <span class="comment">// i -&gt; 100</span></span><br></pre></td></tr></table></figure><p>ECMAScript 还具有：</p><ul><li><p><code>for-in</code> 语句：<strong>精准的迭代语句，可以用于枚举 object 的属性（回忆一下，没有顺序）</strong>，<code>for (property in expression) statement;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;    <span class="comment">// BOM window 对象</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(prop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，使用前需要检查 <code>object</code> 不能为 <code>null/undefined</code>，否则在某些浏览器上会报错</strong>；</p></li><li><p><code>with</code> 语句（大型项目不建议使用，因为性能极差，并且可读性差，<strong>并且在严格模式下不允许使用，会视为错误</strong>）：简化多次编写同一个对象的工作；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (location) &#123;</span><br><span class="line">    qs = search.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>qs</code> 会先当作普通局部变量查找，再当作 <code>location</code> 的属性查找；如果找不到再报错；</p></li></ul><h3 id="2-8-函数"><a href="#2-8-函数" class="headerlink" title="2.8 函数"></a>2.8 函数</h3><p>定义语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">arg0, arg1, ..., argN</span>) &#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ECMAScript 中有几个值得注意的点：</p><ul><li><p>和强类型语言不一样，ECMAScript 不关心函数返回值类型、参数类型；</p></li><li><p>和其他众多语言<strong>不一样</strong>，ECMAScript 甚至不关心形参列表究竟是什么，意味着你即便这么定义函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以这样调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="string">&quot;world&quot;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>因为在函数内部维护了 <code>arguments</code> 保留字，它相当于数组（但不是 <code>Array</code> 的实例，类型是 <code>Object</code>），<strong>可以用方括号访问 entry，也可以访问 <code>.length</code> 来看究竟传入了多少参数</strong>，<strong>并且生存周期仅在函数中，超过周期即销毁为 <code>undefined</code></strong>；</p><p>所以形参表存在的唯一作用是方便函数调用传入参数。<strong>这样，尽管 ECMAScript 没有重载的概念、没有函数签名的概念，但事实上也不需要了</strong>（ECMAScript 尝试定义重名函数，只会保留最后一次出现的定义）。</p><p><strong>值得注意的是，通常在函数内修改 <code>arguments</code> 是不规范的行为，在严格模式下会抛出错误</strong>；</p></li></ul><h2 id="Chapter-3-内存问题-与-变量作用域"><a href="#Chapter-3-内存问题-与-变量作用域" class="headerlink" title="Chapter 3. 内存问题 与 变量作用域"></a>Chapter 3. 内存问题 与 变量作用域</h2><h3 id="3-1-变量类型-与-内存"><a href="#3-1-变量类型-与-内存" class="headerlink" title="3.1 变量类型 与 内存"></a>3.1 变量类型 与 内存</h3><p>在 ECMAScript 中，有 2 种变量类型：</p><p><strong>基本类型（前面提到的 5 种基本数据类型）</strong>和 <strong>引用类型</strong>；</p><p>而当解释器执行某个赋值语句时，<strong>必须确定</strong>当前变量是基本类型还是引用类型。这是为什么？</p><p><strong>主要是因为 JavaScript 中，这两种类型的变量在内存中的形态不同。</strong></p><ul><li>对于基本类型的变量（ECMAScript 中包含字符串），其值存放于<strong>解释器运行时环境中</strong>（可以理解为放在<strong>栈内存</strong>上）；</li><li>对于引用类型的变量，创建总需要 <code>new</code> 关键字在<strong>堆内存</strong>中开辟空间。由于 JavaScript 不允许使用地址 / 指针，因此引用类型变量在复制 / 赋值等操作时总是针对引用（相当于 C 中自动完成 <code>*objPtr</code>）、在设置属性操作时总是针对对象（相当于 C 中自动完成 <code>objPtr-&gt;attr</code>）；</li></ul><p>看两个例子就能彻底明白：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = num1;</span><br></pre></td></tr></table></figure><p><img src="imgs/basicCopy.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br></pre></td></tr></table></figure><p><img src="imgs/refCopy.png"></p><p>那么检查一个变量名存放的究竟是基本数据类型还是引用类型，可以使用 <code>typeof</code> 关键字；</p><p>对于返回值为 <code>object / function</code> 的变量而言，它们一定是引用类型变量，其他则是基本类型；</p><p>此外，对于 JavaScript 中的继承关系，有关键字 <code>instanceof</code> 识别：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>);    <span class="comment">/* 内置 Array 类是 Object 的子类 */</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips. 此内容第一次读可以跳过。</p><p>对于正则表达式，不同的 JavaScript 解释器执行 <code>typeof</code> 的结果不同，这是实现标准不同的原因。对于 ECMA-262 标准规定，任何在内部实现 <code>[[Call]]</code> 方法的对象都应该在应用 <code>typeof</code> 操作符时返回 <code>&quot;function&quot;</code>，Safari（&gt; 5）及 Chrome（&gt; 7）满足这条规定，但 IE 和 Firefox 则会返回 <code>&quot;object&quot;</code>； </p></blockquote><h3 id="3-2-动态属性-与-内存"><a href="#3-2-动态属性-与-内存" class="headerlink" title="3.2 动态属性 与 内存"></a>3.2 动态属性 与 内存</h3><p>了解了基本类型 和 引用类型变量在内存中的排布，那么还有一个问题。<strong>既然像 <code>Object</code> 一类的引用类型是在堆内存中的，那么为他们设置属性的时候，它们的属性应该放在哪里？</strong></p><p>其实也是放在堆中的。毕竟它们的属性也是动态的，运行时随时可以添加和删除。</p><p>所以我们看看以下的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">b</span> = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">obj.<span class="property">f</span> = <span class="variable language_">console</span>.<span class="property">log</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = obj;</span><br></pre></td></tr></table></figure><p>等价于 C 的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span>* b;</span><br><span class="line">    <span class="type">void</span> (*f)(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">&#125; *obj, *obj2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    obj = (Object*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Object));</span><br><span class="line">    obj-&gt;a = <span class="number">1</span>;</span><br><span class="line">    obj-&gt;b = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    obj-&gt;b[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>, obj-&gt;b[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>, obj-&gt;b[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>, obj-&gt;b[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    obj-&gt;f = <span class="built_in">printf</span>;</span><br><span class="line">    </span><br><span class="line">    obj2 = obj1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于 C++ 的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    std::string b;</span><br><span class="line">    <span class="built_in">void</span> (*f)(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object &amp;obj = *(<span class="keyword">new</span> Object);</span><br><span class="line">    obj.a = <span class="number">1</span>;</span><br><span class="line">    obj.b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    obj.c = printf;</span><br><span class="line">    </span><br><span class="line">    Object &amp;obj2 = obj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>还有一个问题，基本类型变量能否设置属性呢？直觉上肯定是会报错的。实际上，<strong>不会报错</strong>，但解释器只是<strong>忽略</strong>了此语句。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">name.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">age</span>);    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>所以我们只能对引用类型变量设置动态属性。</p><h3 id="3-3-函数参数传递-与-内存"><a href="#3-3-函数参数传递-与-内存" class="headerlink" title="3.3 函数参数传递 与 内存"></a>3.3 函数参数传递 与 内存</h3><p>在学习 JavaScript 函数时，我们曾经了解到 <code>arguments</code> 内置变量。而参数传递的过程，就是：</p><ul><li>向 <code>arguments</code> 中赋予 <code>0 ~ N</code> 键对应的值；</li><li>向自定义的形式参数赋予对应的值（如果有的话）；</li></ul><p>这些赋值后的变量都是函数局部变量，如果实际参数是一个<strong>基本类型的变量</strong>，那么直接<strong>值传递</strong>；如果实际参数是一个引用类型的变量，那么进行<strong>引用传递</strong>（类似 C++ 中参数自动完成 <code>Type &amp;param</code>）；</p><h3 id="3-4-执行环境-与-变量作用域"><a href="#3-4-执行环境-与-变量作用域" class="headerlink" title="3.4 执行环境 与 变量作用域"></a>3.4 执行环境 与 变量作用域</h3><p>JavaScript 中一个相当重要的概念就是 <strong>执行环境（execution context）</strong>，和 C 中的作用域的思想相近，但不相同。JavaScript 执行环境有以下特征：</p><ul><li><p>执行环境定义了<strong>变量或函数有权访问的其他数据</strong>，<strong>决定了它们各自的行为</strong>；</p></li><li><p>每个执行环境都有一个与之关联的<strong>变量对象（variable object）</strong>，环境中定义的<strong>所有变量和函数</strong>都保存在这个对象中；</p><blockquote><p>类似 Python 的对于一个包的 <code>__dict__</code> 属性；</p><p>与 Python 不同的是，<strong>开发者没法访问这个变量对象，只有解释器才能使用它</strong>；</p></blockquote></li><li><p>JavaScript 最外围的执行环境被称为<strong>全局执行环境</strong>（可以有多个）。不过，根据 ECMAScript 实现所在的宿主环境不同，<strong>表示执行环境的对象</strong>也不一样；</p><blockquote><p><strong>什么是 “表示执行环境的对象”？</strong></p><p>JavaScript 中将保持上下文变量、函数的任务统统交给了对象（<code>Object</code>）。因此将当前执行环境的变量、函数保存的对象就称为 “表示执行环境的对象”；</p><p>例如，如果宿主环境是 web 浏览器（即浏览器提供解释器），那么全局执行环境就是 <code>window</code> 对象（将在后面介绍）；<strong>因此所有的全局变量、函数都作为 <code>window</code> 对象的属性和方法创建</strong>；</p></blockquote></li><li><p>JavaScript 中每个函数都有自己的执行环境。这就类似 C 中的栈帧，区分<strong>局部变量（存放于当前执行环境中的变量）、全局变量（存放于全局执行环境中的变量）</strong>；</p></li><li><p>JavaScript 在此基础上定义了 <strong>作用域链（scope chain）</strong>的概念，定义为用于<strong>保证对执行环境有权访问的所有变量和函数的有序访问</strong>。可以将它理解为 JavaScript 解释器搜索标识符的字典；</p><blockquote><p>每当程序进入一个新执行环境中，解释器会创建一个新的变量对象（前面的规则），而这个对象就位于作用域链的最前端。<strong>因此作用域链的前端，始终都是当前执行的代码所在环境的变量对象</strong>。以函数环境为例，<code>arguments</code> 对象就是最开始的变量对象。</p><p><strong>作用域链越向后，变量对象越靠环境外层。因此全局执行环境的变量对象始终都是作用域链中的最后一个对象。</strong></p><p><strong>这样的链形结构，以及排布顺序，决定了局部变量、全局变量的优先级（和 C 一样）</strong>。</p></blockquote></li><li><p>除了函数，<code>with</code> 语句、<code>try-catch</code> 语句均拥有一个独立的执行环境（或者说一个独立的变量对象），这点和 C 的作用域也相同；</p></li><li>⚠ 和其他语言有差别的是，<strong>JavaScript 没有块级作用域</strong>。也就是说，<strong>除了函数、<code>with</code>、<code>try-catch</code> 块以外的、由花括号封闭的代码块，没有独立的执行环境（或者说独立的变量对象）</strong>，这点和 C 的作用域不同！</li></ul><h3 id="3-5-垃圾回收机制（GC）"><a href="#3-5-垃圾回收机制（GC）" class="headerlink" title="3.5 垃圾回收机制（GC）"></a>3.5 垃圾回收机制（GC）</h3><p>和 Python、Java 一样，JavaScript 具有自动垃圾回收机制，无需像 C / C++ 一样手动回收分配的空间。</p><p><strong>几乎所有自动 GC 都遵循一个理念：按照某个策略<u>预定的时间</u>（定时策略），释放<u>不再继续使用的</u>（标记策略）<u>引用类型变量</u>所占用的空间</strong>；</p><p>所以，这个 GC 机制中有两个需要决定的策略，我们介绍一下常见的策略类型（以下回收的变量都指的是<strong>引用类型</strong>，不再赘述）。</p><h4 id="3-5-1-标记策略"><a href="#3-5-1-标记策略" class="headerlink" title="3.5.1 标记策略"></a>3.5.1 标记策略</h4><p>JavaScript 中有两种常用的标记策略，分别是：<strong>标记清除（mark-and-sweep）、引用计数（reference counting）</strong>；</p><p>所谓标记清除就是：</p><ul><li>当变量在该环境内的时候，标记的是 <strong>进入环境</strong>；</li><li>当变量离开定义它的环境后，标记的是 <strong>离开环境</strong>；</li><li>当定时策略指定的检查时间到的时候，<strong>仅释放所有离开环境的变量的空间</strong>；</li></ul><p>所谓引用计数就是：</p><ul><li>跟踪记录每个变量被引用的次数。当该引用被赋予一个变量名后，该空间的数据引用计数 + 1；反之，如果该变量名改赋其他值，或被显式 delete 时，引用计数 - 1；</li><li>当定时策略指定的检查时间到的时候，<strong>仅释放所有引用计数为 0 的变量的空间</strong>；</li></ul><p>但是，引用计数策略有个严重问题：<strong>循环引用</strong>。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testCirRef</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    obj1.<span class="property">attr1</span> = obj2;</span><br><span class="line">    obj2.<span class="property">attr2</span> = obj1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果采用引用技术方法作为标记策略，那么退出函数体后，<code>obj1</code> 、<code>obj2</code> 的引用计数永不为 0；而且最有趣的问题是，JavaScript 的 DOM、BOM 的对象是使用 C++ 的 COM（Component Object Model，组件对象模型）实现的，它的回收是内置采用引用计数策略的。<strong>这就意味着使用 DOM / BOM 对象时，不可避免地可能产生循环引用</strong>。例如下面使用 DOM 的代码（后面介绍）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;some_element&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">myObject.<span class="property">element</span> = element;</span><br><span class="line">element.<span class="property">someObject</span> = myObject;</span><br></pre></td></tr></table></figure><p>所以书写时要注意循环引用的情况并且在不需要使用的时候及时解开 DOM 对象 和 JavaScript 原生 Object 之间的连接（想象成要像 C 一样手动释放）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.<span class="property">element</span> = <span class="literal">null</span>;</span><br><span class="line">element.<span class="property">someObject</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注：发生循环引用不仅仅有以上的可能，更多可能以后遇到再讨论。</p></blockquote><hr><p>综上原因所述，<strong>标记清除 是 JavaScript 中最常用的 GC 标记策略</strong>（主流浏览器引擎也都是）；</p><p>而引用计数则存在于 COM 实现的对象中（例如 BOM、DOM 对象），在使用时注意检查循环引用的情况，并且及时手动解引用。</p><h4 id="3-5-2-定时策略"><a href="#3-5-2-定时策略" class="headerlink" title="3.5.2 定时策略"></a>3.5.2 定时策略</h4><p>定时策略非常好想，大家肯定都会想到：<strong>周期性回收</strong>就行；但如何确定回收周期非常讲究。</p><p>IE6 浏览器实现的 JavaScript 解释器曾经有个非常严重的性能问题，这就是定时策略没有设计好。他们是这么为 IE6 JavaScript 设计的：</p><blockquote><p>256 个变量、4096 和对象（包括元素），或者 64 KB 的字符串，达到上述任意一个临界值，GC 会被自动触发。</p></blockquote><p>这么设计有什么问题呢？考虑一个问题，假设一个大型 JavaScript 程序的运行时必须使用多于 256 个变量（或者其他超过临界值的条件），那么<strong>垃圾回收例程会被一直持续触发，严重影响性能</strong>。</p><p>后来，自 IE7 及以后的版本，微软将 IE JavaScript 引擎的 GC Routine 改成了：</p><blockquote><ul><li>各项<strong>初始</strong>临界值和以前一致；</li><li>如果垃圾收集例程回收的内存分配量低于15%，则变量、literal 和（或）array 元素的临界值就会<strong>加倍</strong>；</li><li>如果例程回收了85%的内存分配量，则将各种临界值<strong>重置回默认值</strong>；</li></ul></blockquote><p>这样的定时回收策略大大优化了 GC 机制性能。如今不同的 JavaScript 引擎有着不同的实现方式，但思路都大同小异。</p><h4 id="3-5-3-拓展：开发者如何节省内存"><a href="#3-5-3-拓展：开发者如何节省内存" class="headerlink" title="3.5.3 拓展：开发者如何节省内存"></a>3.5.3 拓展：开发者如何节省内存</h4><p>我们知道，抛开借助 COM 对象的循环引用问题，JavaScript 作为一个自动 GC 的语言，是无需开发者关心内存问题的。</p><p>但是，有一点和我们开发 C/C++ 桌面程序有些不一样的地方：<strong>开发者需要有意地节省可用内存</strong>。</p><p>因为，<strong>浏览器的可用内存数量通常要比分配给桌面应用程序的少</strong>。这样做的目的主要是出于安全方面的考虑，目的是防止运行JavaScript 的网页耗尽全部系统内存而导致系统崩溃。</p><p>因此，<strong>确保占用最少的内存可以让页面获得更好的性能</strong>。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。<strong>一旦数据不再有用，最好通过将其值设置为 <code>null</code> 来释放其引用</strong>——这个做法叫做<strong>解除引用（dereferencing）</strong>；</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAction</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> localAction = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    localAction.<span class="property">name</span> = name;</span><br><span class="line">    <span class="keyword">return</span> localAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalAction = <span class="title function_">createAction</span>(<span class="string">&quot;Open Action&quot;</span>);</span><br><span class="line"><span class="comment">/* Do something... */</span></span><br><span class="line"><span class="comment">/* At the end of the block: */</span></span><br><span class="line">globalAction = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>提示：这样做虽然不会立即回收该内存，但能够起到尽早回收的作用，在一定程度上节省了运行时内存。</p></blockquote><h2 id="Chapter-4-内置的引用类型"><a href="#Chapter-4-内置的引用类型" class="headerlink" title="Chapter 4. 内置的引用类型"></a>Chapter 4. 内置的引用类型</h2><p>我们知道，JavaScript 的引用类型，或者说所有原生（naive）类型的父类都是 <code>Object</code>。你可能会想到 Python 中的 <code>Object</code> 终极父类，但实际上，这种说法<strong>不准确</strong>。</p><p>因为 JavaScript 不具备传统的面向对象语言所支持的类和接口等基本结构，通俗来说，<strong>它不支持定义类</strong>，所以不存在 “类” 的说法（<strong>它的超集语言 <code>TypeScript</code> 支持，也很有用</strong>）。</p><p>但矛盾的是，JavaScript 又是个面向对象的语言，所以<strong>你只能使用内置的基本类型、引用类型，并将它们实例化使用</strong>，所以又称<strong>对象定义</strong>。</p><p>像我们之前使用到的引用类型 <code>Object</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>就是在堆中创建了 <code>Object</code> 引用类型的新的<strong>实例</strong>。<code>Object()</code> 就是 <code>Object</code> 引用类型的构造函数。</p><p>到这里，我们可以这么理解 JavaScript 的引用类型：JavaScript 先集成了几个内置的引用类型，然后将它们都写成 C 中的 <code>final</code> 类，不允许定义新类或者继承，只能使用它们。</p><p><strong>所以，JavaScript 内置的引用类型有哪些呢？一共有 7 个方面。</strong></p><h3 id="4-1-Object-引用类型"><a href="#4-1-Object-引用类型" class="headerlink" title="4.1 Object 引用类型"></a>4.1 Object 引用类型</h3><h4 id="4-1-1-实例创建"><a href="#4-1-1-实例创建" class="headerlink" title="4.1.1 实例创建"></a>4.1.1 实例创建</h4><p>有两种创建 <code>Object</code> 引用类型的方法，一种是 <code>new</code> 构造函数创建，另一种是<strong>对象直接量</strong>创建。</p><p>前者的机制我们之前已经解释了无数遍。后者就像 C / C++ 中定义常量一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，如果你愿意的话，其键名加上引号也是<strong>等效</strong>的。</p><p>⚠ <strong>使用对象直接量创建对象时，不会执行对象的构造函数。</strong></p><p>不仅如此，<strong>在传递属性较多、复用次数较少的 <code>Object</code> 对象作函数参数时</strong>，对象直接量更加高效、代码可读性更强：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">testFunc</span>(&#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-1-2-实例访问"><a href="#4-1-2-实例访问" class="headerlink" title="4.1.2 实例访问"></a>4.1.2 实例访问</h4><p><code>Object</code> 引用类型的实例访问也有两种方法，一种是很熟悉的 <strong>点访问法（<code>obj.attr</code>）</strong>，另一种是 <strong>方括号访问法</strong>（<code>obj[&quot;attr&quot;]</code>），但是，除非不得已（例如<strong>属性名中含有空格，无法使用点访问法</strong>），都应该使用点访问法。</p><h3 id="4-2-Array-引用类型"><a href="#4-2-Array-引用类型" class="headerlink" title="4.2 Array 引用类型"></a>4.2 Array 引用类型</h3><p>除了 <code>Object</code>，ECMAScript 最常用的类型估计就是 <code>Array</code> 引用类型。它具有以下特性：</p><ul><li>数组<strong>每一项可以保存任意类型</strong>（强类型语言根本看不到）；</li><li>数组始终有序（自动排序）；</li><li>数组大小自动动态调整。当然，也允许创建时指定初始大小；</li></ul><h4 id="4-2-1-实例创建"><a href="#4-2-1-实例创建" class="headerlink" title="4.2.1 实例创建"></a>4.2.1 实例创建</h4><ul><li><p>默认构造函数：<code>var a = new Array();</code></p></li><li><p>指定初始大小（<code>length</code>）的构造函数：<code>var a = new Array(20);</code></p></li><li><p>指定数组项的构造函数：<code>var a = new Array(&quot;Alex&quot;, &quot;Ben&quot;, &quot;Cindy&quot;);</code></p><blockquote><p>于是我们发现<strong>没法直接</strong>指定只包含一个数字的数组；</p></blockquote></li><li><p><strong>数组 literal</strong>：<code>var a = [&quot;Alex&quot;, &quot;Ben&quot;, &quot;Cindy&quot;];</code></p><blockquote><p>空数组的话 <code>var a = [];</code></p></blockquote></li></ul><h4 id="4-2-2-实例访问"><a href="#4-2-2-实例访问" class="headerlink" title="4.2.2 实例访问"></a>4.2.2 实例访问</h4><p>和 C++ 等其他语言一样。直接 <code>arr[N]</code>；</p><p><strong>数组越界访问不会报错，返回 <code>undefined</code></strong>；</p><p>但 JavaScript 数组有个非常奇妙的特性：<strong><code>length</code> 属性可以修改</strong>。这意味着，直接通过修改 <code>length</code> 就能改变数组大小，进而完成新增、移除末尾项的功能。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alist = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;coconut&quot;</span>];</span><br><span class="line">alist.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(alist[<span class="number">2</span>]);    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>如果越界赋予值，那么相当于增长数组</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alist = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>];</span><br><span class="line">alist[alist.<span class="property">length</span>] = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">alist[alist.<span class="property">length</span>] = <span class="string">&quot;d&quot;</span>;</span><br><span class="line">alist[alist.<span class="property">length</span> + <span class="number">1</span>] = <span class="string">&quot;e&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(alist);    <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, undefined, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 数组最长 4,294,967,295 个项，更大的范围会抛出错误</strong>。</p><h4 id="4-2-3-实例方法"><a href="#4-2-3-实例方法" class="headerlink" title="4.2.3 实例方法"></a>4.2.3 实例方法</h4><ul><li><p>检查变量是否为数组引用类型：<code>Array.isArray()</code>；</p><blockquote><p>为什么要有这个方法？<code>instanceof Array</code> 不行吗？</p><p>答案是<strong>不行</strong>。考虑一种情况，最终 JavaScript 是要放在网页上的，网页上可能存在很多的框架，那么就会有多个全局执行环境，进而<strong>存在多个不同版本的 <code>Array</code> 构造函数</strong>。</p><p>但由于 JavaScript 没有重载，所以在一个环境下只有一种构造函数，因此<strong>当你从一个框架向另一个框架传入数组时，两个框架的原生数组定义不同，因此无法使用 <code>instanceof</code> 判断</strong>。</p></blockquote></li><li><p>类型转换方法（继承自 <code>Object</code>）：</p><ul><li><code>Array.toString()</code>：返回由调用数组每个元素的 <code>toString()</code> 返回的字符串组成、由<u>逗号</u>分割的字符串；</li><li><code>Array.valueOf()</code>：<strong>返回自身的<u>引用</u></strong>；</li><li><code>Array.toLocaleString()</code>：返回由调用数组每个值的 <code>toLocaleString()</code> 返回的字符串组成、由<u>逗号</u>分割的字符串；</li><li><code>Array.join(delim)</code>：和 <code>toString()</code> 功能相近，只是可以自定义分隔符 <code>delim</code>；</li></ul><blockquote><p>注：以上转字符串的方法的返回值，如果元素是 <code>null</code>、<code>undefined</code>，则其位置上是空字符串。</p></blockquote></li><li><p><strong>容器方法</strong>：</p><ul><li><p><code>push()</code>、<code>pop()</code>：<code>FIFO</code> 栈方法；</p></li><li><p><code>push()</code>（作为 <code>enQueue</code>）、<code>shift()</code>（<code>deQueue</code>）：<code>LIFO</code> 队列方法；</p><blockquote><p>还提供了 <code>unshift()</code> 方法，作为 <code>shift()</code> 的逆方法（类似 <code>prepend</code>）；</p></blockquote></li></ul></li><li><p>查找方法：</p><ul><li><p><code>find([func]/[elem])</code>：<strong>查找返回的是元素的引用 / 找不到返回 <code>undefined</code></strong>；</p></li><li><p><code>indexOf(elem[, start])</code>：第二参数可定制<strong>从 <code>start</code> 开始寻找</strong>，找不到返回 -1；</p></li><li><p><code>lastIndexOf(elem[, start])</code>；</p></li></ul></li><li><p>排序：<code>sort([func])</code>、<code>reverse()</code>；</p><blockquote><p>其中 <code>sort()</code> 方法默认<strong>升序</strong>，排序依据是<strong>每个元素的 <code>toString</code> 返回值</strong>。</p><p>由于字符串在比较数字方面等等的不利性，因此允许传入自定义比较函数。自定义比较函数要求：</p><ul><li>函数只会被这样调用：<code>intVar = func(element1, element2)</code>，所以要求处理两个参数、返回整型；</li><li><code>element1</code> 如果需要排在 <code>element2</code> 的<strong>前面</strong>，那么返回<strong>负数</strong>；如果要在后面，返回<strong>正数</strong>；如果二者排序依据相同，返回 0；</li></ul><p>例如这个函数是按照<strong>数值比较</strong>的<strong>降序</strong>比较函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">comp</span>(<span class="params">v1, v2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> v2 - v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为对于 Number，这个函数显然没问题。对于其他类型，减法运算会调用 <code>valueOf()</code> 函数。所以它能对 <code>valueOf()</code> 返回 Number 类型的参数进行排序。</p></blockquote></li><li><p>操作方法：</p><ul><li><p><code>Array.concat(other)</code>：拼接数组，<code>other</code> 可以是其他任何可迭代的类型，并且个数随意，包括基本类型；重要的是，<strong>返回的数组是新的对象——意味着不加参数就是 deep copy</strong>；</p></li><li><p><code>Array.slice(start, [stop])</code>：数组切片，不包括 <code>stop</code>（不传第二参数则默认 <code>Array.length</code>）；</p><blockquote><p>参数允许为负数，其含义与 Python 的相同，都是倒计数。</p></blockquote></li><li><p><code>Array.splice(start, length[, replaced])</code>：<strong>数组选块替换</strong>；</p><ul><li>删除选中元素：<code>Array.splice(i, j)</code> 表示删除索引从 <code>i</code> 开始的 <code>j</code> 个元素；</li><li>在指定位置插入元素：<code>Array.splice(i, 0, alist)</code> 表示从第 <code>i</code> 索引插入一个或多个可迭代对象 <code>alist</code>；</li><li>删除选中元素，同时在删除位置插入指定元素：<code>Array.splice(i, j, alist)</code> 表示从第 <code>i</code> 索引开始删除 <code>j</code> 个元素，并在该位置插入一个或多个可迭代对象 <code>alist</code>；</li></ul></li></ul><blockquote><p><strong>值得注意的是，操作方法 <code>concat</code>、<code>slice</code> 都会创建数组新的对象，而 <code>splice</code> 则会在原数组上修改。这意味着，如果你想做 deep copy，请不要使用 <code>splice</code></strong>；</p></blockquote></li><li><p><strong>迭代方法</strong>：</p><blockquote><p><strong>所有迭代方法其中一个参数都是 <code>mapFunc</code>，其要求的签名是：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapFunc</span>(<span class="params">curElement, curIdx, selfArr</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><code>Array.forEach(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。没有返回值；</li><li><code>Array.map(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。返回由 <code>mapFunc</code> 返回值组成的数组；</li><li><code>Array.filter(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。返回由 <code>mapFunc</code> 返回 <code>true</code> 的项组成的数组；</li><li><code>Array.every(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。如果该方法对数组每一项都返回 <code>true</code>，那么返回 <code>true</code>；</li><li><code>Array.some(mapFunc)</code>：对数组的<strong>每一项都执行 <code>mapFunc</code></strong>。</li></ul></li><li><p>归并方法（好像用的不多）：遍历数组的所有项，然后构建一个最终返回的值；</p><blockquote><p><strong>所有归并方法其中一个参数都是 <code>mapFunc</code>，其要求的签名是：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapFunc</span>(<span class="params">prev, cur, curIdx, selfArr</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><code>Array.reduce(mapFunc)</code>：从数组的左边向右边遍历，从数组第二项开始执行 <code>mapFunc</code>，返回值传给下一个元素调用 <code>mapFunc</code> 的第一参数，最后返回最终运算值；</p><blockquote><p>对空数组使用会报错；对长度为 1 的数组总是返回该元素的值；</p></blockquote></li><li><p><code>Array.reduceRight(mapFunc)</code>：与 <code>Array.reduce</code> 作用相同，不过从右向左遍历；</p></li></ul></li></ul><h3 id="4-3-Date-引用类型"><a href="#4-3-Date-引用类型" class="headerlink" title="4.3 Date 引用类型"></a>4.3 Date 引用类型</h3><p>首先熟悉 Java 的同学有福了，因为 ECMAScript 的 <code>Date</code> 类型基于早期 <code>java.util.Date</code> 类型构建，使用方法基本相同。</p><h4 id="4-3-1-实例创建"><a href="#4-3-1-实例创建" class="headerlink" title="4.3.1 实例创建"></a>4.3.1 实例创建</h4><p>默认构造函数即可：<code>var now = new Date();</code></p><p>默认构造函数创建的新对象<strong>自动获得当前日期和时间</strong>；</p><ul><li><p>另外可以传入<u>与 <code>UTC</code> 时间相距的毫秒数</u>来构造时间：<code>new Date(int)</code>；</p></li><li><p>也可以向构造函数传入一个字符串，效果和运行 <code>new Date(Date.parse(str))</code> 一样（下面介绍）；</p></li></ul><h4 id="4-3-2-日期解析"><a href="#4-3-2-日期解析" class="headerlink" title="4.3.2 日期解析"></a>4.3.2 日期解析</h4><p><strong>静态方法 <code>Date.parse(rawString)</code></strong> 接受一个<strong>特定日期格式</strong>的字符串，返回该日期<u>与 <code>UTC</code> 时间相距的毫秒数</u>：</p><ul><li><code>mm/dd/yyyy</code>（e.g., <code>6/13/2004</code>）；</li><li><code>English-Month day,year</code>（e.g., <code>January 12, 2023</code>）；</li><li><code>English-Week English-Month day year HH:mm:ss Timezone</code>（e.g., <code>Wed Jan 24 2024 00:00:00 GMT-0700</code>）;</li><li><strong>ISO-8601</strong> 标准拓展格式：<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>（e.g., <code>2024-01-25T14:54:00</code>）</li></ul><p>⚠ 如果字符串不是以上格式（即无法转为日期），则返回 <code>NaN</code>；</p><p>⚠ 如果字符串满足格式，但<strong>不是有效日期</strong>，那么不同解释器有不同行为。有的解释器转为当前日期，有的转为 “最近” 的正确日期；</p><blockquote><p>此外，还有更加方便的 <strong>静态方法 <code>Date.UTC([params])</code></strong>，功能与 <code>Date.parse</code> 相近；</p><p>从第一参数向后，是数值的：年、月、日、时（24）、分、秒，默认均为 0；</p></blockquote><p>此外还有静态方法 <code>Date.now()</code>，和默认构造函数的作用相近。</p><hr><p>为了日期信息提取的方便，ECMAScript 定义了一堆<strong>实例方法</strong>，它们的格式如下：</p><p><code>[set/get][UTC][Time/FullYear/Month/Date/Day/Hours/Minutes/Seconds/Milliseconds]</code></p><p>例如：<code>d.setUTCHours()</code>、<code>d.getDay()</code> 等等。其中 <code>getTime()</code> 和 <code>valueOf()</code> 返回的值一致。</p><blockquote><p><strong>额外记一个函数：<code>getTimezoneOffset()</code>，表示本地时间与 <code>UTC</code> 时间时区的时差分钟数</strong>。</p></blockquote><h4 id="4-3-3-日期格式化"><a href="#4-3-3-日期格式化" class="headerlink" title="4.3.3 日期格式化"></a>4.3.3 日期格式化</h4><ul><li><p>字符串转换函数（继承于 <code>Object</code>）：<code>toString()</code>、<code>toLocaleString()</code>。<u>事实上，这两个函数一般仅作为调试使用</u>；</p></li><li><p>运算类型转换（继承自 <code>Object</code>）：<code>valueOf() -&gt; int</code>，返回距 <code>UTC</code> 毫秒数。<strong>非常有用！可以直接用比较运算符比较日期</strong>； </p></li><li><p><code>Date.toDateString()</code>：转 <code>datetime</code>（e.g., <code>Wen Jan 24 2024</code>）；</p></li><li><p><code>Date.toTimeString()</code>：转 <code>time</code>（e.g., <code>15:29:20 GMT+0800 (China Standard Time)</code>）</p></li><li><p><code>Date.toLocaleDateString</code>、<code>Date.toLocaleTimeString()</code>：上面两种函数锁定当前时区的版本。</p><blockquote><p>前者输出形如 <code>1/24/2024</code>，后者输出形如 <code>3:29:20 PM</code>；</p></blockquote></li><li><p><code>Date.toUTCString()</code>：完整 <code>UTC</code> 格式字符串（e.g., <code>Wed, 24 Jan 2024 07:29:20 GMT</code>）；</p></li></ul><h3 id="4-4-RegExp-引用类型"><a href="#4-4-RegExp-引用类型" class="headerlink" title="4.4 RegExp 引用类型"></a>4.4 RegExp 引用类型</h3><p>这是一个比较强大的引用类型，尽管 ECMAScript 实现的正则表达式没有 <code>Perl</code> 语言的高级（<strong>例如 unicode 支持、并集和交集类、单行、注释、条件匹配等等</strong>），但也能解决绝大多数问题。</p><h4 id="4-4-1-实例创建"><a href="#4-4-1-实例创建" class="headerlink" title="4.4.1 实例创建"></a>4.4.1 实例创建</h4><p>ECMAScript 中，不需要使用引号即可创建正则表达式（直接量 literal）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expr = <span class="regexp">/&lt;pattern&gt;/</span>&lt;flags&gt;;</span><br></pre></td></tr></table></figure><p>也可以从字符串创建（如果是放在字符串里，那么转义符自身也要转义了😢，例如 <code>\d</code> -&gt; <code>&quot;\\d&quot;</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expr = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;&lt;pattern&gt;&quot;</span>, <span class="string">&quot;flags&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>pattern</code> 就是我们最常用的正则表达式模式字符串。</p><p><u>但是以前（ECMAScript 5 之前），正则表达式直接量和 <code>new</code> 初始化的内存机制略有不同。</u></p><p>这是因为，<strong><u>正则表达式直接量</u>相当于 C++ 中的字符串常量，也相当于 Java 中位于字符串池中的常量字符串</strong>，每次引用这个常量都是一个内存地址中的对象；而 <code>new</code> 出来的对象就是真实独立存在堆内存中的对象了。</p><p><u>而在 ECMAScript 5 之后，正则表达式 literal 也必须和直接使用构造函数一样创建新的实例。</u></p><p><code>flags</code> 包含以下几种（仅列举几种常用的，不常用的 JavaScript 也不一定支持）：</p><ul><li><p><code>g</code>：global，表示全局模式，<strong>不会在找到第一个匹配项时停止</strong>（默认会停止，即<u>下次查找从头开始</u>）；</p></li><li><p><code>i</code>：case insensitive，大小写不敏感；</p></li><li><p><code>m</code>：multiline，多行匹配，<code>^</code>、<code>$</code> 会选中一行的开头和结尾，而不再是整个字符串的开头和结尾；</p><blockquote><p>例如字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helloJava</span><br><span class="line">123</span><br><span class="line">HelloPython12</span><br><span class="line">456</span><br></pre></td></tr></table></figure><p>如果使用 <code>/^\d+$/g</code> 则只会匹配到 <code>123</code>，而使用 <code>/^\d+$/gm</code> 则会匹配到 <code>123</code> 和 <code>456</code>；</p></blockquote></li><li><p><code>s</code>：即 <code>.</code> 限定符加入包含换行符 <code>\n</code>，具体表现为使用 <code>.</code> 代表的内容可以不在同一行；</p></li></ul><h4 id="4-4-2-常用实例属性"><a href="#4-4-2-常用实例属性" class="headerlink" title="4.4.2 常用实例属性"></a>4.4.2 常用实例属性</h4><ul><li><p><code>RegExp.global</code>：Boolean，是否设置了 <code>g</code> flag；</p></li><li><p><code>RegExp.ignoreCase</code>：Boolean，是否设置 <code>i</code> flag；</p></li><li><p><code>RegExp.multiline</code>：Boolean，是否设置 <code>m</code> flag；</p></li><li><p><code>RegExp.lastIndex</code>：Number，表示当前正则对象<u><strong>下一次匹配</strong></u>的位置；</p><blockquote><p>注：有这个属性的原因是，在使用 global 模式时，正则对象查找 pattern 会在第一次匹配到的时候不会停止，所以需要为下次匹配继续保留这个状态。</p></blockquote></li><li><p><code>RegExp.source</code>：String，表示当前正则表达式的 <strong><code>pattern</code> 字符串表示</strong>；</p></li></ul><h4 id="4-4-3-常用实例方法"><a href="#4-4-3-常用实例方法" class="headerlink" title="4.4.3 常用实例方法"></a>4.4.3 常用实例方法</h4><p><strong>Ⅰ. 正则式引用类型 匹配方法：<code>exec</code></strong></p><p><code>RegExp.exec(String) -&gt; Extended Array</code></p><p><code>RegExp</code> 的重要方法，也是指示正则匹配的方法。由于 JavaScript 不强调类型，所以返回的信息不像其他语言用类型包装（例如 Qt/C++ 中的 <code>QRegularExpressionMatch</code>、Python 中的 <code>re.Match</code>），只是使用一个数组来存放信息。<u><strong>不过这个数组多了 <code>index</code>、<code>input</code> 两个属性</strong>，并且其他数组项（键 <code>k ∈ [0, N)</code>）存放的是第 k 组</u>；</p><p>需要注意以下几点：</p><ul><li><p><strong>和其他所有正则框架一样，第 0 组是匹配到的字符串的全文</strong>；</p></li><li><p>返回值数组的 <code>index</code> 属性表示 <strong>当前匹配到的字符串在原字符串中的起始位置</strong>；</p></li><li><p>返回值数组的 <code>input</code> 属性表示输入的字符串；</p></li><li><p>即便设置 <code>g</code> flag，调用 <code>exec</code> 仍然每次仅返回一个匹配结果。不过由于设置了 <code>g</code> flag，每次调用 <code>exec</code> 时，<code>index</code> 就被赋予 <code>lastIndex</code> 的值向后查找；</p></li><li><strong>由于 <code>lastIndex</code> 存放在 <code>RegExp</code> 对象中，所以即使 <code>exec</code> 的传入参数换成另一个字符串，匹配仍然会从上一次 <code>lastIndex</code> 处开始，在编程时需要注意</strong>；</li><li>当 <code>exec</code> 向后查找结束（global），或者没有匹配的部分时，返回 <code>null</code>；</li></ul><p>举个例子，想要匹配文字间 Latex 语法，找到所有 $$$$ 隔开的数学行公式，那么使用如下正则式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 确切地说，应该使用 (?&lt;!\$)\$\$(?!\$)(.+?)(?&lt;!\$)\$\$(?!\$)， */</span></span><br><span class="line"><span class="comment">/* 因为 \1 无法指代断言。不过这里只是随便演示一下 */</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?&lt;!\$)(\$\$)(?!\$)(.+?)\1/gm</span>;</span><br></pre></td></tr></table></figure><p>如果这是要查找的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;$jfj4$$3$0$$\nd34of$$deo$$&quot;</span>;</span><br></pre></td></tr></table></figure><p>那么输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; reg.<span class="title function_">exec</span>(str);    <span class="comment">// 第一次查找</span></span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;$$3$0$$&#x27;</span>,        <span class="comment">// array[0] =&gt; 第 0 组，匹配到的全文</span></span><br><span class="line">  <span class="string">&#x27;$$&#x27;</span>,                <span class="comment">// array[1] =&gt; 第一组，也就是 (\$\$) 选中的组</span></span><br><span class="line">  <span class="string">&#x27;3$0&#x27;</span>,            <span class="comment">// array[2] =&gt; 第二组，也就是 (.+?) 选中的组</span></span><br><span class="line">  <span class="attr">index</span>: <span class="number">5</span>,            <span class="comment">// array.index =&gt; 第 0 组的开始位置索引</span></span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;$jfj4$$3$0$$\nd34of$$deo$$&#x27;</span>,</span><br><span class="line">  <span class="attr">groups</span>: <span class="literal">undefined</span></span><br><span class="line">]</span><br><span class="line">&gt; reg.<span class="title function_">exec</span>(str);    <span class="comment">// 第二次查找，从上一次的 lastIndex (=12) 开始</span></span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;$$deo$$&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;$$&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;deo&#x27;</span>,</span><br><span class="line">  <span class="attr">index</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;$jfj4$$3$0$$\nd34of$$deo$$&#x27;</span>,</span><br><span class="line">  <span class="attr">groups</span>: <span class="literal">undefined</span></span><br><span class="line">]</span><br><span class="line">&gt; reg.<span class="title function_">exec</span>(str);    <span class="comment">// 第三次查找，从上一次的 lastIndex (=25) 开始</span></span><br><span class="line"><span class="literal">null</span>                <span class="comment">// 无法找到更多的匹配内容，返回 null，并且将 lastIndex 设为 0</span></span><br></pre></td></tr></table></figure><p><strong>Ⅱ. 正则式引用类型 检查方法：<code>test</code></strong></p><p><code>RegExp.test(String) -&gt; Boolean</code></p><p>从 <code>lastIndex</code> 开始检查下一个是否存在匹配的字符串，会改变 <code>lastIndex</code>（等同于 <code>Boolean(RegExp.exec)</code>）；</p><p><strong>Ⅳ. 正则式引用类型 类型转换方法：<code>toString / toLocaleString</code></strong> 直接返回<strong>构造直接量（pattern + flag）</strong>；</p><p><strong>Ⅴ. 正则式引用类型 构造函数属性</strong></p><p>JavaScript 中的 “构造函数属性” 类似于 <strong>C++ 中的静态数据成员</strong>，也类似于 <strong>Python 中的类属性</strong>；这些属性同时影响整个类的实例。</p><blockquote><p>⚠ 警告：Opera 浏览器的 JS 引擎没有实现大部分这些属性；</p></blockquote><ul><li><code>input</code>：所有正则实例中，最近一次传入的字符串；</li><li><code>lastMatch</code>：所有正则实例中，最近一次匹配的属性；</li><li><code>lastParen</code>：所有正则实例中，最近一次匹配的捕获分组；</li><li><code>leftContext / rightContext</code>：<code>lastParen</code> 之前 / 之后的文本；</li><li><code>multiline</code>：<strong>是否所有正则实例都是多行模式</strong>；</li></ul><h3 id="4-5-Function-引用类型"><a href="#4-5-Function-引用类型" class="headerlink" title="4.5 Function 引用类型"></a>4.5 Function 引用类型</h3><h4 id="4-5-1-Function-引用类型的实质"><a href="#4-5-1-Function-引用类型的实质" class="headerlink" title="4.5.1 Function 引用类型的实质"></a>4.5.1 Function 引用类型的实质</h4><p>我们已经知道，JavaScript 函数就是一种特殊的对象（Object），因此每个函数都是 <code>Function</code> 类型的实例，并且具有一些共有的属性和方法。</p><p>例如以下两种定义方式<strong>几乎相同</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* method 1 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* method 2: Function 类的构造函数 function() */</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么说 “几乎”？因为它们的<strong>唯一区别</strong>在于解释器是否进行<strong>函数声明提升（function declaration hoisting）</strong>的过程。</p><blockquote><p>在 C 里面我们知道，如果你在 <code>*.c</code> 中定义了函数，那么不能在函数名出现前使用它，除非在此前声明。</p><p>而在 JavaScript 中不存在手动声明的说法，是由解释器识别并将函数定义提升至源代码的最前面。如果使用第二种方法定义函数，那么解释器不会对这个赋值操作进行函数声明提升。因此下面两种操作<strong>只有第一种不会报错</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* method 1 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* method 2: wrong */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>我们还需要了解的重要一点，<strong>函数是对象，函数名是指针</strong>。所以在 JavaScript 中，开发者唯一能接触到的指针只有函数指针（即函数名）。</p><p>而存放函数指针的变量和其他变量并没有什么不同，也能随意赋值（<strong>包括函数传参</strong>），这就能解释为什么 JavaScript 中没有重载。</p><h4 id="4-5-2-Function-引用类型的常用内部属性"><a href="#4-5-2-Function-引用类型的常用内部属性" class="headerlink" title="4.5.2 Function 引用类型的常用内部属性"></a>4.5.2 Function 引用类型的常用内部属性</h4><blockquote><p>内部对象属性是 JavaScript 引擎自行构建的；</p></blockquote><ul><li><p><code>Function.arguments.callee</code>：使用场景，解耦合的递归函数（为什么需要解耦合？因为 JavaScript 的函数可以随意赋给另一个变量，它和 C++ 的函数指针一样，运行时指向同一内存地址）；</p></li><li><p><code>Function.caller</code>：当前函数的当前调用方，如果上次在全局作用域中调用，则为 <code>null</code>；</p></li><li><p><code>Function.this</code>：<strong>与 OOP 无关，是函数执行的<u>环境对象</u></strong>（表示作用域的对象，也是 <code>Object</code>）；</p><blockquote><p>例如网页全局作用域中调用函数时，<code>this</code> 就是 <code>window</code> 对象；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">//&quot;red&quot;</span></span><br><span class="line">o.<span class="property">sayColor</span> = sayColor;</span><br><span class="line"><span class="comment">/* 环境作用域中最近有啥，this 就选择啥 */</span></span><br><span class="line">o.<span class="title function_">sayColor</span>(); <span class="comment">//&quot;blue&quot;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>Function.length</code>：函数<strong>希望</strong>接收的参数个数；</p></li><li><p><code>Function.prototype</code>（<strong>不可枚举，不可被 <code>for-in</code> 找到</strong>）：讨论原型时详细介绍；4</p><blockquote><p>对 JavaScript 的<strong>所有引用类型</strong>而言，<strong>是保存引用类型所有实例方法的对象</strong>；</p></blockquote></li><li><p><code>Function.apply(&lt;envObj&gt;, [paramArr]) / Function.call(&lt;envObj&gt;, [param1, param2, ...])</code>：<strong>指定函数作用域对象来调用函数</strong>；</p></li><li><code>Function.bind(&lt;envObj&gt;) -&gt; Function</code>：<strong>无视当前环境，创建新的函数实例，并将其环境对象指定为 <code>&lt;envObj&gt;</code></strong>（相当于在 <code>&lt;envObj&gt;</code> 中定义了该函数）；</li></ul><h3 id="4-6-基本包装类型"><a href="#4-6-基本包装类型" class="headerlink" title="4.6 基本包装类型"></a>4.6 基本包装类型</h3><p>和 Java 类似，为了方便基本类型的操作，JavaScript 定义了<strong>内置基本类型的引用类型</strong>，共有 3 种：<code>Boolean</code>、<code>Number</code>、<code>String</code>；</p><p>它们不需要被显式创建，而是在我们使用基本类型时，如果对它们调用方法，解释器自动为我们进行如下步骤：</p><ol><li><p>创建该基本类型的实例；</p></li><li><p>调用该实例的指定方法；</p></li><li><p>销毁该实例；</p></li></ol><p>这能解释 2 个问题：</p><ul><li><p>为什么基本类型可以存在方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>因为等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>为什么为基本类型赋予属性时会立即消失：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">s1.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(s1.<span class="property">color</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p><strong>因为上一次创建的 <code>String</code> 对象已经被销毁了</strong>；</p></li></ul><p>下面是内置基本包装类型的常用方法（除了普通 <code>Object</code> 也有的）：</p><ul><li><p><code>Number.toFixed(Number)</code>；</p></li><li><p><code>Number.toExponential(Number)</code>；</p></li><li><p><code>Number.toPrecision()</code>：以上两种最方便的切换模式；</p></li><li><p><code>String.charAt() / charCodeAt()</code>；</p></li><li><p><code>String[&lt;idx&gt;]</code>；</p></li><li><p><code>String.concat(&lt;String&gt;)</code>：最好还是用 <code>+</code>；</p></li><li><p><code>String.slice(&lt;start&gt;, [stop]) / String.substr(&lt;start&gt;, [length]) / String.substring(&lt;start&gt;, [stop])</code>：字符串切片 ；</p><ul><li>注意，只有 <code>substr()</code> 第二参数指定的是长度；</li><li>当输入存在负值时，<code>slice</code> 与 python 的 <code>slice</code> 完全一致，start 和 stop 都是反向索引；</li><li>当输入存在负值时，<code>substr</code> 第一参数（start）与之前一致，而第二参数因为是长度，所以如果是负值则转为 0；</li><li>当输入存在负值时，<code>substring</code> <strong>不接受一切负参数</strong>，将负参数转为 0；</li></ul></li><li><p><code>String.indexOf(&lt;substr&gt;, [start]) / String.lastIndexOf(...)</code>：字符子串查找；</p></li><li><p><code>String.trim()</code>：删除字符串前后的所有空白字符，并创建实例副本；</p></li><li><p><code>String.to[Locale][Lower/Upper]Case()</code>：字符串大小写转换；</p></li><li><p><code>String.match(&lt;RegExp&gt;) -&gt; match array</code>：等同于 <code>RegExp.exec(&lt;String&gt;)</code>；</p></li><li><p><code>String.search(&lt;RegExp&gt;) -&gt; Number</code>： 查找第一次出现 pattern 的位置索引，若不存在则返回 -1；</p></li><li><p><code>String.split(&lt;char&gt; | &lt;RegExp&gt;)</code>：⚠⚠ <u>谨慎在此式使用正则表达式，因为在捕获组为空的时候，不同浏览器下行为不一致</u>；⚠⚠</p></li><li><p><code>String.replace(&lt;RegExp&gt;, &lt;newStr&gt;)</code>：字符串替换；</p><p>注意，这里的 <code>newStr</code> 有些特点，例如它允许特殊的字符串标识：</p><ol><li><code>$&amp;</code>：等同于 <code>RegExp.lastMatch</code>；</li><li><code>$&#39;</code>：等同于 <code>RegExp.leftContext</code>（反引号就是 <code>RegExp.rightContext</code>）；</li><li><code>$n/nn</code>：第 n 捕获组字符串（nn 表示两位数），如果没有该组，则表示空字符串；</li><li>$$$$：表示 <code>$</code> 字符本身；</li></ol></li><li><p><code>String.replace(&lt;RegExp&gt;, &lt;rFunc&gt;)</code>：自定义替换规则；</p><p>这里的 <code>rFunc</code> 要求传入参数的形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@brief</span> Inner replace function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>[in] match Matched string (group[0]).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>[in] pos The index of matched string in original string.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>[in] originalText Original string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rFunc</span>(<span class="params">match, pos, originalText</span>);</span><br></pre></td></tr></table></figure><p>举个例子，如果需要将 HTML 中所有特殊字符替换为转义字符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">htmlEscape</span>(<span class="params">text</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> text.<span class="title function_">replace</span>(</span><br><span class="line">        <span class="regexp">/[&lt;&gt;&quot;&amp;]/g</span>,</span><br><span class="line">        <span class="keyword">function</span>(<span class="params">match, pos, origin</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&amp;lt;&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;&gt;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&amp;gt;&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;&amp;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&amp;amp;&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;\&quot;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&amp;quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>String.localeCompare(&lt;str&gt;)</code>：比较两个字符串。顺序比较字符串中每个字符，排在字母表后面的会返回 1，前面会返回 -1。两字符串相同会返回 0；</p></li><li><p><code>String.fromCharCode(&lt;int params&gt;)</code>：从 unicode 构建字符串；</p></li></ul><p><u><strong>在此强烈不建议手动实例化基本包装类型，因为它们可能使 <code>instanceof</code>、<code>typeof</code> 等关键字失去作用</strong></u>。</p><h3 id="4-7-单体内置对象"><a href="#4-7-单体内置对象" class="headerlink" title="4.7 单体内置对象"></a>4.7 单体内置对象</h3><p>由 ECMAScript 实现提供的、<strong>不依赖于宿主环境的对象</strong>，这些对象在 ECMAScript 程序执行之前就已经存在了。</p><p>我们已经接触到的对象有：<code>Object</code>、<code>Array</code>、<code>String</code> 等等（没有真正的类型）；</p><p>这里介绍两个额外的单体内置对象：<code>Global</code>、<code>Math</code>；</p><h4 id="4-7-1-Global"><a href="#4-7-1-Global" class="headerlink" title="4.7.1 Global"></a>4.7.1 Global</h4><p>这个对象你在 JavaScript 中永远无法自己创建。不过可以找到它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种表达式在 JavaScript 中被称为函数表达式，后面介绍</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">global</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="variable language_">this</span>;&#125;();</span><br></pre></td></tr></table></figure><p>而且<strong>不论当前执行环境在哪里，不论你使用 <code>apply()</code>、<code>call()</code> 访问这个函数，其中的 <code>this</code> 都是 <code>Global</code> 对象</strong>；</p><p>而且，JavaScript 中实际上<strong>不存在全局变量和全局函数</strong>，它们<strong>都是 <code>Global</code> 对象的属性和方法</strong>。例如之前遇到的 <code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>、<code>parseFloat()</code>；</p><p><u>无论是 <code>Global</code> 属性还是方法，都不能对其进行赋值操作！</u></p><p><strong><code>Global</code> 方法</strong></p><p>此外，<code>Global</code> 中还有两类方法。一种是 URI 编解码。</p><ul><li><p>URI 编码方法：<code>encodeURI(&lt;str&gt;)</code>、<code>encodeURIComponent(&lt;str&gt;)</code> </p><blockquote><p>有效的 URI 中不能包含某些字符，例如空格；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">&quot;http://www.wrox.com/illegal value.htm#start&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;http://www.wrox.com/illegal%20value.htm#start&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">encodeURI</span>(uri));</span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure></blockquote></li><li><p>URI 解码方法：<code>decodeURI(&lt;str&gt;)</code>、<code>decodeURIComponent(&lt;str&gt;)</code></p></li></ul><p>以上方法可以将 URI 进行编码，以便发送给浏览器处理；</p><p>另一种是 <code>eval()</code> 方法，它<strong>提供了一个完整的 ECMAScipt 解释器</strong>，将参数中的字符串作为 JavaScript 代码直接执行；</p><p>不过有几个需要注意的点：</p><ul><li><code>eval()</code> 中创建的任何变量和函数都不会被提升（包括函数声明提升）；</li><li><code>eval()</code> 存在代码注入的安全问题；</li><li><strong>非严格模式下，<code>eval()</code> 函数内外共享变量和函数作用域</strong>，相当于在原位添加了字符串中的代码；</li></ul><p><strong><code>Global</code> 属性</strong></p><p>之前的 <code>undefined</code>、<code>NaN</code>、<code>Infinity</code> 等都是 <code>Global</code> 对象属性。就连<strong>所有原生引用类型的构造函数也都是 <code>Global</code> 对象的属性（不是方法）</strong>。此外，常见的错误对象（在错误处理一章介绍）也是 <code>Global</code> 对象。</p><p><img src="imgs/global.png"></p><h4 id="4-7-2-window-对象"><a href="#4-7-2-window-对象" class="headerlink" title="4.7.2 window 对象"></a>4.7.2 <code>window</code> 对象</h4><p>在 Web 浏览器的 ECMAScript 引擎中，会自动设置一个全局对象 <code>window</code>，它会自动包含所有 <code>Global</code> 对象的属性和方法（将 <code>Global</code> 对象作为 <code>window</code> 对象的一部分），<u><strong>并且是实时的</strong></u>。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayColor</span>(); <span class="comment">//&quot;red&quot;</span></span><br></pre></td></tr></table></figure><p><code>window</code> 对象在 ECMAScript BOM / DOM 中用的较多。</p><h4 id="4-7-3-Math-对象"><a href="#4-7-3-Math-对象" class="headerlink" title="4.7.3 Math 对象"></a>4.7.3 <code>Math</code> 对象</h4><p><strong><code>Math</code> 对象属性</strong></p><p>大多是常用的常量：<code>Math.E</code>、<code>Math.LN10</code>、<code>Math.LN2</code>、<code>Math.LOG2E</code>、<code>Math.LOG10E</code>、<code>Math.PI</code>、<code>Math.SQRT1_2</code>、<code>Math.SQRT2</code>……</p><p><strong><code>Math</code> 对象方法</strong></p><p>常见数学方法：<code>min(&lt;params&gt;)</code>（<strong>不接受数组，如果需要，请用前面提到的 <code>apply</code></strong>）、<code>max()</code>、<code>ceil()</code>、<code>floor()</code>、<code>round()</code>、<code>random()</code>（取值 <code>[0, 1]</code>）、<code>abs()</code>、<code>exp()</code>、<code>log()</code>、<code>pow(&lt;num&gt;, &lt;power&gt;)</code>、<code>sqrt()</code>、<code>acos()</code>、<code>cos()</code>……</p><h2 id="Chapter-5-OOP-in-JavaScript"><a href="#Chapter-5-OOP-in-JavaScript" class="headerlink" title="Chapter 5. OOP in JavaScript"></a>Chapter 5. OOP in JavaScript</h2><p>在 ECMAScript 中，对于对象的定义是：</p><p><u><strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong></u>。</p><p>对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把 ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。</p><blockquote><p>简而言之，JavaScript 中的对象就是一个类似散列表的结构。</p></blockquote><h3 id="5-1-对象的实际定义"><a href="#5-1-对象的实际定义" class="headerlink" title="5.1 对象的实际定义"></a>5.1 对象的实际定义</h3><p>之前几章中介绍的对象定义方法是无需声明，<u>加点或方括号</u>直接添加属性及方法，如下（构造函数创建）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">person.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line">person.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">person[<span class="string">&quot;G P A&quot;</span>] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">person.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还可以用这种方式（对象直接量创建）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果将所有的 key 全部换为标准的字符串形式，那么就是大名鼎鼎的 JSON（JavaScript Object Notation，JS 对象表示）；</p><p>其实，基本引用类型 <code>Object</code> 的属性都定义了解释器内部特性（attribute），它们：</p><ul><li>给 JavaScript 解释器使用，<strong>JavaScript 代码无法直接访问</strong>；</li><li>描述了 JavaScript 对象的属性的各种特征；</li></ul><blockquote><p>为了规范，将对象属性的 attribute 放在双方括号中表示。</p></blockquote><p>ECMAScript 对象的属性分为 2 种：<u><strong>数据属性、访问器属性</strong></u>。</p><h4 id="5-1-1-数据属性的-attribute"><a href="#5-1-1-数据属性的-attribute" class="headerlink" title="5.1.1 数据属性的 attribute"></a>5.1.1 数据属性的 attribute</h4><p><u>ECMAScript 的所有直接定义的对象属性都是 数据属性</u>。</p><ul><li><code>[[Configurable]]</code>：能否<u>通过 delete 删除属性</u>从而重新定义属性，能否<u>修改属性的特性</u>，或者能否把属性修<u>改为访问器属性</u>（默认为 <code>true</code>）；</li><li><p><code>[[Enumerable]]</code>：能否通过 <code>for-in</code> 循环返回属性。例如前面提到的 <code>Function.prototype</code>就是  <code>false</code>；</p></li><li><p><code>[[Writable]]</code>：表示能否修改属性的值；</p></li><li><code>[[Value]]</code>：<u>该属性的数据值存放处</u>，即读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置；</li></ul><p>可以通过 <code>Object.defineProperty(&lt;targetObj&gt;, &lt;propName&gt;, &lt;descriptor&gt;)</code> 修改。其中描述符对象 <code>descriptor</code> 必须具有属性 <code>configurable</code>、<code>enumerable</code>、<code>writable</code>、<code>value</code> 其中至少一个（默认全为 <code>false</code>），例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5-1-2-访问器属性的-attribute"><a href="#5-1-2-访问器属性的-attribute" class="headerlink" title="5.1.2 访问器属性的 attribute"></a>5.1.2 访问器属性的 attribute</h4><p>访问器属性针对 ECMAScript 对象的 <strong>属性自定义访问方法</strong>，自身不包含数据。常见作用是 <strong>动态获取属性、自定义属性访问权限和访问规则</strong>。</p><p><strong>完全可以理解为 Python 中的 <code>@getter</code>、<code>@setter</code></strong> 定义的实例属性；</p><ul><li><code>[[Configurable]]</code>：表示能否<u>通过 delete 删除属性</u>从而重新定义属性，能否<u>修改属性的特性</u>，或者能否把属性<u>修改为数据属性</u>（默认为 <code>true</code>）；</li><li><code>[[Enumerable]]</code>：表示能否通过 <code>for-in</code> 循环返回属性；</li><li><code>[[Get]]</code>：函数，读取属性时调用，返回值即为该属性值；</li><li><code>[[Set]]</code>：函数，写入属性时调用，它的行为会代替写入行为；</li></ul><p><strong>访问器属性不能被直接定义（普通定义属性的方法都是数据属性），只能使用 <code>Object.defineProperty()</code> 修改，类比数据属性的修改方法</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="attr">_year</span>: <span class="number">2004</span>,</span><br><span class="line">    <span class="attr">edition</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_year</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newValue</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_year</span> = newValue;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.<span class="property">year</span> = <span class="number">2005</span>;</span><br><span class="line"><span class="title function_">alert</span>(book.<span class="property">edition</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>如果在设置访问器属性时，未指定 <code>set</code>，那么意味着写入该属性时什么都不会做，对于 <code>get</code> 同理。</p><h4 id="5-1-3-设置属性的-attribute"><a href="#5-1-3-设置属性的-attribute" class="headerlink" title="5.1.3 设置属性的 attribute"></a>5.1.3 设置属性的 attribute</h4><p>除了上面介绍的 <code>Object.defineProperty()</code>，还可以同时对多个对象属性设置 attribute：</p><p><code>Object.defineProperties(&lt;targetObj&gt;, &lt;propObj&gt;)</code>；</p><p>其中，<code>propObj</code> 对象的格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    &lt;propertyName1&gt;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        &lt;attributeName11&gt;<span class="punctuation">:</span> &lt;entry11&gt;<span class="punctuation">,</span></span><br><span class="line">        &lt;attributeName12&gt;<span class="punctuation">:</span> &lt;entry12&gt;</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    &lt;propertyName2&gt;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        &lt;attributeName21&gt;<span class="punctuation">:</span> &lt;entry21&gt;<span class="punctuation">,</span></span><br><span class="line">        &lt;attributeName22&gt;<span class="punctuation">:</span> &lt;entry22&gt;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="5-1-4-读取属性的-attribute"><a href="#5-1-4-读取属性的-attribute" class="headerlink" title="5.1.4 读取属性的 attribute"></a>5.1.4 读取属性的 attribute</h4><p><code>Object.getOwnPropertyDescriptor(&lt;targetObj&gt;, &lt;propName&gt;)</code> 可以获得该属性的描述符，与设置相对应故不再赘述。</p><h3 id="5-2-创建对象的高级方法"><a href="#5-2-创建对象的高级方法" class="headerlink" title="5.2 创建对象的高级方法"></a>5.2 创建对象的高级方法</h3><p>我们发现，由于 JavaScript 没有真正的类型，只有对象。所以当我们想创建接口相同的对象时，<strong>如果使用上面的构造函数，或者对象直接量创建，那么免不了需要重复定义对象</strong>。这显然是不可取的。</p><p>于是，一代代人采用不同方法来创建对象，以提升代码复用性 和 可维护性。下面是设计迭代的过程。</p><h4 id="5-2-1-工厂模式"><a href="#5-2-1-工厂模式" class="headerlink" title="5.2.1 工厂模式"></a>5.2.1 工厂模式</h4><p><u><strong>通过抽象 “具体对象的创建过程” 为一个函数，来完成对象的构建</strong></u>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    o.<span class="property">name</span> = name;</span><br><span class="line">    o.<span class="property">age</span> = age;</span><br><span class="line">    o.<span class="property">job</span> = job;</span><br><span class="line">    o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>⚠⚠ <strong>缺陷</strong>：<strong>无法识别这个接口相同的对象</strong>。⚠⚠</p><p>为了解决这个问题，设计出了 “构造函数模式” 来创建同接口的对象。</p><h4 id="5-2-2-构造函数模式-与-this-关键字"><a href="#5-2-2-构造函数模式-与-this-关键字" class="headerlink" title="5.2.2 构造函数模式 与 this 关键字"></a>5.2.2 构造函数模式 与 this 关键字</h4><p>首先我们要梳理一个问题——什么是 JavaScript 中的 <code>this</code> 关键字。它的含义相当混乱。我们在前面的时候已经用到过 <code>this</code> 关键字，但是它实际上：</p><ul><li><p>在方法中，this 表示该方法所属的对象；</p></li><li><p>如果单独使用，this 表示全局对象；</p></li><li><p>在函数中，this 表示全局对象（严格模式下为 <code>undefined</code>）；</p></li></ul><blockquote><p>其实还有 <strong>事件</strong>，在 “事件” 中，<code>this</code> 也不相同，不过这里不作介绍，用到再说。</p></blockquote><p>进一步来看 JavaScript 中的 <code>new</code> 关键字的作用。</p><p>首先 <code>new</code> 关键字的操作对象是 <code>Function</code>，并<u>将该函数作为构造函数</u>。</p><p>这是 <code>var obj = new Func()</code> 执行的具体步骤：</p><ol><li><p>创建一个新对象（为对象开辟内存空间），以 <code>o</code> 指代；</p></li><li><p>将 <code>Func</code> 作用域对象绑定为 <code>o</code>，所以 <code>Func</code> 内的 <code>this</code> 由原本的全局对象指向 <code>o</code>；</p></li><li><p>执行 <code>Func</code> 函数体；</p></li><li><p>为对象 <code>o</code> 添加普通属性 <code>constructor</code>，指向 <code>Func</code>；</p><blockquote><p>这样我们可以通过两种方法确定这种对象的接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">constructor</span> == <span class="title class_">Func</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Func</span>);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>自动返回对象 <code>o</code>；</p></li></ol><p>经过这样定义的 <code>this</code> 和 <code>new</code> 关键字就能完成类似 C++ 中构造函数的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样也能解释为什么自定义的对象也继承于 <code>Object</code>。</p><p>同时，这种函数也能作为普通函数使用，因为它的函数体本质上修改的是函数内的 <code>this</code> 对象。我们可以：</p><ul><li><p>直接调用它：这样修改的 <code>this</code> 就是全局对象，相当于给全局对象加了特定属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器引擎中</span></span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); <span class="comment">// 添加到 window</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Greg&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>call() / apply()</code> 指定作用域对象来调用：这就相当于对特定的对象执行了构造函数，同时还能解决工厂模式的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(o, <span class="string">&quot;Kristen&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Nurse&quot;</span>);</span><br><span class="line">o.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Kristen&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>⚠⚠ <strong>缺陷</strong>：<strong>“构造”函数中，写函数定义作为属性，会导致每次构造一个对象，都产生一个新的对应的函数对象</strong>。这会导致不同的作用域链和标识符解析。⚠⚠</p><p>这是因为，函数也是 <code>Object</code> 的一种，函数直接量定义也会在堆内存中创建一个新的函数对象，然后引用。</p><p>有人说，这好办，把所有函数定义都拿到 “构造” 函数以外不就行了？</p><p>但是如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。</p><p>因此另一种 JavaScript 的对象构造模式就出现了。</p><h4 id="5-2-3-原型"><a href="#5-2-3-原型" class="headerlink" title="5.2.3 原型"></a>5.2.3 原型</h4><p>解决 “构造” 函数封装性问题的方法很简单：<strong>再套一层作用域对象，不影响全局作用域对象不就行了</strong>！</p><p>ECMAScript 实际也是这么解决的。我们在 4.5.2 中提到，<code>Function</code> 引用类型有一个属性 <code>prototype</code>，这个就是为了解决对象的构造函数封装问题。</p><p><code>Function.prototype</code> 就是一个引用<strong>指向一个新的对象（在这个函数创建时被创建）</strong>，这个新对象的用途就是 <u><strong>保存特定类型的所有实例共享的属性和方法</strong></u>。</p><p>也就是说，你可以使用某个函数的 <code>prototype</code> 作为存放一类接口相同的对象模板属性的对象（模板对象）。</p><p>于是，我们定义构造函数 <code>Func</code> 时就创建一个新对象（为对象开辟内存空间），暂且叫做 <code>o1</code>，创建的引用指向新对象，<strong>这个引用就叫 <code>prototype</code></strong>；</p><p>而我们使用 <code>new</code> 关键字的过程（<code>var obj = new Func();</code>）就变为：</p><ol><li>创建一个空的 JavaScript 对象，叫做 <code>o2</code>；</li><li>为对象 <code>o2</code> 添加内部属性 <code>[[prototype]]</code>，或者 <code>__proto__</code>，指向 <code>o1</code>（即 <code>Func.prototype</code>所指），对开发者不可见；</li><li>将当前 <code>Func</code> 作用域对象绑定为 <code>o2</code>，所以 <code>Func</code> 内的 <code>this</code> 由原本的全局对象指向 <code>o2</code>；</li><li>执行 <code>Func</code> 函数体；</li><li>为对象 <code>o2</code> 添加普通属性 <code>constructor</code>，指向 <code>Func</code>；</li><li>返回对象 <code>o2</code>；</li></ol><p>这样：</p><ul><li><u><strong><code>prototype</code> 对象中的属性被所有构建出的对象所共享（通过 <code>[[prototype]]</code> 所共享，包括其中所有方法、属性）</strong></u>。相当于 Python 里的 类方法、类属性；</li><li>根据第 4 步，<strong>我们可以在构造函数 <code>Func</code> 中使用 <code>this</code> 修改属性</strong>，这就相当于<strong>仅对当前对象修改属性和方法</strong>，相当于 Python 里的实例方法、实例属性（当然也可以在构造函数外修改）；</li></ul><p><u><strong>还有一个重要的特性，就是 查找对象自己的属性 可以 “fallback” 到原型对象上去查找</strong></u>。</p><p>比如下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instanceProp1</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instanceProp2</span> = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person2.<span class="property">name</span> = <span class="string">&quot;Sam&quot;</span>;    <span class="comment">// 相当于 “实例属性”</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// fallback to Person.prototype.name (&quot;Nicholas&quot;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>);    <span class="comment">// &quot;Sam&quot;</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 解释器如果无法找到对象的某个属性，那么它会通过 <code>[[prototype]]</code> 到它的原型中继续找。</strong></p><hr><p>还有一个问题，之前定义的 <code>__proto__</code> 不是指向共享的原型（其属性就像 Python 里的 类方法、类属性）吗？但它对开发者不可见，那么我该如何使用它？使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(&lt;obj&gt;) -&gt; <span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><p>这样直接能得到原型对象的引用，然后使用其中的属性就行。</p><p>此外，我们还可以分辨创建对象的接口类型（比 <code>constructor</code> 属性的比较更可靠）：使用 <code>Func.prototype.isPrototypeOf(&lt;obj&gt;)</code> 来判断 <code>obj</code> 是否由 <code>Func</code> 的原型构建出来。举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(p)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>还要记住一件事：由于 <code>Func.prototype</code> 被对象共享，所以<strong>请不要轻易替换原型对象，除非你知道你在做什么，否则会出现原型指代不一致的问题</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象后替换了原型对象，</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    name : <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    age : <span class="number">29</span>,</span><br><span class="line">    job : <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    sayName : <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原来的 friend 的 [[prototype]] 还指向旧的原型，</span></span><br><span class="line"><span class="comment">// 而旧的原型没有定义 sayName</span></span><br><span class="line">friend.<span class="title function_">sayName</span>(); <span class="comment">//error</span></span><br></pre></td></tr></table></figure><h4 id="5-2-3-EX-原生对象的原型"><a href="#5-2-3-EX-原生对象的原型" class="headerlink" title="5.2.3 - EX 原生对象的原型"></a>5.2.3 - EX 原生对象的原型</h4><p>原生对象也有原型，思路与这里一致，只需记住一点：</p><p>⚠⚠ ！！！<u><strong>强烈不建议修改原生对象原型</strong></u>！！！⚠⚠</p><h2 id="Chapter-6-函数表达式"><a href="#Chapter-6-函数表达式" class="headerlink" title="Chapter 6. 函数表达式"></a>Chapter 6. 函数表达式</h2><h3 id="6-0-函数表达式的复习-amp-箭头表达式"><a href="#6-0-函数表达式的复习-amp-箭头表达式" class="headerlink" title="6.0 函数表达式的复习 &amp; 箭头表达式"></a>6.0 函数表达式的复习 &amp; 箭头表达式</h3><p>JavaScript 中非常重要的特性，就是函数表达式。<strong>它是定义函数的一种手段</strong>。</p><p>在 2.8 和 4.5 中，我们了解到函数的两种定义方法，一种是直接声明，另一种就是函数表达式（可以创建匿名函数）。</p><p>而且前者会发生函数声明提升，后者不会。</p><p>根据这个特性，有些函数声明无法做到的逻辑，函数表达式却可以，例如根据条件选择函数指针：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Yo!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="keyword">var</span> sayHi;</span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    sayHi = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sayHi = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Yo!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了函数表达式，JavaScript 还支持 <strong>箭头表达式</strong>，但是它一定是匿名的，一般建议只把它作为使用一次的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;paramList&gt;) =&gt; &#123; &lt;funcBody&gt; &#125;</span><br></pre></td></tr></table></figure><p>有意思的是，箭头表达式支持异步（<code>async</code>）；</p><p>有一个 ⚠⚠<strong>危险</strong>⚠⚠：<strong>箭头表达式不能想函数表达式一样作为方法、构造函数等</strong>，这是因为箭头表达式内部<strong>不会定义 <code>this</code>，也没有 <code>arguments</code></strong>；</p><p>此外，函数表达式还有一些高级应用。</p><h3 id="6-1-应用Ⅰ：严格模式下的递归"><a href="#6-1-应用Ⅰ：严格模式下的递归" class="headerlink" title="6.1 应用Ⅰ：严格模式下的递归"></a>6.1 应用Ⅰ：严格模式下的递归</h3><p>为了防止递归函数赋给其他函数变量后可能无法使用的问题，递归函数内一般不写死自己的函数名，而是使用 <code>Function.arguments.callee</code> 的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在严格模式下，无法使用这个属性。我们可以把这个函数定义为函数表达式来巧妙避开这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">num</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num * <span class="title function_">f</span>(num-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="6-2-应用Ⅱ：闭包"><a href="#6-2-应用Ⅱ：闭包" class="headerlink" title="6.2 应用Ⅱ：闭包"></a>6.2 应用Ⅱ：闭包</h3><p>闭包和匿名函数很像，但它们是不同的概念。</p><p>闭包的定义是：<strong>有权访问另一个函数作用域中的变量的函数</strong>。</p><p>创建闭包的常用方法就是 <strong>函数内部定义函数</strong>。这样内部的函数就能访问外部函数的数据，这样内部函数就是闭包了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1, object2</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过有 2 点需要注意：</p><ol><li><p>闭包中，如果访问了外层函数的变量，那么在执行前该变量的值一直不会替换，而是原封不动地保存引用，例如这个例子的每个函数都返回 10：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createFunctions</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法是再加一个匿名函数，使得最内层的闭包无法访问到最外部变化的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createFunctions</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>和上面一个问题一样，这次是 <code>this</code> 对象。如果在对象中定义闭包，那么闭包是无法访问到对象作用域的<code>this</code>（只会找到全局作用域对象），所以需要手动在外部函数指定 <code>this</code> 对象的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">    getNameFunc : <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">// 这会获得 全局作用域中的 name 属性，而非 object.name</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;My Object&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attr">getNameFunc</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> that.<span class="property">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-3-应用Ⅲ：模仿块级作用域"><a href="#6-3-应用Ⅲ：模仿块级作用域" class="headerlink" title="6.3 应用Ⅲ：模仿块级作用域"></a>6.3 应用Ⅲ：模仿块级作用域</h3><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure><p>因为函数这样就能避免 <code>for</code> 语句中的计数变量 <code>i</code> 泄漏到全局中。</p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析 TTY Subsystem</title>
      <link href="//technical/tty-subsystem/"/>
      <url>//technical/tty-subsystem/</url>
      
        <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>References: 参考文献见文章末尾。</i></p><p><i>本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><h2 id="为什么讨论-TTY"><a href="#为什么讨论-TTY" class="headerlink" title="为什么讨论 TTY"></a>为什么讨论 TTY</h2><p>在 Linux 系统中，TTY 是一个相当有名的子系统。当你输入 <code>ls -l /dev</code> 的时候，你能看到许许多多以 <code>tty</code> 为前缀的字符设备，这就是对 TTY 子系统在文件上的抽象。</p><p>虽然我们无论是命令行还是 GUI 使用 Linux 的时候，TTY 似乎对我们无感，但是，当我因为一个小问题在互联网上查了很多关于 TTY 资料，却仍然很难找到一个完整的知识资料的时候，我发现这个 TTY 子系统的重要性被很多人忽视了。在整理了相关资料后，我愿意相信，搞清楚 Linux 的 TTY 子系统，属实是入门 Linux 系统的必由之路。</p><p><strong>尤其是，如果你想要写一些更接近 Linux 底层的、I/O interactive 方面的应用程序，那么 <code>TTY</code> 的知识就显得更加重要。</strong></p><p>前段时间，我在写 CSAPP 的 shell lab，工作量不大所以很快就完成了。但是文档里有句话让我不解，“这个 tiny shell <strong>不需要支持</strong>运行类似 <code>vim</code> 和 <code>tmux</code> 的程序，它们会对你的终端进行一些修改”。出于 “你不让我做，我偏要做” 的心态，我迅速拿着已经完工的 <code>tsh</code> 运行 <code>vim</code>，结果，<strong><code>vim</code> 被第 22 号信号挂起了</strong>。我尝试用内置指令 <code>fg</code> 将任务调向前台，也无济于事：</p><p><img src="imgs/fail.png"></p><p>很自然地，我查看了一下 22 号信号，发现是一个我未曾谋面的信号：<code>SIGTTOU</code>。很快啊，英文文档 “啪” 的一下就来了，我没有闪，只看见字里行间密密麻麻地挤满一个单词：<code>TTY</code>。</p><p>Google 了很多文章之后我才发现，我们一直使用的<strong>命令行（CLI）</strong>都建立在一个无形的机制之上，这个机制接收并且传递我们在终端软件窗口的字符指令，建立起用户和操作系统的 “调度 和 沟通” 的桥梁。这，我以前一直是没有关注的。</p><p>于是我明白，想要了解这之中究竟发生了什么、想要解决这个问题，就有必要了解一下 Linux TTY 了。</p><blockquote><p>对历史不感兴趣的同学请跳过下面一节。</p></blockquote><h2 id="TTY-的成长之路"><a href="#TTY-的成长之路" class="headerlink" title="TTY 的成长之路"></a>TTY 的成长之路</h2><p>实际上，TTY 在 OS 中的迭代和发展史谈不上 “elegant”，甚至可以用 “蜿蜒曲折” 来形容。</p><p>在 1869 年，一种机器叫做 “<strong>股票行情自动收录器</strong>”（stock ticker）在当时金融系统不断发展的资本主义世界诞生了。它的样貌可以描述一下——一个电驱动的机械装置，包含一台机械打字机（typewriter）、一捆的电线，还有一长串用以打孔的纸带组成，它工作时的样貌如下图<sup><a href="#fn_1" id="reffn_1">1</a></sup>：</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="imgs/tick1.png" width="300px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="imgs/tick2.png" width="300px" align=center></div></div></div></div><p>它的使用和早期的计算机一样（不过更早），都需要有一个操作员在一旁输入指令、处理输出纸带，<strong>最终可以达成 “远距离实时广播股票价格” 的任务</strong>，是不是有点像影视剧里的电报？</p><p>不过这个机器很快就演变为一个更快、基于 ASCII 编码的机械结构。知道它的名字的人可能会多一点：<strong>teletype</strong>（电传打字机，简称 TTY）。那么 teletype 在当时时如何完成给通信的另一方传输消息的功能的呢？答案是，连接上当时最大的 “网络”——<strong>Telex</strong>，专门用来在各个资本家之间传输商业电报。</p><p>你可能会好奇，这个时候的计算机是什么情况？很遗憾，这个时候计算机还超级大、超级原始，似乎和 teletype 没啥交集。但是没过几年，当计算机的设计和架构发展到，已经可以支持执行多任务（multitask）的时候，一个重要的能力，却也是等待解决的问题就来了：<strong>计算机可以与用户进行实时交互了</strong>。这意味着，之前 “将打孔写程序的纸带传入机器” 的<strong>旧批处理模型（old batch processing model）</strong>就可以被人机交互所代替，从而大大减小操作员运行计算机的工作量<sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p><p>那么，如何实现与机器的直接交互？（传纸带肯定不够高效的🤡 于是大佬们将视线转向当时市场中一个随处可见的机器——teletype 电传打字机。他们打算用 teletype 连接上计算机，这样只需要打打字向计算机发指令就可以达到交互和执行命令的效果。</p><p>有个难题是，当时市面上的 teletype 没有一个 “行业标准”，每个厂家生产的机器都略有不同。在计算机科学的视角来看，这好办，封装嘛，设计一个统一的 <strong>从 teletype 输入到 计算机的软件层适配接口</strong>（硬件层好说，就串口电信号而已，主要是软件驱动）就行，下次无论 teletype 生产厂家设计什么样的机型，只要计算机的系统支持这个接口规范，那不拿来就能用？</p><p>在当时的 Unix 世界中（当时 Unix 已经出现），一种方法是让 OS Kernel 来实现这层接口，处理所有有关于 teletype 输入的底层细节，例如字长（word length）、串口波特率（baud rate）、流控制（flow control）、校验（parity，学过数电的同学会比较清楚这里面的机制）、基础的行 buffer 编辑能力等等。</p><p>在 20 世纪 70 年代晚期，基于 teletype 和 OS 处理接口的一类新型输入终端出现了（例如 VT-100），它们在 teletype 的基础上包装了屏幕，支持闪烁的命令行光标、有色彩的输出信息等等，被人们称为 <strong>video terminals</strong>。</p><p>不过，到了今天，我们可以发现所有实体的 teletypes、video terminals 都已经 “灭绝” 了，你只能在一些博物馆，或者硬件发烧友的收藏中寻得它们的踪迹。</p><p>由于历史习惯的原因，当今你能看到所有的 Unix 类系统中还有 “TTY”，不过它们都是对以往的 video terminals 在软件上的模拟而已。正如一位外国网友所说：</p><blockquote><p>The legacy from the old cast-iron beasts is still lurking beneath the surface<sup><a href="#fn_3" id="reffn_3">3</a></sup>.</p><p>这头钢铁巨兽（teletypes）的意志仍蛰伏在如今的 OS 的外表之下<sup><a href="#fn_3" id="reffn_3">3</a></sup>。</p></blockquote><h2 id="用户视角下的-TTY-old-versions"><a href="#用户视角下的-TTY-old-versions" class="headerlink" title="用户视角下的 TTY: old versions"></a>用户视角下的 TTY: old versions</h2><p>想要了解现代 Linux 系统中的 TTY 机制，我们还需要将时间拨回很早以前——人们使用实体 teletype 输入的时候。我们将 teletype 这个输入计算机指令以实现人机交互的设备称之为 <strong>终端（terminal）</strong>。当时的软硬件结构是这样的：</p><p><img src="imgs/case1.png"></p><p>teletype 是用一捆捆电线连接到计算机的一个叫 <strong>UART</strong>（Universal Asynchronous Receiver and Transmitter，通用异步收发器）的硬件设备上的。</p><p>对应地，内核里就写了一个驱动 UART driver，用来管理从物理 terminal 设备上发来的电信号 bytes，处理一些细节例如前一节提到的 bytes 校验、流控制。</p><p>一开始，UART driver 是直接将初步处理好的 bytes 流直接传给一些正在运行的进程，但是显然这种方法需要弥补几个缺陷：</p><p><strong>1. 行编辑能力（Line Editing）</strong></p><p>正常人在敲键盘（当时是敲打字机）的时候，无法避免的可能会打错。所以，肯定得有 backspace 退格的功能对吧？这个功能当然可以交给接收信号的进程自己来处理，但是计算机科学讲究不能混淆抽象层级，而且这也不符合 Unix 的设计哲学——运行在其上的程序应该越简单越好（只关心自己的业务逻辑）。</p><p>所以为了方便考虑，当时的人们直接把这个功能也放到了操作系统内核里了。这时，操作系统就需要提供一个编辑内容的缓冲区（editing buffer），并且支持一些基本的编辑指令（退格、擦除单词、清空一行等），这些软件功能模块被叫做 <strong>line discipline</strong>（好家伙，这是在内核里写了一个行编辑器），它的地位如本节开头的图所示。</p><p>不过，不同的上层应用程序对于它们接收的输入流肯定有各种各样的自定义的要求，因此 line discipline 除了提供正常的行编辑功能（cooked or canonical mode），还提供 <strong>raw mode</strong>（对输入流不做处理）。因此这些 advanced application（例如本身就是编辑器软件、邮件客户端、shells，以及自己调用 <code>curses</code> 和 <code>readline</code> 的程序）常常将系统的 line discipline 设置为 raw mode，然后自己执行对流的控制。</p><p>正如上面所说，OS Kernel 提供了多种不同的 line disciplines，不过<strong>一次只有一个 line discipline attach 到指定的串口设备上</strong>（对于旧时设备，如上图，串口设备是 UART driver）。默认的 line discipline 会提供基本的行编辑功能，叫做 <code>N_TTY</code>（<code>driver/char/n_tty.c</code>），还有另外种类的 line disciplines 控制例如鼠标串口等。</p><p><strong>2. 会话管理（Session Management）</strong></p><p>还有一个很重要的一点是，对于一个用户而言可能他（她）需要同时运行多个程序，然后一次与它们之中的一个程序交互。总的来说，用户需要：</p><ul><li><p>如果一个应用程序陷入死循环，那么用户可能会需要向其发信号（kill / suspend……）；</p></li><li><p>一个后台程序如果需要向终端（terminal）写数据，那么它们需要被 <strong>suspend 直至前台进程处理结束，或者前台程序已经为其准备好了写终端的环境</strong>。</p><blockquote><ol><li><p>为什么需要 suspend？不然所有后台程序都能随意更改终端，那不乱套了！其实，再想想，你在后台运行一个 <code>echo &quot;Hello&quot;</code> 好像也不会挂起？这个问题与之前的不相悖，我们后面讨论；</p></li><li><p>这个 suspend 的机制就是借助了 OS Kernel 发送的 <code>SIGTTOU</code> 机制，后面详细说。</p></li></ol></blockquote></li><li><p>用户向当前 terminal 输入，肯定只能发送给当前的 “前台”（foreground）进程。</p></li></ul><p>常见的 OS 都会 implement 一个 TTY driver（<code>drivers/char/tty_io.c</code>）来实现上述需要（具体地位前本章开头的图片）。TTY driver 也是个软件，但和一般的 “进程” 不一样：它是个 “passive object”，这意味着它像一个库，只有一些数据域（data fields）和一些方法（methods），等待其他进程的主动调用 / 内核中断 handler 调用。</p><p>于是，人们通常将 <strong>UART driver</strong>（常用来直接读取串口设备、进行简单 parity 和 flow control）、<strong>line discipline 实例</strong>（用来作为 editing buffer，处理简单的行编辑命令）、<strong>TTY driver</strong>（多个进程间读取 terminal 的会话管理）三元组（triplet）称为一个 <strong>TTY device（TTY 设备）</strong>。</p><p>因此，Unix 操作系统对上层的应用程序抽象的 terminal 就是 <code>TTY</code> 设备文件，存放于 <code>/dev</code>。</p><blockquote><p>顺便提一句，Unix 系统想要对 TTY 设备文件写入的用户需要是这个 TTY 设备文件的拥有者（owner）。我们经常使用 <code>shell</code> 的 login mode 登陆服务器时，内部会执行 <code>login</code> 程序，其工作之一便是以 <code>root</code> 权限将 shell 接下来需要使用的 <code>/dev/ttyN</code> 的拥有者换为登陆用户，以便登录用户能够读写 terminal；</p></blockquote><h2 id="用户视角下的-TTY-modern-versions"><a href="#用户视角下的-TTY-modern-versions" class="headerlink" title="用户视角下的 TTY: modern versions"></a>用户视角下的 TTY: modern versions</h2><p>我们了解了以前计算机是如何将 teletype 连接到计算机上并与之交互的，现在我们再将视野转移到现代计算机（desktop system，一般是图形化的）。</p><p>还是讨论现代 Unix 系统，这个时候输入输出模型可以抽象为如下图形：</p><p><img src="imgs/case2.png"></p><p>此时 TTY driver 和 line discipline 的 作用和以往版本的作用几乎相近，但是现在已经不存在 teletype 了，取而代之的是 键盘 和 显示屏，因此就没有 UART 和实体 terminal 什么事了。</p><p>取而代之的，是一个在 <strong>terminal emulator 中模拟的 video terminal</strong>（可以理解为<strong>一个包括了字符帧缓存（frame buffer of characters）和图形属性）的复杂状态机</strong>）。</p><p>它的作用是接收来自键盘驱动的预处理信号，将其传给对应得 line discipline，并将输出数据渲染到 VGA 显示器上。</p><p>等等！不太对，我们一直讨论的是 terminal emulator，因此有下面 2 种问题：</p><ul><li>目前这台计算机还只能简单字符输入和显示，相当于只实现了命令行子系统（console subsystem）；</li><li>emulator 位于<strong>内核中</strong>，不够灵活（rigid），在抽象层级上说，为了可维护性和可扩展性，应该将其挪到用户态空间中（userland）；</li></ul><p>事实上，为了解决上面的问题，TTY device 的设计更加抽象了：</p><p><img src="imgs/case3.png"></p><p>我们发现，line discipline、TTY driver 的结构都不需要变嘛，因为它们还需要提供基本的行缓冲、会话管理的功能。因此，人们在内核中设计出了 <strong>pseudo terminal（<code>pty</code>，伪终端）</strong>，用于对接支持 <code>xterm</code>（Unix 中一种默认的终端模拟器）的桌面程序。</p><blockquote><p>注意，如果你在一个 <code>xterm</code> 桌面进程中调用了 <code>screen</code>、<code>tmux</code> 等程序，那么就是 pseudo terminal 套 pseudo terminal 的复杂结构，这里不讨论。</p></blockquote><h2 id="TTY-与-进程"><a href="#TTY-与-进程" class="headerlink" title="TTY 与 进程"></a>TTY 与 进程</h2><p>了解了 <code>TTY</code> 的发展和构成，那么 process 是如何和 PTY 对接的呢？为了讨论这个问题，我们需要复习一些进程、shell job control 的知识。</p><h3 id="补充-1：Unix-Processes"><a href="#补充-1：Unix-Processes" class="headerlink" title="补充 1：Unix Processes"></a>补充 1：Unix Processes</h3><p>大部分学过 CSAPP 的同学可能对进程已经有了初步了解，尤其是在考完了 ICS 之后对其理解更为深刻…… 不过 CSAPP 关于进程的知识并不是操作系统的全部，我们下面补充一点。</p><p>一个 Linux Process 通常有 <strong>5 种状态</strong>：</p><p><img src="imgs/process.png"></p><ul><li><p><code>R</code>：Running / Runnable（On OS run queue），此状态的进程正在 CPU 上运行，或者做好被 CPU 调度的一切准备；</p></li><li><p><code>D</code>：Uninterruptible sleep（waiting for some events），此状态的进程因为某些指令正在等待某些事件，大部分原因是 <strong>I/O 事件</strong>，通常不会被 CPU 调度；</p><blockquote><p>例如，程序执行到 <code>read</code> 等系统调用时，等待 I/O 设备触发 CPU 中断引脚；</p></blockquote></li><li><p><code>S</code>：Interruptible sleep（waiting for some events or signals），此状态的进程因为某些指令正在等待某些事件，或者等待某类信号，通常不会被 CPU 调度；</p><blockquote><p>例如，程序执行到 <code>pause</code>、<code>sleep</code> 等系统调用时，挂起等待信号 / 系统计时器中断；</p></blockquote></li><li><p><code>T</code>：Stopped，外部造成的暂停执行，只有 2 种可能：<strong>shell 的 job control signal，或者 debugger 断点</strong>；</p></li><li><p><code>Z</code>：Zombie，已经终止的子进程，但是父进程存在，并且没有回收它；</p></li></ul><p>进程组的知识不再赘述，与大家在 CSAPP 中接触到的一样。</p><h3 id="补充-2：Shell-Job-Control"><a href="#补充-2：Shell-Job-Control" class="headerlink" title="补充 2：Shell Job Control"></a>补充 2：Shell Job Control</h3><p>在 CSAPP 的 shell lab 中，我们进一步深化了对课本中 shell 的理解。通常情况下，一个 shell 承担了一个重要的工作：对用户的程序管理为 <strong>前台、后台</strong> 两种形式，方便用户指定和操作。这种管理方法就称为 <strong>job control</strong>。</p><p>正如 CSAPP 一书中对 job control 的说明，shell 的进程管理应该呈现如下的模式：</p><p><img src="imgs/process_group.png" height="300px"></p><p>当用户通过 shell 登陆，或者仅启动 shell 时，shell 作为系统中的一个进程，会单独设置自己的进程组（自己进程组号改为与自身进程号一致，防止与父进程联系，导致收到父进程的信号）；</p><p>此后，通过 shell 创建的所有进程（执行的所有程序）都会在 <code>execve</code> 前设置单独的进程组号，方便 shell 统一管理。前台、后台进程的子进程一般都在自己的进程组里。其中前台进程只有一个，后台进程有多个。</p><p>但是！CSAPP 中没有说明的一点是，<strong>前台进程是如何与用户输入建立联系的？更准确地说，前台进程如何准确 attach 到当前的 pseudo terminal 上的？</strong></p><h3 id="补充-3：Shell-Sessions（重要）"><a href="#补充-3：Shell-Sessions（重要）" class="headerlink" title="补充 3：Shell Sessions（重要）"></a>补充 3：Shell Sessions（重要）</h3><p>实际上，Linux 上除了进程、进程组，还有一个重要的机制 <strong>会话（Session，其实 Windows 上也有）</strong>。对应的，每个进程也有一个 session ID（<code>sid</code>），其机制如下：</p><ul><li><p>一个 <code>session</code> 一般包含了多个进程，不过其中有且仅有一个进程是特殊的，被称为 <strong>session leader</strong>，它一般是创建这个 session 的进程；</p><blockquote><p>注：Session Leader 可以在进程信息中看到。</p><p>大家不妨运行 <code>ps aux</code> 查看一下当前进程的状况，比如：</p><p><img src="imgs/ps.jpg" height="300px"></p><p>中间红框的一列描述的就是各个进程的状态。其中可能出现的 <code>D</code>、<code>R</code>、<code>S</code>、<code>T</code>、<code>Z</code> 称为 <strong>标识符</strong>，就是之前介绍的含义。还有一类标识符 <code>I</code> 表示 Idle Kernel Thread（空闲的内核线程）<sup><a href="#fn_4" id="reffn_4">4</a></sup>；</p><p>不过除此以外还有一些修饰符，例如：</p><ul><li><code>&lt;</code> 表示该进程的优先级较高（一般是 <code>root</code> 用户指定）；</li><li><code>N</code> 表示该进程优先级较低（一般是普通用户创建，并且主动 Sleep 的时间很长）；</li><li><code>s</code>（小写）<strong>表示该进程为 session leader</strong>；</li><li><code>l</code> 表示该进程中的程序是多线程的；</li><li><code>+</code> <strong>表示该进程在 shell 指定的前台进程组（foreground process group）中</strong>；</li></ul></blockquote></li><li><p>每个新创建的进程的 <code>sid</code> 与父进程相同（<strong>与父进程共用一个 session</strong>）；</p></li><li><p>一个 pseudo terminal 只能与一个 session 建立联系；与当前 <code>pty</code> 建立联系的 session 中，只有 session leader 有权控制 <code>pty</code> 和 session 的联系；</p><blockquote><p>这里的 “联系” 需要开发者（例如 shell 开发者）<strong>显式提醒 <code>TTY driver</code> foreground process group 的 group id</strong> 才能完成。<strong>使用系统调用 <code>tcsetpgrp</code></strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set the specific process group as the foreground process group. */</span></span><br><span class="line"><span class="comment">/* `fd` must be the controlling terminal of the calling process,</span></span><br><span class="line"><span class="comment"> * and still be associated with its session. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcsetpgrp</span><span class="params">(<span class="type">int</span> fd, <span class="type">pid_t</span> pgrp)</span>;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>如果 <strong>后台进程组的程序想要读 <code>stdin</code> 或写 <code>stdout</code></strong>（指向当前 session 对应的 <code>pty</code>），那么 OS Kernel 会向该进程发送 <code>SIGTTIN / SIGTTOU</code> 信号（default action 是终止进程），要求该后台进程等待；</p><blockquote><p>某些情况下，即便是后台进程组也可以直接向当前 session 写，例如在终端上执行命令： <code>echo Hello &amp;</code>，则会直接打印内容。</p><p>这与终端的设定有关。首先 OS 和 <code>TTY device</code> 的设计者们意识到以下的用户需求：</p><ol><li>用户<strong>不希望</strong>后台进程读取当前 terminal 的输入；</li><li>用户<strong>可能允许</strong>后台进程向当前 terminal 输出；</li><li>用户<strong>可能不希望</strong>后台进程更改当前 terminal 的设置（包括串口比特率、line discipline、输出策略等等）；</li></ol><p>因此针对以上需求，设计者们设定：</p><ol><li><strong>OS 不允许后台进程从当前 <code>pty</code> 读入，kernel 一定会对调用读入操作的进程发送 <code>SIGTTIN</code> 信号</strong>；</li><li><strong>OS 默认允许后台进程向当前 <code>pty</code> 输出。允许用户修改这一行为</strong>；</li><li><strong>OS 默认不允许后台进程修改当前 <code>pty</code> 设置，kernel 一定会对该进程发送 <code>SIGTTOU</code> 信号</strong>；</li></ol><p>另外补充一句，用户可以通过 <code>stty</code> 指令来查看、修改当前终端设置。例如：</p><ul><li><code>stty [-a/--all]</code>：打印当前终端设置；</li><li><code>stty tostop/-tostop</code>：设置<strong>不允许 / 允许后台进程向当前 <code>pty</code> 输出</strong>，默认允许；</li></ul></blockquote></li></ul><p>到这里，我们终于能够解释文章一开始的问题了——为什么 <code>tsh</code> 中运行 <code>vim</code>，<code>vim</code> 会收到 <code>SIGTTOU</code> 了。这是因为 <strong>CSAPP 的 shell lab 对 “前台进程” 的处理方式有问题，它没有真正将要在前台执行的进程加入前台进程组</strong>。</p><h3 id="Conclusion-TTY-amp-Process-with-SIGNALs"><a href="#Conclusion-TTY-amp-Process-with-SIGNALs" class="headerlink" title="Conclusion: TTY &amp; Process with SIGNALs"></a>Conclusion: TTY &amp; Process with SIGNALs</h3><p>现在，所有必须的知识已经集齐了，我们来看看 <code>TTY</code> 与进程交互的总体机制。</p><p>之前提到过 Unix 中的一切 I/O 设备都被抽象为 Unix files，这也包括 TTY device。与其他文件一样，一个进程想要进行读写前必须进行一些初始化操作，这个初始化就要求进程与内核间通信，所以<strong>信号</strong>是不可避免的。</p><blockquote><p>Tips. 在 <code>ioctl</code> C 库中含有许多与 <code>TTY</code> 设备读写相关的操作。</p></blockquote><p>我们以涉及修改 <code>pty</code> 设置的一串动作来举个例子。</p><p><strong>step 1.</strong> 假设你在一个 login shell 中执行 <code>vim</code>，那么：</p><p>当前 shell 为 <code>vim</code> 创建一个进程（<code>fork &amp; execve</code>）和进程组（<code>setgid</code>），通知 <code>TTY device</code> 将该进程标记为前台进程组（<code>tcsetpgrp</code>）；</p><p>所以你会看到如下图，启动 <code>vim</code> 后，<code>vim</code> 进程所在组成为 foreground process group（进程状态 <code>S+</code>）；而 shell（这里是 <code>zsh</code>）进程则由 <code>Ss+</code> 转为 <code>Ss</code>（不再是前台进程，但仍是 session leader），并且它们都位于同一个 session 中（指向同一个 <code>pts</code>，即 <code>pts/1</code>）：</p><p><img src="imgs/vim.png" height="350px"></p><p><strong>step 2.</strong> 假设你在 <code>vim</code> 运行时按下 <code>Ctrl + Z</code> 将 <code>vim</code> 转向后台挂起，那么：</p><p>触发 Asynchronous Exception（ECF），<code>vim</code> 作为前台进程组直接收到 OS Kernel 发送的 <code>SIGTSTP</code> 信号。在 <code>vim</code> 的 <code>SIGTSTP</code> signal handler 中，<code>vim</code> 做挂起前的准备工作（例如通过向 <code>TTY device</code> 输出特定序列，将光标移动到上次位置、恢复打开前的命令行内容等等）。最后 <code>vim</code> 向自己进程组发送 <code>SIGSTOP</code>，正式将自己的进程组挂起到后台；</p><p>此时，<code>vim</code> 父进程（之前的 shell）收到 <code>SIGCHLD</code> 信号，shell 进入对应的 handler 进行处理（例如打印 <code>[1]+ Stopped</code> 信息给用户等工作），并且将自己的进程设置为前台进程组（<code>tcsetpgrp</code>）；</p><blockquote><p><strong>这个时候，如果你试图以后台形式运行 <code>vim</code>（例如 <code>bg</code>），那么 <code>vim</code> 会收到 kernel 的 <code>SIGTTOU</code> 信号，继续挂起</strong>（因为 <code>vim</code> 会更改终端设置，例如 line discipline 等等）；</p></blockquote><p><strong>step 3.</strong> 假设此时你使用 <code>fg</code> 将 <code>vim</code> 转到前台继续执行，那么：</p><p>shell 会恢复上一次的 <code>pty</code> 设置、通知 <code>TTY device</code> 当前的前台进程为 <code>vim</code> 所在进程、向 <code>vim</code> 进程发送 <code>SIGCONT</code> 继续。于是 <code>vim</code> 恢复运行、重绘界面；</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>当然，<code>TTY device</code> 在与进程交互时，还有更多可用的操作和行为，例如 flow control、blocking I/O，以及文中没有详细介绍的 <code>pty</code> 终端设置，等等。感兴趣的童鞋可以查阅 Linux 的官方文档、本文所引用的参考资料，或者是 man 文档。更多问题或勘误欢迎交流 ~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>:<a href="https://en.wikipedia.org/wiki/Ticker_tape">Ticker tape - Wikipedia</a><br><sup><a href="#fn_2" id="reffn_2">2</a></sup>: <a href="https://en.wikipedia.org/wiki/Batch_processing">Batch processing - Wikipedia</a><br><sup><a href="#fn_3" id="reffn_3">3</a></sup>: <a href="https://www.linusakesson.net/programming/tty/">The TTY demystified (linusakesson.net)</a></p><p><sup><a href="#fn_4" id="reffn_4">4</a></sup>:<a href="https://stackoverflow.com/questions/14315923/why-does-linux-kernel-need-idle-thread">smp - Why does linux kernel need idle thread? - Stack Overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>放假！吐槽！</title>
      <link href="//chat/summer-rest/"/>
      <url>//chat/summer-rest/</url>
      
        <content type="html"><![CDATA[<h2 id="Hooray"><a href="#Hooray" class="headerlink" title="Hooray !"></a>Hooray !</h2><p>家人们，经历了大半个月的期末周，终于来到假期了！我又活过来了😭 上个学期的时间安排实在是不太充裕，我想我得调整下节奏了🤔</p><h2 id="ツッコミ"><a href="#ツッコミ" class="headerlink" title="ツッコミ"></a>ツッコミ</h2><p>吐槽一下，在准备考试的时候，我和同学们为了分数反复写一些固定的题型，尤其是物理题。不是说我们不应该做物理题，而是这样的做法时间利用的效率真的不高。</p><p>之前看到过一篇文章说的感觉挺有道理的。我们常常听一些教育专家说，现在的学生要全面培养学科交叉能力，我无比赞同这句话，毕竟学科交叉既能开阔我们的专业视野，了解到很多其他方面的学识，又能提升我们的综合素质和学术能力，这是毋庸置疑的。</p><p>另一方面，我认为这个学科交叉是需要说明限度和范围的，而不是学科课表的 “自由组合”。以工科类专业举例，很多人会想，工科嘛，那不得来一整套大学物理，一直学到量子力学，加一点 “金课”，再加五花八门的大学物理实验；末了，再添一点理论力学、甚至大学化学，entitled “学科交叉素养的培养”。</p><p>这个本意是好的，但：每当我看到有些工科同学（惭愧地说，包括笔者）拿着学长学姐留下的 “报告模板”，花一大把时间在大物实验报告上，然后上交后再忘得一干二净，<strong>从此再也不会接触到它</strong>；每当我看到工科同学为了应对课时日益增加的大学物理、应对挖空心思出难题怪题只为<strong>正态成绩分布</strong>的教员们，拼命做题、掌握甚至背诵解题技巧的时候，我的心中总是有种奇怪的滋味。</p><p>也许我们没法改变，那么就要去适应游戏规则。尽管别人告诉你，“哎，大学物理实验能培养你的动手实践能力和写报告的水平，和你的主课一样重要”，你也一定要拎清楚主次，将 “dirty work” 和正常工作 “区别对待”。</p><p>打个不恰当的比方，有人说 “扫一下午大街” 和 “背诵一个下午英语单词” 一样重要，前者锻炼了你的劳动素养，后者增长了你的学术水平，咱不是要全面发展嘛。听起来好像做这两件事各有好处，难以取舍。实际上我们用常识想一想，作为一个学生，肯定很少有人会选择前者来消磨下午的时光。</p><p><strong>因为这并不是这两件事本身的价值孰优孰劣的问题，这是二者谁能为现在的我们提供更大的效益的个体问题。</strong></p><p>“今当远离，临表涕零，不知所言” 🤭。</p><hr><p>吐槽归吐槽，生活还是要继续。最后，终于可以自由地做自己的事情，停更许久的博客也终于可以继续更新了……</p>]]></content>
      
      
      <categories>
          
          <category> chat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tease </tag>
            
            <tag> holiday </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Notes: Scheduler &amp; Arch</title>
      <link href="//review/csapp-sched-arch/"/>
      <url>//review/csapp-sched-arch/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-8-Scheduler-in-OS"><a href="#Chapter-8-Scheduler-in-OS" class="headerlink" title="Chapter 8. Scheduler in OS"></a>Chapter 8. Scheduler in OS</h1><p>为操作系统的调度环境作出假设：</p><ol><li>Each job runs for the same amount of time</li><li>All jobs arrive at the same time</li><li>Once started, each job runs to completion</li><li>All jobs only use the CPU <ul><li>i.e., they perform no I/O</li></ul></li><li>The run-time of each job is known</li></ol><p><u>引入调度优劣衡量指标：周转时间</u>，<strong>$T_{turnaround}=T_{completion}-T_{arrival}$</strong>；</p><h2 id="Strategy-1-FIFO（FCFS，First-Come-First-Served）"><a href="#Strategy-1-FIFO（FCFS，First-Come-First-Served）" class="headerlink" title="Strategy 1: FIFO（FCFS，First Come First Served）"></a>Strategy 1: FIFO（FCFS，First Come First Served）</h2><ul><li>Implementation: queue；</li><li>消除假设 1：若短时任务排在长时任务之后，则平均周转时间效果很差；</li></ul><h2 id="Strategy-2-SJF（Shortest-Job-First）"><a href="#Strategy-2-SJF（Shortest-Job-First）" class="headerlink" title="Strategy 2 : SJF（Shortest Job First）"></a>Strategy 2 : SJF（Shortest Job First）</h2><ul><li>内容：对于<strong>同时到达的</strong>任务，优先选择总时长小的任务。</li><li>作用：（应对假设 1 的消除）缓解了<strong>短时任务排在长时任务之后所造成的较差的平均周转时间</strong>；</li><li>消除假设 2：不同任务到达的时间不一样。如果短时任务出现在长时任务开始后的很短的时间内，那么平均周转时间也很差（<strong>一般没有竞争抢占机制，具体请看题目要求</strong>）；</li></ul><h2 id="Strategy-3-STCF（Shortest-Time-to-Completion-First）"><a href="#Strategy-3-STCF（Shortest-Time-to-Completion-First）" class="headerlink" title="Strategy 3 : STCF（Shortest Time-to-Completion First）"></a>Strategy 3 : STCF（Shortest Time-to-Completion First）</h2><ul><li>内容和作用：（应对假设 2 的消除）竞争抢占机制（<strong>preemptive</strong>），晚到达的短时任务如果<strong>执行剩余时间</strong>短于长时任务的剩余时间，则进行抢占切换；</li><li><u><strong>添加一个衡量标准</strong>：Response Time（反应时间）</u>；<ul><li>the time from when the job arrives in a system to the first time it is scheduled;</li><li><strong>$T_{resp}=T_{firstturn}-T_{arrival}$</strong>;</li></ul></li><li>STCF 在 Response Time 中，如果恰好各个任务消耗的时间相近，它们无法抢占，但是抢占时间会很大；</li></ul><h2 id="Strategy-4-Round-Robin（时间片轮转）"><a href="#Strategy-4-Round-Robin（时间片轮转）" class="headerlink" title="Strategy 4 : Round Robin（时间片轮转）"></a>Strategy 4 : Round Robin（时间片轮转）</h2><ul><li>作用：（提升 Response Time）设计<strong>时间片（Time slice）</strong>，每个任务最多只能执行一段时间的代码，超时则切换到其他进程，使用上面的切换策略；</li><li>注意点：合理设计时间片长度（10ms），防止频繁的切换操作占用大量资源（switching cost）；</li><li>与 SJF 策略比较：有利有弊；</li><li>消除假设 4：任务可能存在 I/O 操作，耗时操作导致该进程很多时间片空闲；</li></ul><h2 id="Strategy-5-Overlap-when-performing-I-O-operation"><a href="#Strategy-5-Overlap-when-performing-I-O-operation" class="headerlink" title="Strategy 5 : Overlap when performing I/O operation"></a>Strategy 5 : Overlap when performing I/O operation</h2><ul><li>内容：当发生 I/O 操作时，应用必然调用系统调用，操作系统可以将此任务 block 进入 stopped 状态，并进行 context switch；</li><li>作用：在进行 I/O 操作时发生 switch，充分利用 I/O 操作的空隙，进行有效的 overlap；</li><li>消除假设 5：任务的运转时间未知，相当于无法比较任务是短时任务还是长时任务（例如交互式任务）；</li></ul><h2 id="Strategy-6-Multi-Level-Feedback-Queue-Scheduler（MLFQ）"><a href="#Strategy-6-Multi-Level-Feedback-Queue-Scheduler（MLFQ）" class="headerlink" title="Strategy 6 : Multi-Level Feedback Queue Scheduler（MLFQ）"></a>Strategy 6 : Multi-Level Feedback Queue Scheduler（MLFQ）</h2><ul><li><p>作用：1. <strong>优化未知任务时长（without a priority knowledge of job length）情况下的周转时间</strong>；2. <strong>最小化响应时间（在用户交互式应用中很重要）</strong>；</p></li><li><p>如何在<strong>没有先验知识</strong>的情况下，做出最合适的任务调度？</p><ol><li><p><strong>Learning from history</strong>：从系统运行程序的特性中做出猜测（类似分支预测器）；</p><ul><li>the multi-level feedback queue;</li></ul></li><li><p><strong>优先级预测队列</strong>策略：</p><p>Rule 1：任务队列使用<strong>多个队列，每个队列的优先级不同，同样队列中的任务优先级相同</strong>，<strong>优先级高的队列中的任务请求资源时，先于优先级低的任务</strong>；</p><p>Rule 2：如果两个任务处于同一优先级，则二者使用 <strong>Round Robin</strong> 策略；</p><blockquote><p>接下来需要考虑优先级的设置和改变问题。</p><p>考虑到 workload 同时含有 <strong>交互式任务</strong>（interactive jobs，CPU 使用时间一般很短，例如用户交互）和 <strong>CPU 密集型任务</strong>（CPU-bound，CPU 使用时间一般很长，例如矩阵计算，一般对 response time 要求不高）；</p></blockquote><p>Rule 3：当一个任务进入系统任务队列时，<strong>最先总是放到最高优先级</strong>；</p><p>Rule 4a：如果一个任务耗尽了一个周期中的所有时间片，那么 CPU 可以认为这个任务<strong>更有可能</strong>是个 CPU-bound job，那么<strong>先降低一个优先级，直到最低优先级</strong>；</p><p>Rule 4b：如果一个任务没有耗尽一个周期的时间片就释放 CPU 资源，那么 CPU 可以认为这个任务<strong>更有可能</strong>是一个 interactive job，那么<strong>保持在当前优先级</strong>；</p></li></ol></li><li><p>缺陷：</p><ol><li><strong>Starvation</strong>：如果有非常多的 interactive jobs 同时运行在最高优先级，那么<strong>很有可能导致最低优先级的 CPU-bound jobs 始终无法得到 CPU 资源</strong>；</li><li><strong>Gaming scheduler attack</strong>：一些恶意程序可能利用这个策略，设计占用大部分时间片内容，但在结束前释放 CPU 资源，这样会一直保持最高优先级，并且妨碍其他程序运行；</li><li><strong>Programs may change its behavior overtime</strong>：一些任务可能在 interactive 与 CPU-bound 的特性间相互转换；</li></ol></li><li><p>改进</p><ul><li><p>Rule 5（<strong>Priority Boost</strong>）：当某个时间周期 <strong>S</strong> 后，将所有任务都移动到<strong>最高优先级</strong>；</p><blockquote><p>好处 1：解决缺陷 1，消除 starvation 现象，保证每个进程都会被调度到；</p><p>好处 2：解决缺陷 3，方便 MLFQ 重新评定各个进程的 priority（保证 interactive / CPU-bound 相互转换的程序被分配到合适的优先级）；</p></blockquote></li><li><p><strong>Refined</strong> Rule 4（<strong>Better Accounting</strong>）：任务在<strong>当前优先级中的全部运行时间累积计算</strong>，以累积的时间长短作为是否降低优先级的评判标准；</p><blockquote><p>好处：解决缺陷 2，故意保留一个时间片剩余时间的程序，如果总 CPU 用时很长，也会被降低优先级；</p></blockquote></li></ul></li><li><p>具体实现：MLFQ 具体的参数是怎样的？怎么落实它的参数？</p><ul><li>MLFQ 应该有几个队列（几个优先级）？</li><li>时间片长短的设计：每个优先级的任务的时间片长度应该多长？</li><li>进行 Priority Boost 的频率应该如何？（既能保证不过度更新浪费资源，又能保证减小 starvation 和 changes in behavior 导致运行效率减慢的可能？）</li></ul></li><li><p>Tuning 与 微调</p><p>针对以上 tuning MLFQ 使其最大化系统性能的过程<strong>没有一个固定的最优解</strong>。大多数情况需要进行调参、凭借经验取定。</p><p>不过有一些通识的点，满足这些点的参数设计一定能够更好提升 MLFQ 的性能：</p><ul><li><p>对于<strong>高优先级的</strong>任务，分配给其的时间片时间应该更<strong>短</strong>些为佳；</p><p>它们通常较少地使用 CPU 资源，可能是 interactive 类型地任务，切换得更频繁；</p></li><li><p>对于<strong>低优先级的</strong>任务，分配给其的时间片时间应该更<strong>长</strong>些为佳；</p><p>它们通常是 CPU-bound 类型任务，分配更长的时间片能够更好地完成任务；</p></li></ul></li></ul><h1 id="Chapter-9-Y86-64-A-self-defined-ISA"><a href="#Chapter-9-Y86-64-A-self-defined-ISA" class="headerlink" title="Chapter 9. Y86-64: A self-defined ISA"></a>Chapter 9. Y86-64: A self-defined ISA</h1><blockquote><p>Y86-64 是由 CMU 教授设计，SJTU 老师改进的一种教学用指令集架构，实际生产中没有处理器使用此架构。</p><p>学习它的目的是 <strong>更好地了解 CPU 与 ISA 间的关系和实现思路，剥离开复杂的细节，从抽象角度帮助我们理解 CPU 与 ISA、软件之间的交融</strong>。</p><p>最后，为我们自己设计模拟器（simulator）、汇编器（assembler）、计算机处理器（CPU）打下基础。</p></blockquote><h2 id="9-1-Y86-64-Processor-State"><a href="#9-1-Y86-64-Processor-State" class="headerlink" title="9.1 Y86-64 Processor State"></a>9.1 Y86-64 Processor State</h2><p>我们定义 Y86-64 架构下，用于保存处理器状态（或者说程序执行状态）的由以下部件构成：</p><ul><li><p>15 只寄存器（Registers），每个大小 64 bits（除了不存在 <code>%r15</code>，其他与 x86-64 相同）；</p><blockquote><p>每个寄存器有独立且唯一的 4-bit ID：</p><p><img src="imgs2/y86-regs.png" height="125px"></p><p><code>0xF</code> 代表不使用寄存器（None），在 Y86-64 中有特殊用途。</p></blockquote></li><li><p>程序计数器（Program Counter，PC），64-bit size；</p></li><li><p>Conditional Codes，共 3 个，每个 1-bit（比 x86-64 少 CarryFlag 等 5 个 CC）；</p><ul><li><code>OF</code>: Overflow Flag，当且仅当上一次运算出现溢出时设置该位；</li><li><code>ZF</code>: Zero Flag，当且仅当上一次运算结果为 0 时设置该位；</li><li><code>SF</code>：Negative（Signed）Flag，当且仅当上一次运算结果为负数时设置该位；</li></ul></li><li><p>Status Code：记录程序运行状态的寄存器，存放一些有含义的数；</p><ul><li><code>AOK</code>: the program is executing normally (<strong>Continue</strong>).</li><li><code>HLT</code>: the processor has executed a halt instruction (<strong>Normal exit</strong>).</li><li><code>ADR</code>: the processor attempted to access <strong>an invalid memory address</strong> (<strong>Segmentation Fault</strong>).</li><li><code>INS</code>: <strong>an invalid instruction</strong> code has been encountered (<strong>IoT</strong>).</li></ul></li><li><p>Memory：程序内存。简单定义为使用 Byte 索引的存储数组。<strong>使用小端序（little-endian）存储</strong>；</p></li></ul><h2 id="9-2-Y86-64-Instructions"><a href="#9-2-Y86-64-Instructions" class="headerlink" title="9.2 Y86-64 Instructions"></a>9.2 Y86-64 Instructions</h2><p>Y86-64 下定义了 12 类处理器指令：</p><p><img src="imgs2/y86-inst.png"></p><p>Tips 1. Generic Form &amp; Encoded Representation</p><p>Tips 2. Instruction Code (first 4 bits) &amp; Function Code (second 4 bits)</p><h3 id="9-2-1-程序终止指令类-halt：0x00"><a href="#9-2-1-程序终止指令类-halt：0x00" class="headerlink" title="9.2.1 程序终止指令类 halt：0x00"></a>9.2.1 程序终止指令类 <code>halt</code>：<code>0x00</code></h3><h3 id="9-2-2-空指令类-nop：0x10"><a href="#9-2-2-空指令类-nop：0x10" class="headerlink" title="9.2.2 空指令类 nop：0x10"></a>9.2.2 空指令类 <code>nop</code>：<code>0x10</code></h3><h3 id="9-2-3-寄存器移动指令类"><a href="#9-2-3-寄存器移动指令类" class="headerlink" title="9.2.3 寄存器移动指令类"></a>9.2.3 寄存器移动指令类</h3><p><code>rrmovq rA, rB</code>：<code>0x20 0x&lt;rA&gt;&lt;rB&gt;</code>（看作无条件的 conditional move）</p><p><code>cmov&lt;XX&gt; rA, rB</code>：<code>0x2&lt;X&gt; 0x&lt;rA&gt;&lt;rB&gt;</code></p><h3 id="9-2-4-直接量-寄存器移动指令类"><a href="#9-2-4-直接量-寄存器移动指令类" class="headerlink" title="9.2.4 直接量-寄存器移动指令类"></a>9.2.4 直接量-寄存器移动指令类</h3><p><code>irmovq V, rB</code>：<code>0x30 0xF&lt;rB&gt; &lt;V&gt;</code>（2+8 bytes）</p><h3 id="9-2-5-寄存器-内存移动指令类"><a href="#9-2-5-寄存器-内存移动指令类" class="headerlink" title="9.2.5 寄存器-内存移动指令类"></a>9.2.5 寄存器-内存移动指令类</h3><p><code>rmmovq rA, D(rB)</code>：<code>0x40 0x&lt;rA&gt;&lt;rB&gt; &lt;D&gt;</code>（2+8 bytes）</p><h3 id="9-2-6-内存-寄存器移动指令类"><a href="#9-2-6-内存-寄存器移动指令类" class="headerlink" title="9.2.6 内存-寄存器移动指令类"></a>9.2.6 内存-寄存器移动指令类</h3><p><code>mrmovq D(rB), rA</code>：<code>0x50 0x&lt;rA&gt;&lt;rB&gt; &lt;D&gt;</code>（2+8 bytes）</p><p>⚠⚠ <u><strong>在 encoded representation 中，用于存储内存基地址的寄存器（在 9.2.5 和 9.2.6 中都用 <code>rB</code> 表示）ID 必须在目标寄存器 ID 之后！ </strong></u> ⚠⚠</p><h3 id="9-2-7-运算指令类"><a href="#9-2-7-运算指令类" class="headerlink" title="9.2.7 运算指令类"></a>9.2.7 运算指令类</h3><p><code>&lt;OP&gt;q rA, rB</code>：<code>0x6&lt;X&gt; 0x&lt;rA&gt;&lt;rB&gt;</code></p><h3 id="9-2-8-跳转指令类"><a href="#9-2-8-跳转指令类" class="headerlink" title="9.2.8 跳转指令类"></a>9.2.8 跳转指令类</h3><p><code>j&lt;XX&gt; Dst</code>：<code>0x7&lt;X&gt; &lt;Dst&gt;</code>（1+8 bytes）</p><p><u><strong>不支持直接跳转的 PC-relative 表示法</strong></u>，下同。</p><h3 id="9-2-9-调用指令类"><a href="#9-2-9-调用指令类" class="headerlink" title="9.2.9 调用指令类"></a>9.2.9 调用指令类</h3><p><code>call Dst</code>：<code>0x80 &lt;Dst&gt;</code> (1+8 bytes)</p><h3 id="9-2-10-返回指令类-ret：0x90"><a href="#9-2-10-返回指令类-ret：0x90" class="headerlink" title="9.2.10 返回指令类 ret：0x90"></a>9.2.10 返回指令类 <code>ret</code>：<code>0x90</code></h3><h3 id="9-2-11-寄存器进栈指令类"><a href="#9-2-11-寄存器进栈指令类" class="headerlink" title="9.2.11 寄存器进栈指令类"></a>9.2.11 寄存器进栈指令类</h3><p><code>pushq rA</code>：<code>0xA0 0x&lt;rA&gt;F</code></p><p>（在 9.3 中详细介绍）</p><h3 id="9-2-12-寄存器出栈指令类"><a href="#9-2-12-寄存器出栈指令类" class="headerlink" title="9.2.12 寄存器出栈指令类"></a>9.2.12 寄存器出栈指令类</h3><p><code>popq rA</code>：<code>0xB0 0x&lt;rA&gt;F</code></p><p>我们根据上面的定义总结出几点有价值的信息：</p><ul><li><p>Y86-64 指令集是比 x86-64 更精简的变长指令集，但每类指令内的长度固定。</p><blockquote><p>因此，机器在读指令的第一个 byte 后，就能根据指令种类确定当前指令的长度。</p></blockquote></li><li><p>条件移动指令存在于寄存器移动指令类，因为它们都是在寄存器间移动数据，<strong>它们共享前 4-bit Instruction Code</strong>；</p></li><li><p><strong>只有运算指令类可以隐式改变 Conditional Codes</strong>、运算指令也<strong>只能操作寄存器，直接量都不行</strong>；</p></li></ul><h2 id="9-3-Y86-64-Program-Stack"><a href="#9-3-Y86-64-Program-Stack" class="headerlink" title="9.3 Y86-64 Program Stack"></a>9.3 Y86-64 Program Stack</h2><p>Y86-64 架构下的程序栈与 x86-64 相近，遵循相似的 ABI：</p><ul><li>栈地址<strong>从高地址向低地址增长</strong>；</li><li>栈在 Y86-64 中也用于处理 Procedure Call 等工作；</li><li><code>%rsp</code> 寄存器仍然用作保存当前栈顶地址；</li></ul><p>此外，在 Y86-64 中的两种对栈操作的指令：</p><ul><li><code>pushq rA</code>（<code>0xA0 0x&lt;rA&gt;F</code>）:<ol><li>先减小 <code>%rsp</code>（8）；</li><li>再将 <code>rA</code> 中的数据存放到 <code>%rsp</code> 所指的位置；</li><li><strong>例外：如果 <code>pushq %rsp</code>，那么将先存放旧的 <code>%rsp</code>，再减小 <code>%rsp</code></strong>；</li></ol></li><li><code>popq rA</code>（<code>0xB0 0x&lt;rA&gt;F</code>）：<ol><li>先从 <code>%rsp</code> 指向的地址读取数据到 <code>rA</code>；</li><li>再增加 <code>%rsp</code>（8）；</li><li>例外：<strong>如果 <code>popq %rsp</code>，那么先增加 <code>%rsp</code>，再读取原来位置的数据</strong>；</li></ol></li></ul><p>⚠⚠ <u><strong>注意，无论是 <code>pushq</code> 还是 <code>popq</code>（读出还是写入）寄存器，寄存器都在 Encoded Representation 的 Function Code 的前 4-bit 内容</strong></u> ⚠⚠</p><blockquote><p>总之注意三个地方的指令的编写位置：</p><ol><li>在寄存器 - 内存间转移的 Load-Store 指令的 <code>rA</code> 和 <code>rB</code> 位置；</li><li>操作栈指令的 <code>rA</code> 与 <code>F</code> 的位置始终是寄存器位于 Function Code first 4-bit；</li><li>在直接量 - 寄存器转移的指令中，Function Code 却遵循 <code>F&lt;rA&gt;</code> 的规律；</li></ol></blockquote><h2 id="9-4-半章小结"><a href="#9-4-半章小结" class="headerlink" title="9.4 半章小结"></a>9.4 半章小结</h2><p><img src="imgs2/y86-isa1.png"></p><p><img src="imgs2/y86-isa2.png"></p><p><img src="imgs2/y86-inst-struct.png"></p><p><img src="imgs2/y86-reg-id.png"></p><p><img src="imgs2/y86-status-code.png"></p><h2 id="9-5-CPU-Design-CISC-vs-RISC"><a href="#9-5-CPU-Design-CISC-vs-RISC" class="headerlink" title="9.5 CPU Design: CISC vs RISC"></a>9.5 CPU Design: CISC vs RISC</h2><div class="table-container"><table><thead><tr><th>TYPE</th><th>CISC</th><th>Early RISC</th></tr></thead><tbody><tr><td>指令数</td><td>极多</td><td>&lt;100$^1$</td></tr><tr><td>指令耗时</td><td>差距较大</td><td>都很少$^2$</td></tr><tr><td>指令长度</td><td>可变长$^3$</td><td>定长</td></tr><tr><td>指令表示</td><td>一种运算有多种指令</td><td>仅表示运算最小完备集</td></tr><tr><td>load &amp; store</td><td>算术、逻辑运算允许内存-寄存器间</td><td>算术、逻辑运算仅允许寄存器间</td></tr><tr><td>机器级细节</td><td>hidden</td><td>exposed$^4$</td></tr><tr><td>条件判断</td><td>Conditional Codes</td><td>Test Instruction + Normal Registers</td></tr><tr><td>procedure call</td><td>少量使用 registers，集中在栈上传递$^5$</td><td>大多数交给 registers</td></tr></tbody></table></div><p>$^1$ : 很少的指令数会导致编译得到的汇编码增多；</p><p>$^2$ : RISC 指令数少、指令执行时长普遍很短，所以它们的执行时长接近，很适合 pipeline 的设计；</p><p>$^3$ : x86-64 一条指令长度在 1 ~ 15 bytes 间；</p><p>$^4$ : 将硬件层面的细节暴露给上面的软件层开发者有利有弊。由于 RISC 的精简指令简化了编译器的工作，编译器得以投入到更深层的优化上来。另一方面暴露硬件细节也会损失一定的兼容性；</p><p>$^5$ : 主要是 CISC 考虑了兼容性。因为早期的机器寄存器数量不多，使用内存栈传递参数是个明智的选择；</p><hr><p>根据上面的线索，我们能总结出 Early RISC 相对于 CISC 的优劣势：</p><ul><li>优势在于能够高效结合 Pipeline 技术、编译器开发更简单、更容易学习和通过它理解指令集架构等等；</li><li>劣势在于同一高级语言编译得到的更多汇编指令、暴露机器级细节破坏了 ISA 的封装性和程序兼容性等等；</li></ul><p>如今，新指令集没法明确地分出它属于哪一种，它们会借鉴两者的特点和原则；</p><p>例如这里的 Y86-64：</p><ul><li>既采用了 CISC 原则: Conditional Codes、变长指令；</li><li>又采用了 RISC 原则: Load/Store Arch、通过寄存器完成 Procedure Call；</li></ul><h2 id="9-5-CPU-Design-Logic-Design-amp-HCL"><a href="#9-5-CPU-Design-Logic-Design-amp-HCL" class="headerlink" title="9.5 CPU Design: Logic Design &amp; HCL"></a>9.5 CPU Design: Logic Design &amp; HCL</h2><p>复习：数字电子电路基础 - 组合时序逻辑电路。例如：</p><ul><li>多路相等比较器；</li><li>多路选择器（<code>Multiplexor</code>）；</li></ul><h3 id="Hardware-Control-Language-Syntax"><a href="#Hardware-Control-Language-Syntax" class="headerlink" title="Hardware Control Language Syntax"></a>Hardware Control Language Syntax</h3><ul><li><p>支持普通逻辑运算符；</p></li><li><p>选择器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Out = [</span><br><span class="line">    s: A;</span><br><span class="line">    1: B:// Default</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h3 id="Arithmetic-Logic-Unit-Design"><a href="#Arithmetic-Logic-Unit-Design" class="headerlink" title="Arithmetic Logic Unit Design"></a>Arithmetic Logic Unit Design</h3><ul><li>Input: X (8 bytes)、Y（8 bytes）；</li><li>Conditional Codes：<code>ZF / OF / SF</code>；</li><li>Output: Z（8 bytes）；</li></ul><h3 id="Register-Storage-Design"><a href="#Register-Storage-Design" class="headerlink" title="Register(Storage) Design"></a>Register(Storage) Design</h3><ul><li><p>Latch &amp; Flip-flop</p><blockquote><p>这里只需要知道：某种锁存器在 clock 上升沿写入输入的信号、仅输出写入的信号；</p></blockquote></li><li><p>Register File</p><p><img src="imgs2/register-design.png" height="200px"></p><p>特征：两个读端口（因为指令存在双寄存器操作），一个写端口，时钟引脚控制读写时机；<code>srcA/srcB</code> 表示读取的 register ID（4-bit），<code>valA/valB</code> 表示对应的 register 中的值；写端口 <code>dstW</code> 表示要写入的 register ID，而 <code>valW</code> 表示要写入的值；</p></li><li><p>Memory</p><p><img src="imgs2/memory-design.png" height="200px"></p><p>特征：读写端口各一个（因为不允许从内存到内存的操作），<code>error</code> 端口提示非法地址等错误，<code>read</code>、<code>write</code> 端口决定当前是读还是写（不会同时出现），时钟引脚控制读写周期；</p></li></ul><h2 id="9-6-CPU-Design-SEQ-General"><a href="#9-6-CPU-Design-SEQ-General" class="headerlink" title="9.6 CPU Design: SEQ General"></a>9.6 CPU Design: SEQ General</h2><p>本节我们在前几节电路基础、Y86-64 ISA 理论基础上构建 Y86-64 微架构，实现串行（sequential）处理器。</p><blockquote><p><code>icode</code> 不在 0 ～ B 间说明非法指令；</p><p><code>ifun</code> 也要检查，不在指令列表中的也需要报错；</p><p>但 <code>icode:ifunc</code> 以后的内容 “编码错误” 不是非法指令，因为 CPU 能够识别，应该属于软件层面的错误。</p></blockquote><h3 id="9-6-1-General-Principle"><a href="#9-6-1-General-Principle" class="headerlink" title="9.6.1 General Principle"></a>9.6.1 General Principle</h3><p>首先要知道，一个汇编指令需要很多步电路操作，所以我们设计时应该遵循如下原则：</p><ol><li>采用 Multi-stages Design，<strong>即分几步来完成一个汇编指令，思想类似函数包装</strong><span id="principle1">；</span></li><li>为了更好地利用硬件，不应该为每个指令设计一个电路，而是考虑<strong>如何让所有指令共用一套电路</strong><span id="principle2">。</span></li></ol><h3 id="9-6-2-Basic-Framework"><a href="#9-6-2-Basic-Framework" class="headerlink" title="9.6.2 Basic Framework"></a>9.6.2 Basic Framework</h3><blockquote><p>本节是上完课后总结的内容，叙述顺序进行了综合。</p></blockquote><p>根据前人的经验，Y86-64 串行处理器设计的 stage 应该分为这几个：</p><ul><li><p>Fetch：<strong>从指令内存中读取指令</strong>；</p><blockquote><p>该步允许使用的 <strong>微架构内容</strong> 如下：</p><p>值（<code>var</code>）：</p><ul><li><strong><code>PC</code></strong>：当前 PC 的值；</li><li><strong><code>icode:ifun</code></strong>：组合读入的 Instruction Code &amp; Function Code；</li><li><strong><code>rA:rB</code></strong>：组合读入的 <strong>寄存器 ID 值存放变量</strong>；</li><li><strong><code>valC</code></strong>：约定俗成认为是常数存放变量，存放 Displacement、Destination、Immediate；</li><li><strong><code>valP</code></strong>：约定俗成认为是<strong>下一个完整指令</strong>的地址，一般所有指令都要操作这个变量；</li></ul><p>表达式（<code>exp</code>）：</p><ul><li><strong>$var\leftarrow M_x[PC+\delta]$：表示将 $PC+\delta$ 地址的内存中 $x$ bytes 的指令数据取到值 $var$ 中</strong>；例如 $rA:rB\leftarrow M_1[PC+1]$；</li><li>$var\leftarrow PC+\delta$：表示将 $PC+\delta$ 的值（也就是地址）赋给值 $var$；</li></ul></blockquote></li><li><p>Decode：<strong>将寄存器值读到变量值中</strong>；</p><blockquote><p>该步允许使用的 微架构内容 如下：</p><p>值（<code>var</code>）：</p><ul><li><strong><code>rA</code>、<code>rB</code></strong>：上步取得的寄存器 ID；</li><li><strong><code>valA</code>、<code>valB</code></strong>：<strong>新的用于存放寄存器内值的 <code>var</code></strong>；</li><li><strong><code>%rsp</code></strong>：该步允许直接使用 <code>%rsp</code> 指代该寄存器内的值；</li></ul><p>表达式（<code>exp</code>）：</p><ul><li><strong><code>valA/varB &lt;- R[rA/rB/%rsp]</code>：从指定寄存器中取值到某个变量中</strong>；</li></ul></blockquote></li><li><p>Execute：<strong>进行计算地址 / 值的操作</strong>；</p><blockquote><p>该步允许使用的 微架构内容 如下：</p><p>值（<code>var</code>）：</p><ul><li><strong><code>valE</code></strong>：约定俗成存放 <strong>ALU 计算结果的 <code>var</code></strong>;</li><li><strong><code>CC</code></strong>：Condition Code；</li><li><strong><code>Cnd</code></strong>：<strong>存放本次 Condition Flag（条件是否成立信息）的 <code>var</code></strong>；</li><li><strong><code>ifun</code></strong>：此处用于判断 Function Code 的条件语义，例如确定 <code>CC</code>、确定运算符；</li></ul><p>表达式（<code>exp</code>）：</p><ul><li><strong><code>valE &lt;- valB/0 + valA/valC/8/-8</code></strong>：将运算结果写到 <code>valE</code> 中，<strong>至于为什么左边是 <code>valB/0</code>，右边是 <code>valA/valC/8/-8</code>，主要是考虑所有指令后，为了最大程度上复用电路的主意；</strong></li><li><strong><code>valE &lt;- valB ifun valA</code></strong>：表示按 <code>ifun</code> 选择，将 <code>valB</code>、<code>valA</code> 运算后赋给 <code>valE</code>（显然这个表达式是专门为了 <code>opq</code> 指令的）；</li><li><strong><code>Set CC</code></strong>：根据运算结果设置 Condition Codes，在 Y86-64 中，只有 <code>opq</code> 可以使用；</li><li><strong><code>Cnd &lt;- Cond(CC, ifun)</code></strong>：表示按 <code>ifun</code> 预期条件、<code>CC</code> 当前条件，将是否应该进行的 Condition Flag 赋给 <code>Cnd</code>；</li></ul></blockquote></li><li><p>Memory：<strong>向内存中读 / 写数据</strong>；</p><blockquote><p>该步允许使用的 微架构内容 如下：</p><p>值（<code>var</code>）：</p><ul><li><strong><code>valM</code></strong>：约定俗成用于<strong>存放从内存中取出的值</strong>；</li><li><strong><code>valA / valE / valP</code></strong>：根据代码逻辑可能会用到的 <code>var</code>（也是考虑所有指令后，为了最大程度上复用电路的主意）；</li></ul><p>表达式（<code>exp</code>）：</p><ul><li><strong>$varM \leftarrow M_x[var]$</strong>：表示以 $var$ 的值为地址，从 Memory 中取 $x$ bytes 数据放入 <code>varM</code> 中；</li><li><strong>$M_x[var_2]\leftarrow var_1$</strong>：表示将 $var_1$ 中的数据放入到 以 $var_2$ 为地址、长度为 $x$ bytes 的内存中；</li></ul></blockquote></li><li><p>Write Back：<strong>向寄存器写入数据</strong>；</p><blockquote><p> 该步允许使用的 微架构内容 如下：</p><p> 值（<code>var</code>）：</p><ul><li><strong><code>varE / varM</code></strong>：根据代码逻辑可能会用到的 <code>var</code>（也是考虑所有指令后，为了最大程度上复用电路的主意）；</li><li><strong><code>rA / rB</code></strong>：本步想要写入寄存器，必须要用到寄存器 ID 值；</li><li><strong><code>Cnd</code></strong>：可能会根据 Condition Flag 进行不同动作（例如 <code>cmovXX</code> 类指令）；</li><li><p><strong><code>%rsp</code></strong>：本步允许直接使用此符号指代该寄存器；</p><p>表达式（<code>exp</code>）：</p></li><li><p><strong><code>R[rA/rB/%rsp] &lt;- valE/valM</code></strong>：将指定位置的值赋给指定的寄存器；</p></li><li><p><strong><code>Cnd ? exp : -</code></strong>：根据 Condition Flag 决定是否执行 本步允许的表达式 <code>exp</code>；</p></li></ul></blockquote></li><li><p>PC Update：<strong>更新 PC</strong>；</p><blockquote><p>该步允许使用的 微架构内容 如下：</p><p>值（<code>var</code>）：</p><ul><li><strong><code>valP / valC / valM</code></strong>：根据代码逻辑可能会用到的 <code>var</code>（也是考虑所有指令后，为了最大程度上复用电路的主意）；</li><li><strong><code>PC</code></strong>：本步的目的就是改变它；</li><li><strong><code>Cnd</code></strong>：可能会用 Condition Flag 决定赋给 <code>PC</code> 的内容（例如 <code>jXX</code> 类指令）；</li></ul><p>表达式（<code>exp</code>）：</p><ul><li><strong><code>PC &lt;- var</code></strong>：将各种本步允许的 <code>var</code> 传给 <code>PC</code>；</li><li><strong><code>PC &lt;- Cnd ? valC : valP</code></strong>：根据 Condition Flag 决定将何种 <code>var</code> 赋给 <code>PC</code>；</li></ul></blockquote></li></ul><h3 id="9-6-3-Describe-Assembly-with-Framework"><a href="#9-6-3-Describe-Assembly-with-Framework" class="headerlink" title="9.6.3 Describe Assembly with Framework"></a>9.6.3 Describe Assembly with Framework</h3><p>有了上面的知识，我们可以把各个指令对应的微架构过程描述出来了。</p><p><code>rrmovq rA, rB</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- 0 + valA    // Save line in Write Back (We shouldn&#x27;t add &quot;valB &lt;- R[rA]&quot;)</span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[rB] &lt;- valE    // No valA in Write Back</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>cmovXX rA, rB</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- 0 + valA    // Save line in Write Back (We can&#x27;t add &quot;valB &lt;- R[rA]&quot;)</span><br><span class="line">Cnd &lt;- Cond(CC, ifun)</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">Cnd ? R[rB] &lt;- valE : -    // No valA in Write Back</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>irmovq V, rB</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valC &lt;- M8[PC + 2]</span><br><span class="line">valP &lt;- PC + 10</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">NONE</span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- 0 + valC    // Save line in Write Back</span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[rB] &lt;- valE    // No valC in Write Back</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>rmmovq rA, D(rB)</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valC &lt;- M8[PC + 2]</span><br><span class="line">valP &lt;- PC + 10</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line">valB &lt;- R[rB]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + valC</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">M8[valE] &lt;- valA</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>mrmovq D(rB), rA</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valC &lt;- M8[PC + 2]</span><br><span class="line">valP &lt;- PC + 10</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valB &lt;- R[rB]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + valC</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">valM &lt;- M8[valE]</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[rA] &lt;- valM</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>opq rA, rB</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line">valB &lt;- R[rB]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB ifun valA</span><br><span class="line">Set CC</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[rB] &lt;- valE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>jXX Dest</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">valC &lt;- M8[PC + 1]</span><br><span class="line">valP &lt;- PC + 9</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">Cnd &lt;- Cond(CC, ifun)</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"># Write Back</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">Cnd ? PC &lt;- valC : valP</span><br></pre></td></tr></table></figure><p><code>call Dest</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">valC &lt;- M8[PC + 1]</span><br><span class="line">valP &lt;- PC + 9</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valB &lt;- R[%rsp]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + -8</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">M8[valE] &lt;- valP</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[%rsp] &lt;- valE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valC</span><br></pre></td></tr></table></figure><p><code>ret</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[%rsp]  // Save line in Memory</span><br><span class="line">valB &lt;- R[%rsp]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + 8</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">valM &lt;- M8[valA]    // No valB in Memory</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[%rsp] &lt;- valE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valM</span><br></pre></td></tr></table></figure><p><code>pushq rA</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line">valB &lt;- R[%rsp]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + -8</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">M8[valE] &lt;- valA</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[%rsp] &lt;- valE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p><code>popq rA</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[%rsp]    // save line in Memory</span><br><span class="line">valB &lt;- R[%rsp]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + 8</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">valM &lt;- M8[valA]    // No valB in Memory</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[%rsp] &lt;- valE</span><br><span class="line">R[rA] &lt;- valM</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><hr><p>其中有几个要点需要着重掌握：</p><ul><li><p>Memory 中化简了 <code>valB</code>，Write Back 中化简了 <code>valA</code> 和 <code>valC</code>；</p></li><li><p><code>popq</code> 的 Write Back Stage 要保证 <code>R[rA] &lt;- valM</code> 在 <code>R[%rsp] &lt;- valE</code> 之后执行并覆盖；</p></li><li><p>电路的结果是充满管线之间的，<strong>但是只有时钟上升延才会被写入</strong>；</p><blockquote><p>这能解释为什么在 <code>opq rA, rB</code> 的 Execute Stage 中，前一步的运算不会影响到 <code>Set CC</code>：<strong>一个汇编指令执行在一个时钟周期内，一定不会相互影响</strong>。</p></blockquote></li></ul><p>再总结一下以上各个 Stage 实际用到的值情况：</p><p><img src="imgs2/used-var.png" height="350px"></p><h3 id="9-6-4-Advantages-amp-Disadvantages"><a href="#9-6-4-Advantages-amp-Disadvantages" class="headerlink" title="9.6.4 Advantages &amp; Disadvantages"></a>9.6.4 Advantages &amp; Disadvantages</h3><ul><li>简单，容易实现；</li><li>指令无法设计复杂，否则耽误其他指令时间（快指令 等 慢指令）；</li><li>电路 propagate 需要时间，导致时钟周期无法很快，进而注定了 SEQ 处理器的速度不会很快（前 stage 等 后 stage）；</li></ul><h2 id="9-7-Principles-of-Pipeline"><a href="#9-7-Principles-of-Pipeline" class="headerlink" title="9.7 Principles of Pipeline"></a>9.7 Principles of Pipeline</h2><p>Some Ideas:</p><ul><li>Multi-Stage Design：和串行处理器的思路一样，分多个独立的 Stage 完成一个 Process；</li><li>Move objects through stages <strong>in sequence</strong>；</li><li>At any given times, <strong>multiple objects being processed</strong>；</li></ul><p>我们定义：</p><ul><li><p>从头至尾执行一条指令所需的时间（不讨论 capacity），称为这条指令的 <strong>延迟（latency）</strong>；</p></li><li><p>单位时间内完成指令的数量（讨论了 capacity），称这个流水线的 <strong>吞吐量（throughput）</strong>，通常的计算方法是 1 / 时钟周期长度 / 承载量（这里 “时钟周期长度” 会受到流水线分级方法的影响）；</p><blockquote><p>吞吐量常用单位是 <code>GIPS</code>（每秒千兆条），可以用每 1 ns 内执行的指令数量进行计算。</p></blockquote></li></ul><h3 id="9-7-1-Time-Analysis-SEQ"><a href="#9-7-1-Time-Analysis-SEQ" class="headerlink" title="9.7.1 Time Analysis: SEQ"></a>9.7.1 Time Analysis: SEQ</h3><p>从之前的串行处理器开始讨论，一条指令执行的耗时情况如下：</p><p><img src="imgs2/comb-version.png"></p><ul><li>组合逻辑电路在输入后，等到电路稳定需要 300 ps（记作 “<strong>Computation Delay</strong>”）；</li><li>时钟上升沿到达后，需要 20 ps 才能确保写入 registers（记作 “<strong>Save Delay</strong>”）；</li></ul><p><strong>因此这种情况下，每个时钟周期至少 320 ps</strong>；</p><h3 id="9-7-2-Time-Analysis-N-Way-Pipelined"><a href="#9-7-2-Time-Analysis-N-Way-Pipelined" class="headerlink" title="9.7.2 Time Analysis: N-Way-Pipelined"></a>9.7.2 Time Analysis: N-Way-Pipelined</h3><p>我们考虑如下流水线的思想，将组合逻辑电路拆成多个 stage，以便使用流水线：</p><p><img src="imgs2/pipeline-idea.png" height="300px"></p><p>如果将组合逻辑电路按照流水线的 ideas，变为 <strong>3-Way Pipelined</strong>：</p><p><img src="imgs2/3-way-pipeline-version.png"></p><ul><li><p>将组合逻辑电路拆分为 3 个独立的 stage（每个 stage 平均 latency 100 ps）；</p></li><li><p>虽然 latency <strong>略微增长</strong>（由于寄存器状态切换的时间开销）：360 ps，但 Throughput 提升了；</p></li><li><p><strong>因为根据流水线思想，在一个 operation 穿过一个 stage 后，其他部分就空闲下来，并且状态已经进入中间状态 registers，因此下一条指令可以立即进入</strong>；</p><p><img src="imgs2/3-way-pipeline-state.png" height="400px"></p></li></ul><h4 id="Limitation-1-Nonuniform-Delays"><a href="#Limitation-1-Nonuniform-Delays" class="headerlink" title="Limitation 1: Nonuniform Delays"></a>Limitation 1: Nonuniform Delays</h4><p><strong>但是，我们没有考虑一个重要问题：逻辑电路划分为 stage 后，每个 stage 的 Delay 时长不一致（Nonuniform Delays）。</strong></p><p>这个时候，有些耗时短的 stage 就要等待耗时长的 stage，例如：</p><p><img src="imgs2/ununiform-delay.png"></p><p>这样我们考虑几个问题：</p><p>根据组合逻辑电路的设计，有些部分是无法继续切分的，这就告诉我们无法无限向下切分 stage。假设有一种设计如下，各个部分不能继续切分：</p><p><img src="imgs2/pipeline-example.png"></p><p>那么，考虑不同 stage 数量下的 CPU 情况：</p><ul><li>当 stage 数量为 2 时，最好的划分方法是 <code>A B C | D E F</code>，这个时候总 <code>latency = 190 * 2 ps = 380 ps</code>，<code>throughput = 1 / 190 * 1000 GIPS = 5.26 GIPS</code>；</li><li>当 stage 数量为 3 时，最好的划分方法是 <code>A B | C D | E F</code>，这个时候总 <code>latency = 130 * 3 ps = 390 ps</code>，<code>throughput = 1 / 130 * 1000 GIPS = 7.69 GIPS</code>；</li><li>当 stage 数量为 4 时，最好的划分方法是 <code>A | B C | D | E F</code>，这个时候总 <code>latency = 110 * 4 ps = 440 ps</code>，<code>throughput = 1 / 110 * 1000 GIPS = 9.09 GIPS</code>；</li><li>当 stage 数量为 5 时，最好的划分方法是 <code>A | B | C | D | E F</code>，这个时候总 <code>latency = 100 * 5 ps = 500 ps</code>，<code>throughput = 1 / 100 * 1000 GIPS = 10 GIPS</code>；</li><li>当 stage 数量大于 5 时，<code>throughput</code> 不可能比 5 个 stage 更好了，因为最大不可分割的单元已经达到 80 ps 了，意味着再增加 stage，不仅不会提升 throughput，还会延长 latency；</li></ul><p>于是我们能得到结论：</p><ul><li>最大的 throughput 不一定是在最大的 Stage 切分数取得，<strong>而是取决于 <u>最大的、不可分割的部分耗时 + 寄存器状态写入的 latency</u></strong>；</li></ul><h4 id="Limitation-2-Register-Overhead"><a href="#Limitation-2-Register-Overhead" class="headerlink" title="Limitation 2: Register Overhead"></a>Limitation 2: Register Overhead</h4><p>另外，当我们将过程切分成更多的 stage 后，loading registers 所占的时长比例愈发的大，这是我们所不希望的。</p><h4 id="Limitation-3-Data-Dependency-amp-Data-Hazard"><a href="#Limitation-3-Data-Dependency-amp-Data-Hazard" class="headerlink" title="Limitation 3: Data Dependency &amp; Data Hazard"></a>Limitation 3: Data Dependency &amp; Data Hazard</h4><p>既然使用流水线，就不可避免要考虑前后 stage 的依赖问题，例如 <strong>前一条指令的结果是后一条指令的运算数（数据依赖）、前一条指令决定后一条指令的执行位置（控制依赖）</strong>。</p><p>对于数据依赖而言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">irmovq $50, %rax</span><br><span class="line">addq %rax, %rbx</span><br><span class="line">mrmovq 100(%rbx), %rdx</span><br></pre></td></tr></table></figure><p>因此，这三条指令在流水线上的时间顺序必须是这样的，才能保证运算结果的正确性：</p><p><img src="imgs2/data-dep.png"></p><p>但是，这样又没法使用流水线，因此可以采用 <strong>中间插入其他指令</strong> 的方式缓解这种问题，具体会在实现的时候进一步讨论：</p><p><img src="imgs2/data-dep-sol.png"></p><h4 id="Limitation-4-Control-Dependency"><a href="#Limitation-4-Control-Dependency" class="headerlink" title="Limitation 4: Control Dependency"></a>Limitation 4: Control Dependency</h4><p>同样，对于控制依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">    subq %rdx, %rbx</span><br><span class="line">    jne targ</span><br><span class="line">    irmovq $10, %rdx</span><br><span class="line">    jmp loop</span><br><span class="line">targ:</span><br><span class="line">    halt</span><br></pre></td></tr></table></figure><p>于是，我们分析了实现流水线的优势、可能遇到的问题。接下来我们会在实现的介绍中，依次解决上面的几个顾虑。</p><h2 id="9-8-Pipeline-Implementation"><a href="#9-8-Pipeline-Implementation" class="headerlink" title="9.8 Pipeline Implementation"></a>9.8 Pipeline Implementation</h2><p>首先同样，根据前人的经验，我们作出如下强调：</p><ul><li><p>SEQ+ Implementations：<strong>将 <code>PC Update</code> Stage 的工作移动到 Fetch Stage（根据上一条指令的寄存器结果得到当前指令的 PC）</strong>，而 PC 不再存在一个真实寄存器中，因为只需要根据上一条指令的寄存器状态就能计算 next PC（变成了组合逻辑电路）。<strong>至此形成经典 5 级流水线的逻辑电路基础</strong>；</p><blockquote><p>New Fetch:</p><ul><li>Select current PC;</li><li>Read instruction;</li><li>Compute incremented PC.</li></ul></blockquote></li><li><p>Naïve PIPE Implementation：先忽略 Control / Data Hazard，只用 <code>nop</code> 解决；</p></li><li><p>Pipeline Feedback</p></li></ul><h3 id="9-8-1-Hardware"><a href="#9-8-1-Hardware" class="headerlink" title="9.8.1 Hardware"></a>9.8.1 Hardware</h3><p><img src="imgs2/5-stage-pipeline-impl.png" height="800px"></p><p>有几点值得注意；</p><ul><li><p>和 SEQ Implementation 不一样，每个 stage 间多了要保存的<strong>状态寄存器</strong>；</p></li><li><p>小写字母前缀表示当前 stage 阶段由控制逻辑块生成的数据，大写字母前缀表示流水线寄存器的一个字段（从上个 stage 接受的数据）；</p><p>例如：<code>D_stat</code> 表示 Decode Stage 接受上个阶段的状态输入值，<code>m_valA</code> 表示 Memory Stage 计算出的 <code>valA</code> 值；</p></li><li><p>Fetch 部分增加了 <strong>用于猜测下一条指令的寄存器 <code>predPC</code></strong>；</p></li><li><p>Decode 部分增加了 <code>Select A</code> 部件，原因是：</p><ul><li>现象：只有 call 指令会在 memory 阶段用到 <code>valP</code>，只有 jump 指令会在 execute 阶段用到 <code>valP</code>（准确说是“携带”）。这两种指令都不需要用到寄存器 A；<strong>还有一点是我们已经将 PC Update 转移到 Fetch 中，在 Fetch 阶段本身就有 Predict PC 部件。这样 <code>valP</code> 在其他场合也不需要传播到 Fetch 阶段之外的场合去</strong>；</li><li>作用：减少控制信号和寄存器的数目。即可以将这两个控制信号合并。</li></ul></li></ul><p>那么这个 implementation 是如何解决 Data / Control Hazard 的？</p><h3 id="9-8-2-Resolve-Data-Hazard-Data-Forwarding-amp-Stalling"><a href="#9-8-2-Resolve-Data-Hazard-Data-Forwarding-amp-Stalling" class="headerlink" title="9.8.2 Resolve Data Hazard: Data Forwarding &amp; Stalling"></a>9.8.2 Resolve Data Hazard: Data Forwarding &amp; Stalling</h3><p>首先对于 Data Hazard，主要的问题是：<strong>Read-after-write</strong>（write 在 read 后面则不会出现问题）。</p><p>可能引发这个问题的指令有：<code>opq</code>、<code>ir/rr/mr/rm movq</code>、<code>popq</code>。</p><p>例如对这样几条汇编而言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># demo-h0.ys</span><br><span class="line">0x000:irmovq $10,%rdx</span><br><span class="line">0x00a:irmovq $3,%rax</span><br><span class="line">0x014:addq %rdx,%rax</span><br><span class="line">0x016:halt</span><br></pre></td></tr></table></figure><p>直接考虑 5 个 stage 流水线形式进入会出现问题，如下左图：</p><p><img src="imgs2/data-hazard-example.png" width="350px"><img src="imgs2/data-hazard-nop.png" width="350px"></p><p>因为在第 3 条指令在 Decode 阶段会读取紧邻的前两条指令计算结果，而前两条指令此时正处于 Memory 和 Execute 阶段，都没有到 Write Back 阶段，这时存在 read-after-write dependency，读取数据一定是错误的。</p><p><strong>第一种尝试方法是之前提到的 插入 <code>nop</code></strong>（Naïve Design）；</p><p>一般如果 Fetch 读入一个改变下一个指令所用寄存器的指令，那么等到该指令更改寄存器位于 Write Back Stage，前后相差 3 个 stage，因此<strong>在有 Data Hazard 的两指令间插入 3 个 <code>nop</code></strong>就能解决问题，如上右图。</p><blockquote><p>考虑一下，如果只插入 2 个 <code>nop</code>，那么第三条指令只能读到 <code>%rdx</code> 中正确的值，因为第二条指令还在 Write Back 阶段没有结束；</p><p>如果只插入一个 <code>nop</code>，那么两个寄存器正确的值都读不到！</p></blockquote><p>虽然这种解决方法非常简单，可以由编译器、硬件处理器，甚至开发者来解决。但是弊端是 <strong>这会严重拖慢流水线速度</strong>。因此我们得想办法尽可能让底层硬件解决这个问题。</p><hr><p><strong>第二种尝试方法是 stalling（拖延住）</strong>；</p><p>这种方法是在 CPU 执行指令时实时进行的，具体以例子说明。假设有个程序在 Y86-64 编译器上编译后长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># demo-h2.ys</span><br><span class="line">0x000:irmovq $10,%rdx</span><br><span class="line">0x00a:irmovq $3,%rax</span><br><span class="line">0x014:nop    # 先考虑简单的情况，假设这中间有两条完全无关、不会出现 data dependency 的指令，</span><br><span class="line">0x015:nop    # 我们假装它们就是 nop 来讨论</span><br><span class="line">    # Bubble</span><br><span class="line">0x016:addq %rdx,%rax</span><br><span class="line">0x018:halt</span><br></pre></td></tr></table></figure><p>我们根据上一种方法的分析可知，现在 <code>0x016</code> 位置上的指令仍然无法读到正确的 <code>%rax</code>，还需要再等一个 clock 才行。这个时候，我们在 <code>0x015</code> 和 <code>0x016</code> 之间插入一个 “Bubble”。</p><p><strong>这个 Bubble 不会在汇编代码中出现，而是 CPU 进行了以下操作</strong>：</p><ol><li>向 <code>0x016</code> 指令（依赖未取得的指令）所在的 Stage（Decode）输入状态寄存器发送 Stalling 信号，<strong>暂停一个 clock 不允许被修改</strong>；</li><li>在向 <code>0x016</code> 指令之前的所有 stage（这里只有 Fetch）的输入状态寄存器发送 Stalling 信号（<strong>防止后来的指令 “撞到” stalling 寄存器上消失</strong>）；</li><li>由于 <code>0x016</code> 指令只是状态寄存器定住了，不正确的信号仍然会向前传递，因此 CPU 还要 <strong>将前进到 Execute Stage、但没来得及修改 CC 和 后继状态寄存器的错误指令的 <code>icode</code> 修改为 <code>1</code>，表示 <code>nop</code>，使它彻底失去作用</strong>；</li></ol><p>这种 “将其他指令的 <code>icode</code> 改为 <code>1</code> 使其成为 <code>nop</code>” 的动作所产生的不在汇编码上的 <code>nop</code> 就叫 bubble。</p><p>这样从 <code>0x015</code> 后的所有指令都会暂停一个 clock，等待 <code>0x00a</code> 指令写入寄存器。</p><p>这种方法只是将插入 <code>nop</code> 的工作移交给了硬件，没有解决速度上的问题。</p><hr><p><strong>第三种尝试方法是 data forwarding</strong>（利用 feedback paths 将后面的结果给到前面的 decode stage）；</p><p>就是说，我们让最终结果未出现前，让正确 / 可能正确的值先通过传输线传递给读的 decode 阶段；这个方法能实现，主要是因为 <strong>能读到信号要早于写入信号</strong>（前者在一个 Clock 开始的一段时间后就可读到，而后者则需要这个 Clock 结束）。</p><p>例如：</p><ul><li><code>irmovq</code> 在 Fetch 阶段就一定可以得到正确的值，后面的任意 stage 都能找到值；</li><li><code>opq</code> 在 Execute 阶段后期一定可以得到正确的值，后面的任意 stage 都能找到值；</li><li><code>ret</code> 在 Memory 阶段结束一定可以得到正确的值；</li></ul><blockquote><p>但是 Feedback Paths 不会出现在 Fetch 阶段，因为太早了，后面的指令没进入 Decode 阶段前很难使用这个结果。</p></blockquote><p>一般用 feedback paths 去解决 data hazard，主要作用在 Decode 阶段，因为这个阶段才可能会用到没有写入的寄存器值。</p><p>再考虑简单的情况，假设 <code>0x00a</code> 和 <code>0x016</code> 之间有两条无关的指令，就假设为 <code>nop</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># demo-h2.ys</span><br><span class="line">0x000:irmovq $10,%rdx</span><br><span class="line">0x00a:irmovq $3,%rax</span><br><span class="line">0x014:nop</span><br><span class="line">0x015:nop</span><br><span class="line">0x016:addq %rdx,%rax</span><br><span class="line">0x018:halt</span><br></pre></td></tr></table></figure><p>这个时候 <code>%rdx</code> 能正确读到，如果我们把 Write Back 阶段的 <code>W_valE</code>（<code>0x00a</code> 的 Write Back Stage 状态寄存器值）通过 feedback path 将信息告诉 Decode Stage 呢？比如在这种情况下，我们把 <code>W_valE</code> 接给 <code>valB</code>，就能够读到正确的值了。</p><p><img src="imgs2/data-hazard-2nop-forward.png" width="280px"><img src="imgs2/data-hazard-1nop-forward.png" width="240px"><img src="imgs2/data-hazard-forward.png" width="280px"></p><p>那我们乘胜追击，假设中间只空 1 个 <code>nop</code> 呢？这个时候产生 <code>%rax</code> 的值还在 Memory 阶段！没事，因为 <code>irmovq</code> 的结果在 Fetch 阶段就知道了嘛，我们把 <code>M_valE</code> 的值给它；</p><p>然后另一个寄存器也无法获取正确的值，就类似上个情况的 “从 Write Back 阶段 <code>W_valE</code> 到 <code>valA</code>“ 接线就行。如上中图所示。</p><p>太好了，更极限一点的话，<code>irmovq</code> 写和 <code>opq</code> 读指令不隔 <code>nop</code>，是否也能用 data forward 解决？</p><p>同样是可以的：在上一条指令处于 Execute Stage 时，我们直接将运算结果 <code>e_valE</code> 给 <code>valB</code>。来的及吗？之前都是给状态寄存器（在 Clock 开始前就等待在外），这次给结果值（Clock 开始后一段时间才能稳定），<strong>是来得及的。因为 <u>Deocde 阶段可以等，直到这个 Clock 快结束才得到都是没问题的</u>。</strong>如上右图。</p><blockquote><p>更进一步考虑，假如上面的指令不是 <code>addq %rdx,%rax</code>，而是 <code>addq %rax, %rbx</code>（前两条指令也对应变），那么寄存器情况是不是一样能这么做？</p></blockquote><p>于是我们发现，只要多加几个 feedback paths，就能解决以 <code>irmovq</code> / <code>opq</code> 为首的 RAW-Dependency 问题，不需要插入 Bubble 或者 <code>nop</code>。我们将这个成功经验拓展到其他指令上，再总结一下：</p><p>首先我们可以从这些位置提前得到寄存器的结果（Forwarding Sources）：</p><ul><li><p>Execute Stage 的计算结果 <code>valE</code>（<code>e_valE</code>）；</p><blockquote><p><strong>不能比这个早，因为上面我们讨论 <code>irmovq</code> 只是一种情况，有些指令例如 <code>opq</code> 必须等到 Execute 结束才能拿到正确的值</strong>。</p></blockquote></li><li><p>Memory Stage 的状态寄存器 <code>valE</code>、<code>valM</code>（<code>M_valE</code>、<code>M_valM</code>）；</p></li><li><p>Write Back Stage 的状态寄存器 <code>valE</code>、<code>valM</code>（<code>W_valE</code>、<code>W_valM</code>）；</p></li></ul><p>其次，我们需要判断是否应该接受 forwarding data，即分情况选择 <code>valA</code>、<code>valB</code> 的来源。<strong>哪些情况应该和平常一样直接使用寄存器的值，哪些时候又应该选择 Forwarding Sources</strong>。</p><p>为了分情况选择，我们向电路里加入了两个逻辑电路用于选择不同情况下 <code>valA</code> 和 <code>valB</code> 的取值，纠正 data hazard 问题：</p><p><img src="imgs2/data-forward-impl.png" height="800px"></p><p>这种 data forwarding 方法看似解决了问题，并且无需使用 bubble 和 <code>nop</code>，但是它还是没有考虑完全。</p><p>我们上面讨论的情况 “以 <code>irmovq</code> 写、<code>opq</code> 读为首的 RAW-Dependency” 有个前提是，<u><strong>直接相邻的两个存在 data dependency 的指令，所使用的有依赖的数据产生阶段不能晚于 Execute Stage</strong></u>，因为直接相邻说明只间隔了一个 stage。</p><p>那么可能构成 data dependency 的指令中（<code>opq</code>、<code>ir/rr/mr/rm movq</code>、<code>popq</code>），有一类是没法在 Execute Stage结束前拿到结果：<strong>从 memory 中取值的 <code>mrmovq</code>、<code>popq</code></strong>。它们必定要等到 Memory Stage 结束才能取到值！</p><p>我们将 “在取 Memory 后，立即使用此值” 的行为称作 “Load / Use Hazard”，这种情况使用 Data Forward 是无法纠正寄存器的读错误。<strong>我们必须要借助前面介绍的 Bubble 让这种连续 Load / Use 分开一个 Cycle</strong>。</p><hr><p>于是，Y86-64 针对 Data Hazard 的解决方法总结如下：</p><ul><li>对于一般的连续两条指令（分开的就更好办）数据依赖，我们可以直接使用 Data Forwarding 设计的 Feedback Paths，选择正确的值就能纠正；</li><li>对于 Load / Use Hazard（连续的从内存读、使用），我们需要在使用 Data Forwarding 的同时，<strong>向 Execute 阶段插入一个 Bubble（同时要将 Decode 和 Fetch stall 住一个 Clock 防止指令损失），以将 Load 和 Use 指令分开一个 Cycle</strong>；这两种方式结合的方法就叫 load interlock（加载互锁）。</li></ul><h3 id="9-8-3-Resolve-Control-Hazard-Part-Ⅰ-Predicting-the-PC"><a href="#9-8-3-Resolve-Control-Hazard-Part-Ⅰ-Predicting-the-PC" class="headerlink" title="9.8.3 Resolve Control Hazard Part Ⅰ: Predicting the PC"></a>9.8.3 Resolve Control Hazard Part Ⅰ: Predicting the PC</h3><p>其次，针对 Control Hazard 的解决方案也是 <strong>Feedback Paths</strong>。根据指令的特点，有几种数据能决定 next PC：</p><ul><li>Next Instruction for most cases（<code>valP</code>，一定可以预测正确）；</li><li>Call destination（<code>valC</code>，一定可以预测正确）；</li><li>Branch information，由有条件的 <code>jmp</code> 指令触发，<strong>可能预测正确</strong>；</li><li>Return point，由 <code>ret</code> 指令触发，地址位于内存，<strong>几乎一定不可预测</strong>；</li></ul><p><strong>所以可以根据这些寄存器中的值进行预先推测，猜测可能下一步可能的指令地址</strong>。</p><blockquote><p>由于上一条指令在 Fetch 之后就要读下一条指令了，所以猜测的可靠性不能保证。</p><p>如果猜测错误，就需要<strong>恢复到猜测前的状态</strong>（如何实现？后面提及）。</p></blockquote><p>对应这几种数据的特点和成功率，我们相应的有<strong>猜测策略</strong>：</p><ul><li><p>对于前两种情况而言，我们直接选择 Fetch 阶段得到的或者计算出的 <code>valC / valP</code>，一定不会出错；</p></li><li><p>对于 Conditional Jumps，<strong>我们总是猜测可能是寄存器 <code>valC</code> 中的地址（即赌本次跳转条件一定成立）</strong>。</p><blockquote><p>为什么？原因有 2 条：</p><ol><li>因为大量数据统计在 60% 的情况下的条件是成立的（Unconditional 和 Conditional Jump 只是 <code>ifun</code> 的区别；还有 <code>while</code>、<code>for</code> 循环翻译成的 <code>jmp</code> 跳转的概率更大）；</li><li>携带 <code>valP</code> 和 <code>valC</code> 的电路设计的复杂程度不一样。人们发现选择 <code>valC</code> 时电路更简单；</li></ol><p><strong>也可以通过一些数据分析的手段来精确这个过程</strong>；</p></blockquote><p>另外，我们还需要知道这次猜测是否正确，如果猜测错误还需要进行恢复。我们可以将 <code>M_Cnd</code>（Memory stage 计算得出的 Cnd flag）、<code>M_valA</code>（Memory 阶段<strong>存储的 <code>valP</code></strong>，因为有 Select A 所以放在这里）两个值通过 Feedback Paths 回接给 Select PC，让它判断是否该相信 <code>predPC</code>；</p></li><li><p>对于 Return 而言，几乎一定无法预测，那么就彻底不预测，也就是不使用 Predict PC，和其他情况一样默认 <code>valP</code>；</p><p>最终的纠错阶段就是真正的返回地址被取出的时候（Write Back state registers）；</p></li></ul><p>现在，我们根据猜测策略，将各种情况下 Next PC 的猜测值全部汇总到 Select PC 原件，让这个逻辑电路根据情况判断正确的下一条指令是什么，如下图。</p><p><img src="imgs2/pred-PC.png" height="300px"></p><h3 id="9-8-4-Resolve-Control-Hazard-Part-Ⅱ-Fix-Wrong-Predictions"><a href="#9-8-4-Resolve-Control-Hazard-Part-Ⅱ-Fix-Wrong-Predictions" class="headerlink" title="9.8.4 Resolve Control Hazard Part Ⅱ: Fix Wrong Predictions"></a>9.8.4 Resolve Control Hazard Part Ⅱ: Fix Wrong Predictions</h3><p>但是有个问题，我们按照上一节的猜测策略暂时得到了<u>可能的</u>下一条指令的执行位置，我们又如何在得到结果后发现、修复错误的猜测结果呢？</p><p><code>ret</code> 指令的结果数据在 Memory 结束、Write Back 状态寄存器才能知道，<code>jmp</code> 类指令的结果数据也要在 Execute 结束、Memory 状态寄存器才能知道。这两种指令紧邻的下一条指令在 Fetch 时（哪怕有 Data Forward）也没法得知结果，怎么办？</p><p>根据猜测策略，<code>jmp</code> 直接先猜测按照 <code>valC</code> 跳转，但是检查 <code>M_Cnd</code> 时，<code>jmp</code> 已经向前前进了 2 个 Stage 了（Fetch Finish -&gt; Execute Finish），如果 <code>M_Cnd</code> 指示符合跳转条件，那么继续执行没有问题，但是如果出错，应该怎么办？<strong>我们发现检查 <code>M_Cnd</code> 的时候，中间两个指令分别在 Decode 起点、Execute 起点，还有下一条指令刚要进入 Fetch 阶段 —— 即便 <code>jmp</code> 错误，当前也并没有产生影响（如更改 CC、写入下一个 stage 的状态寄存器）。</strong>因此很好解决：</p><p><code>jmp</code> 如果发现 <code>M_Cnd</code> 指示不应该跳转，说明预测错误，立即进行以下措施：</p><ol><li>由于 <code>jmp</code> 以后的错误指令只有两条（位于 Decode 和 Execute 开始阶段），并且没产生影响，只需要在时钟上升沿时将它们的 <code>icode</code> 改为 <code>1</code>（<code>nop</code>），就能解决错误执行的问题；</li><li>同样是上升沿阶段，将 <code>M_Cnd</code> 给到 Fetch 阶段，这个时候 Fetch 阶段就能读到正确的下一条指令；</li></ol><p><strong>所以就算 <code>jmp</code> 预测错误，有了上面的措施，也就浪费 2 个 Cycles 而已，不会造成执行语义错误</strong>！</p><p>再来看 <code>ret</code> 的跳转错误如何修复。</p><p>根据策略，<code>ret</code> 不会做猜测（一般行为遵从 Predict PC 拿到的 <code>valP</code>），直接接着这条指令向下读。但是 <code>ret</code> 和 <code>jmp</code> 不一样，不能按照原来 feedback paths 解决，因为 <code>ret</code> 拿到结果 <code>W_valM</code> <strong>要到 Memory Stage 结束，而这个时候 <code>ret</code> 向前前进了 3 个 Stage，紧跟 <code>ret</code> 的指令 Execute 已经执行结束 —— 也就是说，错误的指令改变了 CC 和后续状态寄存器，这是不允许的！</strong></p><blockquote><p>你可能会问，我们能不能早一点拿到 <code>valM</code>，比如 <code>m_valM</code>？不行，因为 <code>m_valM</code> 产生在 Clock 很后面的阶段（尤其是从内存读），Clock 时钟来不及。</p></blockquote><p>因此，我们只能采取 <strong>填充 3 个 Bubbles</strong> 的方法，避免出现错误：</p><ul><li><p>当 CPU 检测到 <code>ret</code> 指令结束 Fetch、进入 Decode Stage 时，<strong>立即向 Fetch Stage 发送 Stalling 信号，不允许 Fetch Stage 的状态寄存器被写入</strong>；</p><blockquote><p>为什么处理 <code>ret</code> 需要把 Fetch Stage Stall 住？因为任由 fetch stage 向下取的话，可能取到非法指令，改变了状态（stat）信息，给后面增添判断的麻烦，所以索性 stall 住。</p></blockquote></li><li><p>将输出到 Decode Stage 的 <code>icode</code> 改为 <code>nop</code> 的；</p></li><li><p>重复以上两个措施共 3 个 Cycles，直至 <code>ret</code> 结束 Memory Stage；</p></li></ul><p>这样，当 <code>ret</code> 结束 Memory Stage 时，时钟上升延会推动正确的返回地址数据到 Write Back Stage 的状态寄存器 <code>W_valM</code> 中，此时利用 Select PC，在 Fetch 阶段就能读到正确的下一条指令的地址了。</p><p>所以，无论如何，<code>ret</code> 后面总是要被 CPU 追加 3 个 bubble 的空隙。</p><p>综上，根据我们的<u><strong>猜测策略 和 修复措施</strong></u>，Select PC 的工作逻辑应该是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int f_PC = [</span><br><span class="line">#mispredicted branch. Fetch at incremented PC</span><br><span class="line">      M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;</span><br><span class="line">#completion of RET instruciton</span><br><span class="line">      W_icode == IRET : W_valM;</span><br><span class="line">#default: Use predicted value of PC</span><br><span class="line">      1: F_predPC</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li>当我们发现之前一条指令是 <code>jmp</code> 类，并且条件有效时，选 <code>M_valA</code>（即原封不动的 <code>valP</code> 值）；</li><li>当我们发现之前一条指令是 <code>ret</code> 时，意味着 Memory 结束、发送给 Write Back 的状态寄存器才是正确的地址（<code>W_valM</code>）；</li><li>其他的情况选择 <code>F_predPC</code>（也就是 Fetch 阶段自己算好的 <code>valP</code>）。</li></ul><hr><p>最后，总结一下 Y86-64 是如何解决 Control Hazard 的问题的：</p><ul><li>对于一般指令（不含 <code>jmp</code>、<code>call</code>、<code>ret</code>），只要让 Select PC 默认读 <code>valP</code>（在 Fetch 阶段就计算好的）就行，此后也无需检查、不存在 Wasted Cycles，因为下一条指令的位置一定是正确的；</li><li>对于 <code>call</code> 指令，只要将 Select PC 默认读 <code>valC</code>（在 Fetch 阶段就读到的）就行，此后也无需检查、不存在 Wasted Cycles，因为下一条指令的位置一定是正确的；</li><li>对于 <code>jmp</code> 指令，读到时默认跳转 <code>valC</code>，继续执行，但在 2 个 Cycles 后检查 <code>M_Cnd</code>，正确就什么都不做，不正确就将中间两条错误指令改为 <code>nop</code>，Fetch 阶段自动会读入正确地址。这种情况总共浪费 2 个 Cycles；</li><li>对于 <code>ret</code> 指令，读到时不作猜测，默认 <code>valP</code>，但是当 <code>ret</code> 进入 Decode Stage 时，Stalling Fetch Stage，并且将传给 Decode 的指令的 <code>icode</code> 改为 <code>nop</code> 的，持续 3 个 Cycles。这样 Fetch 就能通过 <code>W_valM</code> 读到正确的下一条地址。这种情况一定浪费 3 个 Cycles；</li></ul><h3 id="9-8-5-Exception-Handling-in-Pipeline"><a href="#9-8-5-Exception-Handling-in-Pipeline" class="headerlink" title="9.8.5 Exception Handling in Pipeline"></a>9.8.5 Exception Handling in Pipeline</h3><p>在之前的章节，我们介绍了 x86-64 的 Exception Control Flow，它是 OS 与硬件配合改变执行流的动作。</p><p>如果在 SEQ 设计中，我们只需更改 PC 寄存器即可。但是在 Pipeline 设计中，我们需要清理一些寄存器的值、某些 stage 的状态寄存器，才能转到指定的 ECF 地址。主要的步骤如下：</p><ol><li>打断当前程序执行流；</li><li>根据出现的事件，填入 Exception Table Base Register，找到 Exception Table 对应的 Exception Handler 地址，跳入新的执行流；</li><li>（可能）回到原来的执行流；</li></ol><p>我们这里先只考虑 <strong>同步异常（Synchronous Exceptions）</strong>。</p><p>那么可能导致同步异常的硬件层面原因有：</p><ul><li><code>halt</code> 指令；</li><li>指令请求错误的指令地址 / 数据地址；</li><li>非法指令；</li></ul><p>为了处理问题，我们还要讨论错误可能发现的位置：</p><ul><li>能在 Fetch Stage 检测的 Exceptions：<ul><li><code>jmp $-1</code>：<code>jmp</code> 非法地址；</li><li><code>.byte 0xFF</code>：非法指令；</li><li><code>halt</code>：程序终止；</li></ul></li><li>能在 Memory Stage 检测的 Exceptions：<ul><li><code>rmmovq %rax, 0x10000000000(%rax)</code>：非法内存地址；</li></ul></li></ul><p>但是，pipeline 的设计导致一些奇怪的情况：</p><p><strong>Situation 1. 异常检测顺序倒置</strong>：代码的执行流中两个错误，但是后一条错误发现时间（Fetch Stage）在前一条错误发现时间（Memory Stage）之前。导致后一条指令会先报错；</p><p><strong>Situation 2. 不应该触发的异常</strong>：异常的代码不在程序执行流内（例如 halt 以后不全是 0，有没擦干净的乱码；或者 <code>jmp</code> 的另一个不会执行的分支），但是 CPU 仍然可能读入并报错；</p><p>你可能会想，我们要模仿 SEQ，<strong>先检测到错误没事，只要我们在这条指令完全结束后（该指令到 Write Back Stage 结束）再报出错误，就能避免上面两种情况的发生</strong>。但这样做可能引发另一类问题：</p><p><strong>Situation 3. 异常指令的 Side Effect</strong>：错误指令和正常指令一起在流水线中向上传播，可能会导致 CC 被错误地修改（例如<strong>在错误指令后面的指令不应该被执行，但是它仍然更改了 CC</strong>，这会影响 Dump 的数据）；</p><p>综合以上的情况，我们总结出了解决方案：</p><ul><li><p>类比 Program Status，<strong>在每个 stage 的状态（除了 fetch）寄存器中加入 <code>stat</code> 寄存器，表示当前指令的执行情况。<code>AOK</code> 表示指令正常，<code>ADR</code> 表示指令访问错误地址，<code>HTL</code> 表示 <code>halt</code> 终止指令（方便阻止 <code>halt</code> 以后的指令的执行），<code>INS</code> 表示非法指令</strong>；</p></li><li><p>Fetch Stage 或 Memory Stage 如果能检测出错误，那么就设置到下一个阶段的 <code>stat</code> 寄存器；其余阶段（<code>Decode</code>、<code>Execute</code>）直接传递 <code>stat</code> 寄存器；</p><p>即：当异常出现时，仅仅设置状态寄存器（stat），其他正常；</p></li><li><p>如果异常到达 Memory 阶段，则为了防止错误指令影响状态寄存器或 CC，进行以下措施：</p><ol><li><p>对于非法指令，接下来向 Memory 阶段插 bubbles：即对于非法的内存操作，不允许写入内存；</p></li><li><p>立即关闭之后的 Execute 阶段写入 CC；</p></li></ol></li><li><p>如果异常到达 Write Back 阶段，则将该阶段 stall 住，抛出错误（只有在 Write-Back 阶段被触发，保证异常触发的顺序）。</p><blockquote><p>检查 <code>W_stall</code> 的条件，只需要检查 <code>W_stat</code> 就行，不需要管 <code>m_stat</code>；</p></blockquote></li><li><p>最后打断当前执行流：</p><ol><li>将 next PC 值 / 触发异常的指令 PC 压入栈中（通常和 exception <code>stat</code> 一起传递）；</li><li>使用事先固定在 ISA 中的 Exception Handler Address 跳转到 handler 中执行。</li></ol></li></ul><h3 id="9-8-5-Final-Implementation"><a href="#9-8-5-Final-Implementation" class="headerlink" title="9.8.5 Final Implementation"></a>9.8.5 Final Implementation</h3><p>我们将前几节的 Pipeline 设计的思想和注意要点结合起来，考虑设计一个 Y86-64 pipeline 处理器的最终版本。</p><h3 id="9-8-6-Performance-Analysis-Metrics"><a href="#9-8-6-Performance-Analysis-Metrics" class="headerlink" title="9.8.6 Performance Analysis: Metrics"></a>9.8.6 Performance Analysis: Metrics</h3><ul><li><p>Clock Rate</p></li><li><p>CPI (Cycles per instruction): On average, how many clock cycles does each instruction require?</p><script type="math/tex; mode=display">CPI=\dfrac{C}{I}=\dfrac{I+B}{I}=1+\dfrac{B}{I}</script><p>其中 $C$ 表示时钟 cycle 数，$I$ 为在 $C$ 个时钟 cycles 下执行的指令数，$B$ 为在 $C$ 个时钟 cycles 下插入的 bubble 数（$C=B+I$）；如果 $LP$、$MP$、$RP$ 分别代表 Load/Use Hazard、Misprediction Hazard、Return Hazard <strong>平均一条指令中出现的次数</strong>，那么：</p><script type="math/tex; mode=display">\dfrac{B}{I}=LP+MP+RP</script></li></ul><p>比如我们利用 Metrics 的指引进行优化：Speculation Execution in Fetch Logic；</p><p>考虑 PIPE CPU 的关键路径：</p><p><img src="imgs2/pipe-criticalpath.png" height="150px"></p><p>我们发现 increment 阶段是关键路径上较大的部分，它要等待 regids、valC 结果，然后执行 64-bits 的加法运算（最多 +10），所以我们可以先将前 60 bits 的数据 +1（同时保留不加、+1 的数据），然后另一部分仅仅是 4 bits 数的相加，这样可以节省串行进位加法所耗费的时间，如下图所示：</p><p><img src="imgs2/pc-improve.png" height="300px"></p><p>这样指令总体的速度都会快上一些。</p>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> CSAPP </tag>
            
            <tag> ICS </tag>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《只有我不在的城市》番评</title>
      <link href="//chat/anime-bokumachi/"/>
      <url>//chat/anime-bokumachi/</url>
      
        <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: </i> 维基百科词条、<a href="https://movie.douban.com/subject/26427106/">只有我不在的街道 (豆瓣)</a></p><p><strong>声明：本文仅代表个人主观观点，侵删。</strong></p><p><strong>【重要】本文除去剧透警戒线下部分，其他内容不含具体故事情节。</strong></p><hr><p>在我看过的一百多来部的番剧中，有的能真正扣住我心弦，这大抵是少数；现在看来大多却是 “食之无味，弃之可惜”。初中时期的我曾经浅浅尝试过一部，但是由于开头比较惊悚的画面，还有网友打上的 NTR 标签，让我一直敬而远之、束之高阁。这部番的名字是《只有我不在的城市》(僕だけがいない街) 。</p><p>距离我第一次接触它已经过了好几年的时间，我也不是当年看番只看 HE 类型的观众了。于是我鼓起勇气，在这个国庆重温了这个多年前的老动画。</p><p>本以为我每天在睡前看一小会很快就能结束，可是万万没想到，我最终却熬了大夜将其一口气补完了。没错，在我个人看来，这部番绝对算得上是能排上名的一个相当优秀的作品。下面我将从我自己的视角来讲述这个作品带给我的小小震撼。</p><h3 id="优秀的理由"><a href="#优秀的理由" class="headerlink" title="优秀的理由"></a>优秀的理由</h3><blockquote><p>注：本节几乎没有剧透内容。</p></blockquote><p>这个作品是由同名漫画动画化而来，本人先观看了动画作品，而后再了解的漫画，所以这里的评价主要是围绕着<strong>动画的表现</strong>。</p><p>在我心目中，一个番剧想要做到不淹没在其他同质化的番剧之中、“泯然众人”，达到优秀的层面，有这几点要求：<strong>世界观的架构（设定）</strong>或真实或新颖，<strong>故事逻辑</strong>清晰合理，<strong>故事情节</strong>或流畅或跌宕，<strong>人物刻画</strong>不千篇一律。</p><p>《只有我不在的城市》在这些方面看来就已经超过了许多 “流水线生产” 的番：</p><ul><li>设定上男主（悟）生活在普通城市，有 “重放” 的能力。这一点虽然和<a href="https://zh.moegirl.org.cn/%E5%91%BD%E8%BF%90%E7%9F%B3%E4%B9%8B%E9%97%A8%E7%B3%BB%E5%88%97"><strong>石头门</strong></a>的设定有些相似，但不至于落入俗套；并且在情节的加持下，真正观看的时候反而是一个比较吸引人的点；</li><li>故事的情节发展遵循唯一主线，紧密跟随男主视角；叙事节奏相当紧凑，但不慌乱，整体给人一种 “看完一集就忍不住继续下一集” 的想法；</li><li>故事对发生的事件和人物的描绘非常讲究主次和详略，对关键人物和群体的性格表现的比较丰满和立体，不会出现特意为某些角色补戏份、添加降智行为，或者套上标签和刻板印象的情况。</li><li>这部作品无论是动画还是漫画，其画风都比较戳我，颜值尚佳。</li></ul><blockquote><p>遗憾的是，最近这段时间我能找到的番剧中，达到甚至超越上面特征的可谓凤毛麟角。</p></blockquote><p>最后，还是在我<strong>个人</strong>看来，这部作品并没有让我避之不及的 NTR 元素，纯爱战士也能够无伤通关，所以别因为这一点而停下你观赏的脚步。至于原因我会在后面分析，这毕竟是比较主观的方面，一千个人眼中有一千个哈姆雷特嘛。</p><p>🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧 ⚠⚠⚠ <strong>剧透警告</strong> ⚠⚠⚠ 🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧</p><h3 id="故事的主线梳理"><a href="#故事的主线梳理" class="headerlink" title="故事的主线梳理"></a>故事的主线梳理</h3><p>这里简短地回顾一下在动画中的叙事内容。</p><p>首先 29 岁的男主 <strong>藤沼悟</strong> 出生于 1977 年 3 月 2 日，刚登场时看起来发表过一些漫画作品，在披萨店 <code>Oasi Pizza</code> 打工。他的 “重放” 能力能够倒退时间（自身无法控制），回到事件（<strong>通常是坏事件</strong>）未发生的时候。</p><p><img src="imgs/z_1.jpg" height="300px"></p><p>2006 年，<strong>悟</strong> 在某次在打工中途借助了能力救下了一位小学生，恰巧被披萨店的同事 <strong>片桐爱梨</strong> 看见。虽然受到了轻伤，但他的母亲 <strong>藤沼佐知子</strong> 因为担心他，而决定暂时搬过来照顾他。一日，打工回来的他目睹母亲死亡的现场，却被当作凶手通缉。情急之下 <strong>悟</strong> 无意间触发了 “重放” 而回到了 1988 年，也就是自己就读于市立美琴小学的时期。这是 <strong>悟</strong> 从最开始的时间线跳跃到第二条时间线。</p><p>为了解决发生在上个时间线上的小学生连续诱拐事件，同时想办法避免母亲的死亡（据主角推测，是因为目前猜出当年的真正凶手，才惨遭毒手），<strong>悟</strong> 想尽办法与 <strong>雛月加代</strong>（连环案中第一个遇害的学生）处好关系，却在生日（主角推算的案发时间）过后的第二天失踪——这仅仅将她的遇害时间延迟到了 3 月 3 日。到此，主角的所做的努力以失败告终。</p><p><img src="imgs/z_2.jpg" height="300px"></p><p>在 <strong>悟</strong> 结束 “重放”，回到第二个时间线的 2006 年时，他仍然是警方通缉的对象。在与警察的周旋中，<strong>片桐爱梨</strong> 坚信 <strong>悟</strong> 不是弑母凶手，帮助 <strong>悟</strong> 躲避警察追捕。也正因如此，她被真正的犯人纵火困于居住地而昏迷，最后被 <strong>悟</strong> 和 <strong>高桥店长</strong> 救出。在 <strong>爱梨</strong> 住院期间，为了避开警方监视，她拜托母亲伪装，自己逃出意愿与 <strong>悟</strong> 会面，提供了真凶可能是 <strong>西园学</strong>（原名 八代学，1988 年是 悟 的小学班主任）的线索。紧接着 <strong>悟</strong> 继续 “重放”，回到 3 月 2 日 <strong>加代</strong> 未遇害的第三条时间线。</p><p><strong>悟</strong> 在第三条时间线上成功阻止了 3 人被害，但真凶，就是当时的 <strong>八代学</strong>，设圈套利用被孤立的 <strong>柳原美里</strong> 骗 <strong>悟</strong> 并使其溺水成为植物人的状态。15 年后在医院苏醒，在取回记忆后，识破 <strong>西园学</strong>（以前的 八代学）的诡计，并用计让 <strong>西园学</strong> 坦白罪行。</p><p><img src="imgs/z_3.jpg" height="300px"></p><p>故事的最后，<strong>西园学</strong> 被逮捕，而 <strong>悟</strong> 成为了人气漫画家，在桥下躲雪与 <strong>爱梨</strong> 相遇，全剧终。</p><h3 id="番剧内容补充"><a href="#番剧内容补充" class="headerlink" title="番剧内容补充"></a>番剧内容补充</h3><p>事实上，这个动画刷完后，我还有一些地方不是很理解，或者说突兀，例如 八代学 的作案动机等。根据网友的解答，这和动画版删改的细节有关。</p><p>漫画中曾提到，八代学 的哥哥是一个三观扭曲的罪犯，在他的影响下，八代学 小时候就将朋友赠送的数只仓鼠尽数处决。不仅如此，漫画中还交代了他还是个非常缜密的罪犯，他只会找几个特质的人进行处决：“孤立”、“无助”、“不关心他人”、“孩童”，这些人在他的眼中仿佛是 <strong>攀于蛛丝上的犍陀多</strong>（用典 “蜘蛛之丝”）。他想要看到他所处决的对象对于生命执著的样子，而他能从中取得 “快乐”。而且他每处决一人之前，都会先做好缜密的计画，包含了如何取得被害人信任，以及怎样消除能追到他的证据，甚至是如何把这些罪行推到无关的人身上。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="imgs/3_1.jpg" width="350px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="imgs/3_2.jpg" width="350px" align=center></div></div></div></div><p>至于为什么 八代学 在 悟 破坏了他的计划后的 15 年内都没有犯罪，这在漫画中有所暗示，其实不是如此。他设计抹除了他入赘的议员女儿的男朋友，之后入赘到这个议员家里面改姓 “西园”，之后又设计做了岳父，取得了他的人脉后当上议员。接下来靠著议员的身份一直在观察 悟，希望他能够苏醒后亲手处决他。</p><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>这部带给我的不仅仅是绮丽的画风、引人入胜的紧凑剧情以外，我更喜欢的是作者笔下的人情世故。</p><p>悟 坐在 八代学 的车上说，“我想要弥补人心中的空缺”。在成长过程中，我们可能或多或少遇到这样那样的缺失——应该说却没说出口的话，应该保护却没有保护好的人，应该挺身而出却逃避的事……悟 心中的心结之一就是没能在那天夜晚叫上 加代 回家，这样很可能她就不会遇害了。</p><p><img src="imgs/0_k.jpg" height="300px"></p><p>通过 “重放” 回到以前的 悟，卸下以往不关心他人的面具，29 岁的灵魂也勇于说出 “成为正义的伙伴” 的豪言壮语，勇敢地保护同伴，让追求正义地精神感染了身边地同伴，以实际行动弥补过去地遗憾和后悔。虽然最后 悟 在第三条时间线上牺牲了自己 18 年的青春，换来的是伙伴们的安然无恙，算是呼应了作品的标题 “只有我不在的城市”。</p><p>作者通过这种方式，向我们传递了 “悟以往之不谏，知来者之可追” 的人生态度。尽管我们多多少少心怀遗憾，心想 “如果当时这么做就好了”，但也希望我们像假面超人一样的坚韧不拔。我们无法回到过去，但我们拥有未来。愿我们不被胆怯束缚，敢闯敢拼，不留遗憾。</p><p>悟 的母亲 佐知子 也是一个让我印象深刻的人物。尽管警察没有采用 悟 的证言，她在看到 悟 坚定的眼神和解释后，选择相信 悟，并且在第一时间线的 18 年中都一直联系媒体同事追查真凶，即使案件已过追诉时效。</p><p><img src="imgs/0_s.jpg" height="300px"></p><p>在三时间线的最后，悟 在成为植物人的 15 年间，母亲 佐知子 在商店打工照顾 悟，日复一日，她也坚信自己的儿子有一天终将会醒来。动画中，制作组给到的无声的镜头，例如母亲望向柜面上浓重的黑眼圈，独自坐在在公园长椅上，注视着前方熙攘的人群。很难想象，这 15 年里究竟是什么支撑着母亲、又是什么给予母亲继续的希望。想到这里，一种酸楚的感觉仿佛涌上心头。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="imgs/0_1.jpg" width="350px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="imgs/0_2.jpg" width="350px" align=center></div></div></div></div><p>在作者和制作组的笔下，佐知子 这位观察力敏锐、行动力强、坚强善良和极富舐犊之情的母亲形象跃然纸上。</p><p>作品的最后，加代 没有成为 悟 的妻子，这固然是一个遗憾，但这又未尝不是这个作品情节和设计的新颖之处呢？在漫画的外传中，加代 无比感激 悟 为她所做的一切，每天都去 悟 所在的医院协助 佐知子 帮 悟 进行肌肉按摩，一直与他谈学校的故事。直到上了国中以后，悟 更换了病房，善意的 佐知子 给 加代写了封信，一方面是感谢 加代 能给 佐知子 希望，另一方面则是希望加代能把握 “现在”，找到属于自己的另一半。</p><p>这样的设计的情节却更加真实，不落窠臼，也是让我眼前一亮的优点。就像网友所说，“悟选择奋不顾身地去拯救加代，不是出于对加代的爱慕，而是童年时对正义超人的憧憬，和由于过去无法挽救加代而一直深埋潜意识的挥之不去的愧疚”。所以说，<strong>战胜恶龙的勇者需要的或许不是那位被拯救的公主</strong>。这也是这部作品脱离千篇一律的 “包饺子” 结局的一个重要特征。</p><p><img src="imgs/0_0.jpg" height="300px"></p><blockquote><p>从这个角度来看，这个作品（叠甲：<strong>在我个人看来</strong>）是没有 NTR 的成分的，至少我的第一印象如此。并不是所有的结局都是理想直至虚无缥缈的 “大团圆”。</p></blockquote><p>另外插一嘴，动画制作组真的细节，在 11 集的 OP 中移除了 悟 的身影，暗示着 悟 成功更改了时间线，这是只有 悟 不存在的城市。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="imgs/1_1.jpg" width="350px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="imgs/1_2.jpg" width="350px" align=center></div></div></div></div><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="imgs/2_1.jpg" width="350px" align=center></div><div class="group-picture-column" style="width: 50%;"><img src="imgs/2_2.jpg" width="350px" align=center></div></div></div></div><hr><p>最后，喜欢这部动画的观众可以找到对应的漫画（44 话 + 外传）进行进一步阅读，相信会有不一样的感受😉</p>]]></content>
      
      
      <categories>
          
          <category> chat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anime </tag>
            
            <tag> Appreciation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Notes Basic</title>
      <link href="//review/csapp-basic/"/>
      <url>//review/csapp-basic/</url>
      
        <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: </i> <a href="http://www.cs.cmu.edu/~213/schedule.html">CMU - 213</a>, <i>Computer Systems A Programmer’s Perspective 3rd Edition</i> by Randal Bryant, David O’Hallaron</p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p><i>内容很长，写起来很慢</i> 😳</p><hr><span id="more"></span><h1 id="Chapter-0-Intro"><a href="#Chapter-0-Intro" class="headerlink" title="Chapter 0. Intro"></a>Chapter 0. Intro</h1><h2 id="0-1-Ints-are-not-Integers-Floats-are-not-Reals"><a href="#0-1-Ints-are-not-Integers-Floats-are-not-Reals" class="headerlink" title="0.1 Ints are not Integers, Floats are not Reals"></a>0.1 Ints are not Integers, Floats are not Reals</h2><ul><li>$x^2\ge 0$：int（32-bit）may overflow；</li><li>$a+(b+c)=(a+b)+c$：floats may discard some “unsignificant” digits；</li></ul><h2 id="0-2-Learn-Assembly-but-never-write-it"><a href="#0-2-Learn-Assembly-but-never-write-it" class="headerlink" title="0.2 Learn Assembly but never write it"></a>0.2 Learn Assembly but never write it</h2><h2 id="0-3-Memory-Matters-Unbounded"><a href="#0-3-Memory-Matters-Unbounded" class="headerlink" title="0.3 Memory Matters: Unbounded"></a>0.3 Memory Matters: Unbounded</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125; <span class="type">struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">struct_t</span> t;</span><br><span class="line">    t.d = <span class="number">3.14</span>;</span><br><span class="line">    t.a[i] = <span class="number">109390032</span>;</span><br><span class="line">    <span class="keyword">return</span> t.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// func(0)/func(1) -&gt; 3.14</span></span><br><span class="line"><span class="comment">// func(2)    -&gt; 3.13...</span></span><br><span class="line"><span class="comment">// func(6)    -&gt; segment fault</span></span><br></pre></td></tr></table></figure><ul><li>C/C++ don’t provide <strong>any</strong> memory protection（out of bounds/invalid pointer/abuse of malloc-free）: can lead to nasty bugs.</li></ul><h2 id="0-4-There’s-more-to-performance-than-asymtotic-complexity"><a href="#0-4-There’s-more-to-performance-than-asymtotic-complexity" class="headerlink" title="0.4 There’s more to performance than asymtotic complexity"></a>0.4 There’s more to performance than asymtotic complexity</h2><p>(有比渐进复杂度更能够优化性能的做法)</p><ul><li>渐进复杂度中没有体现的“常数”也很重要；</li><li>应该在多方面优化性能：算法、数据结构表示、代码过程、循环等；</li><li><strong>Understand system to optimize performance</strong>;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyij</span><span class="params">(<span class="type">int</span> src[<span class="number">2048</span>][<span class="number">2048</span>], dst[<span class="number">2048</span>][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2048</span>; ++j)</span><br><span class="line">            dst[i][j] = src[i][j];        <span class="comment">// Row first.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyji</span><span class="params">(<span class="type">int</span> src[<span class="number">2048</span>][<span class="number">2048</span>], dst[<span class="number">2048</span>][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2048</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; ++i)</span><br><span class="line">            dst[i][j] = src[i][j];        <span class="comment">// Column first.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In a particular machine it was about close to 20 times difference in performance! (4.3ms vs 81.8ms) </span></span><br><span class="line"><span class="comment">// Memory hierachy: Cache memory</span></span><br></pre></td></tr></table></figure><h2 id="0-5-Computers-do-more-than-execute-programs"><a href="#0-5-Computers-do-more-than-execute-programs" class="headerlink" title="0.5 Computers do more than execute programs"></a>0.5 Computers do more than execute programs</h2><ul><li>They need to get data in &amp; out: I/O system;</li><li>They communicate with each other over network;</li></ul><h1 id="Chapter-1-Bits-Bytes-and-Integers"><a href="#Chapter-1-Bits-Bytes-and-Integers" class="headerlink" title="Chapter 1. Bits, Bytes and Integers"></a>Chapter 1. Bits, Bytes and Integers</h1><h2 id="1-1-Everythings-is-bits"><a href="#1-1-Everythings-is-bits" class="headerlink" title="1.1 Everythings is bits"></a>1.1 Everythings is bits</h2><blockquote><p>本部分知识零碎，应该在数电 + 初级数据结构中接触。</p></blockquote><ul><li>Each bit is 0 or 1;</li><li>By encoding/interpreting sets of bits in various ways;</li><li>Why bits? - Electronic Implemetation.<ul><li><strong>Easy to store</strong> with bistable elements.</li><li><strong>Reliably transmitted</strong> on noisy and inaccurate wires.</li></ul></li><li><strong>Base 2 Number Representation</strong></li><li><p>1 Byte = 8 bits；</p><ul><li>Binary: $00000000_2$ to $11111111_2$；</li><li>Decimal: $0_{10}$ to $255_{10}$；</li><li>Hexadecimal: $00_{16}$ to $FF_{16}$；<ul><li>掌握快速 16 进制转 2 进制：$1010=A,\space1100=C,\space1111=F$，B/D/E 在其中；</li></ul></li></ul></li><li><p>Data Representation in C language</p><table>    <tr>        <td>C Data Type</td>        <td>Typical 32-bit</td>        <td>Typical 64-bit</td>        <td>x86-64</td>    </tr>    <tr>        <td>char</td>        <td>1</td>        <td>1</td>        <td>1</td>    </tr>    <tr>        <td>short</td>        <td>2</td>        <td>2</td>        <td>2</td>    </tr>    <tr>        <td>int</td>        <td>4</td>        <td>4</td>        <td>4</td>    </tr>    <tr>        <td>long</td>        <td>4</td>        <td>8</td>        <td>8</td>    </tr>    <tr>        <td>float</td>        <td>4</td>        <td>4</td>        <td>4</td>    </tr>    <tr>        <td>double</td>        <td>8</td>        <td>8</td>        <td>8</td>    </tr>    <tr>        <td>long double</td>        <td>N/A</td>        <td>N/A</td>        <td>10 / 16</td>    </tr>    <tr>        <td>pointer</td>        <td>4</td>        <td>8</td>        <td>8</td>    </tr></table><ul><li><strong>注：单位 bytes，CSAPP 关注 x86-64 架构</strong>；</li><li><strong>注2：Intel x86-64 处理器的 <code>long double</code> 定为 10 bytes，但数据增量是 16 bytes，意味着会浪费 6 bytes 的存储空间</strong>；</li><li><strong>注3：pointer 值就是虚拟空间的地址，上面也正说明了 32 位和 64 位的名字的来源：这些虚拟内存的地址是 32 bits / 64 bits 长度的值</strong>；我们常说的 32 位机器、64 位机器就是指对应地址值的长度是 32/64 bits；</li></ul></li></ul><h2 id="1-2-Boolean-Algebra"><a href="#1-2-Boolean-Algebra" class="headerlink" title="1.2 Boolean Algebra"></a>1.2 Boolean Algebra</h2><ul><li><p>Developed by George boole in 19C, “True”: 1, “False”: 0;</p></li><li><p>Operations: And(<strong>\&amp;</strong>) / Or(<strong>|</strong>) / Not(<strong>~</strong>) / Exclusive-or(<strong>Xor, ^</strong>);</p><ul><li>Exercise: Operate on Bit Vectors;</li></ul></li><li><p><strong>Example: Representing &amp; Manipulating Sets</strong></p><ul><li><p>Representation: <strong>Width <code>w</code> bit vector can represent subsets of <code>&#123;0,...,w-1&#125;</code></strong>;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp; &lt;=&gt; Intersection</span><br><span class="line">| &lt;=&gt; Union</span><br><span class="line">^ &lt;=&gt; Symmetric Difference</span><br><span class="line">~ &lt;=&gt; Complement</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Shift Operations</p><ul><li>left shift、right shift；</li><li>logic shift：Fill with “0”；</li><li>arithmetic shift：if (negetive) Fill with “1”，else Fill with “0”；</li><li><strong>Undefined Behavior</strong>: shift amount <strong>&lt; 0</strong> or shift amount <strong>≥ word size</strong>；</li></ul></li></ul><h2 id="1-3-原码-true-form-、反码-1’s-complement-、补码-2’s-complement"><a href="#1-3-原码-true-form-、反码-1’s-complement-、补码-2’s-complement" class="headerlink" title="1.3 原码(true form)、反码(1’s complement)、补码(2’s complement)"></a>1.3 原码(true form)、反码(1’s complement)、补码(2’s complement)</h2><ul><li><p>补码速译：<strong>最高位权重变为负值</strong>；</p></li><li><p>Unsigned range：$0\sim 2^w-1$；</p><p>Two’s complement range：$-2^{w-1}\sim2^{w-1}-1$；</p></li><li><p><strong>模 8 运算：保留补码后三位</strong>；</p></li><li><p>Exercise 1: <strong>Mapping between signed &amp; unsigned</strong></p><p>（将同一个数码看作不同的数，例如 11111111 可以表示 unsigned 的 255，也可以表示 signed -1，这两者相同的数码被称为 “<strong>相同的位模式（bit pattern）</strong>”）</p><blockquote><p>这对计算机很重要，因为它原本不知道是 signed 还是 unsigned；</p></blockquote></li><li><p>Exercise 2: <strong>Casting Surprises</strong>（模糊的常数给定，什么时候类型转换？怎么转换？）</p><ul><li><p>什么时候：C++ 书中说，在赋值、比较时进行<strong>隐式类型转换（implicit casting）</strong>，还可以进行强制类型转换；</p></li><li><p>怎么转换：</p><ol><li><p>占用空间小的类型向大的类型转换：<strong>同时有 unsigned int 和 int，则向 unsigned int 转换</strong>（隐式类型转换）；</p><p>⚠ <strong>隐式类型转换转换唯一需要注意的点：“原来是什么，后来还是什么”。例如，<code>int</code> 向 <code>unsigned long</code>、<code>unsigned</code> 向 <code>long</code>是否会 signed / zero extension，取决于原来的数是否有正负。</strong></p></li><li><p>Bit pattern（位模式）保持不变；</p></li></ol></li><li><p>编程的麻烦：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// situation 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="built_in">func</span>(a[i]);</span><br><span class="line"><span class="comment">// situation 2</span></span><br><span class="line"><span class="comment">// 提示：sizeof 的返回值会被编译器认为是 size_t (unsigned long)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i - <span class="built_in">sizeof</span>(<span class="type">char</span>) &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="built_in">func</span>(a[i]);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Exercise 3: <strong>Sign Extension</strong>（在不改变值的情况下，将 w-bit 数变为 w+k-bit (k∈Z) 数）</p><ul><li><p><strong>Expanding Conclusion: Make k copies of MSB in signed, but fill “0” in unsigned.</strong></p><blockquote><p>想想为什么。</p></blockquote></li><li><p><strong>Truncating Conclusion: mod $2^w$ in unsigned,  很像 mod $2^w$ 但不是 in signed (negative or positive)</strong>;</p></li></ul></li></ul><h2 id="1-4-Operations"><a href="#1-4-Operations" class="headerlink" title="1.4 Operations"></a>1.4 Operations</h2><ul><li><p>Unsigned Addition: $sum=UAdd_w(u,v)=u+v\mod2^w$（为什么成立？<strong>Truncating Conclusion</strong>）；</p><ul><li>一种溢出，这种溢出是模运算可以描述的；</li></ul><blockquote><p>e.g., $(unsigned)13+5=1101_2+0101_2\Rightarrow0010_2$ (<strong>Truncated</strong>)</p></blockquote></li><li><p>Two’s complement Addition: $sum=TAdd_w(u,v)=UAdd_w(u,v)$（<strong>equal in bit pattern</strong>, <strong>Truncating Conclusion</strong>）;</p><ul><li>两种溢出：负溢出（$sum\le-2^{w-1}$ 时）和 正溢出（$sum\ge w^{w-1}$ 时）;</li></ul></li><li><p>Unsigned Multiplication: $multi=UMult_w(u,v)=u\cdot v\mod2^w$（与加法同理）;</p></li><li><p>Signed Multiplication Multiplication: $multi=TMulti_w(u,v)=UMulti_w(u,v)$（与加法同理）;</p></li></ul><blockquote><p>这意味着计算机的乘法、加法可以共用硬件；</p></blockquote><ul><li><p>Shift &amp; Power-of-2 Multiply / Divide: 原因可以看作改变权重；</p><ul><li><p>Unsigned: no problem；</p></li><li><p>Signed: <strong>Use arithmetic shift. Add a bias（偏移量 1）to bit pattern and then right shift</strong></p><blockquote><ol><li><p>为什么用 <strong>算数移位</strong>？因为 <strong>Expanding Conclusion</strong>；至于什么移位，C++ 标准没有明确说，但绝大多数机器都会算术移位；</p></li><li><p>为什么要偏移量？使结果向大数舍入；</p></li></ol></blockquote></li></ul></li><li><p>Negative（取相反数，当然只有 signed 做得到）：<strong>flip all the bits and then add 1</strong>（“~” 取反 + 1）</p></li><li><p>在介绍完移位运算后，回忆 1.3 中的 “编程麻烦”，能不能不用 unsigned，通通用 signed （全用补码表示）不就不会出现这些 casting suprises 了吗？确实，C++ 中尽量别用 unsigned，容易出问题；</p><blockquote><p>Java 就是这么做的。取消了 unsigned 的类型，<strong>并且禁止了某些隐式类型转换</strong>。但因为某些其他的需求，Java 不得不引入算数移位（&gt;&gt;&gt; 和 &lt;&lt;&lt;），就是 C++ 中处理 signed divide 的运算符;</p></blockquote><p><strong>但 unsigned 也有用处</strong>：</p><ul><li>取模运算：利用 unsigned 加法溢出特性；</li><li>使用 bits 来代表集合（1.2）；</li></ul></li></ul><h2 id="1-5-Miscellaneous"><a href="#1-5-Miscellaneous" class="headerlink" title="1.5 Miscellaneous"></a>1.5 Miscellaneous</h2><ul><li><p><strong>2 的幂次数大小估算</strong>：因为 $2^{10}\approx10^3$，这意味着每 3 位十进制数和 10 位二进制数相当，所以 $2^{20}\approx10^6$；</p></li><li><p>segmentation fault 的产生：64-bits pointer 让程序认为真的有 $2^{64}$ bit 的内存空间，但实际上并不是。所以当程序访问到操作系统未给它分配的内存时，会抛出 segmentation fault；</p></li><li><p><strong>字长究竟是多大</strong>：不确定。一般是由一种语言中指针表示的范围、存储器上最大存储块大小决定。例如 64 位机器就是擅长 64-bits 计算、指针大小 64-bits 的机器；<strong>因此一个程序的位数是由硬件和编译器共同决定的</strong>；</p><blockquote><p>所以 64 位机器可以运行 32 位程序（向后兼容）；</p><p>考虑内存对齐，32-bits 下字长相当于 4 bytes，64-bits 下字长相当于 8 bytes；</p></blockquote></li><li><p>Byte Ordering</p><ul><li><p>Big Endian（大端序）：<strong>现在常出现的地方就是 Internet，即当发送 32-bits 数据包时</strong></p><ul><li>Least significant byte has highest address（前面的 bits 排在地址靠前的位置，符合人类习惯）；</li></ul></li><li><p>Little Endian（小端序）：<strong>目前支持主流操作系统的处理器都能用小端序</strong></p><ul><li>Least significant byte has lowest address（前面的 bits 排在地址靠后的位置）</li></ul></li><li><p>Representing of integers</p><ul><li><p>Example of <code>01234567</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address: 0x100 0x101 0x102 0x103</span><br><span class="line">big       :  0123  4567</span><br><span class="line">little :  67    45  2301</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Representing of pointers</p></li><li><p>Representing of strings: Every machine is <strong>the same</strong>; (ended by ‘\\0’);</p></li></ul></li></ul><h2 id="1-6-Puzzles"><a href="#1-6-Puzzles" class="headerlink" title="1.6 Puzzles"></a>1.6 Puzzles</h2><p>Initialization:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">foo</span>();</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">bar</span>();</span><br><span class="line"><span class="type">unsigned</span> ux = x;</span><br><span class="line"><span class="type">unsigned</span> uy = y;</span><br></pre></td></tr></table></figure><ul><li><p>$x\lt0\Rightarrow(x*2\lt0)$ ? </p><blockquote><p>False, $x=TMin$ (negative overflow) ?</p></blockquote></li><li><p>$ux\ge0$ ?</p><blockquote><p>True;</p></blockquote></li><li><p>$x\space\And\space7==7\Rightarrow(x&lt;&lt;30)\lt0$ ?</p><blockquote><p>True, $(x&lt;&lt;30)==-2^{31}+2^{30}\lt0$;</p></blockquote></li><li><p>$ux\gt-1$ ?</p><blockquote><p>Always False, implicit casting：$(unsigned)(-1)=(\sum\limits_{k=0}^{31}2^k)_{10}\Longrightarrow\forall x((unsigned)x\le(unsigned)(-1))$;</p></blockquote></li><li><p>$x\gt y\Rightarrow-x\lt-y$ ?</p><blockquote><p>False, $y==TMin\Rightarrow-y==TMin$.</p><p>So: $\forall x(y==TMin\rightarrow -x\ge-y)$</p></blockquote></li><li><p>$x*x\ge0$ ?</p><blockquote><p>False. Positive overflow.</p></blockquote></li><li><p>$x\gt0\space\And\And\space y\gt0\Rightarrow x+y\gt0$ ?</p><blockquote><p>False. Positive overflow.</p></blockquote></li><li><p>$x\ge0\Rightarrow-x\le0$ ?</p><blockquote><p>True.</p></blockquote></li><li><p>$x\le0\Rightarrow-x\ge0$ ?</p><blockquote><p>False, $x==TMin\Rightarrow-x==TMin$.</p></blockquote></li><li><p>$(x|-x)&gt;&gt;31==-1$ ?</p><blockquote><p>False. $x==0$ ?</p></blockquote></li></ul><h1 id="Chapter-2-Floating-Point"><a href="#Chapter-2-Floating-Point" class="headerlink" title="Chapter 2. Floating Point"></a>Chapter 2. Floating Point</h1><h2 id="2-1-Fractional-Binary-Numbers"><a href="#2-1-Fractional-Binary-Numbers" class="headerlink" title="2.1 Fractional Binary Numbers"></a>2.1 Fractional Binary Numbers</h2><ul><li><p>Limitations: Can only exactly represent numbers of the form $x/2^k$; Other rational number have repeating bit representations.</p></li><li><p>IEEE Floating Point</p><ul><li><p>Numerical form: $(-1)^s\cdot M\cdot2^E$;</p><blockquote><ul><li>Sign bit $s$ determines whether number is positive or negative;</li><li>Significand（尾数，Mantissa） M normally a fractional value in $[1.0,2.0)$;</li><li>Exponent E weights value by power of 2;</li></ul></blockquote></li><li><p>Single precision: 32-bits</p><p>$s$: 1-bit; $exp$: 8-bits; $frac$: 23-bits;（$s$、$exp$、$frac$ 代表对应的数据域而已，下略）</p></li><li><p>Double precision: 64-bits</p><p>$s$: 1-bit; $exp$: 11-bits; $frac$: 52-bits;</p></li><li><p><strong>Normalized values</strong>:</p><ul><li><p>$exp$ 不全为 0，也不全为 1；</p></li><li><p>$exp$ coded as a biased value: $E=Exp-Bias$;</p><p>$Exp$: <strong>unsigned</strong> value of exp field.</p><p>$Bias=2^{k-1}-1$, where <strong>$k$ is number of exponent bits</strong>（当前 $exp$ 字段的 bit 长度，非常巧妙）</p><blockquote><p>为什么这么设定 Bias？</p><p>Single precision’s bias: 127（Exp: 1…254, E: -126…127）</p><p>Double precision’s bias: 1023（Exp: 1…2046, E: -1022…1023）</p></blockquote><p><strong>考虑为什么 $E$ 要这么表达？因为这么做比较起来非常方便</strong>（$Exp$ 0000… 最小，1111…最大）；</p></li><li><p>Significand $M$ coded with implied leading 1: $M = (1.xxxx…x)_2$</p><p>$xxxx…x$: bits of $frac$ field（0000…0最小，此时 M = 1；1111…1最大，此时 $M=2-\varepsilon$）</p><blockquote><p><strong>由于前导 1，normalized value 只能表示绝对值 $[2^{1-Bias},(2-2^{-bitsOfFrac})\cdot2^{2\cdot Bias})$ 范围的 floating point</strong>；</p></blockquote></li><li><p>理解：像科学计数法，$2^E$ 相当于十进制中的 $10^E$，用于移位，前面的 $M$ 规定具体数值；</p></li></ul></li><li><p><strong>Denormalized values</strong>:</p><ul><li><p>$exp$ 全为 0；</p></li><li><p>$exp$ coded as: $E=1-Bias$;（<strong>可以理解为此时 $exp$ 字段全 0 本身没意义，它们的个数来表示 $Bias$ 进而表示 $E$</strong>）</p></li><li><p>Significand $M$ coded with implied leading 0: $M=(0.xxx…x)_2$;</p><p>$xxx…x$: bits of $frac$ field;</p><blockquote><p>注意，这里会发现可以表示 “+0” 和 “-0”；⚠ 在比较大小和判断的时候要当心！</p><p><strong>denormalized value 只能表示绝对值 $[0,2^{1-Bias})$ 范围的 floating point</strong>；</p></blockquote></li></ul></li><li><p><strong>Special values</strong>:</p><ul><li>$exp$ 全为 1；</li><li>这种编码<strong>只有两种情况</strong>：<ol><li>$frac$ 域全为 0：代表 $\infty$;</li><li>$frac$ 域不全为 0：代表 $NaN$（not a number），例如 $\sqrt{-1}$、$\infty-\infty$、$\infty\times0$ 等；</li></ol></li></ul></li></ul><blockquote><p>这样规定就会发现，浮点数<strong>恰好可以溢出到 $\pm\infty$</strong>，而且错误数恰为 $NaN$；</p><p>Visualization： <img src="imgs/float_visualization.png"></p><p>想要理解上面规定的原因还可以用少量的数位来模拟，<strong>你会发现之前的设定非常巧妙</strong>：</p><p>（这里以 $s$: 1-bit，$exp$: 4-bits，$frac$: 3-bits 为例）</p><p><img src="imgs/float_range.png" height="350"></p></blockquote></li><li><p>Special Properties of IEEE Encoding</p><ul><li>FP（Floating Point）zero same as Integer zero（<strong>All bits = 0</strong>）；</li><li>Can <strong>almost（except NaN）</strong> use <strong>unsigned integer comparison</strong>；<ul><li>Must first compare sign bits；</li><li>Must consider <strong>-0 = +0</strong>；</li><li>What should comparison with NaN yield？</li><li><strong>Otherwise OK ($+\infty$ 和 $-\infty$ 都能与数比较)</strong>；</li></ul></li></ul></li><li><p>Exercise: <strong>write float pointing in bit-level representation</strong>;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> F = <span class="number">15213.0</span>;</span><br></pre></td></tr></table></figure><ul><li>$15213_{10}=11101101101101_2=1.1101101101101_2\times2^{13}$</li><li>$M=1.1101101101101_2$, $frac=11011011011010000000000_2$</li><li>$E=13$, $Bias=127$, $Exp=E+Bias=140_{10}=10001100_2$;</li><li>$Normalized\space value=01000110011011011011010000000000$</li></ul></li></ul><h2 id="2-2-The-Operations-for-Floating-Point"><a href="#2-2-The-Operations-for-Floating-Point" class="headerlink" title="2.2 The Operations for Floating Point"></a>2.2 The Operations for Floating Point</h2><ul><li><p>Basic idea</p><ol><li>First compute exact result;</li><li>Make it fit into desired precision<ul><li>possibly overflow if exponent too large;</li><li>possibly <strong>round</strong> to fit into $frac$;</li></ul></li></ol></li><li><p>Rounding for base 10 numbers</p><ul><li><p>Towards zero（向 0 舍入）；</p></li><li><p>Round down（向下舍入）；</p></li><li><p>Round up（向上舍入）；</p></li><li><p>Nearest Even（default）</p><blockquote><p>即 <strong>四舍六入五成双</strong>，见概率统计；</p><p>超过一半都是 “六” 的情况，少于一半都是 “四” 的情况，正好一半看最后保留位的奇偶；</p></blockquote></li></ul></li><li><p>Rounding Binary number: Nearest Even 与 普通十进制数思路相同；</p><blockquote><p>举例：Round to nearest 1/4（2 bits right of binary point）：</p><p>$10.00011_2\Rightarrow 10.00_2$，$10.00110_2\Rightarrow10.01_2$，</p><p>$10.11100_2\Rightarrow11.00_2$，$10.10100_2\Rightarrow10.10_2$；</p></blockquote></li><li><p>FP Multiplication: $multi=(-1)^s\cdot M\cdot2^E=(-1)^{s_1}\cdot M_1\cdot 2^{E_1}\cdot(-1)^{s_2}\cdot M_2\cdot2^{E_2}$</p><ul><li>Sign $s=s_1\space^\wedge\space s_2$;</li><li>Significand $M=M_1\times M_2$;</li><li>Exponent $E=E_1+E_2$;</li><li><strong>Fixing</strong><ol><li>If $M\ge2$，shift $M$ right, increment $E$; (<strong>That’s why  $M\lt 2$</strong>) </li><li>If $E$ out of range ($Exp$ out of range), overflow;</li><li>Round $M$ to fit $frac$ precision;</li></ol></li></ul></li><li><p>FP Addition: $sum=(-1)^s\cdot M\cdot2^E=(-1)^{s_1}\cdot M_1\cdot2^{E_1}+(-1)^{s_2}\cdot M_2\cdot2^{E_2}$. (assume $E_1\gt E_2$)</p><ul><li>Sign $s$, Significand $M$: <strong>Result of signed align &amp; add</strong>;</li><li>Exponent $E$: <strong>the same as $E_1$, which means $E_2$ will be ignored if $E_1\gt\gt E_2$</strong>;</li><li><strong>Fixing</strong><ol><li>If $M\ge2$, shift $M$ right, increment $E$;</li><li>If $M\lt1$, shift $M$ left $k$ positions, decrement $E$ by $k$; (<strong>The difference between multiplication</strong>)</li><li>If $E$ out of range, overflow;</li><li>Round $M$ to fit $frac$ precision;</li></ol></li></ul></li><li><p><strong>Mathematical Properties of FP addition / multiplication</strong>:</p><ul><li>具备交换律 (commutative)，不具备结合性 (associative)：舍入的不准确性和溢出、大数和小数之和会丢失小数、大数和大数乘积会变为 $\infty$；</li><li>Every element has additive inverse (相反数) <strong>except for infinites \&amp; NaNs</strong>；</li><li>几乎具备单调性 (Monotonicity): $a\ge b\Rightarrow a+x\ge b+c$ <strong>except for infinites \&amp; NaNs</strong>;</li></ul><blockquote><p><strong>总而言之，在考试时，忘记这些问题不大，想要快速判断是否满足某个定律，只需找特殊：$\infty$、$NaN$、overflow、0，这四者是大多数特例的来源</strong>；</p></blockquote></li></ul><h2 id="2-3-Floating-Point-in-C"><a href="#2-3-Floating-Point-in-C" class="headerlink" title="2.3 Floating Point in C"></a>2.3 Floating Point in C</h2><ul><li><p><code>float</code>（single precision），<code>double</code>（double precision）；</p></li><li><p>Conversions / Casting:</p><ul><li><p><strong><code>int</code>、<code>double</code>、<code>float</code> 间的转换会改变 bit representation</strong>；</p><blockquote><p>回忆 signed 和 unsigned 间的转换，不改变 bit pattern，只是改变某些位置的解释方式；</p></blockquote></li><li><p>implicit casting 发生在占用小空间的类型（int）向占用大空间类型（double）转换，也可显式声明；</p><ul><li><code>int -&gt; double</code>: <strong>准确转换。因为 <code>int</code> 大小小于 53-bits</strong>；</li><li><code>int -&gt; float</code>: <strong>Will rounding according to rounding mode</strong>；</li></ul></li><li><p>显式类型转换 <code>double/float -&gt; int</code></p><ul><li>Truncates (截断) fractional part;</li><li>Like rounding toward 0 (<strong>可以看作向 0 舍入</strong>);</li><li>Not defined when out of range / NaN: <strong>Generally sets to <code>TMin</code></strong>;</li></ul></li></ul></li></ul><h2 id="2-4-Puzzles"><a href="#2-4-Puzzles" class="headerlink" title="2.4 Puzzles"></a>2.4 Puzzles</h2><p>initialization:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = ...;</span><br><span class="line"><span class="type">float</span> f = ...;</span><br><span class="line"><span class="type">double</span> d = ...;</span><br><span class="line"><span class="comment">// Assume neither d nor f is NaN;</span></span><br></pre></td></tr></table></figure><ul><li><p>$x==(int)(float)x$ ?</p><blockquote><p>False; (int)x -&gt; (float)x (rounded)</p></blockquote></li><li><p>$x==(int)(double)x$ ?</p><blockquote><p>True;</p></blockquote></li><li><p>$f==(float)(double)f$ ?</p><blockquote><p>True;</p></blockquote></li><li><p>$d==(double)(float)d$ ?</p><blockquote><p>False; (double)d -&gt; (float)d (rounded)</p></blockquote></li><li><p>$f==-(-f)$ ?</p><blockquote><p><strong>True. Even $f==\pm\infty$ is true.</strong></p></blockquote></li><li><p>$2/3==2/3.0$ ?</p><blockquote><p>False; $(int)2/3=0$, $(double)2/3.0=0.666…67$;</p></blockquote></li><li><p>$d\lt0.0\Rightarrow(d*2\lt0.0)$ ?</p><blockquote><p><strong>True; Even $d*2==-\infty$ is true.</strong></p></blockquote></li><li><p>$d\gt f\Rightarrow-f\gt-d$ ?</p><blockquote><p>False; $d==+\infty$ or $f==-\infty$ ?</p></blockquote></li><li><p>$d*d\ge0.0$ ?</p><blockquote><p><strong>True. Even $d==\pm\infty\Rightarrow d*d==+\infty$ is true.</strong></p></blockquote></li><li><p>$(d+f)-d==f$ ?</p><blockquote><p>False; $d&gt;&gt;f\Rightarrow(d+f)\approx d$;</p></blockquote></li></ul><blockquote><p>C1 &amp; C2 结束，请完成 Data Lab！</p></blockquote><h1 id="Chapter-3-Machine-Level-Programming-Ⅰ-Basics"><a href="#Chapter-3-Machine-Level-Programming-Ⅰ-Basics" class="headerlink" title="Chapter 3. Machine-Level Programming Ⅰ- Basics"></a>Chapter 3. Machine-Level Programming Ⅰ- Basics</h1><blockquote><p>和前面说的一样，本章不会教学一段段写汇编，只要求看懂 GCC 输出的汇编代码即完成任务；</p><p><strong>本章涉及的机器语言运行在 Intel x86-64 机器上</strong>；</p></blockquote><ul><li><p>两种机器代码</p><ul><li>计算机实际运行的目标代码（一串字节编码处理器执行的指令，难以阅读）；</li><li>汇编代码：过去用于直接对机器进行编程，现在是编译器输出的目标。</li></ul><blockquote><p>以后说 “机器代码”，有时指第一种（目标代码），有时指第二种（文本格式的汇编代码），它们两者概念几乎相同，可替换。不过为了防止混淆以后对第二种会说 “汇编代码”。</p></blockquote></li></ul><h2 id="3-1-History-of-Intel-processors-and-architectures"><a href="#3-1-History-of-Intel-processors-and-architectures" class="headerlink" title="3.1 History of Intel processors and architectures"></a>3.1 History of Intel processors and architectures</h2><ul><li><p>什么是 Intel 的 x86-64？</p><blockquote><p>x86 是指 Intel 自己的 x86 processors，因为 Intel 这个系列的第一张处理器芯片的代号是 8086（产于 1978）。</p><p>随着时间推移，这个系列的芯片不断添加特性、升级演进；Intel 自己跳过了 81 系列，推出过 8286、8386系列等，都是以 86 结尾，所以被称为 x86。</p><p>后面的 64 表示这是 64-bits 的机器；</p></blockquote></li><li><p>什么是 <code>CISC</code> 和 <code>RISC</code>？</p><ul><li>Reduced Instruction Set Computer（<code>RISC</code>，精简指令集计算机）：一类装备改良的机器指令集的计算机，思想较新；</li><li>Complex Instruction Set Computer（<code>CISC</code>，复杂指令集计算机）：在 <code>RISC</code> 出现后，<code>RISC</code> 开发者把之前的使用旧指令集的计算机统称为 <code>CISC</code>，所以这个概念出现在本体之后，带有贬义；</li></ul><blockquote><p>Intel 采用的是 <code>CISC</code>，CSAPP 中介绍的这方面的知识还是不全面，想要进一步了解 <code>CISC</code> 需要自己阅读 <code>CISC</code> 手册；</p></blockquote></li><li><p>Intel 芯片的进化</p><ul><li><p>8086: 1978, 5-10 MHz;</p><blockquote><p>First 16-bit Intel processor.</p><p>1 MB Address space.</p></blockquote></li><li><p>386: 1985, 16-33 MHz</p><blockquote><p>First 32-bit Intel processor, referred to as IA32（Intel Architecture 32），占据了极大市场份额；<strong>现在不教它了，因为有更新的 x86-64</strong>;</p><p>Added “flat addressing”，capable of running <strong>UNIX</strong>；</p></blockquote></li><li><p>Pentium 4E（奔腾 4E）: 2004, 2800-3800 MHz</p><blockquote><p>First 64-bit Intel x86 processor, referred to as x86-64;</p><p><strong>收到了产品反馈：性能功耗问题，发热严重，不能无限制增加处理器时钟频率</strong>，开始着手多核处理器（一个芯片上放多个独立处理器）；</p></blockquote></li><li><p>Core 2: 2006, 1060-3500 MHz</p><blockquote><p>First multi-core Intel processor;</p></blockquote></li><li><p>Core i7: 2008, 1700-3900 MHz</p><blockquote><p>Four cores processor;（至今性能也不错）</p></blockquote></li></ul></li><li><p>什么是缓存？<strong>大致定义是 a temporary memory used to hold the most recently accessed data</strong>;</p></li><li><p>2015 年的 Intel 芯片架构</p><p><img src="imgs/chip_in_2015.png" height="400"></p><ul><li><code>DDR</code> 接口是连接到主存储器（DRAM，Dynamic Random Access Memory）的通道；</li><li><code>PCI</code> 接口是与外围设备（peripheral devices）的连接通道；</li><li><code>SATA</code> 接口是与不同类型硬盘的连接通道；</li><li><code>Ethernet</code> 接口是网络接口；</li></ul><blockquote><p>结论：集成到单个芯片上的不仅仅是处理器本身，还有很多逻辑单元所组合起的有机整体；</p></blockquote></li><li><p>Intel 的竞争对手：AMD（Advanced Micro Devices）</p><ul><li>总是跟在 Intel 后面发展，同级别的芯片稍微有点慢，但便宜的多；</li></ul></li><li>什么是 ARM？<ul><li>除了 Intel 公司的 x86 类型的处理器，当前常用的、比较主流的另一类处理器是 ARM（Acron RISC Machine），CSAPP 不会深入涉及；</li><li>创造这种处理器及其对应指令集（RISC）的原公司已经破产，但指令集写的很棒，能自定义，功耗比同水准的 x86 处理器更低。</li><li>所以后继者建立了一个公司，但这个公司不销售处理器，只向众多公司销售 ARM 的设计许可权。因此，ARM 处理器是很多芯片厂商（尤其 Intel）生产的芯片的<strong>一部分</strong>，因为 ARM 的优势而被用在方方面面；</li></ul></li></ul><h2 id="3-2-C-Assembly-Machine-code"><a href="#3-2-C-Assembly-Machine-code" class="headerlink" title="3.2 C, Assembly, Machine code"></a>3.2 C, Assembly, Machine code</h2><blockquote><p>本节只是概述一下整个 C、汇编语言、机器语言的<strong>产生过程</strong> 和 <strong>宏观样貌</strong>。</p><p>具体对汇编代码的学习内容在下一节。</p></blockquote><h2 id="3-2-1-Definitions"><a href="#3-2-1-Definitions" class="headerlink" title="3.2.1 Definitions"></a>3.2.1 Definitions</h2><ul><li><strong>Architecture (also ISA: Instruction Set Architecture)</strong>: The <strong>parts</strong> of a processor design that  one needs to understand or write assembly/machine code.<ul><li>架构是处理器设计的一部分。开发硬件的人员在考虑设计机器和对应机器语言的时候，想到了将 “指令集架构” 这层抽象出来。<strong>例如针对某个寄存器，特定的指令集等</strong>，相当于驱动硬件的接口，将<strong>微架构</strong>和机器码隔离开。这样，硬件设计者只需要关心微架构，上层的设计者需要关注机器语言以及更抽象的语言就行。</li><li>开发人员需要了解，以此来编写对应的汇编码、机器语言，以至对应平台的编译器；</li><li>examples:<ul><li>Intel: x86, IA32, Itanium, x86-64;</li><li>ARM: (Name is itself) Used in almost all mobile phones.</li></ul></li></ul></li><li><strong>Microarchitecture: Implementation of the architecture.</strong><ul><li>例如：缓存大小设计、内核频率设计。CSAPP 中也涉及的很少；</li></ul></li><li>Code Form<ul><li>Machine Code: The byte-level programs that a processor executes;</li><li>Assembly Code: A text representation of machine code.</li></ul></li></ul><h2 id="3-2-2-Assembly-Machine-Code-View"><a href="#3-2-2-Assembly-Machine-Code-View" class="headerlink" title="3.2.2 Assembly/Machine Code View"></a>3.2.2 Assembly/Machine Code View</h2><ul><li><p>Programmer-Visible State（在机器语言中需要开发者了解、操作的一些量，含有与真实硬件相关的细节）：</p><ul><li><p>PC (Program Counter, 程序计数器)</p><ol><li>Get the address of next instruction;</li><li>Called “RIP” (in x86-64);</li></ol></li><li><p>Register file: <strong>Heavily used program data</strong>（汇编程序中绝大多数数据存放的位置）;</p></li><li><p>Condition Codes（状态代码，存放于<strong>状态寄存器</strong>）</p><ol><li>存储绝大多数当前最近的算数/逻辑运算的状态信息；</li><li>数据用来判断状态分支；</li></ol></li><li><p>Memory</p><ol><li>由地址组织的 byte 数组，<strong>实际上是用一种不同方式（这个实现的方式以后的章节会详细介绍）实现的虚构对象，完成操作系统和硬件间的协作，因此称为虚拟内存（Virtual Memory）</strong>，所以这使得虽然内存（硬件上实际的内存又称为<strong>物理内存，Physical Memory</strong>）在硬件上可能是零碎的，但汇编开发者看起来的却是一大块可以按地址成块使用的。每个程序都有自己独立的字节数组来访问数据。</li><li>存放代码、用户信息；</li><li>使用堆栈数据结构来支持步骤；</li></ol><blockquote><p>这里解释一下经常提到的<strong>缓存（Cache）</strong>，缓存是指一个动作，就是将最近访问的数据存储到<strong>高速缓存器</strong>（I/O 远快于普通寄存器和外存储器，但造价高，所以容量小）中。下一次访问<strong>相同</strong>数据时，会直接进入高速缓存器中，速度会更快。</p><p>但是<strong>“缓存”</strong>这个动作对汇编开发者而言<strong>也是不可见（invisible）的</strong>，这是写在硬件中的动作（前面说的 microarchitecture），即使在汇编层面也没有专门的指令，无法操作。</p></blockquote></li></ul></li><li><p>C 代码如何转变为 <code>Object Code</code></p><ul><li>在 GNU Tutor 中曾经介绍过从源文件到目标文件的过程；</li><li><strong>C 源文件（*.c, text）</strong> <u>编译器（compiler, C 一般用 gcc）</u>编译为 <strong>ASM 源文件（*.s, text）</strong>，再交给<u>汇编器（assembler，一般用 gcc/as）</u> 汇编为 <strong>目标文件（*.o, binary）</strong>，最后交给<u>链接器（linker，一般用 gcc/ld）</u> 链接用到的第三方静态库，最终变为可执行文件；</li><li>剩余还有一部分是动态链接库，要么自己写并且编译，放置在指定位置，要么用的是系统环境中的库，在程序运行时动态加载。</li></ul></li><li><p>举例说明：下面以一个简单的 C 程序为例，演示其汇编代码及含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: sum.c</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">plus</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sumstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = plus(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">long</span> y = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">long</span> z;</span><br><span class="line">    sumstore(x, y, &amp;z);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld + %ld --&gt; %ld\n&quot;</span>, x, y, z);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在运行 <code>gcc -Og -S sum.c</code>。</p><ul><li><code>-Og</code> 参数是较新的参数，与 <code>-On</code>（n=0，1，2，3） 优化不一样，为开发人员提供了易读的中间汇编码；另外，如果不加 <code>-O</code> 参数，就什么都不优化，那么代码同样难以阅读；</li><li><code>-S</code> 参数意味着 <code>gcc</code> 套件将仅运行到产生汇编代码（<code>*.s</code>）就停止；</li></ul><p>找到代表 <code>sumstore</code> 函数的 asm 代码，以函数名 + 冒号开头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sumstore:</span><br><span class="line">    pushq%rbx</span><br><span class="line">    .seh_pushreg%rbx</span><br><span class="line">    subq$32, %rsp</span><br><span class="line">    .seh_stackalloc32</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    movq%r8, %rbx</span><br><span class="line">    callplus</span><br><span class="line">    movl%eax, (%rbx)</span><br><span class="line">    addq$32, %rsp</span><br><span class="line">    popq%rbx</span><br><span class="line">    ret</span><br><span class="line">    .seh_endproc</span><br><span class="line">    .def__main;.scl2;.type32;.endef</span><br><span class="line">    .section .rdata,&quot;dr&quot;</span><br></pre></td></tr></table></figure><p>这里注意开头含有 <code>.</code> 的操作<strong>实际不是原先代码的部分，它们与一些其他信息有关</strong>。例如为调试器提供行号的、为链接器提供信息表示全局函数的等等。一开始可以不用太过于在意这些，为了演示方便，这里直接删掉说明，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sumstore:</span><br><span class="line">    pushq%rbx; %rbx 表示访问名为 rbx 的寄存器，pushd 表示数据压入memory栈</span><br><span class="line">    subq$32, %rsp</span><br><span class="line">    movq%r8, %rbx</span><br><span class="line">    callplus; 调用函数名为 plus 的函数</span><br><span class="line">    movl%eax, (%rbx); 移动值</span><br><span class="line">    addq$32, %rsp</span><br><span class="line">    popq%rbx; 将栈中值弹出到 名为 rbx 的寄存器中</span><br><span class="line">    ret; 当前函数结束，返回</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-3-Assembly-Characteristics-Data-Types"><a href="#3-2-3-Assembly-Characteristics-Data-Types" class="headerlink" title="3.2.3 Assembly Characteristics: Data Types"></a>3.2.3 Assembly Characteristics: Data Types</h2><ul><li>“Integer” data of 1,2,4, or 8 bytes（不同的整型数据类型，不区分符号）<ul><li>Data types / Address（untyped pointers）</li></ul></li><li>Floating point data of 4,8, or 10 bytes（浮点数处理方式不同，使用不同的寄存器组，之后详细提）</li><li><strong>在汇编层面不存在聚合结构（aggregate types）</strong>，例如数组、结构体，因为它们是在编译器层面人工设计的，本质上就是连续的一段内存，以后也会实现；</li></ul><h2 id="3-2-4-Assembly-Characteristics-Operations"><a href="#3-2-4-Assembly-Characteristics-Operations" class="headerlink" title="3.2.4 Assembly Characteristics: Operations"></a>3.2.4 Assembly Characteristics: Operations</h2><ul><li>Perform arithmetic function on register or memory data（<strong>算术运算</strong>在存储器上的数据）</li><li>Transfer data between memory and register（在内存和寄存器间<strong>转移数据</strong>）<ul><li>load data from memory to register</li><li>store register data into memory</li></ul></li><li>Transfer control（汇编代码<strong>流程控制</strong>）<ul><li>Unconditional jumps to/from procedures</li><li>Conditional branches</li></ul></li></ul><h2 id="3-2-5-Assembling-amp-Disassembling-Object-Code-At-first-glance"><a href="#3-2-5-Assembling-amp-Disassembling-Object-Code-At-first-glance" class="headerlink" title="3.2.5 Assembling &amp; Disassembling Object Code: At first glance"></a>3.2.5 Assembling &amp; Disassembling Object Code: At first glance</h2><p><strong>先来看 C code 到 汇编语言/机器语言的过程</strong>。</p><p>当汇编代码被 assembler（汇编器）汇编为目标代码时，这时所能看到的就只有二进制序列了。接下来还以之前的 <code>sum.c</code> 中的 <code>sumstore</code> 函数为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x0400595:    # 表示本函数段从 0x0400595 处开始</span><br><span class="line">    0x53# 每一条指令长为 1/3/5 bytes，整段函数的长度为 14 bytes</span><br><span class="line">    0x48</span><br><span class="line">    0x89</span><br><span class="line">    0xd3</span><br><span class="line">    0xe8</span><br><span class="line">    0xf2</span><br><span class="line">    0xff</span><br><span class="line">    0xff</span><br><span class="line">    0xff</span><br><span class="line">    0x48</span><br><span class="line">    0x89</span><br><span class="line">    0x03</span><br><span class="line">    0x5b</span><br><span class="line">    0xc3</span><br></pre></td></tr></table></figure><p>这里每条指令只做一件事。以 <code>sumstore</code> 函数中的一个语句为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*dest = t;    <span class="comment">/* Store value t where designated by dest. */</span></span><br><span class="line">            <span class="comment">/* 这里加信号的含义是取 dest 所指向的地址 */</span></span><br></pre></td></tr></table></figure><p>对应这条汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq %rax, (%rbx)</span><br></pre></td></tr></table></figure><p>对应这条目标代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x40059e:    48 89 03</span><br></pre></td></tr></table></figure><p>这里 <code>t</code> 或某些 local variables 会存储于寄存器中（例如上面表示它在寄存器 <code>%rax</code> 中），而 <code>dest</code> 指针值自己也被存储于寄存器中（上面表示 <code>dest</code> 自身的值存于 <code>%rbx</code> 中）；</p><p>这里的 <code>(%rbx)</code> 表示 <code>Memory[%rbx]</code>，即 <code>%rbx</code> 值所代表的地址在 <code>Memory</code> 中的位置；</p><p><code>mov A, B</code> 指令就是将值从 A 处移动到 B 处。上面的汇编语句连起来就是：<strong>将存放于 <code>%rax</code> 中的值移动到 <code>%rbx</code> 所代表 Memory 地址的位置上</strong>；</p><p>根据汇编器翻译，这条指令只用了 3 bytes 来编码：<code>48 89 03</code>；</p><hr><p><strong>再来看机器语言到汇编语言的反汇编过程（disassembling）</strong>。</p><p>反汇编的实现和汇编一样，后者是将文本版本（汇编代码）转换为字节码（机器代码）的形式表示，前者将字节码对应解释成易读的文本即可。</p><p>如果当前没有源文件，甚至没有汇编代码，那么可以由<strong>反汇编器（disassembler）</strong>来将目标代码（*.o）<strong>或者</strong>可执行程序（已链接库的目标代码）转换成汇编代码（*.s）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d <span class="built_in">sum</span> &gt; sum.d <span class="comment"># 反编译之前的 sum 程序，-d 将可执行部分反汇编显示到 stdout</span></span><br></pre></td></tr></table></figure><p>值得注意的是，在汇编代码的层次下，<strong>无法</strong>再向上还原到源文件（*.c），因为其中的函数/变量名、都在汇编过程丢失了，只剩下一些寄存器的名称和 Memory 地址。</p><p>上面使用 <code>objdump</code> 可以得到真正意义上的汇编代码（从机器代码转换而来），此外还有一种方法：使用 <code>gdb</code>。</p><p>如果使用 <code>gdb</code> 打开目标可执行文件，运行 <code>disassemble &lt;funcName&gt;</code> 就可以对可执行文件中对应的函数区域进行反汇编。但只显示这些指令的地址 + 翻译指令，不显示字节级的编码。</p><h2 id="3-3-Assembly-Basics"><a href="#3-3-Assembly-Basics" class="headerlink" title="3.3 Assembly Basics"></a>3.3 Assembly Basics</h2><h2 id="3-3-1-The-names-for-integer-registers"><a href="#3-3-1-The-names-for-integer-registers" class="headerlink" title="3.3.1 The names for integer registers"></a>3.3.1 The names for integer registers</h2><p>下面列举 x86-64 architecture 的 <strong>整数型寄存器（Integer Register）</strong>。</p><p><img src="imgs/registers_in_x86_64.png" height="400px"></p><p>如图，这些寄存器共有 16 个，名字大致分为 2 类，一类是字母表示的（ax/bx/…），另一类是数字表示的（8/9/…）。</p><p>目前一个 x86-64 架构的 integer register 总大小有 64-bit。鉴于对以前 32-bit 机器和程序的向前兼容（backwards compatibility），汇编语言允许使用一个寄存器的<strong>不同部分</strong>，怎么用取决于指令。</p><p>对于字母类名称的寄存器（如上图左），如果使用<strong>前缀 <code>%r</code></strong>（例如 <code>%rax</code>），那么这个整型寄存器将保存 <strong>64-bit</strong> 大小的整型数据（即使用全部空间）；如果使用<strong>前缀 <code>%e</code></strong>（例如 <code>%eax</code>），那么这个整型寄存器将保存 <strong>32-bit</strong> 大小的整型数据（即从低位开始使用 32 bits，又称为 <strong>low-order 32-bit</strong>）。</p><p>对于数字类名称的寄存器（如上图右），前缀必须是 <code>%r</code>。如果不加后缀，表示保存 <strong>64-bit</strong> 大小的整型；如果使用<strong>后缀 <code>d</code></strong>，那么将保存 <strong>32-bit</strong> 大小的整型。</p><p>在这些寄存器中，可以使用指令存取数据，<strong>而且这些是机器级编程，和具体机器的型号密切相关，每步即必须清楚指出从哪个寄存器到哪个寄存器</strong>。</p><p>在 x86-64 架构下，最常见的是 64-bit register 的使用，其次是 low-order 8-bit 的使用（用在条件控制中，这个会在下一章介绍）。因此，除非提及，下面默认的 register 全部是以 <code>%r</code> 为前缀的 16 个寄存器。</p><hr><p>下面补充一些历史信息，帮助理解这些寄存器奇怪的（quirky）名字：</p><p>在早期 IA32 架构下 32-bit 处理器只用到了 8 个寄存器，它们的名字分别是：</p><p><code>%eax</code>、<code>%ecx</code>、<code>%edx</code>、<code>%ebx</code>、<code>%esi</code>、<code>%edi</code>、<code>%esp</code>、<code>%ebp</code>（都是 <code>%e</code> 前缀,意味着存 32-bit 整型）</p><p>此位，这些寄存器还能引用 <strong>low-order 16-bits</strong>（它们是最开始出现的 16-bit 寄存器，没有 <code>e/r</code> 前缀，引用的名称为 <code>%ax</code>、<code>%cx</code>、<code>%bx</code>……），甚至是 <strong>low-order 8-bits 和 high-order 8-bits</strong>（分别是 <code>%al</code> 和 <code>%ah</code> 等，如下图）。这里不讲述这些旧版本机器的低位寄存器位置的操作指令，不过在下一章会提到操作 <strong>low-order 8-bits</strong> 的操作指令，因为会涉及汇编条件控制。</p><p><img src="imgs/IA32_registers.png" height="350px"></p><p>很早以前，各个寄存器的名字有特定含义，代表它们的目的。例如 <code>a</code> 代表 accumulate，<code>c</code> 代表 counter，<code>d</code> 代表 data，<code>b</code> 代表 base，<code>si</code> 代表 source index，<code>di</code> 代表 destination index，<code>sp</code> 代表 stack pointer，<code>bp</code> 代表 base pointer。</p><p>现在这些寄存器就是普通的存取数据的结构，名字也就没有特定的含义了——<strong>除了名字是 <code>sp</code> 的寄存器</strong>。它在目前的 x86-64 架构中也有一个非常具体的目的，就是上面说的，stack pointer，<strong>栈指针</strong>。</p><p>至于后面数字表示的寄存器，<strong>是后来从 IA32 架构升级到 64 位（x86-64）时，芯片可以在一个时钟周期处理 64-bit 的数据了，旧的寄存器设计不够用了，所以新添加上去的，因为没有特定用途，就以数字进行命名</strong>。</p><p>⚠ 说是没什么“特殊用途”，但还是有约定俗成的使用方法的！</p><p>例如，这些寄存器分为 “<strong>Callee-Saved Register</strong>” 和 “<strong>Caller-Saved Register</strong>”。</p><p>其中，Callee-Saved Register 是由<strong>被调用方保管使用的</strong>寄存器，数据内容只会在被调方的函数内有效、有意义。属于这类的寄存器有：<code>%rbx</code>、<code>%r12-14</code>、<code>%rbp</code> 和 <code>%rsp</code>，后两者是有特殊含义的，前面的寄存器是供被调方存储临时数据（Temporaries）；</p><p>Caller-Saved Register 是<strong>调用方保管使用的</strong>寄存器，它的作用大多数是沟通调用方和被调方的数据信息。例如 <code>%rax</code> 一般存放返回值，<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rcx</code>、<code>%r8</code>、<code>%r9</code> 依此存放调用函数的第 1 ~ 第 6 参数；<code>%r10</code>、<code>%r11</code> 供存储调用方临时数据。</p><p>在下面的部分中，你会一遍遍加深对这个说法的印象的。上面的内容在第五章会进一步提及。</p><p>至于为什么要有 Callee-Saved 和 Caller-Saved Register，这也会在 5.4 中详细说明。</p><hr><h2 id="3-3-2-Move-Operands-and-usage"><a href="#3-3-2-Move-Operands-and-usage" class="headerlink" title="3.3.2 Move, Operands, and usage"></a>3.3.2 Move, Operands, and usage</h2><p>接下来介绍整型寄存器在汇编代码中的使用。</p><h3 id="Moving-Data-Command-movq-lt-SrcR-gt-lt-DstR-gt"><a href="#Moving-Data-Command-movq-lt-SrcR-gt-lt-DstR-gt" class="headerlink" title="Moving Data Command: movq &lt;SrcR&gt;, &lt;DstR&gt;"></a>Moving Data Command: <code>movq &lt;SrcR&gt;, &lt;DstR&gt;</code></h3><blockquote><p>为什么命令名中有 “q” ？因为在 Intel 公司设定中，q 代表 quad，是 4 个字，而在 8086 系列中，1 个字被约定为 16 bits（2 bytes），所以 <strong><code>movq</code> 指令操作的必须是 64 bits 的寄存器</strong>；</p><p>⚠ <strong>另外请格外注意，Intel 和 Microsoft 使用的 x86-64 架构的汇编语言的这些参数和 Linux 使用的 x86-64 架构的参数顺序不一样！CSAPP 教授的指令语法按照 Linux 来，请不要弄错！不要在 Windows 环境下尝试这些指令！</strong></p></blockquote><h3 id="Operands"><a href="#Operands" class="headerlink" title="Operands"></a>Operands</h3><ul><li><p>Immediate（数据直接量，例如常量整型）: <strong>定义和 C 语言一样，但是需要加上前缀 <code>$</code></strong>;</p><blockquote><p>例如：<code>$0x400</code>、<code>$-523</code> 等等；</p></blockquote></li><li><p>Register Name: 16 个中任意一个整型寄存器的名称。</p><blockquote><p><strong>注意：保留作其他用途的寄存器也不应该被手动使用。前面说了，例如在 x86-64 架构中，<code>%rsp</code> 保留做特殊用途</strong>，因为栈中保存其他重要的状态信息，只能由机器内部进行修改。</p></blockquote></li><li><p>Memory: <strong>8 consecutive bytes</strong> of memory <strong>at address</strong> given by registers.</p></li><li><p><strong>汇编代码简单访问 Memory 的方法</strong>：</p><ul><li><p>法 1: Normal <code>(%&lt;registerName&gt;)</code></p><p>即保存在寄存器中的、8 bytes 连续的地址数据对应的 memory 位置。</p><p><strong>也就是说，当把寄存器名称放在括号里时，就是表示把寄存器中数据看作 memory 地址（无论是什么），并用这个地址来引用对应的内存位置</strong>。</p><p>例如：<code>(%rax)</code> 就是代表取存放在 <code>%rax</code> 寄存器中的数据对应 memory 位置的引用；</p><p><u>请牢牢记住</u>，这种在括号内找地址的形式被称为 <strong>Simple Memory Addressing Modes</strong>（简单内存寻址模式），表示这个模式下，寄存器被看作指针，括号相当于取地址并找到 memory 对应的引用。</p></li></ul></li></ul><ul><li><p>法 2: Displacement <code>&lt;D&gt;(%&lt;registerName&gt;)</code></p><p>即保存在寄存器中的、8 bytes 连续的地址对应 memory 的某个位置，以这个位置为基准，向后偏移 <code>D</code> 个 bytes 所对应的内存位置的引用。</p><p>例如：<code>8(%rbp)</code> 就是代表取存放在 <code>%rbp</code> 寄存器中的数据向后偏移 <code>D</code> 个 bytes 的位置对应 memory 的引用；</p></li></ul><ul><li><p><strong>法 3: Most General Form <code>D(&lt;Rbase&gt;, &lt;Rindex&gt;, &lt;Scale&gt;)</code></strong></p><p>等价于 <code>Memory[Reg[Rb] + S * Reg[Ri] + D]</code>，指使用寄存器 <code>Rb</code> 中的数据为基，加上 <code>S</code> 倍率的寄存器 <code>Ri</code> 中的数据（<strong>因此 <code>S</code> 只取 1，2，4，8 这几个之一</strong>），最后总体偏移 <code>D</code> bytes；</p><p><strong>注意，<code>Ri</code> 不建议为寄存器 <code>%rsp</code></strong>;</p><p><strong>法 3 就是原始意义上的数组自然引用的方式</strong>；</p><p>可以思考为什么 <code>S</code> 只取 1、2、4、8 中的一个。原因很简单，这和它存在的意义有关。我们想在引用数组时，<strong>一定希望根据数据类型来缩放索引值</strong>，例如 <code>int</code> 需要缩放 4 倍（4 bytes），<code>long</code> 需要缩放 8 倍；小于这些数，则会导致数据错误，大于这些数据会导致空间浪费。</p></li></ul><ul><li><p>Rules：以上有些 operand 的组合是不允许的。例如：</p><ul><li>直接量作为 destination，没有意义；</li><li>为了方便硬件设计，不允许直接从一个内存位置复制到另一个内存位置，必须 2 步：从内存存入指定寄存器，再由指定寄存器存入另一块内存（<strong>内存到内存必须经过寄存器</strong>）；</li></ul></li><li><p>Examples：</p><ul><li><p>例如 <code>movq $0x4,%rax</code> 可能对应的就是 <code>tmp = 0x4;</code></p></li><li><p>例如 <code>movq $-147,(%rax)</code>可能对应 <code>*p = -147;</code></p></li><li><p>例如 <code>movq %raw,%rdx</code> 可能对应 <code>tmp2 = tmp1;</code></p></li><li><p>例如 <code>movq $rax,(%rdx)</code> 可能对应 <code>*p = tmp;</code></p></li><li><p>例如 <code>movq (%rax),%rdx</code> 可能对应 <code>tmp = *p;</code></p></li><li><p>例如假设下面这段程序可能的汇编代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t0 = *xp;</span><br><span class="line">    <span class="type">long</span> t1 = *yp;</span><br><span class="line">    *xp = t1;</span><br><span class="line">    *yp = t0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">swap:</span><br><span class="line">    movq(%rdi), %rax</span><br><span class="line">    movq(%rsi), %rdx</span><br><span class="line">    movq%rdx, (%rdi)</span><br><span class="line">    movq%rax, (%rsi)</span><br><span class="line">    ret; 回到之前调用 swap 函数的位置，结束当前函数执行</span><br></pre></td></tr></table></figure><p><strong>在上面这个函数体中，<code>%rdi</code> 是保存第一个参数的寄存器，<code>%rsi</code> 是第二个参数寄存器，最多用 6 个</strong>，这是在执行此函数前就设置好的。剩下寄存器的选择是由编译器自己决定的，每次编译都可能不太一样；</p></li></ul></li><li><p>Exercises: Address Computation Examples（根据信息填写下表）</p><p>已知寄存器 <code>%rdx</code> 存放数据 0xf000，寄存器 <code>%rcx</code> 存放数据 0x0100。</p><table>    <tr style="text-align: center;">        <th>Expression</th>        <th>Address Computation</th>        <th>Address</th>    </tr>    <tr>        <td>0x8(%rdx)</td>        <td></td>        <td></td>    </tr>    <tr>        <td>(%rdx,%rcx)</td>        <td></td>        <td></td>    </tr>    <tr>        <td>(%rdx,%rcx,4)</td>        <td></td>        <td></td>    </tr>    <tr>        <td>0x80(,%rdx,2)</td>        <td></td>        <td></td>    </tr></table><p>第一行，就是普通 displacement，<code>0xF000 + 0x8 = 0xF008</code>;</p><p>第二行，省略的 general displacement，<code>0xF000 + 0x0100 = 0xF100</code>;</p><p>第三行，省略的 general displacement，<code>0xF000 + 4 * 0x0100 = 0xF400</code>;</p><p>第四行，省略的 general displacement，<code>0 + 2 * 0xF000 + 0x80 = 0x1E080</code>;</p></li></ul><h2 id="3-3-3-Arithmetic-amp-logical-operations"><a href="#3-3-3-Arithmetic-amp-logical-operations" class="headerlink" title="3.3.3 Arithmetic &amp; logical operations"></a>3.3.3 Arithmetic &amp; logical operations</h2><h3 id="Address-Computation-Instruction-leaq-lt-Src-gt-lt-Dst-gt"><a href="#Address-Computation-Instruction-leaq-lt-Src-gt-lt-Dst-gt" class="headerlink" title="Address Computation Instruction: leaq &lt;Src&gt;, &lt;Dst&gt;"></a>Address Computation Instruction: <code>leaq &lt;Src&gt;, &lt;Dst&gt;</code></h3><blockquote><p>指令含义：load effective address（加载有效地址）；</p><p>指令目标（很抽象，等会慢慢解释）：<strong>相当于 C 的 <code>&amp;</code>（ampersand）符号来计算地址</strong>，基于想要计算的地址的一些内容（一般是指定内存引用）。<strong>同时也作为一种非常方便的算术运算方式</strong>。</p><p>指令的大致过程：通俗来说就是<strong>传入的内存引用 <code>Src</code>，<code>leaq</code> 会找到这个引用的地址值，并把这个地址传给 <code>Dst</code></strong>，最后 <code>Dst</code> 的值是 <code>Src</code> 引用的地址，相当于 <code>Dst</code> 变成了指针，指向了 <code>Src</code>；</p><p><code>Dst</code> 参数<strong>必须是寄存器名称</strong>，不能是直接量、内存引用；</p><p><code>Src</code> 参数<strong>必须是内存引用</strong>，<strong>允许使用之前的 Simple Memory Addressing Mode</strong>，不能是直接量、寄存器名称；</p></blockquote><p>下面举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">m12</span><span class="params">(<span class="type">long</span> x)</span> &#123; <span class="keyword">return</span> x * <span class="number">12</span>; &#125;</span><br></pre></td></tr></table></figure><p>上面的函数对应的汇编代码可以是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m21:</span><br><span class="line">    leaq (%rdi,%rdi,2), %rax</span><br><span class="line">    salq $2, $rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>首先解释 <code>(%rdi,%rdi,2)</code>，这是上面要求记住的 <strong>Simple Memory Addressing Mode</strong>，它代表，把 <code>%rdi</code>（即这里存放函数第一参数 <code>x</code> 的寄存器）中的内容看成地址，进行一个 general displacement：<code>%rdi 的值 + 2 * %rdi 的值</code>，这里<strong>巧妙地完成了找到 3 倍的 <code>%rdi</code> 的值，把它作为索引，其对应的 memory 地址引用</strong>（注：这个地址很可能<strong>不能</strong>被程序使用，这里只是借助它进行算术计算）；</p><p>然后 <code>leaq</code> 将第一参数（3 倍 <code>%rdi</code> 值索引所对应 memory 的引用位置）<strong>对应的地址</strong>赋给了 <code>%rax</code> 寄存器。<strong>到此为止，<code>%rax</code> 中成功获得了 <code>%rdi</code> 中的 3 倍值，中间的方法虽然用到了指针的概念，但本质不是指针操作，是算数操作</strong>（慢慢领悟吧）。</p><p>最后使用的 <code>salq</code> 指令很简单，就是底层的移位指令（在后面介绍），将 <code>%rax</code> 的二进制值向左移动 2 位，相当于 × 4，总的来说 <code>%rax</code> 的值就相当于原来 <code>%rdi</code> 的值 × 12，完成了 × 12 的操作。</p><blockquote><p>有同学可能会问，为什么不全都给 <code>leaq</code> 来计算 × 12 呢？其实移位在效率上会更快一些。一般 C/C++ 程序在乘常数操作时，会被编译器优化，分解出 $2^k$ 的因子，一部分用 <code>leaq</code> 计算，另一部分用 <code>salq</code> 移位。</p></blockquote><h3 id="Some-Arithmetic-Operations"><a href="#Some-Arithmetic-Operations" class="headerlink" title="Some Arithmetic Operations"></a>Some Arithmetic Operations</h3><ul><li><code>addq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst + Src</code></li><li><code>subq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst - Src</code></li><li><code>imulq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst * Src</code></li><li><code>salq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &lt;&lt; Src</code></li><li><code>sarq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &gt;&gt; Src</code>（<strong>算术右移，arithmetic right shift</strong>）</li><li><p><code>shrq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &gt;&gt; Src</code>（<strong>逻辑右移，logical right shift</strong>）</p></li><li><p><code>xorq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst ^ Src</code></p></li><li><code>andq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &amp; Src</code></li><li><code>orq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst | Src</code></li></ul><p><strong>切记，别搞错 operands 的顺序！<code>Src</code> 在前，<code>Dst</code> 在后</strong>；</p><ul><li><code>incq &lt;Dst&gt;</code>：相当于 <code>Dst = Dst + 1</code></li><li><code>decq &lt;Dst&gt;</code>：相当于 <code>Dst = Dst - 1</code></li><li><code>negq &lt;Dst&gt;</code>：相当于 <code>Dst = -Dst</code></li><li><code>notq &lt;Dst&gt;</code>：相当于 <code>Dst = ~Dst</code>（注意是<strong>按位否</strong>）</li></ul><p><strong>还有一部分针对 128 bits 的计算</strong>，先放在这，不急着背，慢慢消化即可：</p><ul><li><p><code>imulq &lt;S&gt;</code>：<strong>默认 <code>%rax</code> 中存放另一个 operand</strong>，<strong>将 <code>S * R[%rax]</code> 的值存放到 <code>R[%rdx]:R[%rax]</code></strong>（high-order 64-bits 由 <code>%rdx</code> 承担，low-order 64-bits 由 <code>%rax</code> 承担）中，<strong>针对 signed 数</strong>；</p><blockquote><p>在 64 位架构下，你会发现 <code>R[%rdx]:R[%rax]</code> 的拼接方法表示 128-bits 数是约定俗成的行为。</p></blockquote></li><li><p><code>mulq &lt;S&gt;</code>：作用与 <code>imulq &lt;S&gt;</code> 相同，不过是对 unsigned 操作；</p></li><li><p><code>idivq &lt;S&gt;</code>：<strong>默认被除数（128-bits）存放在 <code>R[%rdx]:R[%rax]</code>，并与 <code>S</code>（64-bits）进行除法，除数存放在 <code>%rax</code>，余数存放在 <code>%rdx</code></strong>。<strong>针对 signed 数</strong>；</p></li><li><p><code>divq &lt;S&gt;</code>：作用与 <code>idivq &lt;S&gt;</code> 相同，不过是对 unsigned 操作；</p></li><li><p><code>cqto</code>：少见的没有参数的指令。<strong>作用是把 64-bits（quad word，默认存放在 <code>%rax</code>）转为 128-bits（octal word，默认存放在 <code>R[%rdx]:R[%rax]</code>），<u>signed extension</u></strong>；</p></li></ul><p>更多指令请参阅 x86-64 指令手册。</p><hr><p>下面是个 <strong>example</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">arith</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t1 = x + y;</span><br><span class="line">    <span class="type">long</span> t2 = z + t1;</span><br><span class="line">    <span class="type">long</span> t3 = x + <span class="number">4</span>;</span><br><span class="line">    <span class="type">long</span> t4 = y * <span class="number">48</span>;</span><br><span class="line">    <span class="type">long</span> t5 = t3 + t4;</span><br><span class="line">    <span class="type">long</span> rval = t2 * t5;</span><br><span class="line">    <span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arith:</span><br><span class="line">    leaq(%rdi,%rsi), %rax</span><br><span class="line">    addq%rdx, %rax</span><br><span class="line">    leaq(%rsi,%rsi,2), %rdx</span><br><span class="line">    salq$4, %rdx</span><br><span class="line">    leaq4(%rdi,%rdx), %rcx</span><br><span class="line">    imulq%rcx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这里 <code>%rdi</code> 存放了函数第一参数 x，<code>%rsi</code> 存放了函数第二参数 <code>y</code>，<code>%rdx</code> 存放了函数第三参数 <code>z</code>；</p><p>第一步，可以理解为将 <code>%rdi</code> 和 <code>%rsi</code> 值看作地址，找到 <code>%rdi 值 + %rsi 值</code> 对应的 memory 引用，并利用 <code>leaq</code> 将引用代表的地址赋给 <code>%rax</code>，使得 <code>%rax</code> 获得了 <code>%rdi</code> 和 <code>%rsi</code> 值之和的值，<strong>之所以不用 <code>addq</code>，是因为 <code>addq</code>  会把结果加到 <code>Dst</code> 上，但这里显然不想修改任何寄存器中的值，只是想把值给到新的寄存器</strong>（此步对应 <code>long t1 = x + y;</code>，相当于这里 <code>%rax</code> 存的是 <code>t1</code>）；</p><p>第二步，把 <code>%rdx</code> 的值（x）加到 <code>%rax</code> 上，这时的 <code>%rax</code> 存的是 <code>t2</code>（<code>t1</code> 以后不会用了，所以编译器抛弃了，直接用 <code>addq</code> 操作 <code>%rax</code>，这么做可以提升效率，对应 <code>long t2 = z + t1;</code>）；</p><p>第三步、第四步，前面说了好几遍，这里说简单一点，就是把 <code>%rdx</code> （原先存 <code>z</code> 的寄存器，抛弃 <code>z</code> 也是因为之后不用 <code>z</code> 变量了，编译器进行了优化）赋以 3 倍的 <code>%rsi</code> 值，并且把 <code>%rdx</code> 的值乘以 $2^4=16$，总的来说，<code>%rdx</code> 被赋以 48 倍的 <code>%rsi</code>（y）的值，对应 <code>long t4 = y * 48;</code>，这时 <code>%rdx</code> 存放的就是 <code>t4</code> 了；</p><p>第五步，简单说就是 <code>%rcx</code> 被赋以 <code>%rdi 的值（x） + %rdx 的值（t4） + 4</code>，可以看到，这里编译器想尽一切办法，把 <code>long t3 = x + 4;</code> 和 <code>long t5 = t3 + t4;</code> 这步合起来了，整整省下来了一个 <code>t3</code> 的操作，可谓优化到极致。所以，<code>%rcx</code> 存的是 <code>t5</code>；</p><p>最后一步，编译器实在想不到更好的优化方法，只能勉为其难地调用了唯一一次 <code>imulq</code>，把 <code>%rcx</code> 的值（<code>t5</code>）乘到 <code>%rax</code> 上，对应 <code>long rval = t2 * t5;</code>，函数结束，最后存放 <code>rval</code> 的寄存器是 <code>%rax</code>。</p><hr><h1 id="Chapter-4-Machine-Level-Programming-Ⅱ-Control"><a href="#Chapter-4-Machine-Level-Programming-Ⅱ-Control" class="headerlink" title="Chapter 4. Machine Level Programming Ⅱ - Control"></a>Chapter 4. Machine Level Programming Ⅱ - Control</h1><h2 id="4-1-Introduction-to-Condition-Codes"><a href="#4-1-Introduction-to-Condition-Codes" class="headerlink" title="4.1 Introduction to Condition Codes"></a>4.1 Introduction to Condition Codes</h2><h2 id="4-1-1-Processor-State-of-x86-64-partial"><a href="#4-1-1-Processor-State-of-x86-64-partial" class="headerlink" title="4.1.1 Processor State of x86-64, partial"></a>4.1.1 Processor State of x86-64, partial</h2><p>前面介绍过，x86-64 架构具有 16 个寄存器，其中 8 个沿用旧 x86 架构的名称，另外 8 个从 8 ~ 15 命名。可以总结一下，从这些寄存器 / flags 可以看出处理器当前的状态：</p><ul><li><p>Temporary data：除去 <code>%rsp</code> 的所有 15 个寄存器都是处理器运算时存储临时数据的位置；</p></li><li><p>Location of runtime stack：<code>%rsp</code>;（在以后的章节会涉及运行时栈）</p></li><li><p><strong>Location of current code control point</strong>：<code>%rip</code></p><blockquote><p>之前没有见过的寄存器，instruction point，和 <code>%rsp</code> 一样有特殊用途，<strong>可以将它看成程序计数器</strong>。</p><p><strong>它包含了当前正在执行指令的地址</strong>，也不能手动修改，一般是通过获取它的值来进行一些操作；</p><p><strong>它一般由 <code>call</code> 指令 和 <code>ret</code> 指令等修改</strong>；</p></blockquote></li><li><p>Status of recent tests: <strong>Condition Code</strong></p><ul><li>一共 8 种， 现在只说四种，其他的用到再说：<code>CF</code>、<code>ZF</code>、<code>SF</code>、<code>OF</code>;</li><li>它们都是 1-bit flag，不是被直接手动设置，而是根据其他指令操作后的结果进行设置（<strong>implicit setting</strong>）；</li><li>是汇编条件操作的基础；</li></ul></li></ul><h2 id="4-1-2-The-meanings-for-Condition-Codes"><a href="#4-1-2-The-meanings-for-Condition-Codes" class="headerlink" title="4.1.2 The meanings for Condition Codes"></a>4.1.2 The meanings for Condition Codes</h2><ul><li>Single bit register: 这种寄存器不是之前介绍的整型寄存器，它仅存储 1-bit 数据，专门用于存放 condition codes，它们的名称就是对应的 flag 的名称。先介绍其中 4 种的含义：<ul><li><code>CF</code>: Carry Flag (for unsigned, 将两个 unsigned 相加，MSB 的进位)；</li><li><code>SF</code>: Sign Flag (for signed, 当 signed 运算结果的 MSB = 1，说明结果是负值，此位会被置 1);</li><li><code>ZF</code>: Zero Flag (上一个计算结果为 0 时，此位会被置 1。依靠算术指令内部实现);</li><li><code>OF</code>: Overflow Flag (signed 运算溢出的位。<strong>因此可以将 <code>CF</code> 理解为“unsigned 运算溢出的位</strong>”);</li></ul></li><li><strong>注意：之前说的 <code>leaq</code> 不会设置这些 flags</strong>；但之前介绍的算术运算指令会。</li><li><strong>注意2：也有专门利用计算结果值来设置 flags 的指令：<code>compare 和 test</code></strong> (explicit setting)</li></ul><h2 id="4-1-3-Condition-Codes-Explicit-Setting"><a href="#4-1-3-Condition-Codes-Explicit-Setting" class="headerlink" title="4.1.3 Condition Codes: Explicit Setting"></a>4.1.3 Condition Codes: Explicit Setting</h2><h3 id="Compare-cmpq-lt-Src2-Src1-gt"><a href="#Compare-cmpq-lt-Src2-Src1-gt" class="headerlink" title="Compare: cmpq &lt;Src2, Src1&gt;"></a>Compare: <code>cmpq &lt;Src2, Src1&gt;</code></h3><ul><li>作用：几乎和 <code>subq</code> 一样，但不修改结果值，因为它计算 <code>Src1 - Src2</code> 并且不会对 <code>Src1/2</code> 进行任何操作，但会由此设置上面 4 个介绍到的 condition codes；</li><li>内部如何设置 condition codes：主要依据 <code>Src1 - Src2</code> 减法操作。<ul><li><code>CF</code> set if carry out from MSB (used for unsigned comparisons);</li><li><code>ZF</code> set if <code>Src1 == Src2</code>（即 <code>Src1 - Src2</code> 运算结果是否为 0）;</li><li><code>SF</code> set if <code>(Src1 - Src2) &lt; 0</code>（即 <code>Src1 - Src2</code> 运算结果的 sign 位是否为 1）;</li><li><code>OF</code> set if <code>(Src1 - Src2)</code> in two’s complement (signed) overflow（即 <code>(Src1 &lt; 0 &amp;&amp; Src2 &gt; 0 &amp;&amp; (Src1 - Src2) &gt; 0) || (Src1 &gt; 0 &amp;&amp; Src2 &lt; 0 &amp;&amp; (Src1 - Src2) &lt; 0)</code>，用的就是判断 signed 溢出的条件：两个同号 signed 相加为异号，说明正/负溢出）;</li></ul></li></ul><h3 id="Test-testq-lt-Src2-Src1-gt"><a href="#Test-testq-lt-Src2-Src1-gt" class="headerlink" title="Test: testq &lt;Src2, Src1&gt;"></a>Test: <code>testq &lt;Src2, Src1&gt;</code></h3><ul><li>作用：几乎和 <code>andq</code> 一样，但不修改结果值，只计算 <code>Src1 &amp; Src2</code>，并由此设置 condition codes；</li><li>内部如何设置 condition codes：<ul><li><code>ZF</code> set when <code>Src1 &amp; Src2 == 0</code>;</li><li><code>SF</code> set when <code>Src1 &amp; Src2 &lt; 0</code>;</li><li>因为按位且不会导致任何的进位，所以不设置 <code>CF/OF</code>;</li></ul></li><li>和上面的 Compare 相比，Test 指令可以进行一个参数的判断，例如 <code>testq %rax, %rax</code>，也把一个参数写成 mask，例如 <code>testq $0x22, %rax</code>;</li></ul><h2 id="4-1-4-Condition-Codes-Reading"><a href="#4-1-4-Condition-Codes-Reading" class="headerlink" title="4.1.4 Condition Codes: Reading"></a>4.1.4 Condition Codes: Reading</h2><p>前面说完如何设置，现在称述一下如何读取使用。这里一般不允许直接访问 flags 对应的寄存器，而是用一系列的 <code>SetX</code> instructions 来读取并操作。</p><p><code>SetX</code> Instructions 的作用就是<strong>按照当前的 condition codes，来将指定的单个寄存器的单个 byte 设置为 1 或 0</strong>；</p><p><code>SetX</code> Instructions 具体的类型如下：</p><table>    <tr style="text-align: center;">        <th>SetX</th>        <th>Condition</th>        <th>Description</th>    </tr>    <tr>        <td>sete</td>        <td>ZF</td>        <td>Equal/Zero</td>    </tr>    <tr>        <td>setne</td>        <td>~ZF</td>        <td>Not Equal/Not Zero</td>    </tr>    <tr>        <td>sets</td>        <td>SF</td>        <td>Negative</td>    </tr>    <tr>        <td>setns</td>        <td>~SF</td>        <td>Nonegative</td>    </tr>    <tr>        <td>setg</td>        <td>~(SF^OF)&amp;~ZF</td>        <td>Greater (signed)</td>    </tr>    <tr>        <td>setge</td>        <td>~(SF^OF)</td>        <td>Greater or Equal (signed)</td>    </tr>    <tr>        <td>setl</td>        <td>(SF^OF)</td>        <td>Less (signed)</td>    </tr>    <tr>        <td>setle</td>        <td>(SF^OF) | ZF</td>        <td>Less or Equal (signed)</td>    </tr>    <tr>        <td>seta</td>        <td>~CF &amp; ~ZF</td>        <td>Above (unsigned)</td>    </tr>    <tr>        <td>setb</td>        <td>CF</td>        <td>Below (unsigned)</td>    </tr></table><blockquote><p><code>SetX</code> Instructions 都有唯一参数（<strong>语法 <code>setX &lt;Dst&gt;</code></strong>），要求是单个寄存器的 low-order 8-bit 的引用名称，这是由这条指令的作用决定的。</p></blockquote><p>看上面的表，就解释一个。以 <code>setl</code> 为例，因为大多数时候我们使用 <code>cmpq</code> 对 condition codes 进行设置，所以当 <code>SF</code> 为 1 时，很可能是 <code>Src1 - Src2 &lt; 0</code> 的情况。但是需要排除 <code>Src1 - Src2</code> 正溢出的情况——正溢出也可能导致结果为负，因此是 <code>SF ^ OF</code>；</p><p>最后还有一个问题。<code>setX</code> 是为单个寄存器的<strong>单个 low-order 8-bit 设置 0/1</strong>，但之前<strong>在 3.3.1 中明确说过</strong>，我们在 x86-64 架构下一般都讨论 64-bit register 的使用，而那些访问寄存器的 low-order 32-bit（例如 <code>%eax</code>）、low-order 16-bit 的方法用的比较少（在 32 位架构下会多一点）。</p><p>而这里，为了条件控制，我们必须访问 64-bit register 的 low-order 8-bit 的位置，这些位置可以由以下名称给出：</p><ul><li>字母类型命名的 register，不使用前缀 <code>r</code>，而使用后缀 <code>l</code> 就能代表对应的 low-order 8-bit 位置；例如：<code>%rax</code> 的 low-order 1-bit 位置是 <code>%al</code>、<code>%rbx</code> 是 <code>%bl</code>、<code>%rcx</code> 是 <code>%cl</code>、<code>%rdx</code>是 <code>%dl</code>、<code>%rsi</code> 是 <code>%sil</code>、<code>%rdi</code> 是 <code>%dil</code>、<code>%rsp</code> 是 <code>%spl</code>、<code>%rbp</code> 是 <code>%bpl</code>；</li><li>数字类型命名的 register，使用后缀 <code>b</code> 就代表对应的 low-order 8-bit 位置；例如 <code>%r8b</code>、<code>%r15b</code> 等；</li></ul><p>这样操作 64-bit integer register 的 low-order 8-bit，不会影响到其他位的信息；</p><hr><p>下面是 <strong>example</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gt</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br></pre></td></tr></table></figure><p>其对应的汇编代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gt:</span><br><span class="line">    cmpq%rsi, %rdi</span><br><span class="line">    setg%al</span><br><span class="line">    movzbl%al, %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>已知 <code>%rdi</code> 存放了函数的第一参数 x 的值，<code>%rsi</code> 存放了函数第二参数 y 的值，函数返回的结果就放在 <code>%rax</code> 中。下面逐步分析：</p><p>第一步使用了 <code>cmpq</code> 将 <code>%rdi 值 - %rsi 值</code>（即 <code>x - y</code>）计算，并为 4 个 condition codes 进行修改；</p><p>第二步，<code>setg</code> 对 <code>%al</code> 操作，这是 <code>%rax</code>  的 low-order 8-bit 的位置，表明如果 <code>~(SF ^ OF) &amp; ~ZF</code> 成立，即 <code>x &gt; y</code> 成立，那么为 <code>%rax</code> 的 low-order 8-bit 位置置为 1，否则置为 0；<strong>显然，这里的 <code>%rax</code> 还需要把前面 7 bytes 全部置为 0，才能成为我要返回的值（(int)0/1）</strong>，我们应该怎么做呢？</p><p>第三步用到了新的指令 <code>movzbl</code>（<strong>move with zero extension byte to long</strong>）</p><blockquote><p>语法：<code>movzbl &lt;Src&gt;, &lt;Dst&gt;</code>;</p><p>作用：把一个 <code>Src</code> 数据引用大小的 <strong>0 数据</strong> 扩展到 <code>Dst</code> 中（会改变 <code>Dst</code>，但不会改变 <code>Src</code>）;</p></blockquote><p>那么好，问题又来了，为什么我们明明要把 <code>%rax</code> 剩下的所有 7 bytes 全部置 0，但是汇编中写的却是对 <code>%eax</code>（之前提到的，register 的 low-order 32-bit 位置）置 0，剩下的 high-order 32-bit 不管了吗？</p><p>⚠ 实际上，这是 x86-64 架构内部令人迷惑的特性。当一个 64-bit register 从 low-order 只被修改 32-bit 数据时，<strong>会自动将剩下的 high-order 32-bit 全部置 0</strong>。（但是如果只是修改 low-order 16-bit、low-order 8-bit 时，却<strong>不会</strong>为前面的部分置 0）</p><p>到此为止，<code>%rax</code> 中的数据应该长这样：<code>0x000000000000000?</code>（最后一位取决于 <code>setg</code> 到底 set 了什么），这就是我们需要返回的 <code>x &gt; y</code> 表达式的值，所以函数结束。</p><hr><h2 id="4-2-Conditional-Branches"><a href="#4-2-Conditional-Branches" class="headerlink" title="4.2 Conditional Branches"></a>4.2 Conditional Branches</h2><p>前一节的例子描述了如何依靠 condition codes 来修改某个寄存器的 low-order 8-bit 的值，这是实现条件分支的基础。</p><p>这一节将利用 condition code 来组织条件分支，本质上也是 reading condition codes；</p><h2 id="4-2-1-JX-Instructions-【Old】"><a href="#4-2-1-JX-Instructions-【Old】" class="headerlink" title="4.2.1 JX Instructions 【Old】"></a>4.2.1 JX Instructions 【Old】</h2><ul><li><p>语法：<code>jX &lt;LABEL&gt;</code>，这里的 <code>&lt;LABEL&gt;</code> 是汇编程序中的一个<strong>段落标签</strong>，在具体例子中会展示。</p><blockquote><p>还有一种语法，会在 4.4 中介绍。</p></blockquote></li><li><p>作用：有条件（根据 condition codes）/ 无条件跳转到指定部分的汇编代码继续执行；</p></li><li><p>具体类型（和 <code>SetX</code> Instructions 使用名称类似）：</p><table>    <tr style="text-align: center;">        <th>jX</th>        <th>Condition</th>        <th>Description</th>    </tr>    <tr>        <td>jmp</td>        <td>1</td>        <td>Unconditional</td>    </tr>    <tr>        <td>je</td>        <td>ZF</td>        <td>Equal/Zero</td>    </tr>    <tr>        <td>jne</td>        <td>~ZF</td>        <td>Not Equal/Not Zero</td>    </tr>    <tr>        <td>js</td>        <td>SF</td>        <td>Negative</td>    </tr>    <tr>        <td>jns</td>        <td>~SF</td>        <td>Nonegative</td>    </tr>    <tr>        <td>jg</td>        <td>~(SF^OF)&amp;~ZF</td>        <td>Greater (signed)</td>    </tr>    <tr>        <td>jge</td>        <td>~(SF^OF)</td>        <td>Greater or Equal (signed)</td>    </tr>    <tr>        <td>jl</td>        <td>(SF^OF)</td>        <td>Less (signed)</td>    </tr>    <tr>        <td>jle</td>        <td>(SF^OF) | ZF</td>        <td>Less or Equal (signed)</td>    </tr>    <tr>        <td>ja</td>        <td>~CF &amp; ~ZF</td>        <td>Above (unsigned)</td>    </tr>    <tr>        <td>jb</td>        <td>CF</td>        <td>Below (unsigned)</td>    </tr></table></li><li><p>Example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">absdiff</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) result = x - y;</span><br><span class="line">    <span class="keyword">else</span> result = y - x;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">    cmpq%rsi, %rdi</span><br><span class="line">    jle.L4</span><br><span class="line">    movq%rdi, %rax</span><br><span class="line">    subq%rsi, %rax</span><br><span class="line">    ret</span><br><span class="line">.L4:</span><br><span class="line">    movq%rsi, %rax</span><br><span class="line">    subq%rdi, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>已知 <code>%rdi</code> 保存的是函数第一参数 x，<code>%rsi</code> 保存的是函数第二参数 y，<code>%rax</code> 保存函数返回值。</p><blockquote><p>再次说一下，<strong>汇编函数返回前只需要把返回值放在特定的寄存器中就行</strong>，只要调用方清除你放在哪就行。比如这里放在 <code>%rax</code>，那么函数结束后，调用方会去 <code>%rax</code> 访问结果。</p></blockquote><p>第一步 <code>cmpq</code> 根据 <code>%rdi 值 - %rsi 值</code> 来设置 condition codes；</p><p>第二步的 <code>jle</code> 对应的条件是 <code>(SF ^ OF) | ZF</code>，结合上一步也就是 <code>x ≤ y</code> 时，跳至 <code>.L4</code> 标签标记的位置继续执行。</p><p>这里 <code>.L4</code> 是一个标签，<code>.</code> 开头表示它是<strong>内部的</strong>操作或标签，只会出现在汇编代码中，不会出现在目标代码（机器代码）中，所以不会被当作独立的函数。</p><blockquote><p>有同学会说，不是说汇编代码就是机器代码的文本表示吗？为啥还有差别？</p><p>其实是这样的，汇编代码相对于机器代码，在转换为易读的文本同时，会把一些<strong>指令地址</strong>设置成内部标签。在汇编转机器代码时，会再计算代入回去。不然你读 <code>jle 0x0F0E2310</code> 肯定没有 <code>jle .L4</code> 好读。</p></blockquote><p>后两步的含义已经比较简单了，不再赘述。</p><p>上面的内容<strong>类似 C/C++ 中的 goto 语句，不建议在 C/C++ 中使用</strong>；</p></li></ul><h2 id="4-2-2-General-Conditional-Expression-Translation-amp-Conditional-Moves"><a href="#4-2-2-General-Conditional-Expression-Translation-amp-Conditional-Moves" class="headerlink" title="4.2.2 General Conditional Expression Translation &amp; Conditional Moves"></a>4.2.2 General Conditional Expression Translation &amp; Conditional Moves</h2><blockquote><p>本小节介绍了 “条件移动” 这种编译器优化的方式，告诉我们在有些情况下，编译器将条件控制一味地翻译成 <code>JX</code> Instructions 不见得是最好的；同时也指明了不应该使用 “条件移动” 优化的情形。</p></blockquote><p>上面介绍的 <code>JX</code> Instructions 真的适合编译器使用吗？效率是最高的吗？如果仔细看上一节标题会发现有一个 “【Old】” 的标志，这说明现在不经常用到它了。如果效率不佳，那么有哪些方法可以考虑呢？为什么呢？</p><p>如果编译器将 C++ 代码翻译为上面的 <code>JX</code> Instructions，那么这种翻译被称为 <strong>General Conditional Expression Translation</strong>，这也是最自然的方法：如果满足某个条件就跳转到哪里执行，否则如何如何。</p><p>还有一种方法被称为 <strong>条件移动（Conditional Moves）</strong>，是将 C/C++ 代码中的条件分支（if-else）的 “then” 分支和 “else” 分支<strong>全部执行</strong>，最后按照条件再决定将谁移动到结果寄存器中。</p><p>伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result    = the value of Then_Expr</span><br><span class="line">eval    = the value of Else_Expr</span><br><span class="line">cond    = !(the value of Test)</span><br><span class="line">if (cond) result = eval</span><br><span class="line"></span><br><span class="line">return result</span><br></pre></td></tr></table></figure><p>有人说，这把 then 子句和 else 子句都运行了，平均的时间复杂度上不是会比之前的 General Condition Expression 更浪费时间吗？其实不然，这里的知识和后面章节的 “流水线” 有关。</p><p>因为现代处理器采用 “流水线（pipeline）” 的运行方式，在到达一行代码时会关联甚至运行下面几行的代码。现代处理器大概可以同时处理 20 行左右的指令深度（主要取决于事先读入的指令条数）。当运行到含有分支的部分时，处理器会采取 “<strong>分支预测技术</strong>”，根据上下文猜测会运行到哪个分支，并将猜测的分支事先读入流水线。</p><p>如果猜对，那么执行非常迅速，直接读取流水线上的信息，并离开这个分支；但是如果猜错，那么将停止执行当前流水线上的代码，并重新读入另一段分支。这是个耗时操作，较差情况下会花费 40 个时钟周期（40 步普通指令执行时间）。</p><p>因此，<strong>在某些情况下</strong>，使用 Conditional Moves 的条件判断方法可能会比 General Conditional Expression 更高效。</p><p><strong>正因如此，大多数编译器在<u>某些情况下</u>都选择 Conditional Moves，而不是上面的 <code>JX</code> 指令（代表 General Condition Expression），所以你几乎看不到 4.2.1 中的汇编代码。</strong>如果实在想看到，那么在用 gcc 编译时，给定参数 <code>-fno-if-conversion</code>，这样不允许编译器使用条件移动。</p><hr><p>所以在 4.2.1 中大多数情况下的汇编代码应该长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">    movq%rdi, %rax</span><br><span class="line">    subq%rsi, %rax</span><br><span class="line">    movq%rsi, %rdx</span><br><span class="line">    subq%rdi, %rdx</span><br><span class="line">    cmpq%rsi, %rdi</span><br><span class="line">    cmovle%rdx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>再稍微解释一下，第一步是将 <code>%rdi</code> 的值（即函数第一参数 x）赋给 <code>%rax</code>；</p><p>从第二步开始就是条件移动的方法了：第二步先把 <code>%rax</code> 的值（x）减去 <code>%rsi</code>（y），相当于先做了 then 分支的内容；</p><p>第三步是将 <code>%rsi</code> 的值（y）移动到 <code>%rdx</code> 中，并再第四步把 <code>%rdx</code> 的值减去 <code>%rdi</code>（x），相当于完成了 else 分支的内容；</p><p>到目前为止，<code>%rax</code> 中存放 <code>x - y</code> 的值，<code>%rdx</code> 中存放 <code>y - x</code> 的值；</p><p>第五步才是按照 x、y 的值来设置 condition codes；</p><p>最后一步是一个<strong>新指令：<code>cmovle</code></strong>;</p><ul><li>语法：<code>cmovle &lt;Src&gt;, &lt;Dst&gt;</code>；</li><li>作用：条件移动，按照当前 condition codes 的状态进行移动。其中 <code>cmov</code> 就是 conditional moves，<code>le</code> 就是之前的 <code>X</code> 情况（小于等于情况），所以猜测还有 <code>cmovl</code>、<code>cmovge</code>、<code>cmovg</code>……</li></ul><hr><p>但是，上面说 <strong>Conditional Moves 更快是在“某些情况下”</strong>，那么什么是 “另外的情况”？</p><p>现在介绍在什么时候，汇编的翻译不应该用 Conditional Moves：</p><p><strong>Situation 1: Expensive Computations</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = Test(x) ? Hard1(x) : Hard2(x);</span><br></pre></td></tr></table></figure><p>这种 then 子句和 else 子句都非常难以计算的时候，不应该用条件移动。因为重新读入流水线的时间很可能会少于把两个子句都计算一遍的时间；</p><p><strong>Situation 2: Risky Computations</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = p ? *p : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>上面的判断语句必须先判断再进行执行，否则会出现程序错误，尤其是在指针的判断上；</p><p><strong>Situation 3: Computations with side effects</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = x &gt; <span class="number">0</span> ? x*=<span class="number">7</span> : x+=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>上面的 then 和 else 子句一旦执行，会破坏程序的原义，造成意想不到的后果。</p><h2 id="4-3-Loops"><a href="#4-3-Loops" class="headerlink" title="4.3 Loops"></a>4.3 Loops</h2><h2 id="4-3-1-Do-While-Loop"><a href="#4-3-1-Do-While-Loop" class="headerlink" title="4.3.1 Do-While Loop"></a>4.3.1 Do-While Loop</h2><p>对于一个计算 x 代表的二进制代码中的 1 的个数的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pcount_do</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result += x &amp; <span class="number">0x1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的汇编代码非常简单，<strong>就可以用 General Conditional Expression 的方法，结合 <code>JX</code> Instructions 实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pcount_do:</span><br><span class="line">    movl$0, %eax</span><br><span class="line">.L2:</span><br><span class="line">    movq%rdi, %rdx</span><br><span class="line">    andl$1, %edx</span><br><span class="line">    addq%rdx, %rax</span><br><span class="line">    shrq%rdi</span><br><span class="line">    jne.L2</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure><p>对应的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    preparations</span><br><span class="line">loop:</span><br><span class="line">    Body</span><br><span class="line">    if (Test)</span><br><span class="line">        goto loop</span><br></pre></td></tr></table></figure><p>这里注意一下，<code>movl</code> 和 <code>andl</code> 都不算新的指令——之前说过 <code>q</code> 的含义代表操作数的位数，quad 指 4 字（4 × 16 bits），<code>l</code> 就指 2 字，2 × 16 bits；</p><h2 id="4-3-2-General-While-Loop-Translation-1-“Jump-to-Middle”-Translation"><a href="#4-3-2-General-While-Loop-Translation-1-“Jump-to-Middle”-Translation" class="headerlink" title="4.3.2 General While Loop Translation #1 - “Jump to Middle” Translation"></a>4.3.2 General While Loop Translation #1 - “Jump to Middle” Translation</h2><p>从 do-while 到 while 只需要更改一下测试条件的顺序就行。例如上一节的代码改成 while 循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pcount_do</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        result += x &amp; <span class="number">0x1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么对应的汇编伪代码<strong>可以是</strong>（一般在编译器优化等级 <code>-Og</code> 时出现）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    goto test;// 先测试</span><br><span class="line">loop:</span><br><span class="line">    Body</span><br><span class="line">test:</span><br><span class="line">    if (Test)</span><br><span class="line">        goto loop;// 通过再进循环体</span><br><span class="line">done:</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure><h2 id="4-3-3-General-While-Loop-Translation-2-“Do-while”-Conversion"><a href="#4-3-3-General-While-Loop-Translation-2-“Do-while”-Conversion" class="headerlink" title="4.3.3 General While Loop Translation #2 - “Do-while” Conversion"></a>4.3.3 General While Loop Translation #2 - “Do-while” Conversion</h2><p>如果把编译器的优化等级调至 <code>-O1</code>，那么编译器在处理 while 循环时不会采用上面的 ”Jump to Middle“ 的翻译策略，而是采用 <strong>转换为 do-while 循环</strong> 的策略，这样会更加高效。</p><p>这相当于把 C/C++ 代码中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test) &#123;</span><br><span class="line">    Body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换成了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Test)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Body</span><br><span class="line">&#125; <span class="keyword">while</span> (Test);</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>具体的汇编伪代码会变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    if (!Test)// 仅进入前判断一下，接下来就变成 do-while</span><br><span class="line">        goto done;</span><br><span class="line">loop:</span><br><span class="line">    Body</span><br><span class="line">    if (Test)</span><br><span class="line">        goto loop;</span><br><span class="line">done:</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure><p>从这个优化上可以看出，其实 do-while 循环会比 while 循环更高效，但现在的编译器比较智能，只要优化等级不低，这个方面会帮你优化掉的。</p><h2 id="4-3-4-For-Loop"><a href="#4-3-4-For-Loop" class="headerlink" title="4.3.4 For Loop"></a>4.3.4 For Loop</h2><p>for loop 的汇编实现没那么简单，我们可能需要向 while 或 do-while 上看齐。比如对如下 for 循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Init; Test; Update) &#123;</span><br><span class="line">    Body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器可以转换成 while 循环，如果使用了 <code>-O1</code> 优化，会优化到 do-while：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Init;</span><br><span class="line"><span class="keyword">while</span> (Test) &#123;</span><br><span class="line">    Body</span><br><span class="line">    Update;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"></span><br><span class="line">Init;</span><br><span class="line"><span class="keyword">if</span> (!Test) &#123;    <span class="comment">// do-while 前的测试块（Initial Test）</span></span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Body</span><br><span class="line">    Update;</span><br><span class="line">&#125; <span class="keyword">while</span> (Test);</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>很多时候，<code>-O1</code> 下的编译器甚至可以识别 <code>Init</code> 块 和 do-while 前的测试块的关联，并且合理舍弃前置的测试块。</p><h2 id="4-4-Switch-Statements"><a href="#4-4-Switch-Statements" class="headerlink" title="4.4 Switch Statements"></a>4.4 Switch Statements</h2><p>将 C/C++ 的 switch 语句翻译为汇编是相当有难度的。首先应该弄清楚 switch 语句在 C/C++ 中的一系列特性：</p><ul><li><p>Match integer values；</p></li><li><p>Fall through cases：当 case 中不存在 break 时，会一直向下运行；</p></li><li>Merge cases：当一个 case 中没有任何内容时，相当于并入下一个 case（上一点的特例）；</li><li>Default case：对于没有匹配的 cases，会进入最后的 default case（如果有的话）；</li></ul><p>当然，现代的编译器对于 switch 语句的翻译绝不是一系列的 if-else 语句的翻译，而是利用了一个数据结构：<strong>跳表（Jump Table Structure）</strong>；</p><p>如下图，switch-case 语句就像一串代码块，每个 case 就是一个块。编译时，switch-case 块会整体一起编译（如下图 Jump Targets），转为汇编指令后，每个块的汇编指令所对应的<strong>地址</strong>会被存储在一个跳表中（如下图 Jump Table）。这样在根据条件调用相应代码块时，只需要 goto 跳表中的对应地址（ray indexing）就能完成任务，无需一个个比对条件。</p><p><img src="imgs/jump_table.png" height="300px"></p><p>那么，汇编代码是如何在跳表中找到合适的地址的呢？举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_eg</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        w = y * z;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        w = y / z;</span><br><span class="line">        <span class="comment">/* Fall Through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        w += z;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        w -= z;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        w = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子对应的汇编代码可以是（一部分代码）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch_eg:</span><br><span class="line">    movq%rdx, %rcx</span><br><span class="line">    cmpq$6, %rdi</span><br><span class="line">    ja.L8</span><br><span class="line">    jmp*.L4(,%rdi,8)</span><br></pre></td></tr></table></figure><p>逐步解释：</p><p>第一步将 <code>%rdx</code>（第三参数 z）赋值到 <code>%rcx</code> 寄存器中；</p><p>第二步就将 <code>%rdi</code>（第一参数 x）与常数 6 进行做差比较（为什么是 6？因为在源码中 6 是最大的 case），以此修改 condition codes；</p><p>第三步 <code>ja</code> 表示只要 <code>%rdi</code>（x）的值（<strong>看作 unsigned</strong>）在 6 之上，那么就跳至 <code>.L8</code>（看来是 default 片段），否则第四步会无条件跳至某个位置；</p><blockquote><p>这里编译器处理的非常巧妙：使用 <code>ja</code>（unsigned above）而不是 <code>jg</code>（signed greater），这样同时把 <code>x &gt; 6</code> 和 <code>x &lt; 0</code> 的情况都算入 <code>ja</code> 的条件中，进一步提高了效率；</p></blockquote><p>这里还需要解释一下，之前没有提到的 <code>JX</code> Instructions 的使用语法。除了 <code>jX &lt;LABEL&gt;</code> 直接跳转至对应标签（direct jump），另一种方法是<strong>间接跳转（indirect jump）：<code>jX &lt;effectiveAddress&gt;</code></strong>；</p><p>参数是有效地址，可以是寄存器名称，也可以是右值，例如这个例子中 <code>jmp *.L4(,%rdi,8)</code>，后面的部分 <code>.L4(,%rdi,8)</code> 应该很熟悉了：因为标签会被汇编器翻译为代码段的地址，所以它就是 <code>.L4地址 + 8 * x</code>（<code>%rdi</code> 的值是 x），并把这个值看作 memory 的地址。前面的 <code>*</code> 星号就是直接取地址上内容的意思（和 C/C++ 的相同），可以理解为 <code>leaq</code> 相反的过程；<strong>这个 memory 地址中的值就是跳表中的一个代码段的地址</strong>，所以取出来的也是地址；</p><p>第四步跳转的位置如何，我们需要看看剩下来的汇编代码（跳表部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            ; read only data</span><br><span class="line">.section    .rodata; 这行和下一行是为了构造跳表的基本结构</span><br><span class="line">    .align8; 伪对齐指令，指明下面的变量必须从下一个能被 8 整除的地址开始</span><br><span class="line">.L4:                ; 代码块按照 x 的值的顺序进行排列</span><br><span class="line">    .quad.L8; x = 0 的情况</span><br><span class="line">    .quad.L3; x = 1</span><br><span class="line">    .quad.L5; x = 2</span><br><span class="line">    .quad.L9; x = 3</span><br><span class="line">    .quad.L8; x = 4</span><br><span class="line">    .quad.L7; x = 5</span><br><span class="line">    .quad.L7; x = 6</span><br></pre></td></tr></table></figure><p>如上所示，跳表的结构是由汇编代码指定的，如何填这个表是<strong>汇编器的工作</strong>，不是编译器的工作；</p><p>在编译器生成的汇编代码中，<code>.quad</code> 只是个声明，标记表示这里是一个 4 字（4 × 16 bits）的数据，以后汇编器需要填上后面指定标签指令段的地址；</p><p>我们可以发现，<code>x &lt; 0</code> 和 <code>x &gt; 6</code> 的情况在之前的代码中被 <code>ja</code> 处理，跳至 <code>.L8</code>（default 代码段），剩余在 switch 中整数缺省的情况（<code>x = 4</code> 和 <code>x = 0</code>）也会自动转至 <code>.L8</code>;</p><p>主干看完了，继续看之前提到的各个代码段的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.L3:                    ; 对应 x = 1 的情况的代码段</span><br><span class="line">    movq%rsi, %rax</span><br><span class="line">    imulq%rdx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>接下来，编译器的行为就很迷惑了。大家是否还记得，之前在源码的第一行有 <code>long w = 1;</code> 的初始化操作？但编译器不做，因为在很多 case 下并没有用到这个值，所以赋值被推迟了，直到有一个 case—— <code>x = 3</code>，它的代码段是 <code>w += z;</code> 需要用到之前的值，这个时候编译器才开始赋值 1，这么做只是为了提高效率……如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.L5:                    ; 对应 x = 2 的代码段</span><br><span class="line">    movq%rsi, %rax</span><br><span class="line">    cqto</span><br><span class="line">    idivq%rcx; %rcx 中存放 z，这里是 y/z</span><br><span class="line">    jmp.L6</span><br><span class="line">.L9:                    ; 对应 x = 3 的代码段之前的 x = 1 的赋值操作，也是x = 3入口</span><br><span class="line">    movl$1, %eax</span><br><span class="line">.L6:                    ; 对应 x = 3 的代码段主体</span><br><span class="line">    addq%rcx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>其中 <code>cqto</code> 是 Convert Quadword to Octoword，意为 64-bit 扩展至 128-bit，没有参数，作用是将 <code>%rax</code> 中的 MSB 复制到整个 <code>%rdx</code> 寄存器中（这么做的原因是 <strong>Expanding Conclusion</strong>），一般紧接着 <code>idivq &lt;dividerR&gt;</code>，将 <code>rdx:rax</code> 中的 128-bit 数作为被除数，<code>divderR</code> 作为除数，进行 signed 除法，商存在 <code>%rax</code>，余数存在 <code>%rdx</code>；</p><p>继续：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.L7:                    ; x = 5</span><br><span class="line">    movl$1, %eax</span><br><span class="line">    subq%rdx, %rax</span><br><span class="line">    ret</span><br><span class="line">.L8:                    ; x = 6</span><br><span class="line">    movl$2, %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>明白了跳表的原理，这下明白了为啥 C/C++ 要求 switch 的量必须是可以转换为整型的常量了吧？</p><p>无论如何，编译器都会找出你写的所有 case 的最大值、最小值，在此之外的情况会在进入跳表前进行跳转至 default 块；在最值之间的，会出现在跳表中（也就是说 case 的最大值、最小值决定了跳表的大小）；但是在范围中有缺省的情况的，也会补充在跳表中，跳转到 default 块。</p><blockquote><p>小机灵可能会问，诶，如果这些 case <strong>全是负数咋整</strong>？或者<strong>最小值很大咋整</strong>？还能不能建立跳表、用索引了？因为咱之前的 <code>jmp *.L4(,%rdi,8)</code> 不就直接把 x 做跳表索引了吗？</p><p>实际编译器会确保最小值不会低于 0，也不会太大。为此，编译器可能会加上<strong>偏置值（bias）</strong>让 case 变成小的正数。</p><p>还有小机灵可能会问，如果一个 case 是 0， 另一个是 10000，难到在这之中的全部要建表吗？也就是说，如果 case 的<strong>间隔很稀疏、很大</strong>怎么办？</p><p>这个时候编译器会把这些 switch-case 转换成 if-else 语句，再建立 if-else 树，由于稀疏的数据，所以这个树大概率是平衡树，让比对的时间复杂度保持在 $O(log_2(n))$；</p></blockquote><p>综合上面的讨论，无论如何 switch-case 所依赖的跳表的时间复杂度会在 $O(1)\sim O(log_2(n))$ 之间，总是比 if-else 的线性时间复杂度要好。</p><h2 id="4-5-Summary-for-Chapter-4"><a href="#4-5-Summary-for-Chapter-4" class="headerlink" title="4.5 Summary for Chapter 4"></a>4.5 Summary for Chapter 4</h2><p>这章的知识点比较多，在这里总结一下 Chapter 4 的主要内容。</p><p>在一开始，我们先复习了之前的寄存器及其代表的处理器的状态，再初步了解了汇编中的重要 flags: condition codes（目前只认识了 4 个：<code>CF/OF/SF/ZF</code>），它们可以看作一个个 1-bit 数据，不能被手动更改，但可以通过特定的方式进行访问。</p><p>例如 <code>cmpq</code> 和 <code>testq</code> 能根据计算结果修改 flags，<code>setX</code> Instructions 能根据当前 flags 设置特定的 8-bit 位。我们还了解了几个特殊的指令，例如 <code>movzbl</code>；了解了 x86-64 的 low-order 32-bit 填充特性。</p><p>我们不满足于借助 condition codes 仅仅填充几个 bits，我们进一步学习了根据 condition codes 进行流程控制的方法。</p><p>首先是比较低效的 <code>JX</code> Instructions，它代表着 General Conditional Expression，利用汇编<strong>条件跳转</strong>初步实现条件分支；进一步从流水线层面，我们认识到 <strong>Conditional Moves</strong> 可能是更好、更快的选择，但一定要搞清 3 个禁忌条件。我们还认识了 <code>cmovle</code> 等一系列<strong>条件移动的指令</strong>，让过程更加方便。</p><p>在循环控制方面，我们掌握了 do-while 结构的翻译方法，通过 <code>JX</code> 指令轻松解决；针对 while 循环时，我们想到两种方法：“Jump to Middle” 把判断条件放 loop 的中间，开始循环前跳进去；还有一种是转换为 do-while 的 “set guardian” 方法，效率更高。对于 for 循环，我们也可以容易地将其转换为 while 循环，进一步优化为 do-while，通过合理舍弃 “guardian” 进一步加快运行效率。</p><p>在比较繁琐的 switch-case 语句的翻译上，聪明的人们为它引入了<strong>跳表</strong>的数据结构，利用 <code>jX</code> 的间接跳转在 $O(1)\sim O(log_2(n))$ 的复杂度下完成了分支，远胜 if-else 结构的线性复杂度。</p><p>不过上面的几乎所有内容都是在汇编层面<strong>实现了一些小的 “tricks”</strong> 来帮助提升运行效率，这只是在将代码流程控制的翻译这个 procedure 上加一点东西，或者是<strong>改变流程的方法</strong>。这都是底层指令逐步堆砌实现更高级指令的实例。</p><p>下一章节我们将系统学习汇编运行的整个 procedure，知识点将更为复杂，做好准备！</p><h1 id="Chapter-5-Machine-Level-Programming-Ⅲ-Procedure"><a href="#Chapter-5-Machine-Level-Programming-Ⅲ-Procedure" class="headerlink" title="Chapter 5. Machine Level Programming Ⅲ - Procedure"></a>Chapter 5. Machine Level Programming Ⅲ - Procedure</h1><blockquote><p>本章所指的 Procedure 既可以是 function，method，也可以是 normal procedure；</p></blockquote><p>知识补充：什么是 ABI ？</p><p>虽然 CSAPP 讲述的是基于 x86 硬件及其运行方式，但更重要的是我们采用了一套被普遍承认的约定—— ABI（Application Binary Interface），这是个<strong>机器程序级别的接口</strong>。这个接口在第一台 x86 机器被制造出来的时候就出现了，尤其是为 Linux 制定的。它规定了，所有二进制程序、操作系统各个组件、编译器都要对于管理机器上的资源有共同的理解，并且遵守使用规则。</p><p><strong>例如之前说的，约定俗成哪些寄存器用来传递函数参数、哪些寄存器用来传递返回值，哪些是 “Caller-Saved Register”，哪些又是 “Callee-Saved Register”</strong>，这些都是 ABI 规定的；</p><p>到目前，Windows 和 OSX 等操作系统也有自己的 ABI；</p><h2 id="5-1-Mechanisms-in-Procedures"><a href="#5-1-Mechanisms-in-Procedures" class="headerlink" title="5.1 Mechanisms in Procedures"></a>5.1 Mechanisms in Procedures</h2><blockquote><p>过程机理的概览，下几节会一一回答这些问题；</p></blockquote><ul><li>Passing control<ul><li>To beginning of procedure code（运行过程如何进入一个函数？）</li><li>Back to return point（函数运行结束如何跳转到之前调用位置的下一行？）</li></ul></li><li>Passing data<ul><li>Procedure argument（如何向被调方传递参数？）</li><li>Return value（被调方如何返回数据给调用方？）</li></ul></li><li>Memory management<ul><li>Allocate during procedure execution（某过程开始执行时，内存如何分配以供过程使用？）</li><li>Deallocate upon return（某过程结束后，内存如何销毁？）</li></ul></li><li>Mechanisms all implemented with machine instructions（以上机理如何在机器代码中实现？）</li><li>x86-64 implementation of a procedure uses only those mechanisms required（示例）</li></ul><h2 id="5-2-x86-64-Stack"><a href="#5-2-x86-64-Stack" class="headerlink" title="5.2 x86-64 Stack"></a>5.2 x86-64 Stack</h2><blockquote><p>在此之前，先介绍 x86-64 architecture 的内存栈的机制；</p></blockquote><p>程序总是使用栈来<strong>管理过程中调用和返回状态</strong>，这主要是利用了栈 LIFO 的性质，这和调用-返回的思想很相似。因此它可以被用于：<strong>传递潜在信息、控制信息，分配 local 数据</strong>；</p><p>x86 的程序栈也存在于内存中，<strong>栈底位于 high numbered address（高位地址）</strong>，而栈顶位于 low numbered address；</p><p>前面说的 <strong><code>%rsp</code> 寄存器</strong>就是位于栈顶来管理这个过程的。<code>%rsp</code> 寄存器存储的是<strong>栈顶的地址</strong>，当有数据需要进栈时，<strong>通过递减栈指针来完成进栈操作</strong>；</p><p>之前还说过，<code>%rsp</code> 不应该被手动更改，那么有哪些方法能够使用这个栈呢？</p><p>第一个是 <code>pushq</code> 指令。</p><ul><li><p>语法：<code>pushq &lt;Src&gt;</code>;</p></li><li><p>作用：先从 <code>Src</code> 中取得操作数，再将 <code>%rsp</code> 值减 8（quadword，即 4 × 16 bits，64 bits，8 bytes），最后将从 <code>Src</code> 处获得的操作数写入到 <code>%rsp</code> 对应的 memory 地址中；</p><blockquote><p>⚠ 需要注意的点：<strong>这个栈是先移动指针再往里面写的</strong>；</p></blockquote></li><li><p><code>Src</code> 可以是直接量、寄存器名称、内存引用；</p></li></ul><p>与之对应的是 <code>popq</code> 指令。</p><ul><li><p>语法：<code>popq &lt;Dst&gt;</code>;</p></li><li><p>作用：先将 <code>%rsp</code> 值所代表的 memory 地址中的值读进，再将 <code>%rsp</code> 的值加 8，最后将读到的值写入 <code>Dst</code>;</p><blockquote><p>⚠ 需要注意的点：<strong>这个 <code>Dst</code> 只能是寄存器</strong>，因为前面说了，不允许从内存到内存，也不允许存入直接量；</p></blockquote></li></ul><h2 id="5-3-Calling-Conventions"><a href="#5-3-Calling-Conventions" class="headerlink" title="5.3 Calling Conventions"></a>5.3 Calling Conventions</h2><h2 id="5-3-1-Passing-Control"><a href="#5-3-1-Passing-Control" class="headerlink" title="5.3.1 Passing Control"></a>5.3.1 Passing Control</h2><p>以一个例子说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = mult2(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">    <span class="type">long</span> s = a * b;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是上面的源码经过汇编得到的结果（稍微删除了一些无关紧要的部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">    push%rbx</span><br><span class="line">    mov%rdx, %rbx</span><br><span class="line">    callq400550 &lt;mult2&gt;</span><br><span class="line">    mov%rax, (%rbx)</span><br><span class="line">    pop%rbx</span><br><span class="line">    retq</span><br><span class="line"></span><br><span class="line">mult2:</span><br><span class="line">    mov%rdi, %rax</span><br><span class="line">    imul%rsi, %rax</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure><p>这里注意一下 <strong>Passing Control</strong> 是怎么完成的：</p><ul><li><p>使用了程序栈来支持 procedure 的数据；</p></li><li><p>使用 <code>call &lt;LABEL&gt;</code> 指令来完成：</p><ol><li>把 <strong>return address</strong>（调用结束，返回时的位置）加入到栈中；</li><li>跳至 <code>LABEL</code> 执行；</li></ol></li><li><p>使用 <code>ret</code> 指令来完成：</p><ol><li>将栈中的地址弹出读取；</li><li>跳转到读取的地址；</li></ol><blockquote><p>有的时候会看到 <code>rep; ret</code> 的指令行，不用管，它和 <code>ret</code> 作用一样；</p></blockquote></li></ul><p>因此，Passing Control 的过程主要由两个特殊寄存器、一个栈支持；运行的动态如下（地址信息是虚拟的）：</p><p><img src="imgs/procedure_control_1.png" height="200px"><img src="imgs/procedure_control_2.png" height="200px"><img src="imgs/procedure_control_3.png" height="200px"><img src="imgs/procedure_control_4.png" height="200px"></p><h2 id="5-3-2-Passing-Data"><a href="#5-3-2-Passing-Data" class="headerlink" title="5.3.2 Passing Data"></a>5.3.2 Passing Data</h2><p>其实在此之前的前几章，我们已经看到了，汇编程序使用约定俗称的寄存器（“Caller-Saved Resgiter”）来完成函数参数、返回值的传递：</p><ul><li><p><code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rcx</code>、<code>%r8</code>、<code>%r9</code> 这都是 Caller-Saved Register，约定<strong>从前到后</strong>（顺序可以记下来）用来存放函数的六个参数，供被调用方使用；</p><blockquote><p>这里是 integer registers，如果参数不是整型 / 指针，那么会用<strong>浮点数寄存器</strong>来存放，以后说。</p><p>注：在 IA-32 时期，甚至所有参数都放在栈里，这会大大降低程序运行速度的。</p></blockquote></li><li><p>如果函数多于 6 个参数那么从第 7 个参数开始，将按顺序存放在栈里，仅需要才会分配栈（<strong>这个栈也用 <code>%rsp</code> 访问，一般每 8 bytes 一个参数，但是位于另一个栈帧，和调用方的栈帧互不干扰。具体情况见下一节</strong>）</p></li><li><p><code>%rax</code> 也是 Caller-Saved Register，约定是用于存放函数的返回值，供调用方读取；</p></li></ul><h2 id="5-3-3-Managing-Local-Data"><a href="#5-3-3-Managing-Local-Data" class="headerlink" title="5.3.3 Managing Local Data"></a>5.3.3 Managing Local Data</h2><p>早在 5.2 中就介绍了 x86 栈的作用之一就是<strong>分配 local 数据</strong>。那么调用和返回的功能之一就是可以对函数进行嵌套调用。</p><p>此外，我们将栈上<strong>用于特定 call 的每个内存块称为栈帧（stack frame）</strong>，它是特定 procedure、特定 instance 的栈帧。单线程程序共用一个栈，因此通过栈帧来管理各个函数的 Local data；</p><p>栈帧的结构如何？是如何管理的？其中究竟放了些什么？</p><ul><li><p>Structure：大家在 C++ 程序设计课程上应该接触过 “变量作用域”，这个时候应该强调了不同函数的局部变量会存在它的栈帧中。所以可以想象，栈帧就是一段一段堆叠在 stack 上的片段，每个未返回的函数独享一个栈帧；</p><p><img src="imgs/stack_structure.png" height="300px"></p><p><strong>并且 <code>%rsp</code> 就在之前说的栈顶，还有一个普通寄存器 <code>%rbp</code> 可以用来存放两个栈帧交界的位置（只有在一些特殊情况下编译器才会使用它，平时会当作普通寄存器使用）</strong>；</p><p>所以大多数情况下，没有 <code>%rbp</code> 指示，汇编程序员甚至不知道下一层栈帧在哪里，<strong>这只能靠代码自身管理（大部分情况下编译器知道需要分配多少栈帧、销毁多少栈帧），并且正确释放栈帧（本节的一个例子会演示代码如何自身管理栈帧）</strong>；</p><blockquote><p>编译器不知道应该分配多少栈帧的特殊情况：<strong>分配可变大小的数组 / 内存缓冲区</strong> 等情况，这时编译器会无奈选择使用 <code>%rbp</code> 管理；</p></blockquote><p>也正因如此，递归所需的所有基础结构都由栈的原则所保证；</p><p>对于 <strong>x86-64 Linux</strong> 这一特定机器 + 操作系统而言，栈帧的<strong>详细结构</strong>应该是这样的：</p><p><img src="imgs/stack_structure_detail.png" height="350px"></p><ul><li><p>之前在 <strong>Passing Control</strong> 中提到 <code>call</code> 指令压入的返回地址存在 Caller Frame 的最上层，下面压着 <strong>Caller 传给 Callee 的参数</strong>（Arguments 7+，<strong>即最顶层地址较小的位置上是 argument 7，向栈底（地址增大的方向）增大</strong>）；</p></li><li><p>在两个栈帧之间有空间为可选的旧 <code>%rbp</code>（上一层栈帧的 <code>%rdp</code>）空间，当前的 <code>%rbp</code> 就指向这里（如果有的话）；</p></li><li><p>在当前 Callee Frame 中，最底层是 <strong>Callee-Saved Register</strong>（保存 Temporaries）和内存中的<strong>局部变量</strong>；向上就是在 <strong>Pass Data</strong> 中提到的<strong>多于 6 个的传入参数</strong>存放的位置。</p></li><li><p><strong>之前说的 “代码自身管理的方式” 就是在函数返回前将 <code>%rsp</code> 回到一开始的地方（上一层栈帧）</strong>；</p></li></ul></li><li><p>Management：为正在执行、没有返回的函数保留一个栈帧</p><ul><li>Space allocated <strong>when enter procedure</strong><ul><li>“Set-up” code</li><li>Include push by <code>call</code> instruction</li></ul></li><li>Deallocated <strong>when return</strong><ul><li>“Finish” code</li><li>Include pop by <code>ret</code> instruction</li></ul></li></ul></li><li><p>Contents</p><ul><li>Return information</li><li>Local storage（only if necessary）</li><li>Temporary space（only if necessary）</li></ul></li></ul><hr><p>为了演示这一部分，下面列举一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">incr</span><span class="params">(<span class="type">long</span> *p, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = *p;</span><br><span class="line">    <span class="type">long</span> y = x + val;</span><br><span class="line">    *p = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">call_incr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> v1 = <span class="number">15213</span>;</span><br><span class="line">    <span class="type">long</span> v2 = incr(&amp;v1, <span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">incr:</span><br><span class="line">    movq(%rdi), %rax</span><br><span class="line">    addq%rax, %rsi</span><br><span class="line">    movq%rsi, (%rdi)</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">call_incr:</span><br><span class="line">    subq$16, %rsp</span><br><span class="line">    movq$15213, 8(%rsp)</span><br><span class="line">    movl$3000, %esi</span><br><span class="line">    leaq8(%rsp), %rdi</span><br><span class="line">    callincr</span><br><span class="line">    addq8(%rsp), %rax</span><br><span class="line">    addq$16, %rsp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>其实函数 <code>incr</code> 的汇编代码很简单，重点不在这，而是调用它的函数 <code>call_incr</code> 以及过程中的处理情况。我们将一步步分析其中的情况。</p><p>首先，当上层的 caller 刚刚调用 <code>call call_incr</code> 指令、还没有为 <code>call_incr</code> 分配栈帧时，栈中的情况如下图所示：</p><p><img src="imgs/procedure_example_1.png" height="150px"></p><p>此时栈顶仍然是上层 caller 的 <code>call</code> 指令刚压入的 return address；随后机器读取 <code>%rip</code> 中保存的 <code>call_incr</code> 的地址开始执行 <code>call_incr</code> 函数；</p><p>现在请注意上面的 <code>call_incr</code> 汇编代码。</p><p>第一步是将 <code>%rsp</code> 的值减去 16，这意味着一口气在栈中分配了 16 bytes 空间，作为 <code>call_incr</code> 的栈帧（此时 <code>%rsp</code> 理所当然在最上层）；</p><blockquote><p>程序一般在栈上分配的空间会比实际需求多一点，这是因为有一些内部的约定，要求保持内存对齐，例如汇编中典型的 <code>.align</code> 伪指令。这个分配的值是由编译器计算得出的。</p></blockquote><p>第二步向 <code>%rsp + 8</code> 的 memory 地址写入常数 15213，这就相当于向栈顶的下面 8 bytes 的位置写入该常数；现在栈中的情况如下图所示：</p><p><img src="imgs/procedure_example_2.png" height="150px"></p><p>以上的第 1~2 步对应着源码的 <code>long v1 = 15213;</code> 这一步。</p><p>第三步将 <code>%rsi</code>（<code>%esi</code>）写入 32-bit 的 3000 整型（还记得之前说的特性吗？高 32-bit 会自动被置 0），因为 <code>%rsi</code> 将来会作为调用函数的第二参数；</p><p>第四步还记得吗？找到 <code>%rsp + 8</code> 作为地址对应的 memory 引用（这里就是之前栈中存放常数 15213 的位置）<strong>的地址</strong>（也就是存放 15213 的地址）赋给 <code>%rdi</code>，这就相当于 <code>&amp;v1</code> 给了调用函数的第一参数；</p><p>上面的第 3~4 步对应源码中的 <code>long v2 = incr(&amp;v1, 3000);</code> 的 <strong>Passing Data 部分</strong>；</p><p>而在过程中大家发现，代码是不是自身就管理了 <code>%rsp</code> 的位置和栈的分配？</p><p>在完成函数调用的 Passing Data 部分，我们继续进行 <code>long v2 = incr(&amp;v1, 3000);</code> 这一步的 <strong>Passing Control 部分</strong>：</p><p>接下来汇编调用了 <code>call incr</code>，干了 3 件事：<code>%rsp</code> 减 8，存储 return address（这里的是 <code>call incr</code> 下一行指令的地址），并且向 <code>%rip</code> 写入 <code>incr</code> 的起始地址。</p><p>于是程序进入了 <code>incr</code> 函数，这比较简单，其中的内存分配、变量设置就不说了。直接跳到 <code>incr</code> 函数的 <code>ret</code> 指令，此时经过内部的代码控制，<code>%rsp</code> 应该回到了之前 <code>call_incr</code> 函数栈帧的顶部（存放 return address 的位置）。于是 <code>ret</code> 也做了 3 件事：将 return address 取出来，<code>%rsp</code> 加 8，并向 <code>%rip</code> 写入刚刚取得的地址——也就是 <code>call_incr</code> 函数中 <code>call incr</code> 指令的下一行。</p><p>此时，栈的情况如下图所示（18213 是因为 <code>incr</code> 函数修改了 <code>long *p</code> 参数，还有，别搞混了，这个图里的 return address 是调用 <code>call_incr</code> 的上层 caller 的栈帧中的东西）：</p><p><img src="imgs/procedure_example_3.png" height="150px"></p><p>程序进入 <code>call_incr</code> 汇编的最后两步：把 <code>%rax</code>（<code>incr</code> 函数返回值，也就是 <code>v2</code>）加上 <code>%rsp + 8</code> 地址上的内容（18213，也就是新的 <code>v1</code>）作为函数返回值，<strong>并且把 <code>%rsp</code> 加上 16，释放了之前分配给 <code>call_incr</code> 函数的栈帧</strong>（所以你看看，编译器是不是知道之前分配了多少栈帧空间？是不是不需要 <code>%rbp</code> 的指示？）。函数到此结束，栈中的情况如下：</p><p><img src="imgs/procedure_example_4.png" height="100px"></p><p>最后的一句 <code>ret</code> 会读取上层 caller 放的 return address，将 <code>%rsp</code> 减 8，并且将 <code>%rip</code> 写入 return address，下一步程序将回到调用 <code>call_incr</code> 的上层 caller 的函数体中。栈的情况如下：</p><p><img src="imgs/procedure_example_5.png" height="100px"></p><hr><h2 id="5-4-Register-Saving-Conventions"><a href="#5-4-Register-Saving-Conventions" class="headerlink" title="5.4 Register Saving Conventions"></a>5.4 Register Saving Conventions</h2><p>之前无论是 5.3.2 讲述传递数据的方法，还是介绍 ABI 的约定，又或是早在 3.3.1 中介绍寄存器的使用，我们无数次提及 register 约定俗成的用法。为了加深印象、补充更多内容，我们这里再梳理一遍。</p><p>传递数据的时候，调用方（caller）和被调用方（callee）共同使用这所有的 16 个寄存器。那么，怎么保证 “在 caller 中保存特定数据的某些寄存器，在调用 callee 之后，callee 没有改变这些寄存器，并且还能看作原来的值，继续使用” 呢？</p><p>这就是约定 Callee-Saved 和 Caller-Saved Register 的作用了。它们的定义是：</p><ul><li><p>Caller-Saved: Caller saves temporaries values in its frame before the call <strong>but can be modified by procedures</strong>;</p></li><li><p>Callee-Saved: Callee saves temporaries values in its frame before using <strong>and restore them before returning to caller</strong>;</p><p><strong>（所以如果程序在某个 procedure 中使用了 <code>%rbp</code> 作为普通寄存器，那么能够保证这个函数 return 前 <code>%rbp</code> 会恢复到上一层的值，不会影响把 <code>%rbp</code> 当作 base pointer 使用的函数）</strong></p></li></ul><blockquote><p>回忆一下它们分别有哪些？</p></blockquote><p>所以，如果 caller 真的想要寄存器中的某些值不会被 callee 修改，在调用函数后仍然能使用，那么就应该把值放在 callee-saved register 当中。</p><p>此外，ABI 还规定了，callee 在返回前，需要把 callee-saved register 中的值恢复到原来的样子。</p><p>此外，一个介于特殊和普通之间的寄存器需要强调一下——<code>%rbp</code>，由于它有时作为分隔栈帧的 base pointer，所以如果有 callee 想要看作普通寄存器来使用它，那么需要在 return 前恢复到原来的状态。</p><blockquote><p>考虑一个问题，为什么 caller-saved register 一般没有要求 restore？</p><p>因为首先， caller-saved register 中保存函数参数的寄存器就是为了给 callee 读取的，所以调用前 caller 会设置这些寄存器的值，没有必要保持数据；另外如果 caller 真的想在调用之后使用这些值，那么可以<strong>把它的值放在自己的 callee-saved register 中，进而，因为 caller 自己也会是 callee，所以在 caller return 前也要恢复这个 callee-saved register</strong>（main 函数除外）；</p></blockquote><hr><p>那么这些约定在一般的代码中是如何体现的呢？下面以之前的 <code>incr</code> 函数为例子，我们加入一个 <code>call_incr2</code> 函数来展示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incr 函数见 5.3.3 的例子</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">call_incr2</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> v1 = <span class="number">15213</span>;</span><br><span class="line">    <span class="type">long</span> v2 = incr(&amp;v1, <span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> x + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">call_incr2:</span><br><span class="line">    pushq%rbx</span><br><span class="line">    subq$16, %rsp</span><br><span class="line">    movq%rdi, %rbx</span><br><span class="line">    movq$15213, 8(%rsp)</span><br><span class="line">    movl$3000, %esi</span><br><span class="line">    leaq8(%rsp), %rdi</span><br><span class="line">    callincr</span><br><span class="line">    addq%rbx, %rax</span><br><span class="line">    addq$16, %rsp</span><br><span class="line">    popq%rbx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>在上层 caller 进入 <code>call_incr2</code> 的第一件事就是把 <code>%rbx</code> 的值放到 <code>call_incr2</code> 的栈帧中。这是为什么？</p><p>原来，这个 <code>call_incr2</code> 函数有一个参数 <code>long x</code>，一开始存在 <code>%rdi</code> 中。但是，<code>call_incr2</code> 想要调用 <code>incr</code> 函数，后者要求两个参数，意味着 callee 会用到 <code>%rdi</code> 或更改。而在 <code>call_incr2</code> 的最后，<code>return x + v2;</code> 说明了等会还要用到现在 <code>%rdi</code> 中的值 x。所以，<code>call_incr2</code> 为了能够继续使用 x 这个值，需要将 x 存到 callee-saved register 中，<strong>因为调用 <code>incr</code> 之后，无论如何 <code>incr</code> 会将 callee-saved register 恢复到原来的数据的！</strong> 而在此之前，为了能够将这里使用的 callee-saved register 在返回前恢复到上一层调用前的状态，需要将原来的数据存在栈中。</p><blockquote><p>所以现在的情况是，</p><p>① caller 为了保留 caller-saved register（<code>%rdi</code>）的数据（因为要设置新的值给下一层 callee 来 passing data）所以要把 <code>%rdi</code> 数据放到 callee-saved register 中，这样调用后不变 ；</p><p>② 想要改变 callee-saved register，就需要保存之前的值，以保证上一层调用方在其中的值不变，而这个 callee-saved register 原先的值就放到了当前 caller 的栈帧中。</p><p><strong>考虑一个问题，为什么当前函数不把想要保存的数据直接保存在栈中，而是保存在 callee-saved register 中，完事还要为这个 callee-saved register 原先的值保存在自己的栈帧中？</strong></p><p>这是因为，直接保存在栈里不方便。如果有多个需要保存的数据，而且都放在栈里，那么读取方式、读取效率（可能会读很多次）都不佳；而且就没有必要设置 callee-saved register 了。</p><p>相反，如果保存在 callee-saved register 中，那么 caller 被调用后一开始统一保存上一层的 callee-saved register 的值，caller 返回前统一恢复上一层的 callee-saved register 的值，中间 caller 还能自由使用这些 callee-saved register，多次使用速度快，并且不用担心调用下一层函数会影响其中的值，岂不美哉！</p></blockquote><p>因此，在 <code>call_incr2</code> 调用 <code>incr</code> 之前，栈的情况如下图所示：</p><p><img src="imgs/procedure_example2_1.png" height="150px"></p><hr><p>总结：<strong>什么时候栈上会出现 Saved-Register 数据？答：当 caller 需要修改 callee-saved register 来保存某些值的时候，caller 会把数据保存到它的栈帧上。</strong>仅此一种情况。</p><h2 id="5-5-Illustration-of-Recursion"><a href="#5-5-Illustration-of-Recursion" class="headerlink" title="5.5 Illustration of Recursion"></a>5.5 Illustration of Recursion</h2><blockquote><p>本节将详细阐释 “递归” 这个技术在汇编层面的样貌。你会发现，因为有了之前所有的 mechanisms 的支持，C 编译器编译递归函数会和普通函数一样简单。</p></blockquote><p>以一个例子开始，这个 <code>pcount_r</code> 函数就是之前 “计算二进制数中有几个 1”（例子在 4.3）的递归版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Recursive popcount */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">pcount_r</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (x &amp; <span class="number">1</span>) + pcount_r(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个 trick，就是参数是 unsigned long 类型，这是为了让 <code>x &gt;&gt; 1</code> 运算是<strong>逻辑右移</strong>，千万不能用 signed 的类型，因为 <code>x &gt;&gt; 1</code> 是算数右移，所以对于负数而言永远不会停下；</p><p>下面是对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pcount_r:</span><br><span class="line">    movl$0, %eax</span><br><span class="line">    testq%rdi, %rdi</span><br><span class="line">    je.L6</span><br><span class="line">    pushq%rbx</span><br><span class="line">    movq%rdi, %rbx</span><br><span class="line">    andl$1, %ebx</span><br><span class="line">    shrq%rdi</span><br><span class="line">    callpcount_r</span><br><span class="line">    addq%rbx, %rax</span><br><span class="line">    popq%rbx</span><br><span class="line">.L6:</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure><p>你会发现递归版本的源码编译出的汇编代码可能稍微比之前迭代循环版本（loop）的汇编代码更长，这是因为递归版本需要额外管理栈的情况。</p><p>学完了前面几章节，你会发现这些代码就比较好懂了：</p><p>第一步将 <code>%rax</code>（<code>%eax</code>）置零，因为等会可能要 return 0；然后第二步按照 <code>x == 0</code> 的是真是假的答案来设置 condition codes，交由第三步判断并跳转。这是之前的 General Conditional Expression 的翻译方法；</p><p>接下来，将 <code>%rbx</code> 这个 callee-saved register 原来的值备份到当前栈帧中，是因为之后要用这个寄存器保存参数 x；果不其然，下一步就是把 <code>%rdi</code>（x）的值复制到 <code>%rbx</code> 中。</p><p>接下来用到 x 的地方，除了传给下一层 callee 的第一参数，就只有 <code>x &amp; 1</code> 了，所以直接在 <code>%rbx</code> 上与 1 按位且。下一步也直接在 <code>%rdi</code> 上逻辑右移 1 个单位，这就是传给下一层 callee 的第一参数（<code>x &gt;&gt; 1</code>）;</p><p>准备好 passing data 后，进行 passing control，调用 <code>call pcount_r</code> 进行跳转递归。</p><p>如果递归结束，那么紧接着就是把 <code>(x &amp; 1)</code>（即 <code>%rbx</code> 中的值）加到 callee 的结果（<code>%rax</code>）中，得到本函数的结果。最后别忘了在返回前从当前栈帧中恢复 callee-saved register <code>%rbx</code>，函数结束。</p><p>举完这个例子你会发现，这就是前几章所提到所有技巧的综合，它们使用了同一个约定——参数怎么传、可以用哪些寄存器、寄存器怎么用（还有是否要恢复）、如何参与计算等等。这个约定防止了不同函数在调用时相互摧毁寄存器中重要的值的异常情况。总之按照上面的方法使用寄存器，可以让生活更美好！</p><blockquote><p>补充一句，有些函数不依赖栈的结构来完成上述的机制，它们会采用堆或者其他数据结构来完成（例如 SML）。</p></blockquote><p>说了这么多，只有自己上手实践、自己亲自编译、调试这些代码，才能体会到各个部分、tricks、mechanisms 组合起来发挥的作用。</p><h2 id="5-5-Summary-for-Chapter-5"><a href="#5-5-Summary-for-Chapter-5" class="headerlink" title="5.5 Summary for Chapter 5"></a>5.5 Summary for Chapter 5</h2><p>本章的内容也是相当之多。为了进一步加深对于汇编 procedure 的认识，我们现在总结一下本章接触到的内容。</p><p>在本章开头，我们了解一种规范（接口）被称为 ABI，主要围绕 Linux ABI 展开介绍。ABI 规定了所有二进制程序、操作系统各个组件、编译器对于管理机器上的资源的使用规则，例如寄存器使用的场合和管理方法等等，这在之前的章节中也或多或少的提到过。</p><p>想要了解程序运行的总体 procedure，就不得不回答 3 个问题：<strong>程序是如何切换运行控制权的</strong>，<strong>程序如何传递数据的</strong>，还有<strong>程序如何在运行中管理 Memory 内存的</strong>；</p><p>为了搞清以上的问题，我们先了解了 x86 架构下的系统栈的简单结构。因为 C/C++ 是依赖于栈来管理程序上下文的语言，并且根据栈 LIFO 的原则，可以被用于：<strong>传递潜在信息、控制信息，分配 local 数据</strong>。正因如此，栈可以胜任<strong>管理过程中调用和返回状态</strong>的任务，也能隔离各个 procedure 示例之间的数据，为递归提供了坚实高效的结构基础。</p><p>x86 的栈需要注意的点有 3 个：</p><ul><li>栈就是在<strong>内存中的</strong>一段连续的数据结构，栈顶位于 low numbered address，栈底位于 high numbered address（头脑里有张图）；</li><li>栈顶指针由 <strong><code>%rsp</code></strong> 保存，一般不能手动修改，指向最上层被使用的空间，这意味着<strong>要先减小指针，再放入数据</strong>（或先取出数据，再增大指针）；</li><li>想要管理栈中的数据，依靠 <code>pushq</code> 和 <code>popq</code> 这两条指令，这两条指令的参数要求也有重大区别，可以思考一下为什么；</li></ul><p>随后考虑<strong>程序控制权切换的问题</strong>（Passing Control），具体表现就是<strong>调用时 caller 如何跳转到 callee、如何从 callee 返回到 caller</strong>。通过分析，passing control 由 3 个方面实现：</p><ul><li>系统<strong>栈</strong>提供数据结构存储层面的支持；</li><li>指令 <code>call &lt;LABLE&gt;</code> 通过：<strong>向栈中添加 return address</strong>、<strong>改变 <code>%rip</code> 的值来跳转至 callee</strong> 这两大工作来完成 caller 至 callee 的跳转；</li><li>指令 <code>ret</code> 通过：<strong>从栈中取出 return address</strong>、<strong>改变 <code>%rip</code> 的值来跳回 caller</strong> 这两大工作完成 callee 重新返回 caller 的控制流程。</li></ul><p>第二个点就是<strong>程序数据传输问题</strong>（Passing Data），在单线程程序中具体表现为 <strong>caller 如何向 callee 传递参数</strong>、<strong>callee 如何给 caller 返回值</strong>。在前几章的铺垫下，我们进一步记住了各个整型寄存器在 procedure 及其切换时的约定行为，例如 Caller-Saved / Callee-Saved、传入的函数参数由哪个寄存器  / 给出、函数的返回值由哪个寄存器传输。</p><p>前两个问题相对好解决，不过对于 <strong>程序如何在运行中管理 Memory 内存</strong> 这一部分而言，具体表现在进入 procedure 前如何为其分配空间、结束 procedure 前如何释放空间，需要较为详细地了解 x86 栈和<strong>栈帧</strong>的基本结构。对于 x86-64 Linux 而言，一个程序栈在<strong>当前函数实例</strong>中的栈帧从栈底到栈顶应该分别是：</p><ul><li>old <code>%rbp</code>（上一层 base pointer，如果本层也使用 <code>%rbp</code> 做 base pointer 的话，就指向此位置）；</li><li>上层 callee-saved register 备份值（Saved-Register）、local variables（函数局部变量）；</li><li>本函数作为 callee 时传入的超过 6 个的参数存放位置（依次，如果有的话）；</li><li>return address（如果本层函数是 caller，并且正好运行到 <code>call</code> 指令结束时）；</li></ul><p>每个函数结束后能否完全释放栈帧并回到原位、调用其他函数时能否准确分配足够的空间，则<strong>依赖代码的自身管理</strong>。</p><p>搞清了总体 procedure 的样貌，我们进一步讨论了各个寄存器的细节层面的管理约定。包括以下问题：</p><ul><li>Caller-Saved Register 和 Callee-Saved Register 各自有哪些种类和定义；</li><li>什么时候使用 Caller/Callee-Saved Register，在使用前后应该做哪些处理工作；</li><li>为什么要使用 Caller/Callee-Saved Register，栈中的 “Save-Register” 数据是怎么回事。</li></ul><p>到了本章结束，我们已经能从大致轮廓上认识一个程序运行的 procedure，仅限于整数、长整数、指针的数据传递的工作。</p><p>更多的细节，例如之前提到的<strong>浮点数如何传递、保存（浮点寄存器的行为）</strong>，<strong>聚合数据结构在汇编层面如何实现</strong>，等问题，会在下一章进行介绍。</p><h1 id="Chapter-6-Machine-Level-Programming-Ⅳ-Data"><a href="#Chapter-6-Machine-Level-Programming-Ⅳ-Data" class="headerlink" title="Chapter 6. Machine Level Programming Ⅳ - Data"></a>Chapter 6. Machine Level Programming Ⅳ - Data</h1><p>之前我们所见到的程序都是操纵正数 / 长整数 / 指针，它们都是<strong>标量整型数据</strong>。本章将讨论浮点寄存器的情形和聚合数据结构在汇编代码中的实现。</p><h2 id="6-1-Arrays-in-Assembly"><a href="#6-1-Arrays-in-Assembly" class="headerlink" title="6.1 Arrays in Assembly"></a>6.1 Arrays in Assembly</h2><h2 id="6-1-1-Array-Access-Normal-Array"><a href="#6-1-1-Array-Access-Normal-Array" class="headerlink" title="6.1.1 Array Access: Normal Array"></a>6.1.1 Array Access: Normal Array</h2><p>众所周知，数组在 C/C++ 中声明的语法为 <code>T A[L];</code>，表示 Array of data type <code>T</code> and length <code>L</code>；</p><p>这说明了 2 件事：</p><ol><li>数组应该在内存中分配的方式：<strong>Contiguously allocated region of <code>L * sizeof(T)</code> bytes in memory</strong>;</li><li>identifier <code>A</code> 可以被用作<strong>指向数组开头位置的指针（类型 <code>T*</code>）</strong>；</li></ol><blockquote><p>下面的方法都是合理的，请试着分析表达式的含义（<code>val</code> 的类型是 <code>int*</code>）：</p><p><code>val[4]</code>、<code>val</code>、<code>val + 1</code>、<code>&amp;val[2]</code>、<code>*(val + 1)</code>、<code>*val + 1</code>;</p><p>提示：对于指针类型 <code>T*</code> 的增、减运算而言，单位 1 会是 <strong><code>sizeof(T)</code></strong>，也就是说，对这个指针增加 1，那么指针的值实际增加 <code>sizeof(T)</code>；</p><p><strong>补充 C/C++ 基础-1</strong>：指针和数组变量的区别之一是，改变数组变量 <code>val</code> 不是正确的，因为 <code>val</code> 是指针常量；</p></blockquote><hr><p>现在看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZLEN 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> zip_dig[ZLEN];</span><br><span class="line"></span><br><span class="line">zip_dig cmu = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">zip_dig mit = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">zip_dig ucb = &#123; <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>一些编程建议：① 不要将常数随便写死在程序的各个角落，这被称为 magic number，不但不利于阅读，也不利于维护；② 对于 C/C++ 中复杂的数据类型的定义，建议使用 <code>typedef</code> 关键字，这样可以提升可读性；</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_digit</span><span class="params">(zip_dig z, <span class="type">int</span> digit)</span> &#123; <span class="keyword">return</span> z[digit]; &#125;</span><br></pre></td></tr></table></figure><p>上面这个函数的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_digit:</span><br><span class="line">    movl(%rdi, %rsi, 4), %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>由于数组标识符也是指针，因此传入的方式和之前的相同。上面的指令含义是找到地址为 <code>%rdi + 4 * %rsi</code> 的 memory 引用，并将这里的值赋给 <code>%rax</code> 的 low-order 32-bit（<code>%eax</code>）;</p><p>4  就是编译器自己加上的对于 <code>int</code> 类型大小的缩放因子。</p><p>再来一段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zincr</span><span class="params">(zig_dig z)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ZLEN; i++)</span><br><span class="line">        z[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zincr:</span><br><span class="line">    movl$0, %eax</span><br><span class="line">    jmp.L3</span><br><span class="line">.L4</span><br><span class="line">    addl$1, (%rdi, %rax, 4)</span><br><span class="line">    addq$1, %rax</span><br><span class="line">.L3</span><br><span class="line">    cmpq$4, %rax</span><br><span class="line">    jbe.L4</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure><p>这里汇编代码对 for 循环的处理是转化为 while 循环并采用 “jump to middle” translation；</p><p>首先初始化部分将 <code>%rax</code> 置零作为存放 i 的寄存器，接着跳至 <code>.L3</code> 判断部分；</p><p><code>.L3</code> 判断部分将 <code>%rax</code>（i）和 4 比较，只有 unsigned <code>i ≤ 4</code>（<code>CF | ZF</code>）时才进入 <code>.L4</code> 循环；</p><p>在 <code>.L4</code> 循环中，先将地址为 <code>%rdi + 4 * %rax</code> 的 memory 引用处的数据加 1，并且将 <code>%rax</code> 中的数据加 1（<code>i++</code>）；</p><hr><blockquote><p><strong>补充 C/C++ 基础-2</strong>：为了掌握 C/C++ 数组的核心思想，你必须能够理解以下的声明的含义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A1[<span class="number">3</span>];        <span class="comment">// 一个长度为 3 的整型数组</span></span><br><span class="line"><span class="type">int</span> *A2[<span class="number">3</span>];        <span class="comment">// 一个长度为 3 的整型指针 构成的数组</span></span><br><span class="line"><span class="type">int</span> (*A3)[<span class="number">3</span>];    <span class="comment">// 一个指向 长度为 3 的整型数组 的指针</span></span><br></pre></td></tr></table></figure><p><strong>提示：C/C++ 阅读类型声明的关键是从内向外读，这条道理不仅适用于上面的 <code>int (*A3)[3]</code>，还适用于函数指针等复杂类型的阅读</strong>。例如 <code>int**(*)(int*, int)</code> 是指向参数表为 <code>(int*, int)</code>、返回值类型为 <code>int**</code> 的函数的指针。</p><p><strong>补充 C/C++ 基础-3</strong>：数组变量和指针的区别之一是，在声明数组时程序不仅会为数组标识符这个指针来分配空间，而且会为数组中的所有元素分配空间；但指针只会为自身分配空间。这就导致<strong>二者调用 <code>sizeof</code> 的大小是不同的</strong>；例如 <code>sizeof(A3) == 8</code>，<code>sizeof(*A3) == 12</code>，<code>sizeof(**A3) == 4</code>;</p><p>⚠ 另外，如果想判断什么类型的指针取 <code>*</code> 后会导致野指针 / 空指针引用错误，应该想想<strong>在一开始声明的时候，程序有没有为其自动分配空间</strong>。例如上面的例子，如果使用 <code>*A3</code> 则可能出现空指针引用错误，但 <code>*A2</code> 就不会。</p></blockquote><p>为什么要 “补充 C/C++ 基础 1~3” ？<strong>因为只有清楚了解程序的源码表示的含义，才能去关注、正确认识编译后的代码</strong>。</p><h2 id="6-1-2-Array-Access-Two-Dimension-Array"><a href="#6-1-2-Array-Access-Two-Dimension-Array" class="headerlink" title="6.1.2 Array Access: Two Dimension Array"></a>6.1.2 Array Access: Two Dimension Array</h2><blockquote><p>⚠ 本节讨论的 array 规模全部是 <code>constexpr</code>（编译前确定）；</p></blockquote><p>这个时候我们再看二维数组的真实含义。</p><p>⚠ <strong>注意：由上面的讨论可知，一共有 2 类二维数组，尽管源码的使用上是一样的，但汇编层面完全不同！！！</strong></p><ul><li><p>Nested Array</p><ul><li><p>在 C/C++ 中，一种二维数组的声明语法为 <code>T A[R][C];</code>，其实是 <code>T[C] A[R];</code> 的另一种写法，表示 <strong><code>A</code> 是一个包含 <code>R</code> 个元素的数组，其元素是包含 <code>C</code> 个元素的数组</strong>。</p></li><li><p>这种数组被称为 <strong>Nested array</strong>，特点是二维数组中<strong>所有元素的空间在声明时都被自动分配了，更重要的是，它们是连续的</strong>。</p></li><li><p>另一个需要关注的点是，<strong>Nested array 是 “Row-Major” 的，即行优先，第一个索引应该指定行，并且分配空间、存储时，连续的部分也是行，又称 Row Vectors</strong>。</p></li><li><p>Nested Array 的每个行向量 <code>A[i]</code> 开始的地址是 <strong><code>A + i * C * sizeof(T)</code></strong>，每个元素 <code>A[i][j]</code> 的地址是 <strong><code>A + (i * C + j) * sizeof(T)</code></strong>（由 <code>A + i * C * sizeof(T) + j * sizeof(T)</code> 化简得来）;</p></li></ul></li></ul><p><img src="imgs/nested_array.png" height="200px"></p><ul><li>Multi-Level Array<ul><li>另一种二维数组的声明方式是 <code>T* A[R];</code>，随后在初始化中（在栈中）/ new 上（在堆中）数组的各个元素。</li><li>这种数组称为 <strong>Multi-level array</strong>，在声明时，<strong>仅为每个一级元素（<code>int*</code>）进行了空间分配</strong>。</li><li><strong>事实上，这种声明的数组每一行的存储位置可以不是连在一起的，甚至每一行的元素可以不同</strong>！因此每个元素的地址计算应该<strong>取决于 <code>A</code> 中每个元素的值</strong>！没法通过标识符 <code>A</code> 直接取得。</li></ul></li></ul><p><img src="imgs/multi_level_array.png" height="200px"></p><hr><p>我们继续利用之前 <code>zip_dig</code> 的例子，我们分别声明两种类型的二维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PCOUNT 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UCOUNT 3</span></span><br><span class="line"></span><br><span class="line">zip_dig pgh[PCOUNT] = &#123;                    <span class="comment">// Nested array</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> *univ[UCOUNT] = &#123; mit, cmu, ucb &#125;;    <span class="comment">// Multi-level array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里分别是使用它们的两个函数</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">get_pgh_zip</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="keyword">return</span> pgh[index]; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_univ_digit</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> digit)</span> &#123; <span class="keyword">return</span> univ[index][digit]; &#125;</span><br></pre></td></tr></table></figure><p>这时对应函数的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">get_pgh_zip:</span><br><span class="line">    leaq(%rdi,%rdi,4), %rax</span><br><span class="line">    leaqpgh(,%rax,4), %rax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">get_univ_digit:</span><br><span class="line">    salq$2, %rsi</span><br><span class="line">    addquniv(,%rdi,8), %rsi</span><br><span class="line">    movl(%rsi), %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>注意到，这里使用的 <code>pgh</code>、 <code>univ</code> 是全局变量，不存储在栈中，意味着在汇编代码中<strong>可以直接使用变量名称来表示全局变量</strong>。有些时候，编译器输出的汇编代码对于全局变量的处理中也会<strong>直接使用地址</strong>。</p><p>注意！这时候两个数组的索引方式就有差别了。</p><p>对于使用 Nested array 的函数 <code>get_pgh_zip</code> 而言，第一步是相当于进行算术计算 <code>%rax = 5 * %rdi</code>，第二步还是相当于算术计算 <code>%rax = pgh + 4 * %rax</code>。这两步的真实含义是：<code>%rax = pgh + sizeof(int) * 5 * index</code>，这里的 5 就是之前提到的<strong>每列列宽</strong>；</p><p>它可以表示：<code>&amp;Memory[pgh + 5 * sizeof(int) * index]</code>，取得其中的指针；</p><p>对于使用 Multi-level array 的函数 <code>get_univ_digit</code> 而言，<strong>事情完全不一样！</strong></p><p>第一步将 <code>%rsi</code> 的值（<code>digit</code>）乘以 4，没什么好说的；</p><p>第二步注意，这里不是 <code>leaq</code> 而是 <code>addq</code>，说明这里先取得 <code>univ + 8 * %rdi</code> 中的值，并把它看作地址，找到 memory 中该地址对应的引用值。最后把 <code>%rsi</code> 加上引用值;</p><p>这两步<strong>没法写出真实含义的表达式，因为涉及 memory 取值。但可以表示为</strong>：</p><p><code>Memory[Memory[univ + sizeof(int*) * index] + sizeof(int) * digit]</code>;</p><p>最后 <code>get_univ_digit</code> 才把计算好的地址使用 Simple Memory Addressing Mode 取出值，并赋给 <code>%rax</code>（<code>%eax</code>）;</p><hr><p>对比上面两种二维数组的汇编操作，这说明了不同的结构决定了不同的计算方法。前者只需要对<strong>数组标识符</strong>和<strong>索引</strong>进行算术计算，就能得到地址；而后者必须先由<strong>数组标识符</strong>和<strong>行参数</strong>找到一级元素内容，然后用<strong>一级元素内容</strong>和<strong>列索引</strong>才能定位具体的元素位置。</p><h2 id="6-1-3-Array-Access-M-×-N-Matrix"><a href="#6-1-3-Array-Access-M-×-N-Matrix" class="headerlink" title="6.1.3 Array Access: M × N Matrix"></a>6.1.3 Array Access: M × N Matrix</h2><ul><li>对于恒定（constexpr）规模、声明时已分配内存的矩阵而言，就是上一节说的 Nested array；</li><li>对于作为参数传入的 Nested array（未知规模，但空间连续），则必须进行乘法计算（开销较大）结合其他算术计算得出位置；</li></ul><p>总而言之，访问数组的思路就是之前说的 Multi-level array 和 Nested array 两类。其他情况可以同理思考。</p><h2 id="6-2-Structures-in-Assembly"><a href="#6-2-Structures-in-Assembly" class="headerlink" title="6.2 Structures in Assembly"></a>6.2 Structures in Assembly</h2><h2 id="6-2-1-Structure-Representation"><a href="#6-2-1-Structure-Representation" class="headerlink" title="6.2.1 Structure Representation"></a>6.2.1 Structure Representation</h2><p>关于结构体的存储和表示，有下面的 3 条简单规则：</p><ul><li><p>结构体本身在内存中的表示是<strong>连续的</strong>，并且 “big enough to hold all of the fields”；</p></li><li><p>结构体中各个字段在内存中的排布顺序<strong>严格</strong>按照源码中的<strong>声明顺序</strong>；</p></li><li><p><strong>编译器来决定所有字段存储的空间和字节偏移、对齐情况</strong>（相对结构体地址的位置）；</p><blockquote><p>整个过程对汇编层面透明，汇编代码是看不出来这里定义了一个结构体的，只能看到一系列变量排列在内存上；</p></blockquote></li></ul><h2 id="6-2-2-Structure-Access-Generate-Pointer-to-Structure-Member"><a href="#6-2-2-Structure-Access-Generate-Pointer-to-Structure-Member" class="headerlink" title="6.2.2 Structure Access: Generate Pointer to Structure Member"></a>6.2.2 Structure Access: Generate Pointer to Structure Member</h2><p>其实通过 structure representation 就能略知如何用指针找各个字段了。这里以一个例子说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rec</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">get_ap</span><span class="params">(<span class="keyword">struct</span> rec *r, <span class="type">size_t</span> idx)</span> &#123; <span class="keyword">return</span> &amp;r-&gt;a[idx]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_val</span><span class="params">(<span class="keyword">struct</span> rec *r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (r) &#123;</span><br><span class="line">        <span class="type">int</span> i = r-&gt;i;</span><br><span class="line">        r-&gt;a[i] = val;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get_ap</code> 函数对应的汇编代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_ap:</span><br><span class="line">    leaq(%rdi,%rsi,4), %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这里的操作表明了 <code>%rax = %rdi + 4 * %rsi</code>，即 <code>%rax = r + sizeof(int) * idx</code>。这说明了 <code>struct rec</code> 中的第一个成员就位于 <code>rec</code> 空间的开头，并按正常的整型数组进行排列。</p><p>但是对于另外一个函数 <code>set_val</code> 而言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set_val:</span><br><span class="line">.L11:</span><br><span class="line">    movslq16(%rdi), %rax</span><br><span class="line">    movl%esi, (%rdi,%rax,4)</span><br><span class="line">    movq24(%rdi), %rdi</span><br><span class="line">    testq%rdi, %rdi</span><br><span class="line">    jne.L11</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>第一步可以认为 <code>movslq</code> 就是 <strong>取 <code>Src</code> 的 32-bit 数据，符号扩展为 64-bit 数据后放入 <code>Dst</code></strong>，作用是将地址为 <code>%rdi + 16</code>（即 <code>r + 4 * sizeof(int)</code>）的 memory 引用的值覆盖到 <code>%rax</code> 上去。完成了源码的 <code>int i = r-&gt;i;</code> 这一步；</p><p>从这里可以看出，编译器将 <code>int a[4]</code>、<code>int i</code> 和 <code>struct rec* next</code> 这三个成员排在一起，<strong>是没有间隔的，如下图。但某些场合下编译器指定可能会出现间隔</strong>，这是是为了<strong>内存对齐的原因，下面马上会讨论结构体的内存对齐</strong>。</p><p><img src="imgs/struct_example.png" height="150px"></p><p>第二步 <code>movl</code> 将 <code>%esi</code>（<code>%rsi</code> 的 low-order 32-bit）的值赋给地址为 <code>%rdi + 4 * %rax</code>（即 <code>r + sizeof(int) * i</code>）的 memory 引用，完成了 <code>r-&gt;a[i] = val;</code> 这步；</p><p>第三部让 <code>%rdi</code> 的值变为 “地址为 <code>%rdi + 24</code> 的 memory 引用的值”，相当于 <code>r = r-&gt;next;</code></p><p>剩下的部分就是完成 while 循环的判断任务。</p><p><strong>上面的例子中，还有一个重要的问题没有阐释——结构体的内存对齐问题</strong>。</p><p>那么为什么要对结构体进行内存对齐？又是如何进行内存对齐的？再来看另外一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure><p>对于这个结构体而言，如果每个成员紧紧挨在一起，那么在内存中的排布是这样的：</p><p><img src="imgs/struct_example2_unaligned.png" height="60px"></p><p>但实际上编译器会在其中插入一些空数据块，让内存排布变成这样：</p><p><img src="imgs/struct_example2_aligned.png" height="125px"></p><p>这就是因为，x86-64（和其他很多架构的机器）规定了结构体内存对齐的规则。为什么要有这样的规则？这其实是 <strong>硬件效率问题</strong>。</p><p>对于当今大多数机器的内存系统而言，实际从硬件内存中一次读取的数据量大约 64 bytes，本身称为一个读取的<strong>数据块</strong>，大小取决于机器硬件中的各种宽度。所以，如果因为没有对齐的地址，而导致读取时特定的数据跨越了两个数据块的边界，那么很可能会导致操作系统需要采取一些额外的步骤来处理这种情况，从而大大降低处理效率。</p><p>除了上面的这种原因，还有种原因是，如果这些未对齐的结构体组成了数组，那么想要<strong>索引</strong>这些数组的计算将会非常复杂，<strong>使用起来也非常不方便</strong>。</p><p>鉴于以上原因，很多架构都采用了这种内存对齐的思路。其实内存对齐除了在结构体这里，我们之前在 “跳表” 的汇编代码（4.4）中也看到了内存对齐的指令（<code>.align</code>）；</p><blockquote><p>如果某种编译器编译程序时，没有安排内存对齐，那么在 x86-64 的架构上运行是没有问题的，因为微架构中有解决这个问题的方法（重新读入），速度可能会慢一点；但有些架构完全不能运行，会抛出内存错误的异常。</p></blockquote><p>那么如何对齐能够解决上面的问题？x86-64 架构提出了以下<strong>内存对齐的原则</strong>：</p><ol><li><p><strong>Primitive data type requires K bytes, so its address must be multiple of K</strong>;</p><p>如果原始数据类型的大小是 K bytes，那么它（所对应成员）的起始地址必须能被 K 整除。</p><blockquote><p><strong>现在提出一个 “对齐整除数” 的定义：一个数据结构位于结构体 / 联合体中时，地址需要为一个数 K 的整数倍，这个 K 就是该数据结构的 “对齐整除数”</strong>；</p><p>因此，最直接的结论是：primitive data（基础数据类型）的对齐整除数是其自身的大小（切记，由于概率原因，非基础数据类型的对齐整除数通常都不是自身大小，所以一定不能想当然）。</p><p>primitive data 包括：<strong>所有 size 的整型（short / int 等）、所有 size 的浮点型、char、bool（C 中没有）</strong>；</p><p>数组、结构体都不是 primitive data，所以它们的对齐整除数满足：</p><p>如果结构体中存在<strong>数组</strong>，则<strong>本身不存在对齐要求，因此它的对齐整除数一定是单个元素的对齐整除数</strong>，因为数组各元素大小相同，并且不存在 padding 的情况，直接将各个元素无缝堆砌；</p><p>如果结构体中存在<strong>结构体 / 联合体</strong>成员，那么该成员的<u>对齐整除数</u>以<strong>其中最大的原始数据类型的</strong>为准；</p></blockquote></li><li><p><strong>Overall structure length must be multiple of $\max\limits_{i}{K_i}$, where $\max\limits_{i}{K_i}$ is the largest alignment requirement in this structure</strong> (otherwise “external padding”).</p><p>结构体 / 联合体总体的大小必须是其<strong>所有成员中最大的对齐整除数</strong>的整数倍。（满足上一条后，编译器可以通过在结构体尾部追加空数据块来实现）</p></li></ol><p>例如：</p><ul><li>对于 1 byte 的数据类型（如 <code>char</code>），这种类型成员在内存上的排布没有限制，哪里有空往哪搬；</li><li>对于 2 bytes 的数据类型（如 <code>short</code>），这种类型成员要求起始地址必须能被 2 整除（即 LSB of address must be $0_2$）；</li><li>对于 4 bytes 的数据类型（如 <code>int, float</code>），要求起始地址必须能被 4 整除（即 lowest 2 bits of address must be $00_2$）；</li><li>对于 8 bytes 的数据类型（如 <code>double, long, x86-64下各种 pointer</code>），要求起始地址必须能够被 8 整除（即 lowest 3 bits of address must be $000_2$）；</li><li>对于 16 bytes 的数据类型（如 <code>x86-64 gcc/Linux下的 long double</code>），要求起始地址必须能被 16 整除（即 lowest 4 bits of address must be $0000_2$）；</li></ul><p>再例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure><p>这个结构体的内存对齐方式如下：</p><p><img src="imgs/struct_example2_aligned_tail.png" height="125px"></p><p>因为其中含有 <code>double</code> 数据类型，所以总体大小必须是 8 的整数倍；又因为整体长度不是 8 的整数倍（<code>p + 17</code>），所以尾部补充空数据块到 <code>p + 24</code>;</p><h2 id="6-2-3-Accessing-Arrays-of-Structure"><a href="#6-2-3-Accessing-Arrays-of-Structure" class="headerlink" title="6.2.3 Accessing Arrays of Structure"></a>6.2.3 Accessing Arrays of Structure</h2><p>更进一步地，如果有一个结构体数组，并且结构体是被正确定义的，那么编译器就能很容易地确定各个结构体的大小、成员位置和数组的大小，从而在其他使用到的场合为其正确地分配空间、索引成员；</p><p>来看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> i;</span><br><span class="line">    <span class="type">float</span> v;</span><br><span class="line">    <span class="type">short</span> j;</span><br><span class="line">&#125; a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>如果你使用 <code>sizeof(S3)</code> 的话，你会发现值是 12，说明编译器生成的空数据块的大小也计算在内。具体的结构如下图所示，在 <code>i</code> 和 <code>v</code> 成员间、结构体尾部都有分配空数据块：</p><p><img src="imgs/struct_example3.png" height="125px"></p><p>还有使用它的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="title function_">get_j</span><span class="params">(<span class="type">int</span> idx)</span> &#123; <span class="keyword">return</span> a[idx].j; &#125;</span><br></pre></td></tr></table></figure><p>对照 <code>S3</code> 结构体的内存分布图，你就会发现这个函数的汇编代码也没有那么难以理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get_j:</span><br><span class="line">    leaq(%rdi,%rdi,2), %rax</span><br><span class="line">    movzwla+8(,%rax,4), %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>我们来解释上面例子的汇编行为：</p><p>第一步是相当于算术运算 <code>%rax = 3 * %rdi</code>;</p><p>第二步是 <code>%rax = a + 8 + 4 * %rax</code>，实质上是 <code>%rax = a + 8 + 4 * 3 * idx</code>，对照上面的内存分布情况可以理解，<code>a + 8</code> 就指向 <code>a[0].j</code>，而后面加 <code>4 * 3 * idx</code> 则是因为每个结构体占位 <code>4 * 3 bytes = 12 bytes</code> 的空间，这样就对应着 <code>a[idx].j</code> 的位置了。</p><blockquote><p><strong>这里的总结一下遇到的乱七八糟的 <code>movXXX</code> 指令</strong>。</p><p><code>movzbl</code> 和 <code>movsbl</code> 的作用相近，都是<strong>将 8-bit 扩展到 32-bit</strong>。但前者是 <strong>zero extension</strong> 零扩展（根据 <strong>extension conclusion</strong>，针对 unsigned 的扩展），而后者是 <strong>sign extension</strong> 符号扩展（针对 signed 的扩展）；</p><p><code>movzwl</code> 和 <code>movswl</code> 很像，前者是 16-bit（1 word）<strong>零扩展移动</strong>至 32-bit，后者是 16-bit <strong>符号扩展移动</strong>至 32-bit（long）；</p><p><code>movslq</code> 同理。</p><p>⚠ <strong>值得注意的是，<code>movzlq</code> 指令不存在，因为它的字面作用和 <code>movl</code> 相同，想想为什么</strong>。</p><p><strong>如果你会看指令名称的含义的话，上面的内容就无需记忆了</strong>：在 <code>mov&lt;A&gt;&lt;B&gt;&lt;C&gt; &lt;Src&gt;, &lt;Dst&gt;</code> 中，</p><p>A 表示扩展种类，可以是 <code>z</code>（zero extension）、<code>s</code>（sign extension）；</p><p>B 表示扩展源（<code>Src</code>）的大小，可以是 <code>b</code>（1 byte，8 bits），<code>w</code>（word，1 字，16 bits）、<code>l</code>（2 字，32 bits）、<code>q</code>（quadword，4 字，64 bits）；</p><p>C 表示扩展目标（<code>Dst</code>）的大小，可以取的值和 B 相同，但两者不能同时取一个值。</p><p>除此以外就是普通的 <code>mov&lt;X&gt;</code>（没有扩展功能）和条件移动 <code>cmov&lt;cond&gt;</code> 指令了。 </p></blockquote><h2 id="6-2-4-Saving-Space"><a href="#6-2-4-Saving-Space" class="headerlink" title="6.2.4 Saving Space"></a>6.2.4 Saving Space</h2><p>现在，我们了解了结构体的基本排布和表示，也知道了结构体内存对齐的规则。有些同学可能会发现，诶，因为结构体各成员在内存中的排布顺序严格按照源码声明的顺序，那么<strong>结构体中各个成员排布的不同，是不是会导致结构体最终所占的大小不同？</strong></p><p>答案是肯定的，所以，有必要讨论一下 “按什么方式声明结构体，能够让指定结构体的空间占用最小” 这个问题。下面是结论：</p><ul><li><p><strong>将占用空间较大的数据类型声明在前面</strong>。</p><blockquote><p>这种贪心算法是有效的。因为所有数据类型的大小只有 1、2、4、8、16 bytes，全是 2 的整数次幂，在数学上来说能够严格证明。</p></blockquote></li></ul><p>下面的例子中，<code>S4</code> 和 <code>S5</code> 相比，<code>S5</code> 更节省空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125; *p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S5</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure><h2 id="6-3-Floating-Point-in-Assembly"><a href="#6-3-Floating-Point-in-Assembly" class="headerlink" title="6.3 Floating Point in Assembly"></a>6.3 Floating Point in Assembly</h2><h2 id="6-3-1-History-amp-Background-for-Representing-FP"><a href="#6-3-1-History-amp-Background-for-Representing-FP" class="headerlink" title="6.3.1 History &amp; Background for Representing FP"></a>6.3.1 History &amp; Background for Representing FP</h2><p>在 x86 架构中，floating point 的表示有着比较深的历史。</p><p><strong>x87 FP</strong></p><p>很早之前，Intel 的 8087 芯片和 IEEE 浮点数标准一起诞生，安装在 8086 处理器上，是第一个能够完全处理 IEEE 浮点数运算的集成单元。但是编程模型从现在看来比较糟糕，所以 CSAPP 第三版就把这方面的内容完全移除了（expunged）；</p><p><strong>MMX FP</strong></p><p>1997 年 Intel 公司推出了多媒体扩展指令集 MMX，它包括57条多媒体指令。MMX 指令主要用于增强 CPU 对多媒体信息的处理能力，提高 CPU 处理 3D 图形、视频和音频信息的能力。</p><p><strong>SSE FP</strong></p><p>随着人们日益增长的精神文化的需要，例如核显渲染的浮点数运算需求增长，人们迫切需要并行计算的手段，于是一个全新的思路就出现了——<strong>SIMD（Single Instruction Multiple Data），单指令多数据</strong>，和整型寄存器不一样，我们在浮点数寄存器上多放几个数同时计算，那么运算速度不就上去了？</p><p>紧接着，一套新的指令拓展集 SSE（Streaming SIMD Extension）被设计出来，兼容 MMX 指令，配合一套浮点寄存器，来完成标量浮点数，或者单指令多数据的浮点数的计算。</p><p><strong>AVX FP</strong></p><p>在2010 年 AVX 将之前浮点运算数据的宽度从 128 bits 的扩展到 256-bits。同时新的 CPU 架构下数据传输速度也获得了提升。AVX 指令集在 SIMD 计算性能增强的同时也沿用了的 MMX/SSE 指令集。不过和 MMX/SSE 的不同点在于，增强的 AVX 指令在指令的格式上也发生了很大的变化。x86 (IA-32/Intel 64) 架构的基础上增加了prefix，所以实现了新的命令，也使更加复杂的指令得以实现，从而提升了 x86 CPU的性能。</p><blockquote><p>AVX 并不是 x86 CPU 的扩展指令集，可以实现更高的效率，同时和 CPU 硬件兼容性也更好，在 SSE 指令的基础上 AVX 也使 SSE 指令接口更加易用；</p></blockquote><h2 id="6-3-2-Programming-with-SSE3"><a href="#6-3-2-Programming-with-SSE3" class="headerlink" title="6.3.2 Programming with SSE3"></a>6.3.2 Programming with SSE3</h2><p>在 SSE 第 3 版中，指明了 x86 架构有 <strong>16 个 floating point registers</strong>（和之前的 16 个 integer registers 完全不同），每个 floating point register 空间大小 <strong>16 bytes</strong>（大概是 integer register 的两倍大）；</p><p>它们又叫 <code>XMM</code> Register（名称的历史渊源比较多，此处省略，感兴趣看 CSAPP 原书 P294），所以这些寄存器的名称：<code>%xmm0 ~ %xmm15</code>;</p><p>其中，按照<strong>指令使用的不同</strong>，每个 <code>XMM</code> Register 都可以存储：</p><ul><li>16 个 1 byte 整型（<code>char</code>）；</li><li>或 8 个 2 bytes 整型（<code>short</code>）；</li><li>或 4 个 4 bytes 整型（<code>int</code>）；</li><li>或 4 个 单精度浮点数（<code>float</code>）；</li><li>或 2 个双精度浮点数（<code>double</code>）；</li><li>或 1 个 单精度浮点数（<code>float</code>，没存满，有剩余空间）；</li><li>或 1 个 双精度浮点数（<code>double</code>，没存满，有剩余空间）；</li></ul><p><img src="imgs/xmm_registers.png" height="400px"></p><p>这意味着浮点数寄存器<strong>既可以处理整型，又可以处理浮点数类型</strong>；<strong>既可以处理一个数的运算，又可以多个数并行运算</strong>。</p><p>这种一次计算单个数的指令被称为 <strong>Scalar Operations（标量运算）</strong>，一次并行计算多个数的指令被称为 <strong>SIMD Operations（单指令多数据运算）</strong>。</p><p>具体的命令长什么样子的呢？还是经典的 <strong>名称+后缀</strong> 命名方法，所以如果你能读懂命名方法，那就不用记忆太多的指令了。</p><p>对于浮点数运算而言，主要有 4 种指令：<code>addss</code>、<code>addps</code>、<code>addsd</code>、<code>addpd</code>；</p><p>会读的同学已经懂了，就是 <code>&lt;OP_NAME&gt;&lt;OP_TYPE&gt;&lt;DATA_TYPE&gt;</code> 的组合嘛！</p><ul><li><p><code>OP_NAME</code> 就是运算的名称，这里是 <code>add</code> 加法运算（显然还有 <code>mov</code> 移动、<code>sub</code> 减法等等）；</p></li><li><p><code>OP_TYPE</code> 是运算类型，上面提到的 <code>s</code> 代表 Scalar 标量运算（一次算一个数），<code>p</code> 代表 Packed 多数据运算（一次算一组数）；</p><blockquote><p>特别地，如果强调是对齐的数据，那么 <code>OP_TYPE</code> 还有前缀 <code>a</code> 代表 aligned，例如：<code>movapd</code>;</p></blockquote></li><li><p><code>DATA_TYPE</code> 是运算的数据类型，<code>s</code> 代表 Single precision floating point，<code>d</code> 代码 Double precision floating point；</p></li></ul><p>所以举个例子，<code>addpd</code> 就是双精度浮点数的 SIMD 加法运算指令嘛！</p><p>运算的参数和之前的整型寄存器运算一样，<code>&lt;Src&gt;, &lt;Dst&gt;</code>;</p><p>运算的内存表示就是如图：</p><p><img src="imgs/sse_fp_addition.png" height="400px"></p><p>除此以外，FP 还有 <strong>2 点</strong>需要注意：</p><ol><li><p>FP Registers 的 Saving Conventions：</p><ul><li><p><code>%xmm0 ~ %xmm15</code> 就是依次传递参数的 register，参数多于 15 个浮点数类型，则和多出 6 个的整型参数一样，会放到栈帧中去；</p></li><li><p><code>%xmm0</code> 也是约定<strong>返回浮点数值</strong>的存放位置；</p></li><li><p><strong>所有的 <code>XMM</code> Register 都是 Caller-Saved Register</strong>，没有 Callee-Saved Register；</p></li></ul></li><li><p>FP 的还有众多的命令等待认识，不过最重要的还是之前提到的<strong>记忆指令的命名方法</strong>，理解了命名方法就能更少地记忆指令；</p><ul><li><p>FP 数据比较指令：<code>ucomiss</code>（Unordered Compare Scalar Single Precision Floating Point）、<code>ucomisd</code>（Unordered Compare Scalar Double Precision Floating Point）；</p><blockquote><p>和 <code>cmpq</code> 大致相似，会设置 condition codes，包括 <code>CF/ZF/SF</code>；</p></blockquote></li><li><p>FP 常数使用：这里 <code>$</code> 符号<strong>只能</strong>接整型常量，所以如果要使用浮点数常量，需要 <code>xorpd %xmm0 %xmm0</code> 等类似指令运算出 / 从内存中读入才能使用。</p></li></ul></li></ol><p>事实上，之前我们一直担心的 “<strong>浮点数如何通过寄存器传递参数</strong>” 等问题，只要有了命令就非常简单，操作方法几乎和 integer registers 一样。下面是一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">fadd</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">dadd</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">dincr</span><span class="params">(<span class="type">int</span>* p, <span class="type">double</span> v)</span> &#123;</span><br><span class="line">    <span class="type">double</span> x = *p;</span><br><span class="line">    *p = x + v;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fadd:</span><br><span class="line">    addss%xmm1, %xmm0</span><br><span class="line">    ret</span><br><span class="line">dadd:</span><br><span class="line">    addsd%xmm1, %xmm0</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">dincr:</span><br><span class="line">    movapd%xmm0, %xmm1</span><br><span class="line">    movsd(%rdi), %xmm0</span><br><span class="line">    addsd%xmm0, %xmm1</span><br><span class="line">    movsd%xmm1, (%rdi)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>函数 <code>fadd</code> 和 <code>dadd</code> 没有什么好说的，主要看 <code>dincr</code>：</p><p>第一步 <code>movapd</code> 见名知意，Move Aligned Packed Double Precision Floating Point，成组移动双精度浮点数，参数类型和其他的 <code>mov</code> 指令相同；</p><p>这里的 <code>%xmm0</code> 里装的是<strong>函数第二参数 <code>double v</code></strong>（第一参数是指针整型，所以放在 <code>%rdi</code>），移动到了未使用到的 <code>%xmm1</code> 寄存器中；</p><p>第二步 <code>movsd</code>，Move Scalar Double Precision Floating Point，移动标量双精度浮点数，将地址为 <code>%rdi</code> 的 memory 引用值（也就是 <code>p</code> 指向的内存 double 数据）赋给 <code>%xmm0</code>（x），并且最终将作为返回值返回；</p><p>第三步就是标量将 <code>%xmm0</code> 的数据（x）加到 <code>%xmm1</code> 的值（v）上，完成了 <code>*p = x + v;</code></p><p>第四步就将计算结果 <code>%xmm1</code> 的值（t）标量移动到地址为 <code>%rdi</code> 的 memory 引用区域中（p 所指向的区域），完成 <code>*p = t;</code></p><h2 id="6-3-3-AVX-Instructions"><a href="#6-3-3-AVX-Instructions" class="headerlink" title="6.3.3 AVX Instructions"></a>6.3.3 AVX Instructions</h2><p>AVX 新增的指令可以说是非常地多，使用方法、命名规范和之前所有的命令不同的是，加了前缀 “v”（vector，矢量运算），其他都相近。</p><p>AVX 指令用于驱动更新的 浮点数寄存器，例如 <code>%ymm</code> 系列。</p><ul><li><p><code>mov</code> 类命令：<code>vmovss/vmovsd/vmovps/vmovpd/vmovass/...</code>;</p><blockquote><p>命名规范见前面的叙述；</p></blockquote></li><li><p><code>cvt</code> （convert）类命令，一般实现浮点和整型之间的转换：</p><ul><li><p><code>vcvttss2si/vcvttsd2si/vcvttss2si/vcvttss2siq/vcvttsd2siq</code>;</p></li><li><p><code>vcvtsi2ss/vcvtsi2sd/vcvtsi2ssq/vcvtsi2sdq</code>;</p><blockquote><p>有点长，但是命名规范清楚：</p><p><code>vcvt</code> 是 <code>cvt</code> 类命令的前缀；</p><p>中间有 <code>t</code> 表示 truncation，进行截断（<strong>出现在浮点向整型的转换中</strong>）；</p><p>后缀 <code>XX2YY</code> 是 从 <code>XX</code> 类型转换到 <code>YY</code> 类型的意思，<code>XX/YY</code> 可取的值有：<code>ss/sd/ssq/sdq/si(integer, 32-bit)/siq(integer, 64-bit)</code>;</p></blockquote></li></ul></li><li><p>arithmetic 类命令：<code>vaddss/vsubss/vmulss/vdivss/vmaxss/vminss/vxorps/xandps/sqrtss/...</code></p><blockquote><p>新的指令名：<code>sqrt</code>，之前 integer registers 的指令所没有的；</p></blockquote></li><li><p>比较类命令（和 SSE3 相同）：<code>ucomiss/ucomisd</code>;</p></li></ul><h2 id="6-4-Summary-for-Chapter-6"><a href="#6-4-Summary-for-Chapter-6" class="headerlink" title="6.4 Summary for Chapter 6"></a>6.4 Summary for Chapter 6</h2><p>本章的内容密度也相当之大，有必要总结回顾一下本章所学的全部内容。</p><p>本章的一开始我们复习了 C/C++ 中指针和数组的准确定义，从分析<strong>二者的使用方式</strong>和 <strong>2 种区别（常量性、空间分配的自主性）</strong>方面入手，从较深的角度考虑了 <strong>数组标识符的含义和多种声明方式</strong>，以及这些声明方式如何阅读、如何理解。这样我们就能准确地回答：不同标识符的 <code>sizeof</code> 判断问题、空指针/野指针的出现问题，也有助于我们理解在汇编中数组的呈现方式。</p><p>在了解数组在 C/C++ 中的地位后，我们先讨论了普通一维数组的<strong>内存分布</strong>和<strong>访问方式</strong>。</p><p>无论是存在于程序栈帧中的一维数组（<code>T[]</code> 声明法），还是存在于堆中的一维数组（<code>T*</code> 声明法），它们的排布都是位于<strong>连续的</strong>、 <strong><code>L * sizeof(T)</code> 大小的</strong>内存空间中，数组标识符可以看作指向开头位置的指针常量。因此，对于一维数组的汇编访问就是看作<strong>一串连续的同类型数据排布</strong>，按照 Simple Memory Address Mode 进行索引即可。</p><p>而后我们从恒定的（<code>constexpr</code>，编译前确定）数组规模出发，进一步学习二维数组的情况。</p><p>由于 C/C++ 的语言特性，二维数组的两种声明方式（Nested array <code>T[][]</code> 和 Multi-level array <code>T*[]</code>），<strong>尽管二者的使用方法几乎一致</strong>，但所对应的<strong>内存排布方式 和 汇编操作性质完全不同</strong>。</p><p>前者在声明时，所有元素的空间都会被自动分配至栈中，并且以 “Row major” 的方式<strong>连续排布</strong>；而后者则仅有一级元素（<code>T*</code>）被自动分配空间，并且指向的每一行数组之间的存储位置<strong>可以不连续</strong>。</p><p>内存结构上的差异就决定了这两种数组在汇编代码访问方式的不一致。访问 Nested Array 的某个元素时，只需要对<strong>数组标识符</strong>和<strong>索引</strong>进行算术计算（<code>&amp;A[i][j] == A + i * C * sizeof(T) + j * sizeof(T)</code>）就能得到相应地址；而访问 Multi-Level Array 时却必须先由<strong>数组标识符</strong>和<strong>行参数</strong>找到一级元素内容，然后用<strong>一级元素内容</strong>和<strong>列索引</strong>才能定位具体的元素位置。</p><p>讨论完固定规模二维数组的内存排布和访问方式后，我们将眼光拓展到可变规模的 Nested Array（即 M × N Matrix）上。按照所掌握的知识，我们也可以从普通固定规模的两种二维数组出发，类比出访问这种可变规模二维数组的汇编实现。</p><p>聚合结构除了数组，还有一个重要的部分——结构体，也是 C++ 中类的前身。</p><p>结构体在内存中的表示遵循简单的 3 条原则：<strong>连续排布</strong>、<strong>严格按声明顺序</strong>、<strong>编译器决定字段内存对齐</strong>。</p><p>在观察几个例子后，我们发现在有些情况下，结构体的每个程序紧密排布，访问方式与数组相近；但有些情况编译器会在成员间插入空白数据段（也计入数据结构的总大小）。于是我们分析了<strong>结构体内存对齐</strong>的两点<strong>现实原因</strong>和两点<strong>对齐的原则</strong>（“起始地址整除原则”、“最大倍数原则”）；我们根据这些原则能够正确认识结构体在内存中的组织情况，并以此对程序进行存储方面（<strong>如何声明结构体成员，以获得最小的占用空间</strong>）和性能方面的改进。</p><p>对于结构体所组成的数组，则可以看成完整的结构体所为一个基本元素所组成的数组，一级索引方式与普通数组相同，二级索引方式和单一结构体相同，在汇编层面<strong>共同构成结构体数组针对单个元素、单个成员的索引表达式</strong>。</p><p>虽然聚合结构对于汇编层面来说完全透明，但以上建立的规则和约定让底层的一个个指令共同实现了聚合结构的高级功能。</p><p>除了阐明聚合结构在汇编层面的实现之外，我们还整理了非常多的 <code>mov</code> 指令。从中我们归纳出了<strong>指令命名的规则</strong>，这个规则适用于其他几乎所有指令，可以帮助我们<strong>少记忆指令</strong>、<strong>在遇到没有见过的指令时能够推测出其大致作用</strong>。</p><p>最后，我们提及了浮点数指令的历史，及其在内存中的整体存储、汇编层面的使用。</p><p>在 SSE3 指令拓展集中，16 个 <code>XMM</code> Register 既可以存储标量数据，又可以存储成组的数据；既可以存放各种数据类型的整型数据，又可以存放各种数据类型的浮点型数据。在此基础上，我们接触到了两类运算方法（Scalar Op 和 SIMD Op）及其对应的指令，使用方法和整型的情况相近。</p><p>此外，关于 FP Register 的 Saving Conventions、比较指令和常数的使用，进一步加深了我们对浮点数的汇编操作的理解。</p><p>另外介绍的 AVX Instructions 有助于帮助我们理解某些浮点数操作的汇编代码的含义。</p><h1 id="Chapter-7-Machine-Level-Programming-Ⅴ-Advanced"><a href="#Chapter-7-Machine-Level-Programming-Ⅴ-Advanced" class="headerlink" title="Chapter 7. Machine Level Programming Ⅴ - Advanced"></a>Chapter 7. Machine Level Programming Ⅴ - Advanced</h1><h2 id="7-1-Memory-Layout-in-x86-64"><a href="#7-1-Memory-Layout-in-x86-64" class="headerlink" title="7.1 Memory Layout in x86-64"></a>7.1 Memory Layout in x86-64</h2><p>内存（虚拟内存）本质上就是一个很大的字节数组。而之前观察 memory 的角度要么是从汇编 Simple Memory Address Mode 的访问角度，要么是从 x86-64 的程序栈的角度来看内存的。本节将从<strong>更为宏观、更为完整</strong>的角度介绍 <strong>x86-64 Linux 的完整内存布局</strong>。</p><p>首先，从 64 位系统的特征上来说，x86-64 系统上的程序所能访问的内存空间应该是 $2^{64}$ bits（大约 $16\times10^{18}$ bits），但由于当前存储技术的种种限制，当前的硬件限制我们只能使用最高 47 位的地址（大约 $128\times10^{12}$ bits，128 TB）。</p><p>在这个限制下，我们看一看系统提供给程序的运行内存的结构：</p><p><img src="imgs/memory.png" height="400px"></p><ul><li><p>最底层的 128 MB 是栈区（<code>0x0000 7FFF FFFF 0000</code>，即 $2^{47}-4096$ 至 <code>0x0000 7FFF F800 0000</code>），实际 x86-64 栈的<strong>实际最大大小</strong>在 8 MB 左右，向低地址增长。栈的结构参考 5.2 和 5.3。</p><blockquote><ol><li>一般操作系统为了保护栈数据不被攻击，一般在栈的前后放置随机数据区域；如果没有这些保护数据，那么栈就放在内存最底层（<code>0x0000 7FFF FFFF 0000</code> 的位置）.</li><li>如果运行中的程序<strong>试图访问超过这里 8 MB 限制范围的地址</strong>，或者<strong>访问的地址还没有通过 virtual memory allocator 的分配</strong>时，系统会抛出 segmentation fault，并强制结束程序；</li></ol></blockquote></li><li><p>在从最下面看起，位置 <code>0x40 0000</code> 开始向高地址位置，有一段 text 区（找不到这个名字的来源），是程序存放运行机器代码的位置（信息从可执行文件读入）。<strong>我们将在 “链接” 一章详细讨论这个部分的具体内容</strong>。数据只读（Read Only）；</p></li><li><p>再下面一段是 Data 区，<strong>是用来存放程序开始时就分配的数据</strong>。存放的内容包括：</p><ul><li>静态分配的数据；</li><li>程序中的全局变量、静态值、字符串常量；</li><li>……</li></ul></li><li><p>再下面一段是堆。堆和栈的分配方式<strong>完全不同</strong>，堆空间在运行时按代码<strong>动态分配</strong>（dynamically allocated，一般由 malloc()、calloc()、new 等方法创建，free()、delete 等方法销毁），最有趣的是，堆的分配位置和生长方向不固定；下面将由例子来说明；</p></li><li><p>堆下面有一段空间的位置是外部库（Shared Libraries），存储的是类似 malloc()、printf() 的库函数。它们一开始是<strong>作为动态链接库存储于磁盘上</strong>，在程序加载时，它们也载入内存的这个位置，供程序使用，称为<strong>动态加载</strong>。<strong>我们将在 “动态链接” 这一部分详细讨论具体内容</strong>。</p></li></ul><p>我们运行下面的程序进行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> big_array[<span class="number">8388608L</span>];        <span class="comment">/* 1&lt;&lt;24, 16 MB */</span></span><br><span class="line"><span class="type">char</span> huge_array[<span class="number">1073741824L</span>];    <span class="comment">/* 1&lt;&lt;31, 2 GB */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">useless</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *phuge1, *psmall2, *phuge3, *psmall4;</span><br><span class="line">    <span class="type">int</span> local = <span class="number">0</span>;</span><br><span class="line">    phuge1 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">28</span>);    <span class="comment">/* 256 MB */</span></span><br><span class="line">    psmall2 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">8</span>);    <span class="comment">/* 256 B */</span></span><br><span class="line">    phuge3 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">32</span>);    <span class="comment">/* 4 GB */</span></span><br><span class="line">    psmall4 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">8</span>);    <span class="comment">/* 256 B */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 GDB 调试可以发现，在 Linux 内存中，<code>big_array</code>、<code>huge_array</code> 和 <code>global</code> 这三个全局变量分布在大致 <code>0x600000</code> 的低地址的位置，位于 <strong>Data 区</strong>；局部变量 <code>local</code> 在地址 <code>0x7FFE 0000 0000</code> 的大致位置，位于<strong>内存栈区</strong>；对于函数 <code>main()</code> 和 <code>useless()</code> 而言，它们的地址在 <code>0x400000</code> 附近，位于 <strong>Text 区</strong>；</p><p>而对于 <code>phuge1</code>、<code>psmall2</code>、<code>phuge3</code>、<code>psmall4</code> 来说略有特殊。它们是使用 <code>malloc</code> 分配在堆里的，但是它们的位置差别较大：<strong>占用空间很大的 <code>phuge1</code> 和 <code>phuge3</code> 位于更靠近栈区的堆中，而占用空间较小的 <code>psmall2</code> 和 <code>psmall4</code> 则位于更靠近 Data 区的堆中</strong>。大致情况如下图：</p><p><img src="imgs/memory_pos.png" height="350px"></p><p>奇怪的是，<code>malloc</code> 大数据量的堆在上方和 shared libraries 紧贴，向低地址增长；而普通数据的堆在 Data 区的下方向高地址增长。可以预见，当两块 heap 碰头的时候，<code>malloc</code> 会返回空指针。</p><p>这个规律目前还没有解释，等到以后的章节慢慢了解。</p><h2 id="7-2-Buffer-Overflow"><a href="#7-2-Buffer-Overflow" class="headerlink" title="7.2 Buffer Overflow"></a>7.2 Buffer Overflow</h2><p>在 Chapter 0-0.3 的越界实验中，我们就讨论过内存缓冲区溢出的问题。当时造成的后果是结构体中的其他成员的数据被修改。本节会详细解释内存缓冲区溢出的各个方面的影响和应当措施。</p><h2 id="7-2-1-The-Vulnerability"><a href="#7-2-1-The-Vulnerability" class="headerlink" title="7.2.1 The Vulnerability"></a>7.2.1 The Vulnerability</h2><p>继续以 0.3 中的实验代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125; <span class="type">struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">struct_t</span> s;    <span class="comment">/* volatile 关键字表示易变量，警告编译器不进行任何优化 */</span></span><br><span class="line">    s.d = <span class="number">3.14</span>;</span><br><span class="line">    s.a[i] = <span class="number">1073741824</span>;    <span class="comment">/* Possibly out of bounds */</span></span><br><span class="line">    <span class="keyword">return</span> s.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>i</code> 参数取值大于 1 时会污染 <code>s.d</code> 的值，当 <code>i</code> 参数大于 6 时，可能会出现 segmentation fault；</p><p>但内存缓冲区溢出的问题不仅仅是内部开发者编写错误这一个小问题。相反，这是一个<strong>大问题</strong>。</p><ul><li>Buffer overflow 的出现：when <strong>exceeding</strong> the memory <strong>size</strong> allocated for <strong>an array</strong>;</li><li>Buffer overflow 为什么是大问题：它是<strong>头号的技术层面上的安全漏洞</strong>（#1 technical cause of security vulnerabilities）；</li><li>Buffer overflow 产生的原因列举：<ul><li>Unchecked lengths on string inputs（外部因素：<strong>不对输入字符串的长度和内容进行合法性检查</strong>）；</li><li>Illegal indexing / referring / modifying memory（内部因素：<strong>不对访问 memory 的参数进行检查</strong>）；</li></ul></li></ul><p>下面举一个实际点的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get string from stdin */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = getchar();        <span class="comment">/* get a single char from stdin */</span></span><br><span class="line">    <span class="type">char</span> *p = dest;            <span class="comment">/* the pointer p points to the same addr as dest */</span></span><br><span class="line">    <span class="keyword">while</span> (c != EOF &amp;&amp; c != <span class="string">&#x27;\n&#x27;</span>) &#123;    <span class="comment">/* reading stdin until new line or EOF */</span></span><br><span class="line">        *p++ = c;            <span class="comment">/* add the value of p directly. (A problem ?) */</span></span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;                <span class="comment">/* the dest char must ends with &#x27;\0&#x27; */</span></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Echo Line */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>];            <span class="comment">/* Way too small */</span></span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">call_echo</span><span class="params">()</span> &#123; echo(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a string: &quot;</span>);</span><br><span class="line">    call_echo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>gets</code> 函数不管 <code>dest</code> 的实际被分配的大小，直接进行输入，很可能在内存中出现 Buffer Overflow。于是总结出导致 Buffer Overflow 的罪魁祸首之一：<strong>存储字符串，却不检查边界情况的库函数</strong>；C 库里有很多这样不检查边界的库函数：<code>scanf</code>、<code>fscanf</code>、<code>sscanf</code>（等 <code>scanf</code> 家族，尤其是使用 <code>%s</code> 格式化参量）、<code>strcpy</code>、<code>strcat</code>（等字符串移动家族）……</p><p>现在看看运行这个程序会出现什么问题（如果自己想试试的话，记得<strong>关闭 gcc 栈保护 <code>-fno-stack-protector</code></strong>）：</p><ul><li>如果输入短一点的字符串（长度小于 24 个），那么程序很可能会正常运行；</li><li>如果输入很长的字符串，那么程序会报告 segmentation fault；</li></ul><p>那么，都是缓冲区溢出，为什么短一点的看起来不会出问题呢？这时候就需要从汇编代码解释了。我们生成上面的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">    sub$0x18, %rsp</span><br><span class="line">    mov%rsp, %rdi</span><br><span class="line">    callq400680 &lt;gets&gt;</span><br><span class="line">    mov%rsp, %rdi</span><br><span class="line">    callq400520 &lt;puts@plt&gt;</span><br><span class="line">    add$0x18, %rsp</span><br><span class="line">    retq</span><br><span class="line">call_echo:</span><br><span class="line">    sub$0x8, %rsp</span><br><span class="line">    mov$0x0, %eax</span><br><span class="line">    callq4006cf &lt;echo&gt;</span><br><span class="line">    add$0x8, %rsp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure><p>首先观察，一开始系统为 <code>echo</code> 函数的栈帧分配了 24 bytes（<code>0x18</code>）的空间，<strong>因此，如果输入的输出加入超过了所有的栈空间，进入没有被分配的 memory 时，就会报告 segmentation fault</strong>。</p><p>所以，（<strong>当没有使用 <code>gcc</code> 栈保护机制时</strong>）安全问题通常就出现在 “溢出内容超过了原来分配的位置，但是没有超过栈的总体空间” 这种情况下。这时系统不会抛出 segmentation fault，<strong>栈中数据只能任由输入者篡改</strong>。</p><p>再来看看内存对应的情况：</p><p><img src="imgs/buffer_overflow_example1.png" height="260px"><img src="imgs/buffer_overflow_example1_2.png" height="260px"><img src="imgs/buffer_overflow_example1_3.png" height="260px"></p><p>如上左图，当 <code>char buf[4]</code> 声明后，在程序初始化时，编译器为<code>echo</code> 预留了 24 bytes 的空间；<code>echo</code> 栈帧的最顶层存放的是局部变量 <code>buf</code> 数组对应的空间大小是 4 bytes，一切都很正常。</p><p>如上中图，我们不妨假设 <code>call_echo</code> 在 return address 里存放的地址是 <code>0x4006C3</code>（<code>echo</code> 运行结束后应该返回的地址）；如果输入字符串内容超过了 <code>buf</code> 能承受的 3 bytes，则会出现 buffer overflow，如图，数据覆盖了 <code>buf</code> 下方的 20 bytes 其他区域的数据，但因为这个例子中，恰好那个区域没有存放其他数据，所以表面上程序没问题；</p><blockquote><p>如果那 20 bytes 空间放了其他数据，那么会被篡改；</p></blockquote><p>但，如果输入长度更长，那么字符串序列会溢出的更长，如上右图所示，污染了 Return address 的话，问题就出现了。当 echo 想要结束时，会因为 Return address 被修改而转移到一个不知道什么的地方，很可能导致 segmentation fault；<strong>更严重的，如果恰好跳转到一个奇怪的函数中，并且还能运行、没报错，那么坏了，程序不会按预期的方式继续运行，这样的 bug 非常隐晦</strong>；</p><h2 id="7-2-2-Stack-Smashing-Attacks"><a href="#7-2-2-Stack-Smashing-Attacks" class="headerlink" title="7.2.2 Stack Smashing Attacks"></a>7.2.2 Stack Smashing Attacks</h2><p>在上面说到的情况下，如果攻击者想要函数在输入后，跳转到不应该执行的、但是程序里面有的函数中，会让程序出现一些意料之外的行为。</p><blockquote><p>例如登录场景：攻击者想要输入一串内容，让软件跳转到登陆成功的函数中;</p></blockquote><p>这种攻击被称为<strong>缓冲区溢出攻击（stack smashing attack）</strong>，这种攻击就是利用了技术人员不注意输入检查，而导致的缓冲区溢出的问题。</p><p>实现这种攻击的原理比较简单，就是<strong>输入无意义的填充字符（padding）让输入的内容 buffer overflow，并且在末尾设置一个想要跳转到的函数的地址，并且只需让末尾的地址恰好覆盖 return address</strong> 就行。</p><p>如下图所示，正常的流程是 <code>P()</code> 调用 <code>Q()</code>，<code>P</code> 函数在 return address 中写的是 <code>A</code>，也就是 <code>P</code> 函数中调用 <code>Q</code> 的下一行；但由于 <code>Q()</code> 中的 <code>gets(buf)</code> 有溢出风险，在攻击者输入 <code>padding</code> 字符 + <code>S</code> 地址组合的字符串后，<code>gets</code> 函数将缓冲区数据覆盖了，如下图右，return address 被改成了 <code>S</code> 的地址。这样在 <code>Q()</code> 执行结束后，会跳转到 <code>S()</code> 函数中，而不是原来的 <code>P()</code> 中：</p><p><img src="imgs/stack_smashing_attack.png" height="300px"></p><p>做法很简单，但是编译时要关闭 <code>gcc</code> 的栈保护机制（<code>-fno-stack-protector</code>）。现在大多数 C/C++ 编译器都有这项功能，利用栈随机化、“金丝雀” 检查等技术，打乱栈空间的实际排布、利用栈两端的 “金丝雀” 侦测栈溢出，发现就立即终止程序，让攻击难以进行。<strong>（后面会详细讨论）</strong></p><ol><li>找到有导致缓冲区溢出风险的函数（像之前提到的 <code>scanf</code> 家族、<code>str</code> 家族），并且技术人员没有为这些函数的输入进行检查；</li><li>反汇编找到想要跳转的函数（也就是上面的 <code>S</code>）的地址；</li><li>反汇编找到汇编代码中编译器为 <code>Q</code> 函数分配的栈帧大小，计算出 <code>pad</code> 填充字符的大小，使得 <code>S</code> 地址恰好覆盖 return address；</li><li>将 padding 数据 + <code>S</code> 的地址（<strong>注意大小端序的问题</strong>）转换为字符串，运行程序并输入即可。</li></ol><h2 id="7-2-3-Code-Injection-Attacks"><a href="#7-2-3-Code-Injection-Attacks" class="headerlink" title="7.2.3 Code Injection Attacks"></a>7.2.3 Code Injection Attacks</h2><p>也是在上面说到的情况下，如果有攻击者刻意如此设置，让缓冲区溢出到 return address，并且恰好让 return address 指向攻击者事先设计好的 exploit code 中，那么程序就会执行攻击者设计的函数，从而给计算机造成威胁。</p><p>这种攻击被称为 <strong>代码注入攻击</strong>，思路和上面的 stack smashing attack 如出一辙，只不过攻击者不满足于执行软件内的其他函数了，他要执行的是自己嵌入的函数，危害可能更大。</p><p>实现攻击的原理就是，<strong>攻击者输入编码有 exploit code + padding string + pointer to exploit code 的内容</strong>，让读入程序执行结束后跳转到攻击者刚刚输入的 exploit code 中执行，如下图所示：</p><p><img src="imgs/code_injection_attack.png" height="300"></p><blockquote><p>更聪明的攻击者会在运行完 exploit code 后修复溢出的缓冲区，并且跳转到原来的函数，伪装成没有被攻击的假象。</p><p>知识拓展：计算机病毒和计算机蠕虫的区别</p><ul><li>蠕虫：可以通过某种隐蔽的方式，进行自我复制、独立地在机器上运行预期代码；</li><li>病毒：可以通过某种隐蔽的方式，进行自我复制，攻击一个程序，并改变这个程序的行为，但自己不能独立存在。</li></ul></blockquote><h2 id="7-2-4-The-Protection-in-personal-respective"><a href="#7-2-4-The-Protection-in-personal-respective" class="headerlink" title="7.2.4 The Protection: in personal respective"></a>7.2.4 The Protection: in personal respective</h2><p><strong>Avoid overflow vulnerabilities when writing a program</strong></p><blockquote><p>例如之前的 <code>gets</code> 函数有风险，可以换成 <code>fget</code> 指定读入缓冲区的大小；</p><p><code>strcpy</code> 换成 <code>strncpy</code>、<code>scanf</code> 使用时不轻易用 <code>%s</code> 格式，而使用 <code>%ns</code>，或者直接用 <code>fgets</code>;</p></blockquote><p><strong>Avoid overflow vulnerabilities in system-level</strong></p><ul><li><p>栈随机化（stack randomization），是更宏观策略 ASLR (Address Space Layout Randomization, 地址空间布局随机化) 的一部分，<code>gcc</code> 编译器选项：<code>-fPIE</code>；</p><blockquote><p>这样的话，每次运行程序，栈和堆上变量的位置偏移 offset 会随机产生，攻击者就没法找到准确的攻击代码的插入位置了；<code>gcc</code> 编译器禁用：<code>-fno-PIE</code>;</p></blockquote></li><li><p>Non-executable code segments：在栈中规定禁止执行代码，只有在 Text 区 / Shared Libraries 区才能执行；</p><blockquote><p>以前人们在内存中每一个 chunk 前放置 3 个 flags，类似 Unix 上的 可读、可写、可执行三个权限，对于栈区的空间中 flags 应该是可读、可写、不可执行；<code>gcc</code> 编译器取消禁令：<code>-z execstack</code>;</p></blockquote></li><li><p>Stack Canaries（栈 “金丝雀”），在栈中的 buffer 两端设置特殊的随机值（称为 “金丝雀”，早期人们下矿就用金丝雀的生死来判断矿井中瓦斯是否超标），在写入 buffer 的函数退出前检查这些值。如果这些值被改变了，那么说明 buffer overflow，可能会出问题，就立即终止接下来程序的执行；<strong>现在这个技术已经在 <code>gcc</code> 中成为默认的编译选项：<code>-fstack-protector</code></strong>;</p></li></ul><blockquote><p>这里简单从汇编层面分析一下 “金丝雀” 是如何实现的。</p><p>还是以上面的 <code>echo</code> 函数为例，这时我们编译就删除 <code>-fno-stack-protector</code> 这个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">    sub$0x18, %rsp</span><br><span class="line">    mov%fs:0x28, %rax</span><br><span class="line">    mov%rax, 0x8(%rsp)</span><br><span class="line">    xor%eax, %eax</span><br><span class="line">    mov%rsp, %rdi</span><br><span class="line">    callq4006e0 &lt;gets&gt;</span><br><span class="line">    mov%rsp, rdi</span><br><span class="line">    callq400570 &lt;puts@plt&gt;</span><br><span class="line">    mov0x8(%rsp), %rax</span><br><span class="line">    xor%fs:0x28, %rax</span><br><span class="line">    je400768 &lt;echo+0x39&gt;</span><br><span class="line">    callq400580 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">    add$0x18, %rsp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure><p>我们一步步分析：</p><p>第一步给 <code>echo</code> 栈帧分配了 24 bytes 的空间，非常简单；</p><p>第二步用到了一个没见过的东西 <code>%fs:0x28</code>，实际上 <code>%fs</code> 是一个<strong>为原始 8086 芯片设计的一个寄存器</strong>，由于向下兼容，所以它现在还能<strong>以某种方式</strong>使用，但是基本很少用，甚至已经找不到它的文档了……只需要知道 <code>%fs:0x28</code> 是内存的某个隐匿部位，相当于随机数 “金丝雀”，我们将这个数放到 <code>%rax</code>，第三步再将这个值放到 <code>%rsp</code> 所指向的下面 8 bytes 的位置——这就意味着 <code>buf</code> 只要溢出 8 bytes 就会被察觉；</p><blockquote><p>⚠ <code>%fs</code> <strong>不是</strong>真正可用的寄存器，它是 segment register（段寄存器）in protected mode，其中的值是指向某个有效位置的指针。所以只能用如此方式（<code>%fs:0x28</code>）取出值，它（<code>%fs:0x28</code>）实际上是内存中某个位置的引用，<strong>并且每次运行，这个值都会改变</strong>。</p><p>这也回答了为什么不能直接将 <code>%fs:0x28</code> 的值 <code>mov</code> 到内存中。</p><p>——以上摘自 <a href="https://stackoverflow.com/questions/10325713/why-does-this-memory-address-fs0x28-fs0x28-have-a-random-value">StackOverflow</a>;</p></blockquote><p>第四步将 <code>%rax</code> 清空为 0，然后执行普通的 <code>echo</code> 操作，省略；</p><p>直到倒数第 5 步（第 10 行），系统将 “金丝雀” 取出到 <code>%rax</code> 并和原值 <code>%fs:0x28</code> 比较，如果不等就是缓冲区溢出，立即调用 <code>__stack_chk_fail</code> 报错终止执行；</p></blockquote><h2 id="7-2-5-【New】Return-Oriented-Programming-Attacks"><a href="#7-2-5-【New】Return-Oriented-Programming-Attacks" class="headerlink" title="7.2.5 【New】Return-Oriented Programming Attacks"></a>7.2.5 【New】Return-Oriented Programming Attacks</h2><p>在上面的许多防护措施出来后，给攻击者带来很多难题：</p><ul><li>栈随机化使得他们很难预测缓冲区的位置；</li><li>栈区无法执行代码，使得他们插入代码也没用；</li></ul><p>于是攻击者有了一些替代性的措施，<strong>能够突破上面的两个障碍（栈随机化 + 禁止栈中执行代码）</strong>：</p><ul><li>利用已存在的代码，例如标准库中的代码。因为它们不在栈区和堆区，位置不会轻易变动；</li><li>利用 x86 架构中 <code>ret</code> 指令的特殊行为，来执行代码；</li></ul><p>下面介绍这种攻击的原理。</p><p>这种攻击利用的部件称之为 <strong>gadget</strong>，通常是各个函数的<strong>包含 <code>ret</code> 指令的最后几行或者一段</strong>，如下：</p><p><img src="imgs/gadget_1.png" height="225px"><img src="imgs/gadget_2.png" height="225px"></p><p>这些毫无关系的函数的汇编代码最后几行甚至几个片段总会包含一些指令，例如将某个寄存器的值加多少、将某个寄存器的值移动到哪。它们紧接着 <code>ret</code> 指令（对应汇编码 <code>0xC3</code>）。这就意味这我们可以<strong>收集这些 gadget 的地址，按照我们的需求依此排列这些 gadget，通过输入将这些地址溢出到栈里，让栈充当程序计数器的角色，反复执行 <code>gadget1</code> -&gt; <code>ret</code> -&gt; 执行 <code>gadget2</code> -&gt; <code>ret</code> -&gt; …，越过了上面两个限制，将所有 gadget 连在一起，最终让程序段达到我们的目的</strong>，如下图：</p><p><img src="imgs/ROP_execution.png" height="300px"></p><p><strong>可以说是顶级的 “断章取义”！</strong></p><p>不过有两个缺点：</p><ul><li>这种攻击仍然不能突破 “金丝雀” 的防护，因为这毕竟是栈溢出；</li><li>各个 gadget 需要大量地查找，比较费精力。有些人会在标准库中积累一些 gadget；</li></ul><h2 id="7-3-Union-in-Memory"><a href="#7-3-Union-in-Memory" class="headerlink" title="7.3 Union in Memory"></a>7.3 Union in Memory</h2><p>C 中有一个特殊的数据结构：<code>Union</code>，声明方式与 <code>struct</code> 几乎一样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125; *up;</span><br></pre></td></tr></table></figure><p>但用法完全不一样。<strong><code>Union</code> 的所有域共用一块最大的域大小的内存</strong>，这就导致在改动一个域的数据时，其他域的值也会改变；所以 <strong><code>Union</code> 一次只能使用一个域，或者用在通过别名引用不同的内存的场合</strong>。<code>Union</code> 用的地方少，但在单片机、掩码的领域用的比较多。</p><p>对于<strong>联合体的内存对齐</strong>，和之前说的结构体类似，遵循以下几点限制：</p><ul><li>自身的对齐整除数 K（定义见 6.2.2）是所有域的对齐整除数的<strong>最小公倍数</strong>；</li><li>自身的长度（padding 后）既能单独放下每个域，又满足长度 K 对齐；</li></ul><p>看个经典的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">dm</span> &#123;</span></span><br><span class="line">        <span class="type">long</span> i;</span><br><span class="line">        <span class="type">char</span> j[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">    &#125; n;</span><br><span class="line">    <span class="type">double</span> p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>dm</code> 作为结构体 <code>data</code> 的成员，其对齐整除数等于其中域的对齐整除数的最小公倍数，也就是 <code>long i</code> 的 8 bytes，所以 $K(dm)=8$，确定了起始地址的条件，还要确定 <code>dm</code> 的长度。其长度首先能单独方向所有域，所以 $sizeof(dm)\ge10$，但是 K 是 8，所以为了满足第二条件，长度应该取<strong>大于 10 的 K 的倍数</strong>，也就是 16；</p><p>因此 <code>data</code> 的内存排布如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|  m  | dm indent (+4) |  dm  | dm padding (+6) |  p  |</span><br><span class="line">0     4                8      18                24    32  (bytes)</span><br></pre></td></tr></table></figure><p>因此 <code>sizeof(dm) = 16</code>，<code>sizeof(data) = 32</code>；</p><p>还有就是之前的 Data Lab 中用于 <strong>bit-level representation 的 float 和真实的 float 之间相互转换</strong>，不会改变 bit pattern，也能用到 <code>Union</code>（当然不是解题答案，因为不允许）；</p><p><strong>使用 <code>Union</code> 也要特别注意端序的问题</strong>！！！</p><h2 id="7-3-1-Union-Allocation"><a href="#7-3-1-Union-Allocation" class="headerlink" title="7.3.1 Union Allocation"></a>7.3.1 Union Allocation</h2><p>对联合体（<code>Union</code>）而言，内存分配比较简单，只需要判断所有域中占用空间最大的那一个来分配就行。例如上面的例子就是 8 bytes；</p><h2 id="7-3-2-Summary-of-Compound-Types-in-C"><a href="#7-3-2-Summary-of-Compound-Types-in-C" class="headerlink" title="7.3.2 Summary of Compound Types in C"></a>7.3.2 Summary of Compound Types in C</h2><ul><li>Arrays<ul><li>Contiguous allocation of memory（1-D &amp; Nested Array）；</li><li>Aligned to satisfy every element’s alignment requirement；</li><li>Pointer to first element；</li><li>No bounds checking；</li></ul></li><li>Structures<ul><li>Allocate bytes in order declared；</li><li>Pad in middle and at end to satisfy alignment；</li></ul></li><li>Unions<ul><li>Overlay declarations；</li><li>Way to circumvent type system；</li></ul></li></ul><h2 id="7-4-Summary-of-Chapter-7"><a href="#7-4-Summary-of-Chapter-7" class="headerlink" title="7.4 Summary of Chapter 7"></a>7.4 Summary of Chapter 7</h2><p>本章的内容相较于之前两章较少，但是也很重要。</p><p>本章开始我们就从<strong>更全面的</strong>角度来观察 <strong>x86-64 Linux 的完整内存布局</strong>，我们落脚于实际，考虑到实际能够使用的内存不过 128 T 左右，建立了一个 <code>0x0000 7FFF FFFF F000 ~ 0x40 0000</code> 的内存图谱。</p><p>在这个图谱中，自高地址至低地址分布栈区（stack）、外部库区（shared libraries）、堆区（heap）、数据区（data）、机读代码区（text）；</p><p>这些位置都由 virtual memory allocator 进行管理，如果访问了超出整个内存的范围，或是不在已分配的空间内，系统都会抛出 segmentation fault；</p><p>我们了解到，栈区<strong>位于内存的最高地址处</strong>，内部存放见 5.2 和 5.3，实际大小约 8 MB（x86-64），地址在 $2^{47}-4096$ 至 <code>0x0000 7FFF F800 0000</code> 中，前后可能含有因为 ASLR 或 “金丝雀” 产生的<strong>随机数据</strong>，总共约 128 MB；</p><p>在栈区的上方（这里把较低地址的称为 “上方”）是 Shared Libaries 区，<strong>它存放重要的外部库函数</strong>，是动态加载至内存上的部分。如果堆中有较大的数据，可能部分的堆区会与外部库区毗邻，并且向低地址生长。</p><p>跨过中间大片的未分配的区域向低地址看，就是堆区，<strong>由代码函数手段分配和释放的区域，存放大部分由手动分配的普通变量</strong>，向高地址生长；</p><p>在堆区的上方，是数据区，<strong>存放程序开始就分配的数据</strong>，包括静态数据、全局变量、字符串常量等；</p><p>再向上就是内存的地址最低处，机读代码区，开始于 <code>0x40 0000</code>，具体内容会在 “链接” 一章中讨论。</p><p>以上区域，text / data / shared libraries 区域运行时可读可执行，heap / stack 区域可读可写不可执行。</p><p>介绍完 x86-64 Linux 整体的内存分布，我们进一步讨论了 Buffer overflow 的原理和危害性。</p><p>Buffer overflow 出现的<strong>内部原因</strong>是对数组或其他 memory 不恰当的读写访问，<strong>外部原因</strong>是不对输入字符串进行长度和内容的合法性检验。</p><p>最后 Buffer Overflow 或者触发 segmentation fault 导致程序崩溃，或者恰好进行了不恰当的跳转，让程序行为不可预测、难以调试，或者被不法分子利用后，危害计算机系统的正常使用。</p><p>从一个使用容易内存缓冲区溢出的 <code>gets</code> 的函数 <code>echo</code> 出发，我们讨论了输入不同长度的字符串对缓冲区溢出的影响，进而推出了 <strong>3 种</strong>利用缓冲区溢出特点的攻击行为（Stack Smashing Attacks、Code Injection Attacks、Return-Oriented Programming Attacks）。它们共同点是，都利用了溢出影响 return address 的特性，使得程序跳转到攻击者指定的位置执行；但从具体操作上各有差异。</p><p>之后我们介绍了<strong>两类、四种</strong>针对内存缓冲区溢出攻击的防护办法。两类中的一类是<strong>从开发者自己做起</strong>，尽量避免使用有缓冲区溢出风险的函数；另一类是<strong>从系统层面做起</strong>，主要分为 3 种，分别是<strong>栈随机化</strong>、<strong>栈区禁止执行代码</strong> 和 <strong>栈 “金丝雀”</strong>。这 3 种防护思路能够轻松应对 Stack Smashing Attacks 和 Code Injection Attacks，但只有 栈 “金丝雀” 能够防护 Return-Oriented Attacks。</p><p>我们仔细分析了 栈 “金丝雀” 的汇编层面的实现，更加确信这个至今没有被破解的防护方法的强大。</p><p>本章最后，我们接触到了 <code>Union</code> 联合体在内存中的分配和表示，反复强调使用 <code>Union</code> 时<strong>一定要注意端序的问题</strong>，以免出现字节序方面的编程错误。</p><blockquote><p>第 3 ~ 7 章已结束，请完成 Bomb Lab &amp; Attack Lab！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> CSAPP </tag>
            
            <tag> ICS </tag>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MC-Forge开发笔记（一）</title>
      <link href="//technical/mc-forge-1/"/>
      <url>//technical/mc-forge-1/</url>
      
        <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: </i><a href="https://docs.minecraftforge.net/en/1.16.x/">Minecraft Forge Doc 1.16.x</a>、<a href="https://boson.v2mcdev.com/introducation/intro.html">Boson 1.16（导论部分）</a></p><p><i>注意：以 MC 版本 1.16.5 为例</i>（同一大版本 1.16.x 的操作方式变化不大）</p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><hr><span id="more"></span><h2 id="Chapter-0-Forge-导论"><a href="#Chapter-0-Forge-导论" class="headerlink" title="Chapter 0. Forge 导论"></a>Chapter 0. Forge 导论</h2><h3 id="0-1-Forge-历史与定义"><a href="#0-1-Forge-历史与定义" class="headerlink" title="0.1 Forge 历史与定义"></a>0.1 Forge 历史与定义</h3><ul><li><p><code>Minecraft</code> 其中发行版的一个大类是由 <code>Java</code>写的<strong>商业</strong>软件，这意味着：</p><ul><li><code>Minecraft</code> 容易反编译和修改：由于 <code>Java</code> 半解释型语言的特性（但凡换成 C++ 就很可能不会有今天 Mod 丰富的生态了，毕竟 Mojang 当年一直不给官方 API）；</li><li>代码本身是闭源的、被混淆的：这毕竟是一款商业软件。</li></ul></li><li><p>为了给 <code>Minecraft</code> 增添更多的游戏特性，大家千方百计地寻找添加代码的办法。最终 <code>MCP</code>（Mod Coder Pack）项目诞生了，它<strong>规避了没有官方 API 的问题，通过反编译、反混淆直接修改 <code>Minecraft jar</code> 包中的内容</strong>。其发展过程中，人们研究各类的名称的产生如下：</p><ul><li><p><code>notch</code> 名：<code>Minecraft</code> 各种类直接反编译、反混淆之后的名称，通常是无意义的字母数字组合。</p><blockquote><p>例如 <code>j</code> 就是一个典型的 <code>notch</code> 名；</p></blockquote></li><li><p><code>srg</code> 名：与 <code>notch</code> 名一一对应。极大的好处是<strong>在一个版本里是不会变动的</strong>，这意味着类名渐渐可读起来，有相应的前缀后缀来区分。之所以叫做<code>srg名</code>，是为了纪念MCP项目开发的领导者Searge；</p><blockquote><p>例如 <code>notch</code> 名 <code>j</code> 对应 <code>srg</code> 名的 <code>func_70114_g</code>。</p></blockquote></li><li><p><code>mcp</code> 名：这是当年 <code>MCP</code> 项目的 mod 开发者使用的最多的名称。在<code>mcp</code> 名中，<strong>代码已经是可读的了</strong>。和我们正常写java程序中的名称没什么两样，但是也会变动。</p><blockquote><p>例如，<code>notch</code> 名为 <code>j</code> 的函数，其 <code>srg</code> 名为 <code>func_70114_g</code>，其 <code>mcp</code> 名是 <code>getCollisionBox</code>；</p></blockquote></li></ul></li><li><p>随着时间推移和生态的扩展，大家发现这么做很不行，因为直接修改 Jar 文件写 mod 的方式太过于粗暴了，而且 Mod 和 Mod 之间的兼容性可以说基本没有。于是，<code>Forge</code> 项目就诞生了。</p></li><li><p><code>Forge</code> 是通过修改 <code>Minecraft</code> 方式实现的<strong>第三方的 API</strong>，给广大 mod 开发者提供了标准化的接口的指引。而Forge本身也在 <code>Minecraft</code> 1.13 版本到来之后经历了一次重写，引入了大量函数式编程的API。</p><blockquote><p>随着时间的发展，<code>MCP</code> 项目现在已经死亡了，除了 <code>Forge</code> 这套API，<code>Fabric</code> 也风头正盛。</p></blockquote></li><li><p><code>Forge</code> 的工作原理也采用了 <code>MCP</code>  的思路。在为指定版本的 <code>Minecraft</code> 安装完 <code>Forge</code> 之后，游戏的运行过程中，所有的内容都会反编译成 <code>srg</code> 运行，你编译好的 mod 同样也会被混淆成 <code>srg</code>，保证它可以正常运行。</p><blockquote><p>用 <code>srg</code> 名就是因为它每个版本不变。</p></blockquote></li></ul><h3 id="0-2-Minecraft-的架构"><a href="#0-2-Minecraft-的架构" class="headerlink" title="0.2 Minecraft 的架构"></a>0.2 Minecraft 的架构</h3><p>除了了解 <code>Forge</code> 的历史和定义，<code>Minecraft</code> 的架构和运作方式在 Mod 开发中也绝对是必要的。</p><ul><li><p><code>Minecraft</code> 是一种 C/S 架构，整体逻辑如下：</p><ul><li>服务端：负责游戏的逻辑，数据的读写。</li><li>客户端：接受用户的输入输出，根据来自服务端的数据来渲染游戏画面。</li></ul><p><img src="struct.png" height="400px"></p></li><li><p>Tips 1. 这里客户端和服务端的区分<strong>仅是逻辑上的区分</strong>。</p><ul><li>实际上如果你处于单人模式，那么你的电脑上会<strong>同时存在</strong>服务端和客户端，而且他们处于不同的线程（<code>Server thread</code> &amp; <code>Render thread</code>）；</li><li>但是当你连接某个服务器时，你的电脑上只存在客户端，服务端被转移到了远程的一台服务器上。</li></ul></li><li><p>Tips 2. 客户端、服务端<strong>各存在一份数据模型</strong>。不过「客户端数据模型」只是「服务端数据模型」一个副本，虽然它们都有独立的游戏 <code>Tick</code>，也共享很多相同的代码，但是最终逻辑还是以服务端为准。</p></li><li><p>Tips3. 客户端和服务端是存在于不同线程的，所以它们不可避免地需要同步数据。而数据同步都是通过<strong>网络数据包</strong>实现的。</p><blockquote><p>在大部分时候原版已经实现好了数据同步的方法，我们只需要调用已经实现好的方法就行。</p><p>但是在某些情况下，原版没有实现对应的功能，或者不适合使用原版提供的功能，我们就得自己创建和发送网络数据包来完成数据的同步。【可能需要计算机网络基础、<code>Java</code> 网络编程基础】</p></blockquote></li><li><p>在代码中，<strong>区分服务器端和客户端</strong>的方式：<code>World</code> 中有一个 <code>isRemote</code> 字段，开发时判断它就行。</p></li></ul><h3 id="0-3-Minecraft-的运行模式"><a href="#0-3-Minecraft-的运行模式" class="headerlink" title="0.3 Minecraft 的运行模式"></a>0.3 Minecraft 的运行模式</h3><ul><li><strong>离散事件驱动模式</strong>，详见数据结构书籍。这个模式包含了 3 个概念：<ul><li>事件：“当方块被破坏” 这个就是一个事件，“当玩家死亡” 这个也是一个事件，甚至 “当渲染模型时” 这个也是一个事件；</li><li>事件处理器：用来处理 “事件” 的函数。例如可以注册一个事件处理器来处理 “玩家死亡事件”，里面的内容是 “放置一个墓碑”；</li><li>总线：总线是连接 “事件” 和 “事件处理器” 的工具，当 “事件” 发生的时候，“事件” 的信息将会被发送到总线上，然后总线会选择监听了这个 “事件” 的 “事件处理器”，执行这个事件处理器。</li></ul></li><li>在Minecraft中，所写的逻辑基本上都是事件处理。</li><li>在Forge开发里有两条总线，<code>Mod</code> 总线和 <code>Forge</code> 总线，所有和初始化相关的事件都是在 <code>Mod</code> 总线内，其他所有事件都在 <code>Forge</code> 总线内。</li></ul><h3 id="0-4-重要概念准备"><a href="#0-4-重要概念准备" class="headerlink" title="0.4 重要概念准备"></a>0.4 重要概念准备</h3><ul><li><p>注册：如果想往 <code>Minecraft</code> 里添加一些内容，那么你必须做的一件事就是注册。注册是一种机制，告诉游戏本身，有哪东西可以使用。你注册时需要的东西基本上可以分成两个部分：<strong>一个注册名</strong>和<strong>一个实例</strong>；</p></li><li><p>资源地址（<code>ResourceLocation</code>）：<code>Minecraft</code> 管理、定位资源（音频 / 图片）的方式是<strong>采用特殊格式的字符串</strong>。格式为：<code>&lt;domain&gt;:&lt;UNIX-Style relative path&gt;</code>。</p><ul><li>域可以是 <code>minecraft</code>（原版资源），也可以是 mod 的名称。相对路径是相对于 mod 根目录下的 <code>assets</code> 目录而言（如果是原版资源，即域名为 <code>minecraft</code>，那么相对于 <code>.minecraft/assets</code>）;</li><li>例如：<code>minecraft:textures/block/stone.png</code>，<code>mod1:textures/Alex.png</code>；</li></ul></li><li><p>模型和材质：在游戏中 <code>3D</code> 的对象基本上都有它的模型，模型和材质组合在一起规定了一个对象具体的样子。模型相当于是骨头，材质相当于是皮肤。在大部分时候，你的材质都是 png 图片【可能需要平面设计 和 PS 的相关功底】。</p><blockquote><p>注意保证<strong>材质背景是不透明的</strong>，也不要在材质中使用<strong>半透明像素</strong>，会有不可预知的问题。</p></blockquote></li></ul><h3 id="0-5-开发环境"><a href="#0-5-开发环境" class="headerlink" title="0.5 开发环境"></a>0.5 开发环境</h3><blockquote><p><code>Minecraft Forge</code> 是由 <code>Gradle</code> 管理的项目，而 <code>Forge</code> 官方写了一个叫做 <code>ForgeGradle</code>（以后简称FG）的插件来负责整个 mod 开发环境的配置，本节主要介绍这个环境的配置和使用；</p></blockquote><ul><li><p>前提</p><ol><li><code>JDK 8</code>（1.16.x 兼容版本）和 <code>64 bit JVM</code>；请确保您的操作系统已经安装并配置好环境变量 <code>JAVA_HOME</code>、<code>CLASS_PATH</code>；</li><li>官网获得 <code>MDK(Mod Development Kit)</code>：我们这里 1.16.5 选择官网推荐的 <code>forge-36.2.34</code> <a href="https://files.minecraftforge.net/net/minecraftforge/forge/index_1.16.5.html">Downloads for Minecraft Forge for Minecraft 1.16.5</a>；</li><li>Java 开发 IDE，可以选 VSCode / Eclipse / IDEA，本文<strong>以 IDEA 为例</strong>进行。</li></ol></li><li><p>开发准备工作</p><ol><li><p>这里我们将下载的 MDK 解压到一个空目录下；</p><blockquote><p>FG 项目结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">├─ .gitattributes        # Git 用来记录某些文件属性</span><br><span class="line">├─ .gitignore            # Git 用来忽略版本控制的记录文件</span><br><span class="line">├─ build.gradle            # Gradle 构建脚本</span><br><span class="line">├─ changelog.txt        # Forge 项目版本迭代情况</span><br><span class="line">├─ CREDITS.txt            # Forge 项目致谢和 credits</span><br><span class="line">├─ gradle.properties    # Gradle 属性文件，用来定义其他变量和设置</span><br><span class="line">├─ gradlew                # Unix 类系统执行 Gradle wrapper 的 shell</span><br><span class="line">├─ gradlew.bat            # Windows 系统 ~</span><br><span class="line">├─ LICENSE.txt            # Forge 项目证书</span><br><span class="line">├─ README.txt            # 基本安装指导说明书</span><br><span class="line">│</span><br><span class="line">├─ gradle/</span><br><span class="line">│   └─wrapper/            # 这里包含了 Gradle Wrapper，这里使用的是 7.4.2</span><br><span class="line">│        ├─ gradle-wrapper.jar</span><br><span class="line">│        └─ gradle-wrapper.properties</span><br><span class="line">│</span><br><span class="line">├─ run/                # 在构建项目后会出现，相当于 .minecraft</span><br><span class="line">|</span><br><span class="line">└─src/                    # 源文件目录</span><br><span class="line">└─main/                # main 分组的源文件目录</span><br><span class="line">  ├─java/            # main 分组的 java 源文件</span><br><span class="line">  │              # 这里是 java 的 package，将来在这里写 mod</span><br><span class="line">  │</span><br><span class="line">  └─resources/        # main 分组的资源目录</span><br><span class="line">      ├─ pack.mcmeta    # 被 minecraft 用来识别数据和资源包的文件</span><br><span class="line">      │</span><br><span class="line">      └─META-INF/    # Forge 资源 metadata 信息文件存放目录</span><br><span class="line">           └─ mods.toml    # mod 声明的文件</span><br></pre></td></tr></table></figure><p><strong>其中最为重要的几个分别为</strong>：</p><ul><li><code>build.gradle</code>、<code>gradlew.bat</code>、<code>gradlew</code>、<code>gradle/</code> 目录；</li></ul><p>只要有了上面几个的数据，就能创建一个新 <code>mod</code> 项目；</p></blockquote></li><li><p>把上面说的重要的几个文件复制到新目录，以后这里是 mod 项目的根目录了（这么做是为了减少文件干扰，毕竟我们不需要版本控制，对吧）；</p></li><li><p>用 IDEA 打开这个新目录，即可自动下载依赖配件、设置项目；如果中途出现错误，99% 是因为网络错误。请翻*GFW，或者上网找国内源解决；</p></li><li><p>打开后，在 IDEA Terminal 下执行 <code>gradlew genIntellijRuns</code>（如果是 eclipse/vscode，那么后面一个词分别是 <code>genEclipseRuns</code> 和 <code>genVSCodeRuns</code>），它会进一步下载游戏需要的资源，并且设置 <code>Run Configure</code>；</p></li></ol></li><li><p>mod 的 gradle 脚本个性化：刚入门，介绍简单的个性化方式，主要是编辑 <code>build.gradle</code> 的内容。</p><ul><li><p><strong>注意，在不知道含义的情况下，不能编辑其中的 <code>buildscript &#123;&#125;</code> 块。这些代码对于 <code>ForgeGradle</code> 来说是必须的</strong>；</p></li><li><p><strong>更改构建的结果文件名</strong>：编辑 <code>archivesBaseName</code> 的值；</p></li><li><p><strong>更改 <code>maven</code> 构建系统的根目录</strong>：编辑 <code>group</code> 的值；</p></li><li><p><strong>更改 mod 版本信息</strong>：编辑 <code>version</code> 的值；</p></li><li><p><strong>将其中所有 “examplemod” 都替换为自己 mod id（自己定，唯一，只能有小写字母，不能有大写/空格/其他字符，切记！！！）</strong>；</p></li><li><p><strong>设置项目名称映射（mappings）</strong>：在 <code>minecraft&#123;&#125;</code> 块中，第一个就是 <code>mappings</code>，默认官方的 mappings。但是，官方的<strong>没有参数和 <code>javadocs</code> 提示</strong>。如果之后用的不习惯，可以换成以前 <code>MCP</code> 的 mappings（现在已经停止维护）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minecraft &#123;</span><br><span class="line">    <span class="comment">// 这是最后一次 mappings 的更新</span></span><br><span class="line">    mappings channel: <span class="string">&#x27;snapshot&#x27;</span>, version: <span class="string">&#x27;20210309-1.16.5&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>注意：修改完 <code>build.gradle</code> 脚本后需要重新进行前面的步骤进行设置</strong>；</p></blockquote></li><li><p>forge 项目的构建和测试</p><ul><li><p>当 mod 开发结束后，根目录运行 <code>gradlew build</code>，会向 <code>build/libs</code> 中构建 <code>[archivesBaseName]-[version].jar</code>，您可以直接将这个包放在安装了 forge 的 minecraft 游戏的 <code>mod</code> 目录中，即可加载；</p></li><li><p>当然，每写一次就要加入游戏目录的操作不现实。所以测试中，可以使用 <code>Run Configure</code> 来运行测试的 Minecraft 服务器 + 客户端，<strong>这时会加入开发目录（之前说过，<code>src/main/java</code>）的所有 mod jar 包</strong>；</p><blockquote><p>具体命令：启动服务器 <code>gradlew runServer</code>，自动绑定在 <code>localhost</code> 的指定端口；启动客户端 <code>gradlew runClient</code>；</p><p><strong>测试时建议就用上面的测试服务器环境哦~ 别去网络上正式的服务器测试</strong>😂</p></blockquote></li></ul></li></ul><h3 id="0-6-Mod-结构设计"><a href="#0-6-Mod-结构设计" class="headerlink" title="0.6 Mod 结构设计"></a>0.6 Mod 结构设计</h3><ul><li><p>和普通 Java 项目一样，设定好 top level package，然后为 mod 起一个唯一的名字；比如，我的 top level package 名叫做 <code>com.test</code>，然后我起个包名 <code>helloMC</code>，于是叫 <code>com.test.helloMC</code>；</p><blockquote><p>还是补充一下，如果以后做 Java Web，top level package 的名字需要是自己有的域名前缀，例如我有 <code>xxx.org</code>，那么为这个域名开发 Java Web 服务的规范就是 top level package <code>org.xxx</code>；</p></blockquote></li><li><p><code>mods.toml</code> 文件设计：上面说过，这个文件定义了 mod 的元信息（metadata），<strong>可以被 mod 使用者在游戏添加 mod 的界面看到</strong>；</p><ul><li><p>一个信息文件能够描述多个 mod；</p></li><li><p><code>mods.toml</code> 的语言是 <code>TOML</code>（可以理解为和 <code>YAML</code> 差不多的东西，语法不一样），必须要被存放于 <code>src/main/resources/META-INF/</code> 下；</p></li><li><p>一个 <code>mods.toml</code> 最基本的模板如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The name of the mod loader type to load - for regular FML @Mod mods it should be javafml</span></span><br><span class="line">   <span class="attr">modLoader</span>=<span class="string">&quot;javafml&quot;</span></span><br><span class="line">   <span class="comment"># A version range to match for said mod loader - for regular FML @Mod it will be the forge version</span></span><br><span class="line">   <span class="comment"># Forge for 1.16.5 is version 36</span></span><br><span class="line">   <span class="attr">loaderVersion</span>=<span class="string">&quot;[36,)&quot;</span></span><br><span class="line">   <span class="comment"># The license for your mod. This is mandatory and allows for easier comprehension of your redistributive properties.</span></span><br><span class="line">   <span class="comment"># Review your options at https://choosealicense.com/. All rights reserved is the default copyright stance, and is thus the default here.</span></span><br><span class="line">   <span class="attr">license</span>=<span class="string">&quot;All Rights Reserved&quot;</span></span><br><span class="line">   <span class="comment"># A URL to refer people to when problems occur with this mod</span></span><br><span class="line">   <span class="attr">issueTrackerURL</span>=<span class="string">&quot;github.com/MinecraftForge/MinecraftForge/issues&quot;</span></span><br><span class="line">   <span class="comment"># If the mods defined in this file should show as separate resource packs</span></span><br><span class="line">   <span class="attr">showAsResourcePack</span>=<span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">   <span class="section">[[mods]]</span></span><br><span class="line">     <span class="attr">modId</span>=<span class="string">&quot;examplemod&quot;</span></span><br><span class="line">     <span class="attr">version</span>=<span class="string">&quot;1.0.0.0&quot;</span></span><br><span class="line">     <span class="attr">displayName</span>=<span class="string">&quot;Example Mod&quot;</span></span><br><span class="line">     <span class="attr">updateJSONURL</span>=<span class="string">&quot;minecraftforge.net/versions.json&quot;</span></span><br><span class="line">     <span class="attr">displayURL</span>=<span class="string">&quot;minecraftforge.net&quot;</span></span><br><span class="line">     <span class="attr">logoFile</span>=<span class="string">&quot;logo.png&quot;</span></span><br><span class="line">     <span class="attr">credits</span>=<span class="string">&quot;I&#x27;d like to thank my mother and father.&quot;</span></span><br><span class="line">     <span class="attr">authors</span>=<span class="string">&quot;Author&quot;</span></span><br><span class="line">     <span class="attr">description</span>=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">     Lets you craft dirt into diamonds. This is a traditional mod that has existed for eons. It is ancient. The holy Notch created it. Jeb rainbowfied it. Dinnerbone made it upside down. Etc.</span></span><br><span class="line"><span class="string">     &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">     <span class="section">[[dependencies.examplemod]]</span></span><br><span class="line">       <span class="attr">modId</span>=<span class="string">&quot;forge&quot;</span></span><br><span class="line">       <span class="attr">mandatory</span>=<span class="literal">true</span></span><br><span class="line">       <span class="attr">versionRange</span>=<span class="string">&quot;[36,)&quot;</span></span><br><span class="line">       <span class="attr">ordering</span>=<span class="string">&quot;NONE&quot;</span></span><br><span class="line">       <span class="attr">side</span>=<span class="string">&quot;BOTH&quot;</span></span><br><span class="line">    </span><br><span class="line">     <span class="section">[[dependencies.examplemod]]</span></span><br><span class="line">       <span class="attr">modId</span>=<span class="string">&quot;minecraft&quot;</span></span><br><span class="line">       <span class="attr">mandatory</span>=<span class="literal">true</span></span><br><span class="line">       <span class="attr">versionRange</span>=<span class="string">&quot;[1.16.5,1.17)&quot;</span></span><br><span class="line">       <span class="attr">ordering</span>=<span class="string">&quot;NONE&quot;</span></span><br><span class="line">       <span class="attr">side</span>=<span class="string">&quot;BOTH&quot;</span></span><br></pre></td></tr></table></figure><p>以下是必须要填写的信息列表：</p><table>    <tr style="text-align: center;">        <th>Property</th>        <th>Type</th>        <th>Default</th>        <th>Description</th>    </tr>    <tr>        <td>modid</td>        <td>string</td>        <td>mandatory</td>        <td>The modid this file is linked to (also the modid in build.gradle).</td>    </tr>    <tr>        <td>version</td>        <td>string</td>        <td>mandatory</td>        <td>The version of the mod. It should be just numbers separated by dots, ideally conforming to Forge’s Semantic Versioning structure.</td>    </tr>    <tr>        <td>displayName</td>        <td>string</td>        <td>mandatory</td>        <td>The user-friendly name of this mod.</td>    </tr>    <tr>        <td>updateJSONURL</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>The URL to a version JSON.</td>    </tr>    <tr>        <td>displayURL</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>A link to the mod’s homepage.</td>    </tr>    <tr>        <td>logoFile</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>The filename of the mod’s logo. It must be placed in the root resource folder, not in a subfolder.</td>    </tr>    <tr>        <td>credits</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>A string that contains any acknowledgements you want to mention.</td>    </tr>    <tr>        <td>authors</td>        <td>string</td>        <td>&quot;&quot;</td>        <td>The authors of this mod.</td>    </tr>    <tr>        <td>description</td>        <td>string</td>        <td>mandatory</td>        <td>A description of this mod.</td>    </tr>    <tr>        <td>dependencies</td>        <td>[list]</td>        <td>[]</td>        <td>A list of dependencies of this mod.</td>    </tr></table></li></ul></li><li><p><code>@Mod</code> annotation：在编写 mod 中，这个标识是用来提示 <code>Forge Mod Loader</code>，<strong>这个类是一个 Mod entry point</strong>；另外，这个标识的值需要是 <code>modid</code>（在 <code>build.gradle</code> 和 <code>mods.toml</code> 都写过）；</p></li><li><p><strong>一个建议</strong>（不强制）：比起将源文件散落在文件夹中，使用 <code>sub-packages</code> 的结构可读性更强；例如像物体（items）、方块（blocks）、数据实体（tile entities，或者其他 sub-packages）应该放在 <code>common</code> 包，而屏幕（Screens）、渲染器（Renderers）应该放在 <code>client</code> 下；</p><blockquote><p>这里补充一下什么是 <code>tile entities</code>，后面用到详细说。</p><p>Tile Entities就像简化的实体一样，绑定到Block上。 它们用于存储动态数据，执行基于tick的任务以及动态渲染。 </p><p>原本 Minecraft的一些例子是：处理库存（箱子），熔炉上的冶炼逻辑或信标的区域效应。 mod中存在更高级的示例，例如采石场，分拣机，管道和显示器。</p><p>注意：不要滥用！如果使用不当会导致卡顿；</p></blockquote></li><li><p>类名命名规范：<strong>在您创建的类名之后加上它们的父类名（即是什么），可以让读者更能理解这个类在干什么</strong>；</p><blockquote><p>这其实是所有语言、所有场景开发的共同的规范。</p><p>例如，一个自定义物品 <code>PowerRing</code>，它的类继承于 <code>Item</code>，因此最好定为 <code>PowerRingItem</code>;</p><p>再如一个自定义方块 <code>NotDirt</code>，继承于 <code>Block</code>，因此命名为 <code>NotDirtBlock</code>；</p></blockquote></li></ul><h3 id="0-7-Mod-更新系统"><a href="#0-7-Mod-更新系统" class="headerlink" title="0.7 Mod 更新系统"></a>0.7 Mod 更新系统</h3><p>Forge 提供了一个可选的、轻量级的更新检查的框架，在作者提交更新后，使用 mod 的用户会在游戏中 mod 管理的按钮上看到更新，并且会写入 <code>changelogs.txt</code>，但不会自动下载升级；</p><p>为了集成这个功能，只需设置上面 <code>mods.toml</code> 的可选参数 <code>updateJSONURL</code>，这个 URL 可以指向您提供 “update json” 的网站服务器或者 github 上（只要别人能访问到）；</p><p>而这个 “update json” 的格式为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;homepage/download page for your mod&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;&lt;mcversion&gt;&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&lt;modversion&gt;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;changelog for this version&gt;&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="comment">// List all versions of your mod for the given Minecraft version, along with their changelogs</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;promos&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&lt;mcversion&gt;-latest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;modversion&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// Declare the latest &quot;bleeding-edge&quot; version of your mod for the given Minecraft version</span></span><br><span class="line">    <span class="attr">&quot;&lt;mcversion&gt;-recommended&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;modversion&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// Declare the latest &quot;stable&quot; version of your mod for the given Minecraft version</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>值得注意的是：</p><ul><li><code>homepage</code> 的地址在使用者的 mod 需要更新时会显示出来，注意隐私；</li><li>Forge 使用一套内置算法来判断当前版本和 update JSON 的版本哪个更新，大多数情况下应该没问题，如果有疑惑可以查阅 <code>ComparableVersion</code> 类或 <a href="https://semver.org/">Semantic Versioning</a>；</li><li>上面的 <code>changelog</code> 字符串可以使用 <code>\n</code>，也可以给用户提供一个网站让他们在网站上详细看；</li></ul><h3 id="0-8-Mod-进阶调试"><a href="#0-8-Mod-进阶调试" class="headerlink" title="0.8 Mod 进阶调试"></a>0.8 Mod 进阶调试</h3><p>Minecraft 自身提供了一个 Debug Profiler，能够分析出耗时的代码块，这对于 mod 开发者和服务器管理员非常有用；</p><p>开始分析命令：<code>/debug start</code>，结束分析命令：<code>/debug end</code>；</p><ul><li><p>建议最少给 Debug Profiler 的分析留出 1 min 时间，时间越多，分析约准确；</p></li><li><p>要分析的实体（Entities）需要在当前世界中存在，不然分析不到它；</p></li></ul><p>在结束分析后，会自动生成 <code>profile-results-yyyy-mm-dd_hh.mi.ss.txt</code>，</p><p>文件格式：<code>&lt;the depth of the section&gt; | &lt;the name of the section&gt; - &lt;the percentage of time it took in relation to it’s parent&gt;/&lt;how much time it took from the entire tick&gt;</code></p><h3 id="0-9-第一个-Mod：跑通流程"><a href="#0-9-第一个-Mod：跑通流程" class="headerlink" title="0.9 第一个 Mod：跑通流程"></a>0.9 第一个 Mod：跑通流程</h3><p>上面说了很多内容，现在让我们以一个没有内容的测试 mod 来实际跑一遍：</p><p><strong>step 1.</strong> 在 <code>src/main/java</code> 下创建一个包，例如 <code>com.test</code>，创建 Java 类 <code>HelloMC</code>；</p><p><strong>step 2.</strong> 根据 0.6 节中介绍的 modid，<strong>需要用 <code>@Mod(&lt;modid&gt;)</code> 修饰 mod 的 entry point 类</strong>，保持：<strong>@Mod 修饰值、<code>mods.toml</code> 的 <code>modid</code>、<code>build.gradle</code> 的 <code>examplemod</code> 三者一致</strong>。因此，我们需要给 <code>HelloMC</code> 加 <code>@Mod()</code> annotation。为了方便，我们另外创建一个类，专门存储全局变量，就定为 <code>Utils</code>（你也可以不用，看自己的编码习惯）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HelloMC.java</span></span><br><span class="line"><span class="keyword">package</span> com.test.HelloMC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.minecraftforge.fml.common.Mod;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mod(Utils.MOD_ID)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloMC</span> &#123;</span><br><span class="line">    <span class="comment">// 这里先空着，因为没学</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: Utils.java</span></span><br><span class="line"><span class="keyword">package</span> com.test.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MOD_ID</span> <span class="operator">=</span> <span class="string">&quot;mymod&quot;</span>;        <span class="comment">// 自己写 modid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>step 3.</strong> 现在去写 <code>mods.toml</code>，注意填写 <code>mod_id</code>：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面使用的 @Mod 就在这个 modLoader 中，和 loaderVersion 不用改</span></span><br><span class="line">   <span class="attr">modLoader</span>=<span class="string">&quot;javafml&quot;</span></span><br><span class="line">   <span class="attr">loaderVersion</span>=<span class="string">&quot;[36,)&quot;</span></span><br><span class="line">   <span class="comment"># 自己选证书：https://choosealicense.com/.</span></span><br><span class="line">   <span class="attr">license</span>=<span class="string">&quot;All Rights Reserved&quot;</span></span><br><span class="line">   <span class="comment"># 自己定义 issue 提问网站，可选</span></span><br><span class="line">   <span class="attr">issueTrackerURL</span>=<span class="string">&quot;https://github.com/MinecraftForge/MinecraftForge/issues&quot;</span></span><br><span class="line">   <span class="comment"># 暂时用不到，不管它</span></span><br><span class="line">   <span class="attr">showAsResourcePack</span>=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">   <span class="section">[[mods]]</span></span><br><span class="line">     <span class="attr">modId</span>=<span class="string">&quot;yourID&quot;</span></span><br><span class="line">     <span class="attr">version</span>=<span class="string">&quot;1.0.0.0&quot;</span></span><br><span class="line">     <span class="attr">displayName</span>=<span class="string">&quot;Example Mod&quot;</span></span><br><span class="line">     </span><br><span class="line">     <span class="attr">updateJSONURL</span>=<span class="string">&quot;minecraftforge.net/versions.json&quot;</span>    <span class="comment"># 中间这块都是可选的</span></span><br><span class="line">     <span class="attr">displayURL</span>=<span class="string">&quot;minecraftforge.net&quot;</span></span><br><span class="line">     <span class="attr">logoFile</span>=<span class="string">&quot;logo.png&quot;</span></span><br><span class="line">     <span class="attr">credits</span>=<span class="string">&quot;I&#x27;d like to thank my mother and father.&quot;</span></span><br><span class="line">     <span class="attr">authors</span>=<span class="string">&quot;Author&quot;</span></span><br><span class="line">     </span><br><span class="line">     <span class="attr">description</span>=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">     Lets you craft dirt into diamonds. This is a traditional mod that has existed for eons. It is ancient. The holy Notch created it. Jeb rainbowfied it. Dinnerbone made it upside down. Etc.</span></span><br><span class="line"><span class="string">     &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的依赖是必要的，别碰</span></span><br><span class="line">     <span class="section">[[dependencies.yourID]]</span></span><br><span class="line">       <span class="attr">modId</span>=<span class="string">&quot;forge&quot;</span></span><br><span class="line">       <span class="attr">mandatory</span>=<span class="literal">true</span></span><br><span class="line">       <span class="attr">versionRange</span>=<span class="string">&quot;[36,)&quot;</span></span><br><span class="line">       <span class="attr">ordering</span>=<span class="string">&quot;NONE&quot;</span></span><br><span class="line">       <span class="attr">side</span>=<span class="string">&quot;BOTH&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="section">[[dependencies.yourID]]</span></span><br><span class="line">       <span class="attr">modId</span>=<span class="string">&quot;minecraft&quot;</span></span><br><span class="line">       <span class="attr">mandatory</span>=<span class="literal">true</span></span><br><span class="line">       <span class="attr">versionRange</span>=<span class="string">&quot;[1.16.5,1.17)&quot;</span></span><br><span class="line">       <span class="attr">ordering</span>=<span class="string">&quot;NONE&quot;</span></span><br><span class="line">       <span class="attr">side</span>=<span class="string">&quot;BOTH&quot;</span></span><br></pre></td></tr></table></figure><p><strong>step 4.</strong> 再到 <code>build.gradle</code> 中，将所有 <code>examplemod</code> 换成自己的 modid，修改个性化内容，然后构建！</p><p><strong>step 5.</strong> 启动 IDEA 上的任务设置 “RunClient”，进入游戏查看自己的 mod 是否已经显示！</p><h3 id="0-10-事件系统"><a href="#0-10-事件系统" class="headerlink" title="0.10 事件系统"></a>0.10 事件系统</h3><p>早在 0.3 节说明运行模式的时候，我们提到了 <code>Mod</code> 总线和 <code>Forge</code> 总线，这里在开发前必须要说清楚。Forge 自己的事件系统内是独立于 Minecraft 的事件系统的。</p><p>使用 Forge 事件系统的方法有 2 种，先看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEventHandler</span> &#123;</span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pickupEvent</span><span class="params">(EntityItemPickupEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Item picked up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个类 <code>TestEventHandler</code>，里面有个实例方法 <code>pickupEvent()</code>。注意 <code>@SubscribeEvent</code> 标记，<strong>它的作用就是指示下方的方法为事件处理器</strong>，而它监听的事件类型由它的参数决定（<code>EntityItemPickupEvent</code>，实体捡起物品这个事件）。</p><p>但是只是让他声明为事件处理器还不够，还需要在合适的位置将含有事件处理器的类<strong>实例化</strong>，并<strong>注入事件总线中</strong>。是 <code>Forge</code> 总线还是 <code>Mod</code> 总线？</p><ul><li><p><code>Mod</code> 总线：负责游戏的生命周期事件，也就是<strong>初始化过程的事件</strong>；注册方法：<code>FMLJavaModLoadingContext.get().getModEventBus().register(&lt;subscribed_event_obj&gt;)</code>；</p></li><li><p><code>Forge</code> 总线：负责的就是除了生命周期事件外的所有事件；注册方法：<code>MinecraftForge.EVENT_BUS.register(&lt;subscribed_event_obj&gt;)</code>；</p></li></ul><p>显然，上面 “实体捡起物品” 的事件在初始化过程之外，所以加入 <code>Forge</code> 总线：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MinecraftForge.EVENT_BUS.register(<span class="keyword">new</span> <span class="title class_">TestEventHandler</span>());</span><br></pre></td></tr></table></figure><p>显然这样注册的方法比较麻烦，被称为 “实例注册方式”。还有一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mod</span>.EventBusSubscriber(modid = <span class="string">&quot;mymod&quot;</span>, bus = Bus.FORGE, value = Dist.CLIENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStaticClientOnlyEventHandler</span> &#123;</span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">drawLast</span><span class="params">(RenderWorldLastEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管传给注解的参数（都是可选的），我们发现，这个类中的事件处理器是<strong>静态的</strong>（另注：由于是渲染事件，所以仅客户端）。这里，我们就可以在整个类前加上注解 <code>@Mod.EventBusSubscriber([modid, bus, value])</code>，表示将类中的所有事件处理器都加入指定 modid、总线、端中。</p><p>这里补充，如果是 <code>Mod</code> 总线，那么 <code>bus = Bus.MOD</code>，更多信息可以转到 <code>@Mod.EventBusSubscriber()</code> 的源码查看。</p><h2 id="Chapter-1-创建物品"><a href="#Chapter-1-创建物品" class="headerlink" title="Chapter 1. 创建物品"></a>Chapter 1. 创建物品</h2><h3 id="1-1-第一个物品"><a href="#1-1-第一个物品" class="headerlink" title="1.1 第一个物品"></a>1.1 第一个物品</h3><p>本节了解，创建一个物品就 3 步【所有物品都是这样】：</p><ol><li>创建自己的物品类，一般继承于原版的物品的类 <code>Item</code>；</li><li>在合适的位置实例化这个物品；</li><li>将此物品对象注册进游戏；</li></ol><p>我们先以一个原版游戏中没有 “黑曜石锭” 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianIngot</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObsdianIngot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Properties</span>().group(ItemGroup.MATERIALS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就写了一个构造函数，向父类的构造函数传递了一个 <code>Properties</code> 类的对象，而这个 <code>Properties</code> 对象调用了 <code>group()</code>，<strong>表示设置物品所在组为 <code>Materials</code> 组（杂项栏）</strong>。</p><p>传给父类的 <code>Properties</code> 对象的作用是规定了物品的一些属性，比如：是不是食物，或者这个物品在创造模式的哪一个物品栏。这里的 <code>group()</code> 方法就是设置了物品在创造模式的杂项栏。</p><p>如果不调用 <code>group()</code> 方法设置，那么这个物品就不会出现在创造模式物品栏，只能用 <code>/give</code> 获取；</p><p>然后是实例化 + 注册。现在的 <code>Forge</code> 引入了 <code>DeferredRegister</code>的机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DeferredRegister&lt;Item&gt; item_reg = </span><br><span class="line">        DeferredRegister.create(ForgeRegistires.ITEMS, Utils.MOD_ID);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsdianIngot = </span><br><span class="line">        item_reg.register(<span class="string">&quot;obsidian_ingot&quot;</span>, ObsidianIngot::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先使用 <code>DeferredRegister</code> 泛型类的静态方法 <code>create(&lt;ForgeRegistries.TYPE&gt;, &lt;mod_id&gt;)</code> 向 <code>mod_id</code> 的 mod 创建了一个 <code>DeferredRegister&lt;Type&gt;</code>  对象，表示<strong>这是专门注册 <code>Type</code> 类型实体的类</strong>。</p><p>紧接着告诉这个对象要注册 “注册名为 ‘obsdian_ingot’（不能大写）、其对象构造方法为 <code>ObsidianIngot::new</code>” 的一个类的 <code>supplier</code>。</p><p>最后，由于这个 <code>DeferredRegister</code> 泛型类帮助我们注册物品需要依赖<strong>注入事件</strong>。显然注册是一种初始化的事件，所以将 <code>DeferredRegister</code> 对象注入 <code>Mod</code> 总线（我们以 0.9 中的项目为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mod(Utils.MOD_ID)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloMC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloMC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// DeferredRegister 的 register 方法如果参数是总线，就将自己注入总线中</span></span><br><span class="line">        ItemRegistry.item_reg.register(</span><br><span class="line">            <span class="comment">// 这里前面说过，获取 Mod 总线</span></span><br><span class="line">            FMLJavaModLoadingContext.get().getModEventBus()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会发现新的、没有材质的物品出现在创造模式的物品栏中。</p><h3 id="1-2-物品的模型和材质"><a href="#1-2-物品的模型和材质" class="headerlink" title="1.2 物品的模型和材质"></a>1.2 物品的模型和材质</h3><p>一个物品被注册后，还应该指定它的模型和材质。这种指定方式也是固定的，记忆即可。下面以上面的 <code>ObsidianIngot</code> 为例。</p><p>第一步，在 <code>src/main/resources</code> 创建 <code>assets</code> 目录，表示这个 mod 存储资源的位置。并将目录补充为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resources/</span><br><span class="line">├── META-INF/</span><br><span class="line">│   └── mods.toml</span><br><span class="line">├── assets/</span><br><span class="line">│   └── mymod/        # 你的 modid</span><br><span class="line">│       ├── models/</span><br><span class="line">│       │   └── item/    # MC 中要求这个目录名，不能改，表示 item（物品）类型</span><br><span class="line">│       └── textures/</span><br><span class="line">│           └── item/</span><br><span class="line">└── pack.mcmeta</span><br></pre></td></tr></table></figure><p>一定要创建 <code>pack.mcmeta</code>，这相当于为 mod <strong>规定了资源包</strong>。只有这么做，MC 才能发现 <code>assets</code> 中的资源。格式也是 <code>JSON</code>，模板：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">  <span class="attr">&quot;pack&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pack_format&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span>    <span class="comment">// 看官网，pack_format = 10 时支持 MC 1.20 以下的版本</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Resource Pack&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;language&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;LANG_COUNTRY&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Custom Language&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Country/Region name&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bidirectional&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>第二步，在 <code>models/item</code> 的目录中创建 <code>obsidian_ingot.json</code>，文件名需要和之前<strong>物品注册名</strong>相同。</p><p><code>item</code>（物品类）模型的 JSON 文件的模板如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 父模型，即由什么模型加载而来</span></span><br><span class="line">    <span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/generated&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;textures&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">// 指定了最底层的材质（格式在 0.4 中已经叙述）</span></span><br><span class="line">        <span class="attr">&quot;layer0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mymod:item/obsidian_ingot&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>textures/item</code> 的目录中放入自己设计的材质 <code>obsidian_ingot.png</code>（游戏中 1:1，<strong>仅贴图最好不要大于 32×32 像素</strong>），文件名也是物品注册名。</p><p>最后启动游戏就会发现游戏自动读取了模型和材质。</p><p>注：自己制作模型的网站戳 <a href="https://blockbench.net/">这里</a>；</p><h4 id="补充：BlockBench-笔记"><a href="#补充：BlockBench-笔记" class="headerlink" title="补充：BlockBench 笔记"></a>补充：BlockBench 笔记</h4><ul><li>绑骨：按照父级模型生长方向移动、旋转等操作，可以用作设计动画；</li><li>顶点识别；</li><li>隐藏的菜单：x/y/z 轴翻转；</li><li>缩放参数：可以在不改变材质的情况下改变模型大小，允许小数；</li><li>大纲视图的锁定：可以防止误操作；</li><li>背景图的作用大部分是用来拾色的；</li><li>后期添加模型过大，放不下空白材质时，可以为材质调整大小；</li></ul><h3 id="1-3-Item-类和-ItemStack-类"><a href="#1-3-Item-类和-ItemStack-类" class="headerlink" title="1.3 Item 类和 ItemStack 类"></a>1.3 <code>Item</code> 类和 <code>ItemStack</code> 类</h3><p>前面两节叙述了加入普通自定义物品（<code>item</code>）的大致流程。现在深入一下更抽象的层面，考虑这些物品背后的类，以便我们进一步对它们进行自定义。</p><p>首先，很方便理解的是 <code>Item</code> 类，就是规定每种物品属性的类。细心的同学可能会提问，我们之前创建的 <code>ObsidianIngot</code> 这个类在游戏的框中显示的数量呢？一组应该是多少个呢？<code>Item</code> 类都没有定义。</p><p>这是因为，设计者考虑到 <code>item</code> 的有些信息不会因为数量、耐久等参数的改变而改变，例如：</p><ul><li>使用/放置（左键/右键）的行为；</li><li>在客户端上显示的名称及 Tooltip；</li><li>合成配方；</li><li>et cetera；</li></ul><p>这些抽象的属性都在 <code>Item</code> 类中得到定义；而数量、是否有/有多少耐久等信息，就单独提出去打包为一个类，其名曰 <code>ItemStack</code>。游戏中，玩家的物品栏、背包、手持物品等，<strong>都是 <code>ItemStack</code> 的实例</strong>。</p><p>所以，可以将 <code>ItemStack</code> 和 <code>Item</code> 的关系看作<strong>类的聚集</strong>，在对 <code>ItemStack</code> 可以调用 <code>getItem()</code> 实例方法来获得其中含有的 <code>Item</code> 对象。</p><h4 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h4><p>另外有个极其重要的概念——“<strong>享元（Flyweight Pattern）</strong>”，即<strong>一种特定物品只对应一个实例</strong>，而 <code>Item</code> 就是一个享元。这意味着，以 <code>Apple</code> 类为例，你在游戏里见到<strong>所有</strong>苹果都是 <code>Apple</code> 类的唯一实例。正因如此，我们在编写 mod 中，可以直接用 <code>==</code>（即  <code>&lt;ItemStack_obj&gt;.getItem() == &lt;Item_obj&gt;</code>）来判断 <code>Item</code> 种类，不用担心 <code>==</code> 比较的是地址。</p><h4 id="Item-AIR"><a href="#Item-AIR" class="headerlink" title="Item.AIR"></a><code>Item.AIR</code></h4><p>还有一件事，由于 <code>ItemStack</code> 是 <code>non-null</code> 的属性，永远是非空引用，所以 <strong>MC 中 “空的” 栏的 <code>ItemStack</code> 所含的 <code>Item</code> 对象是个特殊对象：<code>Items.AIR</code></strong>。判断 <code>ItemStack</code> 对应的栏目物品是否为空时，应该使用专用的实例函数 <code>isEmpty()</code>，不能直接判断是否为 <code>null</code>。</p><h3 id="1-4-自定义物品组"><a href="#1-4-自定义物品组" class="headerlink" title="1. 4 自定义物品组"></a>1. 4 自定义物品组</h3><p>物品组可以形象地理解为创造模式物品栏的分栏。我们在最开始就提到的类 <code>ItemGroup</code>，所以自定义物品组很简单——就写一个继承于 <code>ItemGroup</code> 类的子类就行。</p><p>这个继承的类只需要写<strong>两个地方</strong>，一个是构造函数，直接使用父类的即可，<strong>第一个参数是物品组的名称 <code>String</code></strong>。（这个组就以 “ObsidianGroup” 为例）</p><p>另一个是重写类里面的 <code>createIcon()</code> 实例方法（实际用途是创建物品栏的图标），要求返回一个 <code>ItemStack</code> 实例（毕竟需要将物品呈现在物品栏中），这个也很简单，用 <code>ItemStack</code> 构造函数构造个实例就行。<strong><code>ItemStack</code> 构造函数的第一参数就是已注册的 <code>Item</code> 实例对象</strong>。</p><blockquote><p>从哪获取已注册的 <code>Item</code> 实例？简单，之前我们注册完物品后，<code>DeferredRegister::register</code> 方法不是返回了一个 <code>RegisterObject&lt;Item&gt;</code>，它就是包裹了注册信息的 <code>Item</code>，直接用 <code>get()</code> 实例方法就能返回已注册的 <code>Item</code> 实例。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianGroup</span> <span class="keyword">extends</span> <span class="title class_">ItemGroup</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObsidianGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;obsidian_group&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemStack <span class="title function_">createIcon</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ItemRegistry.obsidianIngot 对象在 1.1 中定义，忘了回去看</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemStack</span>(ItemRegistry.obsidianIngot.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个简单的物品组类就做好了。但是想要将它显示在游戏里，还要将它在合适的位置实例化。</p><p>我们再定义一个类，专门存放 mod 中实例化的 <code>ItemGroup</code> 的类，就叫 <code>ModGroup</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModGroup</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ItemGroup</span> <span class="variable">og_group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObsidianGroup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在物品类初始化的时候，用 <code>Properties::group()</code> 实例方法将物品加入 <code>og_group</code> 这个实例即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianIngot</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObsidianIngot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Properties</span>().group(ModGroup.itemGroup));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-食物"><a href="#1-5-食物" class="headerlink" title="1.5 食物"></a>1.5 食物</h3><p>食物就是一种特殊的 <code>Item</code>，也继承于 <code>Item</code> 来创建，只是比普通 <code>Item</code> 多几个属性（包括专门的类 <code>Food</code> 作为属性）。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianApple</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="comment">// 定义食物的属性，使用 Food 类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> (</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Food</span>.Builder().saturation(<span class="number">10</span>)</span><br><span class="line">                          .hunger(<span class="number">20</span>)</span><br><span class="line">                          <span class="comment">// 使用接口创建 Supplier&lt;EffectInstance&gt;</span></span><br><span class="line">                          .effect(() -&gt; <span class="keyword">new</span> <span class="title class_">EffectInstance</span>(Effects.POISON, <span class="number">3</span>*<span class="number">20</span>, <span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">                          .build();</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为 Java 基础补充知识：<code>Java</code> <code>Supplier</code>是一个功能接口，代表结果的提供者，<strong>存在于 <code>java.util.function</code> 包</strong>。常用方法是 <code>get()</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用来返回一个<strong>特定</strong>的结果对象。我们可以用 <code>lambda</code> 表达式，例如上面 <code>() -&gt; new EffectInstance(Effects.POISON, 3*20, 1)</code> 创建一个调用返回新 <code>EffectInstance</code> 对象的匿名函数。这个格式得到的左值就是 <code>supplier</code>。</p><p>也可以定义一个完整的匿名函数：<code>() -&gt; &#123; return XXX; &#125;</code></p></blockquote><p>其中，<code>Food::Builder()</code> 静态方法初始化 <code>Food.Builder</code> 类实例，用来在 <code>Food</code> 属性对象生成前设置好参数，支持 <code>saturation()</code>、<code>hunger()</code>、<code>effect()</code> 方法。</p><p>需要说明的是，其中 <code>effect()</code> 方法的<strong>第一参数</strong>是 <code>Supplier&lt;EffectInstance&gt;</code>，<strong>第二参数</strong>是<strong>触发的概率</strong>。<code>EffectInstance</code> 类的初始化方法第一参数是 <strong><code>Effects</code> 类的枚举量</strong>（含有 MC 中几乎所有效果），第二参数是效果持续的游戏 Tick 时间，第三参数是对应的药水等级。</p><blockquote><p>一个游戏刻 <code>Tick</code> 就是主程序循环一次的时间，固定是 <code>0.05 s</code>；上面的 <code>3*20</code> 就是 3 秒。</p></blockquote><p>最后的 <code>Food.Builder::build()</code> 方法将 <code>Food.Builder</code> 及其中的设置构造为 <code>Food</code> 类的实例，可以在初始化物品时对 <code>Properties</code> 对象使用 <code>food()</code> 方法指定（和 <code>group()</code> 一样）。</p><p>接下来的物品注册、模型和材质都与普通 <code>Item</code> 相差无几。</p><h3 id="1-6-近战武器-和-工具"><a href="#1-6-近战武器-和-工具" class="headerlink" title="1.6 近战武器 和 工具"></a>1.6 近战武器 和 工具</h3><p><strong>MC 原版 1.16.5 的近战武器可以认为只有剑</strong>，如果想要自定义近战物品，就可以按剑的类的做法来做（入门不介绍攻击动画的制作，就复用剑的攻击动画）。</p><p><strong>MC 原版 1.16.5 的工具就是耳熟能详几件：稿子、铲子、斧头、锄头</strong>。</p><p>首先，细心的同学可以发现，木头、石头、铁、黄金和钻石种类的武器面板基础数据（除去附魔等加成的效率、耐久、伤害……）是不同的，并且损坏后修复的材料不同。但它们都是 “剑 / 稿 / 斧 / 锄 / 铲” 这个属性，所以这些额外的数据<strong>可以抽象为一个单独的类 / 枚举类型来管理</strong>，在初始化时再传给 “剑 / 稿 / 斧 / 锄 / 铲” 这个类。在 MC 中，它就是<strong>枚举类型 <code>ItemTier</code></strong>，即 “工具等级”（Tiered adj. 阶梯式的、分层的）。</p><p>官方选择了<strong>接口类</strong>来设计 <code>ItemTier</code>，而由于 Java 的枚举类型在能够大量定义常量的同时，允许添加方法，因此我们只需写一个枚举类来 <code>implements</code> 它。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ModItemTier</span> <span class="keyword">implements</span> <span class="title class_">ItemTier</span> &#123;</span><br><span class="line">    <span class="comment">// 规范来说，enum 内部先定义实例</span></span><br><span class="line">    OBSIDIAN(<span class="number">3</span>, <span class="number">2000</span>, <span class="number">10.0F</span>, <span class="number">4.0F</span>, <span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> harvestLevel;        <span class="comment">// 精准采集等级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxUses;            <span class="comment">// 最大耐久值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> efficiency;        <span class="comment">// 效率值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> attackDamage;    <span class="comment">// 伤害</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> enchantability;    <span class="comment">// 附魔能力</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法就是将属性值全部传进去</span></span><br><span class="line">    ModItemTier(<span class="type">int</span> harvestIn, <span class="type">int</span> maxUsesIn, <span class="type">float</span> effIn, <span class="type">float</span> attIn, <span class="type">int</span> enchantabilityIn) &#123;</span><br><span class="line">        <span class="built_in">this</span>.harvestLevel = harvestIn;</span><br><span class="line">        <span class="built_in">this</span>.maxUses = maxUsesIn;</span><br><span class="line">        <span class="built_in">this</span>.efficiency = effIn;</span><br><span class="line">        <span class="built_in">this</span>.attackDamage = attIn;</span><br><span class="line">        <span class="built_in">this</span>.enchantability = enchantabilityIn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面的部分别看它长，就是把 get 方法简单覆盖一下 -------------------|</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHarvestLevel</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.harvestLevel; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxUses</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.maxUses; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getEfficiency</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.efficiency; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getAttackDamage</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.attackDamage; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEnchantability</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.enchantability; &#125;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------------|</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 之前提到的，修复材料需要单独写一下</span></span><br><span class="line">    <span class="comment">// 但具体的合成表还需要以后写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Ingredient <span class="title function_">getRepairMaterial</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Ingredient.fromItems(ItemRegistry.obsidianIngot.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别问为什么要重新写属性并且 <code>override</code>。因为这是个 <code>enum</code> 类型，不存在继承的说法，只能 <code>implements</code>  方法。</p><p>再来看 “剑 / 稿 / 斧 / 锄 / 铲” 类的继承关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Item --&gt; TieredItem (有工具等级的 item) --&gt; SwordItem</span><br><span class="line">                |</span><br><span class="line">                └─--&gt;    ToolItem// 这里是下一节要说的 “工具”，也有工具等级</span><br><span class="line">                            ├─----------&gt; PickaxeItem</span><br><span class="line">                            ├─----------&gt; ShovelItem</span><br><span class="line">                            ├─----------&gt; AxeItem</span><br><span class="line">                            └─----------&gt; HoeItem</span><br></pre></td></tr></table></figure><p>这里简单到爆炸，只需要掌握这些类的初始化方法就行，以剑为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SwordItem</span><span class="params">(ItemTier tier_obj, <span class="type">int</span>, <span class="type">float</span>, Properties prop)</span>;</span><br></pre></td></tr></table></figure><p>像这里以黑曜石剑为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObsidianSword</span> <span class="keyword">extends</span> <span class="title class_">SwordItem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObsidianSword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的 OBSIDIAN 是之前定义 enum ModItemTier 时创建的实例</span></span><br><span class="line">        <span class="comment">// ItemGroup.COMBAT 是战斗物品组，对应创造模式物品栏“铁剑”图标一栏</span></span><br><span class="line">        <span class="built_in">super</span>(ModIterTier.OBSIDIAN, <span class="number">3</span>, -<span class="number">2.4F</span>, <span class="keyword">new</span> <span class="title class_">Properties</span>().group(ItemGroup.COMBAT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SwordItem</code> 构造函数的第一参数 <code>ItemTier</code> 后面的两个参数分别是<strong>攻击伤害、攻击速度</strong>；</p><p>之后的模型、材质、物品注册也是完全和普通 <code>item</code> 相同。</p><p> 稿子、铲子、斧头、锄头也一样。</p><p>注意：以上数据面板理论上只要不溢出都可以自行设置。但如果想要写成好的 Mod，这边建议自己试试平衡性，再调整数值。</p><blockquote><p>你问为什么不介绍 “弓” 这种远程武器？这大概是因为 minecraft java 到处是高耦合度的代码（尤其是弓这个动作复杂的 item），哪怕仅修改拉弓速度都要引入 7~8 个包，故不再这里叙述。实在想要改，建议直接改材质 + 附魔；</p></blockquote><h3 id="1-7-可穿戴装备"><a href="#1-7-可穿戴装备" class="headerlink" title="1.7 可穿戴装备"></a>1.7 可穿戴装备</h3><p>和近战武器/工具类似，可穿戴装备也有 “工具等级” 来管理和装备位置无关的数据，这就是 <code>IArmorMaterial</code> <strong>接口类</strong>，我们模仿 1.6 中的 <code>ModItemTier</code> 用一个枚举类来自定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ObsidianArmorMaterial</span> <span class="keyword">implements</span> <span class="title class_">IArmorMaterial</span> &#123;</span><br><span class="line">    OBSIDIAN(</span><br><span class="line">        <span class="string">&quot;obsidian&quot;</span>, <span class="number">40</span>, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">5</span>&#125;, <span class="number">20</span>, SoundEvents.ITEM_ARMOR_EQUIP_DIAMOND, <span class="number">2.0F</span>, <span class="number">0.0F</span>, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Ingredient.fromItems(ItemRegistry.obsidianIngot.get());</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 下面是 IArmorMaterial 需要拥有的属性：</span></span><br><span class="line">                                                    <span class="comment">// 最大耐久数值数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] MAX_DAMAGE_ARRAY = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">13</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">11</span>&#125;;</span><br><span class="line">    <span class="comment">// 这个名字是给渲染端用的（也就是客户端），也是找材质用的名字。请确保此处、注册名、材质名三者写的是一个名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxDamageFactor;                <span class="comment">// 最大耐久衰减因数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] damageReductionAmountArray;    <span class="comment">// 减伤数组（保护效果）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> enchantability;                <span class="comment">// 附魔能力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SoundEvent soundEvent;            <span class="comment">// 穿着音效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> toughness;                    <span class="comment">// 文档没说，可以自己尝试</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> knockbackResistance;        <span class="comment">// 击退抵抗数值</span></span><br><span class="line">    <span class="comment">// 这个 LazyValue 可以理解为 Forge 包里面内含的一种容器，实现懒加载。泛型参数是懒加载的结果，而它初始化参数是对应泛型的 Supplier</span></span><br><span class="line">    <span class="comment">// 这个属性相当于 ItemTier 中的 getRepairMaterial()</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LazyValue&lt;Ingredient&gt; repairMaterial;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数还是就把之前的属性给它们赋值一遍</span></span><br><span class="line">    ObsidianArmorMaterial(</span><br><span class="line">        String armorName, <span class="type">int</span> maxDamageF, <span class="type">int</span>[]damageReductionArray,</span><br><span class="line">        <span class="type">int</span> enchantAbility, SoundEvent se, <span class="type">float</span> tough, <span class="type">float</span> knockResist,</span><br><span class="line">        Supplier&lt;Ingredient&gt; repairMaterialSupplier</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = armorName; <span class="built_in">this</span>.maxDamageFactor = maxDamageF;</span><br><span class="line">        <span class="built_in">this</span>.damageReductionAmountArray = damageReductionArray;</span><br><span class="line">        <span class="built_in">this</span>.enchantability = enchantAbility;</span><br><span class="line">        <span class="built_in">this</span>.soundEvent = se; <span class="built_in">this</span>.toughness = tough;</span><br><span class="line">        <span class="built_in">this</span>.knockbackResistance = knockResist;</span><br><span class="line">        <span class="built_in">this</span>.repairMaterial = <span class="keyword">new</span> <span class="title class_">LazyValue</span>&lt;&gt;(repairMaterialSupplier);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面实现 IArmorMaterial 接口，只要给出所有的 get 方法就行。注意名字和参数。</span></span><br><span class="line">    <span class="comment">// 注意，getName 因为是为客户端准备的函数，所以加上 annotation @OnlyIn 就行</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDurability</span><span class="params">(EquipmentSlotType slotIn)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MAX_DAMAGE_ARRAY[slotIn.getIndex()] * <span class="built_in">this</span>.maxDamageFactor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDamageReductionAmount</span><span class="params">(EquipmentSlotType slotIn)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.damageReductionAmountArray[slotIn.getIndex()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEnchantability</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.enchantability;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SoundEvent <span class="title function_">getSoundEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.soundEvent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Ingredient <span class="title function_">getRepairMaterial</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.repairMaterial.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnlyIn(Dist.CLIENT)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getToughness</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toughness;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getKnockbackResistance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.knockbackResistance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，和其他 item 一样设置可穿戴装备对应的对象，并且注册。</p><p>但是！一般情况我们无需继承不同的类，只需要创建 <code>ArmorItem</code> 类的不同实例，就能获得不同部位的 item 对象。这多半是因为可穿戴装备是盔甲，都设计成一套，例如注册时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回忆一下，item_reg 是之前在 ItemRegistry 类中定义的 DeferredRegister 类的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsidianHelmet = item_reg.register(<span class="string">&quot;obsidian_helmet&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ArmorItem</span>(ModArmorMaterial.OBSIDIAN, EquipmentSlotType.HEAD, (<span class="keyword">new</span> <span class="title class_">Item</span>.Properties()).group(ModGroup.itemGroup)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsidianChestplate = item_reg.register(<span class="string">&quot;obsidian_chestplate&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ArmorItem</span>(ModArmorMaterial.OBSIDIAN, EquipmentSlotType.CHEST, (<span class="keyword">new</span> <span class="title class_">Item</span>.Properties()).group(ModGroup.itemGroup)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsidianLeggings = item_reg.register(<span class="string">&quot;obsidian_leggings&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ArmorItem</span>(ModArmorMaterial.OBSIDIAN, EquipmentSlotType.LEGS, (<span class="keyword">new</span> <span class="title class_">Item</span>.Properties()).group(ModGroup.itemGroup)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; obsidianBoots = item_reg.register(<span class="string">&quot;obsidian_boots&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ArmorItem</span>(ModArmorMaterial.OBSIDIAN, EquipmentSlotType.FEET, (<span class="keyword">new</span> <span class="title class_">Item</span>.Properties()).group(ModGroup.itemGroup)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在传给 <code>DeferredRegister&lt;Item&gt;::register()</code> 的第二参数不再是类自带的 <code>new</code> 方法，而是临时写的匿名函数，利用已存在的类 <code>ArmorItem</code> 的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一参数是之前定义的 可穿戴装备的“等级枚举类”</span></span><br><span class="line"><span class="comment">// 第二参数是盔甲的部位，会针对性读取材质的某一区域</span></span><br><span class="line"><span class="comment">// 第三参数是原始的 item 对象的 supplier</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArmorItem</span><span class="params">(IArmorMaterial material, EquipmentSlotType type, Supplier&lt;Item&gt; item)</span>;</span><br></pre></td></tr></table></figure><p>现在最后一件事需要注意，<strong>就是盔甲的材质添加和其他 item 不一样</strong>。</p><p><strong>首先</strong>从前面共用一个类可以看出，这里<strong>盔甲的材质也在一个图中</strong>。说 “一个图” 不是很准确，准确来说是<strong>穿着状态的盔甲全套一组图，物品栏中的盔甲又是另一组图</strong>。所以这里需要两组材质图，分布在不同 “<code>layer</code>” 中。因此，如果想自己创作，还需要专门的软件，例如上面提到的 blockbench；</p><p><strong>其次</strong>，minecraft 自己把盔甲<strong>穿着</strong>的材质写死到 <code>minecraft:/</code> 资源作用域下，这意味着，我们不能在原来的地方加材质图，应该新建一个 <code>minecraft</code> 目录；而同时盔甲在物品栏的贴图也要自己设计，和普通 item 一样加 model json 和 扁平材质：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">resources/</span><br><span class="line">├── META-INF/</span><br><span class="line">│   └── mods.toml</span><br><span class="line">├── assets/</span><br><span class="line">│   ├── mymod/        # 你的 modid，之前材质存放的地方（作用域为 mymod:/）</span><br><span class="line">│   |   ├── models/</span><br><span class="line">│   |   │   └── item/                    # 盔甲物品栏图标模型 json 存放位置</span><br><span class="line">│   |   └── textures/</span><br><span class="line">│   |       └── item/                    # 盔甲物品栏材质图片存放位置</span><br><span class="line">|    |</span><br><span class="line">|    └── minecraft/# 新建的目录，材质作用域是 minecraft:/</span><br><span class="line">|            └── textures/</span><br><span class="line">|                    └── models/</span><br><span class="line">|                            └── armor/# 盔甲穿着材质图片存放位置</span><br><span class="line">|                                    └── ...</span><br><span class="line">|            </span><br><span class="line">└── pack.mcmeta</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，盔甲材质图命名格式：<code>&lt;Ingredient名称ID&gt;_layer_1</code>（穿着贴图）和 <code>&lt;Ingredient名称ID&gt;_layer_2</code>（物品栏贴图）；</p><h3 id="1-8-Item-属性重写"><a href="#1-8-Item-属性重写" class="headerlink" title="1.8 Item 属性重写"></a>1.8 Item 属性重写</h3><p>现在回忆一下，在 <code>minecraft</code> 中拉弓，是不是随着时间延长，弓的贴图会变化？这是怎么做到的呢？<strong>这里利用了模型 JSON 中的 <code>&quot;overrides&quot;</code> 项的设定</strong>，我们来看原版 minecraft 弓的模型 JSON 的一部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">&quot;overrides&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;pulling&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/bow_pulling_0&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;pulling&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;pull&quot;</span><span class="punctuation">:</span> <span class="number">0.65</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/bow_pulling_1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;pulling&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;pull&quot;</span><span class="punctuation">:</span> <span class="number">0.9</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/bow_pulling_2&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>overrides</code> 配置项中，可以看到许多组类似这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pulling&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/bow_pulling_0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>的组，这好理解，<code>predicate</code> 项就是编程语言中的 IF（如果判断），在其中的是<strong>条件对</strong>，如果满足了条件对，那么模型和材质会采用同组中的 <code>model</code> 项对应的材质。</p><p>按照这个原理，我们可以设计一种 “根据堆叠数量变色” 的特殊 item。这种 item 的类的定义和普通 item 一样，但<strong>注册</strong>有所差别：<strong>需要向 <code>MOD</code> 总线中添加 <code>propertyOverrideRegistry</code> 的特殊事件</strong>，用来初始化并在游戏中监听物品变化，及时覆盖材质。</p><p>假设我们注册好的对象叫：<code>RegisterObject&lt;Item&gt; magicIngot</code>，那么需要写这么个类来作为属性覆盖的事件处理器：</p><blockquote><p><strong>这是我们第一次向总线中加入事件，不知道含义的可以回到 0.10 事件系统 这节复习一下</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mod</span>.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD, value = Dist.CLIENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyRegistry</span> &#123;</span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">propertyOverrideRegistry</span><span class="params">(FMLClientSetupEvent event)</span> &#123;</span><br><span class="line">        event.enqueueWork(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                ItemModelProperties.registerProperty(</span><br><span class="line">                    ItemRegistry.magicIngot.get(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ResourceLocation</span>(Utils.MOD_ID, <span class="string">&quot;size&quot;</span>),</span><br><span class="line">                    (itemStack, clientWorld, livingEntity) -&gt; itemStack.getCount()</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 <code>@Mod</code> 和 <code>@SubscribeEvent</code> 就是经典的静态的事件注册方法，在 0.10 中介绍过；</p><p>那么在接收 <code>FMLClientSetupEvent</code> 事件中，方法 <code>propertyOverrideRegistry</code> 做了什么？</p><p>首先了解 <code>FMLClientSetupEvent</code> 是在 Java FML（Forge Model Loader）加载时必然触发的事件，所以这里的意思是<strong>在 Java FML 加载的时候运行 <code>PropertyRegistry#propertyOverrideRegistry</code> 这个方法</strong>，方法体就一行 <code>event.enqueueWork(Supplier&lt;?&gt;)</code>，这个可以理解为运行里面的 <code>enqueueWork</code> 的 supplier，我们唯一要做的就是把 overrides 这个 item 的情况注册一下。看看注册 item overrides 的函数声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ItemModelsProperties.registerProperty(</span><br><span class="line">    RegisterObject&lt;Item&gt;registered_item,</span><br><span class="line">    ResourceLocation        resourceLocation,</span><br><span class="line">    Supplier&lt;?&gt;                supplier<span class="comment">// ? 为 游戏中想要监测的属性类型</span></span><br><span class="line">);                                        <span class="comment">// supplier 就是调用获取数据的匿名函数</span></span><br></pre></td></tr></table></figure><p>注意，从上面的实例代码可以看出，这里的 <code>ResourceLocation</code> 的作用就是将获取的数据绑定到指定的资源名称，方便在接下来的 JSON 文件中使用并 <code>overrides</code>；它的初始化函数第二参数是资源名称，<strong>必须要记住</strong>，它和外面的 JSON 文件 <code>predicate</code> 条件中的键的名称要一致（如果用到的话）；</p><p>上面示例中的 <code>itemStack.getCount()</code> 就是获取 itemStack 的堆叠数量。</p><p>最后来看补充的模型文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/generated&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;textures&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;layer0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/iron_ingot&quot;</span>        <span class="comment">// 这里投机取巧，普通模式就用了铁锭的材质</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span>                                    <span class="comment">// 下面是 overrides 添加的部分</span></span><br><span class="line">    <span class="attr">&quot;overrides&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;&lt;modid&gt;:size&quot;</span><span class="punctuation">:</span>    <span class="number">16</span><span class="comment">// 这里注意，&lt;modid&gt; 替换为自己的 modid</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span>                            <span class="comment">// size 就是要求记住的、之前注册的名称</span></span><br><span class="line">            <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/gold_ingot&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>最后放上相应的 texture 试运行一下，应该能见到预期的效果。</p><h2 id="Chapter-EX-1-Localization-amp-Language"><a href="#Chapter-EX-1-Localization-amp-Language" class="headerlink" title="Chapter EX-1. Localization &amp; Language"></a>Chapter EX-1. Localization &amp; Language</h2><p>这一章不是必要的，主要讲述如何给之前的物品添加名称，并且提供语言支持。前面的章节创建的 item 名称都是内部的类名，开发者也许懂，但使用者可能会不理解。</p><p>这是 minecraft 为了提升可维护性，方便本地化，默认是没有物体名称，item 只有自己的<strong>编号（<code>transitionKey</code>）</strong>，也就是之前看到的和类名/包名/属性名很像的 <code>XXX.XXX.XXX</code>；</p><p>实际命名和语言的本地化则需要开发者自己完成，有两者方法，第一种比较简单，用 JSON 文件组成<strong>从前面的编号到名字的映射工作</strong>；第二种是使用 <code>I18n.format</code> 的方法，以后用到再提。</p><p>前者使用比较容易，首先找到前面说的 item 的编号（在 <code>Item</code> 类内部，大家可以自己到源码中找一找）；下一步，是创建一个 <code>lang</code> 目录，位置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resources/</span><br><span class="line">├── META-INF/</span><br><span class="line">│   └── mods.toml</span><br><span class="line">├── assets/</span><br><span class="line">│   ├── mymod/        # 你的 modid，之前材质存放的地方（作用域为 mymod:/）</span><br><span class="line">│   |   ├── models/</span><br><span class="line">│   |   ├── textures/</span><br><span class="line">|    |└── lang/# 这里是新建的 lang 目录</span><br><span class="line">|    |</span><br><span class="line">|    └── minecraft/</span><br><span class="line">|            </span><br><span class="line">└── pack.mcmeta</span><br></pre></td></tr></table></figure><p>在 <code>lang/</code> 中写一个简体中文的 JSON map，举个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: zh_cn.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;item.XXX.obsidian_ingot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑曜石锭&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;item.XXX.obsidian_apple&quot;</span><span class="punctuation">:</span><span class="string">&quot;黑曜石苹果&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;item.XXX.obsidian_sword&quot;</span><span class="punctuation">:</span><span class="string">&quot;黑曜石剑&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;itemGroup.obsidian_group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑曜石物品栏&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>键是之前说的 item 编号，后面是名字/翻译内容；</p><p>当然如果想让自己的 mod 国际化，还可以写 <code>zh_tw.json</code>、<code>en_us.json</code>，具体还有哪些语言可用，可以参阅 <a href="https://minecraft-zh.gamepedia.com/index.php?title=%E8%AF%AD%E8%A8%80&variant=zh#%E5%8F%AF%E7%94%A8%E8%AF%AD%E8%A8%80">wiki</a>；</p><p>To be continued……</p><p>—-EOF—-</p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Minecraft </tag>
            
            <tag> Forge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从C++入门Qt（三）</title>
      <link href="//technical/qt-for-beginners-3/"/>
      <url>//technical/qt-for-beginners-3/</url>
      
        <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: C++ GUI Programming with Qt 4 (2nd Edition) </i></p><p><i>注意：本文章将讲解 <strong>Qt 5</strong> 入门知识，需要一定的 C++ 基础</i></p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p><strong>观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~</strong></p><hr><span id="more"></span><p>前面 4 章节的内容都是从具体项目来学习 Qt 的方法，也已经让我们初步认识了 Qt 的使用方法，下面的内容将按类分块来介绍，文章的篇幅也会短一些。</p><h1 id="Chapter-5-Qt-常用事件"><a href="#Chapter-5-Qt-常用事件" class="headerlink" title="Chapter 5. Qt 常用事件"></a>Chapter 5. Qt 常用事件</h1><p>Qt 中常用的 <code>Event</code> 主要有：<strong>鼠标事件</strong>、<strong>键盘事件</strong>、<strong>内部事件</strong>。其中内部事件绝大多数都交给 <strong>信号-槽</strong> 来处理，少部分的内部事件在特定情况需要重写，例如 <code>QPaintEvent</code>（下一章说）、 <code>QCloseEvent</code> 关闭事件（实现关闭前确认）。前两个事件是输入事件，都继承于 <code>QInputEvent</code>。</p><h2 id="5-1-内部事件"><a href="#5-1-内部事件" class="headerlink" title="5.1 内部事件"></a>5.1 内部事件</h2><p>前面介绍过，对于内部事件（特指关闭事件），<code>QCloseEvent</code> 的使用方法也很简单，重写 <code>void QWidget::closeEvent(QCloseEvent* event)</code> 即可，如果调用了 <strong><code>event-&gt;accept()</code></strong>，表示控件接受关闭事件，正式关闭；而如果调用了 <strong><code>event-&gt;ignore()</code></strong>，则控件忽略关闭事件。</p><h2 id="5-2-鼠标事件"><a href="#5-2-鼠标事件" class="headerlink" title="5.2 鼠标事件"></a>5.2 鼠标事件</h2><blockquote><p>注意：鼠标滚轮另外归于 <code>QWheelEvent</code> 类。在最后会一笔带过。</p></blockquote><h3 id="5-2-1-简单介绍"><a href="#5-2-1-简单介绍" class="headerlink" title="5.2.1 简单介绍"></a>5.2.1 简单介绍</h3><p>Qt 的鼠标事件交由 <code>QMouseEvent</code> 处理，分为鼠标移动、左键 / 右键的单击、双击、释放。具体为何能够实现，归因于 <code>QWidget</code> 的信号-槽，它们会在鼠标在该控件区域发生特点行为时发出信号，进而传递 <code>QMouseEvent</code> 对象。</p><p>有一个重要的点需要阐释：鼠标<strong>移动事件</strong>只会在<strong>按下鼠标按键</strong>的情况下才会发生！除非通过<strong>显式调用 <code>QWidget::setMouseTracking()</code></strong>函数来开启鼠标轨迹，这种情况下只要鼠标指针在移动，就会产生一系列的鼠标移动事件。</p><h3 id="5-2-2-QMouseEvent-的传递方式"><a href="#5-2-2-QMouseEvent-的传递方式" class="headerlink" title="5.2.2 QMouseEvent 的传递方式"></a>5.2.2 <code>QMouseEvent</code> 的传递方式</h3><p>一个鼠标事件包含一些指定的接受标志 <code>flag</code> 用于指出该事件是否会被接收和处理 ，如果鼠标指针所在的父控件不接收该事件则可以调用函数 <code>QMouseEvent::ignore()</code> 予以忽略；</p><p>多个重叠的控件好比一个倒立的树，鼠标事件会沿着鼠标指针所在的父控件向上传递，直到某个控件调用 <code>QMouseEvent::accept()</code> 函数进行事件处理，否则该事件将被过滤销毁掉；</p><p>此外，<code>QWidget</code> 中的属性 <code>Qt::WA_NoMousePropagation</code> 能够改变这种传递行为。如果设置为 <code>true</code>，那么鼠标信号不会再向父控件传递。</p><h3 id="5-2-3-QMouseEvent-的使用"><a href="#5-2-3-QMouseEvent-的使用" class="headerlink" title="5.2.3 QMouseEvent 的使用"></a>5.2.3 <code>QMouseEvent</code> 的使用</h3><p>需要引入 <code>QMouseEvent</code> 类的头文件。通常通过重写下面的函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::mouseDoubleClickEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br></pre></td></tr></table></figure><p>具体 <code>QMouseEvent</code> 有如下获取位置实例方法（成员函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">QMouseEvent::pos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QMouseEvent::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QMouseEvent::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QPoint <span class="title">QMouseEvent::globalPos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QMouseEvent::globalX</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QMouseEvent::globalY</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>注：<code>QPoint</code> 类的方法也有 <code>QPoint::x()</code> 和 <code>QPoint::y()</code>，代表点对象在当前画布的位置。</p><p>如果鼠标事件还涉及处理移动窗口的坐标计算（pos 在窗口外），那么为了防止抖动可以使用 <code>QMouseEvent::globalPos()</code> 获取屏幕全局坐标。</p><p>还需要注意的问题，就是鼠标指针位置类 <code>QCursor</code> 的方法 <code>pos()</code> 和 这里鼠标事件 <code>globalPos()</code> 不一样，需要使用 <code>QWidget::mapToGlobal(pos())</code> 在窗口坐标和全局坐标间转换；</p><hr><p>鼠标事件除了记录位置，还记录了鼠标击键的方法，可以调用下面这些函数判断：</p><p>注意，<code>Qt::MouseButton</code> 是枚举类型，其取值都以十六进制存储，<strong>可以进行按位或的方法来多选</strong>。常见的值有：<code>Qt::NoButton</code>、<code>Qt::AllButtons</code>、<code>Qt::LeftButton</code>、<code>Qt::RightButton</code>、<code>Qt::MiddleButton</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是鼠标移动事件，那么此函数始终返回 Qt::NoButton</span></span><br><span class="line"><span class="function">Qt::MouseButton <span class="title">QMouseEvent::button</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和上面一个可以相互替代，不过这个函数更准，返回同时将触发的按键值**按位或**起来</span></span><br><span class="line"><span class="function">Qt::MouseButton <span class="title">QMouseEvent::buttons</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>正因为 <code>buttons()</code> 的结果是按位或起来，所以判断自然不是 <code>==</code>，而是<strong>按位与</strong>判断有没有特定的按键。</p><p>注：在 <code>QWidget::mouseDoubleClick()</code> 中，因为双击是同一按键，所以也能用 <code>QMouseEvent::button()</code> 来判断按键的。</p><h3 id="5-2-4-鼠标滚轮"><a href="#5-2-4-鼠标滚轮" class="headerlink" title="5.2.4 鼠标滚轮"></a>5.2.4 鼠标滚轮</h3><p>简单介绍 <code>QWheelEvent</code> 类，用的比较多的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QWheelEvent::delta</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>如果返回值大于 0，说明滚轮向下（远离使用者）；反之向上（接近使用者）。</p><h2 id="5-3-键盘事件"><a href="#5-3-键盘事件" class="headerlink" title="5.3 键盘事件"></a>5.3 键盘事件</h2><p>键盘事件交由 <code>QKeyEvent</code> 来处理。传递方式和鼠标事件几乎相同。在使用方面，键盘事件比鼠标简单，不存在移动、右击、双击的事件，就处理按下和释放两个事件，可以重写的函数有两个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::keyPressEvent</span><span class="params">(QKeyEvent* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::keyReleaseEvent</span><span class="params">(QKeyEvent* event)</span></span>;</span><br></pre></td></tr></table></figure><p>具体 <code>QKeyEvent</code> 有如下的实例方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Qt::Key <span class="title">QKeyEvent::key</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">Qt::KeyboardModifiers <span class="title">QKeyEvent::modifiers</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QKeyEvent::isAutoRepeat</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QKeyEvent::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>这里解释一下 <code>isAutoRepeat()</code>。众所周知，<strong>长按键盘的某个键，就相当于快速重复触发这个键（平时在编辑文本中应该感受到了）</strong>。而在 Qt 的键盘事件中，在控件中按一次键就<strong>各触发一次 <code>QKeyEvent</code> 按下和释放事件</strong>，长按也会快速触发 <code>QKeyEvent</code>，但有种方法能够辨别长按的行为——<code>isAutoRepeat()</code>，只有长按键盘的事件第一次会返回 <code>false</code>，快速触发的接下来所有事件都返回 <code>true</code>，直至物理上松开按键。利用这个函数，可以设计出 “不处理长按事件” 的逻辑（需要在按下和释放的处理函数中都写一下）。</p><p>其次，<code>Qt::Key</code> 也是枚举类型，其取值都以十六进制存储，值的格式为 <code>Qt::Key_&lt;keyName&gt;</code>：</p><p><code>Qt::Key_Escape</code>（Esc）、<code>Qt::Key_Tab</code>、<code>Qt::Key_Backspace</code>、<code>Qt::Key_Enter</code>、<code>Qt::Key_Insert</code>、<code>Qt::Key_Delete</code>、<code>Qt::Key_Pause</code>（对于键盘的 <code>Pause/Break</code>，和多媒体的 “暂停” 丝毫没有关系）、<code>Qt::Key_Print</code>、<code>Qt::Key_Home</code>、<code>Qt::Key_End</code>、<code>Qt::Key_[Left/Right/Up/Down]</code>、<code>Qt::Key_PageUp</code>、<code>Qt::Key_PageDown</code>、<code>Qt::Key_Shift</code>、<code>Qt::Key_Control</code>（MacOS 中的 <code>command</code> 键）、<code>Qt::Key_Alt</code>、<code>Qt::Key_Meta</code>（MacOS 中的 <code>Ctrl</code>，Windows 中的徽标键）、<code>Qt::Key_CapsLock</code>、<code>Qt::Key_NumLock</code>、<code>Qt::Key_ScrollLock</code>、<code>Qt::Key_[F1~35]</code>、<code>Qt::Key_Space</code>、<code>Qt::Key_[0-9]</code>、<code>Qt::Key_[A-Z]</code>……</p><p>多个键同时按下时，还可以使用 <code>count()</code> 返回本次 <code>QKeyEvent</code> 事件按键数量。</p><p>如果多个键按下时，伴随的是<strong>修饰键</strong>（例如 <code>shift</code>、<code>ctrl</code>、<code>alt</code> 等），可以用 <code>modifiers()</code> 查到。</p><p>修饰键有单独的枚举类型 <code>Qt::KeyboradModifiers</code>，值有：</p><p><code>Qt::NoModifier</code>、<code>Qt::ShiftModifier</code>、<code>Qt::ControlModifier</code>、<code>Qt::AltModifier</code>、<code>Qt::MetaModifier</code>……</p><p>举个例子，<strong>想要查到 <code>ctrl+M</code> 事件</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestWidget::keyPressEvent</span><span class="params">(QKeyEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">modifiers</span>() == Qt::ControlModifiers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">key</span>() == Qt::Key_M) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> QWidget::<span class="built_in">keyPressEvent</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后强调一个事，Qt 的键盘事件一次仅能捕捉一个按键 ！！！例如看似我“同时”按下 A 和 S 这两个键，实际上会先触发 <code>Qt::Key_A</code>/<code>Qt::Key_S</code> 中的一个，再触发另一个</strong>。</p><p>这对于想要判断<strong>非修饰键的组合键</strong>的同学来说可能有些麻烦——因为这需要设置一个容器，或者十六进制码进行存储，按下键存进去，松开键删除掉，然后统一判断这个存储的信息。</p><h1 id="Chapter-6-Qt-图形绘制"><a href="#Chapter-6-Qt-图形绘制" class="headerlink" title="Chapter 6. Qt 图形绘制"></a>Chapter 6. Qt 图形绘制</h1><p>Qt 所制作的几乎所有 GUI 上的按钮、编辑框等组件都是通过绘图得到的。Qt 的二维绘图基本功能是使用 <code>QPainter</code> 在绘图设备（包括 <code>QWidget</code>、<code>QPixmap</code> 等）上绘图，通过绘制一些基本的点、线、圆等基本形状组成需要的图形，得到的图形不可交互。</p><p>除了 <code>QPainter</code>，Qt 还提供 Graphics View 架构，使用 <code>QGraphicsView</code>、<code>QGraphicsScene</code>、<code>QGraphicsItem</code> 类来制作更多样复杂的、可交互的图形。</p><h2 id="6-1-QPainter-基本绘图"><a href="#6-1-QPainter-基本绘图" class="headerlink" title="6.1 QPainter 基本绘图"></a>6.1 <code>QPainter</code> 基本绘图</h2><h3 id="6-1-1-绘图区"><a href="#6-1-1-绘图区" class="headerlink" title="6.1.1 绘图区"></a>6.1.1 绘图区</h3><p>Qt 基本绘图系统基于 <code>QPainter</code>（绘图操作使用）、<code>QPaintDevice</code>（可以使用 <code>QPainter</code> 的抽象二维界面）、<code>QPaintEngine</code>（为 <code>QPainter</code> 提供各种设备上绘制的接口）类。</p><p>一般情况下不需要关注底层 <code>QPaintEngine</code>，除非想自定义一个可以绘制的设备类型。</p><p>常见的绘图设备有 <code>QWidget</code>、<code>QPixmap</code>、<code>QImage</code>，为 <code>QPainter</code> 提供了 “canvas”。</p><p>下面先以 <code>QWdiget</code> 这个绘图设备为例。</p><p>想在 <code>QWidget</code> 这一绘图设备上绘图很简单，重写以下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::paintEvent</span><span class="params">(QPaintEvent* event)</span></span>;</span><br></pre></td></tr></table></figure><p>这也是上一章提到的 “内部事件” 之一。利用 <code>QPaintEvent</code> 事件，在函数中创建 <code>QPaint</code> 对象，就可以在控件画布上绘图了。</p><p>当然，重写也是有讲究的，需要使用<strong>专用的宏 <code>Q_DECL_OVERRIDE</code></strong> 来声明这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestWidget::paintEvent</span><span class="params">(QPaintEvent* event)</span> Q_DECL_OVERRIDE</span>;</span><br></pre></td></tr></table></figure><p>再介绍一下绘图坐标系中的<strong>视口（viewport）坐标</strong>：<code>QWidget</code> 的左上角就是（0，0），向右是 x 轴正方向，向下是 y 轴正方向；绘图区宽度和高度分别由控件宽度、高度决定：<code>QWidget::width()</code>、<code>QWidget::height()</code>。</p><p>除了视口坐标，还有逻辑坐标和窗口坐标，以后介绍。</p><h3 id="6-1-2-绘图属性"><a href="#6-1-2-绘图属性" class="headerlink" title="6.1.2 绘图属性"></a>6.1.2 绘图属性</h3><p><code>QPainter</code> 具有 3 各重要属性：</p><ul><li><code>QPainter::pen</code>，是一个 <code>QPen</code> 对象，用于控制<strong>线条颜色、宽度、线型</strong>；</li><li><code>QPainter::brush</code>，是一个 <code>QBrush</code> 对象，用于设置一个区域的填充特性，可以设置<strong>填充颜色、填充方式、渐变特性</strong>，也可以指定图片做材质填充；</li><li><code>QPainter::font</code>，是一个 <code>QFont</code> 对象，用于绘制文字时设置<strong>文字样式、大小</strong>；</li></ul><p>下面以一个实例来介绍。假设 <code>TestWidget</code> 类是一个继承于 <code>QWidget</code>、已设计的一个类，只需要在其上绘制图案就完成任务，那么函数这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestWidget::paintEvent</span><span class="params">(QPaintEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个 QPainter 对象，与 TesWidget 对象关联、</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::TextAntialiasing);</span><br><span class="line">    <span class="type">int</span> W = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>();    <span class="comment">// 记录绘图区宽度和高度</span></span><br><span class="line">    <span class="type">int</span> H = <span class="keyword">this</span>-&gt;<span class="built_in">height</span>();</span><br><span class="line">    <span class="comment">// QRect 类是个二维图形类，初始化一个长方形，后文会详细介绍</span></span><br><span class="line">    <span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个指定的画笔</span></span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.<span class="built_in">setWidth</span>(<span class="number">3</span>);    <span class="comment">// 笔的线宽</span></span><br><span class="line">    pen.<span class="built_in">setColor</span>(Qt::red);    <span class="comment">// 笔的颜色</span></span><br><span class="line">    pen.<span class="built_in">setStyle</span>(Qt::SolidLine);    <span class="comment">// 笔画的线的样式（这里是实线）</span></span><br><span class="line">    pen.<span class="built_in">setCapStyle</span>(Qt::FlatCap);    <span class="comment">// 笔画的线的端点样式</span></span><br><span class="line">    pen.<span class="built_in">setJoinStyle</span>(Qt::BevelJoin);    <span class="comment">// 笔画的线的连接点样式</span></span><br><span class="line">    <span class="comment">// 笔设置完后，给  QPainter 装上指定的笔：</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个画刷</span></span><br><span class="line">    QBrush brush;</span><br><span class="line">    brush.<span class="built_in">setColor</span>(Qt::Yellow);    <span class="comment">// 画刷填充的颜色</span></span><br><span class="line">    brush.<span class="built_in">setStyle</span>(Qt::SolidPattern);    <span class="comment">// 画刷填充的样式（这里是实心）</span></span><br><span class="line">    <span class="comment">// 画刷设置完后，给 QPainter 装上指定画刷：</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘图</span></span><br><span class="line">    painter.<span class="built_in">drawRect</span>(rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序先从 <code>QPainter</code> 说起，<code>QPainter::setRenderHint(QPainter::Antialiasing)</code> 表示绘制图形抗锯齿（默认关闭），<code>QPainter::setRenderingHint(QPainter::Textantialiasing)</code></p><p>然后是 <code>QPen</code>，以上已经展示了大多数情况下会用到的方法：<strong>如何设置线宽、颜色、线的样式、端点样式和连接点样式</strong>。</p><p>其中，线的样式有枚举量 <code>Qt::PenStyle</code>，常用的值有 <code>Qt::SolidLine</code>（实线）、<code>Qt::DashLine</code>（虚线）、<code>Qt::DotLine</code>（点状线）、<code>Qt::DashDotLine</code>（点划线）、还有自定义样式 <code>Qt::CustomDashLine</code>，要结合 <code>setDashOffset()</code> 和 <code>setDashPattern()</code> 使用。</p><p>线端点的样式有枚举量 <code>Qt::PenCapStyle</code>，常用的值有 <code>Qt::Square</code>（方形端点）、<code>Qt::FlatCap</code>（平端点）、<code>Qt::RoundCap</code>（圆润端点）。</p><p>线条连接样式有枚举量 <code>Qt::PenJoinStyle</code>，常用的值有 <code>Qt::BevelJoin</code>、<code>Qt::MiterJoin</code>、<code>Qt::RoundJoin</code>；</p><p>然后是 <code>QBrush</code>，主要常用的方法就 4 个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QBrush::setColor</span><span class="params">(<span class="type">const</span> QColor&amp; color)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QBrush::setStyle</span><span class="params">(Qt::BrushStyle style)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QBrush::setTexture</span><span class="params">(<span class="type">const</span> QPixmap&amp; pixmap)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QBrush::setTextureImage</span><span class="params">(<span class="type">const</span> QImage&amp; image)</span></span>;</span><br></pre></td></tr></table></figure><p><code>QColor</code> 和之前见到过的一样，可以用枚举类型，也可以手动创建对象。</p><p>先介绍 <code>Qt::BrushStyle</code> 枚举类型，它定义的是填充样式，常用的值有：<code>Qt::NoBrush</code>（不填充）、<code>Qt::SolidBrush</code>（单一颜色填充）、<code>Qt::HorPattern</code>（水平线填充）、<code>Qt::VerPattern</code>（垂直线填充）、<code>Qt::TexturePattern</code>（材质填充，<strong>需要指定 texture 或 texture image</strong>）、<code>Qt::LinearGradientPattern</code>（线性渐变，需要使用 <code>QLinearGradient</code> 类作为 brush）、<code>Qt::RadialGradientPattern</code>（辐射渐变，需要使用 <code>QRadialGradient</code> 类作为 brush）、<code>Qt::ConicalGradientPattern</code>（圆锥渐变，需要使用 <code>QConicalGradient</code> 类作为 brush）；</p><p>渐变的使用暂时不介绍了，用到再上网查。</p><h4 id="补充：QPixmap-和-QImage"><a href="#补充：QPixmap-和-QImage" class="headerlink" title="补充：QPixmap 和 QImage"></a>补充：QPixmap 和 QImage</h4><p>下面分析一下 <code>QPixmap</code> 和 <code>QImage</code> 类<strong>本身的</strong>使用方法。</p><p>它们的构造函数比较简单，可以是含有图片的 uri 字符串，也可以是 <code>QUrl</code>，构造后即可将图片像素信息读入对象中。</p><p>两者有一些差别，<code>QPixmap</code> 主要是用于绘图，<strong>针对屏幕显示而最佳化设计</strong>（适合小图片的呈现），<code>QImage</code> 主要是为图像I/O、图片访问和<strong>像素修改</strong>而设计的类（适合大图片的编辑）。</p><p>这些差别可以从常用的方法上看出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QImage 类允许从空构造, QImage::QImageFormat 枚举类型含有多种图片格式</span></span><br><span class="line">QImage::<span class="built_in">QImage</span>(<span class="type">int</span> x, <span class="type">int</span> y, QImage::QImageFormat f);</span><br><span class="line">QImage::<span class="built_in">QImage</span>(<span class="type">const</span> QString&amp; picture);</span><br><span class="line"><span class="comment">// 方法允许直接修改像素点</span></span><br><span class="line"><span class="comment">// 注：QRgb 构造函数参数就是 R、G、B 值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QImage::setPixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> QRgb&amp; rgb)</span></span>;</span><br><span class="line"><span class="comment">// 其他非常多方法，等到用到再介绍</span></span><br></pre></td></tr></table></figure><p>二者相互转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">QPixmap::fromImage</span><span class="params">(<span class="type">const</span> QImage&amp; image)</span></span>;</span><br><span class="line"><span class="function">QImage <span class="title">QPixmap::toImage</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="补充：基本图形元件"><a href="#补充：基本图形元件" class="headerlink" title="补充：基本图形元件"></a>补充：基本图形元件</h4><p>最后，介绍上面的示例中的最后一行 <code>painter.drawRect(rect);</code>，这说明 <code>QPainter</code> 底层能够直接绘制出基本的几何图形，这称为 <strong><code>QPainter</code> 绘制的基本图形元件</strong>。下面介绍一些 <code>QPainter</code> 类中常用的图形元件：</p><ul><li><p>绘制一个点 和 一组点：<code>QPainter::drawPoint(const QPoint&amp; p);</code> 和 <code>QPainter::drawPoints(const QPoint[] points, int size);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">drawPoint</span>(<span class="built_in">QPoint</span>(W/<span class="number">2</span>, H/<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 一组点 --------------------------</span></span><br><span class="line">QPoint points[] = &#123;</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">5</span>*W/<span class="number">12</span>, H/<span class="number">4</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">3</span>*W/<span class="number">4</span>, <span class="number">5</span>*H/<span class="number">12</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">2</span>*W/<span class="number">4</span>, <span class="number">5</span>*H/<span class="number">12</span>)</span><br><span class="line">&#125;;</span><br><span class="line">painter.<span class="built_in">drawPoints</span>(points, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>这里的 <code>QPoint</code> 类之前在鼠标事件中就遇到过，构造函数就是坐标系中的 x 和 y；</p></li><li><p>绘制弧线：<code>QPainter::drawArc(const QRect&amp; rect, int startAngle, int spanAngle);</code>（这里的 angle 是角度制）；示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">90</span> * <span class="number">16</span>;    <span class="comment">// 起始为坐标系中 90° 角，其中 0° 指向 x 轴正向</span></span><br><span class="line"><span class="type">int</span> span = <span class="number">90</span> * <span class="number">16</span>;        <span class="comment">// 旋转 90°</span></span><br><span class="line">painter.<span class="built_in">drawArc</span>(rect, start, span);</span><br></pre></td></tr></table></figure><p>聪明的小伙伴可能会问，为什么要乘以 16 呢？因为，出于绘图精细粒度和数据的保存考量，Qt 中大多数绘图角度使用整型（int），并且一个单位是 <strong>1 / 16</strong> 个角度（degree）。</p></li><li><p>绘制弦：<code>QPainter::drawChord(const QRect&amp; rect, int startAngle, int spanAngle);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">90</span> * <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> span = <span class="number">90</span> * <span class="number">16</span>;</span><br><span class="line">painter.<span class="built_in">drawChord</span>(rect, start, span);</span><br></pre></td></tr></table></figure></li><li><p>绘制矩形：<code>QPainter::drawRect(const QRect&amp; rect);</code> 上面的例子就是示例；</p></li><li><p><strong>擦除矩形</strong>：<code>QPainter::eraseRect(const QRect&amp; rect);</code> 示例显然。<strong>本质上是等效于用当前背景色填充该区域</strong>；</p></li><li><p>绘制圆角矩形：<code>QPainter::drawRoundedRect(const QRect&amp; rect);</code> 使用方法同矩形；</p></li><li><p>绘制扇形：<code>QPainter::drawPie(const QRect&amp; rect, int startAngle, int spanAngle);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">40</span> * <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> span = <span class="number">120</span> * <span class="number">16</span>;</span><br><span class="line">painter.<span class="built_in">drawPie</span>(rect, start, span);</span><br></pre></td></tr></table></figure></li><li><p>绘制凸多边形：<code>QPainter::drawConvexPolygon(const QPoint[] pArr, int size);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QPoint points[<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">5</span>*W/<span class="number">12</span>, H/<span class="number">4</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">3</span>*W/<span class="number">4</span>, <span class="number">5</span>*H/<span class="number">12</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">5</span>*W/<span class="number">12</span>, <span class="number">3</span>*H/<span class="number">4</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(W/<span class="number">4</span>, <span class="number">5</span>*H/<span class="number">12</span>)</span><br><span class="line">&#125;;</span><br><span class="line">painter.<span class="built_in">drawConvexPolygon</span>(points, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li><li><p>绘制闭合多边形（闭合折线）：<code>QPainter::drawPolygon(const QPoint[] points, int size);</code> 使用方法同 “绘制凸多边形”；</p></li><li><p>绘制不闭合折线：<code>QPainter::drawPolyline(const QPoint[] points, int size);</code> 使用方法同 “绘制凸多边形”；</p></li><li><p>绘制椭圆：<code>QPainter::drawEllipse(const QRect&amp; rect);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(rect);</span><br></pre></td></tr></table></figure><p>这里实际上是利用了椭圆的外接矩形唯一的特性，长轴长是矩形的长，宽也同理。</p></li><li><p>绘制<strong>图片</strong>：<code>QPainter::drawImage(const QRect&amp; rect, const QImage&amp; image);</code>  和 <code>QPainter::drawPixmap(const QRect&amp; rect, const QPixmap&amp; pixmap);</code>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">QImage <span class="title">image</span><span class="params">(<span class="string">&quot;:/imgs/qt.jpg&quot;</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawImage</span>(rect, image);</span><br><span class="line"><span class="comment">// 或者 Pixmap 图形 ----------------</span></span><br><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/imgs/qt.jpg&quot;</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawPixmap</span>(rect, pixmap);</span><br></pre></td></tr></table></figure></li><li><p>绘制线段：<code>QPainter::drawLine(const QLine&amp; line);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QLine <span class="title">line</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawLine</span>(line);</span><br></pre></td></tr></table></figure><p>这里的 <code>QLine</code> 类，和之前的 <code>QPoint</code>、<code>QRect</code> 一样，都是表示二维图形的类。它的构造函数可以是两个点的坐标，也可以是两个 <code>QPoint</code> 对象。</p></li><li><p>绘制线段组：<code>QPainter::drawLines(const QVector&lt;QLine&gt;&amp; lines);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">QVector&lt;QLine&gt; lines;</span><br><span class="line">lines.<span class="built_in">append</span>(<span class="built_in">QLine</span>(rect.<span class="built_in">topLeft</span>(), rect.<span class="built_in">bottomRight</span>()));</span><br><span class="line">lines.<span class="built_in">append</span>(<span class="built_in">QLine</span>(rect.<span class="built_in">topRight</span>(), rect.<span class="built_in">bottomLeft</span>()));</span><br><span class="line">lines.<span class="built_in">append</span>(<span class="built_in">QLine</span>(rect.<span class="built_in">topLeft</span>(), rect.<span class="built_in">bottomLeft</span>()));</span><br><span class="line">lines.<span class="built_in">append</span>(<span class="built_in">QLine</span>(rect.<span class="built_in">topRight</span>(), rect.<span class="built_in">bottomRight</span>()));</span><br><span class="line">painter.<span class="built_in">drawLines</span>(lines);</span><br></pre></td></tr></table></figure><p>这里用到了 <code>QRect</code> 类的调用顶点方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">QRect::topLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>绘制定制的路径：<code>QPainter::drawPath(const QPainterPath&amp; path);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">QPainterPath path;</span><br><span class="line">path.<span class="built_in">addEllipse</span>(rect);</span><br><span class="line">path.<span class="built_in">addRect</span>(rect);</span><br><span class="line">painter.<span class="built_in">drawPath</span>(path);</span><br></pre></td></tr></table></figure><p>这里的 <code>QPainterPath</code> <strong>不是</strong>基本图形元件，而是复合图形对象。它是由一系列绘图操作的<strong>顺序集合</strong>，很多方法和 <code>QPainter</code> 很接近，也有专用函数，例如 <code>lineTo(const QPoint&amp;)</code>（在当前起点到指定点间连一条线段） <code>closeSubPath()</code>、<code>connectPath()</code> 等，感兴趣查阅文档。</p></li><li><p>绘制文字：<code>QPainter::drawText(const QRect&amp; rect, const QString&amp; text);</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">QFont font;</span><br><span class="line">font.<span class="built_in">setPointSize</span>(<span class="number">30</span>);</span><br><span class="line">font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">painter.<span class="built_in">setFont</span>(font);    <span class="comment">// 这里用 painter 设置字体</span></span><br><span class="line">painter.<span class="built_in">drawText</span>(rect, <span class="string">&quot;Hello, Qt&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="QRect-和-QRectF"><a href="#QRect-和-QRectF" class="headerlink" title="QRect 和 QRectF"></a>QRect 和 QRectF</h4><p>我们在上面的例子中可以看到，几乎所有的绘画过程竟然都用到了 <code>QRect</code> 类。</p><p>看文档的同学可能会问，诶，这个经常看到 <code>QRect</code> 和 <code>QRectF</code> 类同时出现，它们有什么关系吗？实际上两者的目标是一样的，只不过是 “历史遗留问题”。</p><p>先出现的 <code>QRect</code> 的构造方法之一是<strong>左上、右下</strong>的点的坐标。这个构造是准确的，但是调用 <code>bottomRight()</code>、<code>bottonLeft()</code>、<code>topRight()</code> 返回的位置和实际位置<strong>相差 1 个单位</strong>。这是由于对于像素中心的划分方法导致的，只有 <code>topLeft()</code> 返回数据与实际数据相同，官方文档描述如下：</p><p><img src="QRect.png" height="750"></p><p>而后出现的 <code>QRectF</code>，修复了这个问题，所有方法都是准确的。所以，你既可以使用 <code>QRect</code>，但要记住这个 ± 1 的“陷阱”，也可以用 <code>QRectF</code>，这取决于自己，又或是项目的兼容性。</p><p>因为在 Qt 几乎所有的官方函数中，使用到 <code>QRect</code> 类的地方都用了 <code>QRectF</code> 重载了一下。留着 <code>QRect</code> 是为了向前兼容。</p><p>还有 <code>QPoint</code> 和 <code>QPointF</code> 等，想要中文版了解原因，强烈推荐这篇文章：<a href="https://www.cnblogs.com/lvdongjie/p/4816024.html">传送门🚪</a></p><h3 id="6-1-3-绘图坐标系-和-坐标变换"><a href="#6-1-3-绘图坐标系-和-坐标变换" class="headerlink" title="6.1.3 绘图坐标系 和 坐标变换"></a>6.1.3 绘图坐标系 和 坐标变换</h3><h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><p>在 6.1.1 中提到过，目前为止我们使用的都是<strong>视口坐标</strong>，这是 Qt 绘图的默认坐标系统，也被称为绘图设备的物理坐标。为了绘图方便，<code>QPainter</code> 还提供了变换绘图坐标的功能，例如<strong>平移、旋转</strong>等。这个时候，由于旋转涉及大量数学计算，所以使用<strong>逻辑坐标系统</strong>是最方便的。逻辑坐标会在接下来的讨论中逐步解释。</p><p>下面是 <code>QPainter</code> 关于坐标变换的相关方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::translate</span><span class="params">(qreal dx, qreal dy)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::rotate</span><span class="params">(qreal angle)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::scale</span><span class="params">(qreal sx, qreal sy)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::shear</span><span class="params">(qreal sh, qreal sv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::save</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::restore</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::resetTransform</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>先解释 <code>qreal</code>，它就是 Qt 用来存储实数的基础数据类型，和 <code>double</code> 类似的使用。</p><p><code>QPainter::translate()</code> 会<strong>将坐标系统的原点平移给定的偏移量</strong>；</p><p>⚠ 注意，这里平移的是坐标系统，<strong>不会改变已有图形的绝对位置，只会改变当前绘图的坐标、改变原有图形在当前坐标系统下的坐标</strong>。下面所有的功能也都是这样！！！</p><p><code>QPainter::rotate()</code> 会<strong>将坐标系统顺时针（+）旋转给定角度</strong>；</p><p>注：这个角度由于是 <code>qreal</code>，所以是 1° 的角度制。</p><p><code>QPainter::scale()</code> 会<strong>将坐标系统的 x、y 轴分别缩放指定倍数</strong>；</p><p>注：倍数大于 1 放大，小于 1 缩小。</p><p><code>QPainter::shear()</code> 会<strong>将坐标系统在水平、垂直方向做指定倍数的扭转变换</strong>；</p><p><code>QPainter::save()</code> <strong>保存 <code>painter</code> 当前的状态，并将其压入堆栈</strong>；</p><p><code>QPainter::restore()</code> <strong>从堆栈中弹出并恢复到上一个 <code>painter</code> 状态</strong>；</p><p><code>QPainter::resetTransform()</code> <strong>复位所有的坐标变换</strong>；</p><h4 id="绘图坐标系"><a href="#绘图坐标系" class="headerlink" title="绘图坐标系"></a>绘图坐标系</h4><p>现在解释之前的 “<strong>视口坐标系</strong>”、“<strong>窗口坐标系</strong>” 和 “<strong>逻辑坐标系</strong>”。</p><p>视口（viewport）表示绘图设备的<strong>任意</strong>一个矩形区域的物理坐标，默认情况下等于绘图设备的整个矩形区域（意味着可以更改）；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::setViewport</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure><p>窗口（window）和 视口 是同一个矩形，只不过<strong>窗口是用逻辑坐标定义的坐标系</strong>。</p><p>逻辑坐标可以理解为一种相对的坐标，不代表物理坐标，只是数学上的参照。</p><p>上面的解释非常抽象，以一个例子说明：</p><p><img src="viewport_and_window.png" height="150"></p><p>如上图，（a）的外围矩形框代表绘图设备的物理大小、坐标范围，假设宽 300px，高 200px。现在取中间的正方形阴影区域作为视口。因此视口的左上角在设备的物理坐标（50，0），右下角（250，200）；可以这么设置：<code>painter.setViewport(50, 0, 200, 200);</code>；<strong>而在设置指定视口后，逻辑坐标还没有确定，因为没有确定窗口</strong>。</p><p>对于给定的视口，<strong>可以在其上定义窗口</strong>，这里<strong>定义窗口就是在定义逻辑坐标系</strong>。为什么这么说？因为别忘了<strong>窗口和视口是同一个矩形</strong>，这时设置窗口坐标相当于指定窗口在逻辑坐标系中的位置，进而可以由 <code>QPainter</code> 底层计算出逻辑坐标的情况。</p><p>例如，这里我设置 <code>painter.setWindow(-50, -50, 100, 100);</code> 代表当前的窗口左上角在逻辑坐标的位置是（-50，-50），当前窗口的逻辑宽度、逻辑高度都是 100；<strong>注意：逻辑宽度、逻辑高度设置后，可能比例与物理宽高不一致，这取决于您给定的数字。这个例子中逻辑长度和物理长度是 1：1</strong>。由此建立的逻辑坐标系如图（b）所示。<strong>以后的坐标都按逻辑坐标系来给定</strong>。</p><p>为什么要大费周章引入这一系列坐标系？直接用视口坐标（物理坐标）不行吗？其实窗口坐标（逻辑坐标）有优点，就是只需按窗口坐标的定义来绘图，不用管实际物理坐标范围。<strong>例如在固定边长 100px（物理长度）的正方形窗口中绘图，当实际设备的大小变化（可能是用户拖动），绘制图形会自动变化实际大小来适应相对大小</strong>。</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>现在综合之前的知识做个练习：在画布上绘制一个正五角星，并在一旁绘制至少 2 个旋转了不同角度的正五角星。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请自行实现 Canvas 类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Canvas::paintEvent</span><span class="params">(QPaintEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.<span class="built_in">setWidth</span>(<span class="number">3</span>);</span><br><span class="line">    pen.<span class="built_in">setColor</span>(Qt::blue);</span><br><span class="line">    pen.<span class="built_in">setStyle</span>(Qt::SolidLine);</span><br><span class="line">    pen.<span class="built_in">setCapStyle</span>(Qt::RoundCap);</span><br><span class="line">    pen.<span class="built_in">setJoinStyle</span>(Qt::RoundJoin);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">    QBrush brush;</span><br><span class="line">    brush.<span class="built_in">setStyle</span>(Qt::NoBrush);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> H = <span class="keyword">this</span>-&gt;<span class="built_in">height</span>();</span><br><span class="line">    <span class="type">int</span> W = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>();</span><br><span class="line">    <span class="type">const</span> qreal PI = <span class="number">3.141592653</span>;</span><br><span class="line">    <span class="function">QRectF <span class="title">rect</span><span class="params">(-W/<span class="number">2</span>, -H/<span class="number">8</span>, W/<span class="number">2</span>, H/<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setViewport</span>(W/<span class="number">8</span>, H/<span class="number">8</span>, <span class="number">3</span>*W/<span class="number">4</span>, <span class="number">3</span>*H/<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 数学好的同学这里一眼就看出来，逻辑长度:物理长度 = 3:4</span></span><br><span class="line">    painter.<span class="built_in">setWindow</span>(<span class="number">0</span>, -H/<span class="number">2</span>, W, H);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> qreal m = <span class="built_in">qMin</span>(H, W);</span><br><span class="line">    </span><br><span class="line">    <span class="function">QPoint <span class="title">center_1</span><span class="params">(-m/<span class="number">2</span>+m/<span class="number">6</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">center_2</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">center_3</span><span class="params">(m/<span class="number">2</span>-m/<span class="number">6</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_1</span><span class="params">(<span class="number">0</span>, -m/<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_2</span><span class="params">(m/<span class="number">6</span>*std::cos(<span class="number">2</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>), m/<span class="number">6</span>*std::sin(<span class="number">2</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_3</span><span class="params">(m/<span class="number">6</span>*std::cos(<span class="number">4</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>), m/<span class="number">6</span>*std::sin(<span class="number">4</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_4</span><span class="params">(m/<span class="number">6</span>*std::cos(<span class="number">6</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>), m/<span class="number">6</span>*std::sin(<span class="number">6</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_5</span><span class="params">(m/<span class="number">6</span>*std::cos(<span class="number">8</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>), m/<span class="number">6</span>*std::sin(<span class="number">8</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    QPainterPath* path = <span class="keyword">new</span> <span class="built_in">QPainterPath</span>(p_1_1);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_3);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_5);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_2);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_4);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_1);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawPath</span>(*path);</span><br><span class="line">    painter.<span class="built_in">translate</span>(m/<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    painter.<span class="built_in">rotate</span>(<span class="number">30</span>);</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(*path);</span><br><span class="line">    painter.<span class="built_in">translate</span>(m/<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    painter.<span class="built_in">rotate</span>(<span class="number">30</span>);</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(*path);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-2-QGraphicsView-进阶绘图"><a href="#6-2-QGraphicsView-进阶绘图" class="headerlink" title="6.2 QGraphicsView 进阶绘图"></a>6.2 <code>QGraphicsView</code> 进阶绘图</h2><p>在介绍 <code>QGraphicsView</code> 前，请大家回想在第 4 章使用的 <code>QTableWidget</code>（父类 <code>QTableView</code>），它是 <strong>model/view（模型/视图）结构</strong>。在 Qt 中，model/view 结构是 Qt 界面组件显示与编辑数据的一种结构，视图时显示和编辑数据的界面组件，而模型是视图与原始数据之间的接口。最典型的应用是在数据库软件中的表单渲染。</p><p>主要用到的视图组件有 <code>QListView</code>、<code>QTreeView</code>、<code>QTableView</code>  等，它们对应的 <code>XXXWidget</code> 则是一层包装，直接用项存储，而在更高级的用法中就需要 model/view 的结构了。看下面的关系图：</p><p><img src="model_view.png" height="275"></p><ul><li><p>数据（Data）：就是实际的数据，例如数据库的一个表、SQL 查询结果、内存里的一个数组、磁盘文件结构等等；</p></li><li><p>视图或视图组件（View）：是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引（model index），然后依此获得数据并显示。Qt 中的例子如下，大家根据需要，用到再查询文档使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QListView: 用于显示单列的列表数据，适用于一维数据的展示和操作</span><br><span class="line">QTreeView: 用于显示树状结构数据</span><br><span class="line">QTableView: 用于显示表格状数据，适用于二维表格型数据的展示和操作</span><br><span class="line">QColumnView: 用于多个 QListView 显示树状层次，每层用一个 QListView 表示</span><br><span class="line">QHeaderView: 提供表头或列表头的视图组件，例如 QTableView 的行表头和列表头</span><br></pre></td></tr></table></figure><p><strong>这些视图组件一般调用 <code>setModel()</code>  来设置模型或数据模型的种类</strong>。</p></li><li><p>模型或数据模型（Model）：与实际数据通信，并且为视图组件提供数据接口。主要是从原始数据提取内容，并提示视图组件进行显示、编辑。Qt 中的例子如下，大家根据需要，用到再查询文档使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QStringListModel: 用于处理字符串列表的数据模型类</span><br><span class="line">QStandardItemModel: 标准的基于项数据的数据模型类，每个项数据可以是任何数据类型</span><br><span class="line">QFileSytemModel: 计算机上文件系统的数据模型类</span><br><span class="line">QSortFilterProxyModel: 与其他数据类型结合，提供排序、过滤等功能的数据模型类</span><br><span class="line"></span><br><span class="line">QSqlQueryModel: 用于数据库 SQL 查询结果的数据模型类</span><br><span class="line">QSqlTableModel: 用于数据库的一个数据表的数据模型类</span><br><span class="line">QSqlRelationalTableModel: 用于关系型数据库的数据模型类</span><br><span class="line"></span><br><span class="line">// 如果上面的类不能满足要求，还可以自己从 QAbstractItemModel、QAbstractListModel、QAbstractTableModel 等类自行定制</span><br></pre></td></tr></table></figure></li><li><p>代理（Delegate）：这可以让用户定制数据的显示和编辑方式。默认情况下代理显示一个数据，当数据被编辑时，代理通过 model index 和数据模型通信（一般会提供编辑器，默认 <code>QLineEdit</code>）；</p><p>通俗地解释一下，第 4 章中，我们使用 <code>QTableWidget</code> 来创建表格区域时，双击修改表格会弹出一个 <code>QLineEdit</code>，输入回车后消失，它就是代理。当然，除了 <code>QLineEdit</code>，对于特定场景，例如只允许输入整型，那么 <code>QSpinBox</code> 合适，如果要从列表中选择数据填入，那么 <code>QComboBox</code> 合适。<strong>这时，可以从 <code>QStyledItemDelegate</code> 来继承创建一个自定义代理类</strong>。</p></li><li><p>View、Model、Delegate 三者间通过信号-槽通信：源数据改变时，model 向 view 发射信号；用户在 view 中操作数据时，view 向 model 发射信号；用户借助代理编辑数据时，delegate 向 model 和 view 发射信号。</p></li><li><p>Model/View 结构有一些约定的实现需要了解。</p><ul><li>数据<strong>形式上</strong>还是以项的形式存在；这意味着第 4 章中对于 “<code>QTableWidgetItem</code> 设计” 的探讨，这里对于所有的 <code>QStandardItem</code> 都是一样的，都有 “role” 的说法；</li><li>为了保证数据表示 和 数据存取方式的隔离，数据模型中引入了<strong>模型索引（model index）</strong>的概念。通过数据模型存取的每一个数据都有一个模型索引，视图组件 view 和代理 delegate 都通过调用 model 的模型索引来定位、获取数据；</li><li>模型索引有个专门的类来表示：<code>QModelIndex</code>，它提供数据存取的<strong>临时指针</strong>（数据模型内部组织数据的结构随时可能改变）。如果想要持久性的索引，可能需要 <code>QPersistentModelIndex</code> 类，但会牺牲部分的性能和空间；</li><li>由模型索引确定数据，<strong>需要向 <code>QModelIndex</code> 传递 3 个参数：行号、列号、父项的模型索引</strong>。但请注意，这不代表底层的数据以二维数组存储，只是这么表示更方便，所以 <code>QModelIndex</code> 的接口就这么设计。行和列的编号好说，在 <code>List Model</code> 和 <code>Table Model</code> 中就是原本的意思，在 <code>Tree Model</code> 中行指深度优先的编号；父项索引也好说，在 <code>Tree Model</code> 中就是原本的意思，在 <code>List Model</code> 和 <code>Table Model</code> 中就是空对象（<code>QModelIndex()</code>）；</li></ul></li></ul><p>铺垫了这么多 model/view 结构的知识，接下来终于可以开始讨论 <code>QGraphicsView</code> 的使用了。</p><h3 id="6-2-1-场景、视图、图形项"><a href="#6-2-1-场景、视图、图形项" class="headerlink" title="6.2.1 场景、视图、图形项"></a>6.2.1 场景、视图、图形项</h3><p>前一节叙述的 <code>QPainter</code> 绘图只能实现一些简单的绘制事件。对于复杂度高、交互性强、图形间的逻辑关系复杂的情况，很可能就需要 Graphics View 绘图架构来完成。</p><p>这种架构是基于 Graphics/Item 的模型/视图模式，和 Model/View 模式类似。Graphics/Item 模式由 3 个部分组成：<strong>场景、视图、图形项</strong>。</p><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p> <code>QGraphicsScene</code> 类提供绘图场景（Scene）。场景本身不可见，是一个抽象的<strong>管理图形项的容器</strong>，可以向场景加入图形项，获取场景中某个图形项等功能，具体如下：</p><ul><li>提供管理大量图形项的快速接口；</li><li>将事件传播给每个图形项；</li><li>管理每个图形项的状态，例如选择、焦点状态；</li><li>管理未经变换的渲染功能（主要用于打印）；</li></ul><p>场景中除了图形项，还有<strong>背景层</strong>和<strong>前景层</strong>，通常用 <code>QBrush</code> 指定，也可以重写 <code>drawBackground()</code>、<code>drawForeground()</code> 来自定义效果；</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p><code>QGraphicsView</code> 提供绘图的视图（view）组件，用于显示场景中的内容。可以为一个场景设置多个视图，也可以对同一个数据集提供不同视口。下图展示了场景、视图、图形项三者间的关系：</p><p><img src="graphics_view.png"></p><p>虚线框是场景，视图 1 范围比场景大，因此可以显示全部内容（默认居中显示在视图中，可调整视图的 <code>Alignment</code> 属性）；视图 2 小于场景，仅能显示一部分内容，但会<strong>自动</strong>提供滚动条在整个场景中滚动。</p><p><strong>视图负责接收键鼠输入事件，并转换为场景事件，经过坐标变换后传送给可视场景</strong>。</p><h4 id="图形项"><a href="#图形项" class="headerlink" title="图形项"></a>图形项</h4><p>图形项（Graphics Item）就是一些基本图形元件，基类是 <code>QGraphicsItem</code>。Qt 提供了一些基本的图形项，例如椭圆 <code>QGraphicsEllipseItem</code>、矩形 <code>QGraphicsRectItem</code>、文字 <code>QGraphicsTextItem</code> 等。</p><p><code>QGraphicsItem</code> 支持如下操作：</p><ul><li>一切鼠标、键盘、按键输入事件；</li><li>支持拖放操作；</li><li>支持组合，可以是父子项关系组合，也可以通过 <code>QGraphicsItemGroup</code> 类进行组合；</li></ul><h3 id="6-2-2-Graphics-View-的坐标系统"><a href="#6-2-2-Graphics-View-的坐标系统" class="headerlink" title="6.2.2 Graphics View 的坐标系统"></a>6.2.2 Graphics View 的坐标系统</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Graphics View 系统有 3 个有效坐标系：<strong>图形项坐标</strong>、<strong>场景坐标</strong>、<strong>视图坐标</strong>。</p><p>其中，<strong>绘图时，场景坐标等价于 <code>QPainter</code> 的逻辑坐标</strong>，一般以场景中心为原点；</p><p><strong>视图坐标与设备坐标（物理坐标）相同，是绝对的，默认以左上角为原点</strong>；</p><p><strong>图形项坐标是 <u>局部逻辑坐标</u></strong>，一般以某个图形项的几何中心为原点。</p><p>这里很多教程和书籍写的很麻烦，下面用一段话来总结一下：</p><p>首先对于一个图形项而言，就只讨论图形项坐标。图形项坐标就是<strong>以当前图形项为参考系的坐标</strong>；而这个图形项本身整体坐标以几何中心为位置，按其父级 <code>QGraphicsItem</code> 的图形项坐标来表示位置。如果上层没有 <code>QGraphicsItem</code>，那么事件的位置就是<strong>场景坐标位置</strong>。这就意味着图形项坐标层层嵌套，最外层是场景坐标系。因此，场景坐标描述了每个顶层图形项的坐标位置。</p><p>而视图坐标就是<strong>窗口界面（widget）的物理坐标（单位像素）</strong>，只与 widget 有关，与场景无关。<strong>更重要的是，所有鼠标事件、拖动事件的坐标首先由视图坐标定义，然后由转换矩阵转换为场景坐标，以便与图形项交互</strong>。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>那么如何使用？首先创建场景的时候就可以定义场景坐标范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsScene::<span class="built_in">QGraphicsScene</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height);</span><br></pre></td></tr></table></figure><p>在使用时，虽然 <code>QGraphicsScene</code> 描述的是顶层 <code>QGraphicsItem</code>，但有一层封装可以取得所有图形项的场景坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">QGraphicsItem::scenePos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>还有 <code>QGraphicsItem</code> 在其父级中的坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">QGraphicsItem::pos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>注：除了上面两个方法，<code>QGraphicsItem</code> 的方法返回的位置几乎都是自己的<strong>局部坐标</strong>；</p><p>例如获得 <code>QGraphicsItem</code> 的边界矩形框的方法，返回的就是边界矩形在自己的局部坐标系下的坐标值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">QGraphicsItem::boundingRect</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></blockquote><p>既然 <code>pos()</code> 有对应在场景中的 <code>scenePos()</code>，那么 <code>boundingRect()</code> 也有在场景中的 <code>sceneBoundingRect()</code>，<strong>可以指出当前图形项在场景中的边界矩形、图形项的边界有什么变化等</strong>。</p><p><strong>场景本身也会在变化时发射 <code>QGraphicsScene::changed()</code> 信号，参数是一个场景坐标中的 <code>QRect[]</code>，表示发生变化的矩形区</strong>；</p><h4 id="坐标映射"><a href="#坐标映射" class="headerlink" title="坐标映射"></a>坐标映射</h4><p>在场景中操作图形项的时候，在场景、图形项、视图间的坐标变换是非常有用的，这被称为 “坐标映射”。我们可以通过 <strong><code>QGraphicsView::mapToScene()</code></strong> 从视图坐标映射为场景坐标，然后用 <strong><code>QGraphicsScene::itemAt()</code></strong> 获取场景中<strong>鼠标光标处的图形项</strong>；</p><h3 id="6-2-3-主要类的接口"><a href="#6-2-3-主要类的接口" class="headerlink" title="6.2.3 主要类的接口"></a>6.2.3 主要类的接口</h3><p>在接口列表中，<strong>我们省去了设置函数对应的读取函数，例如 <code>setScene()</code> 有对应的 <code>scene()</code> 读，后者是有的，但不会赘述</strong>，同时省去作用域符 <code>::</code> 和显然的参数、<code>const</code> 修饰。</p><h4 id="QGraphicsView"><a href="#QGraphicsView" class="headerlink" title="QGraphicsView"></a><code>QGraphicsView</code></h4><p>对于这个类，主要讨论的是它的视口坐标（视图坐标，也就是物理坐标）。下面列出类中常用的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景类型的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScene</span><span class="params">()</span></span>;        <span class="comment">// 设置与 view 关联的场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSceneRect</span><span class="params">()</span></span>;    <span class="comment">// 用 QRect 设置</span></span><br><span class="line"><span class="comment">// 外观类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlignment</span><span class="params">()</span></span>;    <span class="comment">// 设置场景在视图中的对齐方式，默认上下都居中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setBackgroundBrush</span><span class="params">()</span></span>;    <span class="comment">// 设置场景的背景画刷，用来管理背景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setForegroundBrush</span><span class="params">()</span></span>;    <span class="comment">// 前景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setRenderHints</span><span class="params">()</span></span>;    <span class="comment">// 设置绘图选项，回想一下 QPainter::setRenderHints()</span></span><br><span class="line"><span class="comment">// 交互类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setInteractive</span><span class="params">()</span></span>;    <span class="comment">// 设置场景是否允许交互。如果禁止，那么键鼠事件也会被忽略</span></span><br><span class="line"><span class="function">QRect <span class="title">rubberBandRect</span><span class="params">()</span></span>;    <span class="comment">// 返回当前选中的矩形框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setRubberBandSelectionMode</span><span class="params">()</span></span>;    <span class="comment">// 就是设置选择模式：能否选择、能否多选等，请回想 QTableWidget::setSelectionMode()</span></span><br><span class="line"><span class="function">QGraphicsItem* <span class="title">itemAt</span><span class="params">()</span></span>;    <span class="comment">// 获取视图（物理）坐标系中某位置处的图形项</span></span><br><span class="line"><span class="function">QList&lt;QGraphicsItem*&gt; <span class="title">items</span><span class="params">()</span></span>;    <span class="comment">// 返回场景中所有 / 某个选中区域的图形项列表</span></span><br><span class="line"><span class="comment">// 坐标映射型</span></span><br><span class="line"><span class="function">QPoint <span class="title">mapFromScene</span><span class="params">()</span></span>;    <span class="comment">// 场景坐标 转 视图坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapToScene</span><span class="params">()</span></span>;    <span class="comment">// 视图坐标 转场景坐标</span></span><br></pre></td></tr></table></figure><h4 id="QGraphicsScene"><a href="#QGraphicsScene" class="headerlink" title="QGraphicsScene"></a><code>QGraphicsScene</code></h4><p>这个类就是用于管理图形项的场景，是图形项的容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSceneRect</span><span class="params">()</span></span>;    <span class="comment">// 设置场景的矩形边界，和 QGraphicsView 一样能改</span></span><br><span class="line"><span class="comment">// 分组类型</span></span><br><span class="line"><span class="function">QGraphicsItemGroup* <span class="title">createItemGroup</span><span class="params">()</span></span>;    <span class="comment">// 创建图形项组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroyItemGroup</span><span class="params">()</span></span>;    <span class="comment">// 解除一个图形项组</span></span><br><span class="line"><span class="comment">// 输入焦点类型</span></span><br><span class="line"><span class="function">QGraphicsItem* <span class="title">focusItem</span><span class="params">()</span></span>;    <span class="comment">// 返回当前获得焦点的图形项</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearFocus</span><span class="params">()</span></span>;            <span class="comment">// 去除选择焦点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasFocus</span><span class="params">()</span></span>;            <span class="comment">// 当前视图是否有焦点</span></span><br><span class="line"><span class="comment">// 图形项操作类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addItem</span><span class="params">()</span></span>;                <span class="comment">// 添加一个**已创建**的图形项</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeItem</span><span class="params">()</span></span>;            <span class="comment">// 删除图形项</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;                <span class="comment">// 清除场景中所有图形项</span></span><br><span class="line"><span class="function">QGraphicsItem* <span class="title">mouseGrabberItem</span><span class="params">()</span></span>;    <span class="comment">// 返回鼠标抓取的图形项</span></span><br><span class="line"><span class="function">QList&lt;QGraphicsItem*&gt; <span class="title">selectedItems</span><span class="params">()</span></span>;    <span class="comment">// 与QGraphicsView::items()差距很小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearSelection</span><span class="params">()</span></span>;        <span class="comment">// 清除当前所有选中</span></span><br><span class="line"><span class="function">QGraphicsItem* <span class="title">itemAt</span><span class="params">()</span></span>;    <span class="comment">// 获取场景坐标系下某位置的顶层图形项，和 QGraphicsView::itemAt(); 就是输入坐标有差异</span></span><br><span class="line"><span class="function">QList&lt;QGraphicsItem*&gt; <span class="title">items</span><span class="params">()</span></span>;    <span class="comment">// 参考 QGraphicsView::items();</span></span><br><span class="line"><span class="comment">// 添加图形项类型</span></span><br><span class="line"><span class="function">QGraphicsEllipseItem* <span class="title">addEllipse</span><span class="params">()</span></span>;    <span class="comment">// 加一点椭圆</span></span><br><span class="line"><span class="function">QGraphicsLineItem* <span class="title">addLine</span><span class="params">()</span></span>;        <span class="comment">// 加一点线段</span></span><br><span class="line"><span class="function">QGraphicsPathItem* <span class="title">addPath</span><span class="params">()</span></span>;        <span class="comment">// 加一点 QPainterPath</span></span><br><span class="line"><span class="function">QGraphicsPixmapItem* <span class="title">addPixmap</span><span class="params">()</span></span>;    <span class="comment">// 加一点 pixmap</span></span><br><span class="line"><span class="function">QGraphicsPolygonItem* <span class="title">addPolygon</span><span class="params">()</span></span>;    <span class="comment">// 加一点多边形</span></span><br><span class="line"><span class="function">QGraphicsRectItem* <span class="title">addRect</span><span class="params">()</span></span>;        <span class="comment">// 加一点矩形</span></span><br><span class="line"><span class="function">QGraphicsSimpleTextItem* <span class="title">addSimpleText</span><span class="params">()</span></span>;    <span class="comment">// 加一点简单文字</span></span><br><span class="line"><span class="function">QGraphicsTextItem* <span class="title">addText</span><span class="params">()</span></span>;        <span class="comment">// 加一点字符串</span></span><br><span class="line"><span class="function">QGraphicsProxyWidget* <span class="title">addWidget</span><span class="params">()</span></span>;    <span class="comment">// 加一点界面组件</span></span><br><span class="line">                                    <span class="comment">// 味道好极了</span></span><br></pre></td></tr></table></figure><h4 id="QGraphicsItem"><a href="#QGraphicsItem" class="headerlink" title="QGraphicsItem"></a><code>QGraphicsItem</code></h4><p>它是所有图形项的基类，用户可以从它继承定义自己的图形项类。Qt 中常见的图形项类的继承关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsItem</span><br><span class="line">    |</span><br><span class="line">    ├─ QAbstractGraphicsShapeItem</span><br><span class="line">    ||</span><br><span class="line">    |├─ QGraphicsEllipseItem</span><br><span class="line">    |├─ QGraphicsPathItem</span><br><span class="line">    |├─ QGraphicsPolygonItem</span><br><span class="line">    |├─ QGraphicsRectItem</span><br><span class="line">    |└─ QGraphicsSimpleTextItem</span><br><span class="line">    |</span><br><span class="line">    ├─ QGraphicsLineItem</span><br><span class="line">    ├─ QGraphicsPixmapItem</span><br><span class="line">    ├─ QGraphicsObject</span><br><span class="line">    ||</span><br><span class="line">    |└─ QGraphicsTextItem</span><br><span class="line">    |</span><br><span class="line">    └─ QGraphicsItemGroup</span><br></pre></td></tr></table></figure><p>这个 <code>QGraphicsItem</code> 类提供了对图形项的基本操作方法，常见方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性设置类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setFlags</span><span class="params">()</span></span>;        <span class="comment">// 设置图形项的操作属性，例如可选择、可移动等</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setOpacity</span><span class="params">()</span></span>;        <span class="comment">// 如其名，设置透明度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGraphicsEffect</span><span class="params">()</span></span>;    <span class="comment">// 设置图形效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSelected</span><span class="params">()</span></span>;        <span class="comment">// 设置图形项是否被选中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">()</span></span>;            <span class="comment">// 用户自定义数据</span></span><br><span class="line"><span class="comment">// 坐标类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">()</span></span>;            <span class="comment">// 图形项在父级中的 X 坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">()</span></span>;            <span class="comment">// Y 坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setZValue</span><span class="params">()</span></span>;        <span class="comment">// Z 值控制叠放次序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPos</span><span class="params">()</span></span>;            <span class="comment">// 图形项在父级中的位置</span></span><br><span class="line"><span class="function">QPointF <span class="title">scenePos</span><span class="params">()</span></span>;        <span class="comment">// 返回图形项在场景中的坐标，相当于在 mapToScene 上包装</span></span><br><span class="line"><span class="comment">// 坐标变换类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetTransform</span><span class="params">()</span></span>;    <span class="comment">// 复位坐标系，取消所有变换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setRotation</span><span class="params">()</span></span>;        <span class="comment">// 顺时针(+)旋转指定角度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScale</span><span class="params">()</span></span>;        <span class="comment">// 等比例缩放</span></span><br><span class="line"><span class="comment">// 坐标映射类型</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapFromItem</span><span class="params">()</span></span>;    <span class="comment">// 将另一个图形项的一个**点**映射到本图形项的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapFromParent</span><span class="params">()</span></span>;<span class="comment">// 将父级的一个点映射到本图形项的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapFromScene</span><span class="params">()</span></span>;    <span class="comment">// 将场景的一个点映射到本图形项的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapToItem</span><span class="params">()</span></span>;    <span class="comment">// 将本图形项的一个点映射到另一个图形项的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapToParent</span><span class="params">()</span></span>;    <span class="comment">// 将本图形项的一个点映射到父级的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapToScene</span><span class="params">()</span></span>;    <span class="comment">// 将本图形项的一个点映射到场景坐标</span></span><br><span class="line"><span class="comment">// 绘制类型</span></span><br><span class="line"><span class="comment">// 注意！QGraphicsItem 也可以像 QPainter 一样指定绘制的工具</span></span><br><span class="line"><span class="comment">// ...(略)</span></span><br><span class="line"><span class="comment">// 再补充一个改变鼠标悬停样式的方法：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setCursor</span><span class="params">()</span></span>;        <span class="comment">// 参数请参考 QApplication::setOverrideCursor()</span></span><br></pre></td></tr></table></figure><p>这里说一下 <code>QGraphicsItem::setFlags()</code>  的使用，参数就是 <code>QGraphicsItem::QGraphicsItemFlag</code> 枚举类型，其值也是十六进制数码，<strong>也允许按位或组合</strong>，常见值有：<code>QGraphcisItem::ItemIsMovable</code>、<code>QGraphicsItem::ItemIsSelectable</code>、<code>QGraphicsItem::ItemIsFocusable</code> 等；</p><h2 id="6-3-章末总结"><a href="#6-3-章末总结" class="headerlink" title="6.3 章末总结"></a>6.3 章末总结</h2><h3 id="6-3-1-知识补充"><a href="#6-3-1-知识补充" class="headerlink" title="6.3.1 知识补充"></a>6.3.1 知识补充</h3><p>Qt 中有格式化字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static function</span></span><br><span class="line"><span class="function">QString <span class="title">QString::asprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, __VAR_ARGS__)</span></span>;</span><br></pre></td></tr></table></figure><p>格式化占位符和 C++ 的 <code>printf</code> 函数相同；</p><p>Qt 中还有一个类，比较常用，但是内容很少，就不再另起一节——它就是 <code>QTimer</code>；</p><p><code>QTimer</code> 用于创建和管理定时器。它提供了一种机制，可以在给定的时间间隔内发出信号。比较常用的方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QTimer::<span class="built_in">QTimer</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTimer::interval</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 查询时间间隔</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setInterval</span><span class="params">(<span class="type">int</span> milliSeconds)</span></span>;    <span class="comment">// 设置触发间隔</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isActive</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 当前是否正在计时</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isSingleShot</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// 是否是只触发一次的计时器</span></span><br><span class="line"><span class="comment">// slots:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::start</span><span class="params">()</span></span>;                        <span class="comment">// 计时开始</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::stop</span><span class="params">()</span></span>;                        <span class="comment">// 计时停止</span></span><br><span class="line"><span class="comment">// signals:</span></span><br><span class="line"><span class="comment">// 除非是仅触发一次的计时器，否则每当开始后 interval 的整数倍时间就 emit 一次这个信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::timeout</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="6-3-2-类图总结"><a href="#6-3-2-类图总结" class="headerlink" title="6.3.2 类图总结"></a>6.3.2 类图总结</h3><p>前面几章遇到的类图的总结如下：</p><p><img src="C6.png"></p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Qt </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从C++入门Qt（二）</title>
      <link href="//technical/qt-for-beginners-2/"/>
      <url>//technical/qt-for-beginners-2/</url>
      
        <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: C++ GUI Programming with Qt 4 (2nd Edition) </i></p><p><i>注意：本文章将讲解 <strong>Qt 5</strong> 入门知识，需要一定的 C++ 基础</i></p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p><strong>观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~</strong></p><hr><span id="more"></span><h1 id="Chapter-4-第一个完整的-Qt-入门项目"><a href="#Chapter-4-第一个完整的-Qt-入门项目" class="headerlink" title="Chapter 4 第一个完整的 Qt 入门项目"></a>Chapter 4 第一个完整的 Qt 入门项目</h1><blockquote><p>在完成以上的学习过程后，在座诸位都具有独立写出一个<strong>极简的、</strong>较为完整 Qt 项目的能力；</p><p>以下，本人将用 <strong>纯代码方式</strong> 方式完成这个项目；</p><p><strong>本章末，会总结到目前为止学到的所有 Qt 类的继承/思维图</strong>。</p></blockquote><p><strong>观前提示：本项目的设计思路很长，完整源代码放在 仓库 里，有需要可以取出查看 ~ 本章的目的是为了学习 Qt 一些组件的用法而已 ~</strong></p><p><strong>项目目标：模仿 <code>Microsoft Excel</code> 设计一个表格应用程序</strong>。</p><h2 id="4-1-创建主窗口-UI"><a href="#4-1-创建主窗口-UI" class="headerlink" title="4.1 创建主窗口 UI"></a>4.1 创建主窗口 UI</h2><h3 id="4-1-1-子类化-QMainWindow"><a href="#4-1-1-子类化-QMainWindow" class="headerlink" title="4.1.1 子类化 QMainWindow"></a>4.1.1 子类化 QMainWindow</h3><p>创建一个主窗口最方便的方法是利用 Qt 库中已有的设计类：<code>QMainWindow</code>。</p><p><code>QMainWindow</code> 和 <code>QDialog</code> 都是 <code>QWidget</code> 的子类，所以之前的很多方法在创建主窗口时同样有效。</p><p>编写前先认识 <code>QMainWindow</code> 类的对应结构：</p><p><img src="QMainWindow.png"></p><p>其中中央窗口部件可以放置 Widget，使用 <code>QMainWindow::setCentralWidget(QWidget*)</code> 在此区域添加 Widget；</p><p>首先根据目标，声明一个主窗口类（自己起个名字，这里用  <code>MainWindow</code>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: MainWindow.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面才添加上的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FindDialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HolySheet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义的常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxRecentFiles 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    <span class="comment">// Q_OBJECT</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>();    <span class="comment">// 主窗口构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// closeEvent 时 QWidget 类的虚函数，在 widget 关闭时可以自动调用。所以这里打算覆写此函数，达到“退出时弹出询问窗口”的功能，并保存一些设置到磁盘里</span></span><br><span class="line">    <span class="comment">// 流程：用户点击绑定了原生槽 QWidget::close() 的控件发出的信号(内部emit)，</span></span><br><span class="line">    <span class="comment">// 然后通过内置信号-槽自动调用原生槽 void closeEvent(QCloseEvent* event).</span></span><br><span class="line">    <span class="comment">// 注意，QCloseEvent* event 只有调用了 event-&gt;accept() 才会真正退出窗口，</span></span><br><span class="line">    <span class="comment">// 如果调用了 event-&gt;ignore()，将忽略关闭动作。详细见下文本函数实现的代码。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:    <span class="comment">// 之所以声明为私有槽，是因为它们是需要用户点击后作出相应的函数，而且不需要从类外被调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newFile</span><span class="params">()</span></span>;        <span class="comment">// 私有槽实现新建文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span></span>;        <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">save</span><span class="params">()</span></span>;        <span class="comment">// 保存文件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">saveAs</span><span class="params">()</span></span>;        <span class="comment">// 另存为文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">()</span></span>;        <span class="comment">// 表格查找功能，可以复用之前的 findDialog 窗口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">goToCell</span><span class="params">()</span></span>;    <span class="comment">// 表格定位功能，可以复用之前的 GoToCellDialog 窗口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>;        <span class="comment">// 表格排序功能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">about</span><span class="params">()</span></span>;        <span class="comment">// 关于软件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以上部分是一开始设计出来的 -----------------------------</span></span><br><span class="line">    <span class="comment">// 以下功能是后来加上的，所以实现到再解释 -------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openRecentFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateStatusBar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">holySheetModified</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:    <span class="comment">// 工具函数，大多是代码创建 UI 组件、被上面函数调用的底层功能等</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createActions</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createMenus</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createContextMenu</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createToolBars</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createStatusBar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">readSettings</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">writeSettings</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">okToContinue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">loadFile</span><span class="params">(<span class="type">const</span> QString&amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">saveFile</span><span class="params">(<span class="type">const</span> QString&amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCurrentFile</span><span class="params">(<span class="type">const</span> QString&amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateRecentFileAction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">strippedName</span><span class="params">(<span class="type">const</span> QString&amp; fullFileName)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一些私有数据成员，不用管它，真正编程时，先空着用到再添加</span></span><br><span class="line">    HolySheet* holySheet;    <span class="comment">// 注：HolySheet 类是表格的数据管理类，以后实现</span></span><br><span class="line">    FindDialog* findDialog;</span><br><span class="line">    QLabel* locationLabel;</span><br><span class="line">    QLabel* formulaLabel;</span><br><span class="line">    QStringList recentFiles;    <span class="comment">// 新类 QStringList，QString 类型的列表</span></span><br><span class="line">    QString curFile;</span><br><span class="line">    </span><br><span class="line">    QAction* recentFileActions[MaxRecentFiles];</span><br><span class="line">    QAction* separatorAction;</span><br><span class="line">    </span><br><span class="line">    QMenu* fileMenu;</span><br><span class="line">    QMenu* editMenu;</span><br><span class="line">    QToolBar* fileToolBar;</span><br><span class="line">    QToolBar* newAction;</span><br><span class="line">    QAction* newAction;</span><br><span class="line">    QAction* openAction;</span><br><span class="line">    QAction*aboutAction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在实现以上的内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: MainWindow.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MainWindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化中央窗口部件</span></span><br><span class="line">    holySheet = <span class="keyword">new</span> HolySheet;</span><br><span class="line">    <span class="comment">// QMainWindow 的方法，用于将 widget 设置在中央窗口区</span></span><br><span class="line">    <span class="built_in">setCentralWidget</span>(holySheet);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建顶部栏、侧边栏等其他部件</span></span><br><span class="line">    <span class="built_in">createActions</span>();</span><br><span class="line">    <span class="built_in">createMenus</span>();</span><br><span class="line">    <span class="built_in">createContextMenu</span>();</span><br><span class="line">    <span class="built_in">createToolBars</span>();</span><br><span class="line">    <span class="built_in">createStatusBar</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取磁盘中的软件偏好设置</span></span><br><span class="line">    <span class="built_in">readSettings</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等调用 MainWindow::find() 后再创建</span></span><br><span class="line">    findDialog = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置窗口图标，至于为何前面是“：”，请看解析</span></span><br><span class="line">    <span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/images/icon.png&quot;</span>));</span><br><span class="line">    <span class="built_in">setCurrentFile</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明的是 <code>QMainWindow::setWindowIcon(QIcon)</code> 和 <code>QIcon</code> 类；</p><p>在应用程序需要读取一些资源的时候，通常开发者会把资源放在一个文件夹中，需要的时候通过<strong>和系统相关的路径</strong>载入，这种方法可移植性较低，并且容易因为移动而丢失资源，<strong>最讨厌的是资源路径比较麻烦</strong>；</p><p>因此，比较推荐的是 <strong>Qt 的资源机制（resource mechanism）</strong>，优点是比运行时载入更方便、适用于任意文件格式；推荐的使用方法是：</p><ol><li><p>将资源分类放在各目录下，比如图片放在项目创建的 <code>images</code> 子目录下；</p></li><li><p>新建 <strong>Qt 资源系统文件</strong> <code>*.qrc</code> ，名字自己起，格式是 <code>XML</code> ，举个例子（用相对路径）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RCC</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qresource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/icon.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/gotocell.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RCC</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>记得在项目 <code>*.pro</code> 文件中添加：<code>RESOURCE = yourFileName.qrc</code>（如果您用 Qt Creator  IDE 自动添加，就当我没说）</p></li></ol><p><strong>这样在 Qt 程序的绝大多数地方路径字符串 <code>:/</code> 代表 <code>*.qrc</code> 存在的路径，不会出错</strong>；例如调用上面的 <code>icon.png</code> 时可以这么用：<code>QIcon(&quot;:/images/icon.png&quot;)</code>；</p><h3 id="4-1-2-实现菜单栏、上下文菜单和工具栏"><a href="#4-1-2-实现菜单栏、上下文菜单和工具栏" class="headerlink" title="4.1.2 实现菜单栏、上下文菜单和工具栏"></a>4.1.2 实现菜单栏、上下文菜单和工具栏</h3><p>现在介绍前面没提到的 <code>QAction</code> 类，<strong>Qt 通过 “动作” 的概念简化了有关于菜单和工具栏的编程</strong>，一个动作就是一个可以添加到任意数量的菜单和工具栏上的项；</p><p>所以在 Qt 中创建菜单和工具栏包括以下几个步骤：</p><ol><li>创建并设置动作属性，例如文本、提示、信号-槽、图标、快捷键等；</li><li>创建菜单并将动作添加到菜单上；</li><li>创建工具栏并将动作添加到工具栏上；</li></ol><p>以本章的项目来举个栗子🌰：</p><p><strong>Firstly</strong>，要创建菜单栏的项并设置属性：实现上面的 <code>MainWindow::createActions()</code> 函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建文本为“New”、父控件为 MainWindow 的动作（这样就不用手动释放了）</span></span><br><span class="line">    newAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;New&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    newAction-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/image/new.png&quot;</span>));    <span class="comment">// 设置动作的图标</span></span><br><span class="line">    newAction-&gt;<span class="built_in">setShortcut</span>(QKeySequence::New);        <span class="comment">// 设置动作的快捷键</span></span><br><span class="line">    <span class="comment">// 设置提示性文本</span></span><br><span class="line">    newAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Create a new holySheet file&quot;</span>));</span><br><span class="line">    <span class="comment">// 将动作项与底层函数连接</span></span><br><span class="line">    <span class="built_in">connect</span>(newAction, <span class="built_in">SINGAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">newFile</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下省略 Open、Save、Save As 的动作编写，因为几乎一模一样</span></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Recent Open Files 动作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxRecentFiles; ++i) &#123;</span><br><span class="line">        recentFileActions[i] = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 这里设置隐藏，因为第一次打开没有最近文件</span></span><br><span class="line">        recentFileActions[i]-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 将动作和底层的 openRecentFile() 连接</span></span><br><span class="line">        <span class="built_in">connect</span>(recentFileActions[i], <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()),</span><br><span class="line">               <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">openRecentFile</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Exit 动作</span></span><br><span class="line">    exitAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Exit&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    exitAction-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">tr</span>(<span class="string">&quot;Ctrl+Q&quot;</span>));</span><br><span class="line">    exitAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Exit the Application&quot;</span>));</span><br><span class="line">    <span class="comment">// 这里的 close() 是 QWidget::close() 自带槽</span></span><br><span class="line">    <span class="built_in">connect</span>(exitAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Select All 动作</span></span><br><span class="line">    selectAllAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;All&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    selectAllAction-&gt;<span class="built_in">setShortcut</span>(QKeySequence::SelectAll);</span><br><span class="line">    selectAllAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Select all the cells in the sheet&quot;</span>));</span><br><span class="line">    <span class="comment">// 注意，这里 holySheet 是设计成 QTableWidget 的子类，因为需要看表；</span></span><br><span class="line">    <span class="comment">// 而 QTableWidget 具有内置槽 selectAll()，因此无需自行实现</span></span><br><span class="line">    <span class="built_in">connect</span>(selectAllAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()),</span><br><span class="line">           holySheet, <span class="built_in">SLOT</span>(<span class="built_in">selectAlll</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置中的 Show Grid 动作，是否展示表格边框</span></span><br><span class="line">    showGridAction = <span class="keyword">new</span> <span class="built_in">Action</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Show Grid&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 可勾选模式</span></span><br><span class="line">    showGridAction-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 今后需要在 holySheet 中实现的方法，同步勾选状态 和 显示状态</span></span><br><span class="line">    showGridAction-&gt;<span class="built_in">setChecked</span>(holySheet-&gt;<span class="built_in">showGrid</span>());</span><br><span class="line">    showGridAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Show or hide the holySheet&#x27;s grid&quot;</span>));</span><br><span class="line">    <span class="comment">// 又一个今后需要在 holySheet 中实现的槽，同步勾选动作 和 设置显示槽</span></span><br><span class="line">    <span class="built_in">connect</span>(showGridAction, <span class="built_in">SIGNAL</span>(<span class="built_in">toggled</span>(<span class="type">bool</span>)),</span><br><span class="line">           holySheet, <span class="built_in">SLOT</span>(<span class="built_in">setShowGrid</span>(<span class="type">bool</span>)));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处省略 Auto Recalculate 动作</span></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// About 动作</span></span><br><span class="line">    aboutAction = <span class="keyword">new</span> <span class="built_in">Action</span>(<span class="built_in">tr</span>(<span class="string">&quot;About&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    aboutAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Show the information about the app&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(aboutAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">about</span>());</span><br><span class="line">    <span class="comment">// About Qt 动作</span></span><br><span class="line">    aboutQtAction = <span class="keyword">new</span> <span class="built_in">Action</span>(<span class="built_in">tr</span>(<span class="string">&quot;About &amp;Qt&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    aboutQtAction-&gt;<span class="built_in">setStatusTip</span>(<span class="string">&quot;Show the Qt library&#x27;s About Box&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里的 qApp 将设置为全局变量，QApplication 类，包含 aboutQt() 方法</span></span><br><span class="line">    <span class="built_in">connect</span>(aboutQtAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), qApp, <span class="built_in">SLOT</span>(<span class="built_in">aboutQt</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>其中 <code>QKeySequence</code> 类提供了一套标准化的键盘快捷键的对应 enum 值，可以通过查看文档中 <code>enum QKeySequence::StandardKey</code> 的枚举值来找到运行平台上正确的快捷键表示；</p><blockquote><p>标准键如：全选<code>QKeySequence::SelectAll =&gt; &quot;Ctrl+A&quot;</code>，复制 <code>Ctrl+C</code> 等；</p><p>可惜的是，上面的 <strong>退出</strong> 就没有标准化快捷键，只能自定义：<code>&quot;Ctrl+Q&quot;</code>；</p></blockquote></li><li><p>还可以通过 <code>QActionGroup</code> 类来实现<strong>相互排斥</strong>的勾选 <code>Action</code>，这里不需要就不演示了；</p></li></ol><p><strong>Secondly</strong>，需要创建菜单，并且把创建好的菜单项放进菜单中：实现 <code>MainWindow::createMenus()</code>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createMenus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意：QMainWindow 和 QMenu 类进行了组合，本身有 QMainWindow::menuBar()，</span></span><br><span class="line">    <span class="comment">// 调用即返回内嵌于 QMainWindow 中的菜单栏，位置见上面 QMainWindow 结构展示</span></span><br><span class="line">    fileMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(saveAsAction);</span><br><span class="line">    separatorAction = fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxRecentFile; ++i)</span><br><span class="line">        fileMenu-&gt;<span class="built_in">addAction</span>(recentFileActions[i]);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>(exitAction);</span><br><span class="line">    </span><br><span class="line">    editMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Edit&quot;</span>));</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(cutAction);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(copyAction);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(pasteAction);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(deleteAction);</span><br><span class="line">    </span><br><span class="line">    selectSubMenu = editMenu-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Select&quot;</span>));</span><br><span class="line">    selectSubMenu-&gt;<span class="built_in">addAction</span>(selectRowAction);</span><br><span class="line">    selectSubMenu-&gt;<span class="built_in">addAction</span>(selectColAction);</span><br><span class="line">    selectSubMenu-&gt;<span class="built_in">addAction</span>(selectAllAction);</span><br><span class="line">    </span><br><span class="line">    editMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(findAction);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(goToCellAction);</span><br><span class="line">    </span><br><span class="line">    toolsMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Tools&quot;</span>));</span><br><span class="line">    toolsMenu-&gt;<span class="built_in">addAction</span>(recalculationAction);</span><br><span class="line">    toolsMenu-&gt;<span class="built_in">addAction</span>(sortAction);</span><br><span class="line">    </span><br><span class="line">    optionsMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Options&quot;</span>));</span><br><span class="line">    optionsMenu-&gt;<span class="built_in">addAction</span>(showGridAction);</span><br><span class="line">    optionsMenu-&gt;<span class="built_in">addAction</span>(autoRecalculation);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是菜单间间隔的写法，menuBar() 没有 addMenu，有些系统呈现的是</span></span><br><span class="line">    <span class="comment">// 将之后的菜单放在最右侧，有些系统会直接忽略，有些系统仅仅显示一个分割线</span></span><br><span class="line">    <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    </span><br><span class="line">    helpMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Help&quot;</span>));</span><br><span class="line">    helpMenu-&gt;<span class="built_in">addAction</span>(aboutAction);</span><br><span class="line">    helpMenu-&gt;<span class="built_in">addAction</span>(aboutQtAction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thirdly</strong>，实现完菜单栏，再关注 <strong>上下文菜单栏（context menu 直译，或译作 “右键菜单”）</strong>：实现 <code>MainWindow::createContextMenu()</code>；</p><p><strong>实现上下文菜单的重要机制是：Qt 的上下文菜单策略（context menu policy）</strong></p><p>任何 QWidget 都有一个与之相关联的 <code>QAction</code> 列表，也有上下文菜单策略枚举变量：<code>enum Qt::ContextMenuPolicy</code>；当设置上下文菜单策略为枚举量 <code>Qt::ActionsContextMenu(=2)</code> 时，会以该 QAction 列表为 widget 的上下文菜单，当右击这个 widget 时，会展开上下文菜单；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createContextMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    holySheet-&gt;<span class="built_in">addAction</span>(cutAction);</span><br><span class="line">    holySheet-&gt;<span class="built_in">addAction</span>(copyAction);</span><br><span class="line">    holySheet-&gt;<span class="built_in">addAction</span>(pasteAction);</span><br><span class="line">    holySheet-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::ActionsContextMenu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种设计的方法比较繁琐，不重用之前的 <code>QAction</code>，即上下文菜单策略是<code>Qt::DefaultContextMenu(=1)</code> 时，重新实现：<code>QWidget::contextMenuEvent()</code> 函数，在其中创建一个 <code>QMenu</code>，添加，再对该部件调用 <code>exec()</code>，感兴趣可以尝试，这里不做演示；</p><p><strong>Last but not the least</strong>，关注<strong>工具栏</strong>：实现 <code>MainWindow::createToolBars()</code>；注意，如果你之前设置的 Action 有设置图标的话，可以直接复用，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createToolBars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fileToolBar = <span class="built_in">addToolBar</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">    fileToolBar-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line">    fileToolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">    fileToolBar-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line">    </span><br><span class="line">    editToolBar = <span class="built_in">addToolBar</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Edit&quot;</span>));</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(cutAction);</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(copyAction);</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(pasteAction);</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(findAction);</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(goToCellAction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-设置状态栏"><a href="#4-1-3-设置状态栏" class="headerlink" title="4.1.3 设置状态栏"></a>4.1.3 设置状态栏</h3><blockquote><p>什么是状态栏？大家看 Microsoft Word 中左下角每当进行一些操作时，会显示不同文字，如下，这就是状态栏：</p><p><img src="statusBar-example.png"></p></blockquote><p>下面实现 <code>MainWindow::createStatusBar()</code>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createStatusBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    locationLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot; w999 &quot;</span>);</span><br><span class="line">    locationLabel-&gt;<span class="built_in">setAlignment</span>(Qt::AlignHCenter);</span><br><span class="line">    locationLabel-&gt;<span class="built_in">setMinimumSize</span>(locationLabel-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">    </span><br><span class="line">    formulaLabel = <span class="keyword">new</span> QLabel;</span><br><span class="line">    formulaLabel-&gt;<span class="built_in">setIndent</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">statusBar</span>()-&gt;<span class="built_in">addWidget</span>(locationLabel);</span><br><span class="line">    <span class="built_in">statusBar</span>()-&gt;<span class="built_in">addWidget</span>(formulaLabel, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">connect</span>(holySheet, <span class="built_in">SIGANL</span>(<span class="built_in">currentCellChanged</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">updateStatusBar</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(holySheet, <span class="built_in">SIGNAL</span>(<span class="built_in">modified</span>()),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">holySheetModified</span>()));</span><br><span class="line">    <span class="built_in">updateStatusBar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分状态栏的实现大致可以分为两个部分：</p><ol><li><p>创建控件（大多是 QLabel），设置控件的布局；</p><ul><li>初始的 <code>locationLabel</code> 设置内容 “ w999 ” 表示最大单元格位置，配合 <code>locationLabel-&gt;setMinmumSize(locationLabel-&gt;sizeHint())</code> 可以确定位置状态标签大小满足要求；</li><li><code>locationLabel-&gt;setAlignment(Qt::AlignHCenter)</code> 确保文本居中对齐；</li><li><code>formulaLabel-&gt;setIndent(3)</code> 表示标签内添加文本缩进，这是实现之后进行的微调，确保美观；</li><li><code>statusBar()-&gt;addWidget(QWidget*, int)</code> 中第二个参数是<strong>伸展因子</strong>，参数为 0 表示<strong>紧贴模式（默认）</strong>，参数为 1 表示<strong>最大占用模式（还剩多少就占多少，类似 CSS 中的 auto 参数）</strong>；</li></ul></li><li><p>为状态栏的变化建立连接；</p><ul><li><p>先利用将要实现的 <code>holySheet</code> 信号 <code>currentCellChanged(int, int, int, int)</code>，和更新状态栏的槽 <code>updateStatusBar()</code> 绑定；<code>MainWindow::updateStatusBar()</code> 实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::updateStatusBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    locationLabel-&gt;<span class="built_in">setText</span>(holySheet-&gt;<span class="built_in">currentLocation</span>());</span><br><span class="line">    formulaLabel-&gt;<span class="built_in">setText</span>(holySheet-&gt;<span class="built_in">currentFormula</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>此外，为了实现 <strong>“已修改后会改变窗口标题”</strong>（很多软件在文件修改后，会在窗口标题加一个记号，如 <code>*</code>） ，还要实现 <code>MainWindow::holySheetModified()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::holySheetModified</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QMainWindow 的固有槽</span></span><br><span class="line">    <span class="built_in">setWindowModified</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">updateStatusBar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<strong>每个 <code>QWidget</code> 都有一个 <code>windowModified</code> 属性</strong> ~</p></li></ul></li></ol><h2 id="4-2-主窗口的底层函数实现"><a href="#4-2-主窗口的底层函数实现" class="headerlink" title="4.2 主窗口的底层函数实现"></a>4.2 主窗口的底层函数实现</h2><blockquote><p>函数比较多，还是从窗口的菜单功能下手；</p></blockquote><h3 id="4-2-1-File-菜单"><a href="#4-2-1-File-菜单" class="headerlink" title="4.2.1 File 菜单"></a>4.2.1 File 菜单</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新文件创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::newFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前窗口有没保存的改动，提醒是否保存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">okToContinue</span>()) &#123;</span><br><span class="line">        holySheet-&gt;<span class="built_in">clear</span>();    <span class="comment">// holySheet 等待实现的函数，清屏</span></span><br><span class="line">        <span class="built_in">setCurrentFile</span>(<span class="string">&quot;&quot;</span>);    <span class="comment">// 当前文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::okToContinue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断当前窗口是否有没有保存的修改，也是 QMainWindow 的方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isWindowModified</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> res = QMessageBox::<span class="built_in">warning</span>(</span><br><span class="line">            <span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">            <span class="built_in">tr</span>(<span class="string">&quot;The document has been modified.\n&quot;</span></span><br><span class="line">               <span class="string">&quot;Do you want to save your changes?&quot;</span>),</span><br><span class="line">            QMessageBox::Yes | QMessageBox::No | QMessageBox::Cancel</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (res == QMessageBox::Yes) <span class="keyword">return</span> <span class="built_in">save</span>();    <span class="comment">// 保存更改</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res == QMessageBox::Cancel) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 确认立即继续</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上值得一提的是，<code>QMessageBox</code> 提供了很多标准的信息对话框模板，例如：提示信息、提问、警告、严重错误，语法：<code>QMessageBox::warning(QWidget* parent, QString title, QString message, (enum)QMessageBox::StandardButtons buttons)</code>；</p><p>其中枚举类型 <code>QMessageBox::StandardButtons</code> 含有枚举值 <code>QMessageBox::Yes</code>、<code>QMessageBox::No</code>、<code>QMessageBox::Cancel</code>、<code>QMessageBox::Apply</code>等等，有特殊需要可以参考官方文档，<strong>这里设计非常巧妙，枚举值设置为 16 进制数码，使用多个 buttons 时，利用按位或 <code>|</code> （参考上面代码），达到类似 Linux 权限掩码的多选效果</strong>；</p><p>除了 <code>warning</code> 警告对话框，还有 <code>information</code> 提示对话框、<code>question</code> 提问对话框、<code>critical</code> 严重错误对话框；<strong>语法是相同的</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开已有文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">okToContinue</span>()) &#123;</span><br><span class="line">        QString fileName = QFileDialog::<span class="built_in">getOpenFileName</span>(</span><br><span class="line">                                <span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Open sheet&quot;</span>), <span class="string">&quot;.&quot;</span>,</span><br><span class="line">                                <span class="built_in">tr</span>(<span class="string">&quot;HolySheet file (*.hs)&quot;</span>)</span><br><span class="line">                            );</span><br><span class="line">        <span class="keyword">if</span> (!fileName.<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="built_in">loadFile</span>(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层实现：载入指定文件，之所以不和 MainWindow::open() 合在一起，就是为了在“打开最近文件”的功能中重用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::loadFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holySheet-&gt;<span class="built_in">readFile</span>(fileName)) &#123;    <span class="comment">// holySheet 等待实现的函数</span></span><br><span class="line">        <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;Loading canceled&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setCurrentFile</span>(fileName);</span><br><span class="line">    <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;File loaded&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>借助上面的代码，再补充一些重要的点，<code>QFileDialog</code> 类提供各种<strong>打开文件名（“浏览”）</strong>的对话窗口，和前面介绍的 <code>QMessageBox</code> 都继承于 <code>QDialog</code>；比较常用的是 <code>QFileDialog::getOpenFileName(QWdiget* parent, QString title, QString startPath, QString filter)</code>；</p><p>还有 <code>QFileDialog::getSaveFileName(...)</code>，语法相同，之和代码会介绍；</p><blockquote><p>注意：① 这里的QFileDialog 一般窗口优先级都比父窗口的高，显示在其上层；② 文件过滤器参数 <code>filter</code> 参数的格式是 “<code>&lt;description&gt; (*.suffix)</code>”，如果允许多个文件类型，则用换行符分割：“<code>&lt;desc1&gt; (*.suffix1)\n&lt;desc2&gt; (*.suffix2)</code>”；</p></blockquote></li><li><p><code>QStatusBar::showMessage(QString text, int milisec)</code> 的调用不会影响到 <code>QStatusBar</code> 中添加的 widget，会单独再显示消息；第二个参数 <code>milisec</code> 表示消息停留的<strong>毫秒数</strong>；</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curFile.<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="built_in">saveAs</span>();    <span class="comment">// 当前不存在文件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">saveFile</span>(curFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::saveFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holySheet-&gt;<span class="built_in">writeFile</span>(fileName)) &#123;    <span class="comment">// holySheet 等待实现的函数</span></span><br><span class="line">        <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;Saving canceled&quot;</span>, <span class="number">2000</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setCurrentFile</span>(fileName);    <span class="comment">// 保存成功，则设置当前文件为指定文件</span></span><br><span class="line">    <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;File saved&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::saveAs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QString fileName = QFileDialog::<span class="built_in">getSaveFileName</span>(</span><br><span class="line">                            <span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Save sheet&quot;</span>), <span class="string">&quot;.&quot;</span>,</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;HolySheet file (*.hs)&quot;</span>)</span><br><span class="line">                        );</span><br><span class="line">    <span class="keyword">if</span> (fileName.<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">saveFile</span>(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>QFileDialog::getSaveFileName</code> 和 <code>QFileDialog::getOpenFileName</code> 不同的是，<strong>如果给定的文件已经存在，会自动弹出对话框提醒是否需要覆盖</strong>；也可以传递附加参数： <code>QFileDialog::DontConfirmOverwrite</code>来改变这个行为；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::closeEvent</span><span class="params">(QCloseEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">okToContinue</span>()) &#123;</span><br><span class="line">        <span class="built_in">writeSettings</span>();    <span class="comment">// 写入配置</span></span><br><span class="line">        event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> event-&gt;<span class="built_in">ignore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得之前<strong>在声明这个函数的时候的注释内容</strong>吗？</p><p>此外，<code>QApplication</code> 默认 <code>quitOnLastWindowClosed = true</code>，如果想要**关闭最后一个窗口后，<code>QApplication</code> 仍然运行（例如托盘运行），那么可以将它设置为 <code>false</code>；</p><p>顺便实现内部函数 <code>setCurrentFile</code> 和 <code>strippedName</code>。前者用于<strong>指定当前文件（<code>curFile</code> 私有变量）、修改窗口标题、修改 “最近文件” 列表、修改窗口是否改动的状态</strong>，后者用于得到文件除去后缀的名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::setCurrentFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    curFile = fileName;</span><br><span class="line">    <span class="built_in">setWindowModified</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    QString shownName = <span class="built_in">tr</span>(<span class="string">&quot;Untitled&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!curFile.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        shownName = <span class="built_in">strippedName</span>(curFile);</span><br><span class="line">        recentFiles.<span class="built_in">removeAll</span>(curFile);</span><br><span class="line">        recentFiles.<span class="built_in">prepend</span>(curFile);</span><br><span class="line">        <span class="built_in">updateRecentFileActions</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Qt 的格式化字符串！</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;%1 [*] - %2&quot;</span>).<span class="built_in">arg</span>(shownName).<span class="built_in">arg</span>(<span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">MainWindow::strippedName</span><span class="params">(<span class="type">const</span> QString&amp; fullFileName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QFileInfo</span>(fullFileName).<span class="built_in">fileName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到了更新 “最近文件” 列表，还有之前说到的 “最近文件” 列表的动作绑定，现在来实现 <code>updateRecentFileActions</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::updateRecentFileActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QMutableStringListIterator <span class="title">iter</span><span class="params">(recentFiles)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (iter.<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!QFile::<span class="built_in">exists</span>(iter.<span class="built_in">next</span>()))</span><br><span class="line">            iter.<span class="built_in">remove</span>();    <span class="comment">// 移除还在列表中，但已不存在的文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxRecentFiles; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; recentFiles.<span class="built_in">count</span>()) &#123;</span><br><span class="line">            QString text = <span class="built_in">tr</span>(<span class="string">&quot;&amp;%1 %2&quot;</span></span><br><span class="line">                              .<span class="built_in">arg</span>(i + <span class="number">1</span>)</span><br><span class="line">                              .<span class="built_in">arg</span>(<span class="built_in">strippedName</span>(recentFiles[i]))</span><br><span class="line">                             );</span><br><span class="line">            recentFileActions[i]-&gt;<span class="built_in">setText</span>(text);</span><br><span class="line">            recentFileActions[i]-&gt;<span class="built_in">setData</span>(recentFiles[i]);</span><br><span class="line">            recentFileActions[i]-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> recentFileActions[i]-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    seperatorAction-&gt;<span class="built_in">setVisible</span>(!recentFiles.<span class="built_in">isEmpty</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 <code>QMutableStringIterator</code> 可以看作是 <code>QStringList</code>（<code>recentFiles</code> 的类型）的可变的迭代器；</p><p>其次，对于 <code>recentFileActions[i]-&gt;setData(recentFiles[i])</code> 这一步，其实 <code>QAction</code> 类的函数 <code>setData(QVariant qvar)</code> 对应设置了 <code>QVariant QAction::data</code>  数据成员，它可以保存很多种 C++ / Qt 的数据类型，<strong>包括 <code>QString</code>、一切 <code>numerical</code>、<code>bool</code>、<code>QStringList</code> 等</strong>（以后会进一步讨论）；</p><p>下面实现 <code>openRecentFile</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::openRecentFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">okToContinue</span>()) &#123;</span><br><span class="line">        QAction* action = <span class="built_in">qobject_cast</span>&lt;QAction*&gt;(<span class="built_in">sender</span>());</span><br><span class="line">        <span class="keyword">if</span> (action) <span class="built_in">loadFile</span>(<span class="built_in">action</span>()-&gt;<span class="built_in">data</span>().<span class="built_in">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QObject::sender()</code> 返回 <code>QObject*</code>，用于<strong>查出是哪个信号 / 动作调用了当前的槽（所以在槽函数内使用）</strong>；这里知道调用 <code>openRecentFile()</code> 函数的一定是 <code>QAction</code> 的动作，所以强制转换到它的指针类型，并且读出 <code>data</code> 数据，进而找到点击的 “最近文件” 并调用 <code>loadFile()</code>；</p><h3 id="4-2-2-主窗口调用-Dialog：模态和非模态"><a href="#4-2-2-主窗口调用-Dialog：模态和非模态" class="headerlink" title="4.2.2 主窗口调用 Dialog：模态和非模态"></a>4.2.2 主窗口调用 Dialog：模态和非模态</h3><p>这里会用到之前所写的 <code>findDialog</code>、<code>goToCellDialog</code>、<code>sortDialog</code> 等对话框，进行功能的<strong>拼接</strong>，同时会制作简单的 <code>about</code> 对话框。</p><p>首先是之前的 <code>findDialog</code> 对话框。由于希望用户可以在主窗口、子窗口间<strong>自由切换</strong>（毕竟只是查找功能），所以 <code>findDialog</code> 必须是 <strong>非模态的（modeless）</strong>——在运行的程序中，这种窗口独立于其他窗口，不会覆盖或阻挡，实现方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!findDialog) &#123;    <span class="comment">// 从未创建过 findDialog，懒加载模式</span></span><br><span class="line">        findDialog = <span class="keyword">new</span> <span class="built_in">FindDialog</span>(<span class="keyword">this</span>);    <span class="comment">// 设置父对象可以不用另外析构</span></span><br><span class="line">        <span class="comment">// 将 findDialog 的两个信号绑定到 holySheet 的两个槽上进行查找处理</span></span><br><span class="line">        <span class="built_in">connect</span>(findDialog, <span class="built_in">SIGNAL</span>(<span class="built_in">findNext</span>(<span class="type">const</span> QString&amp;, Qt::CaseSensitivity)), holySheet, <span class="built_in">SLOT</span>(<span class="built_in">findNext</span>(<span class="type">const</span> QString&amp;, Qt::CaseSensitivity)));</span><br><span class="line">        <span class="built_in">connect</span>(findDialog, <span class="built_in">SIGNAL</span>(<span class="built_in">findPrev</span>(<span class="type">const</span> QString&amp;, Qt::CaseSensitivity)), holySheet, <span class="built_in">SLOT</span>(<span class="type">const</span> QString&amp;, Qt::CaseSensitivity));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    findDialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    findDialog-&gt;<span class="built_in">raise</span>();</span><br><span class="line">    findDialog-&gt;<span class="built_in">activateWindow</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过点击 <code>Edit-&gt;Find</code> 菜单来调出 <code>find()</code> 函数有 3 种情况：</p><ol><li>用户第一次调用这个对话框：由于懒加载，会先创建它，再打开；</li><li>用户曾经打开过，现在是关闭（<code>visible=false</code>）状态：直接 <code>show()</code> 就足以完成<strong>显示、置顶、激活</strong>这 3 个状态；</li><li>用户曾经打开，仍没有关闭：这时 <code>show()</code> 不能完成置顶、激活这两个状态，分别需要 <code>raise()</code> 和 <code>activateWindow()</code> 来完成；</li></ol><p>按照这个逻辑，后面 3 行还可以写成：（<strong>不过没必要</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (findDialog-&gt;<span class="built_in">isHidden</span>()) findDialog-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    findDialog-&gt;<span class="built_in">raise</span>();</span><br><span class="line">    findDialog-&gt;<span class="built_in">activateWindow</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看 <code>goToCellDialog</code>，我们希望用户弹出、使用、关闭它，不希望在使用它的期间去碰主窗口，这种子窗口就是 <strong>模态的（modal）</strong>——可弹出并阻塞应用程序的对话框：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::goToCell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里为什么不 new，而只是在栈中建立一个 dialog，是由对话框目的决定；</span></span><br><span class="line">    <span class="comment">// 这里用完就可以销毁，没必要 new + delete.</span></span><br><span class="line">    <span class="function">GoToCellDialog <span class="title">dialog</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (dialog.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        QString str = dialog.lineEdit-&gt;<span class="built_in">text</span>().<span class="built_in">toUpper</span>();</span><br><span class="line">        holySheet-&gt;<span class="built_in">setCurrentCell</span>(str.<span class="built_in">mid</span>(<span class="number">1</span>).<span class="built_in">toInt</span>() - <span class="number">1</span>, str[<span class="number">0</span>].<span class="built_in">unicode</span>() - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：模态对话框不能使用 <code>show()</code>，否则变成非模态对话框！应该使用 <code>QDialog::exec()</code> 阻塞获取对话框返回结果</strong>（由 <code>accept()</code> 和 <code>reject()</code> 决定，<code>QDialog::Accepted=true</code>、<code>QDialog::Rejected=false</code>）；</p><p>另外，<code>HolySheet::setCurrentCell(int x, int y)</code> 等待实现；</p><p><code>QString::mid(int)</code> 指提取从第 int 个字符串以后的子串、<code>toInt()</code> 不解释，其正确性由之前 <code>GoToCellDialog::lineEdit</code> 中设置的 <code>QRegExpValidator</code> 来保证；</p><p>再来看 <code>sortDialog</code>，它也是一个模态对话框，允许用户<strong>在当前选定区域</strong>使用<strong>给定的列</strong>进行排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SortDialog <span class="title">dialog</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 注意：这个函数没写错，就是之后需要在 HolySheet 类中实现的一个函数</span></span><br><span class="line">    <span class="comment">// 它不是 QTableWidget 的原生函数 selectRanges()</span></span><br><span class="line">    QTableWidgetSelectionRange range = holySheet-&gt;<span class="built_in">selectedRange</span>();</span><br><span class="line">    dialog.<span class="built_in">setColumnRange</span>(<span class="string">&#x27;A&#x27;</span> + range.<span class="built_in">leftColumn</span>(),</span><br><span class="line">                          <span class="string">&#x27;A&#x27;</span> + range.<span class="built_in">rightColumn</span>());</span><br><span class="line">    <span class="keyword">if</span> (dialog.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        </span><br><span class="line">        HolySheetCompare compare;</span><br><span class="line">        compare.keys[<span class="number">0</span>] = dialog.primaryColumnCombo-&gt;<span class="built_in">currentIndex</span>();</span><br><span class="line">        compare.keys[<span class="number">1</span>] = dialog.secondaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() - <span class="number">1</span>;</span><br><span class="line">        compare.keys[<span class="number">2</span>] = dialog.tertiaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() - <span class="number">1</span>;</span><br><span class="line">        compare.ascending[<span class="number">0</span>] = </span><br><span class="line">            (dialog.primaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() == <span class="number">0</span>);</span><br><span class="line">        compare.ascending[<span class="number">1</span>] = </span><br><span class="line">            (dialog.secondaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() == <span class="number">0</span>);</span><br><span class="line">        compare.ascending[<span class="number">2</span>] = </span><br><span class="line">            (dialog.tertiaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() == <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        holySheet-&gt;<span class="built_in">sort</span>(compare);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们看到了 2 个新类。一个是 Qt 原生的 <code>QTableWidgetSelectionRange</code>，用来记录 <code>QTableWidget</code> 选中的区域信息，可以由 <code>QTableWidget::selectRange()</code> 得到当前选中的范围。含有 <code>leftColumn()</code>、<code>rightColumn()</code> 方法查到区域的列；</p><blockquote><p>注意：<code>SortDialog::setColumnRange</code> 是之前我们自己定义为了 <code>column ComboBox</code> 的取值范围而设置的函数。</p></blockquote><p>另一个类是 <code>HolySheetCompare</code>，和 <code>HolySheet</code> 一样，是之后我们自己会实现的类。这个类存储<strong>主键、第二键、第三键以及它们的排序顺序（<code>keys</code> 数组存储键的列号，<code>ascending</code> 数组按 <code>bool</code> 格式存储每个键相关顺序）</strong>，这个对象可以被 <code>HolySheet::sort()</code> 使用，用于两行间的比较；</p><blockquote><p>注意：<code>QComboBox::currentIndex()</code> 返回当前选定项的索引值，第一个为 0；</p><p>上面的 “-1” 指去除前面的 “None” 设置值。</p></blockquote><p>本节最后，我们制作一个简单的 <code>About</code> 对话框，只需要静态函数 <code>QMessageBox::about</code> 就行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::about</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">about</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;About HolySheet&quot;</span>),</span><br><span class="line">                      <span class="built_in">tr</span>(<span class="string">&quot;&lt;h2&gt;HolySheet 0.1&lt;/h2&gt;&quot;</span></span><br><span class="line">                         <span class="string">&quot;&lt;p&gt;Copyright &amp;copy; 2023 SJTU-XHW Inc.&lt;/p&gt;&quot;</span></span><br><span class="line">                         <span class="string">&quot;&lt;p&gt;HolySheet is a small application that &quot;</span></span><br><span class="line">                         <span class="string">&quot;demonstrate QAction, QMainWindow, QMenuBar, &quot;</span></span><br><span class="line">                         <span class="string">&quot;QStatusBar, QTableWidget, QToolBar and many &quot;</span></span><br><span class="line">                         <span class="string">&quot;other Qt classes.&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QMessageBox::about(QWidget* parent, const QString&amp; title, const QString&amp; contents)</code> 和 <code>warning/information/critical</code> 不同的是，<strong>它的图标取决于父控件的图标</strong>。</p><h3 id="4-2-3-设置的持久化"><a href="#4-2-3-设置的持久化" class="headerlink" title="4.2.3 设置的持久化"></a>4.2.3 设置的持久化</h3><p>现在关注 <code>readSettings()</code>、<code>writeSettings()</code> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::writeSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QSettings <span class="title">settings</span><span class="params">(<span class="string">&quot;SJTU-XHW Inc.&quot;</span>, <span class="string">&quot;HolySheet&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 这里的 saveGeometry() 是 QWidget 类的原生方法，</span></span><br><span class="line">    <span class="comment">// 返回 QByteArray，可以被 QVariant 存储</span></span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;geometry&quot;</span>, <span class="built_in">saveGeometry</span>());</span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;recentFiles&quot;</span>, recentFiles);</span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;showGrid&quot;</span>, showGridAction-&gt;<span class="built_in">isChecked</span>());</span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;autoRecalc&quot;</span>, autoRecalcAction-&gt;<span class="built_in">isChecked</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>QSettings</code> 类的值设置非常类似 <code>Python</code> 的字典键值对，值也是用 <code>QVariant</code> 存储的；默认情况下，<code>QSettings</code> 在系统上存储方法和系统种类有关（<code>Windows</code> 上就存在注册表，<code>UNIX</code> 存在文本文件中，<code>MacOS</code> 存在 <code>Core Foundation Preferences</code> 编程接口中），详细内容如下表：</p><table>    <tr style="text-align: center;">        <th>Platform</th>        <th>Format</th>        <th>Scope</th>        <th>Path</th>    </tr>    <tr>        <td rowspan=4>Windows</td>        <td rowspan=2>Native</td>        <td>User</td>        <td>HKEY_CURRENT_USER\Software\*</td>    </tr>    <tr>        <td>System</td>        <td>HKEY_LOCAL_MACHINE\Software\*</td>    </tr>    <tr>        <td rowspan=2>INI</td>        <td>User</td>        <td>%APPDATA%\*.ini</td>    </tr>    <tr>        <td>System</td>        <td>%COMMON_APPDATA%\*.ini</td>    </tr>    <tr>        <td rowspan=4>Unix</td>        <td rowspan=2>Native</td>        <td>User</td>        <td>$HOME/.config/*.conf</td>    </tr>    <tr>        <td>System</td>        <td>/etc/xdg/*.conf</td>    </tr>    <tr>        <td rowspan=2>INI</td>        <td>User</td>        <td>$HOME/.config/*.ini</td>    </tr>    <tr>        <td>System</td>        <td> /etc/xdg/*.ini</td>    </tr>    <tr>        <td rowspan=4>Mac OS X</td>        <td rowspan=2>Native</td>        <td>User</td>        <td>$HOME/Library/Preferences/com.*.plist</td>    </tr>    <tr>        <td>System</td>        <td> /Library/Preferences/com.*.plist</td>    </tr>    <tr>        <td rowspan=2>INI</td>        <td>User</td>        <td> $HOME/.config/*.ini</td>    </tr>    <tr>        <td>System</td>        <td> /etc/xdg/*.ini</td>    </tr></table><p><code>QSettings</code> 类的构造函数的参数分别是组织名、程序名，为的是方便设置的<strong>读取、查找</strong>。</p><p>此外，<code>QSettings</code> 的设置还能以路径形式指定子键的值（如 <code>findDialog/matchCase</code>）或者用 <code>beginGroup(QString)</code> 和 <code>endGroup()</code> 的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">settings.<span class="built_in">beginGroup</span>(<span class="string">&quot;findDialog&quot;</span>);</span><br><span class="line">settings.<span class="built_in">setValue</span>(<span class="string">&quot;matchCase&quot;</span>, caseCheckBox-&gt;<span class="built_in">isChecked</span>());</span><br><span class="line">settings.<span class="built_in">setValue</span>(<span class="string">&quot;searchBackward&quot;</span>, backwardCheckBox-&gt;<span class="built_in">isChecked</span>());</span><br><span class="line">settings.<span class="built_in">endGroup</span>();</span><br></pre></td></tr></table></figure><p>还有 <code>readSettings</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::readSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按组织名 + 程序名读取设置</span></span><br><span class="line">    <span class="function">QSettings <span class="title">settings</span><span class="params">(<span class="string">&quot;SJTU-XHW Inc.&quot;</span>, <span class="string">&quot;HolySheet&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">restoreGeometry</span>(settings.<span class="built_in">value</span>(<span class="string">&quot;geometry&quot;</span>).<span class="built_in">toByteArray</span>());</span><br><span class="line">    recentFiles = settings.<span class="built_in">value</span>(<span class="string">&quot;recentFiles&quot;</span>).<span class="built_in">toStringList</span>();</span><br><span class="line">    <span class="built_in">updateRecentActions</span>();    <span class="comment">// 更新 “最近文件” 菜单栏</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二参数是默认值，类似 Python dict 类的 setdefault()</span></span><br><span class="line">    <span class="type">bool</span> showGrid = settings.<span class="built_in">value</span>(<span class="string">&quot;showGrid&quot;</span>, <span class="literal">true</span>).<span class="built_in">toBool</span>();</span><br><span class="line">    showGridAction-&gt;<span class="built_in">setChecked</span>(showGrid);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> autoRecalc = settings.<span class="built_in">value</span>(<span class="string">&quot;autoRecalc&quot;</span>, <span class="literal">true</span>).<span class="built_in">toBool</span>();</span><br><span class="line">    autoRecalcAction-&gt;<span class="built_in">setChecked</span>(autoRecalc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以在应用程序的其他任何地方使用 <code>QSettings</code> 方便地查询、修改设置。</p><p>到目前为止，<code>MainWindow</code> 及其 UI 界面已经几乎完全实现，主要的任务就是实现 <code>HolySheet</code> 类和 <code>HolySheetCompare</code> 类了。</p><h3 id="4-2-4-锦上添花：多文档模式"><a href="#4-2-4-锦上添花：多文档模式" class="headerlink" title="4.2.4 锦上添花：多文档模式"></a>4.2.4 锦上添花：多文档模式</h3><p>现在我们可以准备编写程序的 <code>main</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainWindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow win;        <span class="comment">// 这里不用 new 创建</span></span><br><span class="line">    win.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑这个问题：我们想要<strong>同一时间打开、处理多个表格</strong>，怎么办？</p><p>肯定不能让用户重复打开程序——这是不方便的。应该像浏览器打开页面一样，提供多个窗口。这就是程序的<strong>多窗口（文档）模式</strong>。</p><p>这时，我们就需要对 <code>File</code> 菜单进行一些改动，<strong>使得一个应用程序实例，能够处理多个文档</strong>：</p><ul><li><p><code>File-&gt;New</code> 操作不再是使用原先存在的窗口，而是<strong>创建一个空文档窗口</strong>，已存在的窗口需要手动关闭；</p></li><li><p><code>File-&gt;Close</code> 关闭当前的主窗口，而不是清除内容；</p><blockquote><p><strong>注：原来的 <code>MainWindow</code> 没有这个 <code>Close</code> 选项，因为是单窗口，它的作用和 <code>Exit</code> 相同</strong>；</p></blockquote></li><li><p><code>File-&gt;Exit</code> 关闭所有窗口，而不是关闭当前仅有的窗口。</p></li></ul><p>想要具有多窗口功能，需要使用 <code>new</code> 来统一创建、销毁窗口。所以 <code>main.cpp</code> 改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainWindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow* win = <span class="keyword">new</span> MainWindow;</span><br><span class="line">    win-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着修改 <code>newFile()</code> 槽和 <code>Actions</code> 的组成和提示信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: mainWindow.cpp</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWondow::newFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MainWindow* otherWin = <span class="keyword">new</span> MainWindow;</span><br><span class="line">    otherWin-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    closeAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Close&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    closeAction-&gt;<span class="built_in">setShortCut</span>(QKeySequence::Close);</span><br><span class="line">    closeAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Close this window&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(closeAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line">    </span><br><span class="line">    exitAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;E&amp;xit&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    exitAction-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">tr</span>(<span class="string">&quot;Ctrl+Q&quot;</span>));</span><br><span class="line">    exitAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Exit the application&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(exitAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), qApp, <span class="built_in">SLOT</span>(<span class="built_in">closeAllWindows</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>QApplication</code> 的槽 <code>closeAllWindows()</code> 会关闭所有在 <code>app</code> 循环中创建的窗口，并且不用担心释放问题，每个窗口都会调用 <code>closeEvent()</code> 处理。</p><p>同时需要注意另一个问题，是创建窗口过多的问题。<strong>这时就需要考虑 <code>MainWindow</code> 的析构问题了</strong>。解决方法很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个设置会使得所有 <code>close()</code> 的控件立即被析构。可是有个更需要解决的问题：<strong>“最近文件” 列表的问题</strong>——多个窗口需要共享一个 “最近文件” 的列表。</p><p>这个问题可以通过将 <code>recentFiles</code> 改成静态变量的方法解决，读者可以自行思考。</p><p>实现本节 “多文档” 的目标不止这一种，还可以采用 <code>Qt</code> 的 <code>MDI</code>（multiple document interface）管理方法，以后介绍。</p><h3 id="4-2-5-锦上添花：程序启动画面"><a href="#4-2-5-锦上添花：程序启动画面" class="headerlink" title="4.2.5 锦上添花：程序启动画面"></a>4.2.5 锦上添花：程序启动画面</h3><p>这个需求可能是因为甲方的要求，又或是要掩饰程序启动慢的事实（手动狗头）；很简单，只需要在 <code>main</code> 函数中使用 <code>QSplashScreen</code> 类就能解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    QSplashScreen* splash = <span class="keyword">new</span> QSplashScreen;</span><br><span class="line">    splash-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/splash.png&quot;</span>));    <span class="comment">// 设置启动界面背景图</span></span><br><span class="line">    splash-&gt;<span class="built_in">show</span>();        <span class="comment">// 不管主程序有没有启动，先启动“启动画面”再说</span></span><br><span class="line">    </span><br><span class="line">    Qt::Alignment topRight = Qt::AlignRight | Qt::AlignTop;</span><br><span class="line">    </span><br><span class="line">    splash-&gt;<span class="built_in">showMessage</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;Setting up the main window...&quot;</span>),</span><br><span class="line">                        topRight, Qt::black);</span><br><span class="line">    MainWindow win;</span><br><span class="line"></span><br><span class="line">    splash-&gt;<span class="built_in">showMessage</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;Testing windows (5s)...&quot;</span>),</span><br><span class="line">                        topRight, Qt::black);</span><br><span class="line">    QTime timer;</span><br><span class="line">    timer.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">while</span> (timer.<span class="built_in">elapsed</span>() &lt; <span class="number">5000</span>)</span><br><span class="line">        app.<span class="built_in">processEvents</span>();</span><br><span class="line">    </span><br><span class="line">    win.<span class="built_in">show</span>();</span><br><span class="line">    splash-&gt;<span class="built_in">finish</span>(&amp;win);    <span class="comment">// 完成，把位置让给 MainWindow</span></span><br><span class="line">    <span class="keyword">delete</span> splash;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-程序中央窗口实现：QTableWidget"><a href="#4-3-程序中央窗口实现：QTableWidget" class="headerlink" title="4.3 程序中央窗口实现：QTableWidget"></a>4.3 程序中央窗口实现：<code>QTableWidget</code></h2><p>中央窗口部件常见的设计方法有下面几种：</p><ol><li>使用一个<strong>标准的 Qt 窗口部件</strong>（或继承于其的控件）作为 <code>centralWidget</code>，例如 <code>QTableWidget</code>、<code>QTextEdit</code> 等，本工程就是用这种方法；</li><li>使用一个<strong>自定义窗口部件</strong> 作为 <code>centralWidget</code>，以后会介绍怎么自定义窗口部件（继承得到的不叫自定义部件）；</li><li>使用一个<strong>带布局管理器的普通 <code>QWidget</code></strong> 作为 <code>centralWidget</code>，这也是初学者最喜欢用的方法；</li><li>使用<strong>切分窗口（<code>QSplitter</code>）</strong>，利用切分条（<code>splitter handle</code>）控制它们的尺寸；</li><li>使用<strong><code>MDI</code></strong>。上一节说了，以后再讨论。</li></ol><p>本项目使用的是标准 Qt 窗口部件 <code>QTableWidget</code>，并采用继承的方法来给 <code>HolySheet</code> 类添加一些必要的功能。先搞清 <code>QTableWidget</code> 的继承关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QObject -&gt; QWidget -&gt; QTableView -&gt; QTableWidget -&gt; HolySheet(自定义)</span><br><span class="line"></span><br><span class="line">// 这是个纯粹的数据类，就是存放数据、为 QTableWidget 类服务</span><br><span class="line">QTableWidgetItem -&gt; Cell(自定义)</span><br></pre></td></tr></table></figure><p>再了解一下 <code>QTableWidget</code> 类对象的组成：</p><p><img src="QTableWidget.png"></p><h3 id="4-3-1-表格的定义"><a href="#4-3-1-表格的定义" class="headerlink" title="4.3.1 表格的定义"></a>4.3.1 表格的定义</h3><p>最后开始设计 <code>HolySheet</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QTableWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后会说 Cell 类的定义和实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Cell.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一些常量</span></span><br><span class="line"><span class="keyword">namespace</span> holysheet &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> MagicNumber = <span class="number">0x7F51C883</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> RowCount = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ColumnCount = <span class="number">26</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> holysheet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类是自己写的，先声明以供 HolySheet 类使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HolySheetCompare</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HolySheet</span> : <span class="keyword">public</span> QTableWidget &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HolySheet</span>(QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 这些函数几乎全是之前在 MainWindow 类里面要用的，可以回忆一下它们被用在哪里</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAutoRecalc</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> autoRecalc; &#125;</span><br><span class="line">    <span class="function">QString <span class="title">currentLocation</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">currentFormula</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QTableWidgetSelectionRange <span class="title">selectedRange</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 之所以写 clear 的原因是，不想“全部清除”</span></span><br><span class="line">    <span class="comment">// 想要留下表头提示信息等，所以需要自定义</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">readFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">writeFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span></span>;</span><br><span class="line">    <span class="comment">// 后面实现的时候再说 HolySheetCompare 的定义和实现</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">const</span> HolySheetCompare&amp; compare)</span></span>;</span><br><span class="line"><span class="keyword">public</span> slot:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paste</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectCurrentRow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectCurrentColumn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recalculate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAutoRecalculate</span><span class="params">(<span class="type">bool</span> recalc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findNext</span><span class="params">(<span class="type">const</span> QString&amp; text, Qt::CaseSensitivity cs)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findPrev</span><span class="params">(<span class="type">const</span> QString&amp; text, Qt::CaseSensitivity cs)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modified</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">somethingChanged</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> autoRecalc;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Cell* <span class="title">cell</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">text</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">formula</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFormula</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">const</span> QString&amp; formula)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-表格的-“文本”-和-“公式”"><a href="#4-3-2-表格的-“文本”-和-“公式”" class="headerlink" title="4.3.2 表格的 “文本” 和 “公式”"></a>4.3.2 表格的 “文本” 和 “公式”</h3><p>下面正式开始实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HolySheet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">HolySheet::<span class="built_in">HolySheet</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QTableWidget</span>(parent) &#123;</span><br><span class="line">    </span><br><span class="line">    autoRecalc = <span class="literal">true</span>;    <span class="comment">// 默认选中</span></span><br><span class="line">    <span class="comment">// 自定义表格每个格子的内容模式，参数类型需要 QTableWidgetItem</span></span><br><span class="line">    <span class="comment">// 这里用的是继承的 Cell 实例</span></span><br><span class="line">    <span class="built_in">setItemPrototype</span>(<span class="keyword">new</span> Cell);</span><br><span class="line">    <span class="comment">// 设置 QTableWidget 的选择方法，这里仅限连续格子的选择</span></span><br><span class="line">    <span class="built_in">setSelectionMode</span>(ContiguousSelection);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原生信号 QTableWidget::itemChanged(QTableWidgetItem*)</span></span><br><span class="line">    <span class="comment">// 为何不直接连接 modified 信号，而非要经过 somethingChanged 槽？</span></span><br><span class="line">    <span class="comment">// 因为 somethingChanged 槽中需要检查 autoRecalc 并且自动更新！(实现会说)</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">itemChanged</span>(QTableWidgetItem*)),</span><br><span class="line">            <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">somethingChanged</span>()));</span><br><span class="line">    <span class="comment">// 第一次启动需要清空格子内容</span></span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清除行列数（为了删除内容）并重设行列总数</span></span><br><span class="line">    <span class="built_in">setRowCount</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">setColumnCount</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">setRowCount</span>(RowCount);</span><br><span class="line">    <span class="built_in">setColumnCount</span>(ColumnCount);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是给每列第一行加上表头</span></span><br><span class="line">    <span class="comment">// 无需为每行第一列考虑，它们默认数字编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ColumnCount; ++i) &#123;</span><br><span class="line">        QTableWidgetItem* item = <span class="keyword">new</span> QTableWidgetItem;</span><br><span class="line">        item-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="built_in">QChar</span>(<span class="string">&#x27;A&#x27;</span> + i)));</span><br><span class="line">        <span class="comment">// 原生函数，设置指定内容的 QTableWidgetItem 实例为每一列的表头</span></span><br><span class="line">        <span class="built_in">setHorizontalHeaderItem</span>(i, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将选中的位置回归到原点</span></span><br><span class="line">    <span class="built_in">setCurrentCell</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明中的 <code>cell()</code> 函数是为了给定行列，返回一个 <code>Cell</code> 指针，目的和 <code>QTableWidget::item()</code> 取 <code>QTableWidgetItem</code> 一样。只不过之前设置了每个格子类型为 <code>Cell</code>，所以这里自定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cell* <span class="title">HolySheet::cell</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Cell*&gt;(<span class="built_in">item</span>(row, col));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更方便的是，可以直接取单元格的数据为字符串、公式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">HolySheet::text</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Cell* c = <span class="built_in">cell</span>(row, col);</span><br><span class="line">    <span class="keyword">if</span> (c) <span class="keyword">return</span> c-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">HolySheet::formula</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Cell* c = <span class="built_in">cell</span>(row, col);</span><br><span class="line">    <span class="keyword">if</span> (c) <span class="keyword">return</span> c-&gt;formula();    <span class="comment">// Cell 类等待实现：Cell::formula()</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠ 注意：<strong>“公式” 和 “文本” 数据在每个 <code>Cell</code> 中存储在不同地方（机理和 <code>QTableWidgetItem</code> 类有关，由 <code>role</code> 参数控制，等实现 <code>Cell</code> 类再说。目前只需要知道看文本用 <code>text()</code>、看公式 <code>formula()</code>）</strong>，而公式数据可以按照计算结果来修改本格的文本数据。</p><p>这里需要搞清楚，很多情况下，公式和文本是相同的，它的<strong>处理规则</strong>如下：</p><ul><li><p>公式是普通文本时，和文本数据一样，不会计算。例如公式 “Hello” 等价于文本 “Hello”；</p></li><li><p>公式是数字的时候，公式的数字会被认为双精度浮点数（double），而非文本；</p></li><li>公式以单引号开始（Excel 中把这个叫做转义内容），那么剩余部分会被认为是文本，例如：公式 “ ‘12345 ” 就是文本，等价于字符串 “12345”；</li><li>公式以等号开始，那么公式会被认为是算数公式，例如公式 “ =A1+A2 ” 会计算 A1 和 A2 单元格的文本（转化为数字）之和的值，并填入 <code>Cell</code> 的文本数据中；</li></ul><p>这里 <strong>由公式计算出值</strong> 的过程会由 <code>Cell</code> 类完成，<code>HolySheet</code> 类不会涉及。</p><p>上面实现的是取数据的函数，下面实现设定数据的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::setFormula</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">const</span> QString&amp; formula)</span> </span>&#123;</span><br><span class="line">    Cell* c = <span class="built_in">cell</span>(row, col);</span><br><span class="line">    <span class="keyword">if</span> (!c) &#123;                    <span class="comment">// 当前格子还没有创建对应的 Cell 对象</span></span><br><span class="line">        <span class="comment">// 不用担心释放问题，这里 QTableWidget 会自动</span></span><br><span class="line">        <span class="comment">// 取得新的 QTableWidgetItem 的所有权，并且在合适的时机自动析构</span></span><br><span class="line">        c = <span class="keyword">new</span> Cell;</span><br><span class="line">        <span class="built_in">setItem</span>(row, col, c);</span><br><span class="line">    &#125;</span><br><span class="line">    c-&gt;<span class="built_in">setFormula</span>(formula);        <span class="comment">// Cell 类来设定、计算公式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的读者会发现，这里只有 <code>setFormula</code>，没有 <code>setText</code>，刚刚不是说两个分开存储吗？对，这里还是和 <code>QTableWidgetItem</code> 类有关。<strong>我们会在 “<code>QTableWidgetItem</code> 机理简介” 一节进行解释</strong>。</p><p>另外能看出来的是，我们存储表并不是使用二维数组或字符串列表，而是<strong>存储为项（item）</strong>，有助于节省空间、加快运行速度等。这种方法在 <code>QListWidget</code> 和 <code>QTreeWidget</code> 类中也能看到（对应 <code>QListWidgetItem</code> 和 <code>QTreeWidgetItem</code> 类）；</p><p>此外，对于更大数据量的应用场景，Qt 还支持模型/视图类（model/view），以后介绍。</p><p>再来实现其他用到的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">HolySheet::currentLocation</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// currentRow() 和 currentColumn() 还是 QTableWidget 的原生函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QString</span>(<span class="string">&#x27;A&#x27;</span> + <span class="built_in">currentColumn</span>()</span><br><span class="line">                + QString::<span class="built_in">number</span>(<span class="built_in">currentRow</span>() + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原本在 MainWindow 中的用途是展示在 formulaLabel 中的</span></span><br><span class="line"><span class="function">QString <span class="title">HolySheet::currentFormula</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> formula(<span class="built_in">currentRow</span>(), <span class="built_in">currentColumn</span>());    <span class="comment">// 上面的取公式函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::somethingChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为什么不直接 emit modified() 的原因在这</span></span><br><span class="line">    <span class="keyword">if</span> (autoRecalc) <span class="built_in">recalculate</span>();</span><br><span class="line">    <span class="function">emit <span class="title">modified</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-表格数据的存取"><a href="#4-3-3-表格数据的存取" class="headerlink" title="4.3.3 表格数据的存取"></a>4.3.3 表格数据的存取</h3><p>再来看<strong>表数据的存储和读取</strong>的问题。我们要用一种<strong>自定义的二进制格式</strong>来实现 <code>HolySheet</code> 文件的读取和存储。这时就用到了 <strong><code>QFile</code> 类和 <code>QDataStream</code> 类</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HolySheet::writeFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="comment">// 如果只写的打开方式失败，说明文件不存在或有权限问题等</span></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::WriteOnly)) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;Cannot write file %1:\n%2.&quot;</span>)</span><br><span class="line">                            .<span class="built_in">arg</span>(file.<span class="built_in">fileName</span>())</span><br><span class="line">                            .<span class="built_in">arg</span>(file.<span class="built_in">errorString</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">QDataStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">    <span class="comment">// 这个版本看你的 Qt 版本。例如 5.12 版本就用 QDataStream::Qt_5_12</span></span><br><span class="line">    out.<span class="built_in">setVersion</span>(QDataStream::Qt_5_14);</span><br><span class="line">    out &lt;&lt; <span class="built_in">quint32</span>(MagicNumber);        <span class="comment">// 混淆作用，你可以随便改 MagicNumber</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更改鼠标指针样式为 “等待”</span></span><br><span class="line">    QApplication::<span class="built_in">setOverrideCursor</span>(Qt::WaitCursor);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; RowCount; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; ColumnCount; ++col) &#123;</span><br><span class="line">            QString str = formula(row, col);</span><br><span class="line">            <span class="keyword">if</span> (!str.<span class="built_in">isEmpty</span>())</span><br><span class="line">                out &lt;&lt; <span class="built_in">quint16</span>(row) &lt;&lt; <span class="built_in">quint16</span>(col) &lt;&lt; str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还原鼠标指针样式</span></span><br><span class="line">    QApplication::<span class="built_in">restoreOverrideCursor</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>QDataStream</code> 模仿了标准 C++ 的流（<code>stream</code>）类，都使用 <code>&gt;&gt;/&lt;&lt;</code> 运算符来输入输出流，例如：<code>in &gt;&gt; x &gt;&gt; y;</code> 和 <code>out &lt;&lt; x &lt;&lt; y;</code>。</p><p>这里还考虑到 C++ 的基本类型<strong>在不同平台下的空间大小不同</strong>，所以将它们强制转换为 <code>qint8/quint8/...(16、32)/qint64/quint64</code>，其中 <code>quint64</code> 最安全，但占用空间也比较多，所以结合实际数据范围，上面的代码以 <code>quint16</code> 为例。</p><p>在上面的例子中，<code>HolySheet</code> 程序的文件（<code>*.hs</code>）存储格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MagicNumber(混淆码，32 bits, 4 Bytes) | row(16 bits) | column(16 bits) | string (32 bits) | row | column | string | ...</span><br></pre></td></tr></table></figure><p>而具体存储方式由 <code>QDataStream</code> 内部决定。例如，<code>quint16</code> 会被 <code>QDataStream</code> 按<strong>小端序</strong>存成 2 Bytes，<code>QString</code> 会被存成 <code>字符串长度 + Unicode字符</code> 形式；</p><p><strong>而且不同版本的 Qt ，存储方式不同</strong>，这也是为什么上面要指定 <code>QDataStream</code> 的版本（<code>setVersion</code>）；</p><p><code>QDataStream</code> 除了使用在 <code>QFile</code> 上，还能用在 <code>QBuffer</code>、<code>QProcess</code>、<code>QTcpSocket</code>、<code>QUdpSocket</code>、<code>QSslSocket</code> 等类中。</p><p>如果仅仅是读取文本，还可以用 <code>QTextStream</code> 来代替 <code>QDataStream</code>。以后会深入介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HolySheet::readFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly)) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;Cannot read file %1:\n%2.&quot;</span>)</span><br><span class="line">                            .<span class="built_in">arg</span>(file.<span class="built_in">fileName</span>())</span><br><span class="line">                            .<span class="built_in">arg</span>(file.<span class="built_in">errorString</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">QDataStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">    in.<span class="built_in">setVersion</span>(QDataStream::Qt_5_14);</span><br><span class="line">    </span><br><span class="line">    quint32 magic;</span><br><span class="line">    in &gt;&gt; magic;</span><br><span class="line">    <span class="keyword">if</span> (magic != MagicNumber) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;The file is broken / not a HolySheet file.&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">clear</span>();    <span class="comment">// 读取文件之前已经确认过，所以这里直接清空表格</span></span><br><span class="line">    </span><br><span class="line">    quint16 row, column;</span><br><span class="line">    QString str;</span><br><span class="line">    </span><br><span class="line">    QApplication::<span class="built_in">setOverrideCursor</span>(Qt::WaitCursor);</span><br><span class="line">    <span class="keyword">while</span> (!in.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">        in &gt;&gt; row &gt;&gt; column &gt;&gt; str;</span><br><span class="line">        <span class="built_in">setFormula</span>(row, column, str);</span><br><span class="line">    &#125;</span><br><span class="line">    QApplication::<span class="built_in">restoreOverrideCursor</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-4-表格编辑功能"><a href="#4-3-4-表格编辑功能" class="headerlink" title="4.3.4 表格编辑功能"></a>4.3.4 表格编辑功能</h3><p>到现在为止，<code>HolySheet</code> 除 “公式处理功能” 以外的其他功能已经基本具备（准确地说是接口做好了，可以当作 <code>Cell</code> 类已经实现），现在把 <code>Edit</code> 菜单中对应的诸如 <strong>复制、粘贴、剪切、删除</strong> 等功能补充完全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.cpp ------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::cut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">copy</span>();</span><br><span class="line">    <span class="built_in">del</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QTableWidgetSelectionRange range = <span class="built_in">selectedRange</span>();</span><br><span class="line">    QString str;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// QTableWidgetSelectionRange::rowCount 和 columnCount 是原生方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range.<span class="built_in">rowCount</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) str += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; range.<span class="built_in">columnCount</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) str += <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">            <span class="comment">// QTableWidgetSelectionRange::topRow 和 bottomRow 也是原生方法</span></span><br><span class="line">            str += formula(range.<span class="built_in">topRow</span>() + i, range.<span class="built_in">leftColumn</span>() + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置系统剪切板的静态方法</span></span><br><span class="line">    QApplication::<span class="built_in">clipboard</span>()-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的复制方法的结果认为，<strong>每列每格间隔一个制表符（<code>\t</code>），每行间格一个换行符（<code>\n</code>）——这是几乎全球通用的格式</strong>，<code>Microsoft Excel</code> 也这么用，所以可以直接粘贴到其他多数软件上。</p><p>对于<strong>粘贴、删除</strong>（剪切包含在其中）的操作，会导致<strong>modified</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里考验信息提取的简单方法的设计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::paste</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QTableWidgetSelectionRange range = <span class="built_in">selectedRange</span>();</span><br><span class="line">    QString str = QApplication::<span class="built_in">clipboard</span>()-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="comment">// 下面解析剪切板中的内容</span></span><br><span class="line">    QStringList rows = str.<span class="built_in">split</span>(<span class="string">&#x27;\n&#x27;</span>);        <span class="comment">// 和 Python 很像</span></span><br><span class="line">    <span class="type">int</span> numRows = rows.<span class="built_in">count</span>();</span><br><span class="line">    <span class="type">int</span> numColumns = rows.<span class="built_in">first</span>().<span class="built_in">count</span>(<span class="string">&#x27;\t&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 区域合法性检验</span></span><br><span class="line">    <span class="keyword">if</span> (range.<span class="built_in">rowCount</span>() * range.<span class="built_in">columnCount</span>() != <span class="number">1</span></span><br><span class="line">       &amp;&amp; (range.<span class="built_in">rowCount</span>() != numRows || range.<span class="built_in">columnCount</span>() != numColumn)) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;The contents in the clipboard cannot be&quot;</span></span><br><span class="line">                              <span class="string">&quot; pasted because the contents and the &quot;</span></span><br><span class="line">                              <span class="string">&quot;selected area aren&#x27;t the same size.&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">        QStringList columns = rows[i].<span class="built_in">split</span>(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numColumns; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> row = range.<span class="built_in">topRow</span>() + i;</span><br><span class="line">            <span class="type">int</span> column = range.<span class="built_in">leftColumn</span>() + j;</span><br><span class="line">            <span class="keyword">if</span> (row &lt; RowCount &amp;&amp; column &lt; ColumnCount)</span><br><span class="line">                <span class="built_in">setFormula</span>(row, column, columns[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">somethingChanged</span>();        <span class="comment">// 手动触发槽，其中 emit modified() 信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::del</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QTableWidget::selectedItems 原生函数</span></span><br><span class="line">    QList&lt;QTableWidgetItem*&gt; items = <span class="built_in">selectedItems</span>();</span><br><span class="line">    <span class="keyword">if</span> (!items.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="comment">// Qt 自带的 foreach，模仿 Java</span></span><br><span class="line">        foreach (QTableWidgetItem* item, items)</span><br><span class="line">            <span class="keyword">delete</span> item;</span><br><span class="line">        <span class="built_in">somethingChanged</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用了那么多次自定义的 <code>selectedRange()</code> 函数，现在看看如何实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTableWidgetSelectRange <span class="title">HolySheet::selectedRange</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QTableWidget::selectedRanges() 原生函数</span></span><br><span class="line">    <span class="comment">// 返回放置所有选中的、连续区域对应的 QTableWidgetSelectionRange</span></span><br><span class="line">    QList&lt;QTableWidgetSelectionRange&gt; ranges = <span class="built_in">selectedRanges</span>();</span><br><span class="line">    <span class="keyword">if</span> (ranges.<span class="built_in">isEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QTableWidgetSelectRange</span>();</span><br><span class="line">    <span class="comment">// 还记得吗？之前设置 setSelectionMode(ContiguousSelection)</span></span><br><span class="line">    <span class="comment">// 只会选择连续区域的单元格，所以 ranges 的 size 只会是 0 或 1</span></span><br><span class="line">    <span class="keyword">return</span> range.<span class="built_in">first</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看 <code>MainWindow</code> 的菜单栏中 <code>select</code> 子菜单中，有两个功能（另外一个 <code>selectAll</code> 函数就是 <code>QTableWidget</code> 的原生函数，不用写，直接 <code>connect</code> 就行），一个是 <code>select column</code>，另一个是 <code>select row</code>，它们就是选定当前选中单元格所在的列 / 行，只需要交给原生的 <code>QTableWidget::selectColumn/selectRow(int)</code> 就行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::selectCurrentRow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">selectRow</span>(<span class="built_in">currentRow</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::selectCurrentColumn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">selectColumn</span>(<span class="built_in">currentColumn</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再实现心心念念的 <code>findNext</code>、<code>findPrev</code>（早在 <code>findDialog</code> 的编写上就看到了）：</p><blockquote><p>注意：无论是向前找，还是向后找，都是从当前选中位置开始的，这是共识</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::findNext</span><span class="params">(<span class="type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为要找下一个，所以从同一行、下一列开始</span></span><br><span class="line">    <span class="comment">// 思考：为什么这里不用考虑出界？——有 while 循环条件保证</span></span><br><span class="line">    <span class="type">int</span> row = <span class="built_in">currentRow</span>(), column = <span class="built_in">currentColumn</span>() + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (row &lt; RowCount) &#123;</span><br><span class="line">        <span class="keyword">while</span> (column &lt; ColumnCount) &#123;</span><br><span class="line">            <span class="comment">// QString::contains(QString, Qt::CaseSensitivity) 原生函数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">text</span>(row, column).<span class="built_in">contains</span>(str, cs)) &#123;</span><br><span class="line">                <span class="built_in">clearSelection</span>();    <span class="comment">// 清除当前选择</span></span><br><span class="line">                <span class="built_in">setCurrentCell</span>(row, column);    <span class="comment">// 选择到下一个符合要求的格子</span></span><br><span class="line">                <span class="built_in">activateWindow</span>();    <span class="comment">// 焦点落回表格</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++column;</span><br><span class="line">        &#125;</span><br><span class="line">        column = <span class="number">0</span>; ++row;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使系统鸣叫一下，表示没找到</span></span><br><span class="line">    QApplication::<span class="built_in">beep</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::findPrev</span><span class="params">(<span class="type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为要查找上一个，所以从同一行、上一列开始</span></span><br><span class="line">    <span class="type">int</span> row = <span class="built_in">currentRow</span>(), column = <span class="built_in">currentColumn</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (row &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (column &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">text</span>(row, column).<span class="built_in">contains</span>(str, cs)) &#123;</span><br><span class="line">                <span class="built_in">clearSelection</span>();</span><br><span class="line">                <span class="built_in">setCurrentCell</span>(row, column);</span><br><span class="line">                <span class="built_in">activateWindow</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --column;</span><br><span class="line">        &#125;</span><br><span class="line">        column = ColumnCount - <span class="number">1</span>;</span><br><span class="line">        --row;</span><br><span class="line">    &#125;</span><br><span class="line">    QApplication::<span class="built_in">beep</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来实现支持 <code>MainWindow</code> 的 <code>Tools</code> 和 <code>Options</code> 菜单的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此函数是将所有单元格全部遍历一遍，并标记存在数据的 cell 实例，</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::recalculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; RowCount; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> column = <span class="number">0</span>; column &lt; ColumnCount; ++column) &#123;</span><br><span class="line">            <span class="comment">// Cell::setDirty() 等待实现</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cell</span>(row, column)) <span class="built_in">cell</span>(row, column)-&gt;<span class="built_in">setDirty</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面对于所有有数据的格子都调用了 setDirty()，</span></span><br><span class="line">    <span class="comment">// 接下来调用原生函数 QTableWidget::viewpoint() 获得全局视口</span></span><br><span class="line">    <span class="comment">// 对视口（类型）更新重新绘制 update()，调用每一个 “dirty” 的格子重新计算 text</span></span><br><span class="line">    <span class="built_in">viewport</span>()-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置自动重计算</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::setAutoRecalculate</span><span class="params">(<span class="type">bool</span> recalc)</span> </span>&#123;</span><br><span class="line">    autoRecalc = recalc;</span><br><span class="line">    <span class="keyword">if</span> (autoRecalc) <span class="built_in">recalculate</span>();    <span class="comment">// 设置后立即先生效一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-5-表格的排序功能"><a href="#4-3-5-表格的排序功能" class="headerlink" title="4.3.5 表格的排序功能"></a>4.3.5 表格的排序功能</h3><p>接下来解释 <code>HolySheetCompare</code> 类 和 <code>HolySheet::sort()</code> 排序的实现原理。</p><p>首先，我们要想起 <code>sort</code> 操作的用户使用方法就是：<strong>先选中一个区域，然后在弹出的 <code>sortDialog</code> 对话框中选择第一、二、三键（比较的列数）和升降序的要求，最终程序按数据和要求排序</strong>；</p><p><strong>我们简单设计给表格排序的算法</strong>：</p><ol><li><p>将选中的区域分割成 <strong>行列表</strong>（每一行在一个列表中，不同列的作为列表的不同元素），对这些行列表进行编号；</p></li><li><p>使用 Qt 自带的 <code>qStableSort</code> 算法（看到名字就知道是稳定的排序算法），它的参数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemT</span>&gt;</span><br><span class="line"><span class="built_in">qStableSort</span>(</span><br><span class="line">    QList&lt;elemT&gt;::iterator iter_start,</span><br><span class="line">    QList&lt;elemT&gt;::iterator iter_end,</span><br><span class="line">    <span class="built_in">bool</span> (comp)(elemT obj1, elemT obj2)    <span class="comment">// 这不是正规写法，源代码是typename</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中 <code>comp</code> 函数指针<strong>一定要对传入的所有可能的 <code>elemT</code> 类数据都能比较</strong>，要求：<strong>如果第一参数小于第二参数，则返回 <code>true</code>，反之无论如何返回 <code>false</code>，那么最后是升序排序</strong>；</p><blockquote><p>如果想降序，只要让 <code>comp</code> 指向的函数在大于关系时返回 <code>true</code> 就行；</p></blockquote><p>这里利用传入的将行列表作为排序的最小单元，所以传给 <code>qStableSort</code> 的第一、二参数都会是 <code>QList&lt;QStringList&gt;</code> 类型；第三个参数的函数指针<strong>是设计的核心</strong>，类型要求：<code>bool (comp)(QStringList, QStringList)</code>，<strong>并且能够按 <code>QStringList</code> 中指定的键进行依此排序</strong>；</p></li><li><p>最后只需把排序好的 <code>QList&lt;QStringList&gt;</code> 重新写入当前列表，并且标记为 “modified” 就完成了。</p></li></ol><p>为了完成上面的第二步的要求，我们设计出了 <code>HolySheetCompare</code> 类，使其<strong>不仅能够保存用户排序的需求信息，还能并且能够按用户指定的键进行元素先后判别</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.h</span></span><br><span class="line"><span class="keyword">namespace</span> hsCompare &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> KeyCount = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> hsCompare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HolySheetCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里重载括号运算符，使得这个类能有函数一样的行为：compare(A, B) -&gt; bool</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> QStringList&amp; row1, <span class="type">const</span> QStringList&amp; row2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 保存第 n 键在 QStringList 中的索引</span></span><br><span class="line">    <span class="type">int</span> keys[KeyCount];</span><br><span class="line">    <span class="comment">// 保存第 n 键是否为升序</span></span><br><span class="line">    <span class="type">bool</span> ascending[KeyCount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里是实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HolySheetCompare::operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> QStringList&amp; row1, <span class="type">const</span> QStringList&amp; row2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第一键到第三键，如果当前键比较的数据不同，那么可以得出结果，结束单次比较；</span></span><br><span class="line">    <span class="comment">// 否则，进入下一键的比较；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KeyCount; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> column = keys[i];    <span class="comment">// 当前比较的键的列索引</span></span><br><span class="line">        <span class="comment">// -1 的含义是用户没有要求这个键（对应 comboBox 界面中的 None）</span></span><br><span class="line">        <span class="comment">// column != -1 说明用户选择了这个键（要比较，否则就不比了）</span></span><br><span class="line">        <span class="keyword">if</span> (column != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(row1[column] != row2[column]) &#123;    <span class="comment">// 说明这个键就能得出结果</span></span><br><span class="line">                <span class="comment">// qStableSort 的要求。详细见上面的参数分析</span></span><br><span class="line">                <span class="keyword">if</span> (ascending[i]) <span class="keyword">return</span> row1[column] &lt; row2[column];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> row1[column] &gt; row2[column];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果本键相同，说明无法比较，需要进行下一个键的比较</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// 所有能比较的键都比完了，还是相同（不是小于），所以返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就能完整实现 <code>HolySheet::sort</code> 函数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheeet::sort</span><span class="params">(<span class="type">const</span> HolySheetCompare&amp; compare)</span> </span>&#123;</span><br><span class="line">    QList&lt;QStringList&gt; rows;    <span class="comment">// 行列表</span></span><br><span class="line">    QTableWidgetSelectionRange range = <span class="built_in">selectedRange</span>();</span><br><span class="line">    <span class="type">int</span> i;    <span class="comment">// 提出来，因为频繁用到计数变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历每一行</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; range.<span class="built_in">rowCount</span>(); ++i) &#123;</span><br><span class="line">        QStringList curRow;    <span class="comment">// 当前读到的行</span></span><br><span class="line">        <span class="comment">// 对当前行的每一列遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; range.<span class="built_in">columnCount</span>(); ++i)</span><br><span class="line">            curRow.<span class="built_in">append</span>(formula(range.<span class="built_in">topRow</span>() + i,</span><br><span class="line">                                  range.<span class="built_in">leftColumn</span>() + j));</span><br><span class="line">        rows.<span class="built_in">append</span>(curRow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qStableSort</span>(rows.<span class="built_in">begin</span>(), rows.<span class="built_in">end</span>(), compare);</span><br><span class="line">    <span class="comment">// 把行列表放回原位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; range.<span class="built_in">rowCount</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; range.<span class="built_in">columnCount</span>(); ++j)</span><br><span class="line">            <span class="built_in">setFormula</span>(range.<span class="built_in">topRow</span>() + i,</span><br><span class="line">                       range.<span class="built_in">leftColumn</span>() + j,</span><br><span class="line">                       rows[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">clearSelection</span>();    <span class="comment">// 排序完清除选中</span></span><br><span class="line">    <span class="built_in">somethingChanged</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-6-表格的公式计算实现"><a href="#4-3-6-表格的公式计算实现" class="headerlink" title="4.3.6 表格的公式计算实现"></a>4.3.6 表格的公式计算实现</h3><p>到此为止，<code>HolySheet</code> 的全部要求都实现完毕，现在进行 <code>Cell</code> 的定义和实现，一举解决公式计算问题。</p><p>根据上面 <code>HolySheet</code> 类对于 <code>Cell</code> 的请求，<code>Cell</code> 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: Cell.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QTableWidgetItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 Cell 类不需要信号-槽机制，所以就不需要 Q_OBJECT 宏</span></span><br><span class="line"><span class="comment">// 更何况 QTableWidgetItem 并不是由 QObject 派生而来</span></span><br><span class="line"><span class="comment">// 这也是为了让项（item）的开销尽可能地低、访问效率尽可能地高</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span> : <span class="keyword">public</span> QTableWidgetItem &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cell</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFormula</span><span class="params">(<span class="type">const</span> QString&amp; formula)</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">formula</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDirty</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下没见过的函数 / 数据成员，会在后面讲它们的含义</span></span><br><span class="line">    <span class="function">QTableWidgetItem* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> role, <span class="type">const</span> QVariant&amp; value)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QVariant <span class="title">data</span><span class="params">(<span class="type">int</span> role)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">QVariant <span class="title">value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前缓存的单元格的值</span></span><br><span class="line">    <span class="keyword">mutable</span> QVariant cachedValue;</span><br><span class="line">    <span class="comment">// 这个值是否不是最新的，即：是否需要更新</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> cacheIsDirty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先解释基础 C++ 知识（和 Qt 没关系）——什么是 <code>mutable</code> 关键字。在 C++ 面向对象中，<code>const(constant)</code> 和 <code>mutable</code> 是一对含义恰好相反的关键字。</p><p>考虑这个场景：<strong>如果我有个函数（<code>func_1</code>），只想改变一个数据成员（<code>A</code>），其他（<code>B/C/D/...</code>）变量都不允许它改变，想要保护起来。</strong>为了<strong>强调</strong> “保护数据成员” 这一要求，我们可能会想把 <code>func_1</code> 声明为 <code>const</code> 常量函数，但是怎么能改到 <code>A</code> 呢？</p><p>没错！把 <code>A</code> 声明为 <code>mutable</code> 变量就行了！<strong>所谓 <code>mutable</code> 关键字的作用就是：类中的、凡被此关键字修饰的数据成员，都可以被常量函数修改！</strong>这样做可以起到一个作用：强调 “这个静态函数不会修改其他任何数据” 的特点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: Cell.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Cell.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Cell::<span class="built_in">Cell</span>() &#123; <span class="built_in">setDirty</span>(); &#125;    <span class="comment">// 构造函数意思是单元格刚创建时，就需要更新</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cell::setDirty</span><span class="params">()</span> </span>&#123; cacheIsDirty = <span class="literal">true</span>; &#125;    <span class="comment">// 当前 cell 设置需要更新</span></span><br></pre></td></tr></table></figure><p>这里没必要传递父对象，因为当你 <code>new</code> 一个 <code>Cell</code> 对象，并且用 <code>setItem()</code> 插入到 <code>QTableWidget</code> 当中时，<code>QTableWidget</code> 会<strong>自动获得对该 <code>Cell</code> 对象的控制权，也会自动帮您析构</strong>。</p><h3 id="4-3-7-补充：QTableWidgetItem-类的机理简介"><a href="#4-3-7-补充：QTableWidgetItem-类的机理简介" class="headerlink" title="4.3.7 补充：QTableWidgetItem 类的机理简介"></a>4.3.7 补充：<code>QTableWidgetItem</code> 类的机理简介</h3><p>现在也不得不回答，之前提出的问题：<strong>“为什么在 <code>HolySheet</code>、<code>Cell</code> 里面都只有 <code>setFormula</code>，没有 <code>setText</code>，但却说 ‘公式和文本分开存储’ 呢？”</strong></p><p>实际上，在上面 <code>Cell.h</code> 的声明中也能看到，<code>Cell</code> 和它的父类都采用 <strong><code>role</code> 参数来控制 <code>Data</code> 的方法，而这就是 <code>QTableWidgetItem</code> 的设计。</strong></p><p>在 Qt 中有几个枚举值：<code>Qt::DisplayRole</code>、<code>Qt::EditRole</code>、<code>Qt::TextAlignmentRole</code>，用来指定 <code>QTableWidgetItem</code> 存储数据的 “不同模式”：</p><ul><li><code>Qt::EditRole</code> 表示编辑模式，指的是单元格的原始内容（raw）；</li><li><code>Qt::DisplayRole</code> 表示显示模式，指的是单元格的显示内容；</li><li><code>Qt::TextAlignmentRole</code> 表示对齐样式模式，指的是单元格的对齐方式；</li></ul><p>无论是原式内容，还是显示内容，都由 <code>QTableWidgetItem::data(Qt::role)</code> 这个原生原生函数统一返回。在默认情况下，<code>QTableWidgetItem</code> 的显示内容和原始内容是一模一样的。</p><p><strong>但是我们的程序是模仿 Excel 表格，要处理公式——于是乎，我们自定义了 <code>data(Qt::role)</code> 函数，使得公式所在单元格的显示内容和原始内容可能不一样</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QVariant <span class="title">Cell::data</span><span class="params">(<span class="type">int</span> role)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用方想要获得显示模式（已计算）的信息</span></span><br><span class="line">    <span class="keyword">if</span> (role == Qt::DisplayRole) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">value</span>().<span class="built_in">isValid</span>()) <span class="keyword">return</span> <span class="built_in">value</span>().<span class="built_in">toString</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;####&quot;</span>;    <span class="comment">// 计算失败，不符语法的公式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用方想要获得显示模式中，内容（已计算）显示的格式</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (role == Qt::TextAlignmentRole) &#123;</span><br><span class="line">        <span class="comment">// 如果里面存的是字符串（已计算）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">value</span>().<span class="built_in">type</span>() == QVariant::String) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(Qt::AlignLeft | Qt::AlignVCenter); <span class="comment">//垂直居中，左对齐</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果里面存的是数据（已计算）</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(Qt::AlignRight | Qt::AlignVCenter);<span class="comment">//垂直居中，右对齐</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用方想要获得表格的原始内容</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的方法，将格子中的所有数据原封不动地给调用方</span></span><br><span class="line">        <span class="keyword">return</span> QTableWidgetItem::<span class="built_in">data</span>(role);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先解释一下上面的 <code>if (value().isValid())</code>：这个 <code>Cell::value()</code> 是等会会实现的自定义函数，<strong>用来从 EditRole 的原始内容计算出 DisplayRole 的展示内容，换言之，这个函数用来计算公式的！！！</strong></p><p>只有当 “文本是公式，并且不符合语法“的，<code>value()</code> 函数才会返回 <code>QVariant()</code>，其他的无论是<strong>纯文本（原封不动）</strong>，还是<strong>符合语法的公式（解析得到答案）</strong>都会返回有数据的 <code>QVariant</code> 实例。</p><p>大家可能会奇怪，<code>QVariant::isValid()</code> 是用来判断什么有效的？事实上，<strong>只有使用 <code>QVariant</code> 的默认构造函数构造（无参数）出来的实例，其 <code>isValid()</code> 返回值才是 <code>false</code>，其他含有数据的实例都是 <code>true</code></strong>。</p><p>现在就能解释 “为什么只有 <code>setFormula</code> 没有 <code>setText</code>” 的问题。</p><p>因为 <code>QTableWidgetItem::text()</code> 是原生函数（这里 <code>Cell</code> 类没有覆写，因为满足要求），在内部会调用 <code>QTableWidgetItem::data(Qt::DisplayRole)</code>。也就是说：<strong><code>text()</code> 获取的是 “展示模式” 的数据，<code>formula()</code> 获取的是 原始数据</strong>。</p><p>所以，我们只需要设置原始数据（<code>Cell::setFormula</code>，更底层调用 <code>Cell::setData</code>）、设置原始数据的计算方式（<code>Cell::value</code> 及相关函数），就能让展示模式、原始内容各自呈现出我们想要的内容！</p><p>既然我们现在知道了 <code>setFormula</code>、<code>formula</code>、<code>value</code>、 <code>setData</code> 的作用，现在我们分别实现它们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cell::setFormula</span><span class="params">(<span class="type">const</span> QString&amp; formula)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用底层自定义的 data 设置原始内容</span></span><br><span class="line">    <span class="built_in">setData</span>(Qt::EditRole, formula);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">Cell::formula</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用自定义的 data 以 QString 形式返回原始数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>(Qt::EditRole).<span class="built_in">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写底层的 QTableWidgetItem::setData，添加一个 “标记 dirty” 的功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cell::setData</span><span class="params">(<span class="type">int</span> role, <span class="type">const</span> QVariant&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置数据的功能和父类一样</span></span><br><span class="line">    QTableWidgetItem::<span class="built_in">setData</span>(role, value);</span><br><span class="line">    <span class="comment">// 增添的是标记功能</span></span><br><span class="line">    <span class="keyword">if</span> (role == Qt::EditRole)</span><br><span class="line">        <span class="built_in">setDirty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>Cell::setData</code> 的 <code>if (role == Qt::EditRole)</code>，有同学可能会问，为啥要判断一下？既然修改了，直接 <code>setDirty</code> 不就行？其实不是这样。</p><p>前面说了，用户只能改原始数据 （<code>Qt::EditRole</code>）；而展示数据（<code>Qt::DisplayRole</code>）是程序内部计算公式 / 纯文本的时候才会更改。<code>setDirty</code> <strong>只需要，也只能</strong> 标记用户的修改行为。一旦标记了机器的修改行为，轻则浪费系统资源，重则会陷入 “机器更新展示数据 -&gt; <code>setDirty</code> -&gt; 机器更新展示数据 -&gt; …” 的<strong>死循环</strong>中。</p><p>继续：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里偷个懒，用我很早以前写的简易计算器程序，支持+-*/^()运算</span></span><br><span class="line"><span class="comment">// 简易计算器不在这里展示，详情请看项目源码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value() 底层函数，用于计算原始数据</span></span><br><span class="line"><span class="comment">// 是纯文本 / 符合语法的公式 -&gt; return QVariant(计算结果)</span></span><br><span class="line"><span class="comment">// 是不符合语法的公式 -&gt; return QVariant()，可以被 isValid() 发现</span></span><br><span class="line"><span class="function">QVariant <span class="title">Cell::value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cacheIsDirty) &#123;</span><br><span class="line">        cacheIsDirty = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        QString formulaStr = formula();</span><br><span class="line">        <span class="keyword">if</span> (formulaStr.<span class="built_in">startsWith</span>(<span class="string">&#x27;\&#x27;&#x27;</span>))    <span class="comment">// 单引号引起的内容代表纯文本</span></span><br><span class="line">            cachedValue = formulaStr.<span class="built_in">mid</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (formulaStr.<span class="built_in">startsWith</span>(<span class="string">&#x27;=&#x27;</span>)) &#123;    <span class="comment">// 以等号开头的是公式</span></span><br><span class="line">            cachedValue = <span class="built_in">QVariant</span>();</span><br><span class="line">            <span class="comment">// 将中缀表达式中所有变量（正则式如下）全部递归替换为已计算内容</span></span><br><span class="line">            <span class="function">QRegularExpression <span class="title">exp</span><span class="params">(<span class="string">&quot;([a-zA-Z][1-9][0-9]&#123;0,2&#125;)&quot;</span>)</span></span>;</span><br><span class="line">            QRegularExpressionMatch curMatch;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                curMatch = exp.<span class="built_in">match</span>(formulaStr);</span><br><span class="line">                <span class="keyword">if</span> (!curMatch.<span class="built_in">hasMatch</span>()) <span class="keyword">break</span>;</span><br><span class="line">                QString var = curMatch.<span class="built_in">captured</span>(<span class="number">1</span>);</span><br><span class="line">                QChar tmp = var[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> column = tmp.<span class="built_in">toInt</span>(), row = var.<span class="built_in">mid</span>(<span class="number">1</span>).<span class="built_in">toInt</span>() - <span class="number">1</span>;</span><br><span class="line">                Cell* varCell = <span class="built_in">static_cast</span>&lt;Cell*&gt;(</span><br><span class="line">                    <span class="built_in">tableWidget</span>()-&gt;<span class="built_in">item</span>(row, column)</span><br><span class="line">                );</span><br><span class="line">                QString cur;</span><br><span class="line">                <span class="keyword">if</span> (varCell) cur = varCell-&gt;<span class="built_in">text</span>();    <span class="comment">// 递归替换内容</span></span><br><span class="line">                <span class="keyword">else</span> cur = <span class="string">&quot;0.0&quot;</span>;</span><br><span class="line">                formulaStr.<span class="built_in">replace</span>(</span><br><span class="line">                    formulaStr.<span class="built_in">indexOf</span>(var),    <span class="comment">// offset</span></span><br><span class="line">                    var.<span class="built_in">size</span>(),                    <span class="comment">// length</span></span><br><span class="line">                    cur                            <span class="comment">// new string</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="function">calc <span class="title">calculator</span><span class="params">(formulaStr.toStdString().c_str())</span></span>;</span><br><span class="line">                cachedValue = calculator.<span class="built_in">getResult</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (exprErr err) &#123;    <span class="comment">// 公式计算错误</span></span><br><span class="line">                QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                                    <span class="built_in">tr</span>(err.<span class="built_in">what</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;    <span class="comment">// 是纯文本，但不清楚是不是纯数字</span></span><br><span class="line">            <span class="type">bool</span> ok;    <span class="comment">//能否转换为数字</span></span><br><span class="line">            <span class="type">double</span> d = formulaStr.<span class="built_in">toDouble</span>(&amp;ok);</span><br><span class="line">            <span class="keyword">if</span> (ok) cachedValue = d;        <span class="comment">// 赋值为双精度浮点数</span></span><br><span class="line">            <span class="keyword">else</span> cachedValue = formulaStr;    <span class="comment">// 只能作为字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后可能需要覆写一个父类里的函数 <code>QTableWidget::clone()</code>，它的作用是，当用户在表格中从未创建过的单元格中写入数据时，自动调用 <code>clone()</code> 传递给之前的 <code>QTableWidget::setItemPrototype()</code>，这里需要用 <code>Cell</code> 类 <code>new</code>，不能用父类来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTableWidgetItem* <span class="title">Cell::clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Cell</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样返回的虽然是父类指针，但是指向子类的对象，在 <code>setItemPrototype</code> 函数里会转换回去，所以满足要求。</p><hr><p>至此，<code>Cell</code>、<code>HolySheet</code> 类已经全部完成，现在只需要回到 <code>MainWindow</code> 中，把剩下还没加入的一些 <code>Action</code> 添加进去，<strong>整个程序就完成了</strong>！</p><p>如果你不是 IDE 用户，别忘了写一写 <code>CMakeLists.txt/Makefile</code> 或者运行运行 <code>qmake</code>，把项目跑起来吧 ~</p><h2 id="4-4-章末总结-amp-下文预告"><a href="#4-4-章末总结-amp-下文预告" class="headerlink" title="4.4 章末总结 &amp; 下文预告"></a>4.4 章末总结 &amp; 下文预告</h2><p>下面是本人总结的 Qt 5 类图，和上次总结相比，非常非常地长。需要 <code>*.xmind/*.pdf/*.png</code> 格式的同学可以联系本人 ~</p><p><img src="C4.png"></p><p><strong>同系列下一篇文章预告：将会是关于 Qt 的 <code>event</code>（事件）、图形绘制 和 游戏的内容。</strong></p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Qt </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023 HDC 参会笔记与感悟</title>
      <link href="//literary/2023-hdc/"/>
      <url>//literary/2023-hdc/</url>
      
        <content type="html"><![CDATA[<p><i>Author: SJTU-XHW</i></p><p><i>Language: Simple Chinese</i></p><p><i>License:</i> <a href="https://creativecommons.org/licenses/by/4.0/deed.cy">CC BY 4.0</a></p><p><i>本人学识有限，内容难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><p>注：在笔记的 <a href="#display">这里</a> 你可以体验有趣的 WebXR 的项目 Demo ~</p><hr><h1 id="8-月-4-日"><a href="#8-月-4-日" class="headerlink" title="8 月 4 日"></a>8 月 4 日</h1><h2 id="主会场：HarmonyOS-4-与-SDK-主题演讲"><a href="#主会场：HarmonyOS-4-与-SDK-主题演讲" class="headerlink" title="主会场：HarmonyOS 4 与 SDK 主题演讲"></a>主会场：HarmonyOS 4 与 SDK 主题演讲</h2><h3 id="一、-Harmony-4-UX-设计"><a href="#一、-Harmony-4-UX-设计" class="headerlink" title="一、 Harmony 4 UX 设计"></a>一、 Harmony 4 UX 设计</h3><ul><li><p>系统输入法表情更新：上千个专属定制的 <code>unicode</code> 表情符号，精细化表情符号所代表的语义；</p><ul><li>举例：一碗面条所对应的表情就有 4 种之多，提供 “宽面”、“窄面”，“拌面”、“汤面” 之选择；</li></ul></li><li>结合 HarmonyOS 4 图像识别处理的技术，用户可以 <strong>定制 “以自己主角” 的壁纸、主题</strong>，体现个性化界面设计之美；</li><li>系统界面 UI 焕然一新，同时给用户和开发者提供更多不同的<strong>窗口组件</strong>；</li></ul><h3 id="二、-Security"><a href="#二、-Security" class="headerlink" title="二、 Security"></a>二、 Security</h3><ul><li><p>细化权限控制粒度，最小化权限给予。将应用权限交由用户决定；</p><ul><li>举例：用户不允许透露的信息（如通讯录），可以采取提交 “虚假信息” 或者空信息的方法；</li></ul></li><li><p>优化应用行为跟踪的逻辑，可以由用户自己决定是否要关联；</p></li></ul><h3 id="三、-Widget"><a href="#三、-Widget" class="headerlink" title="三、 Widget"></a>三、 Widget</h3><ul><li>通知栏不仅仅按时间排序，更按种类归类，区分轻重缓急，不会胡乱堆砌；</li><li>窗口小组件 和 负一屏 连通各个应用，例如<strong>快递/外卖的进程</strong>，<strong>天气组件关联桌面壁纸</strong>等等；</li><li><strong>应用流转</strong>，如分布式相机，端到端间 <strong>各种文件在各个界面的拖放/拉取</strong>；</li></ul><h3 id="四、-小艺"><a href="#四、-小艺" class="headerlink" title="四、 小艺"></a>四、 小艺</h3><ul><li>接入盘古大语言模型，提供模糊意图支持，语音书写通讯录、车辆设备控制……</li><li><strong>低代码编程能力</strong>：语言/文字输入意图，例如语音定制一个有特殊用途的桌面卡片组件（2 周前纪念日提醒等等）；</li></ul><h3 id="五、-Software【方舟引擎】"><a href="#五、-Software【方舟引擎】" class="headerlink" title="五、 Software【方舟引擎】"></a>五、 Software【方舟引擎】</h3><ul><li>GPU Turbo + 微内核调度 开销下降；</li><li>超帧方舟游戏引擎：编码加速、极速休眠；</li><li>超空间存储压缩引擎、动态内存引擎；</li><li>EROFS 文件系统；</li><li>拒绝 Linux 4k 小内存页管理，创新 4K、8K、16K、64K 的动态内存页管理，优化资源利用率；</li></ul><h3 id="六、-合作伙伴发言-amp-应用案例"><a href="#六、-合作伙伴发言-amp-应用案例" class="headerlink" title="六、 合作伙伴发言 &amp; 应用案例"></a>六、 合作伙伴发言 &amp; 应用案例</h3><ul><li>中国农业银行、网易、去哪儿旅行……</li></ul><h3 id="七、-SDK"><a href="#七、-SDK" class="headerlink" title="七、 SDK"></a>七、 SDK</h3><ul><li><p>便捷性：几行代码轻松设计配合系统 UI 的应用控件；</p><ul><li>案例：配合系统原生 UI 和 原生大模型接口，添加一个自定义信息显示卡片；</li></ul></li><li><p>独创 <strong>ArkTS 语言、方舟编译器及一系列开发套件</strong>，规避 JS-TS 开发生态的不足之处；</p><ul><li>结合 DevEco Studio，把模型接入开发、调试过程中；</li></ul></li><li>自动利用系统的大语言模型，帮助各个应用更智能地与用户交互；</li></ul><h1 id="8-月-5-日"><a href="#8-月-5-日" class="headerlink" title="8 月 5 日"></a>8 月 5 日</h1><blockquote><p>课程、论坛的种类很多，我只选了其中的两个论坛听；</p></blockquote><h2 id="Forum-1-Harmony-应用开发-新能力"><a href="#Forum-1-Harmony-应用开发-新能力" class="headerlink" title="Forum 1 Harmony 应用开发-新能力"></a>Forum 1 Harmony 应用开发-新能力</h2><h3 id="一、-ArkUI"><a href="#一、-ArkUI" class="headerlink" title="一、 ArkUI"></a>一、 ArkUI</h3><ul><li><p>ArkUI 框架功能集</p><p><img src="ArkUIFrame.jpg" height="275px"></p></li><li><p>组件节点能力提升</p><ul><li>细粒度组件分层设计，优化视觉 &amp; 交互效果；</li><li>轻量级图文混排的效果优化；</li><li>实时模糊效果，多种模糊材质可以选择；</li><li>组件级共享元素动画，页面内<strong>一镜到底</strong>；</li></ul></li><li><p>视觉 &amp; 动效增强</p><ul><li>可动画属性增多，更多开发自由度；</li><li>强大的拖拽能力，提供文件中转站；</li><li>更多开箱即用的组件工具，更多惊艳的视觉效果；</li></ul></li></ul><h3 id="二、-智慧生活应用-ArkUI"><a href="#二、-智慧生活应用-ArkUI" class="headerlink" title="二、 智慧生活应用 ArkUI"></a>二、 智慧生活应用 ArkUI</h3><ul><li>设备详情页实现方式：95% 终端设备（台灯/空调/打印机等）采用 H5 设计；5% 终端设备（路由器/摄像头等）采用<strong>原生平台开发</strong>，多平台，维护成本高；</li><li>“<strong>一次开发、两次编译、三平台部署</strong>”；</li><li>总结：ArkUI 跨平台框架开发的优势<ul><li>性能：Harmony OS <strong>原生渲染</strong>，Android / iOS 自渲染，<strong>持平竞品</strong>；</li><li>成本<ol><li>统一 ArkUI 范式，不需要额外框架；</li><li>声明式 UI 框架、丰富 UI 组件；</li></ol></li><li>能力<ol><li>支持动态加载，版本与宿主<strong>解耦</strong>；</li><li>跨平台支持 <strong>*.so </strong> 库，<strong>降低宿主 ROM 占用</strong>；</li></ol></li></ul></li></ul><h3 id="三、-ArkUI-跨平台方案的实现"><a href="#三、-ArkUI-跨平台方案的实现" class="headerlink" title="三、 ArkUI 跨平台方案的实现"></a>三、 ArkUI 跨平台方案的实现</h3><ul><li><p>ArkUI 的架构</p><p><img src="ArkUIMainFrame.jpg" height="275px"></p></li><li><p>新一代跨平台框架：<strong>ArkUI-X</strong>；</p><ul><li>扩展 ArkUI 支持跨平台的开源项目；</li><li>一次开发，多平台运行；</li><li>高性能<strong>方舟运行时</strong> + <strong>方舟渲染引擎</strong>；</li><li>生态统一的跨平台 API 能力集 + 扩展机制；</li><li>开发友好便捷，高代码复用性；</li></ul></li><li><p>命令行工具 <strong>ACE Tool</strong> 的使用</p></li><li><p>DevEco Studio IDE：跨平台 SDK 支持，运行时开销监测</p><ul><li>应用开发能力：Stage 模型 + Resource 支持 + 特化 UI 组件 + 支持 25+ 种 标准插件的 API；</li><li>应用测试能力：将资源检测、热点函数监控、行数定位的能力引入 IDE；</li><li>支持按模块集成（支持构建共享库）</li></ul></li></ul><h3 id="四、-元服务"><a href="#四、-元服务" class="headerlink" title="四、 元服务"></a>四、 元服务</h3><ul><li><p>定义：面向万物互联时代 HarmonyOS 的一种为用户提供更便捷服务的轻量级<strong>应用程序新形态</strong>；</p></li><li><p><strong>基于</strong> HarmonyOS API 开发，支持 <strong>1 + 8 + N（手机 + 电脑/平板/车载屏等 8 个平台 + N 个其他设备）</strong> 设备；</p></li><li><p>特征：随处可及、服务直达（免安装，卡片信息）、跨设备；</p></li><li><p>增强技术特性</p><ul><li><p>服务免安装提速：分包预加载；</p><p><img src="MetaService.jpg" height="200px"></p></li><li><p>卡片能力演进</p><ul><li>统一 ArkUI 卡片开发范式；</li><li>卡片自定义能力；</li><li>Push 刷新，卡片信息及时推送；</li></ul><p><img src="std.jpg" height="300px"></p></li><li><p>跨设备分享：元服务快速分享；</p></li><li><p>用户体验提升</p><ul><li>元服务<strong>即点即用，服务直达</strong>；</li><li>服务卡片<strong>便捷交互，信息直达</strong>；</li></ul></li></ul></li><li><p>元服务应用案例</p><ul><li>华为智慧生活；</li><li>讯飞听见，快速上线 + 图形翻译；</li></ul></li></ul><h3 id="五、-HarmonyOS-性能体验优化"><a href="#五、-HarmonyOS-性能体验优化" class="headerlink" title="五、 HarmonyOS 性能体验优化"></a>五、 HarmonyOS 性能体验优化</h3><ul><li><p>涉及性能的典型场景</p><ul><li>启动：启动时延；</li><li>点击响应：响应时延；</li><li>滑动/动效：帧率 60/90/120；</li></ul></li><li><p>编程模式影响</p><ul><li>同步 和 异步：异步模式。避免阻塞主线程；</li><li>命令式 和 声明式：状态变量驱动 UI 变更；</li></ul></li><li><p>关键流程</p><p><img src="pipline.jpg" height="260px"></p></li><li><p>关键优化方向</p><ul><li><p>语言</p><ul><li>编码建议</li><li>Taskpool 并行化</li><li>AOT + PGO 方舟编译器优化</li></ul><blockquote><p>解析时间：60ms -&gt; 0.725ms</p></blockquote></li><li><p>UI </p><ul><li>布局优化</li><li>节点复用</li></ul></li><li><p>动效</p><ul><li>图形动画优化：结合 Ark 动画引擎</li></ul></li><li><p>后台</p><ul><li><p>后台任务运行模型</p><p><img src="tasks.jpg"></p></li></ul></li></ul></li></ul><h3 id="六、-Cocos-验证-HarmonyOS-性能优化"><a href="#六、-Cocos-验证-HarmonyOS-性能优化" class="headerlink" title="六、 Cocos 验证 HarmonyOS 性能优化"></a>六、 Cocos 验证 HarmonyOS 性能优化</h3><ul><li><p>背景介绍</p><ul><li>游戏项目验证的原因<ul><li>CPU + GPU 利用率高；</li><li>对帧率敏感，不得低于 30；</li></ul></li><li>第一个适配 OpenHarmony 的游戏引擎；</li></ul></li><li><p>性能优化之旅</p><ul><li>AOT 优化（Ahead of Time）：能够在 Host 端将字节码提前编译成 Target 端可运行的机器码，这样字节码可以获得充分编译优化，放到 Target 端运行时可以获得加速；</li><li>优化方向<ul><li><strong>保存并完善 TS 源码类型信息（因为 TypeScript 打包为 JavaScript 时丢失变量类型信息）</strong>；</li><li>使用 <strong>PGO（Profile Guided Optimization）定位热点函数</strong>；</li></ul></li></ul></li><li><p>实现路径</p><ul><li>解决运行时问题；</li><li>Profile 工具分析热点函数；</li><li>TsAutoReturnType 自动补齐类型；</li><li>制定高性能编码规范；</li></ul></li></ul><h3 id="七、-HarmonyOS-端云开放能力"><a href="#七、-HarmonyOS-端云开放能力" class="headerlink" title="七、 HarmonyOS 端云开放能力"></a>七、 HarmonyOS 端云开放能力</h3><ul><li>华为账号接入；</li><li>软硬协同<ul><li>统一扫码服务实现方案；</li><li>Analytics Kit 能力框架；</li><li>Ad API；</li><li>Map 能力框架；</li></ul></li></ul><h3 id="八、-媒体生态一致性"><a href="#八、-媒体生态一致性" class="headerlink" title="八、 媒体生态一致性"></a>八、 媒体生态一致性</h3><ul><li><p>拍摄效果一致性</p><ul><li><p>系统相机 和 第三方相机 的 不一致问题的解决</p><p><img src="problem.jpg" height="200px"></p><p><strong>解决方案</strong>：</p><ol><li>统一接口，统一流程，统一效果；</li><li>分离预览、拍照、录像操作流，明确数据流的用途；</li></ol></li></ul></li><li><p>音视频焦点、时延、播控一致性</p><ul><li>音频焦点管理；</li><li>低时延播放；</li></ul></li></ul><h3 id="九、-HarmonyOS-文件存储技术进展"><a href="#九、-HarmonyOS-文件存储技术进展" class="headerlink" title="九、 HarmonyOS 文件存储技术进展"></a>九、 HarmonyOS 文件存储技术进展</h3><ul><li>端云一体的文件系统：<strong>统一数据管理框架 UDMF</strong>；</li><li>应用文件分享框架；</li><li>备份恢复框架；</li></ul><h3 id="十、-HarmonyOS-网络应用开发"><a href="#十、-HarmonyOS-网络应用开发" class="headerlink" title="十、 HarmonyOS 网络应用开发"></a>十、 HarmonyOS 网络应用开发</h3><ul><li>蜂窝网络；</li><li>HTTP 2-&gt;3；</li><li>指定 HTTP 合理优先级和数据类型；</li><li>建议支持 IPv4/6 双栈；</li></ul><h2 id="Forum-2-Huawei-AR-amp-VR"><a href="#Forum-2-Huawei-AR-amp-VR" class="headerlink" title="Forum 2 Huawei AR &amp; VR"></a>Forum 2 Huawei AR &amp; VR</h2><h3 id="一、-产业背景-和-资源"><a href="#一、-产业背景-和-资源" class="headerlink" title="一、 产业背景 和 资源"></a>一、 产业背景 和 资源</h3><ul><li><p>Devices：</p><ul><li><p>Head mounted displays</p></li><li><p>Controllers</p></li><li><p>Base station</p></li><li>Body / hand / Object / Eye Tracker</li><li>……</li></ul></li></ul><ul><li>想要获取 OpenXR 资源或者 API 文档：<ul><li><a href="https://registry.khronos.org/OpenXR/#apispecs">OpenXR API specs</a>；</li><li><a href="https://github.com/KhronosGroup/OpenXR-Tutorials">Github - OpenXR Tutorials</a>；</li></ul></li></ul><h3 id="二、-OpenXR"><a href="#二、-OpenXR" class="headerlink" title="二、 OpenXR"></a>二、 OpenXR</h3><ul><li><p>和 OpenGL 的地位很像，就是一种<strong>跨平台的 API 规范</strong>，适配各种标准 XR 设备；</p><blockquote><p>X 仅仅是占位符，可以代表 AR，VR，Mixed Reality等</p></blockquote></li><li><p>适配 Unreal、Unity 等游戏引擎；</p></li><li><p>最新应用：Kitware Paraview / Beat Saber；</p></li><li><p>工作小组：一致性测试（Conformance Test Suite），Input Device Plugin，5G/Cloud……</p></li><li><p>KHR / EXT：是否通过 CTS 验证的 lib；</p></li><li><p>OpenXR Resources；</p></li></ul><h3 id="三、-Metaverse"><a href="#三、-Metaverse" class="headerlink" title="三、 Metaverse"></a>三、 Metaverse</h3><ul><li>元宇宙的标准开发 与 元宇宙标准论坛：Metaverse Standard Forum (MSF)</li></ul><h3 id="四、-WebXR"><a href="#四、-WebXR" class="headerlink" title="四、 WebXR"></a>四、 WebXR</h3><ul><li><p>Web 并不局限于浏览器，具有 UA 和 对应的数据类型</p><blockquote><p>WebXR 基于 WebGL</p></blockquote></li><li><p>W3C Immersive Web 的工作组和标准</p><ul><li>开发资源 three.js + unity</li></ul></li><li><p>Web XR Core 的 API 规范</p></li></ul><h3 id="五、-Web3D-助力-WebXR"><a href="#五、-Web3D-助力-WebXR" class="headerlink" title="五、 Web3D 助力 WebXR"></a>五、 Web3D 助力 WebXR</h3><ul><li><p>WebXR 的背景</p><ul><li>Web3D 与 元宇宙同时产生于 1992 年；</li><li>元宇宙被称为新一代 3D 引擎技术；</li><li>元宇宙有互联网方面 3D 引擎的需求；</li><li>云渲染的计算/传输/运营成本大；</li><li>优势：用户的选择<ul><li>易用便捷普通去中心化；</li><li>上线访问随时随地随意；</li><li>上线创作任意场景任意操作多人协同；</li></ul></li></ul></li><li><p>Web3D 的痛点剖析</p><ul><li><p>总体量瓶颈：场景体量太大</p><ul><li>网络带宽却实在有限，相对于3D规模与体量的扩张显得越来越狭窄；</li><li>Web3D大数据的互联网传输之路永远都是一条 “窄路”；</li></ul></li><li><p>文件粒度瓶颈：目前的场景文件结构没有考虑到网络传输</p><ul><li>图形文件均以粗粒度模式来存储；</li><li>不利于网上在线加载与即时渲染的细粒度化调度处理；</li><li>网页端算力与缓存的双重受限；</li><li>传统的重量级粗粒度场景文件结构以及本地的场景管理需要改造；</li></ul></li><li><p>网络传输瓶颈</p><ul><li>初始加载时间过长，而用户容忍时长仅通常仅为秒级；</li><li>漫游时渐进式在线加载要流畅，因带宽堵塞而很容易导致网络瘫痪；</li><li>多人同步在线易造成服务器崩溃；</li></ul></li><li><p>网页端渲染瓶颈</p><ul><li>难以支撑在线渲染规模越来越大的场景；</li><li>难以达到在线实时全局光照的高品质渲染；</li></ul></li></ul></li><li><p><span id="display">关键技术</span></p><blockquote><p><strong>下面的 “教授的网页演示” 比较有趣，可以点击探索 ~ 不保证网站永久有效 ~</strong></p></blockquote><ul><li><p>建筑物细粒度化预处理</p></li><li><p>大规模树木群落的轻量级细粒度化处理：<a href="http://smartweb3d.com/forest/">教授的网页演示</a>；</p></li><li><p>海量 Web3D 数字孪生智慧工厂：<a href="http://smartweb3d.com/huayi">教授的网页演示</a>；</p></li><li><p>细粒度化边缘对等传输调度：<a href="http://smartweb3dlab.cn">教授的网页演示</a>；</p><blockquote><p>理论上人越多，速度越快；</p></blockquote></li><li><p>轻量级 Web3D 全局光照在线高品质渲染：<a href="http://116.225.120.225:8888/">教授的网页演示</a>；</p><blockquote><p>据教授说，一张 GTX 20 系的显卡就能实现 300+ 人同时在线；</p></blockquote><ul><li>大规模人群的轻量级细粒度化在线渲染：<a href="http://smartweb3d.com/gym/">教授的网页演示</a>；</li></ul></li></ul></li><li><p>总结</p><ul><li>OS层面：HarmonyOS 与轻量级在线 3D 关键技术融合；</li><li>浏览器层面：与轻量级 Web3D 引擎相融合；</li><li>通讯传输层面：三维元宇宙无穷大数据的部署与分布式传输调度协议；</li></ul></li></ul><h3 id="六、-华为-AR"><a href="#六、-华为-AR" class="headerlink" title="六、 华为 AR"></a>六、 华为 AR</h3><ul><li><p>华为的 AR 生态：AR Engine 全球 Top3 AR 开发引擎；</p></li><li><p>Instant AR 实现快速放置虚拟物体</p></li><li><p>环境跟踪 和 光照估计、实时环境构建、图像锚定、语义跟踪、表面 Mesh 跟踪；</p></li><li><p>人脸跟踪和人体跟踪：面部表情，人脸 mesh，头部位姿矩阵，2/3D 骨骼，姿态识别，人体 mask；</p></li><li><p>开发框架</p><p><img src="ARFrame.jpg" height="350px"></p></li><li><p>开发框架的难题</p><ol><li>跟踪手机的位置姿态，统一虚拟坐标系和物理坐标系；</li><li>识别桌面，锚定虚拟物体；</li><li>提供手机相机的实时参数，统一渲染引擎虚拟相机的相应参数；</li></ol></li></ul><h3 id="七、-华为-VR-Engine"><a href="#七、-华为-VR-Engine" class="headerlink" title="七、 华为 VR Engine"></a>七、 华为 VR Engine</h3><ul><li>VR 交互进展：手柄🎮交互，<strong>手眼交互</strong>【重要的是触觉反馈】，空间感知；</li><li>渲染领域：AI 画质增强，Smart Render 3.0【动态注视点，PTW】；</li><li>VR Engine 的 XR 框架；</li><li>端到端空间视频设计方案 + 体积视频部署案例；</li></ul><h3 id="八、-Cocos-CreatorXR"><a href="#八、-Cocos-CreatorXR" class="headerlink" title="八、 Cocos CreatorXR"></a>八、 Cocos CreatorXR</h3><ul><li>Cocos 数字内容生产平台<ul><li>Cocos 开发工具链的优势特点</li><li>Cocos 产品图谱</li></ul></li><li>CreatorXR 创作工具<ul><li>Cocos CreatorXR 的使用方法/工作流：5个步骤，一站式配置开发</li><li>集成了主流标准：WebGL OpenXR</li><li>同时支持：WebXR AR MR 构建创作</li></ul></li><li>共建 XR 内容生态<ul><li>持续为开发者提供完善快捷的跨平台开发工具；</li></ul></li><li>总结<ol><li>Cocos 3D 引擎轻量高效跨平台，适用于车机、元宇宙、游戏等各种业务场景；</li><li>CreatorXR 一站式创作工具，一次开发，多平台、多设备、多形式发布；</li><li>CocosXR Runtime安全轻量低功耗，系统级运行容器，快速推动生态繁荣；</li></ol></li></ul><h3 id="九、-Unity-打造高画质多交互的-XR-内容"><a href="#九、-Unity-打造高画质多交互的-XR-内容" class="headerlink" title="九、 Unity 打造高画质多交互的 XR 内容"></a>九、 Unity 打造高画质多交互的 XR 内容</h3><ul><li>Unity XR 新架构优势</li><li>Unity XR 开发者工具介绍<ul><li>XR Interaction Toolkit<ul><li>视频功能展示：UI 交互，套件交互，物体抓取，注视交互（XR Gaze Interaction）；</li></ul></li><li>AR Foundation；</li><li>MARS；</li></ul></li><li>Unity XR 新增功能介绍和使用<ul><li>New Input System for XR；</li><li>URP for XR；</li><li>HDRP for XR；</li></ul></li><li>Unity XR 相关案例</li></ul><h1 id="8月-6-日"><a href="#8月-6-日" class="headerlink" title="8月 6 日"></a>8月 6 日</h1><h2 id="活动：Codelabs-amp-体育馆展区"><a href="#活动：Codelabs-amp-体育馆展区" class="headerlink" title="活动：Codelabs &amp; 体育馆展区"></a>活动：Codelabs &amp; 体育馆展区</h2><ul><li>所需技术：ArkTS（<strong>TypeScript 的超集</strong>），简单的项目认知能力，会看 OpenHarmony 的文档，了解 DevEco Studio 的基本使用；</li><li>本人参与的 Tasks 有：HarmonyOS 页面 Scroller 二级联动的实现、HMS Core ML QRCode 识别程序补全、HMS Core Swap 产品购买程序的补全、OpenGallery Connect 程序的低代码开发和 UI 设计；</li></ul><h1 id="附录-Ⅰ-快讯整理"><a href="#附录-Ⅰ-快讯整理" class="headerlink" title="附录 Ⅰ  快讯整理"></a>附录 Ⅰ  快讯整理</h1><p>2023 年 8 月 4 日，华为开发者大会（HDC.Together）开幕演说在东莞篮球中心成功举行。华为发布了 HarmonyOS 4 和 全新升级的鸿蒙开发套件。另外，HarmonyOS Next 开发者预览版本等一系列领先技术也为用户提供前所未有的革新体验。</p><p>5 至 6 日，HDC 在三丫坡开设了数个开发者论坛供来自各地的工程师和技术研究人员进行学习和交流讨论。另外，现场的多个地点还设置了多种趣味性十足的闯关和运动游戏，让参会者们在学习讨论之余放松心情、锻炼身体。</p><p>最为火爆的是位于 B3 区的 Codelabs 活动，将华为 ArkUI 和 ArkTS 语言融入编程趣味挑战中，提供不同代码量、不同难度的闯关赛题。在学习到最新的优秀语言的同时，还能获得大量丰富的奖励。</p><h1 id="附录-Ⅱ-随笔-amp-感悟"><a href="#附录-Ⅱ-随笔-amp-感悟" class="headerlink" title="附录 Ⅱ  随笔 &amp; 感悟"></a>附录 Ⅱ  随笔 &amp; 感悟</h1><p>三天的时间一转眼就过去了，在东莞三丫坡召开的华为开发者大会在思维的碰撞和交流中落下帷幕。回顾这几天的经历，可以说是让我受益匪浅。会场内，来自不同国家的人们满怀激情和热忱，交流着技术观点；志愿者和工作人员在超过 30℃ 的天气下维护秩序、给参会者提供无微不至的帮助。</p><p>虽然目前我的学识有限，会议的内容我还无法全部理解，但是这里开放包容、开源共享的氛围，将激励着我努力学习，向我感兴趣的方向继续前进。</p><p><img src="more/oc.jpg"></p><p>我要感谢这次会议跟随我们的吴老师、李老师，还有安排这次活动的老师和工作人员，他们在我遇到某些问题时及时、热心地协助我解决。没有他们的帮助，我可能就无法享受到这次的视听盛宴。</p><p>我所参加的两个论坛，一个在 ArkUI 方面为开发者介绍了一种新语言 ArkTS（衍生自 TypeScript），这为我们展开了贴近于 HarmonyOS UI 设计的新方法；另一个论坛向我们介绍了关于华为 AR &amp; VR 方面的最新进展，基于 OpenXR 规范的 Web3D 和 鸿蒙 XR 的技术正不断成熟，开发生态也不断扩大。</p><hr><p>在本次大会的讨论中，有几项技术让我比较感兴趣，其中一个是华为独创的 <code>ArkUI</code> 及其配套的设计语言 <code>ArkTS</code>，它是 <code>TypeScript</code> 的超集，包含了绝大多数 TS 的语法，并且集成了新的 features，像 <code>@entry</code> annotation，还有更新颖、简洁的 UI 声明语法。</p><p>相较于 <code>HTML + CSS + JS</code> 三件套组织形式，华为的 <code>ArkTS</code> 则简化了编写人员的技术栈，在一个编码文件中轻松 handle 了 HarmonyOS 的控件外观设计。</p><p>在 Codelabs 活动中，我也上手初步认识了这样的一个开发流程，通过 AppGallery 和 HMS Core 等项目的补充实现，让我深深体会到这项技术是如此的便捷和优雅。</p><p><img src="more/mosaic.jpg"></p><hr><p>此外，工作人员还向我们介绍了 HarmonyOS 的软总线技术。他们强调，这种华为独创的技术能够成功地支持 <code>WI-FI / Bluetooth</code> 双通道连接，并且在传输文件的同时，优先选择速度更快的通道，并且<strong>切换对用户无感知</strong>，保证当前最大的传输速率。这是 Apple 等厂商所不具备的技术。</p><p><img src="more/dbus.jpg"></p><p>现场的工作人员还强调，在工业应用场景中，HarmonyOS 软总线会更注重 <strong>海量设备互联、发送的成功率</strong>，以确保满足大规模流量的实际应用场景。</p><p>作为 HarmonyOS 其他繁荣的上层应用的基石之一，软总线不仅需要速度和质量，更要安全。OpenHarmony 俱乐部也同时关注<strong>机密软总线</strong>的底层技术，相信能够为 HarmonyOS 的软总线的进一步发展提供更多优秀的思路。</p><hr><p>本次大会论坛的热点之一是华为 XR 技术，而同济大学的贾金原教授在 Web3D 和元宇宙方面所做的报告更是让我眼前一亮。从剖析 Web3D、WebXR 和元宇宙的背景和当前痛点出发，提供了数个全面提升视觉效果和渲染性能的算法。教授还在会上分享了多个超大规模的在线 Demo，同时具有十足的趣味性和启发性。</p><p><img src="more/XR.jpg"></p><p>这次的 HDC 让我收获到了很多，可以说是不虚此行！</p><h1 id="附录-Ⅲ-饮食-in-深圳-东莞"><a href="#附录-Ⅲ-饮食-in-深圳-东莞" class="headerlink" title="附录 Ⅲ  饮食 in 深圳/东莞"></a>附录 Ⅲ  饮食 in 深圳/东莞</h1><blockquote><p>“ <strong>有一千双手，就有一千种味道。中国烹饪，无比神秘，难以复制</strong> ”  —— <i>《舌尖上的中国》</i></p></blockquote><ul><li><p>茶餐厅比较有名。去里面吃饭貌似服务员会默认你带上一个饮品（奶茶/凉茶/红茶的种类挺多），好像是饮食习惯。平均单人价格 40+；</p></li><li><p>东莞这边的餐厅，汤汤水水的名称明显密集。让我极为震惊的是，汤的名字可谓各具特色——“川贝雪梨猪肺汤”、“五指毛桃猪骨汤”、“XX爪XX壳汤”（名字忘了），比较后悔的是没有拍个照片，每个汤的成分似乎都出在了我意料之外的地方（没有见识实锤，，</p></li><li><p>点名表扬 “XX鱼泡”（名字还是忘了），极薄的像馄饨皮一样的一层包裹着鱼肉丸，口感 Q 弹爽滑，还是比较吸引人的；</p></li><li><p>这里的卤味的“叉烧包”和我想象中的大相径庭：上海那边买到的叉烧包更像小煎包，大约是婴儿的拳头大小，可能灌汤；但这里的叉烧包更像馒头（不是指馅，指的是材质和大小），馅的话我点的是卤味，所以里面是 juicy 的五花肉和腊肠；</p></li><li><p>印象最深刻的是<strong>从内到外都呈现 <u>淡瓦片颜色</u> 的豆腐</strong>（不知道瓦片颜色的同学可以打开 “植物大战僵尸”，并从僵尸脸上取色）；味道比较奇妙，有一种腥味和豆腐原生的厚重的感觉杂糅在一起。很好奇是用什么手法做出来的，毕竟我见过的豆腐不都是白色的材质么。我们问了服务员做法是啥，服务员<strong>笑而不语</strong>（说吧，是商业机密还是科技狠活</p></li><li><p>这边有一种全新的烹饪方式我从未听说过：<strong>啫</strong>。说实话，菜单上有一片区域的菜名全部都以 “啫” 开头，我都误以为是加啫喱做出来的菜😂；晚上回去网上查了一下才发现这是<strong>粤菜的一种做法</strong>：</p><blockquote><p>生啫是将生的食材直接投入瓦煲内，加入味料和酱料，全程大火干烧至熟，不加入一滴水，因此，这种技法对瓦煲的杀伤力非常大，上边是生冷的食材，下边是猛烈的旺火，在一冷一热的刺激之下，瓦煲用上一、两次就会出现裂缝，而有裂缝的瓦煲就不能再循环使用了，如果勉强上阵，上一次啫时渗入裂缝中的油和肉汁就会跑出来，那股异味会传到这一次的食材里面。</p><p>而熟啫则是由于有个别食材特别难熟、或韧度特别大，所以前期必须要先经过熟处理才能拿来啫。</p><p>小声说：我们点的 “啫芥兰” 用的锅就裂开了，事后回想起难怪味道比较奇怪……</p></blockquote></li></ul><h1 id="附录-Ⅳ-大会园区美景"><a href="#附录-Ⅳ-大会园区美景" class="headerlink" title="附录 Ⅳ 大会园区美景"></a>附录 Ⅳ 大会园区美景</h1><p>图片由本人摄制。篇幅有限，只展示一部分。</p><p><img src="more/1.jpg"></p><p><img src="more/2.jpg"></p><p><img src="more/3.jpg"></p><p><img src="more/4.jpg"></p><p><img src="more/5.jpg"></p><p><img src="more/6.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> literary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDC </tag>
            
            <tag> HarmonyOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从C++入门Qt（一）</title>
      <link href="//technical/qt-for-beginners-1/"/>
      <url>//technical/qt-for-beginners-1/</url>
      
        <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: C++ GUI Programming with Qt 4 (2nd Edition) </i></p><p><i>注意：本文章将讲解 <strong>Qt 5</strong> 入门知识，需要一定的 C++ 基础</i></p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p><strong>观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~</strong></p><hr><span id="more"></span><h1 id="Chapter-0-前置知识"><a href="#Chapter-0-前置知识" class="headerlink" title="Chapter 0 前置知识"></a>Chapter 0 前置知识</h1><h2 id="0-1-C-基础-和-面向对象编程"><a href="#0-1-C-基础-和-面向对象编程" class="headerlink" title="0.1 C++ 基础 和 面向对象编程"></a>0.1 C++ 基础 和 面向对象编程</h2><h2 id="0-2-C-的宏（macro）"><a href="#0-2-C-的宏（macro）" class="headerlink" title="0.2 C++ 的宏（macro）"></a>0.2 C++ 的宏（macro）</h2><ul><li>宏的定义非常自由甚至可以把一个符号定义为一个很长的字符串，甚至代码；主要是因为宏的工作原理是<strong>编译前将宏直接原封不动地替换</strong>；例如下面的极端例子：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接把 HELLO 定义为一串代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLO \</span></span><br><span class="line"><span class="meta">    QLabel* label = new QLabel(<span class="string">&quot;&lt;h2&gt;&lt;i&gt;Hello,&lt;/i&gt;&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;&quot;</span>);\</span></span><br><span class="line"><span class="meta">    QPushButton* btn = new QPushButton(<span class="string">&quot;Quit&quot;</span>);\</span></span><br><span class="line"><span class="meta">    QObject::connect(btn, SIGNAL(clicked()), &amp;app, SLOT(quit()));\</span></span><br><span class="line"><span class="meta">    label-&gt;show();\</span></span><br><span class="line"><span class="meta">    btn-&gt;show();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接写 HELLO 就相当于替换了</span></span><br><span class="line">    HELLO</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0-3-Qt-环境配置"><a href="#0-3-Qt-环境配置" class="headerlink" title="0.3 Qt 环境配置"></a>0.3 Qt 环境配置</h2><blockquote><p>Unix 系统：不是安装完就能在命令行里用了吗？</p></blockquote><p>Windows 系统：在下载安装的 Qt 目录中找到编译器文件夹（安装时应该提醒你设置过了），把编译器目录下 <code>bin</code> 文件夹目录添加到 <strong>用户/系统环境变量 <code>Path</code></strong> 中；</p><h1 id="Chapter-1-Qt-初认识"><a href="#Chapter-1-Qt-初认识" class="headerlink" title="Chapter 1 Qt 初认识"></a>Chapter 1 Qt 初认识</h1><h2 id="1-1-简单示例"><a href="#1-1-简单示例" class="headerlink" title="1.1 简单示例"></a>1.1 简单示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span>    <span class="comment">// Qt 中一些类的定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QApplication 支持两个参数，说明 Qt 也有自己的命令行参数</span></span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;    <span class="comment">// 创建 QApplication 对象，用于管理程序资源</span></span><br><span class="line">    <span class="comment">// 创建了显示 “……” 的 QLabel 窗口部件(widget)</span></span><br><span class="line">    QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, Qt!&quot;</span>);</span><br><span class="line">    <span class="comment">// 显示该 widget，详见 tips2.</span></span><br><span class="line">    label-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// 将应用程序的控制权传递给 Qt，程序进入循环等待状态，监听用户动作并根据代码作出反应</span></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="comment">// 此处不考虑内存泄漏，因为整个程序结束后，空间能直接被操作系统回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>widget：窗口部件，指用户界面中的一个可视化元素，相当于 Windows 中的控件、容器。按钮、菜单、滚动条、框架等都是窗口部件。</p><p>tips 1. <strong>绝大多数应用程序会使用 <code>QMainWindow</code> 或 <code>QDialog</code> 作为窗口</strong>；而且在 Qt 中很灵活，甚至可以使用 QLabel 窗口部件来作为窗口（如上例）；</p><p>tips 2. <strong>创建 widget 时，大多都是“隐藏”属性，这可以使得我们先更改一些性质，在手动显示它们</strong>；</p><p>tips 3. <code>QLabel</code> 类的初始化参数的字符串<strong>允许简单 HTML 文本</strong>！例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLabel* label = <span class="built_in">QLabel</span>(<span class="string">&quot;&lt;h2&gt;&lt;i&gt;Hello,&lt;/i&gt;&lt;/h2&gt;&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><h2 id="1-2-要点：通过命令行（qmake）创建、编译-Qt-工程"><a href="#1-2-要点：通过命令行（qmake）创建、编译-Qt-工程" class="headerlink" title="1.2 要点：通过命令行（qmake）创建、编译 Qt 工程"></a>1.2 要点：通过命令行（qmake）创建、编译 Qt 工程</h2><p>本文单独提出为一个小节足以证明重要性，这里不会，连程序都跑不起来……</p><p>【⚠ 劝退警告】了解 Qt 前，本文默认大家已经对 C++ 从编码到编译运行的过程都基本了解；</p><blockquote><p>不了解就想学 Qt，只能说你是抱着没打算学透彻的心态，或者是只会用 IDE，一碰到报错就四处提问，，建议直奔 B 站 “1天速成”，或者某 CSDN 看“教程”；</p><p>但如果想要了解这方面内容可以参见博客 “GNU Tutor” 来入门，或者配合 GCC、CMake 相关课程学习（当然要先学会 C++ 基础）；</p></blockquote><p>从现在开始将使用 Qt 的用户分为 2 类（和操作系统环境无关）：</p><ol><li><p>使用 Qt Creator 的用户（即在官网安装 Qt Creator IDE 及 全套 Qt 运行环境的用户），<strong>以后称这类用户为 “IDE 用户”</strong>；</p><blockquote><p>这很像 C++ 使用 VS、VSCode、CLion 等 IDE（集成开发环境） 一键编译运行的用户；</p></blockquote></li><li><p>使用单独的 Qt Designer 的用户（即 Qt 库 + 命令行编译 + Qt Designer 的用户），<strong>以后称这类用户为 “非 IDE 用户”</strong>；</p><blockquote><p>这很像 C++ 使用<strong>编辑器</strong>写代码、手动使用 CMake/Make/GCC 编译、使用命令行运行的<strong>亲力亲为</strong>的用户；</p></blockquote></li></ol><h3 id="非-IDE-用户如何创建、编译运行-Qt-项目"><a href="#非-IDE-用户如何创建、编译运行-Qt-项目" class="headerlink" title="非 IDE 用户如何创建、编译运行 Qt 项目"></a>非 IDE 用户如何创建、编译运行 Qt 项目</h3><blockquote><p>由于手动编译更困难、更接近 Qt 运行的原理，所以优先介绍非 IDE 用户的做法；</p><p>劝退警告：Windows 环境配置复杂于 Linux，不过能让你更好了解 Qt 项目编译全过程，如果感兴趣可以使用这种方法；本人在开发 Windows 桌面应用时就采用这种方法</p></blockquote><ul><li><p><span id="script-env">【此步仅 Windows 用户】</span>确认编译器环境：Windows 中你可能在之前就有一个 C++ 编译器，并且已经配置在环境变量里，例如 MSVC 或者 minGW，所以为了防止手动编译用错了编译器，导致报错，<strong>这步是必须的</strong>；</p><p>在编译前，需要<strong>临时加入2个环境变量，来确保覆盖系统内其他C++编译器的环境变量</strong>：</p><ol><li><p>和 Qt 库配套的 C++ 编译器目录。如果你安装了 Qt Creator，那么在安装时应该顺带让你设置并安装了对应版本的 minGW 编译器，它的位置和 Qt 是放在一起的；</p><p><strong>通常位置是：<code>&lt;Qt安装根目录&gt;\Tools\mingw&lt;版本号&gt;\bin</code></strong>;</p><p>例如本人的位置：<code>D:\Qt5.14.2\Tools\mingw730_64\bin</code>；</p></li><li><p>Qt 库引入新的编译器，例如 <code>moc</code> 编译器、<code>uic</code> 编译器（后面会说），所在的目录；</p><p><strong>通常位置是：<code>&lt;Qt安装根目录&gt;\&lt;Qt版本号&gt;\mingw&lt;版本号&gt;\bin</code></strong>；</p><p>例如本人的位置：<code>D:\Qt5.14.2\5.14.2\mingw73_64\bin</code>；</p></li></ol><p>为了在手动编译完项目后，不影响其他C++编译器的正常使用，应该把这两个环境变量设置为临时环境变量，最方便的做法是<strong>写成 BAT 脚本</strong>，在命令行窗口中使用，只保留到本次会话结束；<strong>坏处是每次编译前都要运行这个脚本</strong>；例如本人的脚本应该这么写：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File: addEnv.bat</span></span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> PATH=D:\Qt5.<span class="number">14.2</span>\<span class="number">5.14</span>.<span class="number">2</span>\mingw73_64\bin;D:\Qt5.<span class="number">14.2</span>\Tools\mingw730_64\bin;%PATH%</span><br></pre></td></tr></table></figure><p>你可以将这个脚本保存在你的项目目录，或者其他目录，编译前运行一下就行，<strong>注意必须用命令行运行，而且编译必须使用这个命令行，不能关闭，否则临时环境变量会丢失，需要重新运行</strong>；</p><blockquote><p><strong>当然，如果你十分肯定系统中唯一的 C++ 编译器就是 Qt 安装的这个编译器，并且还在环境变量里，那么这一整个步骤就不用做了</strong>；</p></blockquote></li><li><p>创建工程：在<strong>已安排源文件（你已经创建了一些 <code>*.h/cpp</code>）的目录</strong>下执行：<code>qmake -project</code>，生成 <code>*.pro</code> 文件，与平台无关的项目文件；</p><blockquote><p>或者你想让项目目录干净点可以新建一个 build 文件夹，将命令行切入 build 中，再执行 <code>qmake -project &lt;你的项目目录&gt;</code></p></blockquote></li><li><p>添加 Qt 库：如果这个项目除了 <code>QtCore</code>、<code>QtGui</code>（默认包含） 以外，还想添加额外的 Qt 库，例如常用的 <code>QtWidgets</code>，<code>QtNetwork</code>，那么在 <code>*.pro</code> 文件的合适位置添加：<code>QT += widgets</code>、<code>QT += network</code>；</p><blockquote><p>想要了解更详细的 <code>*.pro</code> 文件的编写规则，请查阅<a href="https://doc.qt.io/qt-5/qmake-manual.html">官方文档</a>；</p><p><span id="important1"><strong>不过除了添加 Qt 库，其他应该很少会直接修改 <code>pro</code> 文件，例如引入项目文件就不用</strong>：</span></p><ul><li>IDE 用户可以在 Qt Creator 左侧文件栏右击添加文件，会自动更新 pro 文件；</li><li>非 IDE 用户只需在相同文件夹下重新运行 <code>qmake -project</code> 即可更新 pro 文件；</li></ul></blockquote></li><li><p>编译工程：使用 <code>qmake *.pro</code> 将一般项目文件编译为与平台相关的 <code>makefile</code> 文件；最后运行<code>make</code> 直接编译即可；</p><blockquote><p><code>qmake *.pro</code> 的过程有点像 CMake 对照 CMakeLists.txt 生成 Makefile 的过程；</p><p>注：Windows 下稍微麻烦一点，在项目目录下：</p><ol><li><p>运行 <code>qmake *.pro -spec win32-g++ &quot;CONFIG+=debug&quot; &quot;CONFIG += qml_debug&quot;</code></p></li><li><p>运行 <code>mingw32-make.exe</code>，这就相当于 Unix 系统下的 <code>make</code>；</p></li></ol></blockquote><ol><li><p>⚠ <strong>当你在生成 <code>makefile</code> 后，又向程序中加入一些新的包或函数，那么可能需要再次运行 <code>qmake</code> 来生成 新的 <code>makefile</code>，以防编译器无法找到新文件</strong>；</p></li><li><p><strong>有同学可能会问，能不能不用 <code>qmake</code>，就用 <code>cmake</code>？这个可以，下一节就说！</strong></p></li></ol></li></ul><h3 id="IDE-用户如何创建、编译运行-Qt-项目"><a href="#IDE-用户如何创建、编译运行-Qt-项目" class="headerlink" title="IDE 用户如何创建、编译运行 Qt 项目"></a>IDE 用户如何创建、编译运行 Qt 项目</h3><ul><li>法1（纯 IDE 法）：打开 Qt Creator -&gt; 新建项目 -&gt; 按指示配置环境（界面中 Qt Application 模板对新手不友好，可能需要思考一会项目结构） -&gt; 编写项目 -&gt; 编译运行就交给 IDE 吧~；</li><li>法2（命令行法，比较自由）：新建一个项目文件夹 -&gt; 按需创建 <code>*.cpp</code> <code>*.h</code> 等项目文件 -&gt; 命令行进入该目录运行 <code>qmake -project</code> -&gt; 进入生成的 <code>*.pro</code> 按需添加所需 Qt 库 -&gt; 双击 pro 文件/进入 Qt Creator 打开项目 -&gt; 编写项目 -&gt; 编译运行就交给 IDE 吧~；</li></ul><h2 id="1-2-EX-使用-CMake-代替-qmake-构建项目"><a href="#1-2-EX-使用-CMake-代替-qmake-构建项目" class="headerlink" title="1.2-EX 使用 CMake 代替 qmake 构建项目"></a>1.2-EX 使用 CMake 代替 qmake 构建项目</h2><p><strong>使用 IDE 的小伙伴就可以跳过了哦 ~ 因为你们只需要在创建项目时，选择 “项目构建系统” 为CMake，就完成了！</strong></p><p>下面，在原来的 CMake 语法的基础上（基础语法不作介绍，可以看本站以前的文章，或者网上学习），本人仅会介绍 <strong>和普通 C++ 项目构建的不同之处</strong>：</p><ol><li><p><strong>【必要】添加 Qt 专属编译器</strong>（这些编译器在后面会一一介绍，学完可以回来看看）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动调用 uic 编译器处理 *.ui</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"><span class="comment"># 自动调用 moc 编译器处理 Qt 宏和关键字</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="comment"># 自动处理 *.qrc Qt 资源文件</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>【必要】</strong>如果 你在 qmake 中需要添加诸如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += widgets network    // *.pro 的写法</span><br></pre></td></tr></table></figure><p>的 Qt 库，在 CMake 中需要这么写：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $ENV&#123;&#125; 调用系统环境变量，这个 Qt_HOME 需要自己设置在系统环境变量里</span></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Widgets Network REQUIRED PATHS $ENV&#123;Qt_HOME&#125;)</span><br></pre></td></tr></table></figure><p><strong>很遗憾，CMake 没有 qmake 的默认设置，qmake 默认加入的 <code>Gui</code>、<code>Core</code> 库需要在 CMakeLists 中手动加入</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Core Gui REQUIRED)</span><br></pre></td></tr></table></figure><p><strong>而且在最后还要手动链接库</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(exeName PRIVATE Qt5::Widgets Qt5::Core Qt5::Gui)</span><br></pre></td></tr></table></figure></li><li><p><strong>【注意】</strong>：在 CMake 中，由于之前添加了专属编译器，所以 <code>*.ui</code> 和 <code>*.h/cpp</code> 一样，都需要在 <code>add_executable</code> 或 <code>add_library</code> 构建目标时，<strong>作为源文件加入进去</strong>；</p></li></ol><p><strong>最后，以一个示例项目为例子（不同的项目没法照抄哦~）</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span>(HelloWorld)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【optional】设置工程包含当前目录</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_INCLUDE_CURRENT_DIR <span class="keyword">ON</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FIND_PACKAGE</span>(Qt5 COMPONENTS Widgets Gui Core REQUIRED PATHS $ENV&#123;Qt5_HOME&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前文件夹中的所有相关文件</span></span><br><span class="line"><span class="keyword">FILE</span>(GLOB SOURCE_FILES <span class="string">&quot;./*.cpp&quot;</span>) </span><br><span class="line"><span class="keyword">FILE</span>(GLOB HEADER_FILES <span class="string">&quot;./*.h&quot;</span>) </span><br><span class="line"><span class="keyword">FILE</span>(GLOB UI_FILES <span class="string">&quot;./*.ui&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过Ui文件生成对应的头文件</span></span><br><span class="line">QT5_WRAP_UI(WRAP_FILES <span class="variable">$&#123;UI_FILES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加资源文件</span></span><br><span class="line"><span class="keyword">SET</span>(RCC_FILES rcc.qrc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【optional】生成UI文件夹</span></span><br><span class="line"><span class="keyword">SOURCE_GROUP</span>(<span class="string">&quot;UI&quot;</span> FILES <span class="variable">$&#123;UI_FILES&#125;</span> <span class="variable">$&#123;WRAP_FILES&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件，需添加RCC_FILES、WRAP_FILES</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SOURCE_FILES&#125;</span> <span class="variable">$&#123;HEADER_FILES&#125;</span> <span class="variable">$&#123;RCC_FILES&#125;</span> <span class="variable">$&#123;WRAP_FILES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Qt5依赖项</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> Qt5::Widgets Qt5::Core Qt5::Gui)</span><br></pre></td></tr></table></figure><h2 id="1-3-建立连接"><a href="#1-3-建立连接" class="headerlink" title="1.3 建立连接"></a>1.3 建立连接</h2><blockquote><p>之前我们认识了简单 Qt 程序的基本运作，那么如何实现 <strong>Qt 响应用户的动作呢？</strong></p></blockquote><h3 id="1-3-1-信号与槽的原理"><a href="#1-3-1-信号与槽的原理" class="headerlink" title="1.3.1. 信号与槽的原理"></a>1.3.1. 信号与槽的原理</h3><ul><li><p>Qt 的 widget 通过<strong>发射信号</strong>（signal，实质是一个函数，和操作系统的信号无关）来表明用户的某个动作已发生，或者状态已改变；</p><blockquote><p>举例：用户点击按钮类 <code>QPushButton</code> 时，按钮会发射 <code>clicked()</code> 信号；</p></blockquote></li><li><p>Qt 的 <strong>槽（slot）能够接收信号</strong>，是一个实际上的函数，一旦触发该信号，slot 会自动执行；</p><p>⚠<strong>注意：槽就是函数！一个类如果具有一个方法，那么它就可以作为这个类的槽</strong>；</p></li><li><p>Qt 通过宏（macro）来将 click() 等对象转化为信号str、将函数 F() 转化为槽，并使用 <code>QObject::connect</code> 函数进行绑定；</p><blockquote><p><strong>宏转化的时候，如果信号 / 槽对应的函数有参数，务必填入参数类型，例如：</strong></p><p><code>SIGNAL(valueChanged(int))</code></p></blockquote></li></ul><p>ℹ 这里简单带过一下，给读者一个初印象，以后会详细深入介绍 信号-槽机制；</p><h3 id="1-3-2-示例代码"><a href="#1-3-2-示例代码" class="headerlink" title="1.3.2. 示例代码"></a>1.3.2. 示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QPushButton* btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;quit&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用 connect 静态成员函数，其参数原型为：</span></span><br><span class="line">    <span class="comment">// QObject::connect(QObject* p1, SIGNAL, QObject* p2, SLOT)</span></span><br><span class="line">    <span class="comment">// 其中 p1 是指向发送信号的widget指针，p2 是指向接受信号的函数槽**所在的widget**指针，这里是 含有quit()方法 的 QApplication 对象；</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(btn, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), &amp;app, <span class="built_in">SLOT</span>(<span class="built_in">quit</span>()));</span><br><span class="line">    button-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-Qt-窗口的布局设计"><a href="#1-4-Qt-窗口的布局设计" class="headerlink" title="1.4 Qt 窗口的布局设计"></a>1.4 Qt 窗口的布局设计</h2><h3 id="1-4-1-widget-间的父子关系"><a href="#1-4-1-widget-间的父子关系" class="headerlink" title="1.4.1 widget 间的父子关系"></a>1.4.1 widget 间的父子关系</h3><blockquote><p>当需要在一个窗口中，<strong>合理地</strong>安排各种 widget 的摆放时，需要考虑这些 widget 间的层次关系；</p><p>Qt 中，和其他类的 GUI 设计库类似的做法是，<strong>引入 widget 间的父子关系</strong>；表示：<strong>A 是 B 的子控件 就可以理解为 A 是布局在 B 上的 控件</strong>；</p></blockquote><p><img src="layout.png" height="100px"></p><p>比如，想要制作如上图的应用界面，就需要遵循这样的步骤（仅供参考，其他方法也能实现）：</p><ol><li><p>在窗口最顶层设置一个 <code>QWidget</code> 类对象的抽象的 widget，用来盛放其他 widget，可以理解现实中的一个 “桌布”；</p></li><li><p>以 <code>QWidget</code> 类对象为父控件（QWidget 自己没有父控件，它就是顶层窗口），设置 <code>QSpinbox</code> 和 <code>QSlider</code> 对象（分别是 微调框 控件类、滑动条 控件类）;</p><blockquote><p><strong>一般情况下，QWidget 及其子类设置父控件的方法是通过布局管理器实现</strong>；理解为“用布局管理器打包在一起”；</p></blockquote></li><li><p>绑定内部信号-槽的关联；</p></li><li><p>最后<strong>使用布局管理器</strong>将子控件<strong>按指定“摆放方式”</strong>显式加入父控件，显示顶层 widget 即可；</p></li></ol><p>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QHBoxLayout&gt;</span>    <span class="comment">// 引入 布局管理器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QSlider&gt;</span>        <span class="comment">// 引入 滑动条控件类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Qtwidgets/QSpinBox&gt;</span>        <span class="comment">// 引入 微调框控件类</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    QWidget* mainWindow = <span class="keyword">new</span> QWidget;</span><br><span class="line">    mainWindow-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;Enter your age&quot;</span>);    <span class="comment">// QWidget 类具有成员函数 setWindowTitle</span></span><br><span class="line">    </span><br><span class="line">    QSpinBox* spinBox = <span class="keyword">new</span> QSpinBox;</span><br><span class="line">    QSlider* slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal);    <span class="comment">// QSlider 的构造函数的第一个参数可以使用 Qt 枚举量 Horizontal 设置滑动方向</span></span><br><span class="line">    spinBox-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">130</span>);</span><br><span class="line">    slider-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">130</span>);    <span class="comment">// 两个类都具有成员函数 setRange</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个类都具有：valueChanged(int) 信号、setValue(int) 槽，因此将两者相互绑定</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(spinBox, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), slider, <span class="built_in">SLOT</span>(<span class="built_in">setValue</span>(<span class="type">int</span>)));</span><br><span class="line">    QObject::<span class="built_in">connect</span>(slider, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), spinBox, <span class="built_in">SLOT</span>(<span class="built_in">setValue</span>(<span class="type">int</span>)));</span><br><span class="line">    </span><br><span class="line">    spinBox-&gt;<span class="built_in">setValue</span>(<span class="number">35</span>);    <span class="comment">// 初始化值为35</span></span><br><span class="line">    </span><br><span class="line">    QHBoxLayout* layout = <span class="keyword">new</span> QHBoxLayout;    <span class="comment">// 初始化布局管理器</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(spinBox);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(slider);    <span class="comment">// 布局管理器将子控件打包在一起</span></span><br><span class="line">    <span class="comment">// QWidget 具有成员函数 setLayout，可以传入布局管理器实现布局设计</span></span><br><span class="line">    window-&gt;<span class="built_in">setLayout</span>(layout);    <span class="comment">// 再将包传给父控件，底层会自动将管理器中的所有子控件定向其父控件</span></span><br><span class="line">    </span><br><span class="line">    window-&gt;<span class="built_in">show</span>();        <span class="comment">// 最后只需展示顶层 widget 即可</span></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-布局设计的意义"><a href="#1-4-2-布局设计的意义" class="headerlink" title="1.4.2 布局设计的意义"></a>1.4.2 布局设计的意义</h3><p>有同学会问，为什么需要 layout？<strong>layout 可以让多个 widget 按想要的方式排列在一个窗口上</strong>；如果不这么做，就没法定义摆放方式了！你可以试一试，不用布局管理器，你会发现两个或多个 widget 是分布在不同的窗口下的；</p><h3 id="1-4-3-布局管理器的类型"><a href="#1-4-3-布局管理器的类型" class="headerlink" title="1.4.3 布局管理器的类型"></a>1.4.3 布局管理器的类型</h3><p>除了以上例子介绍的 <code>QHBoxLayout</code> 类，还有 <code>QVBoxLayout</code>、<code>QGridLayout</code>，其作用分别是：</p><ul><li><code>QHBoxLayout</code>：默认在水平方向，从左到右排列 widget；</li><li><code>QVBoxLayout</code>：默认在竖直方向，从上到下排列 widget；</li><li><code>QGridLayout</code>：将 widget 排列在预设的网格中；</li></ul><p>常见的使用方法：先声明、在设置属性，最后添加打包到布局管理器中，设置给父控件；</p><p><strong>它们都继承于 <code>QLayout</code>，所以它们不是 widget（<code>QWidget</code>），一般也不可见</strong>；</p><h2 id="1-5-章末贴士"><a href="#1-5-章末贴士" class="headerlink" title="1.5 章末贴士"></a>1.5 章末贴士</h2><ul><li><p>重要：一定要会使用官方文档；</p></li><li><p>有些同学会想，里面的命令行参数 <code>argc</code> 和 <code>argv</code> 究竟可以做什么？其实，举个例子就明白了，其中一个用途是<strong>设置应用界面的主题</strong>，即：<code>./应用名 -style &lt;style name&gt;</code>，常用的 <code>style name</code> 有：<code>plastique</code>、<code>Cleanlooks</code>、<code>CDE</code>、<code>Motif</code>、<code>Windows</code>、<code>Windows XP</code>、<code>Windows Vista</code>、<code>Mac</code>；</p></li><li><p>本章涉及到的类和一些方法的总结</p><p><img src="C1.png"></p></li><li><p><strong>和 Qt 4 比较</strong>：QLabel、QPushButton、QSlider、QSpinBox 都还是 QWidget 的子类，但 Qt 5 类的头文件移动到<strong>单独的 <code>QWidgets</code> 模块中</strong>，即 include 时，需要：<code>#include&lt;QtWidgets/QXXX&gt;</code></p><blockquote><p>例如 1.4.1 的例子在 Qt 4 环境下应该这么写<strong>【亲测能跑】</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QSpinBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QSlider&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// …… （后面一毛一样）</span></span><br><span class="line"><span class="comment">// 记得在 *.pro 中移除：QT += widgets</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>最后强调一下， Qt 4 到 5、Qt 5 到 6 的很多操作都改变了，所以别轻易更换项目的 Qt 大版本！</strong></p></li></ul><h1 id="Chapter-2-面向对象的-Qt"><a href="#Chapter-2-面向对象的-Qt" class="headerlink" title="Chapter 2 面向对象的 Qt"></a>Chapter 2 面向对象的 Qt</h1><h2 id="2-1-纯代码设计"><a href="#2-1-纯代码设计" class="headerlink" title="2.1 纯代码设计"></a>2.1 纯代码设计</h2><h3 id="2-1-1-示例：以简单对话框为例"><a href="#2-1-1-示例：以简单对话框为例" class="headerlink" title="2.1.1 示例：以简单对话框为例"></a>2.1.1 示例：以简单对话框为例</h3><p><img src="QDiag.png" height="150px"></p><blockquote><p>想象一下，这是一个庞大应用程序的一个小部分对话框，现在想要单独设计它。但是第一章的代码都写在一个 main 函数中，如果窗口一多，不仅不利于维护，而且容易编写错误；</p><p>所以我们从现在开始采用 C++ 中的不同类来编写不同窗口，可以形成很好的封装性，增强可读性；</p></blockquote><p>下面将这个窗口编写为一个类 <code>findDialog</code>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: findDialog.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FINDDIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FINDDIALOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QDialog&gt;</span>    <span class="comment">// 包含 Qt 对话的基类，派生于 QWidget，和 1.5 中说的一样，在 Qt 4 中要写 #include&lt;QDialog&gt;，以下不再赘述；</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QCheckBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">findDialog</span> : <span class="keyword">public</span> QDialog &#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">// 很重要的一个宏，里面写了 QObject 类的几乎所有信号和槽，还有其他属性和方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这是一个典型的 Qt widget 类的定义方式，第一个参数指定父控件</span></span><br><span class="line">    <span class="built_in">findDialog</span>(QWidget* parent = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 marco 说明以下定义的函数都是 信号函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">// Qt::CaseSensitivity 是 enum 类型，和 C++ 中的 true、false 如出一辙，本身的值也是 0 或 1，用于区分大小写是否敏感的具体情况，含有值 Qt:CaseSensitive 和 Qt::CaseInSensitive</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findNext</span><span class="params">(<span class="type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findPrevious</span><span class="params">(<span class="type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 声明了私有的槽</span></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findClicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 思考一下，已知 QPushButton 自己有槽函数 setEnabled(bool)，为什么还要包装一层 私有的槽呢？（答案在实现这个槽的时候揭晓）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enabledFindButton</span><span class="params">(<span class="type">const</span> QString&amp; text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLabel* label;</span><br><span class="line">    QLineEdit* lineEdit;</span><br><span class="line">    QCheckBox* caseCheckBox;</span><br><span class="line">    QCheckBox* backwardCheckBox;</span><br><span class="line">    QPushButton* findButton;</span><br><span class="line">    QPushButton* closeButton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这是窗口的实现 cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: findDialog.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtGui&gt;</span>        <span class="comment">// 详见注解 tips 1.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;findDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// findDialog 继承于 QDialog，所以也使用它的一些数据成员，自然需要委托构造</span></span><br><span class="line">findDialog::<span class="built_in">findDialog</span>(QWidget* parent) : <span class="built_in">QDialog</span>(parent) &#123;</span><br><span class="line">    <span class="comment">// 这里有 3 点需要解释，详见 tips 2. 、 tips 3. 和 tips 4.</span></span><br><span class="line">    label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="built_in">tr</span>(<span class="string">&quot;Find &amp;what&quot;</span>));    <span class="comment">// tips2. tips3.</span></span><br><span class="line">    <span class="comment">// 新的类：QLineEdit 类，单行输入框类</span></span><br><span class="line">    lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    label-&gt;<span class="built_in">setBuddy</span>(lineEdit);    <span class="comment">// tips4.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新的类：QCheckBox 类，勾选框类，初始化参数和 QLabel 一样，也是str内容</span></span><br><span class="line">    caseCheckBox = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="built_in">tr</span>(<span class="string">&quot;Match &amp;case&quot;</span>));</span><br><span class="line">    backwardCheckBox = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="built_in">tr</span>(<span class="string">&quot;Search &amp;backward&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    findButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Find&quot;</span>));</span><br><span class="line">    findButton-&gt;<span class="built_in">setDefault</span>(<span class="literal">true</span>);        <span class="comment">// tips 5.</span></span><br><span class="line">    findButton-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);        <span class="comment">// tips 6.</span></span><br><span class="line">    </span><br><span class="line">    closeButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="built_in">tr</span>(<span class="string">&quot;Close&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里不用写作用域 “QObject::”，因为 QDialog 就是 QObject 的子类</span></span><br><span class="line">    <span class="comment">// 详见 tips 7.</span></span><br><span class="line">    <span class="comment">// 还记得之前声明的私有槽吗？（再等会实现定义）这里是将 lineEdit 的文字改变信号连接到 findDiag 窗体的 enabledFindButton(const QString&amp;) 私有槽上；</span></span><br><span class="line">    <span class="built_in">connect</span>(lineEdit, <span class="built_in">SIGNAL</span>(<span class="built_in">textChanged</span>(<span class="type">const</span> QString&amp;)),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">enableFindButton</span>(<span class="type">const</span> QString&amp;)));</span><br><span class="line">    <span class="built_in">connect</span>(findButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">findClicked</span>()));</span><br><span class="line">    <span class="comment">// tips 8.</span></span><br><span class="line">    <span class="built_in">connect</span>(closeButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代码块未完待续----------------------------</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>tips 1.</strong> 头文件 <code>QtGui.h</code> 包含了 Qt GUI 类的 <code>QtCore</code> 和 <code>QtGui</code> 模块的所有类的定义；</p><blockquote><p><strong>回顾一下 Qt 的主要模块：<code>QtCore</code>、<code>QtGui</code>、<code>QtNetwork</code>、<code>QtOpenGL</code>、<code>QtSql</code>、<code>QtSvg</code>、<code>QtXml</code></strong>；</p></blockquote><ul><li>同学会问，为什么不在 <code>findDialog.h</code> 中直接 <code>#include&lt;QtGui&gt;</code>？<strong>因为这个包比较大，引入他可能造成引用的不清晰，不是一个好习惯；理论上用到什么引入什么</strong>；</li></ul></li><li><p><strong>tip 2.</strong>  在 Qt 中，所有字符串都认为是 <code>QString</code> ——有 <code>tr(QString)</code> 方法可以将它们翻译；这就意味着，<strong>在所有用户可见的字符串周围加上 <code>tr()</code> 函数</strong>是个好习惯；这样方便软件后期的翻译工作，对 <code>tr()</code> 的翻译会在后面介绍；</p></li><li><p><strong>tips 3.</strong> 如果想在用户可见的字符串中加入<strong>快捷键来控制焦点（选中的区域，意味着用户可以直接输入，或者按 ENTER=点击）</strong>，那么在字符串前中写 <strong>“&amp;”</strong> 符号，表示<strong>将 <code>Alt + 字符串第一个字符</code> 作为快捷键</strong>；</p></li><li><p><strong>tips 4.</strong> 几乎所有 <code>QWidget</code> 都有一个方法 <code>setBuddy(QWidget* ptr)</code> 用来绑定两个 widget 为兄弟控件，具体表现在<strong>共用同一个快捷键</strong>（这个快捷键会同时聚焦这两个控件）；</p></li><li><p><strong>tips 5.</strong> 大多数 <code>QWidget</code> 都有一个方法 <code>setDefault(bool flag)</code> 用来指定<strong>刚打开窗口时聚焦的控件</strong>；</p></li><li><p><strong>tips 6.</strong> <code>QPushButton</code> 有一个特有属性 <code>enabled</code>，如果是 <code>true</code>，则这个按钮是可以点击的，否则按钮呈现灰色不可点击的状态；</p></li><li><p><strong>tips 7.</strong> 由上面的 <code>connect</code> 函数可以看出，<code>QLineEdit</code> 类有一个 <code>textChanged(const QString&amp;)</code> 信号；</p></li><li><p><strong>tips 8.</strong> 这里 <code>QDialog</code> 的 <code>close()</code> 方法<strong>继承于 <code>QWidget</code> 类</strong>，默认行为是<strong>将 widget 隐藏起来（而非删除）</strong>，这和 <code>QApplication</code> 类的 <code>quit()</code> 方法不一样，<code>quit()</code> 方法是关闭并删除窗口及其上的所有布局、widget；</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 上接上一个代码块 --------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记住在 1.4.1 中说的 4 个基本步骤，这里是倒数第二个：打包布局</span></span><br><span class="line">    <span class="comment">// 这里的案例告诉我们，对于多个 widget 的布局，可以采用多个不同位置、不同类型的布局管理器来进行，这里的具体划分见 tips 9.</span></span><br><span class="line">    QHBoxLayout* topLeftLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    topLeftLayout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">    topLeftLayout-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line">    </span><br><span class="line">    QVBoxLayout* leftLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    <span class="comment">// tip 10.</span></span><br><span class="line">    leftLayout-&gt;<span class="built_in">addLayout</span>(topLeftLayout);</span><br><span class="line">    leftLayout-&gt;<span class="built_in">addWidget</span>(caseCheckBox);</span><br><span class="line">    leftLayout-&gt;<span class="built_in">addWidget</span>(backwardCheckBox);</span><br><span class="line">    </span><br><span class="line">    QVBoxLayout* rightLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    rightLayout-&gt;<span class="built_in">addWidget</span>(findButton);</span><br><span class="line">    rightLayout-&gt;<span class="built_in">addWidget</span>(closeButton);</span><br><span class="line">    <span class="comment">// tip 11.</span></span><br><span class="line">    rightLayout-&gt;<span class="built_in">addStretch</span>();</span><br><span class="line">    </span><br><span class="line">    QHBoxLayout* mainLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(leftLayout);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(rightLayout);</span><br><span class="line">    <span class="comment">// 回想之前在 1.4.1 中对 QWidget 顶层窗口使用 setLayout</span></span><br><span class="line">    <span class="built_in">setLayout</span>(mainLayout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和 1.4.1 中一样，这里是 QWidget 派生来的方法</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Find&quot;</span>));</span><br><span class="line">    <span class="comment">// tip 12.</span></span><br><span class="line">    <span class="built_in">setFixedHeight</span>(<span class="built_in">sizeHint</span>().<span class="built_in">height</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>tips 9.</strong> 此处的布局划分的方式如下图所示：</p><p><img src="QLayout.png" height="200px"></p><p>这样的划分思路很类似 HTML 的设计框架布局，<strong>先划分大的区域，再根据功能或对齐位置逐个 “切开” </strong>；</p></li><li><p><strong>tips 10.</strong> <code>QLayout</code> 类的对象都有 <code>addLayout(QLayout* ptr)</code>，与 <code>addWidget(QWidget* ptr)</code> 类似；前者可以将布局嵌套布局，形成更复杂的结构；</p></li><li><p><strong>tips 11.</strong> <code>QLayout</code> 类中的 <code>addStretch()</code> 方法，如 tip9 中的图片中的 “分隔符” 的作用，用来撑开当前的 <code>Layout</code>，与同级的 <code>Layout</code> 高度或宽度对齐适应，同时使之前加入布局管理器的 widget 更加紧凑；</p></li><li><p><strong>tips 12.</strong> <code>setFixedHeight(int h)</code> 是 <code>QWidget</code> 类的方法，可以设定一个固定的 widget 高度，<code>QWidget::sizeHint()</code> 可以计算当前 widget 中各个布局管理器中各子 widget 默认 size，从而得出比较适宜的高度；</p></li></ul><p><strong>写完构造函数，无需写析构函数。因为：Qt 在删除父对象时，会自动删除所有子 widget 和 子布局；</strong></p><p>下面<strong>定义之前声明的私有槽</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">findDialog::findClicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取当前 lineEdit 中的字符串到 text 中</span></span><br><span class="line">    QString text = lineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="comment">// tips 13.</span></span><br><span class="line">    Qt::CaseSensitivity cs = </span><br><span class="line">        caseCheckBox-&gt;<span class="built_in">isChecked</span>() ? Qt:CaseSensitive : Qt:CaseInSensitive;</span><br><span class="line">    <span class="keyword">if</span> (backwardCheckBox-&gt;<span class="built_in">isChecked</span>())</span><br><span class="line">        <span class="comment">// tips 14.</span></span><br><span class="line">        <span class="function">emit <span class="title">findPrevious</span><span class="params">(text, cs)</span></span>;</span><br><span class="line">    <span class="keyword">else</span> emit <span class="built_in">findNext</span>(text, cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findDialog::enableFindButton</span><span class="params">(<span class="type">const</span> QString&amp; text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代码块 1 中的疑问，答案揭晓：tips 15.</span></span><br><span class="line">    findButton-&gt;<span class="built_in">setEnabled</span>(!text.<span class="built_in">isEmpty</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>tips 13.</strong> <code>QCheckBox</code> 具有方法 <code>isChecked()</code>，指示这个选择框有没有被选中；</p></li><li><p><strong>tips 14.</strong> <code>emit &lt;function&gt;</code> 是 Qt 的关键字之一，<strong>表示向函数 <code>function</code> 发射信号</strong>；</p></li><li><p><strong>tips 15.</strong> 之所以要单独设计一个私有槽，是因为考虑到不仅仅是在输入变换的时候，使这个按钮处于 enable 状态，还要考虑<strong>在文本框为空的时候，使按钮再次 disable</strong>，而这需要额外的逻辑设计；这里就是 <code>!text.isEmpty()</code> 这个方法；</p><blockquote><p>整体逻辑：如果改变了文本，就调用 <code>enableFindButton</code> 槽；如果文本为空，就 disable “Find” 按钮；</p></blockquote></li></ul><p>这下将所有的部件放在一起：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;findDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    findDialog* dialog = <span class="keyword">new</span> findDialog;</span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⚠注意：因为这里没有实际应用场景，所以以上代码的信号 <code>findPrevious(str, cs)</code> 和 <code>findNext(str, cs)</code> 暂时没有应用，以后继续补充</strong>；</p><h3 id="2-1-2-进一步了解信号-槽机制"><a href="#2-1-2-进一步了解信号-槽机制" class="headerlink" title="2.1.2 进一步了解信号-槽机制"></a>2.1.2 进一步了解信号-槽机制</h3><ul><li><p>槽（<code>slot</code>）：和普通 C++ 成员函数<strong>几乎一模一样</strong>：可以是虚函数、可以被重载、可以是 <code>public/protected/private</code>、可以被其他 C++ 成员函数之间调用、参数可以是任意类型；唯一不同的就是<strong>槽可以和信号连接在一起</strong>，只要 <code>emit</code> 了对应的信号，就会自动调用这个槽；</p><blockquote><p><strong>当普通 C++ 函数变成槽调用时，一般会忽略原本的返回值</strong>；</p></blockquote></li><li><p>信号 - 槽的连接的函数：<code>QObject::connect(QObject* sender, SIGNAL(signal), QObject* receiver, SLOT(slot))</code></p><blockquote><p>其中宏 <code>SIGNAL()</code> 和 <code>SLOT()</code> <strong>会将它们的参数转换成相应的字符串</strong>（暂时不必了解这些字符串的结构）；</p></blockquote></li><li><p>信号-槽连接的<strong>要求</strong>：要想信号和槽成功连接，<strong>它们的参数必须有相同的顺序和相同的类型</strong>；</p><blockquote><p>有一种情况例外：<strong>信号的参数多于槽的参数，但对应的参数类型相同</strong>（这样多余的参数会被简单地忽略掉）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ftp, <span class="built_in">SIGNAL</span>(<span class="built_in">rawCommnadReply</span>(<span class="type">int</span>, <span class="type">const</span> QString&amp;)),</span><br><span class="line">    <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">checkErrorCode</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure></blockquote></li><li><p>信号-槽连接的<strong>特性</strong></p><ol><li><p><strong>一个信号可以连接多个槽</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这个例子中，如果信号 slider 被 emit，那么会以不确定的顺序一个接着一个调用这些槽（setValue(int) 和 updateStatusBarIndicator(int)，可以不止两个）</span></span><br><span class="line"><span class="built_in">connect</span>(slider, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)),</span><br><span class="line">        spinBox, <span class="built_in">SLOT</span>(<span class="built_in">setValue</span>(<span class="type">int</span>)));</span><br><span class="line"><span class="built_in">connect</span>(slider, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)),</span><br><span class="line">       <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">updateStatusBarIndicator</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure></li><li><p><strong>多个信号可以连接一个槽</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论发射其中的哪一个信号，都会调用这个槽</span></span><br><span class="line"><span class="built_in">connect</span>(lcd, <span class="built_in">SIGNAL</span>(<span class="built_in">overflow</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleMathError</span>()));</span><br><span class="line"><span class="built_in">connect</span>(calc, <span class="built_in">SIGNAL</span>(<span class="built_in">divisionByZero</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleMathError</span>()));</span><br></pre></td></tr></table></figure></li><li><p><strong>一个信号可以连接另一个信号</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// emit 第一个信号，就会触发 emit 第二个信号</span></span><br><span class="line"><span class="built_in">connect</span>(lineEdit, <span class="built_in">SIGNAL</span>(<span class="built_in">textChanged</span>(<span class="type">const</span> QString&amp;)),</span><br><span class="line">       <span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">updateRecord</span>(<span class="type">const</span> QString&amp;)));</span><br></pre></td></tr></table></figure></li><li><p>连接可以被移除：<strong>这种情况应用较少，因为 <code>Qt</code> 在移除对象时，会自动移除和对象相关的所有连接</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(lcd, <span class="built_in">SINGAL</span>(<span class="built_in">overflow</span>()),</span><br><span class="line">          <span class="keyword">this</span>, <span class="built_in">handlerMathError</span>());</span><br></pre></td></tr></table></figure></li><li><p><strong>信号-槽不仅可以应用在图形化界面的编写中，在哪怕不是为了设计 GUI，在类中声明宏 <code>Q_OBJECT</code> 也可以实现信号-槽机制</strong>；</p></li></ol></li></ul><h3 id="2-1-3-Qt-的元对象编译器-moc-和-元对象系统"><a href="#2-1-3-Qt-的元对象编译器-moc-和-元对象系统" class="headerlink" title="2.1.3 Qt 的元对象编译器 moc 和 元对象系统"></a>2.1.3 Qt 的元对象编译器 moc 和 元对象系统</h3><p>在我一开始尝试写一些基本的程序的时候，一直很疑惑，Qt 的宏 <code>slots</code>、<code>signal</code>、<code>Q_OBJECT</code> 究竟是什么？因为我不理解这其中的原理，所以犯过一个低级的错误——将声明成信号（<code>signal</code>）的函数加以定义，像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: XXX.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XXX</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">signal:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">signalA</span><span class="params">(Type1 p1, Type2 p2)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File: XXX.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XXX::signalA</span><span class="params">(Type1 p1, Type2 p2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 某些代码逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写实际上会在 <code>make</code> 编译是报 <code>multiple definition</code> 的错误，我正纳闷，为啥会 “重复定义” 呢？再一看报错的信息：<strong>重复定义的位置位于 <code>moc_XXX.cpp</code> </strong>，我再想，我也没有写过 <code>moc_XXX.cpp</code> 呀？于是就引出了 <strong><code>Qt</code> 中相当重要的概念：<code>moc</code> 元对象编译器</strong>；</p><p>Qt 的主要成就之一就是使用一种机制对 C++ 进行了扩展，并且使用这种机制创建了软件组件；</p><p>这种机制叫做 “元对象系统（meta-object system）”，它提供了关键的 2 项技术：<strong>信号-槽机制</strong> 和 <strong>内省（introspection）</strong>；</p><p>内省功能对于实现信号和槽是必需的，还允许开发人员获得有关 <code>QObject</code> 子类的 “元信息（meta-information，<strong>包含一些类名和它所支持的信号-槽列表</strong>）”，还支持 Qt 设计师属性（<strong>下一节将提到</strong>）和文本翻译（之前所说的 <code>tr()</code>），为 <code>QScript</code> 模块奠定基础（不过目前接触不到）；</p><p>但以上提到的这些，标准 C++ 没有，这意味着用普通的 C++ 编译器一定没法实现；所以 Qt 引入了新的编译器：<code>moc</code> 元对象编译器；</p><p>因此，Qt 整个编码到运行的工作流程是：</p><ol><li><code>qmake</code> 效仿 <code>cmake</code> ，以平台无关的方式指定了程序编译所需的库，这里包含了标准 C++ 所没有的 Qt 的库；最后生成了普通的 <code>Makefile</code>；</li><li><code>moc</code> 元对象编译器一边识别 Qt 特定的宏或关键字（例如 <code>QObject</code>、<code>slots</code>、<code>signal</code>），添加特定内容（例如自动实现信号函数），一边和普通 C++ 编译器一样，编译链接源文件；</li><li><code>moc</code> 元对象编译器在编译时还会补充 <code>QObject</code> 的 内省函数，完成特殊的触发工作；</li></ol><p>以上内容一般很少需要开发者去考虑，都封装在 <code>qmake</code>、<code>moc</code>、<code>QObject</code>内部；如果感兴趣，可以阅读有关 <code>QMetaObject</code> 文档，或者是前面提到的 <code>moc</code> 自动生成的 C++ 源码 <code>moc_XXX.cpp/h</code>；</p><h2 id="2-2-Qt-Designer：UI-快速设计"><a href="#2-2-Qt-Designer：UI-快速设计" class="headerlink" title="2.2 Qt Designer：UI 快速设计"></a>2.2 Qt Designer：UI 快速设计</h2><p>在上面一些纯代码设计的例子中，我们会发现 GUI 的设计遵循一些基本的规律定式：</p><ol><li>创建、初始化（例如设置文本内容）子窗口部件；</li><li>将 widget 放置到布局中；</li><li>设置 Tab 键顺序；</li><li>建立信号 — 槽连接；</li><li>实现自定义槽；</li></ol><p>现在，可以使用 Qt Designer 将图形化设计的一部分（指前三步）交给图形界面；</p><h3 id="2-2-1-Qt-Designer-的基本使用"><a href="#2-2-1-Qt-Designer-的基本使用" class="headerlink" title="2.2.1 Qt Designer 的基本使用"></a>2.2.1 Qt Designer 的基本使用</h3><blockquote><p>本部分将介绍 Qt Designer 如何设计基本 UI 界面，完成上面所提到的 <strong>前3步</strong>，同时<strong>回顾之前所学到的方法</strong>；</p></blockquote><p><img src="cellDialog.png"></p><p>以上面的窗体为目标设计一个窗口类；</p><ul><li><p>打开 Qt Designer：在进行此步前，建议按之前的方法先创建一个 Qt 项目；</p><ul><li>IDE 用户可以在 Qt Creator 中右击创建 <code>Qt 设计师文件</code> （<strong>文件名很重要，将要作为这个窗体的变量名，需要记住，下面提到</strong>），在左边栏的列表中直接双击打开 <code>*.ui</code>；</li><li>非 IDE 用户可以直接进入 Qt Designer 按所需模板新建一个 <code>ui</code> 文件（<strong>文件名很重要，需要记住，下面提到</strong>）；</li></ul></li><li><p>创建、初始化子窗口部件 和 部分常用属性</p><ol><li><code>text</code> 属性：大部分组件的显示内容（还记得之前 <code>QPushButton</code>、<code>QLabel</code> 的初始化参数吗？），拖动出来双击就可以编辑；</li><li><code>objectName</code> 属性：<strong>这个名字建议自己设置，需要记住，因为这是控件的变量名，之后设计信号-槽时需要用到</strong>；</li><li><code>default</code> 属性：记得之前的方法 <code>QWidget::setDefault</code> 吗？这就是它的图形化；</li><li><code>enabled</code> 属性（<code>QPushButton</code>）：相当于在创建 widget 的同时指定 <code>btn-&gt;setEnabled(bool)</code>；</li><li><code>windowTitle</code> 属性（<code>QMainWindow</code>，这里点击窗体在右边栏就能搜到）：相当于 <code>win-&gt;setWindowTitle(str)</code>；</li></ol></li><li><p>Qt Designer 设计模式</p><ul><li>Edit Widgets 模式：默认模式，可以直接编辑上述部件及其属性，在程序顶部“Edit”菜单可以点击进入；</li><li>Edit Buddies 模式：点击顶部菜单栏相应按钮进入。此模式下，点击控件并拖到另一个部件上可以完成<strong>部件伙伴的设置</strong>，就是之前设置的 <code>widget1-&gt;setBuddy(widget2)</code>；</li><li>Edit Tab Order 模式：点击顶部菜单栏相应按钮进入。此模式下可以<strong>设置 Tab 键顺序</strong>；</li></ul></li><li><p>Qt Designer 中的布局设置</p><ul><li>方法1：使用左边栏的 Layout 控件；</li><li>方法2：按住 CTRL 选中一些 widget，点击顶部菜单栏中的 <code>Lay out Vertically/Horizontally</code>；</li></ul><blockquote><p>注：在布局中加入左边栏中的 <code>Spacer</code> 就等价于之前设置的 <code>layout-&gt;addStretch()</code></p></blockquote></li><li><p>Qt Designer 中的窗口大小设计</p><p>可以点击顶部菜单栏中的 <code>Adjust size</code>（调整大小），可以自动将窗体大小定义为最佳形式（等价于之前的 <code>setFixedHeight(sizeHint().height())</code>）</p></li></ul><h3 id="2-2-2-Qt-Designer-的运行原理【重要】"><a href="#2-2-2-Qt-Designer-的运行原理【重要】" class="headerlink" title="2.2.2 Qt Designer 的运行原理【重要】"></a>2.2.2 Qt Designer 的运行原理【重要】</h3><p>说了这么多 Qt Designer 的基本使用，那么它是怎么将 图形界面中设计的 UI 转换为之前的纯代码，并交给 <code>moc</code> 编译器 和 C++ 编译器的呢？</p><p>细心的同学可能以文本形式打开过 <code>*.ui</code> ，会发现里面的格式是 <code>XML</code> 文件格式，那么它又是如何转化为 <code>*.h/cpp</code> 的呢？<strong>下面先从非 IDE 用户的视角讲述，IDE 用户也建议看一下，因为 Qt Creator IDE 的自动操作比较奇怪，可能不好理解</strong>；</p><p> 以下的案例以名为 <code>myDialog</code> 的主窗口 <code>MainWindow</code> 的设计为例；</p><h4 id="非-IDE-用户的视角"><a href="#非-IDE-用户的视角" class="headerlink" title="非 IDE 用户的视角"></a>非 IDE 用户的视角</h4><p>首先，我们向项目中导入这个 <code>myDialog.ui</code> 文件（创建文件并 <code>qmake -project</code>，即前面的<a href="#important1">要点🔗</a>）；</p><p>你会发现，<code>qmake</code> 自动更新了 pro 文件：<code>FORM += myDialog.ui</code>（不用自己写）；</p><p>紧接着运行 <code>qmake myDialog.pro</code> 生成 <code>Makefile</code> 的同时，<code>qmake</code> 智能识别 <code>myDialog.ui</code>，会在 Makefile 中加入配置规则 <strong>调用 Qt 的新的一种编译器，这不是 GCC，也不是 <code>moc</code>，而是 Qt 用户界面编译器（user interface compiler，uic）</strong>；它会将 <code>myDialog.ui</code> 转换为 C++ 代码存储于 <code>ui_myDialog.h</code> 中；</p><p>在 <code>ui_myDialog.h</code> 会生成一个类，类名是 <code>myDialog</code>，<strong>位于 <code>Ui</code> 命名空间</strong>（命名空间 <code>Ui</code> 是 Qt 中用于存放各种 UI 类 的命名空间，通常存放在里面是一种规范）</p><blockquote><p>⚠ <strong>注意：这里 <code>ui</code> 文件名 <code>XXX.ui</code>、生成的 <code>ui_XXX.h</code> 中的 <code>XXX</code>、生成的类名 <code>XXX</code> 应该是一个名字！！！</strong></p><p>不建议轻易修改，不然有可能在下次编译时，编译器找不到相应组件；</p><p>这也是为什么之前提醒 “创建 <code>*.ui</code> 文件的文件名很重要”；</p></blockquote><p><code>ui_myDialog.h</code> 中自动生成的类看起来像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// #include something</span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE    <span class="comment">// Qt 独有的宏，将其中的类加入特定的namespace中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ui_myDialog</span> &#123;        <span class="comment">// 生成类，由于它谁都不继承，功能少，通常作为中间类使用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Widgets</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setupUi</span><span class="params">(QMainWindow* myDialog)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// realize ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">myDialog</span>: <span class="keyword">public</span> ui_myDialog &#123;&#125;;    <span class="comment">// Qt 自动在 Ui 命名空间中</span></span><br><span class="line">&#125;                                <span class="comment">// 定义了继承于 ui_myDialog 的类 myDialog</span></span><br></pre></td></tr></table></figure><p>而真正想要应用这个窗口类，需要进行<strong>多继承</strong>，使用它和 <code>QMainWindow</code> 的子类——<strong>毕竟这个类不是 <code>QObject</code>，没有办法完成信号-槽的创建</strong>；</p><p>所以一般情况下将 <code>ui_myDialog</code> 类作为中间类，再<strong>手动</strong>为这个窗口创建 <code>myDialog.h</code> 和 <code>myDialog.cpp</code>，分别书写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: myDialog.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_myDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请注意！！！这里的 myDialog 和之前定义在 ui_myDialog.h 文件中 Ui 命名空间中的类 myDialog 不一样！</span></span><br><span class="line"><span class="comment">// 这里的 myDialog 和 Ui::myDialog 类进行了继承，使 myDialog 具有了 Ui::myDialog 类一样的控件作为属性</span></span><br><span class="line"><span class="comment">// 同时 myDialog 还和 QMainWindow 进行多继承，使 myDialog 还具有 QMainWindow的属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myDialog</span> : <span class="keyword">public</span> QMainWindow, <span class="keyword">public</span> Ui::myDialog &#123;</span><br><span class="line">    Q_OBJECT        <span class="comment">// 为何需要继承 Ui::myDialog，组合不行吗？不行。</span></span><br><span class="line"><span class="keyword">public</span>:                <span class="comment">// 因为需要修改信号-槽连接，涉及其中的控件</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">myDialog</span><span class="params">(QWidget* parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: myDialog.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 myDialog 是 QMainWindow 的子类，因此想要重用它的属性，</span></span><br><span class="line"><span class="comment">// 需要委托调用父类的构造函数：QMainWindow(parent)；</span></span><br><span class="line"><span class="comment">// 此外，setupUi(this) 是以当前窗口为顶级控件，按 UI 设计部署控件</span></span><br><span class="line">myDialog::<span class="built_in">myDialog</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个只有图形界面、没有添加 槽-函数 连接的主窗口类 <code>myDialog</code> 就设计完成了；</p><blockquote><p>提示：除了上面的继承方法，还可以把 <code>Ui::myDialog</code> 作为 <code>myDialog</code> 的一个数据成员使用。</p></blockquote><h4 id="IDE-用户视角"><a href="#IDE-用户视角" class="headerlink" title="IDE 用户视角"></a>IDE 用户视角</h4><p>事实上，使用 Qt Creator 的用户在一开始，<strong>向项目中添加 <code>UI 设计师文件</code></strong>，IDE 会提示用户起名的时候，就会同时创建 <code>myDialog.ui</code>、<code>myDialog.h</code>、<code>myDialog.cpp</code> 三个文件，并更新 <code>&lt;项目名称&gt;.pro</code> 文件，直接省去非 IDE 方法中所有步骤；</p><p>值得一提的是，Qt Creator 在编译时生成的 <code>ui_myDialog.h</code> 不在项目目录中（也许是考虑到相关性），而藏在上层 build_XXX 目录里，不过使用的时候也无需注意，因为引入工作已经在自动生成的 <code>myDialog.h</code> 中写好了；</p><p>这下关于 Qt Designer 的运行机制、IDE 封装的机制是不是更清楚了呢？</p><h3 id="2-2-3-案例演示"><a href="#2-2-3-案例演示" class="headerlink" title="2.2.3 案例演示"></a>2.2.3 案例演示</h3><blockquote><p>本节将一步步地完成 2.2.1 中的窗体设计目标；将以非 IDE 的方式完成（IDE 的操作简单就不演示了）（<strong>注意，它的角色是子窗口</strong>）</p></blockquote><ol><li><p>创建一个项目目录：新建项目文件夹 <code>testUI</code>，创建文件 <code>main.cpp</code>、<code>GoToCellDialog.cpp</code>、<code>GoToCellDialog.h</code>；</p></li><li><p>打开 Qt Designer，选择 <code>Dialog without button</code> 模板，按照图中要求设计出 UI，窗体命名为 <code>GoToCellDialog</code>（<code>objectName</code>），保存文件为 <code>GoToCellDialog.ui</code>，记得保存在项目目录中；</p></li><li><p>命令行切换至项目目录，新建目录 build（为了让项目目录更干净，build 就设置在项目目录里面，你也可以设置在其他地方，比如上层目录——Qt Creator IDE 就是这么干的），命令行切入，运行 <code>qmake -project ../</code>，向 生成的 <code>testUI.pro</code> 中添加 <code>QT += widgets</code>；</p></li><li><p>编写 Go to Cell 窗体的主要逻辑代码（包括信号-槽的定义）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: GoToCellDialog.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_GoToCellDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoToCellDialog</span> : <span class="keyword">public</span> QDialog, <span class="keyword">public</span> Ui::GoToCellDialog &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoToCellDialog</span>(QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 自定义槽</span></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="comment">// 注意：这么命名是有讲究的！！！</span></span><br><span class="line">    <span class="comment">// 在 uic 和 moc 编译时，会识别所有 on_&lt;objectName&gt;_&lt;signalName&gt;() 命名的函数，自动连接：</span></span><br><span class="line">    <span class="comment">// connect(lineEdit, SIGNAL(textChanged(const QString&amp;)),</span></span><br><span class="line">    <span class="comment">//             this, SLOT(on_lineEdit_textChanged()));</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_lineEdit_textChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: GoToCellDialog.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GoToCellDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数中的 widget 变量名就是之前你在 GoToCellDialog.ui 设计中的 objectName</span></span><br><span class="line">GoToCellDialog::<span class="built_in">GoToCellDialog</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setupUi</span>(<span class="keyword">this</span>);    <span class="comment">// 以当前对象为父 widget 初始化窗体部件</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">QRegExp <span class="title">reg</span><span class="params">(<span class="string">&quot;[a-zA-Z][1-9][0-9]&#123;0,2&#125;&quot;</span>)</span></span>;        <span class="comment">// 正则表达式类</span></span><br><span class="line">    <span class="comment">// 新方法：为 QLineEdit 类设置正则可接受检验器</span></span><br><span class="line">    <span class="comment">// QRegExpValidator 的构造函数 第一个参数是 QRegExp（正则Pattern）</span></span><br><span class="line">    <span class="comment">// 第二个参数是 parent，使 QRegExpValidator 对象成为 parent 的</span></span><br><span class="line">    <span class="comment">// 子控件，这样就不要手动 delete，在父控件析构时，子控件一起析构了（之前提过）</span></span><br><span class="line">    lineEdit-&gt;<span class="built_in">setValidator</span>(<span class="keyword">new</span> <span class="built_in">QRegExpValidator</span>(reg, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置信号-槽</span></span><br><span class="line">    <span class="comment">// 这里的 accept() 和 reject() 槽是 QDialog 的固有槽，</span></span><br><span class="line">    <span class="comment">// 触发这两槽之一都会关闭窗口，但是分别会修改：</span></span><br><span class="line">    <span class="comment">// QDialog::Accepted 和 QDialog::Rejected 数据成员的值，</span></span><br><span class="line">    <span class="comment">// 以便主窗口判断用户执行了什么操作</span></span><br><span class="line">    <span class="built_in">connect</span>(okBtn, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">accept</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(cancelBtn, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">reject</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是指，当文本框改变，就进入这个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoToCellDialog::on_lineEdit_textChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果经过 QRegExpValidator 检查符合，那么激活 okBtn，否则禁用</span></span><br><span class="line">    okBtn-&gt;<span class="built_in">setEnabled</span>(lineEdit-&gt;<span class="built_in">hasAcceptableInput</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GoToCellDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    GoToCellDialog* dialog = <span class="keyword">new</span> GoToCellDialog;</span><br><span class="line">    </span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行 <code>qmake testUI.pro</code>；</p></li><li><p><strong>Windows 用户</strong>请按照之前所说的，在当前命令行运行 <a href="#script-env">配置临时环境变量的脚本🔗</a> ；</p></li><li><p>Unix 用户 执行 <code>make</code>，Windows 用户执行 <code>mingw32-make</code>，构建完成；</p></li></ol><p>如此一来，一个子窗口类的演示就做好了；</p><h1 id="Chapter-3-Qt：样式更丰富的子窗口"><a href="#Chapter-3-Qt：样式更丰富的子窗口" class="headerlink" title="Chapter 3 Qt：样式更丰富的子窗口"></a>Chapter 3 Qt：样式更丰富的子窗口</h1><blockquote><p>前面几章，只是零碎地介绍基本编写方法；</p><p>在 1.4 中，初步学习了 面向过程的简单<strong>主窗口纯代码</strong>设计；</p><p>在 2.1 中，初步学习了 面向对象的简单<strong>子窗口纯代码</strong>设计；</p><p>在 2.2 中，初步学习了 面向对象的简单<strong>子窗口快速 UI</strong> 设计；</p><p>本章将介绍更多其他样式的子窗口的设计；</p></blockquote><h2 id="3-1-扩展对话框"><a href="#3-1-扩展对话框" class="headerlink" title="3.1 扩展对话框"></a>3.1 扩展对话框</h2><p><img src="externDialog.png" height="300px"></p><p>本节技术栈并没有拓展，还是之前的 Qt Creator、Qt Designer 使用技术；</p><p>此处仅会提及新出现的控件属性或方法等信息；</p><ul><li><code>QPushButton</code> 的属性 <code>checkable</code> ：如果修改为 <code>true</code>，则在用户点击一下后持续有效（相当于 <code>checkBox</code>），再次点击才会还原；</li><li><code>QPushButton</code> 的槽 <code>toggled(bool)</code>：当按钮 <code>enabled</code> 属性被改变时，<code>toggle</code> 会发射信号，参数就不用说了吧，，这个槽在按钮为 <code>checkable</code> 时有用；</li><li><code>QPushButton</code> 的槽 <code>setText(QString)</code>：可以在中途改变按钮的文本；</li><li><code>QGridLayout</code> 布局管理器：在 1.4.3 中介绍过，如果发现按钮较多，而且摆不整齐的时候可以尝试这个布局，它可以使控件按照行、列的规则摆放；</li><li><strong>有些人会疑惑水平/竖直分隔符（spacer）有什么用</strong>，其实它就像 Qt Designer 上画的一样，用来在窗口伸缩时，调节控件之间的位置关系的；</li><li>在 2.2.1 中，其实还有一种 <strong>Qt Designer 设计模式没有介绍到：Edit Signals/Slots</strong>，在此模式下可以<strong>直接编辑信号-槽连接</strong>，无需手动写 <code>connect</code> 函数；使用方法 和 Edit Buddy 模式类似，感兴趣可以尝试一下；</li><li><strong>新的类 <code>QGroupBox</code> 组群盒</strong>：如上图，就是那一个个小方框；</li><li>大多数 Widget 都有一个槽：<code>QWidget::setVisible(bool)</code>，可以理解为<strong>含参数、可重用的 <code>QWidget::close()</code>槽</strong>；</li><li>快捷复制：按住 CTRL，单击要复制的控件，再拖动就能复制了 ~</li><li><strong>新的类 <code>QComboBox</code> 下拉栏选择器</strong><ul><li>具有方法 <code>clear()</code>，常用在初始化时，清空选项；</li><li>具有方法 <code>addItem(QString)</code>，添加下拉栏内容，一般在 Qt Designer 里添加，也可自己在代码里写；</li><li>具有方法 <code>setMinimumSize(int)</code>，设置下拉栏的最小大小值；</li></ul></li><li><p><strong>新的类 <code>QChar</code> 字符类</strong></p><ul><li>具有方法 <code>unicode()</code>：转化为 unicode 码，可以运算；</li><li>可以作为 <code>QString</code> 的初始化参数；</li></ul></li><li><p><strong>设置窗口固定尺寸的常用方法：<code>layoutName-&gt;setSizeConstraint(QLayout::SetFixedSize)</code></strong>；</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: SortDialog.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_SortDialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortDialog</span> : <span class="keyword">public</span> QDialog, <span class="keyword">public</span> Ui::SortDialog &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SortDialog</span>(QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// Initialize the content of each column comboBox</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColumnRange</span><span class="params">(QChar first, QChar last)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: SortDialog.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortDialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtGui&gt;</span></span></span><br><span class="line"></span><br><span class="line">SortDialog::<span class="built_in">SortDialog</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent) &#123;</span><br><span class="line">    <span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// Hide the group box first,</span></span><br><span class="line">    <span class="comment">// Because the setVisible(bool) function hasn&#x27;t been called.</span></span><br><span class="line">    secondaryGroupBox-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    tertiaryGroupBox-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="comment">// Fix the size of the window</span></span><br><span class="line">    <span class="built_in">layout</span>()-&gt;<span class="built_in">setSizeConstraint</span>(QLayout::SetFixedSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setColumnRange</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortDialog::setColumnRange</span><span class="params">(QChar first, QChar last)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clear the content of each comboBox</span></span><br><span class="line">    primaryColCombo-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    secondaryColCombo-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    tertiaryColCombo-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional</span></span><br><span class="line">    secondaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">tr</span>(<span class="string">&quot;None&quot;</span>));</span><br><span class="line">    tertiaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">tr</span>(<span class="string">&quot;None&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于 primaryColCombo 中显示单字符时，展示的宽度小于</span></span><br><span class="line">    <span class="comment">// secondary 和 tertiary ColCombo 显示的 “None”，所以设置</span></span><br><span class="line">    <span class="comment">// primaryColCombo 的最小宽度，防止宽度不相同的现象</span></span><br><span class="line">    primaryColCombo-&gt;<span class="built_in">setMinimumSize</span>(secondaryColCombo-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line"></span><br><span class="line">    QChar ch = first;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= last) &#123;</span><br><span class="line">        primaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">QString</span>(ch));</span><br><span class="line">        secondaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">QString</span>(ch));</span><br><span class="line">        tertiaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">QString</span>(ch));</span><br><span class="line">        ch = ch.<span class="built_in">unicode</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    SortDialog* dialog = <span class="keyword">new</span> SortDialog;</span><br><span class="line">    <span class="comment">// 测试函数是否能用</span></span><br><span class="line">    dialog-&gt;<span class="built_in">setColumnRange</span>(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行项目即可；</p><h2 id="3-2-Qt-内置的更多部件和对话框"><a href="#3-2-Qt-内置的更多部件和对话框" class="headerlink" title="3.2 Qt 内置的更多部件和对话框"></a>3.2 Qt 内置的更多部件和对话框</h2><blockquote><p>这里仅作初步介绍，在完整项目的应用中会进一步介绍使用方法，因为一次性看完很可能记不住……</p></blockquote><ul><li><p>Qt 中的按钮类</p><ul><li>QPushButton：之前演示的普通按钮；</li><li>QToolButton：具有图标的功能按钮；</li><li>QCheckBox：复选框类；</li><li>QRadioButton：单选框类，只能在一组中选一个激活；</li></ul><p><img src="btns.png" height="100px"></p></li><li><p>Qt 中的单页容器部件</p><ul><li>QGroupBox：之前演示的群组框；</li><li>QFrame：QLabel 的父类，可以用来展示图片、文字等信息（所以 QLabel 也行）；</li></ul></li><li><p>Qt 中的多页容器部件</p><ul><li>QTabWidget：切换多个 Tab 的窗口控件；</li><li>QToolBox：切换不同工具分类的窗口控件；</li></ul><p><img src="multiPWidgets.png" height="200"></p></li><li><p>Qt 中的显示窗口部件：<code>QLabel</code>、<code>QLCDNumber</code>、<code>QProgressBar</code>、<code>QTextBrowser</code></p><p>注：QTextBrowser 是只读的 QTextEdit 子类，也可以显示带格式的文本，<strong>建议处理大型格式化文本</strong>，因为它和 QLabel 不同，可以在必要时自动提供滚动条；</p><p><img src="showWidgets.png"></p></li><li><p>Qt 中的输入窗口部件：<code>QSpinBox</code>、<code>QDoubleSpinBox</code>、<code>QComboBox</code>、<code>QDateEdit</code>、<code>QTimeEdit</code>、<code>QDateTimeEdit</code>、<code>QScrollBar</code>、<code>QSlider</code>、<code>QTextEdit</code>、<code>QLineEdit</code>、<code>QDial</code></p><p>注：QTextEdit 支持输入掩码、检验器（2.2.3 已演示）等功能；</p><p><img src="inputWidgets.png"></p></li><li><p>Qt 的反馈对话框：<code>QInputDialog</code>、<code>QProgressDialog</code>、<code>QMessageBox</code>、<code>QErrorMessage</code>、<code>QColorDialog</code>、<code>QFontDialog</code>、<code>QFileDialog</code>、<code>QPrintDialog</code> 等；</p></li></ul><h2 id="3-3-Qt-类的第二次总结-amp-下文预告"><a href="#3-3-Qt-类的第二次总结-amp-下文预告" class="headerlink" title="3.3 Qt 类的第二次总结 &amp; 下文预告"></a>3.3 Qt 类的第二次总结 &amp; 下文预告</h2><blockquote><p>学完了以上的知识，目前使用到的 Qt 类的框架如下图所示：</p></blockquote><p><img src="C3.png"></p><p><strong>同系列下一篇文章预告：将会是 第一个完整的 Qt 入门项目（会非常地长，比本篇还长），目的是通过实战来学习 Qt 的更多类的用法，源代码和程序 届时会放在仓库，以供读者参考。</strong></p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Qt </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake 进阶</title>
      <link href="//technical/cmake-advanced/"/>
      <url>//technical/cmake-advanced/</url>
      
        <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference: </i> <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMake Tutor</a></p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p>本文目标：在前文（GNU Tutor）<strong>初步了解 CMake、C++ 编译过程后</strong>，继续深入学习 CMake 在 C++ 构建中的使用；</p><hr><span id="more"></span><blockquote><p>⚠ <strong>劝退警告：如果你只想用 IDE 一键编译运行，而不想了解构建和编译细节，那么这篇文章不是为你准备的！</strong></p></blockquote><h2 id="Chapter-0-Make-介绍"><a href="#Chapter-0-Make-介绍" class="headerlink" title="Chapter 0. Make 介绍"></a>Chapter 0. Make 介绍</h2><blockquote><p><strong>对 Make 没兴趣的这章可以跳过</strong>！</p><p>CMake 生成的 Makefile 究竟是什么？语法是怎样？为什么要有它？</p><p>由于现在是 21 世纪 20 年代，所以像 <code>make</code> 这样底层的古董就点到为止；；</p></blockquote><ul><li><p>地位：GNU 计划的一个开源程序；</p></li><li><p>作用</p><ol><li>制定整个项目的<strong>编译规则</strong>（利用 <code>Makefile</code> 定义整个编译流程以及各个目标文件与源文件之间的依赖关系），自动化编译步骤，以此提高开发效率；</li><li>二次编译时，仅重新编译你的修改会影响到的部分，从而降低编译的时间；</li></ol></li><li><p>劣势：为什么上面说 “点到为止”？因为它比较底层，导致抽象层级不高，<strong>不能跨平台</strong>，每个平台有各自的 make 程序，导致编写 <code>Makefile</code> 较为繁琐；</p><blockquote><p>例如在 前文 “GNU Tutor” 中提到的 MinGW 编译器中的 make 和 Unix 系统下的 make 就有所差别；</p></blockquote><p><strong>这一劣势将由 CMake 进行弥补</strong>，之后讨论；</p></li></ul><h3 id="0-1-Makefile-的规则"><a href="#0-1-Makefile-的规则" class="headerlink" title="0.1 Makefile 的规则"></a>0.1 Makefile 的规则</h3><h4 id="0-1-1-显式规则"><a href="#0-1-1-显式规则" class="headerlink" title="0.1.1 显式规则"></a>0.1.1 显式规则</h4><ul><li><p>定义：显式规则说明了如何生成一个或多个目标文件。这是由 Makefile 的书写者明显指出要生成的文件、文件的依赖文件和生成的命令；</p></li><li><p>基本语法：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt;</span><br><span class="line">    &lt;command&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># And   &lt;-- Makefile 的行注释是 “#” 字符</span></span><br><span class="line"></span><br><span class="line">&lt;pTarget&gt; :</span><br><span class="line">    &lt;command&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>target</code>：可以是一个object file（<code>*.o</code>），也可以是一个执行文件（最终目标）；</p></li><li><p><code>pTarget</code>：在一个 makefile 中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等；被称为<strong>伪目标</strong>；</p><blockquote><p><code>pTarget</code> 部分在运行 <code>make</code> 的时候不会自动调用，外界可以使用 <code>make [pTargetName]</code> 来手动调用，例如：<code>make clean</code>，<code>make install</code> （如果 Makefile 中定义了的话）</p></blockquote></li><li><p><code>prerequisites</code>：生成该 <code>target</code> 所依赖的文件<strong>和</strong> <code>target</code>；</p></li><li><p><code>command</code>：该 <code>target</code> 或 <code>motion</code> 要执行的命令（任意的 shell 命令）</p></li></ul><p><strong>这指明了文件的依赖关系，即：<code>target</code> 这一个或多个的目标文件依赖于 <code>prerequisites</code> 中的文件，其生成规则定义在 <code>command</code> 中。</strong></p><blockquote><p>有有同学会问，Make 是怎么做到 <strong>上面的第二条作用（仅重新编译修改的部分）</strong>的呢？</p><p>很简单，如果 <code>prerequisites</code> 文件的日期要比 <code>targets</code> 文件的日期要新，或者 <code>target</code> 不存在的话，那么，make 就会执行后续定义的 <code>command</code>；</p></blockquote></li><li><p>示例：这个例子可以不需要了解项目依赖关系；废话少说，上栗子🌰：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设有一个项目包含 3 个头文件、8个源文件（名称如下）：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终目标 edit</span></span><br><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间目标</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪目标</span></span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">backup :</span><br><span class="line">    cp edit main.o kbd.o command.o display.o \</span><br><span class="line">     insert.o search.o files.o utils.o /opt/</span><br><span class="line">install :</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><ul><li><p>中间目标一般都是 <code>*.o</code> ；最终目标视需求而定，可以是可执行文件，也可以是动/静态链接库；</p></li><li><p><code>prerequisites</code> 是目标的依赖，一般是 <code>*.h/c/cpp</code>；</p></li><li><p><code>command</code> 是获得目标 / 完成动作的操作；上面的例子中，<strong><code>cc</code> 是 C 的编译器命令，<code>cp</code> 和 <code>rm</code> 是 Unix 系统的命令</strong>；</p><blockquote><ol><li><strong>必须以制表符（或者说 <code>\t</code>、Tab 键）开头</strong>；</li><li>默认工作目录为 Makefile 所在目录；</li></ol></blockquote></li></ul></li><li><p><strong>（规范）伪目标声明</strong>：对于<strong>伪目标</strong>而言，应该使用 <code>.PHONY</code> 关键字声明，更符合规范；</p><p>例如上面例子的规范写法应该加上：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean backup install</span><br></pre></td></tr></table></figure><p>另外，规范来说，请将所有伪目标写在后面，以防读者误认为最终目标；</p><ul><li><p>作用：防止与文件名/最终目标重名，增强可读性；</p></li><li><p>特点：伪目标<strong>可以有依赖</strong>，这样相当于是<strong>委托调用</strong>，例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">    rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">    rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">    rm *.diff</span><br></pre></td></tr></table></figure></li></ul></li><li><p>指定文件查找目录：<code>VPATH</code> 关键字（知道就行）；</p></li></ul><h4 id="0-1-2-隐晦规则"><a href="#0-1-2-隐晦规则" class="headerlink" title="0.1.2 隐晦规则"></a>0.1.2 隐晦规则</h4><blockquote><p>作用：make 有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile；</p></blockquote><ol><li>生成 <code>*.o</code> 时，默认将同名的 <code>*.c/cpp</code> 加入依赖中，同时<strong>省去相应的编译命令</strong>；</li><li>当 make 在 Makefile 中找不到与目标同名的 <code>*.c/cpp</code>，那么 make 认为这个目标为伪目标；</li></ol><p>因此，利用隐晦规则，最开始的例子可以简化为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">    </span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><blockquote><p>注：上面的 “<code>-rm edit</code>” 前面有个 “-”，表示中间如果出现错误，也请继续进行的意思（忽略错误）；</p><p>这里正好补充一下 Makefile 的变量使用：</p><ul><li>定义：<code>name=value</code>；调用：<code>$&#123;variableName&#125;</code>；</li><li><strong>类似 C++ 中的宏替换</strong>（后面介绍赋值运算符）；</li></ul></blockquote><h4 id="0-1-3-文件指示-和-编译设置"><a href="#0-1-3-文件指示-和-编译设置" class="headerlink" title="0.1.3 文件指示 和 编译设置"></a>0.1.3 文件指示 和 编译设置</h4><p><strong>文件指示一共包含 3 个部分</strong>：</p><ol><li><strong>在一个 Makefile 中引用另一个 Makefile</strong>，就像 C 语言中的 #include 一样；</li><li>根据某些情况<strong>指定 Makefile 中的有效部分</strong>，就像 C 语言中的预编译 #if 一样；</li><li>还有就是<strong>定义一个多行的命令</strong>，不会深入介绍，感兴趣请查看 <a href="https://seisman.github.io/how-to-write-makefile/index.html">教程</a>；</li></ol><p>这里就介绍第一个：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make *.mk $&#123;bar&#125;</span><br></pre></td></tr></table></figure><p>上面这行代码的含义是：包含 <code>foo.make</code>，所有后缀为 <code>mk</code> 的，和在变量 <code>$&#123;bar&#125;</code> 中的文件作为 Makefile；</p><p>此外，以 UNIX 为例，make 自动包含了 <code>/usr/local/bin</code> 和 <code>/usr/include</code> 中的文件；</p><p>还可以加上 “-” 表示读取错误全部忽略：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> foo.make *.mk $&#123;bar&#125;</span><br></pre></td></tr></table></figure><p><strong>编译设置</strong> 最常用的是设置 C++ 编译器，可以由修改内置变量完成：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC := clang</span><br><span class="line">CXX := clang++</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码含义是：<strong>将 C 编译器改为 <code>clang</code>，将 C++ 编译器改为 <code>clang++</code></strong>；</p></blockquote><h4 id="0-1-4-赋值运算符"><a href="#0-1-4-赋值运算符" class="headerlink" title="0.1.4 赋值运算符"></a>0.1.4 赋值运算符</h4><blockquote><p>看到上面的例子，大家可能有些疑惑，<code>:=</code> 和 <code>=</code> 赋值有区别吗？答案是，有的。</p></blockquote><ul><li><p><code>=</code> 是<strong>保留计算式</strong>的赋值；</p></li><li><p><code>:=</code> 是<strong>立刻计算结果</strong>并覆盖原来的值；</p></li><li><p><code>?=</code> 是如果没有被赋值过就赋予等号后面的值；</p></li><li><p><code>+=</code> 是添加等号后面的值；</p></li></ul><p>举个例子体会一下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = foo</span><br><span class="line">y = <span class="variable">$(x)</span> bar</span><br><span class="line">x = xyz</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="string">&quot;<span class="variable">$(y)</span>&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := xyz</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="string">&quot;<span class="variable">$(y)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>上面一段 Makefile 运行 <code>make all</code> 会输出：<code>xyz bar</code>；</p><p>而下面一段会输出：<code>foo bar</code>；</p><h4 id="0-1-5-小结：Make-的工作方式"><a href="#0-1-5-小结：Make-的工作方式" class="headerlink" title="0.1.5 小结：Make 的工作方式"></a>0.1.5 小结：Make 的工作方式</h4><ol><li><p>读入所有的 Makefile；</p></li><li><p>读入被 include 的其它 Makefile；</p></li><li><p>初始化文件中的变量；</p></li><li><p>推导隐晦规则，并分析所有规则；</p></li><li><p>为所有的目标文件创建依赖关系链；</p></li><li><p>根据依赖关系，决定哪些目标要重新生成；</p></li><li><p>执行生成命令；</p></li></ol><h3 id="0-2-Make-命令的使用"><a href="#0-2-Make-命令的使用" class="headerlink" title="0.2 Make 命令的使用"></a>0.2 Make 命令的使用</h3><ul><li>Windows 上如果安装 <code>MinGW</code> 编译器套件，那么应该使用 <code>mingw32-make</code> 来进行；不讨论 <code>MSVC</code> 编译器套件 ~ 用它的大多数是用了微软的 Visual Studio 的套件；</li><li>Linux 本身就是 GNU 产物，直接安装 <code>make</code> 就能用了；</li></ul><h2 id="Chapter-1-CMake-命令使用"><a href="#Chapter-1-CMake-命令使用" class="headerlink" title="Chapter 1. CMake 命令使用"></a>Chapter 1. CMake 命令使用</h2><p>众所周知，CMake 可以完成 2 步：① 将 CMakeLists.txt 翻译生成 Makefile；② 代替 make 完成编译构建；</p><p>下面我们特指 ① 为 <strong>生成</strong>，② 为 <strong>编译/构建</strong>；</p><h3 id="1-1-生成指令"><a href="#1-1-生成指令" class="headerlink" title="1.1 生成指令"></a>1.1 生成指令</h3><p>总体语法：<code>cmake [options] &lt;projectDir&gt;</code>（<code>projectDir</code> 需含有 <code>CMakeLists.txt</code>）；</p><p>下面介绍 <code>[options]</code>：</p><ul><li><p>指定生成 Makefile 等中间文件的目录（生成时会将所有文件放入该目录）：<code>-B &lt;dirName&gt;</code>（<code>dirName</code> 默认当前目录，下同）；</p></li><li><p><strong>指定生成的 Makefile 种类</strong>：<code>-G &lt;Makefile-Type&gt;</code>；</p><blockquote><p>这里 Unix 类系统（macOS 和 Linux）会默认 <code>&quot;Unix Makefiles&quot;</code>，<strong>大多数情况下无需更改</strong>，因为<strong>使用 Unix 内置的 GNU/Make 程序和 GNU/GCC 编译器</strong>；</p><p>这里<strong>对于 Windows 用户很重要</strong>，因为 Windows 的 make 工具种类很多，针对您所安装的编译器对应的 <code>make</code>，需要进行合理选择，取值有（有空格，命令行里记得加双引号）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Visual Studio 17 2022        &lt;--- 使用 VS IDE 的同学不需要指定，IDE 会自动设置</span><br><span class="line">Visual Studio 16 2019</span><br><span class="line">Visual Studio 15 2017 [arch]</span><br><span class="line">Visual Studio 14 2015 [arch]</span><br><span class="line">Visual Studio 12 2013 [arch]</span><br><span class="line">Visual Studio 11 2012 [arch]</span><br><span class="line">Visual Studio 9 2008 [arch]</span><br><span class="line">Borland Makefiles</span><br><span class="line">NMake Makefiles            &lt;--- 使用 nmake 的同学选这个</span><br><span class="line">NMake Makefiles JOM</span><br><span class="line">MSYS Makefiles</span><br><span class="line">MinGW Makefiles            &lt;--- 使用正宗 MinGW 编译器的同学选这个</span><br><span class="line">Green Hills MULTI</span><br><span class="line">Unix Makefiles            &lt;--- Unix 系统的同学不需要指定，系统会自动设置</span><br><span class="line">Ninja                    &lt;--- 使用 Ninja 的同学选这个</span><br><span class="line">Ninja Multi-Config</span><br><span class="line">Watcom WMake</span><br><span class="line">CodeBlocks - MinGW Makefiles    &lt;--- 你的 codeblocks 装了什么编译器？</span><br><span class="line">CodeBlocks - NMake Makefiles</span><br><span class="line">CodeBlocks - NMake Makefiles JOM</span><br><span class="line">CodeBlocks - Ninja</span><br><span class="line">CodeBlocks - Unix Makefiles</span><br><span class="line">CodeLite - MinGW Makefiles</span><br><span class="line">CodeLite - NMake Makefiles</span><br><span class="line">CodeLite - Ninja</span><br><span class="line">CodeLite - Unix Makefiles</span><br><span class="line">Eclipse CDT4 - NMake Makefiles</span><br><span class="line">Eclipse CDT4 - MinGW Makefiles</span><br><span class="line">Eclipse CDT4 - Ninja</span><br><span class="line">Eclipse CDT4 - Unix Makefiles</span><br><span class="line">Kate - MinGW Makefiles</span><br><span class="line">Kate - NMake Makefiles</span><br><span class="line">Kate - Ninja</span><br><span class="line">Kate - Ninja Multi-Config</span><br><span class="line">Kate - Unix Makefiles</span><br><span class="line">Sublime Text 2 - MinGW Makefiles</span><br><span class="line">Sublime Text 2 - NMake Makefiles</span><br><span class="line">Sublime Text 2 - Ninja</span><br><span class="line">Sublime Text 2 - Unix Makefiles</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="1-2-编译构建指令"><a href="#1-2-编译构建指令" class="headerlink" title="1.2 编译构建指令"></a>1.2 编译构建指令</h3><ul><li><p><strong>构建编译</strong>（可代替 <code>make</code>）：<code>cmake --build &lt;dirName&gt;</code>；</p><blockquote><p>和 Make 一样，可以仅重新编译你的修改会影响到的部分，从而降低编译的时间；</p></blockquote></li></ul><h2 id="Chapter-2-CMakeList-常见函数"><a href="#Chapter-2-CMakeList-常见函数" class="headerlink" title="Chapter 2. CMakeList 常见函数"></a>Chapter 2. CMakeList 常见函数</h2><blockquote><p>注：CMake 的函数名不区分大小写；</p><p>以下函数分为 3 个等级：optional 可选、recommended 推荐书写、necessary 必要；</p><p>众所周知，C++ 项目的编译和构建的目标可以是 <strong>可执行文件</strong>，也可以是<strong>静/动态链接库</strong>；以下函数如果仅用于某个特定目标，那么会标注 <strong>in EXE Project</strong> 或 <strong>in LIB Project</strong>；</p></blockquote><ul><li><p>【optional】指定 CMake 版本，可选低于版本产生致命错误：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ver 建议是当前系统中的 CMake 版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION &lt;ver&gt; [FATAL_ERROR])</span><br><span class="line"><span class="comment"># 例如我的 CMake 版本是 3.12，并且想让其他人生成时，CMake低于这个版本就报错，那么这么写：</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span> FATAL_ERROR)</span><br></pre></td></tr></table></figure></li><li><p>【recommended】指定 Project 名称、使用编译器语言（不填写也可自动识别）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span> (&lt;projectName&gt; [LANGUAGES CXX])</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意，这里指定项目名称后，变量 <code>$&#123;PROJECT_NAME&#125;</code> 就被设定了，可以在后面使用</strong>；</p></blockquote></li><li><p>【optional】告诉编译器从哪里寻找非标准 C++ 的头文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span> (&lt;dir&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>可以理解为：</p><p>Makefile 中的 include 关键字：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;dir&gt;/*</span><br></pre></td></tr></table></figure><p>或者 g++ 中的 <code>-I</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ [...] -I&lt;<span class="built_in">dir</span>&gt; [...]</span><br></pre></td></tr></table></figure></blockquote></li><li><p>【optional】向指定目标规定寻找非标准 C++ 头文件路径：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TARGET_INCLUDE_DIRECTORIES</span> (&lt;targetName&gt; [INTERFACE | PRIVATE | PUBLIC] &lt;dir&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PUBLIC 表示这个项目的外部使用者能看到</span></span><br><span class="line"><span class="comment"># PRIVATE 则对外部完全隐藏，即不希望调用这个项目目标的使用者知道“这个项目引入了该头文件”</span></span><br></pre></td></tr></table></figure><blockquote><p><strong><code>INCLUDE_DIRECTORIES</code> 和 <code>TARGET_INCLUDE_DIRECTORIES</code> 比较：</strong></p><p>前者是向整个项目（包括子目录和库）添加了寻找头文件的寻找路径；</p><p>后者是向特定目标添加了寻找头文件的寻找路径，<strong>同时可以指定暴露级别</strong>；</p><p><strong>这就和不同范围设置 C++ 标准异曲同工</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_STANDARD <span class="number">11</span>)        <span class="comment"># 全局设置 C++ 规范</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">TARGET_COMPILE_FEATURES</span> (&lt;targetName&gt; [...] cxx_std_11)    <span class="comment"># 设置特定库的规范</span></span><br></pre></td></tr></table></figure><p>从项目规范性上说，<strong>建议使用 <code>TARGET_INCLUDE_DIRECTORY</code> 而非 <code>INCLUDE_DIRECTORY</code></strong>；</p></blockquote></li><li><p>【necessary <strong>in EXE Project</strong>】将指定源文件加入构建为 <strong>可执行文件</strong> 的目标中：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (&lt;exeName&gt; &lt;sourceFileNames&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>位于 <code>TARGET_LINK_LIBRARIES</code> 前，在其他函数之后；</p><p><strong>注意，和 Make 的隐晦规则恰好相反，如果这个头文件被某一源文件引入的话，可以省略对应的头文件</strong>；</p></blockquote></li><li><p>【recommended】查找指定目录下的所有源文件，并将文件名存入变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (&lt;dir&gt; &lt;variableName&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>此后就能使用变量：<code>$&#123;&lt;variableName&gt;&#125;</code>；</p></blockquote></li><li><p>【optional】给项目加入子目录（<strong>即读取这个目录下的 <code>CMakeLists.txt</code></strong>）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span> (&lt;dir&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>书写这个函数后，在主 <code>CMakeLists.txt</code> 中就可以直接指明子目录下生成的目标名，<strong>这在导入并链接自己编写的 动/静态链接库 时用的较多</strong>；</p></blockquote></li><li><p>【necessary <strong>in LIB Project</strong>】将指定源文件加入构建为 <strong>链接库</strong> 的目标中：</p><blockquote><p>请大家复习一下什么是 “静态链接库”、什么是 “动态链接库”：</p><p>静态链接库是 <strong>运行前、编译时可以链接进入到目标文件中</strong>，优点是分发时文件个数少，不依赖外部文件；缺点是修改了静态链接库的内容的话程序整体需要重新编译；</p><p>动态链接库是 <strong>运行时才链接到目标文件中</strong>，优点是只要 API 不变，修改动态链接库可以单独进行编译，并且节省内存（仅在调用库函数时才加载到内存中）；缺点是文件分发数多，不便管理；</p><p><strong>注：C++ 的库的隐含规则——链接库文件名是 “lib” + 库名 + 后缀</strong>；</p></blockquote><ol><li><p><strong>目标为静态链接库</strong>（后缀名可能是 <code>*.a</code>、<code>*.lib</code>，<strong>和操作系统、编译器类型都有关系</strong>）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_LIBRARY</span> (&lt;libName&gt; [STATIC] &lt;sourceFileNames&gt;)    <span class="comment"># 默认 STATIC</span></span><br></pre></td></tr></table></figure></li><li><p><strong>目标为动态链接库</strong>（后缀名可能是 <code>*.so</code>、<code>*.dll</code>、<code>*.dylib</code>）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态链接库一般不和主程序一起编译，因为这样还不如用静态链接库</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span> (&lt;libName&gt; SHARED &lt;sourceFileNames&gt;)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>【optional】告诉编译器从哪里寻找非标准 C++ 的<strong>动态链接库</strong>，<strong>一般也同时指定非标准头文件查找目录（include_directories 或 target_include_directories）</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LINK_DIRECTORIES</span> (&lt;dir&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>可以理解为 g++ 的 <code>-L</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ [...] -L &lt;<span class="built_in">dir</span>&gt; [...]</span><br></pre></td></tr></table></figure></blockquote></li><li><p>【optional】<strong>向 可执行文件目标 或 链接库目标 链接一些库</strong>：</p><blockquote><p>众所周知，想要链接库，必须要有 <strong>头文件、动/静态链接库文件</strong>，并且把它们都引入自己的项目中</p></blockquote><ol><li><p><strong>要链接的库是自己编写的 / 第三方静态链接库</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是自己编写的静态链接库，请确保使用了 add_subdirectory 引入该库的 CMakeLists</span></span><br><span class="line"><span class="comment"># 或者在当前 CMakeLists 中指定编译的库，需要 add_library</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是第三方静态链接库，则建议引入头文件，使用 include_directory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (&lt;targetName&gt; &lt;libName/libFileName&gt;)</span><br></pre></td></tr></table></figure></li><li><p><strong>要链接的库是动态链接库</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span> (&lt;dir&gt;)    <span class="comment"># 引入非标准头文件查找目录</span></span><br><span class="line"><span class="keyword">LINK_DIRECTORIES</span> (&lt;dir&gt;)    <span class="comment"># 引入非标准链接库查找目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果最终目标是可执行文件，那么 add_executable 应该写在这里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (&lt;targetName&gt; &lt;libName/libFileName&gt;)</span><br></pre></td></tr></table></figure></li><li><p><strong>要链接的库是标准 C++ 库</strong>（一般这种情况是这个标准 C++ 库不在标准位置，<strong>最常见的是官方的 C++ 扩充，例如 Qt 的库</strong>）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定标准库名，如果它在环境变量中，那么就不需要后面的 PATHS 参数</span></span><br><span class="line"><span class="keyword">FIND_PACKAGE</span> (&lt;stdLibDirName&gt; [REQUIRED] [PATHS &lt;dir&gt;])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定标准库以何种形式链接到目标中</span></span><br><span class="line"><span class="comment"># PUBLIC 和 PRIVATE 含义和之前的 TARGET_INCLUDE 的含义相同</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (&lt;targetName&gt; [PUBLIC | PRIVATE] &lt;stdLibDirName::stdLibName&gt;)</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="Chapter-3-CMakeLists-变量控制"><a href="#Chapter-3-CMakeLists-变量控制" class="headerlink" title="Chapter 3. CMakeLists 变量控制"></a>Chapter 3. CMakeLists 变量控制</h2><h3 id="3-1-常用内置变量"><a href="#3-1-常用内置变量" class="headerlink" title="3.1 常用内置变量"></a>3.1 常用内置变量</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>        <span class="comment"># 这是 CMakeLists.txt 所在目录</span></span><br><span class="line"><span class="variable">$&#123;PROJECT_NAME&#125;</span>                    <span class="comment"># 项目名称，上面介绍了</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;CMAKE_CXX_STANDARD&#125;</span>            <span class="comment"># 这是 C++ 标准设置，如果要使用新特性，例如 auto 出现在 </span></span><br><span class="line">                                <span class="comment"># C++ 11 中，那么应该指定标准版本为 11，否则会报错</span></span><br><span class="line"><span class="variable">$&#123;CMAKE_C_FLAGS&#125;</span></span><br><span class="line"><span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span>                <span class="comment"># 这两个变量是传给 gcc/g++ 的编译器参数，</span></span><br><span class="line">                                <span class="comment"># 一些常用的参数例如 -Wall 警告、-ggdb 调试行号</span></span><br><span class="line"><span class="comment"># 使用的规范是在后面添加，例如：</span></span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall -ggdb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;CMAKE_BUILD_TYPE&#125;</span>                <span class="comment"># 这是设置编译类型，可以是 Release | Debug</span></span><br></pre></td></tr></table></figure><h3 id="3-2-赋值和使用"><a href="#3-2-赋值和使用" class="headerlink" title="3.2 赋值和使用"></a>3.2 赋值和使用</h3><p>CMake 变量赋值函数 <code>SET</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> (&lt;variableName&gt; &lt;value&gt; [CACHE] [<span class="keyword">STRING</span> | BOOL] [Description])</span><br></pre></td></tr></table></figure><p>使用直接：<code>$&#123;&lt;variableName&gt;&#125;</code>；</p><h3 id="3-3-编译时宏定义"><a href="#3-3-编译时宏定义" class="headerlink" title="3.3 编译时宏定义"></a>3.3 编译时宏定义</h3><blockquote><p>假设程序中有一个量，不希望其他人知道，但其他代码都可以开源——那么需要实现：仅编译时将这个量传入；假设这个量在源码中以 <code>APP_ID</code> 表示，那么 CMakeLists.txt 应该这么写：</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> (</span><br><span class="line">    _APP_ID<span class="comment"># 设置 CMakeLists 临时环境变量</span></span><br><span class="line">    CACHE <span class="keyword">STRING</span></span><br><span class="line">    &lt;Description&gt;</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 要求必须传入这个量，否则报错</span></span><br><span class="line"><span class="keyword">IF</span> (_APP_ID <span class="keyword">STREQUAL</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span> (SEND_ERROR &lt;prompt&gt;)</span><br><span class="line"><span class="keyword">ENDIF</span> ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译时宏定义，相当于编译前加入了：#define APP_ID &lt;值&gt;</span></span><br><span class="line"><span class="keyword">TARGET_COMPILE_DEFINITIONS</span> (&lt;targetName&gt; PRIVATE APP_ID=<span class="string">&quot;$&#123;_APP_ID&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>这是传入临时值的方法是 cmake 的 <code>-D&lt;env=value&gt;</code> 参数，例如上面的<strong>生成指令</strong>应该这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -D_APP_ID=<span class="string">&quot;XXX&quot;</span> &lt;Dir&gt;</span><br></pre></td></tr></table></figure><h2 id="Chapter-4-CMakeLists-常见模板"><a href="#Chapter-4-CMakeLists-常见模板" class="headerlink" title="Chapter 4. CMakeLists 常见模板"></a>Chapter 4. CMakeLists 常见模板</h2><blockquote><p>下面模板的项目依赖极其简单，但不能照抄，需要根据项目实际依赖情况进行调整；</p></blockquote><h3 id="4-1-普通-C-项目"><a href="#4-1-普通-C-项目" class="headerlink" title="4.1 普通 C++ 项目"></a>4.1 普通 C++ 项目</h3><p>项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.    # C++ 标准 11</span><br><span class="line">|</span><br><span class="line">|--- main.cpp</span><br><span class="line">|--- App.h</span><br><span class="line">|--- App.cpp</span><br><span class="line">|--- CMakeLists.txt</span><br></pre></td></tr></table></figure><p>模板：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (myApp)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp App.cpp)</span><br></pre></td></tr></table></figure><h3 id="4-2-多个目录的-C-项目"><a href="#4-2-多个目录的-C-项目" class="headerlink" title="4.2 多个目录的 C++ 项目"></a>4.2 多个目录的 C++ 项目</h3><blockquote><p>多个目录可以考虑使用静态链接库，下面展示一种自定义静态链接库的 CMakeLists.txt 写法</p></blockquote><p>项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.    # 这个项目需要 Debug 模式构建，并且增添编译参数 “-Wall” 和 “-ggdb”</span><br><span class="line">|</span><br><span class="line">|--- main.cpp</span><br><span class="line">|--- App.h</span><br><span class="line">|--- App.cpp</span><br><span class="line">|--- CMakeLists.txt</span><br><span class="line">|--- src/                # 这个目录需要编译为静态链接库并同时链接到主程序</span><br><span class="line">        |</span><br><span class="line">        |--- Manager.h</span><br><span class="line">        |--- Manager.cpp</span><br><span class="line">        |--- CMakeLists.txt</span><br></pre></td></tr></table></figure><p>在项目根目录下的 CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (myApp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAG&#125; -Wall -ggdb&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_BUILD_TYPE Debug)</span><br><span class="line"></span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (. MAIN_SRC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span> (src/)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;MAIN_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> myLib)</span><br></pre></td></tr></table></figure><p>在 <code>src/</code> 目录下的 CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (. LIB_SRC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span> (myLib <span class="variable">$&#123;LIB_SRC&#125;</span>)    <span class="comment"># 默认静态链接库</span></span><br></pre></td></tr></table></figure><h3 id="4-3-使用动态链接库的-C-项目"><a href="#4-3-使用动态链接库的-C-项目" class="headerlink" title="4.3 使用动态链接库的 C++ 项目"></a>4.3 使用动态链接库的 C++ 项目</h3><p>项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.    # 项目使用 C++ 11 规范</span><br><span class="line">|</span><br><span class="line">|--- main.cpp</span><br><span class="line">|--- App.cpp</span><br><span class="line">|--- App.h</span><br><span class="line">|--- CMakeLists.txt</span><br><span class="line">|--- core/                # 这个 core 目录要求链接到主程序</span><br><span class="line">        |</span><br><span class="line">        |--- lib/</span><br><span class="line">        ||</span><br><span class="line">        ||--- libManager.so</span><br><span class="line">        |</span><br><span class="line">        |--- include/</span><br><span class="line">                |</span><br><span class="line">                |--- Manager.h</span><br></pre></td></tr></table></figure><p>项目根目录下的 CMakeLists.txt 写法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (myApp)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (. SRC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">LINK_DIRECTORIES</span> (<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/core/lib/)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_INCLUDE_DIRECTORIES</span> (</span><br><span class="line">    <span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/core/<span class="keyword">include</span>/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> libManager.so)</span><br></pre></td></tr></table></figure><p>或者不用 <code>LINK_DIRECTORIES</code>，直接改为单独设置库的代码：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (myApp)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (. SRC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span> (Manager STATIC IMPORTED)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span> (Manager</span><br><span class="line">    PROPERTIES</span><br><span class="line">        IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/core/lib/libManager.so</span><br><span class="line">        INTERFACE_INCLUDE_DIRECTORIES <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/core/<span class="keyword">include</span>/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> Manager)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
            <tag> GNU </tag>
            
            <tag> Programmimg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fiddler Everywhere的crack实践</title>
      <link href="//technical/fiddler-everywhere/"/>
      <url>//technical/fiddler-everywhere/</url>
      
        <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><p><i>本文如有侵权，请联系作者删除</i></p><hr><span id="more"></span><p>众所周知，Fiddler 是一个无比好用的、免费的网络调试代理工具，可以方便地进行抓包、代理服务等基本操作。最近在看到一些文章介绍 Fiddler 的使用时无意间发现 Fiddler everywhere 的软件，UI 制作更加用心，而且功能更加强大，可惜的是会订阅收费。在受到 <a href="https://github.com/msojocs/fiddler-everywhere-enhance/tree/master">Github@msojocs</a>（好像停更了）的指引下，我开始了对 Fiddler-Everywhere 软件的 “学习”。</p><blockquote><p>声明：本文不含有实际的<strong>观点导向</strong> 或者 <strong>建议</strong>，如有侵权，请联系删除；</p><p>在尽情使用的同时，欢迎大家订阅官网正版的 <a href="https://www.telerik.com/download/fiddler-everywhere">Fiddler everywhere</a>；</p></blockquote><h2 id="工作环境准备"><a href="#工作环境准备" class="headerlink" title="工作环境准备"></a>工作环境准备</h2><p>要进行 crack 实践，必然得从反编译入手；</p><p>首先了解到 Fiddler Everywhere 是使用 C# 编写的程序，所以事先必须准备关于 C# 的运行环境 和 反编译程序；</p><p>Windows 自带 <code>.net</code> 运行库不够用，需要下载 <code>dotnet-sdk</code>，再将开发包里的反编译程序 <code>ilasm</code> 和 <code>ildasm</code> 设置到环境变量中使用；当然，如果不想下载各种运行库，也可以使用 <code>dnSpy</code> 反编译工具；</p><blockquote><p><code>dnSpy</code> 解压即用：<a href="crack_fiddler/dnSpy-win64.rar">dnSpy.rar</a>，也可上 Github 上找同名的开源项目；</p></blockquote><p>Linux 用户如果觉得直接装的系统环境中没啥问题，可以使用 <code>.net</code> 官网的方式安装 <code>dotnet-sdk</code> 和 反编译工具 <code>ilasm (ildasm)</code></p><p>Linux 用户如果不想 <code>.net</code> 直接装到系统环境里面，可以使用本人配置的 dockerfile 构建镜像，然后进去操作；（这里只是用来隔离一个环境，然而 docker 并不是这么用的，所以不上传到 docker Hub 上去了）</p><ol><li>在 Linux 任意发行版上配置好 docker，在某个新目录下写好 <code>Dockerfile</code>；</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&quot;</span> /etc/apk/repositories \        <span class="comment"># 这里如果在国内上网，则需要更换源</span></span></span><br><span class="line"> &amp;&amp; apk --update <span class="keyword">add</span><span class="language-bash"> --no-cache dotnet7-sdk \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; dotnet new console -n crackFiddler \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mkdir</span> fiddler &amp;&amp; <span class="built_in">cd</span> crackFiddler \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; dotnet add package Microsoft.NETCore.ILAsm \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; dotnet add package Microsoft.NETCore.ILDAsm \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; dotnet publish -c Release --self-contained --runtime linux-x64 \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">printf</span> <span class="string">&quot;PATH=<span class="subst">$(pwd)</span>/bin/Release/netcoreapp3.1/linux-x64/publish:<span class="variable">$PATH</span>&quot;</span> &gt;&gt; /etc/profile \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure><ol><li><p>构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t crackImage .</span><br></pre></td></tr></table></figure></li></ol><p>之后只需等待 Fiddler Everything 装好再修改就行；</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>开始前需要安装 Fiddler Everything 正版软件 <strong>4.0.1 版本</strong>（为什么是这个版本，后面介绍）； </p><p>安装完成后记住安装根目录：Windows 在“快捷方式 -&gt; 打开文件所在目录” 寻找，Linux 在安装目录寻找；</p><p>⚠ <strong>注意：进行反编译前，请注册一个 Fiddler 账户，并且打开软件、“开始试用” 再关闭，不然无法进行 crack；</strong></p><p>后面的步骤会以 Windows 为例，需要修改的部分 linux 也相同，不过 linux 用的是 <code>ildasm</code> （将动态链接库反编译为 <code>*.il</code> 文本）和 <code>ildasm</code> （将 <code>*.il</code> 编译为 动态链接库）。语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ildasm &lt;libFilename&gt; --output=&lt;outputFile&gt;</span><br><span class="line"></span><br><span class="line">ilasm &lt;ilFile&gt; --output=&lt;libName&gt;</span><br></pre></td></tr></table></figure><p>下面介绍 Windows 的详细做法：</p><p>根据 Github 上的高手找到的 Fiddler Everything 授权验证的代码区域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 这是授权认证的入口处变量定义的位置</span><br><span class="line">Fiddler Everywhere\resources\app\out\WebServer\ClientApp\dist\main.xxxxxx.js</span><br><span class="line"></span><br><span class="line"># 这是 Fiddler Everything 文件校验的函数所在的动态链接库</span><br><span class="line">Fiddler Everywhere\resources\app\out\WebServer\Fiddler.WebUi.dll</span><br><span class="line"></span><br><span class="line"># 这是 Fiddler Everything 验证账户是否激活的函数所在的动态链接库</span><br><span class="line">Fiddler Everywhere\resources\app\out\WebServer\FiddlerBackendSDK.dll</span><br><span class="line"></span><br><span class="line"># 这是 Fiddler Everything 自动更新版本功能所在的 javascript 脚本</span><br><span class="line">Fiddler Everywhere\resources\app\out\main.js</span><br></pre></td></tr></table></figure><p>⚠ 本人还发现，这种方法必须是 <strong>4.0.1</strong>，官方在 <strong>4.3</strong> 以后<strong>已经移除了</strong>文件校验函数所在的 <code>Fiddler.WebUi.Helper</code> 命名空间中的 <code>ScriptHelper</code> 类；</p><p><strong>下面是本人的详细步骤</strong>：</p><ol><li><p>修改<strong>授权认证的入口处变量的定义</strong>（位于 Fiddler Everything 根目录下的 <code>resources\app\out\WebServer\ClientApp\dist\main.xxxxxx.js</code>，这里的 “XXX” 在每一版本中都不同，需要自行在目录下确认）；</p><p>有工程经验的同学会发现，<code>dist</code> 文件夹一般是 <code>javascript</code> 源 或者 <code>typescript</code> 编译后所存放的目录，<strong>这里修改生成文件在 JS 开发中是不妥当的：生成代码堆砌在一起难以阅读，并且下一次生成不会保存修改</strong>；但这次是 crack，并且以后不会再编译项目，所以这么改没关系。</p><p>如图，使用搜索工具查找到更新授权信息的函数 <code>updateUserLicense</code> 定义（第一个匹配才是定义，后面的都是引用）：</p><p><img src="crack_fiddler/updateUserLicense.png"></p><p>紧接着<strong>在函数的第一句前</strong>加上如下一段语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;param&gt;.<span class="property">licenseInfo</span>.<span class="property">currentLicense</span> = <span class="string">&quot;Pro&quot;</span>;</span><br><span class="line">&lt;param&gt;.<span class="property">licenseInfo</span>.<span class="property">hasExpiredTrial</span> = <span class="literal">false</span>;</span><br><span class="line">&lt;param&gt;.<span class="property">licenseInfo</span>.<span class="property">isTrialAvailable</span> = <span class="literal">false</span>;</span><br><span class="line">&lt;param&gt;.<span class="property">licenseInfo</span>.<span class="property">hasValidLicense</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>其中 “\<param\>” 需要替换成你的文件里所看到的这个函数的参数（在上面我的图里，这个参数名叫 <code>ve</code>，因此把 “\<param\>” 换成 “ve”）</strong>，效果如下图：</p><p><img src="crack_fiddler/updateUserLicense2.png"></p></li><li><p><strong>反编译 文件校验的函数所在的动态链接库</strong>（位于根目录下 <code>resources\app\out\WebServer\Fiddler.WebUi.dll</code>）；</p><p>打开 <code>dnSpy</code> C# 反编译工具，导入该动态链接库（Linux 同学这步替换为 <code>ildasm</code> 反编译该文件为 <code>*.il</code>），搜索反编译码，找到<strong>命名空间 <code>Fiddler.WebUi.Helper</code></strong>，再在其中找到<strong>类 <code>ScriptHelper</code></strong>，查看到这个类的两个方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x06000943 RID: 2371 RVA: 0x0001C678 File Offset: 0x0001A878</span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryOpenClientMainScript</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">string</span> error</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x06000944 RID: 2372 RVA: 0x0001C8E0 File Offset: 0x0001AAE0</span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryOpenElectronMainScript</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">string</span> error</span>)</span>;</span><br></pre></td></tr></table></figure><p>将其中的 <code>try&#123;&#125; catch&#123;&#125;</code> 块全部删除，它们的作用是<strong>校验启动脚本的正确性</strong>，应该将其删除，最终函数将直接返回 <code>true</code>，如下图：</p><p><img src="crack_fiddler/scriptHelper.png"></p><p>记得将再将该库<strong>编译回去</strong>、<strong>保存这个模块</strong>；</p><p>比如这是我编译出来的动态链接库：<a href="crack_fiddler/Fiddler.WebUi.dll">Fiddler.WebUi.dll</a>；</p></li><li><p><strong>反编译 验证账户激活函数所在的动态链接库</strong>（位于根目录下 <code>resources\app\out\WebServer\FiddlerBackendSDK.dll</code>）；</p><p>继续使用 <code>dnSpy</code> 打开该库，找到<strong>命名空间 <code>FiddlerBackendSDK.User</code></strong>，再定位到其中的一个<strong>类 <code>UserClient</code></strong>，找到其中的<strong>方法 <code>GetBestAccount</code></strong>，将函数体中的判断语句直接换为返回 <code>true</code>，换好后如图：</p><p><img src="crack_fiddler/getBestAccount.png"></p><p>这是我编译出来的动态链接库：<a href="crack_fiddler/FiddlerBackendSDK.dll">FiddlerBackendSDK.dll</a>；</p></li><li><p><strong>禁用自动更新</strong>（位于根目录下 <code>resources\app\out\main.js</code>）；</p><p>找到这么一行语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.<span class="property">settingsService</span>.<span class="title function_">get</span>().<span class="property">autoUpdateSettings</span>.<span class="property">disabled</span></span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span>||e.<span class="property">settingsService</span>.<span class="title function_">get</span>().<span class="property">autoUpdateSettings</span>.<span class="property">disabled</span></span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="crack_fiddler/update_disable.png"></p></li></ol><p>到目前为止，再次打开 Fiddler Everywhere 就完成的本次实践 ~</p><p><img src="crack_fiddler/finish.png"></p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
            <tag> Crack </tag>
            
            <tag> Disassembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 基础</title>
      <link href="//technical/docker-basic/"/>
      <url>//technical/docker-basic/</url>
      
        <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>Reference：</i><a href="https://docs.docker.com/engine/reference/builder/">Docker 官方文档</a></p><p><i>本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p><hr><span id="more"></span><blockquote><p><strong>前置知识：Linux、Git、虚拟机、略懂操作系统</strong>；</p></blockquote><h2 id="Chapter-0-Docker-安装"><a href="#Chapter-0-Docker-安装" class="headerlink" title="Chapter 0. Docker 安装"></a>Chapter 0. Docker 安装</h2><h3 id="Mac-安装"><a href="#Mac-安装" class="headerlink" title="Mac 安装"></a>Mac 安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask docker</span><br></pre></td></tr></table></figure><h3 id="Linux-任何-distribution-自动安装"><a href="#Linux-任何-distribution-自动安装" class="headerlink" title="Linux 任何 distribution 自动安装"></a>Linux 任何 distribution 自动安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh    <span class="comment"># 自动安装脚本</span></span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun <span class="comment"># 国内阿里云，如果你在国外，删除 --mirror参数</span></span><br></pre></td></tr></table></figure><h3 id="Ubuntu-手动安装"><a href="#Ubuntu-手动安装" class="headerlink" title="Ubuntu 手动安装"></a>Ubuntu 手动安装</h3><ol><li><p>卸载旧版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker \</span><br><span class="line">               docker-engine \</span><br><span class="line">               docker.io</span><br></pre></td></tr></table></figure></li><li><p>安装 HTTPS 必要软件包 和 CA 证书防止安装包篡改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure></li><li><p>添加软件源的 <code>GPG</code> 密钥，以确认所下载软件包的合法性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你在国外，或者正在科学上网，请使用国外密钥：</span></span><br><span class="line"><span class="comment"># curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span></span><br></pre></td></tr></table></figure></li><li><p>向 APT 源添加国内软件源（stable 版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 如果你在国外……</span></span><br><span class="line"><span class="comment"># echo \</span></span><br><span class="line"><span class="comment">#   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="comment">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br></pre></td></tr></table></figure></li><li><p>更新 APT 缓存并安装 <code>docker-ce</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure></li><li><p>启动 Docker 服务并建立对应用户组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Chapter-1-基本概念"><a href="#Chapter-1-基本概念" class="headerlink" title="Chapter 1. 基本概念"></a>Chapter 1. 基本概念</h2><h3 id="1-1-具体原理、地位和性质"><a href="#1-1-具体原理、地位和性质" class="headerlink" title="1.1 具体原理、地位和性质"></a>1.1 具体原理、地位和性质</h3><blockquote><p>本部分内容涉及内容比较深，学完 <code>Go</code> 和 操作系统再回来填坑……</p></blockquote><h3 id="1-2-Docker-和-传统虚拟化技术的比较"><a href="#1-2-Docker-和-传统虚拟化技术的比较" class="headerlink" title="1.2 Docker 和 传统虚拟化技术的比较"></a>1.2 Docker 和 传统虚拟化技术的比较</h3><p><img src="virtualization.png" height="200px"></p><p><img src="docker.png" height="150px"></p><p>如上图所示，传统虚拟化技术构建出的 <code>Hypervisor</code> 需要<strong>虚拟出一套硬件</strong>，并在其上运行一个完整的操作系统（<code>Guest OS</code>），再在该系统上运行所需进程；</p><p>而 Docker 容器中的应用进程借助 <code>Docker Engine</code> 直接运行于宿主内核，无需硬件虚拟；</p><table>    <tr style="text-align: center;">        <th>特性</th>        <th>容器</th>        <th>虚拟机</th>    </tr>    <tr>        <td>启动</td>        <td>秒级</td>        <td>分钟级</td>    </tr>    <tr>        <td>硬盘使用</td>        <td>一般为 MB</td>        <td>一般为 GB</td>    </tr>    <tr>        <td>性能</td>        <td>接近原生</td>        <td>弱于</td>    </tr>    <tr>        <td>系统支持量</td>        <td>单机支持上千个容器</td>        <td>一般几十个</td>    </tr>    <tr>        <td>迁移和部署</td>        <td>容易</td>        <td>困难</td>    </tr>    <tr>        <td>维护和扩展</td>        <td>高质量官方镜像</td>        <td>极其困难</td>    </tr></table><h3 id="1-3-镜像"><a href="#1-3-镜像" class="headerlink" title="1.3 镜像"></a>1.3 镜像</h3><ul><li><p>操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持；</p></li><li><p>而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统（实际上就是一个特殊的文件系统）；除了<strong>提供</strong>容器运行时所需的<strong>程序、库、资源、配置</strong>等文件外，还包含了一些为运行时准备的一些配置参数（如<strong>匿名卷、环境变量、用户</strong>等）；</p></li><li><p>Docker 镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变；</p></li><li><p>Docker 镜像采用 <strong><a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a></strong> 技术（操作系统术语），设计为 <strong>分层存储</strong> 的架构——并非像 <code>*.iso</code> 一样打包成一个文件，<strong>而是一组、多层文件系统联合而成</strong>；</p><ol><li><p>镜像的<strong>构建</strong>时，会一层层构建；前一层是后一层的基础；</p></li><li><p>每一层构建完就不再改变，<strong>后一层的任何更改只发生在自己这层</strong>；</p><blockquote><p>比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除（最终容器运行时，也不会看到）；</p></blockquote></li><li><p>优点：<strong>分层存储的特征还使得镜像的复用、定制变的更为容易</strong>；</p></li></ol></li><li><p>镜像的构建方法以后再说；</p></li></ul><h3 id="1-4-容器"><a href="#1-4-容器" class="headerlink" title="1.4 容器"></a>1.4 容器</h3><ul><li><p>Docker 镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，可以看成面向对象程序设计中的 <strong>类</strong> 和 <strong>实例</strong>；</p><blockquote><p>镜像是<strong>静态</strong>的定义，容器是镜像<strong>运行时的</strong>实体；</p></blockquote></li><li><p>容器的实质是<strong>进程</strong>（process），但和运行在 <code>Host OS</code> 上的普通进程不一样，有着<strong>独立的<a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>（<code>Linux namespace</code>），包含独立的 <code>root</code> 文件系统、网络配置、进程空间、用户 ID 空间</strong>；</p><blockquote><p>体现<strong>隔离</strong>特性，有利于保证宿主系统的安全性；</p></blockquote></li><li><p>容器 和 镜像一样，使用<strong>分层存储</strong>——以镜像为<strong>基础层</strong>，在其上创建一个当前容器的存储层，称这个为容器<strong>运行时访问</strong>而准备的存储层为 <strong>容器存储层</strong>；</p><blockquote><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失；</p></blockquote><p><strong>tips 1.</strong> <span id="needVolume">按 Docker 规范，容器不应该向其存储层内写入任何数据，容器存储层要保持<strong>无状态化</strong>；</span></p><blockquote><p>注：Instead，应该使用 <strong>数据卷（Volume，类似 <code>Linux</code> 中的 <code>mount</code> 挂载目录）</strong>、或者 <strong>绑定宿主目录</strong>（这两种方法将在 Chapter 5 介绍），在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高；</p><p>相反，当我们运行一个容器的时候（<strong>如果不使用卷的话</strong>），我们做的任何文件修改都会被记录于容器存储层里，<strong>导致多个无关文件被修改，不利于迁移、维护</strong>；</p></blockquote><p><strong>tips 2.</strong> 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡，因此在容器被删除或重启后，在数据卷中的数据不会丢失；</p></li></ul><h3 id="1-5-仓库"><a href="#1-5-仓库" class="headerlink" title="1.5 仓库"></a>1.5 仓库</h3><ul><li><p>Docker 社区提供集中的<strong>存储、分发镜像</strong>的服务，称为<strong><code>Docker Registry</code> 公开服务</strong>，最常用的是 <code>Docker Hub</code>（可以理解成类似 <code>Github</code>、<code>Gitee</code> 一样）：提供 <strong>公共仓库（public repository）</strong> 服务，允许用户免费上传、下载公开的镜像；</p><blockquote><p>因此，<strong>Registry 和 Repository 是两个完全不同的概念</strong>；前者指注册的、提供这些服务的服务器，后者指可以被认为是一个具体的项目或目录；</p><p>例如，对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名；</p></blockquote></li><li><p>用户也还可以借助 ① Docker 开发团队的开源 Docker Registry 镜像；或 ② 第三方软件（如 Harbor 和 Sonatype Nexus），来实现<strong>本地搭建私有 Docker Registry</strong>；</p></li></ul><h2 id="Chapter-2-使用镜像"><a href="#Chapter-2-使用镜像" class="headerlink" title="Chapter 2. 使用镜像"></a>Chapter 2. 使用镜像</h2><h3 id="2-1-镜像获取"><a href="#2-1-镜像获取" class="headerlink" title="2.1 镜像获取"></a>2.1 镜像获取</h3><ul><li><p>从 <code>Docker Hub</code> 上获取：<code>docker pull [options] [addr:port/]&lt;RepositoryName&gt;[:tag]</code></p><ul><li><code>[options]</code>：请运行 <code>docker pull --help</code> 查看；</li><li><code>[addr:port/]</code>：默认 <code>docker.io:443</code>（<code>Docker Hub</code> 服务器）；</li><li><code>&lt;RepositoryName&gt;</code>：格式为 <code>&lt;userName&gt;/&lt;softwareName&gt;</code>，<strong>如果仅有 <code>softwareName</code>，则默认官方镜像（<code>userName = library</code>）</strong>;</li><li><code>[:tag]</code>：<strong>镜像标签</strong>，可以理解成 <code>Git</code> 中的 <code>tag</code>，起到<strong>标识镜像版本或分类</strong>的作用；<strong>同一个镜像必须有相同的 ID，可以有不同的 <code>tag</code></strong>；</li></ul><blockquote><p>下载会一层层下载（分层存储），完成后会显示<strong>每层 ID 前 12 位</strong>和镜像整体的 <code>sha256</code> 摘要；</p></blockquote></li></ul><h3 id="2-2-列出镜像"><a href="#2-2-列出镜像" class="headerlink" title="2.2 列出镜像"></a>2.2 列出镜像</h3><ul><li><p>列出顶层镜像：<code>docker image ls</code>，显示 <strong>仓库名、标签、镜像 ID、创建时间和占用空间大小</strong>；</p></li><li><p>关于 <strong>“占用空间大小”</strong>：由于 Docker 使用 Union FS 和多层存储结构，<strong>不同层间可以继承、复用</strong>，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比上面命令显示的小很多；</p><blockquote><p>想要查看<strong>镜像、容器、数据卷</strong>所占用的<strong>真实空间</strong>，请运行：<code>docker system df</code>；</p></blockquote></li><li><p><strong>虚悬镜像（dangling image）</strong>：一种特殊的<strong>顶层镜像</strong>，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>；</p><ul><li>产生原因：① 同一标签的镜像因为官方的维护，ID 发生变更，这样在 <code>docker pull</code> 同个镜像 <code>tag</code> 时，此镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消；② 自己本地构建镜像（<code>docker build</code>，以后介绍）时，由于新旧镜像同名，旧镜像名称被取消；</li><li><strong>查找虚悬镜像</strong>：<code>docker image ls -f dangling=true</code>（加 <code>-f</code> 参数，<code>--filter</code> 过滤）；</li><li><strong>删除虚悬镜像</strong>：虚悬镜像已经失去了存在的价值，可以随意删除：<code>docker image prune</code>；</li></ul></li><li><p><strong>中间层镜像</strong>：想要看中间层镜像，需要使用 <code>docker image ls -a</code>（加 <code>-a</code> 参数）；</p><blockquote><p>此时可能会出现没有标签的镜像，<strong>但它们不是虚悬镜像，而是中间层镜像</strong>，由于多层存储结构，它们相互依赖，<strong>千万不能盲目删除</strong>；</p></blockquote></li><li><p><strong>按条件筛选列出镜像</strong>：<code>docker image ls -f &lt;dangling=bool/since=repositoryName/label=labelName&gt;</code></p></li><li><p><strong>输出格式化</strong>：<code>docker image ls --format &quot;&lt;GoTemplate&gt;&quot;</code></p><blockquote><p>这里的 <code>GoTemplate</code> 是 Go 语言的<strong>模板语法</strong>，可以简单使用常见变量：<code>&#123;&#123;.ID&#125;&#125;</code>、<code>&#123;&#123;.Repository&#125;&#125;</code>、<code>&#123;&#123;.Tag&#125;&#125;</code>；</p></blockquote></li></ul><h3 id="2-3-删除镜像"><a href="#2-3-删除镜像" class="headerlink" title="2.3 删除镜像"></a>2.3 删除镜像</h3><ul><li><p>镜像 ID 删除：<code>docker image rm &lt;IMAGE_ID&gt;</code></p><blockquote><p>一般只有脚本使用完整 ID，人工一般都使用短 ID，对长度没有要求，只要能区分就行（一般 长度大于 3 就能区分）</p></blockquote></li><li><p><code>repositoryName</code> 删除：<code>docker image rm &lt;RepositoryName&gt;</code>；</p></li><li><p>镜像 <code>sha256</code> 摘要删除：<code>docker image &lt;name@sha256:VALUE&gt;</code>；</p><blockquote><p>查询镜像 <code>sha256</code> 摘要：<code>docker image ls --digests</code>；</p></blockquote></li><li><p>补充：<code>Untagged</code> 和 <code>Deleted</code> 的区别：请结合 <code>Git</code> 自行品味；<code>Git</code> 和这个很相似；</p></li><li><p><strong>查询删除法</strong>：<code>docker image rm $(docker image ls -q &lt;之前的查询条件&gt;)</code></p></li></ul><h3 id="2-4-镜像定制和构建"><a href="#2-4-镜像定制和构建" class="headerlink" title="2.4 镜像定制和构建"></a>2.4 镜像定制和构建</h3><blockquote><p>注：第一次学习感觉有难度的可以先跳过本节，直接进入下一章 Chapter 3！</p></blockquote><p><strong>镜像的定制实际上就是定制每一层所添加的配置、文件</strong>。</p><blockquote><p>正如官方文档所说：如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决；</p><p><strong>这个脚本</strong>（文本文档）就是 <code>Dockerfile</code>。和 <code>Makefile</code>、<code>CMakeLists</code> 有异曲同工之妙，名字必须是 <code>Dockerfile</code>；</p></blockquote><h4 id="2-4-1-Dockerfile-定制"><a href="#2-4-1-Dockerfile-定制" class="headerlink" title="2.4.1 Dockerfile 定制"></a>2.4.1 Dockerfile 定制</h4><blockquote><p><code>Dockerfile</code> 包含了一条条的 <strong>指令(Instruction)</strong>，每条指令构建一层，每行一条指令，末尾没有分号；</p></blockquote><h5 id="FROM-指令：指定基础镜像"><a href="#FROM-指令：指定基础镜像" class="headerlink" title="FROM 指令：指定基础镜像"></a><code>FROM</code> 指令：指定基础镜像</h5><ul><li><p>语法：<code>FROM &lt;REPO_NAME&gt;</code>，<code>&lt;REPO_NAME&gt;</code> 为之前提到的存储库名；</p></li><li><p>所谓定制镜像，那一定是<strong>以一个镜像为基础，在其上进行定制</strong>；</p></li><li><p>因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是<strong>必备的指令</strong>，并且<strong>必须是第一条指令</strong>；</p></li><li><p><code>Docker Hub</code> 上有很多高质量基础镜像：</p><ol><li>服务类镜像：<code>nginx</code>、<code>redis</code>、<code>mongo</code>、<code>mysql</code>、<code>httpd</code>、<code>php</code>、<code>tomcat</code> 等；</li><li>语言应用类镜像：<code>node</code>、<code>openjdk</code>、<code>python</code>、<code>ruby</code>、<code>golang</code> 等；</li><li>操作系统类镜像（具有对应软件库可更自由地配置）：<code>ubuntu</code>、<code>debian</code>、<code>centos</code> 等；</li></ol></li><li><p><strong>空白基础镜像</strong>：<code>scratch</code>（意味着<strong>不以任何镜像为基础</strong>，接下来所写的指令将作为镜像第一层开始存在）；</p><blockquote><p>不以任何系统为基础，<strong>直接将可执行文件复制进镜像</strong>的做法并不罕见：</p><ol><li>Linux 下静态编译的程序（所需的一切库都已经在可执行文件中，无需操作系统的运行时支持）；</li><li>大部分使用 Go 语言开发的应用（Go 特别适合容器微服务架构的原因之一）；</li></ol></blockquote></li></ul><h5 id="RUN-指令：执行命令"><a href="#RUN-指令：执行命令" class="headerlink" title="RUN 指令：执行命令"></a><code>RUN</code> 指令：执行命令</h5><ul><li><p>语法：<code>RUN &lt;SH_COMMAND&gt;</code> 或 <code>RUN [&quot;executableName&quot;, &quot;param1&quot;, ...]</code>；</p><ul><li><code>RUN &lt;SH_COMMAND&gt;</code> 参数会自动翻译为 <code>RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;&lt;SH_COMMAND&gt;&quot;]</code>；</li></ul></li><li><p>⚠ <strong>注意：每一个 <code>RUN</code> 指令都会新建一层镜像层</strong>，因此从重用性角度出发，<strong>同一个目的的操作尽量写在一个 <code>RUN</code> 语句中</strong>，例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样的 Dockerfile 编写方式是不恰当的！！！结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等</span></span><br><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y gcc libc6-dev make wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这段代码只有一个目的，就是编译、安装 redis 可执行文件，所以没有必要建立很多层，这只是一层的事情。</span></span><br><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x; buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># 以下清理文件是非常重要的步骤，确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</span></span></span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \ <span class="comment"># 清理了 apt 缓存文件</span></span><br><span class="line">    &amp;&amp; rm redis.tar.gz \             <span class="comment"># 清理了所有下载、展开的文件</span></span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps <span class="comment"># 删除了为了编译构建所需要的软件和库</span></span><br></pre></td></tr></table></figure><p>⚠ <strong>更重要的是</strong>，每个 <code>RUN</code> 指令由于所处的层数不一样，所以执行这个命令的命令行也不一样，这样就相当于开了新的命令行窗口，有的时候第一种写法甚至是错误的、无法运行的，例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure><p>你会发现 <code>world.txt</code> 根本不在 <code>/app/</code> 下面，因为下一个 <code>RUN</code> 的 console 已经不在 <code>/app/</code> 下面了；<strong>这就是对 Docker 分层存储理解不透的结果</strong>。也正是这个原因，请不要把 <code>Dockerfile</code> 作为 shell 脚本使用！</p><p>想要实现上面的操作，可以改成：<code>RUN cd /app &amp;&amp; echo &quot;hello&quot; &gt; world.txt</code>；</p><p>⚠ 如果你实在需要分成多个 <code>RUN</code> 步骤（例如为了容器层的可重用性——中间多一层可以有其他用处），但<strong>又希望命令行固定在某个目录下进行</strong>，请参考下文 <strong><code>WORKDIR</code> 指令的使用</strong>；</p></li></ul><h5 id="COPY-指令：复制文件"><a href="#COPY-指令：复制文件" class="headerlink" title="COPY 指令：复制文件"></a><code>COPY</code> 指令：复制文件</h5><ul><li><p>语法：<code>COPY [--chown=&lt;user:group&gt;] &lt;src1&gt;[, src2, ...], &lt;dist1&gt;[, dist2, ...]</code> ；</p></li><li><p>支持 <code>--chown</code> 参数更改文件所属用户和组；</p></li><li><p>使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等；</p></li><li><p><code>src</code> 源路径必须在上下文路径中，关于什么是上下文路径，建议立即查看 <a href="#contextPath"><strong>下文</strong>🔗</a>；</p></li><li><p>不仅可以指定多个文件，<code>src</code> 还支持 <code>Go</code> 语言的 <a href="https://golang.org/pkg/path/filepath/#Match"><code>filepath.Match</code></a> 通配符规则，可以简单认为：</p><table>    <tr style="text-align: center;">        <th>Regex 正则</th>        <th>Go::filepath.Match</th>    </tr>    <tr>        <td>.*</td>        <td>*</td>    </tr>    <tr>        <td>.?</td>        <td>?</td>    </tr>    <tr>        <td>[a-zA-Z]</td>        <td>[{a-zA-Z}]</td>    </tr></table></li><li><p><strong>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径</strong>；举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|</span><br><span class="line">|--- Dockerfile</span><br><span class="line">|--- ABC.txt</span><br><span class="line">|--- testDir/</span><br><span class="line">        |</span><br><span class="line">        |--- DEF.txt</span><br><span class="line">        |--- testDir2/</span><br><span class="line">                |</span><br><span class="line">                |--- FGH.txt</span><br><span class="line">                |--- IJK.txt</span><br></pre></td></tr></table></figure><p>上面的项目目录，如果在 Dockerfile 中有这么一段：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>并且构建镜像以 <code>testDir</code> 为上下文根目录：<code>docker build -f Dockerfile -t XXX ./testDir/</code>，那么在容器中，<strong><code>testDir</code> 本身不会在里面</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app/</span><br><span class="line">|--- DEF.txt</span><br><span class="line">|--- testDir2/</span><br><span class="line">        |</span><br><span class="line">        |--- FGH.txt</span><br><span class="line">        |--- IJK.txt</span><br></pre></td></tr></table></figure></li></ul><h5 id="ADD-指令：自动解压并复制文件"><a href="#ADD-指令：自动解压并复制文件" class="headerlink" title="ADD 指令：自动解压并复制文件"></a><code>ADD</code> 指令：自动解压并复制文件</h5><ul><li>和 <code>COPY</code> 语法几乎相同，<strong>真正需要 <code>ADD</code> 的场景是自动解压缩</strong>，即 <code>&lt;src&gt;</code> 路径是一个 <code>*.zip/*.bz/*.xz/*.gz/*.tar</code> 时会自动解压缩；<strong>其他时候应该使用语义明确的 <code>COPY</code></strong>；</li></ul><h5 id="CMD-指令：设置容器启动命令"><a href="#CMD-指令：设置容器启动命令" class="headerlink" title="CMD 指令：设置容器启动命令"></a><code>CMD</code> 指令：设置容器启动命令</h5><ul><li><p>用于指定默认的容器主进程的启动命令（容器启动指令 <code>docker run</code> 将在 3.1 介绍），语法和 <code>RUN</code> 相同；</p></li><li><p>如果指定了该命令，那么当运行 <code>docker run</code> 后，<strong>默认运行容器中的 <code>/bin/bash</code></strong> 的行为将被更改为 <code>CMD</code> 后的指令；</p></li><li><p><strong>易错点：前台执行 &amp;&amp; 后台执行</strong>；先问大家伙一个问题，下面的指令有意义吗？</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;&lt;h1&gt;Hello, nginx!&lt;/h1&gt;&quot;</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> systemctl start nginx</span></span><br></pre></td></tr></table></figure><p>如果你认为没有任何问题的话，恭喜你，<strong>你成功地将 传统虚拟机 和 docker 容器搞混了！</strong> 请你好好复习 <strong>1.2 和 1.4</strong> 的内容：容器本身就是一种进程，<strong>它不是虚拟机、内部不存在守护进程，因此不允许在“后台”启动应用，必须在前台，否则会直接退出</strong>；</p><blockquote><p>引用官方文档的一句话：对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出；</p></blockquote><p>上面的 <code>CMD systemctl start nginx</code> 会被解释成：<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，这样运行完这条指令后主进程直接结束！</p><p><strong>想要在容器生存周期内持续运行 <code>nginx</code>，必须以指定前台的方式运行，如下：</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;&lt;h1&gt;Hello, nginx!&lt;/h1&gt;&quot;</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="ENTRYPOINT-指令：设置容器入口点"><a href="#ENTRYPOINT-指令：设置容器入口点" class="headerlink" title="ENTRYPOINT 指令：设置容器入口点"></a><code>ENTRYPOINT</code> 指令：设置容器入口点</h5><ul><li><p>语法和 <code>RUN</code>、<code>CMD</code> 都相同，<strong>它存在的主要作用有两个：① 更方便地从外部添加运行参数；② 更方便地进行容器运行前准备工作</strong>；</p></li><li><p>想理解主要作用，需要知道 <code>ENTRYPOINT</code> 如何工作：<strong>当指定 <code>ENTRYPOINT</code> 后，<code>CMD</code> 指令的意义发生变化：<code>CMD</code> 默认值变为空，并且<code>CMD</code> 将作为 <code>ENTRYPOINT</code> 的参数进行传递</strong>；这使得 <code>ENTRYPOINT</code> 实现了上述两个优点；分别举一个栗子🌰说明：</p><p><strong>①</strong> 假设有一个镜像是这么设计的：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>如果<strong>想向里面的 <code>curl</code> 命令添加参数</strong>，例如 <code>-i</code>，是做不到的；</p><p>（之后会介绍 <code>docker run [options] &lt;containerName&gt; [CMD]</code> 启动容器的命令，在”容器名“后面的参数是 <code>CMD</code>，会覆盖 <code>Dockerfile</code> 中的 <code>CMD</code> 指令）</p><p>但是如果这么写就不一样了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>这样在 <code>docker run</code> 最后指定 <code>CMD</code> 时，这个参数会传递给 <code>ENTRYPOINT</code> 作为参数，完美解决这个传参问题；</p><p><strong>②</strong> 再假设我们在使用一个数据库镜像，可能需要以 <code>root</code> 身份完成一些数据库配置、初始化的工作，再根据需要<strong>切换用户以保证安全性</strong>；<strong>比如官方 <code>Redis</code> 镜像是这么做的</strong>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File: Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.4</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># root 身份建立用户组相关设置</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]        <span class="comment"># 容器启动后执行该脚本</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;redis-server&quot;</span> ]    <span class="comment"># 因为上文有 ENTRYPOINT，所以这里不是指容器的启动命令，</span></span></span><br><span class="line">                        <span class="comment"># 而是指传给 ENTRYPOINT 的默认参数是 &quot;redis-server&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    find . \! -user redis -<span class="built_in">exec</span> <span class="built_in">chown</span> redis <span class="string">&#x27;&#123;&#125;&#x27;</span> +</span><br><span class="line">    <span class="built_in">exec</span> gosu redis <span class="string">&quot;<span class="variable">$0</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个脚本指的就是根据 CMD 参数的内容来判断，如果是 redis-server 的话，</span></span><br><span class="line"><span class="comment"># 则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="ENV-指令：设置环境变量"><a href="#ENV-指令：设置环境变量" class="headerlink" title="ENV 指令：设置环境变量"></a><code>ENV</code> 指令：设置环境变量</h5><ul><li><p>语法：<code>ENV &lt;key&gt; &lt;value&gt;</code> 或 <code>ENV &lt;key1&gt;=&lt;value1&gt; [&lt;key2&gt;=&lt;value2&gt; ...]</code>（语法特殊，只有多个环境变量参数间不用加逗号），<strong>环境变量将停留在容器的全生命周期中</strong>；</p></li><li><p>它的作用：设置合适的环境变量可以让维护工作变得轻松，例如 <code>node</code> 官方镜像的 Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; grep <span class="string">&quot; node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt | <span class="built_in">sha256sum</span> -c - \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; tar -xJf <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> -C /usr/local --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">ln</span> -s /usr/local/bin/node /usr/local/bin/nodejs</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="ARG-指令：设置构建参数"><a href="#ARG-指令：设置构建参数" class="headerlink" title="ARG 指令：设置构建参数"></a><code>ARG</code> 指令：设置构建参数</h5><ul><li><p>语法与 <code>ENV</code> 相同，不过 <code>ARG</code> 只是<strong>构建镜像时临时存在的环境变量</strong>，并且<strong>只在 <code>FROM</code> 中生效</strong>，想要在其他语句中使用，必须重新指定，举几个栗子🌰：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 情况 1 ----------------------------</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span> <span class="comment"># 这步是无效输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 2 -----------------------------</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想在 FROM 之后使用，必须再次指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span> <span class="comment"># 这样才是有效输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 3（多阶段构建，后面说） -----------</span></span><br><span class="line"><span class="comment"># 这个变量在每个 FROM 中都生效（使用的场合必须要都是 FROM）</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 4（多阶段构建）-------------------</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span> <span class="comment"># 有效输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span> <span class="comment"># 有效输出</span></span></span><br></pre></td></tr></table></figure></li></ul><h5 id="VOLUME-指令：定义匿名卷"><a href="#VOLUME-指令：定义匿名卷" class="headerlink" title="VOLUME 指令：定义匿名卷"></a><code>VOLUME</code> 指令：定义匿名卷</h5><ul><li><p>语法：<code>VOLUME &lt;inContainerPath&gt;</code> 或 <code>VOLUME &quot;&lt;inPath1&gt;&quot;, &quot;&lt;inPath2&gt;, ...&quot;</code>；</p></li><li><p>它的作用：在 <a href="#needVolume">之前</a> 提到过，容器运行时应该尽量保持容器存储层不发生写操作，所以数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中（后面 <strong>5.1</strong> 会介绍数据卷），而<strong>为了防止用户运行容器 <code>docker run</code> 忘记加 <code>-v</code> 参数（后面说）来指定目录挂载卷，可以在 <code>Dockerfile</code> 中写 <code>VOLUME</code> 匿名卷，相当于“没有指定目录名的默认卷”</strong>；</p><p>这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据；</p><blockquote><p>注意：匿名卷正因为匿名、没有指定在 <code>Host OS</code> 上的挂载目录，docker engine 会自动选择诸如： <code>/var/lib/docker/</code> 这样的一些位置存起来，在容器删除后也不会自动删除，得自己找，比较麻烦；</p><p><strong>所以尽量自己记得挂载数据卷，不要依赖匿名卷</strong>；</p></blockquote></li></ul><h5 id="EXPOSE-指令：声明端口"><a href="#EXPOSE-指令：声明端口" class="headerlink" title="EXPOSE 指令：声明端口"></a><code>EXPOSE</code> 指令：声明端口</h5><ul><li>语法：<code>EXPOSE &lt;port1&gt; [port2 ...]</code> （和 <code>ENV</code> 一样，多个参数没逗号）；</li><li>⚠ <strong>注意：是声明，而不是直接暴露</strong>，意味着在容器运行时<strong>并不会因为这个声明应用就会开启这个端口的服务</strong>；那它有什么用呢？</li><li>它的作用：① <strong>帮助镜像使用者理解</strong>这个镜像服务的守护端口，以方便自行配置映射；② 当使用 <code>docker run</code> 的 <code>-P(大写)</code> 参数（后面介绍，是将容器端口开放到 <code>Host OS</code> 的随机端口）时，默认使用 <code>EXPOSE</code> 声明的端口；</li><li><strong>辨析：<code>EXPOSE</code> 不能和 <code>docker run</code> 的 <code>-p(小写)</code> 参数</strong>（也是后面介绍）<strong>作用搞混，后者是真的会进行从宿主到容器的端口映射，而前者只是声明</strong>；</li></ul><h5 id="WORKDIR-指令：指定工作目录"><a href="#WORKDIR-指令：指定工作目录" class="headerlink" title="WORKDIR 指令：指定工作目录"></a><code>WORKDIR</code> 指令：指定工作目录</h5><ul><li><p>语法：<code>WORKDIR &lt;inContainerDir&gt;</code>（如果容器内该目录不存在，则<strong>会自动创建</strong>）；</p></li><li><p>它的作用：<strong>改变以后各层的工作目录位置</strong>，确保每一层的命令行默认位置都在该目录下；如果参数是<strong>相对路径</strong>，那么和<strong>之前的</strong>工作目录有关，例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span>    <span class="comment"># 此时在容器内命令行中打印的应该是 /a/b/c/</span></span></span><br></pre></td></tr></table></figure></li></ul><h5 id="USER-指令：指定当前用户"><a href="#USER-指令：指定当前用户" class="headerlink" title="USER 指令：指定当前用户"></a><code>USER</code> 指令：指定当前用户</h5><ul><li><p>语法：<code>USER &lt;userName&gt;[:userGroup]</code>；</p></li><li><p>它的作用：<strong>改变</strong>之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的<strong>身份</strong>（之前说过，docker 容器有一套完整独立的命名空间）；</p></li><li><p>和 <code>WORKDIR</code> 的异同比较：</p><ul><li>和 <code>WORKDIR</code> 的作用效果类似，都是<strong>改变环境状态并影响以后的层</strong>；</li><li>和 <code>WORKDIR</code> 不同的是，如果指定用户不存在，则无法切换——<strong>此指令不会自动创建用户</strong>；</li></ul></li><li><p>⚠ 如果要建立一个用户、用户组（大多数时候用 <code>RUN</code>），并且在 <code>RUN</code> 的中途想要切换用户（不添加中间层的情况，就没法使用 <code>USER</code>），请 <strong>一定不要</strong> 使用 <code>su</code> 和 <code>sudo</code>，因为通常在刚下载的原始镜像中都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错；</p><blockquote><p>尤其是这种情况：<strong>如果容器内的应用需要 “优雅停机”（接收信号量 <code>SIGABRT</code>）</strong>，那么一定需要这个应用的进程<strong>在容器内的 <code>PID</code> = 1</strong>；而运行 <code>su/sudo</code> 会先建立 <code>sudo</code> 进程，再建立后面的进程，不能保证容器应用的 <code>PID</code> = 1！</p></blockquote><p><strong>正确做法之一是下载并使用 <code>gosu</code></strong>，以 <code>redis</code> 镜像中用户设置和切换为例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户和用户组</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/gosu \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; gosu nobody <span class="literal">true</span></span></span><br><span class="line"><span class="comment"># 设置 CMD，并使用 gosu 换另外的用户传参（gosu 使用方法：gosu + user + cmd）</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>至于使用 <code>gosu</code> 而不是 <code>su/sudo</code> 的深层原因，我看有篇博客写的不错，如果感兴趣这方面的原理可以戳 <a href="https://www.cnblogs.com/gaoyuechen/p/14336078.html">这里🔗</a>；不过看懂英文的话，最好看 <code>gosu</code> 官方解释：<a href="https://github.com/tianon/gosu">github 传送门</a>；</p><p><strong>另一种正确方法比较方便，是使用 <code>chroot</code> 的 <code>--userspec</code> 参数</strong>：<code>chroot --userspec=&lt;userName&gt;</code>，可以完成相似效果；</p></li></ul><h5 id="HEALTHCHECK-指令：健壮性检查"><a href="#HEALTHCHECK-指令：健壮性检查" class="headerlink" title="HEALTHCHECK 指令：健壮性检查"></a><code>HEALTHCHECK</code> 指令：健壮性检查</h5><ul><li><p>语法：<code>HEALTHCHECK [OPTIONS] CMD &lt;HOST_COMMAND&gt;</code> 或 <code>HEALTHCHECK NONE</code>；</p><ul><li><strong><code>HEALTHCHECK</code> 和 <code>CMD</code>、<code>ENTRYPOINT</code> 一样，只可以出现一次，如果写了多个，只有最后一个生效</strong>；</li><li><code>[options]</code>：<code>--interval=&lt;带单位的数值&gt;</code>、<code>--timeout=&lt;...&gt;</code> 前面两个都默认 <code>30s</code>；<code>--retries=&lt;N&gt;</code> 默认 3 次，超过则认为不健康；</li><li><code>CMD &lt;...&gt;</code>：检查时由宿主机向容器内执行的指令，指令返回值代表本次检查是否成功：<code>0:成功, 1:失败, 2:放弃结果</code>；</li><li><code>NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令；</li></ul></li><li><p>它的作用：引用官方文档的话：</p><blockquote><p>在没有 <code>HEALTHCHECK</code> 指令前，Docker engine 只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入<strong>死锁</strong>状态，或者<strong>死循环</strong>状态，应用进程并不退出，但是该容器已经无法提供服务了。</p><p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而<strong>比较真实地反应</strong>容器实际状态。</p></blockquote></li><li><p>举个例子🌰：对于一个网络服务而言，如果需要检查 WEB 服务是否还有响应，那么可以这么写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5s --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1        <span class="comment"># 使用 curl 来判断</span></span></span><br></pre></td></tr></table></figure></li><li><p>健康检查的日志可以使用 <code>docker inspect --format &#39;&#123;&#123;json .State.Health&#125;&#125;&#39; &lt;containerName&gt;</code> 来查看（json 格式）；</p></li></ul><h5 id="ONBUILD-指令：多级构建准备"><a href="#ONBUILD-指令：多级构建准备" class="headerlink" title="ONBUILD 指令：多级构建准备"></a><code>ONBUILD</code> 指令：多级构建准备</h5><ul><li><p>语法：<code>ONBUILD &lt;所有其他指令&gt;</code>；</p></li><li><p>它的效果：它后面跟的是其它指令，而<strong>在当前镜像构建时并不会被执行</strong>。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行；</p></li><li><p>它的作用：<strong>提升镜像多级构建的重用性和扩展性</strong>；这句非常抽象，需要举例说明；首先说明<strong>什么是多级构建</strong>——利用已构建好的镜像为基础，构建下一级镜像（<strong>事实上所有镜像都是这么构建的，但多级构建更强调这几个镜像都是自己写出来的</strong>）</p><blockquote><p>以下的例子涉及 <code>node.js</code> 相关知识，只需了解 <code>node.js</code> 使用 <code>npm</code> 作为包管理器之一，相关包依赖和启动信息存在 <code>package.json</code> 中，可以类比成 <code>Python</code> 中的 <code>pip</code> 和 <code>requirements.txt</code>；部署项目时需要在根目录下执行 <code>npm install</code> 安装依赖，才能运行项目；</p></blockquote><p>🌰 假设我们在一个 <code>node.js</code> 项目中，目录情况如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|</span><br><span class="line">|--- Dockerfile</span><br><span class="line">|--- package.json</span><br><span class="line">|--- ...             # 其他项目文件</span><br></pre></td></tr></table></figure><p>因此 Dockerfile 应该这么写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app                <span class="comment"># 创建并以 /app 为工作目录</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./package.json /app    <span class="comment"># 将当前上下文目录下的 package.json 文件复制到镜像中的 /app/ 下</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]    <span class="comment"># 执行 sh -c npm install 安装项目依赖</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app/                <span class="comment"># 将当前上下文目录中(即客户端中的项目根目录)所有文件复制到 /app/ 下</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]        <span class="comment"># 设置容器默认启动命令为 npm start</span></span></span><br></pre></td></tr></table></figure><p>很好。那如果还有一个项目，<strong>项目文件不一样，但依赖的包和它一模一样</strong>，如果想要定制为镜像，应该怎么办？你可能会说，简单！把 Dockerfile 直接复制过去不就行了？好，那如果还有 5 个、10个呢？<strong>直接复制 Dockerfile 一定不现实，会给版本控制造成极大阻碍</strong>（例如，如果你想把这些所有项目的镜像基础 <code>node:slim</code> 换成 <code>node:alpine</code>，那你得一个个改）；</p><p>聪明的人会想，这也好办，直接把<strong>和项目无关的部分提出来</strong>——这样公共部分只要修改一次就行（<strong>这就是多级构建的思想</strong>，注意和后面的 <strong>多阶段构建区分</strong>）：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公共镜像的 Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>假设这个生成的镜像名叫 <code>my-node</code>，那么某一个用到这个镜像的项目的 Dockerfile 可以这么写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用到公共镜像的某个项目镜像的 Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> my-node</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br></pre></td></tr></table></figure><p>这么进行 “多级构建” 是没有问题的；但是，如果项目创建容器时，我想给<strong>每个项目的启动命令 <code>npm install</code> 都加个相同的参数呢</strong>？哦吼，完了，问题又回去了，是不是要一个个改呢……有些同学会说：那把 <code>RUN</code> 挪到公共镜像的 Dockerfile 中？不行。因为下面的 <code>COPY</code> 和 <code>RUN</code> 和项目有关，<strong>如果这样构建，某个项目的文件就进入公共镜像中，显然不符合重用的要求</strong>；</p><p>这个时候，应该用 <code>ONBUILD</code> 完成：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公共镜像的 Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>这样 <code>ONBUILD</code> 这几步在构建公共镜像时不会运行，而各个项目只需要写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br></pre></td></tr></table></figure><p><strong>这一句话就行！</strong>是不是非常方便！</p></li></ul><h5 id="LABEL-指令：添加镜像元数据-metadata"><a href="#LABEL-指令：添加镜像元数据-metadata" class="headerlink" title="LABEL 指令：添加镜像元数据 metadata"></a><code>LABEL</code> 指令：添加镜像元数据 metadata</h5><ul><li><p>一般是用来申明镜像的作者、文档地址等：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.authors=<span class="string">&quot;XXX&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.documentation=<span class="string">&quot;https://XXX&quot;</span></span></span><br></pre></td></tr></table></figure></li></ul><h5 id="SHELL-指令：指定命令行运行参数"><a href="#SHELL-指令：指定命令行运行参数" class="headerlink" title="SHELL 指令：指定命令行运行参数"></a><code>SHELL</code> 指令：指定命令行运行参数</h5><ul><li><p>语法：<code>SHELL [&quot;executable&quot;, &quot;params&quot;]</code></p></li><li><p>作用：用来指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell，Linux 中默认为 <code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-cex&quot;</span>]</span></span><br><span class="line"><span class="comment"># 命令转为 /bin/sh -cex &quot;nginx&quot;</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> nginx</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="很重要的网站"><a href="#很重要的网站" class="headerlink" title="很重要的网站"></a>很重要的网站</h5><ul><li><p><code>Docker</code> 官方镜像 <code>Dockerfile</code>：<a href="https://github.com/docker-library/docs">Dockerfile contents - github</a>；</p><p>在你不知道官方镜像的设计，或者想学习官方 Dockerfile 的用法时，这是极好的了解途径；</p></li></ul><h4 id="2-4-2-从容器快照定制"><a href="#2-4-2-从容器快照定制" class="headerlink" title="2.4.2 从容器快照定制"></a>2.4.2 从容器快照定制</h4><p><strong>见 3.4 容器的导入和导出</strong></p><h4 id="2-4-3-构建镜像"><a href="#2-4-3-构建镜像" class="headerlink" title="2.4.3 构建镜像"></a>2.4.3 构建镜像</h4><ul><li><p>语法：<code>docker build [options] &lt;contextPath&gt;</code></p></li><li><p><code>[options]</code> 中 <strong>最常用的是 <code>-t &lt;tagName&gt;</code>，给生成的镜像固定一个标签</strong>、<code>-f &lt;DockerfilePath&gt;</code> 指定 <code>Dockerfile</code>；</p></li><li><p><span id="contextPath"><code>&lt;contextPath&gt;</code> 指<strong>上下文路径</strong>，想要理解它，就需要理解部分 <code>docker build</code> 的工作原理</span>：</p><p><img src="docker-on-linux.png" height="300"></p><ul><li><p>Docker <strong>采用 C/S 架构设计</strong>，在运行时分为 Docker Engine（也就是服务端守护进程 <code>containerd</code>）和客户端工具（图片最上面的 4 个）；</p></li><li><p>Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能；<strong>这种 C/S 分离式的设计，使得操作远程服务器的 docker engine 和本地一样轻松</strong>；</p></li><li><p>所以什么是上下文路径（contextPath）？</p><ol><li><p>构建镜像时，构建操作一定是在服务器端进行（C/S 架构），因此服务端会请求将 <strong><code>Dockerfile</code> 所在目录（这不是 contextPath，因为默认不用 <code>-f DockerfileName</code> 指定的，引擎默认是上下文目录下的 <code>Dockerfile</code>）下的</strong>所有文件打包，并从客户端传递给 <code>Docker Engine</code>；</p><blockquote><p>正因如此，① 应该将 <code>Dockerfile</code> 置于一个<strong>空目录</strong>下，或者<strong>项目根目录</strong>下；</p><p>② 如果该目录下没有所需文件，那么应该把所需文件<strong>复制一份过来</strong>；</p><p>③ 如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <strong><code>.dockerignore</code></strong>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的；</p></blockquote></li><li><p><strong>真正的 contextPath 是</strong>：<code>docker build</code> 指定<strong>要压缩给服务器的目录</strong>，<strong>并且从此以后，<code>Dockerfile</code> 中的所有的相对路径（如 <code>COPY</code> 等命令，也强烈建议是相对路径）的 “<code>.</code>” 都代表 <code>docker build</code> 中指定的上下文目录</strong>；</p></li></ol></li><li><p>举个两个栗子🌰🌰帮助理解上面内容：</p><ol><li><p>假设有一个项目结构是这样的，想要添加到 <code>nginx</code> 镜像中合成新的镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|</span><br><span class="line">|--- Dockerfile</span><br><span class="line">|--- .dockerignore</span><br><span class="line">|</span><br><span class="line">|--- index.html</span><br><span class="line">|--- webConfig        # nginx 配置文件</span><br></pre></td></tr></table></figure><p>由于 <code>Dockerfile</code> 恰在项目根目录下，因此可以这么写（这里只是演示什么是上下文目录，不建议这么做，建议使用<strong>数据卷或挂载主机目录</strong>）：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./index.html /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./webConfig /etc/nginx/site-avaliable/webConfig</span></span><br></pre></td></tr></table></figure><p>那么指令应该这么写：<code>docker build -t my_nginx:v1 .</code></p><p>这里：</p><p>① 无需指定 <code>Dockerfile</code>，是因为上下文目录恰好指定的是当前目录，该目录下又恰好有 <code>Dockerfile</code>，因此不用指定；</p><p>② <code>Dockerfile</code> 中 <code>COPY</code> 语句中的 “源目录(第一参数)” 中的 “<code>.</code>” 指的是 <strong>contextPath</strong>，也是在服务器端解压后的 “<code>.</code>”，<strong>而非客户端的“当前目录”</strong>；</p></li><li><p>再假设有一个项目结构是这样的，想以 <code>src/</code> 为整个项目打包进容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|</span><br><span class="line">|--- Dockerfile</span><br><span class="line">|--- .dockerignore</span><br><span class="line">|</span><br><span class="line">|--- src/</span><br><span class="line">        |--- index.html</span><br><span class="line">        |--- webConfig# nginx 配置文件</span><br></pre></td></tr></table></figure><p>那么如果 <code>Dockerfile</code> 这么写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./index.html /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./webConfig /etc/nginx/site-avaliable/webConfig</span></span><br></pre></td></tr></table></figure><p>则指令应该这么写：<code>docker build -f ./Dockerfile -t my_nginx:v1 ./src/</code></p><p>这里：</p><p>① <strong>指定了上下文路径是 <code>src/</code>，意味着只会给 docker engine 压缩打包这个目录，仅此而已</strong>；</p><p>② 在这个上下文目录（<code>src/</code>）中，没有 <code>Dockerfile</code>，因此需要指定 <code>Dockerfile</code> 在客户端的位置； <code>-f</code> 参数指定 <code>Dockerfile</code>，<strong>这个路径和 contextPath 无关，真的是客户端的路径</strong>；</p><p>③ 在 <code>Dockerfile</code> 中，<code>COPY</code> 的源路径（第一参数）中的 “<code>.</code>” 可以理解为的是在服务器端<strong>刚解压后的当前路径</strong>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. &lt;--- 它就是上下文路径在 Dockerfile 中表示的含义</span><br><span class="line">|</span><br><span class="line">|--- index.html</span><br><span class="line">|--- webConfig</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h4 id="2-4-4-多阶段构建"><a href="#2-4-4-多阶段构建" class="headerlink" title="2.4.4 多阶段构建"></a>2.4.4 多阶段构建</h4><ul><li><p><strong>多阶段构建和多级构建的对比：后者的目的是为了提升重用性，多写了几个镜像并依赖构建；前者是因为原本的镜像过于庞大，要拆解镜像层次，人为降低镜像的体积</strong>；前者一次只会一次构建出一个镜像，后者强调分步构建好几个镜像；</p></li><li><p>使用方法：<strong>就是一个 Dockerfile 文件中写好几个 <code>FROM</code></strong>，引入 <code>as</code> 关键字，使得外部可以通过 <code>docker build</code> 的 <code>--target</code> 参数<strong>指定构建的阶段</strong>；并且多阶段之间的镜像<strong>可以相互复制文件</strong>！</p><p>举个例子🌰：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest as prod</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是使用上一阶段(--from=0) “builder” 镜像的文件</span></span><br><span class="line"><span class="comment"># 0 是“上一个”的简写，还可以 --from=builder</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /go/src/github.com/go/helloworld/app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>也可以只构建 <code>builder</code>：<code>docker build --target builder -t XXX:XX .</code></p></li><li><p>⚠ <strong>当需要的容器服务过于多的时候，写 <code>Dockerfile</code> 变得很繁琐（例如一个镜像中同时需要 python、nginx、redis 服务等），建议使用 <code>docker compose</code>（见 Chapter 7）</strong>；</p></li></ul><h2 id="Chapter-3-操作容器"><a href="#Chapter-3-操作容器" class="headerlink" title="Chapter 3. 操作容器"></a>Chapter 3. 操作容器</h2><h3 id="3-1-创建和启动容器"><a href="#3-1-创建和启动容器" class="headerlink" title="3.1 创建和启动容器"></a>3.1 创建和启动容器</h3><h4 id="3-1-1-新建容器并启动"><a href="#3-1-1-新建容器并启动" class="headerlink" title="3.1.1 新建容器并启动"></a>3.1.1 新建容器并启动</h4><ul><li><p>语法：<code>docker run [options] &lt;IMAGE_NAME or ID&gt; [CMD]</code>；</p><ul><li><p><code>[options]</code>：① <code>-i</code> 启动容器内 bash 并绑定于 stdin 允许交互；</p><p>② <code>-t</code> 分配伪终端（显示命令提示符，<strong>常和 <code>-i</code> 联用将容器 I/O 绑定在当前 TTY 上：<code>-it</code></strong>）；</p><blockquote><p>如果使用 <code>-i</code> 参数，<code>[CMD]</code> 为必须项，且一般填写 <code>/bin/bash</code> 或 sh；</p></blockquote><p>③ <code>-d</code> 拒绝和当前终端连接（detach，在启动容器后不与当前 TTY 关联，与 <code>-it</code> 互斥，此时 <strong>stdout 的内容可以使用 <code>docker container logs</code> 查看</strong>）；</p><p>④ <code>-p &lt;host_port:container_port&gt;</code> 将容器指定端口映射到主机指定端口；</p><p>⑤ <code>-P</code> 将容器端口开放到 <code>Host OS</code> 的随机端口；</p><p>⑥ <code>-v &lt;host_dir:container_dir&gt;</code> 将主机指定目录作为<strong>数据卷</strong>挂载到容器指定目录上，<strong>不会覆盖</strong> Dockerfile 中的 <code>VOLUME</code> 指令。因为如果有 <code>VOLUME</code> 指令，那么在构建镜像时匿名卷已被创建；（<strong>详细见 Chapter 5</strong>）</p><p>⑦ <code>--name &lt;containerName&gt;</code> 为容器命名，<strong>在容器互联、集群时非常重要</strong>；</p><p>⑧ <code>--network</code> 参数见 <strong>6.2 容器互联</strong>；</p></li><li><p><code>[CMD]</code>：<strong>会覆盖 Dockerfile 中的 <code>CMD</code> 指令</strong>；</p></li></ul></li><li><p>运行该命令后 docker engine 在干什么：</p><ol><li>检查本地是否存在指定的镜像，不存在就从 Docker Registory 下载；</li><li>利用镜像创建并启动一个容器；</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层；</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去；</li><li>从地址池配置一个 ip 地址给容器；</li><li>执行用户指定的应用程序；</li><li>执行完毕后容器被终止；</li></ol></li></ul><h4 id="3-1-2-启动已终止的容器"><a href="#3-1-2-启动已终止的容器" class="headerlink" title="3.1.2 启动已终止的容器"></a>3.1.2 启动已终止的容器</h4><p>就一句：<code>docker container start &lt;ID&gt;</code>（如果容器没有exit，应该用 <code>restart</code>）；</p><h3 id="3-2-终止容器"><a href="#3-2-终止容器" class="headerlink" title="3.2 终止容器"></a>3.2 终止容器</h3><p>也就一句：<code>docker container stop &lt;ID&gt;</code>；</p><p>此外，查看所有<strong>正在运行的</strong>容器：<code>docker container ls</code>；</p><p>⚠ <strong>处于终止状态的容器需要在后面加 <code>-a</code> 参数：<code>docker container ls -a</code></strong>；</p><h3 id="3-3-进入容器"><a href="#3-3-进入容器" class="headerlink" title="3.3 进入容器"></a>3.3 进入容器</h3><p>本质上就是在容器中创建一个 bash 程序，并把 I/O 绑定到当前 TTY 上。总共两种方法：</p><ul><li><code>docker attach &lt;ID&gt;</code>，不建议使用，因为执行 <code>exit</code> 退出这个 bash 后，会给整个容器发送 SIGABRT 信号，导致终止；</li><li><code>docker exec -it &lt;ID&gt; bash</code>：使用 <code>exit</code> 退出 bash 不影响原来容器；显然 <code>docker exec</code> 不止可以进入容器，还能干其他事（把 <code>-it</code> 去掉，最后一个参数换成要运行的命令等等，详细内容请参阅官方文档，或者运行 <code>docker exec --help</code>）；</li></ul><h3 id="3-4-导入和导出"><a href="#3-4-导入和导出" class="headerlink" title="3.4 导入和导出"></a>3.4 导入和导出</h3><ul><li><p>将容器保存为快照（<strong>这会丢弃容器的元数据</strong>）：<code>docker export &lt;ID&gt; &gt; compressFile.tar</code>；</p></li><li><p>将<strong>容器快照展开为镜像</strong>（这是镜像的另一种创建方式：<strong>从容器创建</strong>）：<code>cat compressFile.tar | docker import - &lt;REPO_NAME&gt;</code></p><blockquote><p>复习一下，<code>REPO_NAME</code> = <code>userName/IMAGE_NAME:tag</code>；</p></blockquote><p>除了管道流方法以外，还可以从指定地址展开镜像：<code>docker import http://example.com/exampleimage.tgz example/imagerepo</code>；</p></li></ul><h3 id="3-5-删除容器"><a href="#3-5-删除容器" class="headerlink" title="3.5 删除容器"></a>3.5 删除容器</h3><ul><li><p>删除<strong>处于终止状态的</strong>容器：<code>docker container rm &lt;ID&gt;</code>；</p><ul><li>如果需要删除任何状态的容器（包括正在运行的），则需添加 <code>-f</code> 参数，这会给正在运行的容器先发送 <code>SIGKILL</code> 信号；</li><li>如果实在需要在停止容器的同时删除挂载的数据卷：添加 <code>-v</code> 参数；</li></ul></li><li><p>清除<strong>所有</strong>处于终止状态的容器：<code>docker container prune</code> </p><blockquote><p>复习一下：清除所有虚悬镜像：<code>docker image prune</code></p></blockquote></li></ul><h2 id="Chapter-4-访问仓库"><a href="#Chapter-4-访问仓库" class="headerlink" title="Chapter 4. 访问仓库"></a>Chapter 4. 访问仓库</h2><h3 id="4-1-Docker-Hub"><a href="#4-1-Docker-Hub" class="headerlink" title="4.1 Docker Hub"></a>4.1 Docker Hub</h3><ul><li><p>登录/登出 docker 账户：<code>docker login/logout</code>；</p></li><li><p>查找相关镜像：<code>docker search [--filter=starts=N] &lt;...&gt;</code>（里面示例筛选器是筛选 N 星以上的镜像）；</p></li><li><p>推送镜像到自己账户的公共仓库中（需登录）：<code>docker push &lt;userName/IMGAE_NAME:tag&gt;</code>；</p><blockquote><p>提示：<strong>目前自动构建（Automated build）仅支持付费用户</strong>，没钱没用过，不讨论；</p></blockquote></li></ul><h3 id="4-2-私有仓库管理"><a href="#4-2-私有仓库管理" class="headerlink" title="4.2 私有仓库管理"></a>4.2 私有仓库管理</h3><p><code>docker-registry</code> 相关命令，平时没啥人用，不作介绍；</p><h2 id="Chapter-5-数据管理"><a href="#Chapter-5-数据管理" class="headerlink" title="Chapter 5. 数据管理"></a>Chapter 5. 数据管理</h2><h3 id="5-1-数据卷"><a href="#5-1-数据卷" class="headerlink" title="5.1 数据卷"></a>5.1 数据卷</h3><p>在之前已经无数次接触到数据卷的概念，现在详细说明数据卷的概念和使用；</p><ul><li><p>概念和特征：是一个可供一个或多个容器使用的特殊目录，<strong>可以理解为 Linux 下对目录或文件进行 <code>mount</code></strong>；</p><ul><li><p>数据卷可以<strong>在容器之间共享和重用</strong>；</p></li><li><p>对数据卷的修改会立马生效；但对数据卷的更新，不会影响镜像（挂载的特征）；</p></li><li><p>数据卷默认会一直存在，即使容器被删除（<strong>没有自动回收机制，独立于容器，需要手动删除</strong>）</p><blockquote><p>数据无价，谨慎删除；</p></blockquote></li><li><p><strong>匿名卷也是一个数据卷</strong>；</p></li></ul></li><li><p>管理数据卷：docker 支持在没有启动容器时，手动对数据卷进行管理；</p><ul><li><p>查看所有数据卷：<code>docker volume ls</code>；</p></li><li><p>查看特定数据卷详细信息：<code>docker volume inspect &lt;volumeName&gt;</code>；</p></li><li><p>创建数据卷：<code>docker volume create &lt;volumeName&gt;</code>；</p><blockquote><p>和匿名卷一样，默认挂载于 <code>/var/lib/docker/containers/</code> 中；</p></blockquote></li><li><p>启动一个挂载指定数据卷的容器：3.1.1 介绍过，<code>-v</code> 参数，<strong>等价于：<code>--mount source=&lt;volumeName&gt;,target=&lt;containerPath&gt;</code></strong>；</p></li><li><p>手动删除数据卷：<code>docker volume rm &lt;volumeName&gt;</code>；</p></li><li><p>清理<strong>没有被当前容器使用的</strong>数据卷：<code>docker volume prune</code>；</p></li></ul></li></ul><h3 id="5-2-挂载主机目录"><a href="#5-2-挂载主机目录" class="headerlink" title="5.2 挂载主机目录"></a>5.2 挂载主机目录</h3><ul><li><p>和数据卷比较：挂载主机目录和挂载数据卷极其类似，不过前者是自定义位置，后者默认和匿名卷都放在一起；</p></li><li><p>使用：<code>docker run</code> 的 <code>-v</code> 参数，<strong>如果 Host OS 中没有指定目录，会自动创建</strong>；</p><p>或者：<code>docker run</code> 的 <code>--mount type=bind,source=&lt;dir&gt;,target=&lt;cDir&gt;</code> ，如果本地目录不存在，则报错；</p><p><strong>也可以仅赋予只读权限：<code>--mount type=bind,source=&lt;dir&gt;,target=&lt;cDir&gt;,readonly</code></strong>；</p></li><li><p><strong>甚至可以只挂载一个主机文件</strong>；</p></li></ul><h2 id="Chapter-6-网络配置"><a href="#Chapter-6-网络配置" class="headerlink" title="Chapter 6. 网络配置"></a>Chapter 6. 网络配置</h2><h3 id="6-1-外部访问"><a href="#6-1-外部访问" class="headerlink" title="6.1 外部访问"></a>6.1 外部访问</h3><p>绝大部分内容已在 3.1.1 启动容器时介绍，这里仅介绍一些高级用法；</p><ul><li><p><code>-p</code> 参数可以多次使用来绑定多个端口：<code>docker run -d -p 80:80 -p 443:443 nginx:alpine</code></p></li><li><p><code>-P</code> 参数的 “随机” 是针对 Host OS 的端口随机分配，一般会按照 Dockerfile 中的 <code>EXPOSE</code> 分配指定的容器内部端口；</p><blockquote><p>等价于在 <code>docker run</code> 中加入参数：<code>-p 127.0.0.1::&lt;EXPOSE_port&gt;</code></p></blockquote></li></ul><h3 id="6-2-容器互联"><a href="#6-2-容器互联" class="headerlink" title="6.2 容器互联"></a>6.2 容器互联</h3><p>以前会使用<code>docker run</code> 的 <code>--link</code> 参数，进行点对点的连接；但随着结点数的增大，这么做不容于配置；正确做法是<strong>自行配置容器间的网络</strong>；</p><ul><li><p>新建容器网络：<code>docker network create -d bridge &lt;netName&gt;</code></p><blockquote><p><code>-d</code> 参数指定网络类型，参数值有 <code>bridge</code>（网桥） 和 <code>overlay</code>，前者用的多，后者需要配合 <code>swarm mode</code> 配置集群，暂时不介绍；</p></blockquote></li><li><p>运行容器同时将容器连接到网络：<code>docker run</code> 的 <code>--network &lt;netName&gt;</code> </p><blockquote><p>注意：如果要容器连接网络，强烈建议自己为<strong>容器命名</strong>：<code>--name</code> 参数，因为容器间交互识别就靠容器名——<strong>在一个容器中可以访问同网络的另一个容器：<code>ping &lt;containerName&gt;</code></strong>；</p></blockquote></li></ul><p><strong>其实更方便的做法是：使用 <code>Docker compose</code>（Chapter 7）</strong>；</p><h3 id="6-3-DNS-配置"><a href="#6-3-DNS-配置" class="headerlink" title="6.3 DNS 配置"></a>6.3 DNS 配置</h3><p>这个操作在特殊场合有用（因为一般默认容器中的 DNS 设置就够用了），比如某些同学想用 <code>Grasscutter</code> 建立 Ys 私服的时候，包装成 Docker 镜像时就需要将一系列网络代理到本机上——如果使用 DNS 劫持的方法就需要在容器内配置 DNS；</p><p>最方便的方法是构建镜像时自己写一个 <code>HOST</code> 文件在放到<code>/etc/hosts</code>；</p><p>当然，也可以通过 <code>docker run</code> 的 <code>-h HOSTNAME</code> 写入 <code>/etc/hosts</code> 和 <code>/etc/hostname</code> ，还可以通过 <code>docker run</code> 的 <code>--dns=IP_ADDR</code> 写入 DNS 服务器地址（在 <code>/etc/resolv.conf</code>）；</p><p>还可以通过修改主机 <code>/etc/docker/daemon.json</code> 来<strong>同时修改所有容器的 DNS 服务器</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Chapter-7-Docker-Compose"><a href="#Chapter-7-Docker-Compose" class="headerlink" title="Chapter 7. Docker Compose"></a>Chapter 7. Docker Compose</h2><h3 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h3><ul><li><p>地位：由 <code>Python</code> 编写的 Docker 官方的开源项目；</p></li><li><p>定位：定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）；</p></li><li><p>作用：允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project），<strong>很方便地实现容器运行设置、互联</strong>；</p></li><li><p><strong>两个重要概念</strong>：服务和项目</p><ul><li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例；</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义；</li></ul><blockquote><p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理；</p></blockquote></li><li><p>和 docker 普通用法的比较【重要】：docker compose <strong>不在于构建镜像</strong>，而在于<strong>直接一条龙拉取已有镜像/按 <code>Dockerfile</code> 构建自定义镜像（前面章节的内容），并按配置运行<u>一组</u>容器</strong>；</p></li><li><p><strong>举例认识</strong>🌰：假设有一个项目，使用 <code>Python</code> 建立一个记录页面访问次数的 Web 服务，使用 <code>Flask</code> 框架、<code>redis</code> 服务器；</p><blockquote><p>（本部分无需看懂，只需要感受 <code>docker compose</code> 使用便捷就行）</p><p><strong>如果使用 docker 原来的方法，编写 <code>Dockerfile</code> 来构建容器，那么需要作很多事</strong>：从一个 Python 镜像中开始构建、安装 flask、安装 redis、复制项目文件、删除安装的 apt 缓存和安装包等文件，运行 <code>docker run</code> 还要加各种参数，例如挂载、端口、网络互联……</p><p>但如果使用 <code>docker compose</code> 就不一样了：</p></blockquote><p>编写模板文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File: docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span>        <span class="comment"># 容器内的所有服务</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span>            <span class="comment"># web 服务</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span>    <span class="comment"># 镜像构建方法是当前页面的自定义镜像：./Dockerfile</span></span><br><span class="line">    <span class="attr">ports:</span>        <span class="comment"># 运行该 web 服务的容器时，进行端口映射，相当于 docker run 的 -p</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span>        <span class="comment"># redis 服务</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span>    <span class="comment"># 镜像构建方法是直接从 redis:alpine 拉取</span></span><br></pre></td></tr></table></figure><p>编写 web 服务的镜像构建 Dockerfile（python + flask + 项目文件）：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install redis flask</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>最后直接运行：<code>docker compose up -d</code> ，结束！</p></li></ul><h3 id="7-2-安装"><a href="#7-2-安装" class="headerlink" title="7.2 安装"></a>7.2 安装</h3><blockquote><p>需要已经安装 Docker 及其服务；</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_CONFIG=/usr/local/lib/docker/cli-plugins</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p <span class="variable">$DOCKER_CONFIG</span>/cli-plugins</span><br><span class="line"><span class="comment"># 国内加速：</span></span><br><span class="line"><span class="comment"># sudo curl -SL https://download.fastgit.org/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose</span></span><br><span class="line">sudo curl -SL https://github.com/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 -o <span class="variable">$DOCKER_CONFIG</span>/cli-plugins/docker-compose</span><br><span class="line">sudo <span class="built_in">chmod</span> +x <span class="variable">$DOCKER_CONFIG</span>/cli-plugins</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="7-3-compose-命令"><a href="#7-3-compose-命令" class="headerlink" title="7.3 compose 命令"></a>7.3 compose 命令</h3><blockquote><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响；</p></blockquote><p>语法：<code>docker compose [options] [compose-command]</code>；</p><h4 id="options-参数"><a href="#options-参数" class="headerlink" title="[options] 参数"></a>[options] 参数</h4><ul><li><code>-f template</code> 指定 docker compose 模板，默认 <code>docker-compose.yml</code>；</li><li><code>-p Name</code> 指定项目名称；</li><li><code>--verbose</code> 运行时调试信息更详细；</li></ul><h4 id="compose-command-命令"><a href="#compose-command-命令" class="headerlink" title="[compose-command] 命令"></a>[compose-command] 命令</h4><h5 id="构建-amp-运行命令"><a href="#构建-amp-运行命令" class="headerlink" title="构建&amp;运行命令"></a>构建&amp;运行命令</h5><ul><li><p><code>pull</code>：拉取模板中的基础镜像；</p></li><li><p><code>build [options]</code>：按模板构建项目中的所有镜像并组合为容器；</p><ul><li><code>--force-rm</code>：删除构建过程中产生的临时镜像；</li><li><code>--no-cache</code>： 不使用缓存构建；</li></ul></li><li><code>start [serviceName]</code>：启动<strong>已存在的指定服务容器</strong>；</li><li><code>restart [-t TIMEOUT]</code>：重启项目中的服务；<ul><li><code>-t TIMEOUT</code>：重启前停止容器；</li></ul></li><li><code>run [options] &lt;serviceName&gt; [CMD]</code>：手动<strong>按 <code>docker run</code> 一样的参数</strong>启动指定容器，用的少，因为不如在 <code>docker-compose</code> 里设置并且 <code>up</code>  启动；</li><li><strong><code>up [options]</code>：强大的命令，可以一次性实现上述所有命令（构建镜像、（重新）创建服务、启动服务，并关联服务相关容器）</strong>；<ul><li><code>-d</code>（detach）：后台运行；</li><li>其他选项和上面的前 4 条命令一样；</li></ul></li></ul><h5 id="停止-amp-管理命令"><a href="#停止-amp-管理命令" class="headerlink" title="停止&amp;管理命令"></a>停止&amp;管理命令</h5><ul><li><code>down</code>：停止 <code>up</code> 所启动的容器，同时移除网络；</li><li><code>stop [serviceName]</code>：仅停止指定服务容器，不删除任何东西，可以通过 <code>start</code> 再启动；</li><li><code>kill [-s SIGNAL] [serviceName]</code>：通过 <code>-s</code> 传递终止信号结束服务容器 ；</li><li><code>pause/unpause [serviceName]</code>：暂停指定服务容器 / 恢复被暂停的服务容器；</li><li><code>rm [options] [serviceName]</code>：删除所有处于停止状态的服务容器，options 参数和 docker 一样；</li><li><code>exec [options]</code>：进入指定容器，参数和 docker 一样；</li></ul><h5 id="维护命令"><a href="#维护命令" class="headerlink" title="维护命令"></a>维护命令</h5><ul><li><code>images</code>：列出模板中所含的所有镜像；</li><li><code>ps</code>：列出项目中<strong>当前所有容器</strong>；</li><li><code>top</code>：查看<strong>各服务容器里运行的进程</strong>（这样就不用在容器里装 <code>procps</code> 包了）；</li><li><code>logs [serviceName]</code>：查看某个服务容器的 stdout 输出，对调试有用；</li><li><code>version</code>：版本信息；</li><li><code>help</code>：帮助；</li></ul><h3 id="7-4-docker-compose-模板"><a href="#7-4-docker-compose-模板" class="headerlink" title="7.4 docker-compose 模板"></a>7.4 docker-compose 模板</h3><p>和 7.1 里说的一样，<code>docker-compose.yml</code> 同时完成指定构建什么镜像（自己不会设计镜像）和 <code>docker run</code> 的工作，所有<strong>可以将下面的选项和前几章的指令一一对照</strong>； </p><p>下面直接在文件中说明：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span>    <span class="comment"># 指定一个版本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span>        <span class="comment"># 必不可缺的部分，是容器运行的核心——服务</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">webApp:</span><span class="comment"># 服务名，可以自己取，代表容器的其中一个服务。</span></span><br><span class="line">                <span class="comment"># 注意，每个服务都可以指定一个构建镜像</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&lt;XX/XX&gt;</span><span class="comment"># image 和 build 选项二选一（必选，因为容器必须要从镜像开始）</span></span><br><span class="line">        <span class="attr">build:</span> <span class="string">&lt;dir&gt;</span><span class="comment"># image 指这个容器从已存在的镜像构建，值是 REPO_NAME</span></span><br><span class="line">                        <span class="comment"># build 指这个容器将自行构建镜像，值是上下文目录（必须包含 Dockerfile）</span></span><br><span class="line">        <span class="attr">build:</span><span class="comment"># 但如果上下文目录和 Dockerfile 不在一起，请详细指定，如左</span></span><br><span class="line">            <span class="attr">context:</span> <span class="string">&lt;dir&gt;</span></span><br><span class="line">            <span class="attr">dockerfile:</span> <span class="string">&lt;path&gt;</span></span><br><span class="line">            <span class="attr">args:</span></span><br><span class="line">                <span class="comment"># 这里相当于 docker build 的参数，不过不能缩写，没有“--”</span></span><br><span class="line">                </span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">&lt;name&gt;</span><span class="comment"># 谨慎使用，会降低模板文件的扩展性，因为容器名唯一</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">command:</span> <span class="string">&lt;CMD&gt;</span><span class="comment"># 这里覆盖 Dockerfile 里的 CMD 指令 或者是默认的 CMD 指令</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">devices:</span><span class="comment"># 这里在 Dockerfile 中没讲过，可以映射硬件设备</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;/dev/&lt;host_device&gt;:/dev/&lt;container_device&gt;&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">depends_on:</span><span class="comment"># 这里可以解决依赖问题，会先启动依赖服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;serviceName&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">dns:</span><span class="comment"># DNS 服务器，对应 docker run 的 --dns 参数</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;IP_ADDR&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">tmpfs:</span><span class="comment"># 对应 Dockerfile 中的 VOLUME 指令</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;dir&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">env_file:</span><span class="comment"># 对应 Dockerfile 的 ENV 指令</span></span><br><span class="line">                        <span class="comment"># 通过文件载入环境变量，环境变量文件规范如下：</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;ENV_file&gt;</span><span class="comment"># 以 “#” 作行注释、后缀名 *.env</span></span><br><span class="line">                            <span class="comment"># 内容 “key=value” 顶格、中间不能有空格</span></span><br><span class="line">                            <span class="comment"># 有表达特殊含义的 value 必须用引号引起，特殊词包括：</span></span><br><span class="line">                            <span class="comment">#  y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</span></span><br><span class="line">        <span class="attr">environment:</span><span class="comment"># 环境变量少可以这么用，多的话建议用上面的 env_file</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">key=value</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">expose:</span><span class="comment"># 对应 Dockerfile 的 EXPOSE 指令</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;&lt;port&gt;&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">ports:</span><span class="comment"># 对应 docker run 的 -p 参数</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;&lt;host_port&gt;:&lt;container_port&gt;&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">extra_hosts:</span><span class="comment"># 对应 docker run 的 -h 参数，可以进行 DNS 劫持</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;domain:IP&quot;</span><span class="comment"># 会在 /etc/hosts 文件中添加：&quot;IP domain&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">healthcheck:</span><span class="comment"># 对应 Dockerfile 的 HEALTHCHECK 指令</span></span><br><span class="line">            <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;&lt;COMMAND&gt;&quot;</span>]</span><br><span class="line">            <span class="attr">interval:</span> <span class="string">&lt;time&gt;</span></span><br><span class="line">            <span class="attr">timeout:</span> <span class="string">&lt;time&gt;</span></span><br><span class="line">            <span class="attr">retries:</span> <span class="string">N</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">labels:</span><span class="comment"># 对应 Dockerfile 的 LABEL 指令</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">value</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">user:</span> <span class="string">&lt;name&gt;</span><span class="comment"># 对应 Dockerfile 的 USER 指令</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">working_dir:</span> <span class="string">&lt;dir&gt;</span><span class="comment"># 对应 Dockerfile 的 WORKDIR 指令</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">entrypoint:</span> <span class="string">&lt;COMMAND&gt;</span> <span class="comment"># 对应 Dockerfile 的 ENTRYPOINT 指令</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">restart:</span> <span class="string">&lt;options&gt;</span><span class="comment"># 指定容器退出后的重启策略</span></span><br><span class="line">                            <span class="comment"># 相当有用的选项，对保持服务始终运行十分有效</span></span><br><span class="line">                            <span class="comment"># 在生产环境中推荐配置为 always 或者 unless-stopped</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">logging:</span>    <span class="comment"># 设置容器输出日志</span></span><br><span class="line">            <span class="attr">driver:</span> <span class="string">&lt;&quot;json-file&quot;/&quot;syslog&quot;/&quot;none&quot;&gt;</span><span class="comment"># 写成 json 还是和系统一致</span></span><br><span class="line">            <span class="attr">options:</span><span class="comment"># 日志轮替选项</span></span><br><span class="line">                <span class="attr">max-size:</span> <span class="string">&quot;Nk&quot;</span> <span class="comment"># 或 &quot;Nm&quot;</span></span><br><span class="line">                <span class="attr">max-file:</span> <span class="string">N</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 如此还可以写下一个服务……</span></span><br></pre></td></tr></table></figure><p>还有<strong>两个重要选项 和 一个重要的行为</strong>需要单独拎出来说：</p><p><strong>① <code>volumes</code> 挂载选项</strong>：对应 Dockerfile 的 <code>VOLUME</code> 指令，用法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="string">&lt;serviceName&gt;:</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;host_dir&gt;:&lt;container_dir&gt;</span><span class="comment"># 对应 docker run 本机目录挂载（可选）</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;volumName&gt;:&lt;container_dir&gt;</span><span class="comment"># 对应 docker run 数据卷挂载（可选）</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 如果上面使用了数据卷名（volumnName），那么需要声明创建一个数据卷：</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">    <span class="string">&lt;volumeName&gt;:</span><span class="comment"># 和匿名卷放在一个位置，不用给它值</span></span><br></pre></td></tr></table></figure><p><strong>② <code>networks</code> 网络选项</strong>：对应 docker run 的 <code>--network</code> 参数，用法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="string">&lt;serviceName&gt;:</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">networks:</span><span class="comment"># 容器加入某个指定网络，可以同时加入多个网络</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;netName&gt;</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 上面使用了 networks 就必须指定网络名称</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="string">&lt;netName1&gt;:</span><span class="comment"># 如果名字是 default，设置默认网络，一般不用设置</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">&lt;bridge/overlays&gt;</span><span class="comment"># 对应 docker network create 的 -d 参数</span></span><br><span class="line">        </span><br><span class="line">    <span class="string">&lt;netName2&gt;:</span></span><br><span class="line">        <span class="attr">external:</span><span class="comment"># 如果不希望 docker compose 创建网络，想自己 docker network create，那么引入外部设置网络需要 external 选项</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">&lt;external_netName&gt;</span></span><br></pre></td></tr></table></figure><p>⚠ <strong>重要行为：<code>docker-compose.yml</code> 读取环境变量</strong></p><p>如果在模板文件中使用 <code>$&#123;XXX&#125;</code> 的变量，模板会先搜索<strong>系统环境变量</strong>，再搜索<strong>之前设置的 <code>env_files/environment</code> 选项</strong>；</p><hr><p>docker 入门基础篇完【EOF】</p><p>预计将会跟进 docker 底层实现分析、<code>Kubernetes</code> 集群 等内容；</p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Container </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL学习笔记-第一部分</title>
      <link href="//technical/sql-basic-1/"/>
      <url>//technical/sql-basic-1/</url>
      
        <content type="html"><![CDATA[<p><i>written by SJTU-XHW</i></p><p><i>本部分文章是 SQL 的基础部分，纪念我丢掉的 SQL 笔记</i> 😭</p><p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p><p>Reference: 《 <a href="https://forta.com/books/0135182794/">SQL 必知必会 (第 5 版 )</a> 》</p><hr><h1 id="使用前须知"><a href="#使用前须知" class="headerlink" title="使用前须知"></a>使用前须知</h1><p>本系列文章的 “章末习题” 使用的数据库和表的关系如下图所示；</p><p><img src="./sample_tables.jpg"></p><p>这里提供创建表和数据的 SQL 文本（以 MySQL 为例）：<a href="./generate.sql">generate.sql</a>，可以在搭建好 MySQL 环境后直接导入它，以备后面章末习题使用；</p><h1 id="Chapter-0-数据库的基本概念"><a href="#Chapter-0-数据库的基本概念" class="headerlink" title="Chapter 0 数据库的基本概念"></a>Chapter 0 数据库的基本概念</h1><ul><li><p>数据库（从 SQL 角度看）：<strong>以某种有组织的方式存储的数据集合</strong>；</p></li><li><p>关系型数据库 &amp; 非关系型数据库</p><ul><li>关系型数据库：采用关系模型、遵循关系代数模式来组织数据的数据库（例如 MySQL、PostgreSQL等）；<strong>关系模型类似二维表，允许表间数据相互关联，支持多表查询</strong>；</li><li>非关系型数据库（No SQL）：不依赖关系模型的、分布式的数据库（例如 MongoDB、Redis 等）；<strong>以键值来存储，结构不稳定，每个元组的字段可以不相同，可以面向高并发key-value读写 / 面向文档</strong>；</li></ul><div style="text-align: center;">表一 关系型数据库 &amp; 非关系型数据库比</div><table>    <tr>        <td>项目</td>        <td>RDB</td>        <td>NOSQL(Not Only SQL)</td>    </tr>    <tr>        <td>是否依赖关系模型</td>        <td>是，二维表容易理解</td>        <td>否，key-value 存储较为零散</td>    </tr>    <tr>        <td>是否有通用的 SQL</td>        <td>有，使用方便</td>        <td>无，无法提供WHERE字段查询</td>    </tr>    <tr>        <td>事务的一致性</td>        <td>强，ACID属性易于维护</td>        <td>弱，适宜面向网络/文档/高并发读写等场景</td>    </tr>    <tr>        <td>拓展能力</td>        <td>纵向，依赖处理能力提升</td>        <td>横向，天然分布式</td>    </tr>    <tr>        <td>存储数据</td>        <td>适宜结构化数据，例如账户、地址</td>        <td>适宜非结构化数据，例如文章、评论</td>    </tr></table></li></ul><p>  注：一般生产环境会使用 <code>RDB + NoSQL</code> 组合方案，互相取长补短；</p><p>  ⚠ <strong>本文章仅讨论关系型数据库中的 标准 SQL</strong>；</p><ul><li><p>数据库管理系统（DBMS）：俗称数据库管理系统；<strong>数据库是通过 DBMS 创建和操纵的容器</strong>；</p><blockquote><p>MySQL、mariaDB、mongoDB、SQLite 等等都是 DBMS，而它们创建的数据库才是真正的 “数据库”；</p></blockquote></li><li><p>表（table）：某种特定类型数据的结构化清单；</p><blockquote><p><strong>根据定义，可以理解为：在数据库（相当于文件柜）中，存放文件需要放在特定的档案中，这个“文件柜”中的“档案”就是表；</strong></p><p><strong>表存储的是同一种类型的数据或清单，<u>便于归类和查找</u></strong></p></blockquote></li><li><p>表名：表的唯一标识符（ID），在一个数据库中唯一，但不同数据库的表之间名字可以相同；</p></li><li><p>模式（schema）：关于数据库和表的布局及特性的信息；</p><blockquote><p><strong>描述数据库中特定的表，或者描述整个数据库及表的关系</strong>；</p><p>包括：储存什么数据？数据如何分解（parse）？各部分信息如何命名？……</p></blockquote></li><li><p>列（column）：表中的一个字段，存储表的某一个部分/领域（field）的信息；</p><blockquote><p><strong>所有表都是由一个或多个列组成</strong>；</p><p><strong>正确地按需求对数据列分解对于分类、过滤意义重大</strong>；例如，将国家和省市信息组合在一个列中，那么仅按省市查找的难度就比 “国家、省市信息分开在两列中” 的情况更大；</p></blockquote></li><li><p>数据类型：每一列需要有相应的数据类型，限制该列存储的数据（以方便分类和查找）；</p><blockquote><p>对表的各列设计数据类型也是重要的：正确地设计数据类型不仅可以帮助正确分类和查找，还可以优化磁盘容量；</p></blockquote><p>⚠ <strong>因为有些 DBMS 中同一个数据类型的名称不一样（数据类型兼容问题），即便名称相同，定义可能不一样，所以应该总是查阅文档、学习和应用时需要注意</strong>；</p></li><li><p>行：表中的一个记录（从技术上说，行才是正确的术语）；</p></li><li><p>主键（primary key）：表中的每一行都<u>应该</u>有一列（或几列）可以<strong>唯一标识自己（ID）</strong>；</p><blockquote><p><strong>没有主键，更新、删除数据库表的特定行就极其困难，不能保证没有误操作</strong>；</p><p>所以规范来说，表应该总是定义主键；</p></blockquote><p><strong>主键的要求</strong>：</p><ol><li><strong>互异性</strong>：表的任意两行都不具有相同主键值；</li><li><strong>非空性</strong>：每一行必须具有一个主键值（不允许为 NULL 空值）；</li><li><strong>固定性</strong>：主键列中的值不允许修改和更新；</li><li><strong>不可重用性</strong>：如果表的一行从表中被删除，那么它的主键不能赋给以后的新行；</li></ol></li><li><p>SQL：<code>Structured Query Language</code>，结构化查询语言（专门用来与数据库沟通的语言）；</p><ol><li>不是某个数据库厂商、某类 DBMS 特有的语言；</li><li>关键字数量极少，但功能强大；</li></ol><blockquote><p>本文章不考虑某些 DBMS 的 SQL 扩展（某个厂商独有、独自开发的），仅讨论标准 SQL（ANSI SQL）；</p></blockquote></li><li><p>SQL 的关键字：作为 SQL 组成部分的保留字，不能用作表 / 列的名字；会在以后章节中逐渐提及；</p></li><li><p>SQL 语言注意事项</p><ol><li><p>SQL 语句的结束：以分号结尾；</p></li><li><p>SQL 语句不区分大小写，但习惯上约定俗成：关键字大写、列/表名小写；</p></li><li><p>在一个 SQL 语句未结束时，可以在两个词间添加换行，不会有影响，一般是方便阅读；</p></li><li><p>SQL 语言的索引<strong>从0开始</strong>，因此也是一种 <strong>0-index 语言</strong>；</p></li><li><p>注释方式：行内注释 <code>--</code>（后面跟一个空格）、单行注释 <code>#</code> （某些 DBMS 不支持）、多行注释 <code>/* [contents] */</code>；</p><blockquote><p>好习惯：和 其他所有编程语言一样，必要时多加注释；</p></blockquote></li></ol></li></ul><h1 id="Chapter-1-数据检索"><a href="#Chapter-1-数据检索" class="headerlink" title="Chapter 1 数据检索"></a>Chapter 1 数据检索</h1><h2 id="1-1-SELECT-语句"><a href="#1-1-SELECT-语句" class="headerlink" title="1.1 SELECT 语句"></a>1.1 SELECT 语句</h2><ul><li><p>用途：从一个或多个表中检索信息；</p></li><li><p>语法</p><ul><li><p>检索某一个表的 <strong>某一个列</strong>：<code>SELECT &lt;column_name&gt; FROM &lt;table_name&gt;;</code></p></li><li><p>同时检索 <strong>多个列</strong>：<code>SELECT &lt;col_name1, [col_name2, ...]&gt; FORM &lt;table_name&gt;;</code></p></li><li><p>检索 <strong>所有的的列</strong>：<code>SELECT * FORM &lt;table_name&gt;;</code></p><blockquote><p><strong>谨慎使用通配符（*），除非真的需要，或者不知道需要列的列名</strong>；</p></blockquote></li><li><p>检索表中 <strong>某列不同的值</strong>（<code>DISTINCT</code> 关键字）：<code>SELECT DISTINCT &lt;col_name&gt; FROM &lt;table_name&gt;;</code></p><p>⚠ <strong>不可以部分使用 <code>DISTINCT</code> 关键字，例如：<code>SELECT DISTINCT &lt;col_name1, col_name2&gt; FROM &lt;table_name&gt;;</code></strong></p><p>因为 <code>DISTINCT</code> 作用于所有的列！部分使用会导致失去想要的结果（SQL 需要同时考虑其他列也有 <code>DISTINCT</code>，最后会出现组合的现象）；（而且这么做不符合逻辑）</p><p>ℹ <strong>和 <code>DISTINCT</code>  相反的是 <code>ALL</code>，一般无需指定，因为这是默认行为</strong>；</p></li><li><p>检索 <strong>结果限制</strong>（用来缩小范围找到想要的数据）</p><ol><li><p>限制仅查询 N 行</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">MySQL</button><button type="button" class="tab">Oracle</button><button type="button" class="tab">SQL-server</button><button type="button" class="tab">DB2</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>col_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">LIMIT N;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>col_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> <span class="number">5</span>;    <span class="comment">-- 行计数器</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">5</span> <span class="operator">&lt;</span>col_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>col_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">5</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p><strong>以下仅以常见的 <code>MySQL</code>、<code>MariaDB</code>为例，不再赘述</strong>；</p></li><li><p>限制指定行：<code>M ~ M+N</code></p><p>⚠ <strong>SQL 语言 0-index</strong>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;col_name&gt;</span><br><span class="line">FROM &lt;table_name&gt;</span><br><span class="line">LIMIT N OFFSET M; -- 即 0+M ~ 0+M+N</span><br><span class="line">-- 或者</span><br><span class="line">LIMIT M,N;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>习题</p><ol><li><p>从 <code>customers</code> 表中检索所有的 <code>cust_id</code> 列的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id</span><br><span class="line"><span class="keyword">FROM</span> customers;</span><br></pre></td></tr></table></figure></li><li><p>已知表 <code>OrderItems</code> （订单表）中存在一列 <code>prod_id</code>（产品 ID），问所有出现在订单中的产品 ID，要求每个产品 ID 仅显示一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> prod_id</span><br><span class="line"><span class="keyword">FROM</span> OrderItems;</span><br></pre></td></tr></table></figure></li><li><p>检索 <code>customers</code> 表中所有的列，再检索其中列 <code>cust_id</code>、<code>cust_name</code>、<code>cust_country</code> 的第 5~9 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers;</span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_country</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line">LIMIT <span class="number">5</span> <span class="keyword">OFFSET</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="1-2-排序已检索数据"><a href="#1-2-排序已检索数据" class="headerlink" title="1.2 排序已检索数据"></a>1.2 排序已检索数据</h2><blockquote><p>主要内容：<code>SELECT</code> 的 <code>ORDER BY</code> 子句；</p></blockquote><ul><li><p>子句（clause）的定义：SQL 语句由子句构成；</p><blockquote><ol><li>有些子句是必需的，有些是可选的；</li><li>一个子句通常是由一个关键字 + 所提供的数据组成；</li></ol></blockquote><p>举例：SELECT 语句的 <code>FROM</code> 子句、<code>LIMIT</code> 子句、<code>ORDER BY</code> 子句等；</p></li><li><p>语法</p><ul><li><p>检索时 <strong>按某一列排序</strong>：<code>SELECT &lt;col_name1[, col_name2, ...]&gt; FROM &lt;tb_name&gt; ORDER BY &lt;col_nameN&gt;;</code></p><p>⚠ <strong>必须保证 <code>ORDER BY</code> 子句为 <code>SELECT</code> 语句的最后一句，否则会出错！</strong> </p><p>ℹ 排序依据的列可以不是选择列（即 <code>col_nameN</code> 可以不在 <code>col_name1, col_name2,...</code>中）；</p></li><li><p>检索时 <strong>按多个列排序</strong>：<code>SELECT &lt;col_name1[, col_name2, ...]&gt; FROM &lt;tb_name&gt; ORDER BY &lt;col_nameN1, col_nameN2, ...&gt;;</code></p><blockquote><p>含义：首先按 <code>col_nameN1</code> 排序，再按 <code>col_nameN2</code> 排序，有点像高考录取排序方法；</p></blockquote></li><li><p>检索时 <strong>使用已选择列的列号排序</strong>（仅仅是一种简化方法）：<code>SELECT &lt;col_Name1[, ...]&gt; FROM &lt;tb_name&gt; ORDER BY &lt;col_num1[, ...]&gt;;</code></p></li><li><p>检索时 <strong>指定排序方向</strong>：<code>SELECT &lt;col_name1[, ...]&gt; FROM &lt;tb_name&gt; ORDER BY &lt;col_nameN1[ASC/DESC][, ...]&gt;;</code></p><blockquote><p>关键字 <code>ASC</code>（Ascending，<strong>默认升序</strong>）、<code>DESC</code>（Descending）；</p></blockquote></li></ul></li><li><p>习题</p><ol><li><p>从 <code>Customers</code> 表中检索所有的顾客名称（<code>cust_names</code>），并按从 Z 到 A 的顺序显示结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_names</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_names <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>从 <code>Orders</code> 表中检索顾客 ID（<code>cust_id</code>）和订单号（<code>order_num</code>），并先按顾客 ID 对结果进行排序，再按订单日期（<code>order_date</code>）倒序排列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_id <span class="keyword">ASC</span>, order_date <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="1-3-过滤已检索数据"><a href="#1-3-过滤已检索数据" class="headerlink" title="1.3 过滤已检索数据"></a>1.3 过滤已检索数据</h2><blockquote><p>主要内容：<code>SELECT</code> 的 <code>WHERE</code> 子句、<code>SELECT</code> 的 <code>LIKE</code> 子句（模糊过滤）；</p></blockquote><ul><li><p><span id="principle">应用须知：<strong>对数据的过滤操作应该交给 SQL，而非上层的应用程序（开发语言）</strong>；</span></p><blockquote><p>原因：</p><ol><li>数据库 SQL 对于数据过滤优化力度远远大于你自己在外层写的，造成性能资源浪费；</li><li>降低上层应用程序的可移植性、可读性、可维护性；</li></ol></blockquote></li><li><p>过滤条件：也称“搜索条件”，用于根据特定操作提取表数据的子句；</p><p>模糊过滤条件：使用类似正则式的方式确定过滤条件（仅适用于文本-string）；</p></li><li><p>谓词（predicate）：某些关键字不是操作符，而是作为谓词使用，例如 <code>LIKE</code>；</p></li><li><p>语法</p><ul><li>在检索时 <strong>过滤条件</strong>：<code>SELECT &lt;col_name[, ...]&gt; FROM &lt;tb_name&gt; WHERE &lt;cond&gt;;</code></li><li>在检索时 <strong>使用模糊过滤条件</strong>：<code>SELECT &lt;col_name[, ...]&gt; FROM &lt;tb_name&gt; WHERE &lt;col_str&gt; LIKE &lt;pattern&gt;;</code></li></ul></li><li><p><code>WHERE &lt;cond&gt;</code> 子句判断操作符：小于(等于)、大于(等于)（与普通编程语言相同），<strong>等于（<code>=</code>）</strong>，不等于（<code>!=</code> 或 <code>&lt;&gt;</code>），不小于（<code>!&lt;</code>），不大于（<code>!&gt;</code>）；</p><blockquote><p>另外：在指定两个值之间使用关键字操作符 <code>BETWEEN...AND...</code>，判断是否为 NULL <code>IS NULL</code>；</p><p>以上操作符有冗余，有些 DBMS 不支持，请自行判断；</p></blockquote><p>⚠ <strong>注意1：NULL（空值）和字段包含0、空字符串、仅含空格的情况都不一样</strong>；</p><p>⚠ <strong>注意2：只要使用了过滤条件，除了 <code>IS NULL</code> 操作符，其他的匹配无法选中匹配列记录为 NULL 的记录！</strong></p><p>⚠ <strong>注意3：等于操作符和主流编程语言不一样，只有一个等号！</strong></p></li><li><p><code>WHERE &lt;cond&gt;</code>  子句条件操作符：<code>AND</code>、<code>OR</code>、<code>NOT</code>、圆括号（改变运算顺序）；</p><blockquote><p>运算顺序同主流编程语言；</p></blockquote></li><li><p><code>WHERE &lt;cond&gt;</code> 子句包含操作符：<code>IN</code>、定元组（例如：<code>(&#39;DLL01&#39;, &#39;BRS01&#39;)</code>）；</p><blockquote><p>建议能用 <code>IN</code>，就用它：</p><p>（例如：<code>SELECT prod_name FROM products WHERE prod_id == &#39;DLL01&#39; OR prod_id == &#39;BRS01&#39;;</code> 不如 <code>SELECT prod_name FROM products WHERE prod_id in (&#39;DLL01&#39;, &#39;BRS01&#39;);</code>）</p><p>因为它有好处：</p><ol><li><code>IN</code> 操作符可读性更强；</li><li>数据库底层优化 <code>IN</code> 可以使用一次 HASH 操作，效率高于 <code>OR</code> 连接的运算；</li><li><code>IN</code> 操作符可以实现 <code>WHERE</code> 子句的嵌套（后面讨论）；</li></ol></blockquote></li><li><p><code>WHERE</code> 子句的 <code>pattern</code>：</p><div style="text-align: center;">表二 SQL pattern 和 正则式对比</div><table>    <tr>        <td>SQL pattern</td>        <td>% (NULL excluded)</td>        <td>_</td>        <td>[char set]</td>        <td>[^char set]</td>    </tr>    <tr>        <td>Regex</td>        <td>.?</td>        <td>.</td>        <td>.[char set]</td>        <td>.[^char set]</td>    </tr></table></li></ul><p>  ⚠ <strong>注意1：在 <code>LIKE</code> 匹配时，<code>pattern</code> 区分大小写！</strong></p><p>  ⚠ <strong>注意2：在有些数据库的数据中，对于字符串数据类型按指定位存储时，不满位数的会填充以空格，因此 pattern 可能很难匹配到；正确做法是利用 SQL 自带函数去除字符串两边空格，后面讨论；</strong>、</p><p>  ⚠ <strong>注意3：不宜过度使用通配符、不宜将通配符作为靠前的搜索条件；</strong></p><ul><li><p>习题</p><ol><li><p>从Products 表中检索产品ID（<code>prod_id</code>）和产品名称（<code>prod_name</code>），只返回价格（<code>prod_price</code>）为 9 或更高的产品：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure></li><li><p>从 <code>OrderItems</code> 表中检索出所有不同订单号（<code>order_num</code>），其中包含产品个数（<code>quantity</code>）在 100 个至 200 个之间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> quantity <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">WHERE</span> quantity <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">AND</span> quantity <span class="operator">&lt;=</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure></li><li><p>返回 <code>Products</code> 表中所有价格在 3 美元到 6 美元之间的产品的名称（<code>prod_name</code>）和价格（<code>prod_price</code>），然后先按价格、后按 ID （<code>prod_id</code>）对结果都进行降序排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">6</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name <span class="keyword">DESC</span>, prod_id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>查找所有至少订购了总量（<code>quantity</code>） 100 个的，ID 为 <code>BR01</code>、<code>BR02</code> 或 <code>BR03</code> 的订单。你需要返回<code>OrderItems</code> 表的订单号（<code>order_num</code>）、产品ID（<code>prod_id</code>）和数量，并按产品 ID 和数量进行升序排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, prod_id</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> quantity <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">AND</span> prod_id <span class="keyword">IN</span> (<span class="string">&#x27;BR01&#x27;</span>, <span class="string">&#x27;BR02&#x27;</span>, <span class="string">&#x27;BR03&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_id, quantity;</span><br></pre></td></tr></table></figure></li><li><p>从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回描述中未出现 <code>toy</code> 一词的产品。要求按产品名称对结果进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_desc</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> (prod_desc <span class="keyword">LIKE</span> <span class="string">&#x27;%toy%&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure></li><li><p>从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回在描述<br>中以先后顺序同时出现 <code>toy</code> 和 <code>carrots</code> 的产品：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_desc</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_desc <span class="keyword">LIKE</span> <span class="string">&#x27;%toy%carrots%&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="Chapter-2-字段格式化输出"><a href="#Chapter-2-字段格式化输出" class="headerlink" title="Chapter 2 字段格式化输出"></a>Chapter 2 字段格式化输出</h1><blockquote><p>表中的列称为列，而在“计算字段”（格式化字段）中称为字段（field）；</p><p><strong>格式化输出的思想也遵循<a href="#principle">本思想🔗</a></strong></p></blockquote><h2 id="2-1-字段拼接"><a href="#2-1-字段拼接" class="headerlink" title="2.1 字段拼接"></a>2.1 字段拼接</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">MySQL</button><button type="button" class="tab">SQL-Server</button><button type="button" class="tab">DB2/SQLite</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Concat(col_name1<span class="operator">/</span><span class="string">&#x27;string1&#x27;</span>[, ...])</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_name1<span class="operator">/</span><span class="string">&#x27;string1&#x27;</span> <span class="operator">+</span> ... <span class="operator">+</span> col_nameN<span class="operator">/</span><span class="string">&#x27;stringN&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_name1<span class="operator">/</span><span class="string">&#x27;string1&#x27;</span> <span class="operator">||</span> ... <span class="operator">||</span> col_nameN<span class="operator">/</span><span class="string">&#x27;stringN&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="2-2-简单算术运算和-strip"><a href="#2-2-简单算术运算和-strip" class="headerlink" title="2.2 简单算术运算和 strip"></a>2.2 简单算术运算和 strip</h2><p><code>+-*/</code> 和简单函数 <code>LTRIM(str)</code>（去左空格）、<code>RTRIM(str)</code>（去右空格）、<code>TRIM(str)</code>（去两边空格）；</p><p>常见数学函数几乎都与主流编程语言相同（<code>SIN()</code>、<code>EXP()</code>、<code>ABS()</code> 等）；</p><p>常量：<code>PI()</code>；</p><p>⚠ <strong>以上描述都没有提及别名（alias，又称导出列，derived column），其实规范来说，对于所有的格式化输出（包括以后提及的），都应该设置别名，好处如下：</strong></p><ol><li>方便客户端引用。没有别名的格式化列无法被某些客户端使用，有些操作会变得困难；</li><li>重命名包含不合法字符的原列名；</li><li>提升可读性。在原来的列名含混、意义不清晰时扩充、具体化它；</li></ol><h2 id="2-3-普通函数处理"><a href="#2-3-普通函数处理" class="headerlink" title="2.3 普通函数处理"></a>2.3 普通函数处理</h2><p>⚠ <strong>本部分内容的可移植性会受到不同 DBMS 对函数名称和定义的影响</strong>；</p><p>⚠ <strong>函数名称也不区分大小写</strong>；</p><div style="text-align: center;">表三 SQL 普通函数对比</div><table style="text-align: center;">    <tr>        <th rowspan=2>函数用法</th>        <th colspan=5>函数语法</th>    </tr>    <tr>        <th>MySQL</th>        <th>SQL Server</th>        <th>DB2</th>        <th>SQLite</th>        <th>Oracle</th>    </tr>    <tr>        <td>字符串子串</td>        <td colspan=2>SUBSTRING()</td>        <td colspan=3>SUBSTR()</td>    </tr>    <tr>        <td>数据类型转换</td>        <td colspan=2>CONVERT()</td>        <td>CAST()</td>        <td colspan=2>因类型不同</td>    </tr>    <tr>        <td>取日期</td>        <td>CURDATE()</td>        <td>GETDATE()</td>        <td>CURRENT_DATE</td>        <td>DATE()</td>        <td>SYSDATE</td>    </tr>    <tr>        <td>格式化日期</td>        <td>YEAR()等</td>        <td>DATEPART(yy, DATE)</td>        <td>同 MySQL</td>        <td>strftime(strf, DATE)</td>        <td>EXTRACT(year FROM DATE)</td>    </tr>    <tr>        <td>去空格</td>        <td colspan=5>LTRIM()、RTRIM()、TRIM()</td>    </tr>    <tr>        <td>求字符串长度</td>        <td>CHAR_LENGTH()</td>        <td>LEN()</td>        <td>STRING-LEGTH()</td>        <td colspan=2>LENGTH()</td>    </tr>    <tr>        <td>求数据所占Byte</td>        <td>LENGTH()</td>        <td>DATALENGTH()</td>        <td>同 MySQL</td>        <td>TYPEOF()对应的Byte</td>        <td>LENGTHB()</td>    </tr></table><p>tips 1. <code>SUBSTRING(str, start, end)</code>，其中 <code>end</code> 包含，且此处函数面向用户，是 <strong>1-index</strong>；</p><p><strong>tips 2. 还有些通用性比较好的函数：<code>UPPER()/LOWER()</code>（取大/小写）、<code>SOUNDEX()</code>（返回字符串的 <code>SOUNDEX</code> 值）</strong>;</p><p><strong><code>SOUNDEX()</code> 适用于英文，实质是一种将单词转化为描述发音的字母数字算法，可以找出发音近似或相同的单词，在有一些误输入的查找中有用，比如顾客名 <code>Michael</code> 误输入为 <code>Michelle</code>，但二者的 <code>SOUNDEX()</code> 相同，因此可以匹配</strong>；</p><h2 id="2-4-聚集函数"><a href="#2-4-聚集函数" class="headerlink" title="2.4 聚集函数"></a>2.4 聚集函数</h2><ul><li><p>定义：对表的<strong>某个列</strong>（某一行数据类型很可能不相同）运行的函数，仅计算返回一个值；</p></li><li><p><code>AVG()</code> 平均值函数</p><ol><li><p><strong>仅能针对单个列使用！！！</strong>如果需要多个列，请依次书写；</p><blockquote><p>仅有一种特例（实质还是一个列——导出列）：<strong>列以算术运算符连接</strong>；</p></blockquote></li><li><p><strong>忽略值为 <code>NULL</code> 的行</strong>；</p></li></ol></li><li><p><code>COUNT()</code> 计数函数</p><ol><li><code>COUNT(*)</code>：<strong>给表中的行计数，不忽略 <code>NULL</code></strong>；</li><li><code>COUNT(column)</code>：<strong>给特定列的行计数，忽略 <code>NULL</code></strong>；</li></ol></li><li><p><code>MAX()/MIN()</code> 最值函数：<strong>返回升序 / 降序排序后的第一行</strong>；</p></li><li><p><code>SUM()</code> 求和函数；</p></li><li><p>注意事项</p><ol><li><strong>允许列结合算数运算符</strong>；</li><li><strong>聚集不同值</strong>：如果对某列要按不同值进行聚集，应该在列名前指定 <code>DISTINCT</code>；</li><li><strong>使用聚集函数时强烈建议取别名</strong>；</li></ol></li></ul><h2 id="2-5-数据分组"><a href="#2-5-数据分组" class="headerlink" title="2.5 数据分组"></a>2.5 数据分组</h2><blockquote><p>主要内容：<code>SELECT</code> 的 <code>GROUP BY</code> 子句 和 <code>HAVING</code> 子句；</p></blockquote><ul><li><p>需求：在 2.4 中的聚集函数一般都是面向整个一列，或者一列的特定部分（如果使用了 <code>DISTINCT</code>、<code>WHERE</code> 约束）；但没法<strong>按照分类组来统计、聚集数据</strong>（例如按照 <code>date</code> 时间段分组求最大值），所以引入了<strong>数据分组</strong>；</p></li><li><p>创建分组：<code>SELECT &lt;col_name-X, [AgFuctions]&gt; FROM &lt;tb_name&gt; GROUP BY &lt;col_name-X&gt;;</code></p><blockquote><p>以上语句的含义指：将 <code>col_name-X</code> 先 <code>DISTINCT</code> 一下（<strong>所以上面的列名仅推荐使用 <code>col_name-X</code></strong>，即<strong>选择的列</strong>），再按 <code>col_name-X</code> 分组（内部完成），<strong>这时通配符 <code>*</code> 指代的对象会变成：<u>当前选择列中</u> 各自分好的组（意味着 <code>col_name-X</code> 只能有一个，否则不能使用通配符 <code>*</code>）</strong>！</p><p>ℹ 你可以使用聚集函数的 <code>*</code> 来试一试上面的理论；</p></blockquote></li><li><p>分组的性质</p><ol><li><p>数据列中 <code>NULL</code> 会被分为一组；</p></li><li><p><strong><code>GROUP BY</code> 子句必须在 <code>WHERE</code> 子句后，在 <code>ORDER BY</code> 子句之后</strong>；</p><blockquote><p><code>GROUP BY</code> 必须在 <code>WHERE</code> 之后的原因：</p><p><strong><code>GROUP BY</code> 产生内部分组，而 <code>WHERE</code> 只能对所有行筛选，<u>完全没有分组的概念</u></strong>，所以 <code>WHERE</code> 不能筛选分组（否则造成意想不到的结果）！</p><p>应该使用可以筛选分组的子句：<code>HAVING</code>（这个子句除了<strong>多了一个“可以筛选分组”的功能</strong>，其他使用与 <code>WHERE</code> 几乎一致、可以替代；但标准来说只有 <code>GROUP BY</code> + 需要筛选时才用到 <code>HAVING</code>）</p></blockquote></li><li><p><code>GROUP BY</code>  子句允许嵌套分组；</p></li></ol></li><li><p>过滤分组：<code>SELECT &lt;col_name-X [AgFunctions]&gt; FROM &lt;tb_name&gt; GROUP BY &lt;col_name-X&gt; HAVING &lt;cond&gt;;</code></p></li><li><p>排序分组：<code>SELECT &lt;col_name-X [AgFunctions]&gt; FROM &lt;tb_name&gt; GROUP BY &lt;col_name-X&gt; ORDER BY &lt;col_name-X&gt;;</code></p><p>⚠ 虽然你可能发现 <code>GROUP BY</code> 本身就可以按分组后的结果排序，但这个行为不在 SQL 规范中，<strong>所以如果有需要对分组进行排序，仍需要 <code>ORDER BY</code> 子句</strong>，不能仅仅依赖 <code>GROUP BY</code>；</p></li></ul><h2 id="2-6-本章习题"><a href="#2-6-本章习题" class="headerlink" title="2.6 本章习题"></a>2.6 本章习题</h2><ol><li><p>从 <code>Vendors</code> 表中检索 <code>vend_id</code>、<code>vend_name</code>、<code>vend_address</code> 和 <code>vend_city</code>，将 <code>vend_name</code> 重命名为 <code>vname</code>，将 <code>vend_city</code> 重命名为 <code>vcity</code>，将 <code>vend_address</code> 重命名为 <code>vaddress</code>。再按供应商名称对结果进行排序。注意所有的字符串变量的存储都有定长、记录前可能有空格：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,</span><br><span class="line">    <span class="built_in">TRIM</span>(vend_name) <span class="keyword">AS</span> vname,</span><br><span class="line">    <span class="built_in">TRIM</span>(vend_city) <span class="keyword">AS</span> vcity,</span><br><span class="line">    <span class="built_in">TRIM</span>(vend_address) <span class="keyword">AS</span> vaddress</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vname;</span><br></pre></td></tr></table></figure></li><li><p>商店正在进行打折促销，所有产品均降价 10%. 编写 SQL 语句，从 <code>Products</code> 表中返回 <code>prod_id</code>、<code>prod_price</code> 和 <code>sale_price</code>，其中<code>sale_price</code> 是一个包含促销价格的计算字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price,</span><br><span class="line">    prod_price<span class="operator">*</span><span class="number">0.9</span> <span class="keyword">AS</span> sale_price</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure></li><li><p>假设商店已经上线了，正在创建顾客账户。所有用户都需要登录名，默认登录名是其名称和所在城市的组合。在表 <code>Customers</code> 中编写 SQL 语句，返回顾客 ID（<code>cust_id</code>）、顾客名称（<code>cust_name</code>）和登录名（<code>user_login</code>），其中登录名全部为大写字母，并由顾客联系人的前两个字符（<code>cust_contact</code>）和其所在城市的前三个字符（<code>cust_city</code>）组成。例如，我的登录名是 <code>BEOAK</code>（<code>Ben Forta</code>，居住在 <code>Oak Park</code>）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name,</span><br><span class="line">    <span class="built_in">UPPER</span>(</span><br><span class="line">        CONCAT(</span><br><span class="line">            <span class="built_in">SUBSTRING</span>(cust_contact, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            <span class="built_in">SUBSTRING</span>(cust_city, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        )</span><br><span class="line">    ) <span class="keyword">AS</span> user_login</span><br><span class="line"><span class="keyword">FROM</span> Customers;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，返回 2020 年 1 月的所有订单（<code>Orders</code> 表）的订单号（<code>order_num</code>）和订单日期（<code>order_date</code>），并按订单日期排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, order_date</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> date_format(order_date, <span class="string">&#x27;%Y-%m&#x27;</span>) <span class="operator">=</span> <span class="string">&#x27;2020-01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，找出 <code>Products</code> 表中的 <code>num_items</code> 项的总个数（不包括 <code>NULL</code>）、值不同的个数、最小、最大、平均值，列在一个表格中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(num_items) <span class="keyword">AS</span> total_cnt,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> num_items) <span class="keyword">AS</span> dist_cnt,</span><br><span class="line">    <span class="built_in">MIN</span>(num_items) <span class="keyword">AS</span> min_items,</span><br><span class="line">    <span class="built_in">MAX</span>(num_items) <span class="keyword">AS</span> max_items,</span><br><span class="line">    <span class="built_in">AVG</span>(num_items) <span class="keyword">AS</span> avg_items</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure></li><li><p>计算 <code>OrderItems</code> 表中各行所要花费的金钱总和（物品数量 <code>quantity</code> * 物品价格 <code>item_price</code> 再求和）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(quantity <span class="operator">*</span> item_price) <span class="keyword">AS</span> total_cost <span class="keyword">FROM</span> OrderItems;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，确定 <code>Products</code> 表中价格不超过 10 美元的最贵产品的价格（<code>prod_price</code>）。将计算所得的字段命名为 <code>max_price</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(prod_price) <span class="keyword">AS</span> max_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，要求统计 <code>Products</code> 表的供应商 ID <code>vend_id</code> 各自提供的商品个数（即每个供应商在 <code>Product</code> 中含有的数据行数），按 “ID、个数（列名 <code>num_prods</code>）” 顺序输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，要求找出 <code>Orders</code> 表中订单数不少于 2 的顾客 ID（<code>cust_id</code>），即每个 <code>cust_id</code> 在表中含有的数据行数，按 “ID、订单数” 顺序输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_orders</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，要求找出 <code>Products</code> 表中 “提供 2 个及以上的、价格（<code>prod_price</code>）不少于4 的产品” 的供应商，按 “供应商ID（<code>vend_id</code>）、满足条件的产品数（列名 <code>num_prods</code>）” 顺序输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span> <span class="number">4</span>    <span class="comment">-- 注意：在这里非分组筛选需要在分组前进行</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>OrderItems</code> 表包含每个订单的每个产品。编写SQL 语句，返回每个订单号（<code>order_num</code>）各有多少行数（<code>order_lines</code>），并按 <code>order_lines</code> 对结果进行升序排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> order_lines</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_lines;</span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 语句，返回名为 <code>cheapest_item</code> 的字段，该字段包含每个供应商（<code>vend_id</code>）成本最低的产品（使用 <code>Products</code> 表中的 <code>prod_price</code>），然后从最低成本到最高成本对结果进行排序（按 “供应商 ID、<code>cheapest_item</code>” 输出）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注意：此处 prod_price 已不再是整个列，而是各分组的 prod_price，对它用聚集函数会得到各列的结果</span><br><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">MIN</span>(prod_price) <span class="keyword">AS</span> cheapest_item</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cheapeset_item;</span><br></pre></td></tr></table></figure></li><li><p>商店经营中，确定最佳顾客非常重要。有一个店主想出 2 种方法来确定他的最佳顾客：</p><p>Ⅰ. 找出满足 “所有订购产品的数量不少于 100” 的订单，至少持有一个这样订单的顾客是 “最佳顾客”；（注：在 <code>OrderItems</code> 表中特定的订单号 <code>order_num</code>、本订单订购商品名 <code>order_item</code>下的商品数量 <code>quantity</code>，是 “这个订单中 这个产品的数量”）</p><blockquote><p>所以请编写 SQL 语句，只需找出满足上述条件的这个订单，输出订单号即可；</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(quantity) <span class="operator">&gt;=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>Ⅱ. 找出满足 “总价（包含不同的商品）至少为 1000” 的订单，至少持有一个这样订单的顾客是 “最佳顾客”；（注：对于一个订单中的一个商品而言，需要在 <code>OrderItems</code> 表中计算 <code>item_price * quantity</code> 来获得订单中一类商品的总价格）</p><blockquote><p>所以请编写 SQL 语句，找出满足上述条件的订单，以降序输出订单号（<code>order_num</code>），按 “订单号、总价（列名 <code>total_price</code>）” 输出；</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">SUM</span>(item_price <span class="operator">*</span> quantity) <span class="keyword">AS</span> total_price</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> total_price <span class="operator">&gt;=</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_num <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>在不运行下列语句的前提下，指出下列语句的错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> items</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> items</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> items, order_num;</span><br></pre></td></tr></table></figure><p><strong>Answer：<code>GROUP BY</code> 语句不能对聚合函数分组！</strong>从分组聚合的含义上来说，<code>COUNT(*)</code> 是对分组后的组进行计数，这样是循环指代，从逻辑上行不通；</p><p><strong>改正方案：将 <code>GROUP BY items</code> 分组依据改成 <code>GROUP BY order_num</code> 就正确了，如下：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> items</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> items, order_num;</span><br></pre></td></tr></table></figure><p><strong>这段语句的含义是：找出所有满足 “包含不少于 3 种商品” 的订单，并按 “订单所含商品种类数、订单号” 输出（最后按种类数，再按订单号升序排序）；</strong></p></li></ol><h1 id="EX-1-第一部分语法总结"><a href="#EX-1-第一部分语法总结" class="headerlink" title="EX-1 第一部分语法总结"></a>EX-1 第一部分语法总结</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>col_name1[, ...]<span class="operator">&gt;</span> [<span class="keyword">AS</span> new_name]</span><br><span class="line">[<span class="keyword">FROM</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>cond<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>col_name1<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">HAVING</span> <span class="operator">&lt;</span>cond<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>col_name<span class="operator">-</span>N<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> SQL </tag>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab 复习</title>
      <link href="//technical/matlab-review/"/>
      <url>//technical/matlab-review/</url>
      
        <content type="html"><![CDATA[<p><i>Written by SJTU_XHW</i></p><p><i>Version: Matlab R2020b</i></p><p><i>References:</i> <a href="https://www.mathworks.com/help/matlab/">MATLAB Documentation (mathworks.com)</a></p><hr><span id="more"></span><h3 id="Chapter0-Matlab-is-a-1-index-language"><a href="#Chapter0-Matlab-is-a-1-index-language" class="headerlink" title="Chapter0 Matlab is a 1-index language"></a>Chapter0 Matlab is a 1-index language</h3><h3 id="Chapter1-Basic-Operations"><a href="#Chapter1-Basic-Operations" class="headerlink" title="Chapter1 Basic Operations"></a>Chapter1 Basic Operations</h3><h4 id="1-1-operators-numerical-；logical-amp-amp-gt-lt-（按位运算须函数）-；"><a href="#1-1-operators-numerical-；logical-amp-amp-gt-lt-（按位运算须函数）-；" class="headerlink" title="1.1 operators: numerical { +-*/^() } ；logical { ~ || &amp;&amp; &gt; &lt; ==（按位运算须函数） }；"></a>1.1 operators: numerical { +-*/^() } ；logical { ~ || &amp;&amp; &gt; &lt; ==（按位运算须函数） }；</h4><h4 id="1-2-variables-do-not-need-to-be-declaed-before-assignment-类似Python"><a href="#1-2-variables-do-not-need-to-be-declaed-before-assignment-类似Python" class="headerlink" title="1.2 variables: do not need to be declaed before assignment (类似Python)"></a>1.2 variables: do not need to be declaed before assignment (类似Python)</h4><h4 id="1-3-numeric-variable-type：logical、char、numeric、cell、struct、scalar"><a href="#1-3-numeric-variable-type：logical、char、numeric、cell、struct、scalar" class="headerlink" title="1.3 numeric variable type：logical、char、numeric、cell、struct、scalar"></a>1.3 numeric variable type：logical、char、numeric、cell、struct、scalar</h4><h4 id="1-4-constants：ans，i-j，Inf，eps（2-2204e-016），NaN，pi"><a href="#1-4-constants：ans，i-j，Inf，eps（2-2204e-016），NaN，pi" class="headerlink" title="1.4 constants：ans，i/j，Inf，eps（2.2204e-016），NaN，pi"></a>1.4 constants：ans，i/j，Inf，eps（2.2204e-016），NaN，pi</h4><h4 id="1-5-keywords：iskeyword"><a href="#1-5-keywords：iskeyword" class="headerlink" title="1.5 keywords：iskeyword"></a>1.5 keywords：<code>iskeyword</code></h4><h4 id="1-6-calling-priority"><a href="#1-6-calling-priority" class="headerlink" title="1.6 calling priority"></a>1.6 calling priority</h4><blockquote><p>local variable $\gt$ built-in fuction $\gt$ subfunction $\gt$ private fuction(self defined: <em>.mex, </em>.p, *.m)</p></blockquote><h4 id="1-7-numeric-display-“format”"><a href="#1-7-numeric-display-“format”" class="headerlink" title="1.7 numeric display “format”"></a>1.7 numeric display “format”</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format [options]</span><br></pre></td></tr></table></figure><p>short（3.1416）、long（3.1415…）、shortE（3.1416e+00）、longE（3.1415…e+00）、bank（3.14）、hex  、rat（ratio of small integers）</p><h4 id="1-8-command-line-terminal"><a href="#1-8-command-line-terminal" class="headerlink" title="1.8 command line terminal"></a>1.8 command line terminal</h4><ol><li><p>“;” at the end of a command suppresses output to the terminal.</p></li><li><p>“↑” display previous commands.</p></li><li><p><strong>Common commands</strong>：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clc; <span class="comment">% clear command window display</span></span><br><span class="line">clear; <span class="comment">% remove all variables int the workspace</span></span><br><span class="line">who <span class="comment">% variables in the workspace</span></span><br><span class="line">whos <span class="comment">% variable information of the workspace </span></span><br><span class="line">     <span class="comment">% 作用类似于Python中的语句“\”，起到过长文字换行作用</span></span><br><span class="line"><span class="keyword">end</span>; <span class="comment">%    指代当前上下文中数组最后一行/列的索引</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Chapter2-Array-Operations"><a href="#Chapter2-Array-Operations" class="headerlink" title="Chapter2 Array Operations"></a>Chapter2 Array Operations</h3><h4 id="2-1-Array-Definition"><a href="#2-1-Array-Definition" class="headerlink" title="2.1 Array Definition"></a>2.1 Array Definition</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]; <span class="comment">% row vector（“，”can be omitted）</span></span><br><span class="line">b = [<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>]; <span class="comment">% column vector</span></span><br><span class="line">c = [<span class="number">1</span>, <span class="number">21</span>, <span class="number">6</span>;</span><br><span class="line">    <span class="number">5</span>, <span class="number">17</span>, <span class="number">9</span>;</span><br><span class="line">    <span class="number">31</span>, <span class="number">2</span>, <span class="number">7</span>]; <span class="comment">% matrix</span></span><br></pre></td></tr></table></figure><h4 id="2-2-Array-Indexing"><a href="#2-2-Array-Indexing" class="headerlink" title="2.2 Array Indexing"></a>2.2 Array Indexing</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">21</span>, <span class="number">6</span>;</span><br><span class="line">    <span class="number">5</span>, <span class="number">17</span>, <span class="number">9</span>;</span><br><span class="line">    <span class="number">31</span>, <span class="number">2</span>, <span class="number">7</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">% 单参数索引都是“线性索引”-----------</span></span><br><span class="line">A(<span class="number">8</span>) <span class="comment">% 按列来数，第8个元素，这里称它为“线性索引”</span></span><br><span class="line">A([<span class="number">1</span> <span class="number">3</span> <span class="number">5</span>]) <span class="comment">% 以一维向量（数组）作为索引，则每个元素代表一个“线性索引”，构成同形状的数组</span></span><br><span class="line">A([<span class="number">1</span> <span class="number">3</span>; <span class="number">1</span> <span class="number">3</span>]) <span class="comment">% 以矩阵作为索引，每个元素代表一个“线性索引”，构成同一形状的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 双/多参数索引是普通的行（前）-列（后）索引------------</span></span><br><span class="line">A(<span class="number">3</span>, <span class="number">2</span>) <span class="comment">% 第3行，第2列元素</span></span><br><span class="line">A([<span class="number">1</span> <span class="number">3</span>], [<span class="number">2</span> <span class="number">4</span>]) <span class="comment">% 第1、3行，第2、4列元素构成子式对应的矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Colon Operator（省略号操作符）-------------</span></span><br><span class="line"><span class="built_in">j</span>:k <span class="comment">% is equivalent to [j, j+1, j+2, ..., j+m]（j+m ≤ k）</span></span><br><span class="line"><span class="built_in">j</span>:<span class="built_in">i</span>:k <span class="comment">% is equivalent to [j, j+i, j+2i, ..., j+m*i]（j+m*i ≤ k）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Examples:</span></span><br><span class="line">B = <span class="number">1</span>:<span class="number">5</span>;</span><br><span class="line">B = <span class="number">1</span>:<span class="number">2</span>:<span class="number">5</span>;</span><br><span class="line">B = [<span class="number">1</span>:<span class="number">5</span>; <span class="number">2</span>:<span class="number">3</span>:<span class="number">15</span>; <span class="number">-2</span>:<span class="number">0.5</span>:<span class="number">0</span>];</span><br><span class="line">str = <span class="string">&#x27;a&#x27;</span>:<span class="number">2</span>:<span class="string">&#x27;z&#x27;</span>;  <span class="comment">% 字符数组</span></span><br><span class="line"><span class="comment">% 与C++、Python都不同，可以直接这样切片数组赋值</span></span><br><span class="line">A(<span class="number">3</span>, :) = [] <span class="comment">% 索引参数由“：”替代时，表示全选该参数位</span></span><br></pre></td></tr></table></figure><h4 id="2-4-Array-Concatenation"><a href="#2-4-Array-Concatenation" class="headerlink" title="2.4 Array Concatenation"></a>2.4 Array Concatenation</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">2</span> <span class="number">1</span>;</span><br><span class="line">    <span class="number">3</span> <span class="number">2</span>;</span><br><span class="line">    <span class="number">-2</span> <span class="number">2</span>];</span><br><span class="line">B = [<span class="number">1</span> <span class="number">1</span>;</span><br><span class="line">    <span class="number">3</span> <span class="number">4</span>;</span><br><span class="line">    <span class="number">2</span> <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">C = [A, B]; <span class="comment">% 行拼接</span></span><br><span class="line">D = [A; B]; <span class="comment">% 列拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cat函数拼接</span></span><br><span class="line">E = <span class="built_in">cat</span>(dim_direction, A, B);</span><br><span class="line"><span class="comment">% 1=列方向，2=行方向，&gt;2 抽象</span></span><br></pre></td></tr></table></figure><h4 id="2-5-Array-Manipulation"><a href="#2-5-Array-Manipulation" class="headerlink" title="2.5 Array Manipulation"></a>2.5 Array Manipulation</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A [+-*/] const  <span class="comment">% 数组[?]常数--&gt;数组每一个元素都[?]该常数</span></span><br><span class="line">A ^ const  <span class="comment">% 矩阵的const次幂</span></span><br><span class="line">A .^ const  <span class="comment">% 矩阵每个元素分别作const次幂（&quot;.&quot;表示对每个元素操作）</span></span><br><span class="line">A’  <span class="comment">% 矩阵的转置</span></span><br><span class="line">A [+-] B  <span class="comment">% 同型数组之和/差</span></span><br><span class="line">A * B   <span class="comment">% 矩阵乘法</span></span><br><span class="line">A .* B   <span class="comment">% 数组对应元素相乘</span></span><br><span class="line">A / B    <span class="comment">% 与A * inv(B)相同，但内部实现更优</span></span><br><span class="line">A ./ B   <span class="comment">% 数组对应元素相除</span></span><br><span class="line">A \ B    <span class="comment">% inv(A) * B，但内部实现更优。注意和B / A不同！！！</span></span><br><span class="line">A .\ B   <span class="comment">% 对应元素反除，这里相当于 B ./ A</span></span><br></pre></td></tr></table></figure><h4 id="2-6-Special-Matrices"><a href="#2-6-Special-Matrices" class="headerlink" title="2.6 Special Matrices"></a>2.6 Special Matrices</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eye</span>(n);  <span class="comment">% n阶单位矩阵</span></span><br><span class="line"><span class="built_in">zeros</span>(n1, n2);    <span class="comment">% n1×n2 零阵</span></span><br><span class="line"><span class="built_in">ones</span>(n1, n2);    <span class="comment">% n1×n2 1阵</span></span><br><span class="line"><span class="built_in">diag</span>(v, offset=<span class="number">0</span>);    <span class="comment">% 主对角元组成向量v的矩阵，offset＞0，向主对角线上方偏移，反之向下</span></span><br><span class="line"><span class="built_in">diag</span>(A, offset=<span class="number">0</span>);    <span class="comment">% 以上过程的逆过程</span></span><br></pre></td></tr></table></figure><h4 id="2-7-Basic-Functions-of-Matrix"><a href="#2-7-Basic-Functions-of-Matrix" class="headerlink" title="2.7 Basic Functions of Matrix"></a>2.7 Basic Functions of Matrix</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A);    <span class="comment">% 向量最大值、矩阵每一列的最大值行向量、多维数组沿第一个数组维度不为1的维度计算，将元素视为向量（这样此维度大小变为1，其他维度不变）。如果第一个数组维度=0，则返回与原数组大小相同的空数组。</span></span><br><span class="line"><span class="built_in">max</span>(A, [], dim);    <span class="comment">% 规定以哪个维度作为“第一维度”的max，1=行，2=列，＞2时抽象</span></span><br><span class="line"><span class="built_in">min</span>(A, [], dim=<span class="number">1</span>);    <span class="comment">% 同理</span></span><br><span class="line">sum(A, dim=<span class="number">1</span>);    <span class="comment">% 处理规则类似max，返回沿不等于1的第一个数组维度的元素之和</span></span><br><span class="line"><span class="built_in">mean</span>(A, dim=<span class="number">1</span>);    <span class="comment">% 处理规则类似max，返回沿不等于1的第一个数组维度的元素的均值</span></span><br><span class="line"><span class="built_in">mean</span>(A, <span class="string">&#x27;all&#x27;</span>);    <span class="comment">% 返回A中所有元素均值</span></span><br><span class="line"><span class="built_in">sort</span>(A, dim=<span class="number">1</span>);    <span class="comment">% 处理规则类似max。向量：对元素排序；矩阵，排序列向量（dim=1）；多维数组：沿不等于1的第一个数组维度计算，将元素视为向量，进行向量排序</span></span><br><span class="line"><span class="built_in">sortrows</span>(A, col=<span class="number">1</span>);    <span class="comment">% 以第一列作为排序依据，若相同，则看第二优先度的列（本质：对行向量排序）</span></span><br><span class="line"><span class="built_in">size</span>(A);    <span class="comment">% 类似Python.numpy的ndarray.shape，这里返回行向量：[dim1, dim2, ...]</span></span><br><span class="line"><span class="comment">% 可以写：[dim1, dim2, ...] = size(A);</span></span><br><span class="line"><span class="built_in">size</span>(A, dim);    <span class="comment">% 指定维度的size</span></span><br><span class="line"><span class="built_in">length</span>(A);    <span class="comment">% 数组最大维度的长度</span></span><br><span class="line"><span class="built_in">find</span>(X);    <span class="comment">% 返回数组（logical数组为多，结合逻辑运算式）中每个非零元素的索引向量（X为向量：返回方向相同的向量；X为矩阵/多维数组：返回“线性索引”组成的列向量）</span></span><br><span class="line"><span class="comment">% find 可选参数：n：前/后n个索引；direction：‘first’/‘last’</span></span><br></pre></td></tr></table></figure><h3 id="Chapter3-Structured-Programming"><a href="#Chapter3-Structured-Programming" class="headerlink" title="Chapter3 Structured Programming"></a>Chapter3 Structured Programming</h3><h4 id="3-1-Flow-Control"><a href="#3-1-Flow-Control" class="headerlink" title="3.1 Flow Control"></a>3.1 Flow Control</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% if - elseif - else</span></span><br><span class="line"><span class="comment">% switch - case - otherwise</span></span><br><span class="line"><span class="comment">% for</span></span><br><span class="line"><span class="comment">% while</span></span><br><span class="line"><span class="comment">% try - catch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 条件表达式：不需要括号、不需要冒号、不需要大括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% end：以上结构的结束都需要此关键字</span></span><br><span class="line"><span class="comment">% pause：暂停脚本执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% break</span></span><br><span class="line"><span class="comment">% continue</span></span><br></pre></td></tr></table></figure><h4 id="3-2-Programming-Tip-Pre-allocating-Space-to-Variables"><a href="#3-2-Programming-Tip-Pre-allocating-Space-to-Variables" class="headerlink" title="3.2 Programming Tip: Pre-allocating Space to Variables"></a>3.2 Programming Tip: Pre-allocating Space to Variables</h4><blockquote><p>Tips. 提前为变量（尤其是大规模数组）分配内存空间非常必要。Matlab的数组和C++的STL容器类似，使用时会插入元素。当元素数量较多时，频繁分配空间会降低运行效率，所以提前分配好空间（已知大小/大致范围）再更改值会更好。</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tic                                <span class="comment">% 程序改进：</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">2000</span>                    <span class="comment">% A = zeros(2000, 2000);</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">2000</span><span class="comment">% for i=1:size(A, 1)</span></span><br><span class="line">        A(<span class="built_in">i</span>, <span class="built_in">j</span>) = <span class="built_in">i</span> + <span class="built_in">j</span>;<span class="comment">%     for j=1:size(A, 2)</span></span><br><span class="line">    <span class="keyword">end</span><span class="comment">%         A(i, j) = i + j;</span></span><br><span class="line"><span class="keyword">end</span>                                <span class="comment">%     end</span></span><br><span class="line">toc                                <span class="comment">% end</span></span><br></pre></td></tr></table></figure><h4 id="3-3-Good-Habits-for-Script-Writing"><a href="#3-3-Good-Habits-for-Script-Writing" class="headerlink" title="3.3 Good Habits for Script Writing"></a>3.3 Good Habits for Script Writing</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% At the beginning</span></span><br><span class="line">clear all;    <span class="comment">% 1. Remove previous variables</span></span><br><span class="line">close all;    <span class="comment">% 2. Close all figures</span></span><br><span class="line"><span class="comment">% 3. Use semicolon &quot;;&quot; at the end of commands to inhibit unwanted outputs</span></span><br><span class="line"><span class="comment">% 4. Use ellipsis &quot;...&quot; to make scripts more readable:</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">4</span> <span class="number">1</span>; ...</span><br><span class="line">     <span class="number">6</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line"><span class="comment">% 5. Use &quot;Ctrl + C&quot; to terminate the script before conclusion</span></span><br></pre></td></tr></table></figure><h4 id="3-4-Matlab-Functions"><a href="#3-4-Matlab-Functions" class="headerlink" title="3.4 Matlab Functions"></a>3.4 Matlab Functions</h4><ul><li><p>方程作为一个单独脚本（*.m）存在，并且文件名必须与方程名相同；</p></li><li><p>方程文件存放位置必须位于“预设位置”/当前文件夹位置，供程序寻找；</p></li><li><p>查看内置函数方法：<code>edit(which(&#39;函数名.m&#39;))</code></p></li><li><p>方程书写规范（以mean.m为例）：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 文件名：mean.m</span></span><br><span class="line"><span class="comment">% 关键字 output(s)=FunctionName(Input(s))</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">mean</span><span class="params">(x)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 多参数书写方式：e.g., [a F] = acc(v2, v1, t2, t1, m)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%MEAN Average or mean value.  这里写“Online Help”，即帮助文档</span></span><br><span class="line"><span class="comment">%    S = MEAN(X) is the mean value of the elements in X. 描述清调用方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% MATLAB CODES（函数实现方法）</span></span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line"><span class="keyword">if</span> nargin==<span class="number">2</span> &amp;&amp; ischar(dim)</span><br><span class="line">    flag = dim;</span><br><span class="line"><span class="keyword">elseif</span> nargin &lt; <span class="number">3</span></span><br><span class="line">    flag = <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% ...</span></span><br></pre></td></tr></table></figure></li><li><p>方程内部预设变量</p><ul><li><p><code>inputname</code>：Variable name of function input</p></li><li><p><code>mfilename</code>： File name of currently runing function</p></li><li><p><code>nargin</code>：Number of the function input arguments（Linux shell：$#）</p></li><li><p><code>nargout</code>：Number of the function output arguments</p></li><li><p><code>varargin</code>：Variable length input argument list（Python：args，此处是1×n的cell）</p><p>e.g., <code>function y = f(x, t, varargin)</code></p></li><li><p><code>varargout</code>：Variable length output argument list</p></li></ul></li><li><p>特殊函数：Function handles（类似Python、C++的匿名函数）</p><ul><li>Definition：<code>f = @(x) exp(-2*x)</code></li><li>Domain：this file <strong><u>ONLY</u></strong></li><li>Usage（example）：<code>x = 0:0.1:2; plot(x, f(x));</code></li><li>Tips：”@”用在函数前变为函数指针，可以作为函数参数；</li></ul></li><li><p>常见内置函数</p><ul><li><p><code>x = input(prompt)</code>：输入变量函数；</p></li><li><p><code>mod(x, y)</code>：等价于 x % y；</p></li><li><p><code>num2str(A, [int precision])</code>：将数值数组转为数字的字符数组（尤其在使用数值为绘图添加标签和标题时有用）；</p><p><strong><u>以下为针对numeric数组的函数</u></strong></p></li><li><p><code>reshape(A, row, col)</code>：将A数组的形状改为row行col列（注：item num  = row*col）；</p></li><li><p><code>linspace(x1, x2, [n])</code>：生成x1~x2间等间距100个点，加上n参数就是n个点；</p></li><li><p><code>logspace(x1, x2, [n])</code>：生成$10^{x_{1}}$~$10^{x_{2}}$呈以10对数关系间距的50个点；<strong>注意：由于信号系统的方便性，惯例约定当$x_{2}=\pi$时，生成的是$10^{x_{1}}$~$\pi$的对数点</strong>；</p></li><li><p><code>[X, Y] = meshgrid(xVector, yVector)</code>：生成xVector和yVector交叉点网格矩阵（常用于绘制面图）；</p></li><li><p><strong><u>注：以下谓词函数缺省参数</u></strong></p></li><li><p><code>isempty(A)</code>：判空函数（是否为空，即至少一个维度为0的数组）</p></li><li><p><code>isinteger</code></p></li><li><p><code>islogical</code></p></li><li><p><code>isnan</code></p></li><li><p><code>isinf</code></p></li><li><p><code>isnumeric</code></p></li><li><p><code>isprime</code></p></li><li><p><code>isreal</code></p></li><li><p><code>ischar</code></p></li><li><p><code>isequal</code>：numerically</p></li><li><p><code>isglobal</code></p></li></ul></li></ul><h3 id="Chapter4-Data-Structure-amp-File-Access"><a href="#Chapter4-Data-Structure-amp-File-Access" class="headerlink" title="Chapter4 Data Structure &amp; File Access"></a>Chapter4 Data Structure &amp; File Access</h3><h4 id="4-1-Data-Types"><a href="#4-1-Data-Types" class="headerlink" title="4.1 Data Types"></a>4.1 Data Types</h4><ul><li>可作为1~多维数组元素的数据类型（括号内为C++对应类型）：logical，char，cell，struct，numeric：{ int8、unit8、int16（short）、uint16（unsigned short）、int32（int）、uint32（unsigned）、int64（long long）、uint64（unsigned long long）|   single、double }</li><li>作为标量的数据类型：function handle</li></ul><h4 id="4-2-Numeric"><a href="#4-2-Numeric" class="headerlink" title="4.2 Numeric"></a>4.2 Numeric</h4><ul><li>Numeric内部类型间的转换函数均为：类型名()</li></ul><h4 id="4-3-Char-amp-String"><a href="#4-3-Char-amp-String" class="headerlink" title="4.3 Char &amp; String"></a>4.3 Char &amp; String</h4><ul><li>char：和C++相同，底部以数字表示，可以简单认为是ASCII对应数据（uint16），实际上支持中文</li><li>string：与普通numeric数组相同，参与逻辑计算方式相同，同一维度可直接拼接。<ul><li>定义方式有差异：<code>s = &#39;Example&#39;;</code><strong><u>请注意：使用单引号是char数组，双引号是string对象！！！</u></strong></li><li>逻辑运算方式：char数组与char/char数组运算（返回与最长数组同型的logical数组）</li><li>重要拓展：<code>str(str == &#39;a&#39;) = &#39;Z&#39;;</code>表示将所有含’a’的位置全换为’Z’（仅限str为char数组）</li></ul></li><li>相互转换函数<ul><li><code>string(char_arr)</code>：字符数组转string</li><li><code>convertStringsToChars(string/string_arr)</code>：字符串（数组）转字符数组（字符数组元胞）</li></ul></li></ul><h4 id="4-4-Structure"><a href="#4-4-Structure" class="headerlink" title="4.4 Structure"></a>4.4 Structure</h4><ul><li><p>定义、赋值：和C++不同，无需提前声明结构体的字段（fields）和数据类型，直接赋值即可</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 以student结构体为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第一次使用该结构体对象时，对象名即为结构体名</span></span><br><span class="line"><span class="comment">% 第一次定义字段时，在结构体中创建该字段</span></span><br><span class="line">student.name =  <span class="string">&#x27;Alex&#x27;</span>;</span><br><span class="line">student.id = <span class="string">&#x27;12345&#x27;</span>;</span><br><span class="line">student.grade = [<span class="number">100</span>, <span class="number">95</span>, <span class="number">93</span>; ...</span><br><span class="line">                 <span class="number">95</span>, <span class="number">100</span>, <span class="number">91</span>];</span><br><span class="line"><span class="comment">% 目前student既为第一个该类型结构体对象，也为该结构体类型名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第N（N＞1）次应用结构体类型创建新对象时，使用student(N)</span></span><br><span class="line">student(<span class="number">2</span>).name = <span class="string">&#x27;Cindy&#x27;</span>;</span><br><span class="line">student(<span class="number">2</span>).id = <span class="string">&#x27;23456&#x27;</span>;</span><br><span class="line">student(<span class="number">2</span>).grade = []; <span class="comment">% 略</span></span><br></pre></td></tr></table></figure></li><li><p>内置函数（部分见“cell类型的内置函数”）</p><ul><li><code>fieldnames(struct)</code>：返回n×1的cell数组，每列cell储存一个字段名（char数组）</li><li><code>isfield(struct, fieldname)</code>：检查fieldname字符数组是否为一个struct的字段名</li><li><code>isstruct(struct)</code>：struct、是否为一个结构体</li><li><code>rmfield(struct, fieldname)</code>：删除struct的fieldname字段</li><li><code>orderfields(struct)</code>：将struct的字段按ASCII字典序排序，返回新结构体</li><li><code>structfun(function_handle, scalar_struct)</code>：将函数作用于标量结构体的每个字段</li></ul></li></ul><h4 id="4-5-Cell"><a href="#4-5-Cell" class="headerlink" title="4.5 Cell"></a>4.5 Cell</h4><ul><li><p>定义方式（共3种，前两种也是赋值方式）：普通索引引用、元胞引用、直接书写</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 普通索引（说明m×n的cell实际由1×1的cell组合而成）</span></span><br><span class="line">A(<span class="number">1</span>, <span class="number">1</span>) = &#123;[<span class="number">1</span> <span class="number">4</span> <span class="number">3</span>; <span class="number">3</span> <span class="number">4</span> <span class="number">2</span>]&#125;;</span><br><span class="line">A(<span class="number">1</span>, <span class="number">2</span>) = &#123;<span class="string">&#x27;Anne Smith&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 元胞引用</span></span><br><span class="line">A&#123;<span class="number">1</span>, <span class="number">1</span>&#125; = [<span class="number">1</span> <span class="number">4</span> <span class="number">3</span>; <span class="number">3</span> <span class="number">4</span> <span class="number">2</span>];</span><br><span class="line">A&#123;<span class="number">1</span>, <span class="number">2</span>&#125; = <span class="string">&#x27;Anne Smith&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 直接书写</span></span><br><span class="line">A = &#123;<span class="string">&#x27;Anne Smith&#x27;</span>, [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]&#125;;</span><br></pre></td></tr></table></figure></li><li><p>容器的内部机理：实际上每个entry都有指向数据空间的指针，这样使得不同大小数据能存于同一个cell中</p></li><li><p>内置函数</p><ul><li><code>cell2mat(cell)</code>：将cell转为numeric数组，拼接方式按所处在cell中位置为准。<strong><u>注意：cell的entries必须全是numeric标量/“对应位置同型”numeric数组</u></strong></li><li><code>num2cell(A)</code>：将数组每个元素都作为一个元胞，转换为cell</li><li><code>mat2cell(A, dim1List, dim2List, ...)</code>：将mat按每个维度上“元素数量划分列表“转换为cell</li><li><code>cell2struct(cell, fields, dim)</code>：将cell转为结构体。</li><li><code>struct2cell(struct)</code>：…</li><li><code>cellplot(cell)</code>：用figure显示cell的抽象关系</li><li><code>iscell(cell)</code>：是否为cell类型</li></ul></li></ul><h4 id="4-6-Table"><a href="#4-6-Table" class="headerlink" title="4.6 Table"></a>4.6 Table</h4><ul><li>地位：精简行为的结构体，可以和*.csv、数据库等关联，数据处理中比结构体常用</li><li>定义：table构造函数<ul><li><code>tb = table(record1_arr, record2_arr, ...recordN_arr, &#39;VariableNames&#39;, name_cell)</code></li><li>其中，recond1~N_arr都应该是n×1的数组/cell，而name_cell应该是1×N的cell（表的直观印象）</li><li>不指定name_cell时，会按照变量名来记录</li></ul></li><li>类型转换函数<ul><li><code>array2table(array, &#39;VariableNames&#39;, name_cell);</code>  其中array支持符合形状的cell、数组等</li><li><code>table2cell(table)</code>：表格转cell，不包含表头</li></ul></li><li>与结构体一样，直接访问字段名以获得数据（组）：<code>table.FieldName</code></li></ul><h4 id="4-7-Categorial"><a href="#4-7-Categorial" class="headerlink" title="4.7 Categorial"></a>4.7 Categorial</h4><ul><li>地位：类似C++的enum枚举类型，储存有限类型的数据，相较于cell类型，可以规定元素间的大小同时保留易懂的名字，同时意味着能识别相同内容、去重；</li><li>定义：<code>categorial(array)</code>：array可以是几乎所有组：numeric array、logical array、cell array等；</li><li>展示拥有的分类（可用于去重）：<code>categories(categorial_array)</code></li><li>可以用于table数据类型中</li></ul><h4 id="4-8-File-Access"><a href="#4-8-File-Access" class="headerlink" title="4.8 File Access"></a>4.8 File Access</h4><ul><li>save &amp; load：<code>save fileName.mat [variable(s)];  load(&#39;fileName.mat&#39;);</code><ul><li>save未指明variable(s)，则保存全工作区变量</li></ul></li><li>针对table的读写：writetable &amp; readtable<ul><li><code>writetable(table, fileName)</code>：将表变量写入文件，支持类型：*.csv,*.txt, *.xls, *.xlsx, *.dat等</li><li><code>tb = readtable(fileName, &#39;Format&#39;, &#39;...&#39;);</code>：从文件（支持类型同writetable）中读表变量，其中，’Format’的value是格式化字符串，指定每一字段的格式（%s字符向量，%u uint32，%f float64 双精度浮点数，与C++不同）</li></ul></li><li>针对table的大数据量的读写：parquetwrite &amp; parquetread（支持后缀*.parquet，snappy压缩方案）<ul><li><code>parquetwrite(fileName, table)</code></li><li><code>tb = parquetread(fileName);</code></li></ul></li></ul><h3 id="Chapter5-Plotting"><a href="#Chapter5-Plotting" class="headerlink" title="Chapter5 Plotting"></a>Chapter5 Plotting</h3><h4 id="5-1-Basic-Plotting"><a href="#5-1-Basic-Plotting" class="headerlink" title="5.1 Basic Plotting"></a>5.1 Basic Plotting</h4><blockquote><p>知识补充：Matlab中的绘图机制以面向对象为核心，<strong>并把控件对象空间包含关系看作继承关系</strong></p><p>Figure类 -&gt;（包含有）Axes类 -&gt; {Line类，Text类，Surface类…} </p><p>对应：图窗对象（Figure类）、坐标轴对象（Axes类）、函数点集（Line类）、添加文字（Text类）…</p><p><strong>常用内置变量：gca（当前正在编辑的axes对象），gcf（当前正在编辑的figure对象）</strong></p></blockquote><ul><li><p>Basic Commands：基本绘图指令；<strong><u>以下命令默认指定当前figure、当前坐标轴等信息</u></strong></p><ul><li><code>line_obj = plot(x, y, &#39;str&#39;)</code>：’str’={Data_markers, Line_types, Colors}</li><li><p><code>[line_objs] =  plot(x1,y1, str1, x2, y2, str2, ...)</code></p></li><li><p><code>hold on/off</code>：have both plots in one figure</p></li><li><p><code>legend_obj = legend(&#39;name1&#39;, &#39;name2&#39;,...)</code>：按图线构造顺序标记</p></li><li><p><code>title_obj = title(str)</code></p></li><li><p><code>?label_obj = ?label(str)</code>：？可取x，y，z</p></li><li><p><code>text_obj = text(x_pos, y_pos, LaTex_str, &#39;Interpreter&#39;, &#39;latex&#39;)</code>：插入LaTex行公式</p></li><li><p><code>annotation_obj  = annotation(&#39;arrow&#39;, &#39;X&#39;, [from,to], &#39;Y&#39;, [from,to])</code>：插入箭头标识</p></li></ul></li><li><p>Figure Adjustment：实质是调整控件对象的属性</p><blockquote><p><code>set(obj, ‘attrName’, attrVal)</code>：修改对象的属性名对应的属性值</p><p><code>get(obj)</code>：得到对象的所有属性和对应值（字典形式，一个键值对一行）</p><p><code>get(obj, &#39;attrName&#39;)</code>：多用于获得对象的多级属性</p><p><code>del(obj)</code>：提前删除对应对象</p><p>另外的修改属性方式：<code>obj_attr_dict.attrName = attrVal;</code>（必须是对象字典才能用）</p><ul><li>拿到对象字典两种方式：get()/直接将对象赋给一个新变量，Matlab会给变量赋字典，而非对象本身</li></ul></blockquote><ul><li>Font、Font Size：一般有显示文字的控件都有此属性<ul><li>属性名：FontName <strong>[字符数组]</strong>、FontSize <strong>[numeric]</strong>（驼峰命名）</li></ul></li><li>Line Width、Line Style：Line对象属性<i>（可以在plot中以“Name-Value”方式指定）</i><ul><li>属性名：LineWidth <strong>[numeric]</strong>、LineStyle <strong>[字符数组]</strong></li></ul></li><li>Marker Size、Marker Colors：Line对象属性（此属性属于Marker子对象）<ul><li>属性名：MarkerEdgeColor <strong>[同Color的类型]</strong>、MarkerFaceColor、MarkerSize <strong>[numeric]</strong></li></ul></li><li>Axis Limit：Axes对象属性<ul><li>属性名：XLim、YLim（、ZLim）<strong>[1×2 numeric 数组]</strong></li></ul></li><li>Axis Label’s Name：Axes对象的二级属性<ul><li>属性名：XLabel.String、YLabel.String（、ZLabel.String）<strong>[string对象 或 char数组]</strong></li></ul></li><li>Tick Position：Axes对象属性<ul><li>属性名：XTick、YTick（、ZTick）<strong>[1×n numeric 数组]</strong></li></ul></li><li>Tick Label：Axes对象属性<ul><li>属性名：XTickLabel、YTickLabel（、ZTickLabel）<strong>[字符数组 构成的1×n的cell，标量numeric数组也可，底层会转换mat2cell、num2str]</strong></li><li>注：在此属性中，‘p’字符指代了$\pi$字符</li></ul></li><li>Color：大部分对象都具有此属性<ul><li>属性名：Color <strong>[字符数组（颜色字母/十六进制字符）/ 1×3 numeric数组（RGB矩阵）]</strong></li></ul></li></ul></li><li><p>Multiple Figures：多图窗使用（position参数不常使用，略）</p><ul><li>主动创建：<code>fig_obj = figure(&#39;Name&#39;, &#39;标题名称&#39;, &#39;NumberTitle&#39;, &#39;窗口自动编号：on/off&#39;);</code></li><li>切换到指定窗口作为当前编辑窗口：<code>figure(&#39;Name&#39;或Number（自动编号开启时）);</code></li></ul></li><li><p>Several Plots in One Figure：子图使用</p><ul><li>切换到指定子图（同时就是创建）：<code>subplot(m, n, N);</code>：m总列数，n总行数，N按行编号的子图</li></ul></li><li><p>Axis State Adjustment：坐标轴状态调整（关键字法）</p><ul><li><code>axis/box/grid off/on</code></li><li><code>axis normal</code></li><li><code>axis square</code>：坐标轴显示部分呈正方形</li><li><code>axis equal</code>：横纵（竖）轴标度相等（数据-长度比例对应）</li><li><code>axis equal tight</code>：使坐标轴limit适配数据最值</li><li><code>axis ij</code>：坐标轴原点置于左上角</li><li><code>axis xy</code>：坐标轴原点置于左下角</li></ul></li></ul><h4 id="5-2-Advanced-Plotting"><a href="#5-2-Advanced-Plotting" class="headerlink" title="5.2 Advanced Plotting"></a>5.2 Advanced Plotting</h4><ul><li><p>Purpose versus Type</p><p><img src="pic/adv_purpose.png" height="450"></p></li><li><p>Commands: Global Color Adjustment</p><ul><li><code>colormap(RGBMatrix/Built-in-Name)</code>：指定RGB矩阵作为当前配色方案（适用于所有含有闭合面积的图像中）；内置名”jet”, “hot”, “cool”, “gray”, “winter”, “summer”, “autumn”, “parula”, “prism”；</li><li><code>colorbar(&#39;southoutside&#39;)</code>：在规定位置显示颜色-值条；</li></ul></li><li><p>Commands: Analysis Gragh</p><ul><li><p><code>loglog(...)</code>：作双对数轴图；参数使用方法几乎完全与plot相同；</p></li><li><p><code>semilogx(...) &amp; semilogy(...)</code>：作单对数轴（含有的字母即为对数轴），参数方法同上；</p></li><li><p><code>yyaxis left/right;</code>：关键字方法，声明使用双y轴，此命令可以切换当前编辑的y轴；</p></li><li><p><code>histogram(X, nbins/edges)</code>：绘制频度直方图（nbins指定分块数量，edges向量指定边缘，边缘包含左边，不包含右边，末尾分组两边都包含；当不填nbins、edges时自动调整）</p></li><li><p><code>histogram(CategorialArray, nbins/edges)</code>：为分类数组统计直方图</p><p><strong><u>直方图（histogram）对象较于前面的Line对象的属性有所不同（以下列举属性名，提示：属性可以用到时，再在程序中disp查询，下略</u></strong>：</p><ul><li>Data：直方图源数据；</li><li>NumBins、BinWidth：实际分段数、实际分段宽度；</li><li><p>BinLimits：[1×2 numeric数组] 实际的分块边界数组；</p></li><li><p>Values：[1×n numeric数组] 直方图的分段数据，可以用来数据分段；</p></li><li>FaceColor、EdgeColor：[类型同Color] 直方图的面颜色、边缘颜色；</li></ul></li><li><p><code>bar(Y, [&#39;stacked&#39;])</code>：Y为向量：为每一个元素创建一个条形，高度为其值，横轴名称为排名数字；Y为矩阵时，一列作为一类数据，一行数据作平行比较，最后一个参数指明是否以堆栈形式显示；</p></li><li><p><code>bar(ticks_arr/categorial, Y, [&#39;stacked&#39;])</code>：作用同上，第一个参数指定横轴（categorial数组可以从大到小匹配、普通数组/字符数组cell只能按索引对齐）；</p></li><li><p><code>bar3(...)</code>：参数同bar，只是将前面的一行平行比较的数据拉到另一个维度比较，支持 ‘group’、‘stacked’参数；</p></li><li><p><code>barh(...)</code>：参数类同bar，只是将图数据展示在水平方向上（horizontal）</p></li><li><p><code>pie(X/categorial, [explode], [labels])</code>：X为一维向量/分类数组（sum(X)＜1，值即面积，展示一部分；sum(X)＞1，面积为比例）；explode为同型向量，指明裂开的部分；labels也为同型向量，可以给定名称；</p></li><li><p><code>polar(thetaVector, RVector)</code>：作极坐标图；</p></li><li><p><code>stairs(y)</code>：台阶图；</p></li><li><p><code>stem(y)</code>：枝干图；</p></li><li><p><code>boxplot(x, [labels], [&#39;Notched&#39;, &#39;on&#39;])</code>：箱线图（含中位数、上下四分位数、离群值显示），可以指定是否为缺口箱线图，labels可以是字符数组cell，也可以是数组；</p></li><li><p><code>errorbar(x, y, err)</code>：误差线图；</p></li><li><p><code>imagesc(matrix)</code>：平面颜色显示矩阵值；</p></li></ul></li><li><p>Commands: 3D Plot</p><ul><li><code>plot3(x1, y1, z1, ..., xN, yN, zN, ...)</code>：”Name-Value”参数几乎与plot相同（参数方程、普通方程皆可）；</li><li><code>mesh(x, y, z) &amp; surf(x, y, z)</code>：都能绘出3D网状图，不过mesh是网格（FaceColor透明），surf是平面（FaceColor不透明，可以指定EdgeColor透明）；</li><li><p><code>[C, h] = contour(x, y, z)</code>：基于立体图生成等高线图（参数几乎同mesh、surf）；返回两个参数，第一个为绘制点集，第二个为对应高度数组；</p><ul><li><code>clabel(C, h)</code>：专门对等高线图标记的命令；</li></ul></li><li><p><code>[C, h] = contourf(x, y, z)</code>：上色的等高线图；</p></li><li><code>meshc(x, y, z) &amp; surfc(x, y, z)</code>：组合等高线图的surf和mesh；</li><li><code>[X, Y, Z] = sphere(R)</code>：生成球；</li></ul></li></ul><h3 id="Chapter6-Numeric-Differentiation-amp-Integration"><a href="#Chapter6-Numeric-Differentiation-amp-Integration" class="headerlink" title="Chapter6 Numeric Differentiation &amp; Integration"></a>Chapter6 Numeric Differentiation &amp; Integration</h3><h4 id="6-1-Polynomial-Function"><a href="#6-1-Polynomial-Function" class="headerlink" title="6.1 Polynomial Function"></a>6.1 Polynomial Function</h4><ul><li>多项式表示法：行向量（最后为$x^{0}$项系数，从右向左一次递增，不得省略）:$9x^{3}+3x+7$ =&gt; [9,0,3,7]；</li><li>多项式求值：<code>y = polyval(pVector, x)</code>：求多项式在x数组每个元素上的值；</li><li>多项式求导：<code>yd = polyder(pVector)</code>：对多项式关系式求导；</li><li>卷积与多项式乘法：<strong><u>两个向量的卷积与这两个向量对应的两个多项式乘积结果对应向量相等</u></strong><ul><li><code>conv(pVector1, pVector2)</code>：两个向量的卷积（两个多项式乘法）</li></ul></li><li>多项式积分（含初值）：<code>polyint(pVector, f(0))</code>；给定的f(0)即为多项式常数；</li><li>多项式求根：<code>roots(pVector)</code>;</li></ul><h4 id="6-2-Numerical-Differentiation（数值微分）"><a href="#6-2-Numerical-Differentiation（数值微分）" class="headerlink" title="6.2 Numerical Differentiation（数值微分）"></a>6.2 Numerical Differentiation（数值微分）</h4><ul><li>一阶差分运算<code>diff(vector)</code>：计算vector相邻元素之差的向量（返回少一个元素个数的差分向量）；</li><li>一阶数值微分近似计算：只要差分运算的向量元素间足够接近，则差分可以对函数微分作近似数值计算；<ul><li>举例：<code>x = 0:0.05:pi;  y = sin(x);  m = diff(y)./diff(x);</code>则m向量为各个点间的导数值点；</li><li>注意：求导的结果向量比输入向量少一个元素，记得绘图时舍弃一个点再绘图；</li></ul></li><li>高阶数值微分近似计算：多个微分共用x向量；</li></ul><h4 id="6-3-Numerical-Integration（数值积分）"><a href="#6-3-Numerical-Integration（数值积分）" class="headerlink" title="6.3 Numerical Integration（数值积分）"></a>6.3 Numerical Integration（数值积分）</h4><ul><li><p>Midpoint Rule（中间点积分法）：$\int_{a}^{b}{f(x)dx}\approx h\sum_{i=0}^{n-1}f(x_{i})$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 以sin(x)从0~1的近似数值积分为例</span></span><br><span class="line">a = <span class="number">0</span>; b = <span class="number">1</span>; bins = <span class="number">500</span>; s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = (b-a)/(<span class="number">2</span>*bins):(b-a)/bins:(<span class="number">1</span>-(b-a)/(<span class="number">2</span>*bins))</span><br><span class="line">    s += <span class="built_in">sin</span>(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">s *= (b - a) / bins;</span><br><span class="line"><span class="comment">% 以上过程可以用sum()更快：</span></span><br><span class="line">midP = (x(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>)+x(<span class="number">2</span>:<span class="keyword">end</span>))./<span class="number">2</span>;</span><br><span class="line">y = <span class="built_in">sin</span>(midP); s = sum(y * (b-a)/bins);</span><br><span class="line"><span class="comment">% s 即为所求</span></span><br></pre></td></tr></table></figure></li><li><p>Trapezoid Rule（梯形法则/梯形积分法）：$\int_{a}^{b}{f(x)dx}\approx h[f(a)+f(b)+\dfrac{1}{2}\sum_{i=1}^{n-1}{f(x_{i})}]$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 以sin(x)从0~1的近似数值积分为例</span></span><br><span class="line">a = <span class="number">0</span>; b = <span class="number">1</span>; bins = <span class="number">500</span>; s = <span class="number">0</span>;</span><br><span class="line">s += <span class="built_in">sin</span>(a) + <span class="built_in">sin</span>(b);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = (b-a)/bins:(b-a)/bins:(<span class="number">1</span>-(b-a)/bins)</span><br><span class="line">    s += <span class="number">0.5</span> * (<span class="built_in">sin</span>(<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">s *= (b - a) / bins;</span><br><span class="line"><span class="comment">% s 即为所求</span></span><br></pre></td></tr></table></figure><blockquote><p>也可使用：<code>s = h * trapz(y);</code>其中h为y的取点间隔；</p></blockquote></li><li><p>Simpson’s Rule（辛普森法则/辛普森积分法）：$\int_{a}^{b}{f(x)dx}\approx \dfrac{h}{3}[f(a)+f(b)+4\sum_{i=1}^{2n-1}f(x_{i})+2\sum_{i=2}^{2n-2}f(x_{i})]$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 以sin(x)从0~1的近似数值积分为例</span></span><br><span class="line">a = <span class="number">0</span>; b = <span class="number">1</span>; bins = <span class="number">500</span>; s = <span class="number">0</span>;</span><br><span class="line">x = a:(b-a)/bins:b; y = <span class="built_in">sin</span>(x);</span><br><span class="line">s = (b-a)/(<span class="number">3</span>*bins)*(y(<span class="number">1</span>)+y(<span class="keyword">end</span>)+<span class="number">2</span>*sum(y(<span class="number">3</span>:<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>))+<span class="number">4</span>*sum(y(<span class="number">2</span>:<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>)));</span><br><span class="line"><span class="comment">% s 即为所求</span></span><br></pre></td></tr></table></figure></li><li><p>包装好的数值积分函数</p><ul><li>辛普森法：<code>quad(function_handle, x_start, x_end);</code></li><li>一阶数值积分<code>integral(function_handle, x_start, x_end);</code></li><li>二阶数值累次积分：<code>integral(function_handle, x_start, x_end, y_start, y_end);</code></li><li>三阶数值累次积分：<code>integral3(function_handle, x_start, x_end, y_start, y_end, z_start, z_end);</code></li><li>注：重积分仅介绍符号运算，见符号运算章节</li></ul></li></ul><h3 id="Chapter7-Equation-s-Solving-amp-Symbolic-Approach"><a href="#Chapter7-Equation-s-Solving-amp-Symbolic-Approach" class="headerlink" title="Chapter7 Equation(s) Solving &amp; Symbolic Approach"></a>Chapter7 Equation(s) Solving &amp; Symbolic Approach</h3><h4 id="7-1-Symbolic-Representation"><a href="#7-1-Symbolic-Representation" class="headerlink" title="7.1 Symbolic Representation"></a>7.1 Symbolic Representation</h4><blockquote><p>Matlab 中的新数据类型：sym符号类型，可以组成sym数组；</p><p>定义的：<code>syms x y(x);</code>中x是sym类型，y是symfun类型；等式<code>sin(x) == y</code>也是symfun类型，条件 <code>y(0) == 1</code>也是symfun类型；多个表达式<code>conds = [x == 0, y(1) == 0];</code>的conds是1×2 symfun数组；</p></blockquote><ul><li>Symbolic Variables Definition（<strong>Independent</strong>）：<code>syms a b c...; 或 sym(&#39;x&#39;);</code></li><li><p>Symbolic Variables Definition（<strong>Dependent</strong>，常用于解方程中）：<code>syms z(x, y);</code></p></li><li><p>Symbolic Beautify：<code>pretty(sym_expr)</code></p></li><li>具体值代入符号：<code>subs(sym_expr, [target_var], value);</code>，当sym_expr为单变量时，target_var可省略</li></ul><h4 id="7-2-Symbolic-Plotting"><a href="#7-2-Symbolic-Plotting" class="headerlink" title="7.2 Symbolic Plotting"></a>7.2 Symbolic Plotting</h4><ul><li><code>fplot(function_handle, [left, right], Name-Value)</code>：按符号绘图；</li><li><code>fplot3、fsurf、fcontour</code>：同理</li></ul><h4 id="7-3-Symbolic-Differentiation-amp-Integration"><a href="#7-3-Symbolic-Differentiation-amp-Integration" class="headerlink" title="7.3 Symbolic Differentiation &amp; Integration"></a>7.3 Symbolic Differentiation &amp; Integration</h4><ul><li>Symblic Differentiation：<code>fprime = diff(sym_expr, [arg_sym, n])</code>：对于自变量arg_sym的n阶导数，允许计算偏导数，sym_expr为符号表达式；</li><li>Symbolic Integration（Indefined Intergration, 但默认简单的初值）：<code>fs = int(sym_expr, [arg_sym]);</code></li><li>重积分（几重添几个int，右边以二重积分为例）：<code>int(int(sym, arg), arg)</code></li><li><strong><u>注：无法求解符号积分时，请使用“数值积分”求近似数值</u></strong>；</li></ul><h4 id="7-4-Normal-Equation-s-Solving-Root-Finding"><a href="#7-4-Normal-Equation-s-Solving-Root-Finding" class="headerlink" title="7.4 Normal Equation(s) Solving: Root Finding"></a>7.4 Normal Equation(s) Solving: Root Finding</h4><blockquote><ol><li><p>友情提示：线性方程组可以使用矩阵求解、多项式请用6.1的roots命令，可能更快</p></li><li><p>数据类型提示：无论是这里的solve，还是接下来的dsolve，如果求解有多个结果/变量，返回结果是sym结构体，使用：结果变量.sym_name获得对应sym_name的解析式；</p></li></ol></blockquote><ul><li><p>求解符号方程：<code>S = solve(eqn, target_var)</code>；</p></li><li><p>求解符号方程组（传入eqns、target_vars为sym数组）：<code>S = solve(eqns, target_var/target_vars)</code>；</p></li><li><p><strong><u>注：无法求解符号方程时，先绘图找到大致范围，使用数值近似解</u></strong><code>V = vpasolve(eqn, target_var, [left, right]);</code></p></li><li><p>解不等式（组）：语法与上述相同，只是解S的结构不同：有parameters（结果是范围，参数方程）、conditions（不等式解）等；</p></li></ul><h4 id="7-5-Differential-Equation-s-Solving"><a href="#7-5-Differential-Equation-s-Solving" class="headerlink" title="7.5 Differential Equation(s) Solving"></a>7.5 Differential Equation(s) Solving</h4><blockquote><p>注：纯积分方程可以在7.4中由solve求解；微分、微积分方程可由本部分的dsolve求解。</p></blockquote><ul><li><p>求解符号微分方程：<code>S = dsolve(eqn, cond)</code></p><ul><li><p>举例：<code>dsolve(diff(y, t, 2) == a*y, [y(0) == 5, subs(diff(y, t), t, 0) == 1]);</code></p><p>是给定初值的微分方程：$\dfrac{d^{2}y}{dt^{2}}=ay,\quad y|_{t=0}=5,\quad \dfrac{dy}{dt}|_{t=0}=1$ （其中a为常数）的解</p></li></ul></li></ul><h3 id="Chapter8-Linear-Algebra-Tools"><a href="#Chapter8-Linear-Algebra-Tools" class="headerlink" title="Chapter8 Linear Algebra Tools"></a>Chapter8 Linear Algebra Tools</h3><ul><li>矩阵用于求解线性方程组：结合”Array Operations“和线性代数知识即可，略；</li></ul><blockquote><p>提示：运行后面的矩阵操作前，建议运算这三个参数以评估矩阵的状态</p><p>知识补充：矩阵A条件数$\kappa(A)$用于衡量线性方程$Ax=b$的稳定程度，表征系统解$x$在参数A受扰动时是否会受到剧烈影响的情况。数学证明$\kappa(A)=\dfrac{\sigma_{max}}{\sigma_{min}}$，可以认为“构成A的数据组向量两两间越接近共线，即越线性相关，A越易受到扰动”，此类扰动容易导致LU分解的数值不稳定、方程解不稳定。<strong><u>（条件数越小越稳定）</u></strong></p></blockquote><ul><li>求逆、求秩、求条件数$\kappa$：<code>inv(matrix)</code>、<code>rank(matrix)</code>、<code>cond(matrix)</code></li><li>Gaussian Elimination（使用初等行变换）：<code>R = rref(matrix);</code></li><li>LU Factorization：<code>[L, U] = lu(matrix);</code></li><li>LUP Factorization：<code>[L, U, P] = lu(matrix);</code></li><li>Cholesky Factorization：<code>U = chol(matrix);</code></li></ul><blockquote><p>知识补充：矩阵LU分解可用于：求线性方程组、求逆矩阵、求行列式</p><p>使用LU分解条件：满秩方阵A</p><p><strong>警告：数值不稳定，一般改用LUP分解：$PA=LU$，或者在A为对称正定阵时，使用Cholesky Factorization（LU分解的特例、变形：$A=U^{T}U$），实现数值稳定</strong></p><p>LU分解操作方法：A通过<strong>左乘</strong>若干初等矩阵得到上三角矩阵U，左边的初等矩阵组合一定为下三角矩阵L（也可以将左边矩阵移动到等式右边，再把这个新的下三角矩阵称为L）</p><p>LU分解法求线性方程组：$L\underbrace{Ux}_{y}=b$</p><p>LU分解法求逆矩阵：$A^{-1}=U^{-1}L^{-1}$</p><p>LU分解求行列式：$|A|=|L||U|$</p></blockquote><ul><li>QR Decomposition：<code>[Q, R] = qr(matrix);</code></li></ul><blockquote><p>知识补充：矩阵正交三角形（QR）分解，求一般矩阵全部特征值的最有效并广泛应用的方法。</p></blockquote><ul><li>SVD（Singular Value Decomposition）：<code>[U, S, V] = svd(matrix);</code></li></ul><blockquote><p>知识补充：矩阵奇异值分解（SVD），相较于普通方阵A可以实现的特征分解（$A=W\Sigma W^{T}$），非方阵A也可以由数学证明，按特征值分解为：$B=U\Sigma V^{T}$，其中$U$是$AA^{T}$方阵的特征向量张成矩阵，这些特征向量称<strong>左特征值向量</strong>；$V$是$A^{T}A$方阵的特征向量张成矩阵，这些特征向量称<strong>右特征向量</strong>（不难得出U、V为正交阵）；$\Sigma$为奇异值在对角线排列的矩阵，<strong>由数学证明，奇异值是特征值的平方根</strong>。</p><p>较繁，求解方法请参考各个线性代数书籍。</p></blockquote><ul><li><p>包装好的求特征值和特征向量：<code>[V, D] = eig(matrix);</code></p><ul><li>其中V为特征值在对角元的对角矩阵；D为对应位置的特征向量张成的矩阵；</li></ul></li><li><p>矩阵指数（Matrix Exponential）：<code>Y = expm(matrix);</code></p></li></ul><blockquote><p>矩阵指数的意义：www.bilibili.com 搜索“矩阵指数”-3Blue1Brown</p><p>简单认为：应用层面上<strong>有助于解决线性微分方程组</strong></p><p>类似于$\dfrac{d}{dt}y=ry$的解是$y=r_{0}e^{rt}$，理解为“如果y增长率为自身的r倍，则y是变化因子$e^{rt}$作用于初值$r_{0}$得到的结果”，$\dfrac{d}{dt}\begin{bmatrix}x(t)\\y(t)\end{bmatrix}=\begin{bmatrix}a &amp; b \ c &amp; d \end{bmatrix}\begin{bmatrix}x(t)\\y(t)\end{bmatrix}$表示向量$\begin{bmatrix}x(t)\\y(t)\end{bmatrix}$在空间中的变化率为初值$\begin{bmatrix}x(0)\\y(0)\end{bmatrix}$在增长因子$e^{\begin{bmatrix}a&amp;b\\c&amp;d\end{bmatrix}t}$作用下的结果：$\begin{bmatrix}x(t)\\y(t)\end{bmatrix}=\begin{bmatrix}x(0)\\y(0)\end{bmatrix}e^{\begin{bmatrix}a&amp;b\\c&amp;d\end{bmatrix}t}$</p><p>结论：$\dfrac{d}{dt}\overrightarrow{v(t)}=M·\overrightarrow{v(t)}$ 的解是：$\overrightarrow{v(t)}=\overrightarrow{v_{0}}·e^{Mt}$，其中M为与$\overrightarrow{v(t)}$同维的矩阵，$e^{M}$计算方法是其定义：代入“泰勒级数”：$e^{Mt}=E+Mt+M^{2}\dfrac{t^{2}}{2!}+…+M^{n}\dfrac{t^{n}}{n!}+…$.</p></blockquote><h3 id="Chapter9-Statistics-amp-Data-Analysis"><a href="#Chapter9-Statistics-amp-Data-Analysis" class="headerlink" title="Chapter9 Statistics &amp; Data Analysis"></a>Chapter9 Statistics &amp; Data Analysis</h3><h4 id="9-1-Desciptive-Statistics"><a href="#9-1-Desciptive-Statistics" class="headerlink" title="9.1 Desciptive Statistics"></a>9.1 Desciptive Statistics</h4><ul><li><p>最大值、最小值：<code>max(...)、min(...)</code>（前面介绍过）</p></li><li><p>平均数、中位数、众数：<code>mean(A, [&#39;all&#39; / dim])、median(...)、mode(...)</code>（后面两个参数同mean，之前介绍过）</p></li><li><p>分位数：<code>prctile(X, p, [&#39;all&#39; / dim])</code>，其中p∈[0, 100]，函数对X为向量、矩阵、多维数组时的行为和前面的函数一样；</p></li><li><p>标准差、方差：<code>s = std(X); v = var(X);</code>同理</p></li><li><p>数据偏度（skewness）：<code>y = skewness(X);</code></p><blockquote><p>知识补充：数据偏度衡量数据概率密度分布的偏移程度，定义为样本三阶标准化矩：$Skew(X)=E[(\dfrac{X-\mu}{\sigma})^{3}]$当 平均数＜中位数＜众数时，数据分布为“左偏分布”（Left-Skewed，但图形上向右倾斜，Skewnewss＜0）；当众数＜中位数＜平均数时，数据分布为“右偏分布”（Left-Skewed，但图形上向左倾斜，Skewnewss＞0）；正态分布为标准的“对称分布”，偏度为0.</p></blockquote></li><li><p>数据峰度（Kurtosis）<code>y = kurtosis(X);</code></p><blockquote><p>知识补充：数据峰度表征概率密度分布在平均值处峰值高低大小（也反映了分布曲线顶部的“尖锐程度”），定义为样本四阶标准化中心矩：$Kurt(X)=E[(\dfrac{X-\mu}{\sigma})^{4}]$；相对于正态分布（Kurt=3），Kurt＜3时，瘦尾分布；Kurt＞3，厚尾分布。</p></blockquote></li></ul><h4 id="9-2-Inferential-Statistics"><a href="#9-2-Inferential-Statistics" class="headerlink" title="9.2 Inferential Statistics"></a>9.2 Inferential Statistics</h4><ul><li>常用函数<ul><li><code>rand</code>：返回<code>X~U(0,1)</code>时随机变量X的任意值；</li><li><code>rand(n)</code>：n×n的矩阵，每个元素都是rand计算出的，相互独立；</li><li><code>rand(dim1, dim2, ...)</code>：生成多维随机矩阵（服从(0,1)均匀分布）；</li><li><code>randi(imax, n, [className])</code>：生成1~imax间均匀分布的伪随机数，可指定numeric类型；</li><li><code>randi(imax, dim1, dim2, ..., [className])</code>：同理；</li><li><code>randn(n)</code>：生成n×n矩阵，元素服从标准正态分布；</li><li><code>randn(dim1, dim2, ...)</code>：同理；</li><li><code>normrnd(mu, sigma, dim1, dim2, ...)</code>：生成规定大小随机矩阵，服从<code>N(mu, sigma^2)</code>；</li><li><code>exprnd(mu, dim1, dim2, ...)</code>：生成规定大小随机矩阵，服从均值为mu的指数分布；</li></ul></li></ul><blockquote><p>此章节等复习了概率论与数理统计再补充</p></blockquote><h3 id="Chapter10-Curve-Fitting-amp-Interpolation"><a href="#Chapter10-Curve-Fitting-amp-Interpolation" class="headerlink" title="Chapter10 Curve Fitting &amp; Interpolation"></a>Chapter10 Curve Fitting &amp; Interpolation</h3><blockquote><p><strong><u>概念辨析：拟合方法包括回归、插值、逼近等，本章介绍回归和插值</u></strong></p><p>插值一定会通过所有数据观测点，但回归不一定</p></blockquote><h4 id="10-1-Simple-Linear-Regression-单变量线性回归（最小二乘法）"><a href="#10-1-Simple-Linear-Regression-单变量线性回归（最小二乘法）" class="headerlink" title="10.1 Simple Linear Regression: 单变量线性回归（最小二乘法）"></a>10.1 Simple Linear Regression: 单变量线性回归（最小二乘法）</h4><ul><li>前提：在一组收集的数据中假设x-y线性相关，满足：$\hat{y_{i}}=\beta_0+\beta_1x_i$</li><li>最小二乘法（Least-squares Solution）原理：使平方和误差（Sum of Squared Errors，SSE）最小，即$SSE=\sum\limits_{i}\epsilon_i^2=\sum\limits_i(y_i-\hat{y_i})^2=\sum\limits_i(y_i-\beta_0-\beta_1x_i)^2$最小，求偏导、极值得结论；</li><li><p>多项式曲线拟合：<code>pVector = polyfit(xList, yList, order);</code> 其中order为指定拟合多项式的阶数；</p><ul><li>可以使用双输出参数：<code>[pVector, S] = polyfit(...);</code>，使用结构体S以便进行误差分析：<code>[y_fit, delta] = polyval(pVector, x, S);</code>，其中，95%预测区间为：<code>y_fit ± 2*delta</code>.</li></ul></li><li><p>散点图（除了plot/plot3作散点，此方法也可）：<code>scatter(x, y)、scatter3(x, y, z);</code></p><ul><li>散点常用后缀参数：“filled”，可使散点实心显示；</li></ul></li><li><p>变量线性相关性（correlation coefficient, 即最小二乘法中的“r值”，-1 ≤ r ≤ 1）：<code>corrcoef(x, y);</code></p></li><li><strong><u>注：通过数学处理，也可以解决大部分单变量非线性回归问题，例如拟合假设 $\hat{y}=b+alnx$ 可以将数据集x替换为lnx，继续进行线性拟合.</u></strong></li></ul><h4 id="10-2-Multiple-Linear-Non-Linear-Regression-多变量（非）线性回归"><a href="#10-2-Multiple-Linear-Non-Linear-Regression-多变量（非）线性回归" class="headerlink" title="10.2 Multiple Linear/Non-Linear Regression: 多变量（非）线性回归"></a>10.2 Multiple Linear/Non-Linear Regression: 多变量（非）线性回归</h4><ul><li><p>多元线性回归拟合：<code>[b, bint, r, rint, stats] = regress(y, X, [Alpha]);</code></p><ul><li><p>y：模型观测值（响应值）；</p></li><li><p>X：模型输入矩阵，要求第一列必须为全1列（以便软件处理模型常数）、接下来几列每列分别存放各个<strong><u>预测因式（不是自变量！！！）</u></strong>参数的取值向量（与y位置对应）</p><ul><li>预测因式：假设拟合的表达式为：$\hat{y}=\beta_0+\beta_1x_1+\beta_2x_2^2+\beta_3x_1x_2$，则预测因式为：$x_1$、$x_2^2$、$x_1x_2$，X矩阵应该是：<code>X = [ones(length(X1)) X1 X2.^2 X1.*X2];</code></li></ul></li><li><p>Alpha：显著性水平，用于设定100*（1-Alpha）%置信水平，默认0.05；</p></li><li><p>b：对应于X中预测因式的拟合系数组成的向量；</p></li><li><p>bint：系数估计值95%置信区间的矩阵（n(b)×2数组，每行表示该拟合点置信边界的上、下界）；</p></li><li><p>r：拟合-实际点对应残差向量；</p></li><li><p>rint：用于诊断离群值的区间（n(X)×2数组，每行表示该观测点的离群区间，如果这个区间不包含0，则对应残差在置信区间之外，是离群值）</p></li><li><p>stats：拟合评估向量 $[R^2, F, p, est]$</p></li></ul></li><li><p>非线性回归拟合：<code>beta = nlinfit(X, Y, modelFunc_handle, beta0); 或使用工具cftool();</code></p><ul><li><p>nlinfit原理：迭代最小二乘法估计</p></li><li><p>X、Y为数据列表，modelFunc_handle为模型函数指针，beta0为合适的迭代初值</p></li><li><p>modelFunc如何找，需要对数学模型非常熟悉，按曲线变化类型一个个试；</p><p><strong><u>如何得到合适的beta0？</u></strong></p></li><li><p>目标：越接近真实情况的参数越好（估计实际情况下模型参数大致是多少）</p><blockquote><p>法1：目测观测点估计法；</p><p>法2：代入几个数据点，使用solve/dsolve解出大致参数；</p><p>法3：在评估真实参数大致范围（越小越好）后，使用随机数生成；</p></blockquote></li></ul></li></ul><h4 id="10-3-Common-Interpolation"><a href="#10-3-Common-Interpolation" class="headerlink" title="10.3 Common Interpolation"></a>10.3 Common Interpolation</h4><blockquote><p>以下两个插值函数都具有外插值默认值，针对不同method有不同赋值方式，只需在method后给定默认外插值即可；</p><p>提示：可以对灰度图像矩阵进行插值；</p></blockquote><ul><li>一维数据插值（表查找）：<code>vectorQuery = interp1(x, y, xQuery, method);</code><ul><li>x：样本点；y：样本点对应观测值；</li><li>xQuery：查询点（一般查询内插值点）；</li><li>vectorQuery：查询结果值（估计）；</li><li>method：插值方法</li></ul></li></ul><p><img src="pic/methods.png"></p><blockquote><p>注：method=’pchip’等价于命令pchip(…), Piecewise Cubic Hermite Interpolating Polynomial;   method=’spline’等价于命令spline(…), Cubic spline data interpolation;</p></blockquote><ul><li><p>补充相关函数：分段多项式（piecewise polynomial）</p><ul><li>生成分段多项式：<code>pp = mkpp(breakPointsV, pVectors);</code>（其中pp为结构体，可以被ppval读取）</li><li>分段多项式的值：<code>v = ppval(pp, x);</code></li><li>直线绘制：<code>line_obj = line([x_s, x_e], [y_s, y_e], [LineSpec]);</code><ul><li>用于绘制断点x=x0处的垂直虚线：<code>line([x0, x0], ylim或get(gca).YLim, &#39;--&#39;);</code></li></ul></li></ul></li><li><p>二维数据插值：<code>vQuery = interp2(X, Y, Z, XQuery, YQuery, method);</code></p><ul><li>X、Y、Z对应二维数据点及其值，XQuery、YQuery为内部查询点，vQuery为查询值；</li><li>同时支持高维数组填充插值：<code>Mq = interp2(M, k);</code>在每维度M的样本间分割k次插入值；</li><li>method：插值方式</li></ul></li></ul><p><img src="pic/methods2D.png"></p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Math </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN服务分析和推荐</title>
      <link href="//chat/my-cdn-services/"/>
      <url>//chat/my-cdn-services/</url>
      
        <content type="html"><![CDATA[<p>请大家放心食用，不是广告，不恰饭。仅提供 CDN 服务的一些数据和行情的信息，供大家参考。</p><span id="more"></span><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>本人在几个月前维护博客网站的时候，总是发现进入博客页面的时间远远长于预料的时间。在服务器上搜索一番后，我发现很可能是因为博客上存放和展示的图片过多，并且很多图片的大小都在 1MB+；更何况我也没有对图片进行压缩和处理，所以在运营一段时间后，打开慢是一种必然现象。</p><p>没办法，只好自己去找 CDN（Content Delivery Network）来加快访客对于网页的访问速度。目前市面上提供 CDN 的企业种类繁多，真能让人看花了眼，尤其是对于我这种小白来说更是害怕。唉！在现在这个互联网时代，想要守好自己的钱袋子和自己的信息安全并不是一件容易的事。</p><h3 id="CDN-服务归纳"><a href="#CDN-服务归纳" class="headerlink" title="CDN 服务归纳"></a>CDN 服务归纳</h3><p>我前前后后找了几家看起来比较正规的 CDN 服务商（因为自己网站的资源和信息的安全还是要有点保障的，太差了可不行），信息罗列如下，评价部分可能带有一定主观色彩，请自行评估！想要直接看结论，戳<a href="#conclusion">这里🔗</a></p><h4 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h4><ul><li>费用：新用户连续 6 个月每月 50G 流量赠送；普通用户 100G（个人网站，如博客）17 元 / 月，500G 84 元 / 月；</li><li>描述：每月提供 10G 免费流量，结点数 10 ~ 20 左右，100G 购买起步；</li><li>口碑：国内大厂，稳定性和安全性有保障；</li></ul><h4 id="百度云"><a href="#百度云" class="headerlink" title="百度云"></a>百度云</h4><ul><li>费用：每月 10G 免费流量，超出的流量会回源处理，不会继续扣费；（<strong>收费项目项目貌似都是面向企业用户？</strong></li><li>描述：个人的加速结点比较少，联通、电信之类的结点，只有几个；</li><li>口碑：还不错，但百度似乎主业不是这个？</li></ul><h4 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h4><ul><li>费用：支持两种购买方式，<strong>按量付费和资源包购买</strong>；资源包 50G 每月 8.4 元，一次买越多，优惠越大；</li><li>描述：HTTP 流量和 HTTPS 流量需要分开购买（类型似乎分的很细？）支持境外流量；</li><li>口碑：国内大厂，这也是它的主营业务之一，安全性和稳定性没话说，我的一个服务器就是买阿里云的；</li></ul><h4 id="又拍云"><a href="#又拍云" class="headerlink" title="又拍云"></a>又拍云</h4><ul><li>费用：账户余额制，资源包、境外流量单独购买，大小和价格取决于购买量，可以自己指定购买天数；</li><li>描述：又拍云联盟<strong>每月10G 免费存储空间、15G 免费 CDN 流量</strong>，HTTP 和 HTTPS 皆可；加入联盟需要在页脚挂广告；<strong>可以自行添加防盗链、加密等功能</strong>；</li><li>口碑：后起之秀；服务贼快，响应时间 &lt; 20min</li></ul><h4 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h4><ul><li>费用：100G 起购买，100G 20元 / 月（最近有6.18大促，降到了15.4），<strong>不分开 HTTP 和 HTTPS</strong>，按 <code>HTTP:HTTPS = 1:1.15</code> 的比例扣费；</li><li>描述：每个月前 10G 流量免费，但仅有 HTTP；</li><li>口碑：还不错，据它自己说，为多家大公司提供 CDN 服务；</li></ul><h4 id="freeCDN"><a href="#freeCDN" class="headerlink" title="freeCDN"></a>freeCDN</h4><blockquote><p>注意识别，口碑不算优秀</p></blockquote><ul><li>费用：普通个人用户建议使用免费版；收费面向企业，300元 / 月；</li><li>描述：免费支持 HTTPS，无防盗链，免费的份额够用；</li><li>口碑：一般；</li></ul><h4 id="Cloudflare"><a href="#Cloudflare" class="headerlink" title="Cloudflare"></a>Cloudflare</h4><ul><li>费用：个人一般选免费版本，收费面向企业；</li><li>描述：对个人的免费力度极大，无限流量；</li><li>口碑：国外大厂，安全性有保障；可惜稳定性很差，对国内环境不算友好；</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><i id="conclusion">注：下表在2023年6月16日前收集</i></p><div style="text-align: center;"><span>表1 CDN 服务对照表</span></div><table>    <tr>        <td>服务商</td>        <td>腾讯云</td>        <td>百度云</td>        <td>阿里云</td>        <td>又拍云</td>        <td>七牛云</td>        <td>freeCDN</td>        <td>Cloudflare</td>    </tr>    <tr>        <td>费用</td>        <td>0.17 元/G/月</td>        <td>1590/年</td>        <td>0.168元/G/月</td>        <td>充值制</td>        <td>年包 0.2元/G</td>        <td>小型企业 300元/月</td>        <td>插件按月</td>    </tr>    <tr>        <td>口碑 &amp; 安全性</td>        <td>++++</td>        <td>+++</td>        <td>+++++</td>        <td>+++</td>        <td>+++</td>        <td>++</td>        <td>+++++</td>    </tr>    <tr>        <td>HTTPS流量</td>        <td>单独收费</td>        <td>单独收费</td>        <td>单独收费</td>        <td>不单独收费</td>        <td>单独收费</td>        <td>Free</td>        <td>Free</td>    </tr>    <tr>        <td>可白嫖</td>        <td>每月10G</td>        <td>每月10G</td>        <td>❌</td>        <td>每月10G+15G</td>        <td>10G HTTP</td>        <td>Totally free✅</td>        <td>Totally free✅</td>    </tr>    <tr>        <td>是否需要备案</td>        <td>是</td>        <td>是</td>        <td>是</td>        <td>是</td>        <td>是</td>        <td>是</td>        <td>否</td>    </tr>    <tr>        <td>稳定性</td>        <td>++++</td>        <td>++++</td>        <td>+++++</td>        <td>++++</td>        <td>++++</td>        <td>++</td>        <td>境外，较差</td>    </tr></table>]]></content>
      
      
      <categories>
          
          <category> chat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个FLAG</title>
      <link href="//chat/planning-flag/"/>
      <url>//chat/planning-flag/</url>
      
        <content type="html"><![CDATA[<p>最近期末考试终于结束了，想到又能将自己的时间分配在自己需要的方面（例如写博客），又是一件令人振奋人心的事情！只可惜大学生的暑假竟然会被老师布置的作业充斥，这真是从未想到 😂</p><span id="more"></span><p>在前天最后一门考试结束后，我迅速进入放松状态，和室友打了整整两天的 MC（感觉有点放纵……于是，在导师的建议下，我得快速开始制定一些计划，防止我过于颓废 [doge].</p><p>咳咳，好的朋友们，我现在要立下一个大 flag：<strong>我将在暑假结束前完成我制定的所有计划和任务，鼓足干劲，绝不颓废！</strong></p><p>下定决心，以此博客为证！</p>]]></content>
      
      
      <categories>
          
          <category> chat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学复习</title>
      <link href="//review/discrete-math/"/>
      <url>//review/discrete-math/</url>
      
        <content type="html"><![CDATA[<p><i><u>本系列文章为作者复习离散数学过程中的知识点总结、速通，欢迎补充</u></i></p><p><i>written by SJTU-XHW</i></p><p><i>Reference: 清华大学出版社《数理逻辑与集合论（第二版）》《图论与代数结构》</i></p><p><i>提示：大段文字阅读，点击右侧齿轮图标，进入阅读模式体验更佳 ~ </i></p><span id="more"></span><hr><h2 id="Chapter-1-命题逻辑"><a href="#Chapter-1-命题逻辑" class="headerlink" title="Chapter 1 命题逻辑"></a>Chapter 1 命题逻辑</h2><h3 id="1-1-重要概念汇总"><a href="#1-1-重要概念汇总" class="headerlink" title="1.1 重要概念汇总"></a>1.1 重要概念汇总</h3><ul><li><p>命题的定义：能判断真假的陈述句；（真假性：命题的值）</p></li><li><p>命题分类：原子命题、复合命题（成分命题 + 联结词）</p></li><li><p>真值联结词：非（否定式）、且（合取式）、或（析取式）、如果则（蕴含式）、等价（等值式）；</p></li><li><p>命题变元：以真假为变域的变元；</p></li><li><p>真值函数：以真假为定义域、真假为值域的函数；</p></li><li><p>命题演算公式的定义：（通俗）由命题变元利用真值联结词构成的式子；</p><blockquote><p>命题变元是、公式的否定式是、两个公式的合取、析取式是；仅限于此；</p></blockquote></li><li><p>变元组：n元公式 α 含有不同命题变元 p1、p2、……、pn，称（p1, p2, …, pn）为 α 的变元组；</p></li><li><p>完全指派：变元组任一组确定值都称为 α 关于这个变元组的一个 ~；</p></li><li><p>部分指派：仅对变元组部分变元赋以确定值，另外一部分不赋值（X），称……；</p><blockquote><p>完全、部分指派举例：(p, q, r, s) = (T, T, F, T)；(p, q, r, s) = (T, X, X, F)</p></blockquote></li><li><p>成真指派、成假指派；</p><p><strong>一个公式的性质</strong></p></li><li><p>重言式：该公式的所有完全指派都是成真指派；</p></li><li><p>矛盾式：该公式的所有完全指派都是成假指派；</p></li><li><p>可满足公式：该公式存在成真指派；</p><blockquote><p>又可以分为：仅可满足公式、重言式；</p></blockquote></li><li><p>非永真式：该公式存在成假指派；</p><blockquote><p>又可分为：仅可满足公式、矛盾式；</p></blockquote><p><strong>两个公式的关系</strong></p></li><li><p>逻辑等值（<strong>同真假</strong>）：两个公式在它们的合成变元组的任何完全指派下，有完全相同的真假性；</p><blockquote><p>相对地，有<strong>互相矛盾性</strong>，~都取不同的真假值；</p><p>推论：α = β $\Longleftrightarrow$ α $\leftrightarrow$ β 为永真式；</p></blockquote><p><strong>需要记忆的同真假式变换：</strong></p><ul><li>交换律、结合律：<strong>蕴含词不满足</strong>；</li><li>分配律：<strong>等值词不满足、蕴含词分配后不变：$p\rightarrow(q\rightarrow r)=(p\rightarrow q)\rightarrow(p\rightarrow r)$</strong>；</li><li>摩根律、双重否定律、幂等律（与自身运算）、同一律和零律；</li><li><strong>联结词化归结论：$p\rightarrow q=\overline{p}\vee q$、$p\leftrightarrow q=p\wedge q \vee \overline{p}\wedge\overline{q}$</strong>；</li></ul></li></ul><ul><li><p>同永真性：若 α 永真当且仅当 β 永真，则称~；</p></li><li><p>同可满足性</p><blockquote><p>推论：α、β 同真假 $\Longrightarrow$ α、β 既同永真性，又同可满足性；</p></blockquote></li><li><p>对偶式：将任一<strong>不含蕴含词、等价词</strong>的 α 中所有 $\wedge$、$\vee$ 互换得到的公式称为 α 的对偶式，记为 $\alpha^*$；</p><blockquote><p>注：永真（T）、永假（F）看作 $p\vee\overline{p}$、$p\wedge\overline{p}$；</p></blockquote></li><li><p>内否式：将任一 α 中各变元（<strong>不能是子公式</strong>）的所有肯定形式和否定形式互换，得到的公式称为 α 的内否式，记为 $\alpha^-$；</p><script type="math/tex; mode=display">\begin{aligned}&\alpha=(\overline{p\wedge q}\space\vee\space \overline{p\wedge r})\space\wedge\space(p\vee(\overline{q}\wedge\overline{r}))\\&\alpha^*=(\overline{p\vee q}\wedge\overline{p\vee r})\space\vee\space(p\wedge(\overline{q}\vee\overline{r}))\\&\alpha^-=(\overline{\overline{p}\wedge\overline{q}}\vee\overline{\overline{p}\wedge\overline{r}})\space\wedge\space(\overline{p}\wedge(q\vee r))\end{aligned}</script><p>常用性质：</p><ul><li>$\alpha^-\wedge\beta^-=(\alpha\wedge\beta)^-$（对各种真值联结词适应，甚至蕴含词）</li><li>$(P\vee Q\wedge R)^*=P\wedge(Q\vee R)$（变换后不改变原来运算次序）</li><li>$\overline{\alpha^*}=\overline{\alpha}^*$、$\overline{\alpha^-}=\overline{\alpha}^-$（对偶、内否都可与否定交换运算顺序）</li><li>$\overline{\alpha}=\alpha^{*-}$（内否、对偶同时取即为取反）</li></ul><p>推论：</p><ul><li>$\alpha$ 与 $\alpha^-$ 既同永真性，又同可满足性（不一定同真假）；</li><li>$\overline{\alpha}$ 与 $\alpha^*$ 既同永真性，又同可满足性；</li><li>【对偶定理】$\alpha\rightarrow\beta$ 与 $\beta^*\rightarrow\alpha^*$ 既同永真性，又同可满足性、$\alpha\leftrightarrow \beta$ 与 $\alpha^*\leftrightarrow \beta^*$ 既同永真性，又同可满足性；</li></ul></li><li><p><strong>置换规则和代入规则的异同</strong>：</p><ul><li><p>置换规则：对公式的子公式，用与之等值的公式进行替换，得到的新公式与原公式同真假；</p><blockquote><p>可以只对某一个子公式替换；</p></blockquote></li><li><p>代入规则：对公式中出现的所有同一个命题变元代入一个公式，得到的新公式与原公式同真假；</p><blockquote><p>必须处处代入、必须对变元代入；</p></blockquote></li></ul></li><li><p>范式：一个公式到真假指派的<strong>逆过程</strong>——如何从真假指派构造出公式</p></li><li><p>简单合取式：命题变元，或（可兼得）其否定，或（可兼得）由它们利用联结词 $\wedge$ 组成的公式；</p><p>简单析取式：……联结词 $\vee$ ……；</p></li><li><p>实合取式、虚合取式：某一变元的否定及其自身<strong>最多仅出现一次</strong>的简单合取式称为<strong>实合取式</strong>，否则为<strong>虚合取式（即：永假合取式）</strong>；</p><p>实析取式、虚析取式：……简单析取式……（<strong>永真析取式</strong>）；</p></li><li><p>（极大项极小项）唯一指派定理：对一个确定的变元组而言，任一实合取式有且仅有一个成真指派、任一个实析取式有且仅有一个成假指派（回顾数电中的极大项、极小项）；</p><blockquote><p>变元组 (p, q, r) = (T, X, F) 是一个成真指派 对应：$p\wedge\overline{q}$；</p><p>变元组 (p, q, r) = (F, F, T) 是一个成假指派 对应：$p\vee q\vee \overline{r}$；</p></blockquote></li><li><p>范式表示定理：<strong>任一公式 $\alpha$ 恒可以表示为简单合取式的 析取，称为 $\alpha$ 的析取范式（即逻辑代数中的 SOP）</strong>，也可以表示为<strong>简单析取式的 合取，称为 $\alpha$ 的合取范式（POS）</strong>；</p><blockquote><p>合取范式和析取范式不唯一；</p></blockquote></li><li><p>主析取范式、主合取范式：析合范式、合析范式中的简单合取式、简单析取式全为最小项、最大项；（标准SOP和标准POS）</p><p>主析/合取范式定理：任一个 n 元公式，都存在一个唯一的与之等值的、恰含这 n 个变元的主析/合取范式；</p><p><strong>最小项的表示：$m_i$ 指 使最小项为真的各变元组成的二进制数代表 i 的那个组合</strong>；</p><p><strong>最大项的表示：$M_i$ 指 使最大项为真（这里和主流教材不一样）的各变元组成的二进制数代表 i 的那个组合</strong>；</p><p><strong>最小项的性质：</strong></p><ul><li>n 元公式的最小项共 $2^n$ 种；</li><li>在公式的变元组任意完全指派中，有且仅有一种最小项 为真；</li><li>全体最小项析取为1，任意两个最小项合取为0；</li></ul><p><strong>最大项的性质</strong>：</p><ul><li>n 元公式的最大项共 $2^n$ 种；</li><li>在公式的变元组任意完全指派中，有且仅有一个最大项 为假；</li><li>全体最大项合取为0，任意两个最大项析取为1；</li></ul></li><li><p>范式表示定理的延伸：联结词的完备集；</p></li></ul><h3 id="1-2-命题逻辑的推理形式"><a href="#1-2-命题逻辑的推理形式" class="headerlink" title="1.2 命题逻辑的推理形式"></a>1.2 命题逻辑的推理形式</h3><ul><li><p>判断A 和 B是否重言蕴含：<strong>判断 $A\rightarrow B$ 是否永真，即在 A 所有的成真指派下，B是否都为真</strong>；</p></li><li><p>重言蕴含的性质</p><ul><li>若 $A\Rightarrow B$，则：若 A 永真，则 B 永真；</li><li>若 $A\Rightarrow B$、 $B\Rightarrow A$，则 A、B 等价；</li><li>若 $A\Rightarrow B$ 且 $A\Rightarrow C$，则 $A\Rightarrow(B\wedge C)$（归并合取）；</li><li>若 $A\Rightarrow C$ 且 $B\Rightarrow C$，则 $(A\vee B)\Rightarrow C$（归并析取）；</li></ul></li><li><p>基本推理公式</p><ul><li><p>$P\wedge Q\Rightarrow P$（从严格到一般）；</p></li><li><p>$P\Rightarrow(P\vee Q)$（从一般到模糊）；</p></li><li><p>$P\wedge(P\rightarrow Q)\Rightarrow Q$（分离规则）；</p><p>$\overline{Q}\wedge(P\rightarrow Q)\Rightarrow\overline{P}$（分离规则的逆否命题）；</p></li><li><p>$(P\rightarrow Q)\space\wedge\space(Q\rightarrow R)\Rightarrow P\rightarrow R$（三段论）；</p><p>$(P\leftrightarrow Q)\space\wedge\space(Q\leftrightarrow R)\Rightarrow P\leftrightarrow R$</p></li></ul></li><li><p>如何证明推理公式</p><ul><li>可以使用<strong>重言蕴含</strong>的定义（$A\rightarrow B$ 为永真式）——永真推理 / 假设推理；</li><li>使用<strong>重言蕴含</strong>定义的反面（$A\wedge\overline{B}$ 为永假式）——归结推理；</li><li>证明推理公式本身的<strong>逆否命题</strong>；</li><li>按三段论拆分；</li><li>真值表法；</li></ul></li><li><p>推理演算规则</p><ul><li><p>前提引入：推理过程中可以随时引入前提；</p></li><li><p>结论引入：推论过程中获得的结论可以作为后续推理的前提；</p></li><li><p>代入规则、置换规则</p><blockquote><p><strong>代入：对命题变元、代入的必须是重言式、所有出现都要代入</strong>；</p><p><strong>置换：子公式，置换部分需要等值，可以仅一部分</strong>；</p></blockquote></li><li><p>分离规则；</p></li><li><p>条件证明规则：<strong>$A_1\wedge A_2\Rightarrow B\Longleftrightarrow A_1\Rightarrow A_2\rightarrow B$</strong>（将条件移动到另一边）；</p></li></ul></li><li><p>归结推理法</p><p>为证明 $A\rightarrow B$ 重言，从 $A\wedge\overline{B}$ 开始：</p><p>step 1. 将 $A\wedge\overline{B}$ 化为<strong>合取范式</strong>，并由其中的子句（析取式+）构成子句集 S；</p><p>step 2. 对 S 中的子句做归结：<strong>消互补对（$C_1=L\vee C_1^\prime$ 和 $C_2=\overline{L}\vee C_2^\prime$ 归结为 $R(C_1,C_2)=C_1^\prime\vee C_2^\prime$）</strong>；</p><p>step 3. 重复step2，直至得到空子句（矛盾）；</p></li></ul><h3 id="1-3-考点和常见题型"><a href="#1-3-考点和常见题型" class="headerlink" title="1.3 考点和常见题型"></a>1.3 考点和常见题型</h3><ul><li><p>命题的判断</p><blockquote><ol><li>必定为陈述句，否则没有真假；</li><li>必须可以辨别真假；</li><li>未证明的定理算，因为最终是有真假的；</li><li>悖论不算：“这句话是假话”；</li></ol></blockquote></li><li><p>真值联结词和自然语言的差异</p><ul><li>并列“和”、并且“和”；</li><li>可兼得“或”、不可兼得“或”；</li><li>不关心因果的“如果……则……”；</li></ul></li><li><p>波兰表达式（前缀表达式）、逆波兰表达式（后缀表达式）、中缀表达式的转换</p><p><strong>前缀式书写思路：找到当前最后运算的运算符，先放到当前区块的最前面，以此为分割，分别处理左右边的式子</strong>；</p></li><li><p>给定一个公式，确定其成真指派、成假指派</p><p>step 1. 应用等值运算将否定词深入到变元上；</p><p>step 2. 随机指定一个变元（建议选出现次数多、对它指派能轻松得到结果的变元），对其分别做 T、 F 指派（分类讨论），得到两个不含该变元，但有真假值的公式；</p><p>step 3. 化简这两个公式，如果仍存在变元，重复上面的操作，直至能够直接判断真假为止；</p><blockquote><p>e.g., 判定 $(p\vee\overline{r})\rightarrow\overline{((p\rightarrow q)\leftrightarrow\overline{(p\wedge\overline{(q\leftrightarrow r)})})}$ 的永真性和可满足性；</p></blockquote></li><li><p>判断联结词的完备集、联结词相互转化</p><ul><li><p>否定、析取、合取：$\neg$ 和 $\vee$ 、$\neg$ 和 $\wedge$ 构成<strong>最小完备集</strong>，但 $\wedge$ 和 $\vee$ 不行！！！</p></li><li><p>与非（$\uparrow$）、或非（$\downarrow$）：各自独立构成<strong>最小完备集</strong>；</p></li><li><p><strong>否定和蕴含（$\rightarrow$）构成一个最小完备集</strong>，但否定和等价<strong>甚至连完备集都不是</strong>！！！</p></li><li><p>除了以上提到的最小完备集，及其扩充，其他任何联结词组成的集合都不是完备集；</p><blockquote><p>e.g., $\{\wedge,\leftrightarrow\},\{\vee,\rightarrow\},\{\neg,\leftrightarrow\}$ 等，都不是完备集；</p></blockquote></li></ul></li><li><p>n 元联结词的数量：$2^{2^n}$个；</p></li><li><p>将一个公式转换为对应的主析取范式、主合取范式、最简析合范式、最简合析范式；</p><blockquote><p>e.g.1, 将 主析取范式 $A=\bigvee_{0,1,4,5,7}$ 转换为主合取范式；</p><p>e.g.2, 将 合取范式$P\vee Q$ 转换为析取范式；</p></blockquote></li><li><p>证明推理公式：例题略</p></li><li><p>判断推理式是否正确：<strong>从重言蕴含化为蕴含运算，看是否为永真式</strong>；</p></li><li><p>自然语言到命题公式的形式化和证明</p><p>⚠<strong>极易出错点：只有……才、除非……否则、或者……或者的形式化</strong></p><ul><li>“只有P-才Q”：只有满足P，才满足Q，<strong>言外之意，P 是 Q 的必要不充分条件！（如果不满足P，那么并不影响 Q）</strong>，所以翻译为：$Q\rightarrow P$；</li><li>“除非P-否则Q”：等价于只有满足 $P$，才满足 $\neg Q$，所以翻译为 $\neg Q\rightarrow P$；</li><li>“或者P-或者Q”：<strong>有两种理解方式：可兼得或、不可兼得或</strong>，视语境而定；可兼得或，和“……可以，……也可以”的意义相同，这个时候翻译成 $P\vee Q$；不可兼得或，和“要么……要么……”的意义相同，这个时候翻译成 $P\oplus Q=P\wedge\neg Q\vee\neg P\wedge Q$；</li></ul></li></ul><h3 id="1-4-错题"><a href="#1-4-错题" class="headerlink" title="1.4 错题"></a>1.4 错题</h3><ul><li><p>形式化语句：如果水是清的，那么或者张三能见到池底或者他是个近视眼；</p><p><strong>错因：读题问题</strong></p><p><strong>“或者……或者……”在这里是不可兼得或，表示“要么……要么……”</strong></p><blockquote><p>设 P: 水清；Q: 张三能见池底；R: 张三是近视眼；</p><p>$P\rightarrow(Q\wedge\overline{R}\vee\overline{Q}\wedge R)$</p></blockquote></li><li><p>将公式写为波兰表达式、逆波兰表达式：$P\rightarrow Q\vee R\vee S$、$\neg\neg P\vee(W\wedge R)\vee\neg Q$、$P\wedge\neg R\leftrightarrow P\vee R$；</p><p><strong>错因：运算符优先级判断错误（$\neg\gt\wedge\gt\vee\gt\rightarrow\gt\leftrightarrow$）</strong></p><p>$\rightarrow P\vee\vee QRS$、$PQR\vee S\vee$、$\leftrightarrow \wedge P\space\neg R\vee P Q$（其他略）</p></li></ul><h2 id="Chapter-2-谓词逻辑（一阶）"><a href="#Chapter-2-谓词逻辑（一阶）" class="headerlink" title="Chapter 2 谓词逻辑（一阶）"></a>Chapter 2 谓词逻辑（一阶）</h2><blockquote><p>将原子命题进一步分析为<strong>个体</strong>和<strong>谓词</strong>；</p></blockquote><h3 id="2-1-重要概念集合"><a href="#2-1-重要概念集合" class="headerlink" title="2.1 重要概念集合"></a>2.1 重要概念集合</h3><ul><li><p>个体：可以指具体/抽象的独立存在的对象；</p><blockquote><p>如：字母R，XX公司，1，2，-1，张三等；</p></blockquote></li><li><p>个体域：由个体组成的集合；</p><p>全总个体域：所有个体聚合在一起所组成的集合；</p></li><li><p>个体变元：以某个个体域 I 中的个体为变域的变元，称为<strong>个体域 I 上的个体变元</strong>；</p></li><li><p>谓词：个体、命题所具有的性质，或者若干个体、若干命题之间的关系；</p><ul><li>一元谓词：指明个体/命题的性质；</li><li>二元谓词：指明两个个体/一个个体和一个命题间的关系；</li></ul><p><strong>谓词实际上是一个以个体/命题（目前仅讨论以个体为变域的一阶谓词）为变域、命题为值的函数</strong>；</p><blockquote><p>真值函数是个以命题为变目、命题为值的函数，所以也是谓词；（真值联结词同理）</p></blockquote><p>⚠<strong>注意：谓词与个体域紧密相关，例如一元谓词”是质数“相对于自然数域而言</strong>；</p></li><li><p>谓词变元：以谓词为变域的变元；</p><blockquote><p>约定：小写字母为（pqr）命题变元、大写字母（PQR）为命题、小写字母（abc）为个体变元、大写字母（ABC）为特定谓词、大写字母（XYZ）为谓词变元；</p></blockquote></li><li><p>谓词填式：将谓词后面填以<strong>个体变元</strong>所得的式子；</p><blockquote><p>谓词和谓词填式是两个完全不同的概念；</p></blockquote></li><li><p>命名变元：为了了解谓词的元数，一般在谓词后写<strong>命名变元</strong>来说明元数（类似函数形参）；</p></li><li><p>谓词命名式：谓词后填以<strong>命名变元</strong>的式子（类似函数声明）；</p><blockquote><p><strong>谓词命名式 等价于 谓词</strong>，所以谓词命名式和谓词填式完全不同；</p></blockquote></li><li><p>谓词的严格定义：以某个个体域 I 为定义域，以真假为值域的谓词，称为<strong>个体域 I 上的谓词</strong>；</p><p>谓词变元的严格定义：以个体域 I 上的谓词为变域的变元，称为<strong>个体域 I 上的谓词变元</strong>；</p><p><strong>结论：k 个个体组成的个体域 I 上的 m 元谓词共有 $2^{k^m}$ 个</strong>；</p></li><li><p>量词：仅有个体、谓词，还是无法描述一些问题—-&gt;<strong>措施：使用新的变元 + 约定新的变元的个体域 + 规定新的变元的性质 来处理</strong></p><p>新的变元：</p><ul><li>全称性变元：表示<strong>任意一个</strong>的变元，都称~；</li><li>存在性变元：表示<strong>确定的一个，但现在可能不知道/无需指明的一个</strong>，都称~；</li></ul><p>引入谓词约束新的个体域：</p><ul><li><p>谓词配合全称性量词+蕴含前件约束：</p><blockquote><p>所有实数，要么大于0，要么小于0，要么等于0</p><p>$Ay\rightarrow(y\gt0\vee y=0\vee y\lt 0)$，y是<strong>以全总个体域为变域的全称性变元</strong>，A表”是实数“；</p></blockquote></li><li><p>谓词配合存在性量词+合取约束：</p><blockquote><p>一个中国人来了（Ae表示e来了）</p><p>$Bu\wedge Au$，u是<strong>以全总个体域为变域的存在性变元</strong>，B表”是中国人“；</p></blockquote></li></ul><p>引入<strong>量词</strong>规定新的变元的性质：$\forall x$（全称量词）、$\exists x$（存在量词）；</p></li><li><p>细小概念：对两种公式：$\forall x\alpha(x),\space\exists x\alpha(x)$</p><ul><li>$\forall x、\exists x$ 中的 x 是相应量词的<strong>指导变元</strong>；</li><li>$\alpha(x)$ 为相应量词的<strong>作用域（或辖域）</strong>；</li><li>在作用域中，但不与指导变元同名的其他变元称为<strong>参数</strong>；</li></ul></li><li><p><strong>谓词演算公式（定义和主流教材不一样！有争议，应该不考定义，这里写主流教材的）</strong>：由命题变元、谓词填式利用真值联结词和量词作成的如下式子：</p><ul><li>命题公式是公式；</li><li>填以个体变元的谓词填式也是公式；</li><li>公式的否定是公式；</li><li>两个公式的合取、析取、蕴含、等价也是公式；</li><li>若 α 是公式，x 是个体变元，则 $\forall x\alpha,\space\exists x\alpha$ 也是公式；</li></ul><blockquote><p>提示，本教程中不主流，认为$\forall xF(x)\wedge G(x)$ 不是公式；</p></blockquote></li><li><p>自由出现和约束出现：设 α 为一个谓词演算公式，Qxβ是 α 的一个子公式（Q为量词的一种，x 为变元，β 为公式），则在Qxβ 中：变元 x 的一切出现都称为 x 在 α 中的<strong>约束出现</strong>；而 α 中的 x 除了约束出现以外的一切出现都称 x 在 α 中的<strong>自由出现</strong>；</p><blockquote><p>$\forall x((Xxy\wedge\exists yYy)\rightarrow\exists y(\overline{X}xy\leftrightarrow\exists y\overline{X}y))$中，</p><p>第一个 y 是公式中 y 的自由出现，第2、3、4、5、6、7都是公式中 y 的约束出现；</p></blockquote></li><li><p>约束关系：各个量词和变元的出现间的约束上的关系；</p><p>确定约束关系的过程：确定”公式中哪个变元的哪些出现受哪个量词的约束“的过程；</p></li><li><p>自由变元、约束变元；</p><p><strong>同一变元在一个公式中可能既是自由变元，又是约束变元</strong>；</p><p><strong>在一阶谓词逻辑中，认为命题变元、谓词变元都是自由变元，不受量词约束</strong>；</p></li><li><p>改名：将一个变元改为另一个变元，并要求改名后的式子与原来的式子语义相同</p><ul><li>改名<strong>针对约束变元</strong>而言，不能对自由变元改名；</li><li>改名必须同时对原式中该变元的一切受<strong>某个量词约束</strong>的约束出现<strong>均</strong>改名（<strong>同约束全替换</strong>）；</li><li>改名后的名字不允许和作用域中其他自由变元同名；（会改变约束关系）</li><li>改名后，<strong>一般</strong>不与作用域中约束变元同名，因为容易混；</li></ul></li><li><p>代入：将一个变元代以式子（式子的变域与变元变域要相同），要求代入后的式子是原式的特例；（不要求等值）</p><ul><li>代入<strong>针对自由变元</strong>而言，约束变元不允许代入；</li><li>代入式当中的变量名不能与原式作用域中的约束变量同名；</li><li>同一自由变元出现<strong>全部替换</strong>；</li></ul><blockquote><p>可以的：命题变元代入公式、个体变元代入项、谓词变元代入同元谓词；</p></blockquote></li></ul><p><strong>总结：1、只要没改变约束关系的、不引发歧义的改名、代入都行；</strong></p><p>​            <strong>2、要改全改，要代全代</strong>；</p><blockquote><p>$\forall y(p\rightarrow Ay)$ 可以将 p（命题变元）代入为 $\exists yBxy$，因为没有歧义、没有改变约束关系；</p></blockquote><p>​    <strong>一个公式的关系</strong></p><ul><li><p>谓词演算公式的永真性、可满足性</p><p>【POINT 1】<strong>谓词演算公式的真假与：个体域、自由变元（自由个体变元、谓词变元、命题变元）有关</strong>，和约束变元无关；</p><ul><li><p>谓词演算公式的成真指派、成假指派、有缺指派</p><p>一个一阶谓词演算公式 α，其自由个体变元 $x_1,x_2,…,x_h$，命题变元 $p_1,p_2,…,p_k$，谓词变元 $X_1,X_2,…,X_r$，则将 α 表示为：$\alpha(x_1,x_2,…,x_h;\space p_1,p_2,…,p_k;\space X_1,X_2,…,X_r)$；</p><p>若对其个体域 $I$ 的指派为 $I_0$（约束变元的全总个体域也变为 $I_0$），</p><p>对  $x_1,x_2,…,x_h$ 指派为： $\alpha_1,\alpha_2,…,\alpha_h$ 、对 $p_1,p_2,…,p_k$ 指派为 $p_1^0,p_2^0,…,p_k^0$、对  $X_1,X_2,…,X_r$ 指派为 $A_1,A_2,…,A_r$，则称对 α 作一个个体域 $I_0$ 上的指派 $(\alpha_1,\alpha_2,…,\alpha_h;\space p_1^0,p_2^0,…,p_k^0;\space A_1,A_2,…,A_r)$；</p><p><strong>在一个确定的个体域、自由个体变元、命题变元、谓词变元的指派下，公式 α 的真假值确定</strong>；</p><p>若该指派下公式的值为真，则称为成真指派，否则为成假指派；</p><p>若仅对 α 中的部分自由变元指派，则称该指派为 α 的一个有缺指派（有缺指派下公式不一定有确定的真假值）；</p></li></ul><p>【POINT 2】谓词演算公式的真假值确定的<strong>关键</strong>在于<strong>确定 $\forall x\alpha(x)$ 和 $\exists x \alpha(x)$ 的真假</strong>；</p><blockquote><p> $\forall x\alpha(x)$ 为真，当且仅当 I 中每个个体都使公式为真；</p><p> $\exists x \alpha(x)$ 为真，当且仅当 I 中至少有一个个体使公式为真；</p></blockquote><ul><li><p><strong>永真性（普遍有效性）、可满足性</strong>：若公式 α 对于个体域 I 中任何指派均取真值，则称 α 在 I 中永真；若 α 在每一个非空个体域中均永真，则称 α <strong>永真（普遍有效公式）</strong>；</p><blockquote><ol><li>可满足性的定义同理；</li><li>此处许多定理，例如 α、β 同真假 $\Longleftrightarrow$ α $\leftrightarrow$ β 永真，和命题逻辑类似，略去；</li></ol></blockquote><p><strong>重要定理：有限域上，公式的永真性、可满足性仅取决于个体域中的个体数</strong>；</p><blockquote><p>感性理解：如果公式的永真性取决于个体域中的不同个体的<strong>特征</strong>的话，那么就不是永真了；</p></blockquote><p>因此，将 $\{1,2,3,…,k\}$ 作为具有 k 个个体的个体域的代表（仅与数量有关，所以元素是啥都行），命名为 “k-域”，α 在 k 域上永真称为<strong>k-永真</strong>；</p></li><li><p>同永真性、同可满足性：α 永真当且仅当 β 永真，则称 α、β <strong>同永真性</strong>；</p></li></ul></li><li><p>有限域下的公式表示法：有限域 $D=\{1,2,3,…,k\}$ 不失一般性；</p></li></ul><script type="math/tex; mode=display">\begin{aligned}&\forall xP(x)=P(1)\wedge P(2)\wedge\cdots\wedge P(k)\\&\exists xP(x)=P(1)\vee P(2)\vee\cdots\vee P(k)\end{aligned}</script><blockquote><p><strong>当发现某些谓词演算公式难以理解时，尝试在 {1, 2} 域下展开</strong>；</p></blockquote><ul><li><p>全称封闭式、存在封闭式：将公式中的一切自由个体变元，构造出对应的全称量词并置于全式之前，则称得到的新公式为 α 的全称封闭式，记作$\Delta\alpha$；（存在封闭式同理）</p><p><strong>重要定理：α 与它的全称封闭式在每个域中同永真性、与它的存在封闭式在每个域中同可满足性</strong>；</p><blockquote><p>感性理解：一个公式一旦确定为永真，那么他的所有自由个体变元的所有取值都不影响它的真，所以它的全称封闭式也为真；</p></blockquote><p><strong>引入存在封闭式，可以将公理50 $\Delta(\forall x\alpha(x)\rightarrow\alpha(\xi))$、公理51 $\Delta(\alpha(\xi)\rightarrow\exists x\alpha(x))$ 没有歧义地表述，不容易造成误解和错用</strong>；</p></li></ul><p>​    <strong>两个公式的关系</strong></p><ul><li><p>谓词演算公式的同真假性、在 I 上同真假性（或者说<strong>等值</strong>）：设有公式 α、β，若对个体域 I 的每一指派，α、β 均取相同真假值，则称 α、β <strong>在 I 上同真假</strong>；若 α、β 在每个非空域上同真假，则称二者<strong>同真假</strong>；</p><p><strong>谓词演算公式同真假公式记忆：</strong></p><ul><li><p>$\overline{\forall}x\alpha(x)=\exists x\overline\alpha(x)$、$\overline{\exists}x\alpha(x)=\forall x\overline\alpha(x)$；（<strong>量词否定的同真假变换</strong>）</p></li><li><p>$\overline\forall x\exists y\alpha(x)=\exists x\forall y\overline\alpha(x)$（<strong>对多个量词的否定同真假变换，多少个量词都一样</strong>）</p></li><li><p>$\forall x(\alpha(x)\vee\gamma)=\forall x\alpha(x)\vee\gamma$、$\forall x(\alpha(x)\wedge\gamma)=\forall x\alpha(x)\wedge\gamma$</p><p>$\exists x(\alpha(x)\vee\gamma)=\exists x\alpha(x)\vee\gamma$、$\exists x(\alpha(x)\wedge\gamma)=\exists x\alpha(x)\wedge\gamma$；（<strong>量词与”自由公式“的结合律</strong>）</p><p>（γ 为<strong>不含自由变元 x </strong>的公式）</p><p><strong>请注意：如果涉及蕴含符号，请自行推导，结论是不同的！</strong></p></li></ul><p><strong>第二组重要的等值公式：相关约束分配律</strong></p><ul><li><p>$\forall x(P(x)\wedge Q(x))=\forall xP(x)\wedge\forall xQ(x)$</p><p>$\exists x(P(x)\vee Q(x))=\exists xP(x)\vee\exists xQ(x)$</p><p><strong>分开个体不必相同，原因在于：理解为有限域下公式表示，是否展开为连续的 $\wedge$ 和 $\vee$</strong>；</p></li><li><p>$(\forall x)P(x)\vee(\forall x)Q(x)=\forall x\forall y(P(x)\vee Q(y))$</p><p>$(\exists x)P(x)\wedge(\exists x)Q(x)=\exists x\exists y(P(x)\wedge Q(y))$</p><p><span id="diff"><strong>分开不一定相同，一般情况是 $(\forall x)P(x)\vee(\forall x)Q(x)$、$\exists x(P(x)\wedge Q(x))$ 更强一些：</strong></span></p><p>$\forall xP(x)\vee \forall xQ(x)\Rightarrow \forall x(P(x)\vee Q(x))$</p><p>$\exists x(P(x)\wedge Q(x))\Rightarrow\exists xP(x)\wedge\exists xQ(x)$</p><p>记忆方法可以采用<strong>“唱歌跳舞解释法”</strong>：例如，班里所有人都会唱歌 或 班里所有人都会跳舞 <strong>强于</strong> 班里所有人都会唱歌或跳舞（因为可能恰好一部分人只会唱歌、另一部分人只会跳舞，这样满足后者，却不满足前者）</p></li></ul></li></ul><ul><li><p>前束型公式、准前束型公式：一个公式的量词都在开头，它们的作用域延伸到全式的末尾，称这样的公式为<strong>前束型公式</strong>；由前束型公式利用真值联结词作成的公式称为<strong>准前束型公式</strong>；</p><blockquote><p>$\forall x\exists y\forall z(Xxy\rightarrow Yyz)$ 为前束型公式，$\forall x\exists yXxy\wedge\forall y\exists zYyz$ 为准前束型公式；</p></blockquote></li><li><p><strong>前束范式定理：任何一个谓词演算公式都与一个前束型公式同真假（称此前束型公式为前束范式）</strong></p><blockquote><p><strong>前束范式不唯一！</strong></p></blockquote><p>⚠<strong>完全不建议、甚至禁止将蕴含词、等价词留在式中，因为考虑否定深入，需要将这些属性的词展开，有时甚至不展开是错误的！因为量词在进出这些运算符时可能多了一层否定</strong></p><p><strong>将公式转化为前束范式的思路：</strong></p><p>step 1. 否定深入，将量词上的否定转移到作用域内部（利用前面两条同真假公式）；</p><p>step 2. 适当改名：规避将量词提出时的重名错误；（考虑约束关系会不会在提出后有歧义或改变）</p><p>step 3. 根据同真假公式，依此提出内层的量词开头的公式；</p></li><li><p>Skolem 标准型：一阶谓词逻辑的任一公式 α，若：</p><ol><li>其前束范式中所有的存在量词都在全称量词的左边（<strong>$\exists$ 前束范式</strong>），</li><li>或者，仅保留全称量词而消去存在量词（<strong>$\forall$ 前束范式</strong>）</li></ol><p>则得到的 α 的新公式称为 <strong>skolem 标准型</strong>；</p><p>⚠<strong>skolem 标准型一定无法像前束范式一样，与原式保持完全等值的关系，只能保持一定意义上的“关系”</strong></p><ul><li><p>$\exists$ 前束范式：$\exists x_1\exists x_2\cdots\exists x_i\forall x_{i+1}\cdots\forall x_nM(x_1,x_2,…,x_n)$，保证 i ≥ 1且 M 内<strong>不含量词和自由个体变元</strong>；</p><p><strong>$\exists$ 前束范式定理：FOL（一阶谓词逻辑）的任一公式 α 都能写成与之对应的（不一定等值）$\exists$ 前束范式，且 <u>α 和 其 $\exists$ 前束范式同永真性</u></strong></p><blockquote><p>所以 一般当 α 永真时，或者想要进行<strong>同永真转换</strong>时，才使用 $\exists$ 前束范式；</p></blockquote></li><li><p>$\forall$ 前束范式：仅保留全称量词的前束范式</p><p><strong>$\forall$ 前束范式定理：FOL 的任一公式 α 都能写成与之对应的（不一定等值）$\forall$ 前束范式，且 <u>α 和 其 $\forall$ 前束范式同可满足性</u></strong></p><blockquote><p>所以 一般当 α 永假时，或者想要进行<strong>同不可满足转换（通常是谓词演算公式的归结推理）</strong>时，才使用 $\forall$ 前束范式；</p></blockquote></li></ul></li></ul><h3 id="2-2-谓词演算公式的推理演算"><a href="#2-2-谓词演算公式的推理演算" class="headerlink" title="2.2 谓词演算公式的推理演算"></a>2.2 谓词演算公式的推理演算</h3><ul><li><p>较之命题演算新增 4 个规则：</p><ol><li><p>全称量词消去（公理50）${\forall xP(x)}\over{\therefore\space P(y)}$ 和 ${\forall xP(x)}\over{\therefore\space P(c)}$</p><ul><li>要求取代的自由变元不能在原式中约束出现（否则改变约束关系，这个一般不会违反）</li><li>必须取代所有的 该变元（消去全称量词的指导变元对应的变元，一般也不会违反）</li></ul><blockquote><p>提示：全称量词的消去有两种使用方法，一种是左边的消去为全域的自由变量 y，另一种是消去为个体常量 c； </p></blockquote></li><li><p>全称量词引入（全“0”规则）${P(y)}\over{\therefore\space\forall xP(x)}$</p><ul><li><p><strong>要求左式 $P(y)$ 中的 y 是使公式为真的<u>自由个体变元</u></strong></p><blockquote><p>具体是要求查找前面所有<strong>假设</strong>中，y 是否自由出现，如果是，一定<strong>不满足</strong>这个条件；</p></blockquote></li><li><p>取代 y 的 x 约束变元不能在 P(y) 中约束出现（否则改变约束关系，这个一般不违反）</p></li></ul></li><li><p>存在量词消去（<strong>存在假设</strong>）${\exists xP(x)}\over{\therefore\space P(e)}$</p><ul><li>要求右式的 e 必须是使公式为真的<strong>个体常项</strong>，不在 P 中出现；</li><li>要求 P <strong>不能有自由个体变元</strong>，会导致个体域混淆；</li></ul></li><li><p>存在量词引入（公理51）${P(c)}\over{\therefore\space\exists xP(x)}$</p><ul><li>要求个体常项 c 不在 P 中其他地方出现；</li></ul></li></ol></li><li><p>归结推理：在命题逻辑处理的基础上，将“同不可满足公式”转换为 $\forall$ 前束范式，略去全称量词、$\wedge$ 以逗号相连，构成子句集，归结方法：<strong>$R(x)\vee Q(x)$ 和 $\overline R(a)\vee P(y)$ 归结为 $Q(a)\vee P(y)$</strong>（不是x 的原因是：在子句集中，看起来是自由变元的都是全称变元），直至空子句；</p><p><strong>为了方便起见，一般不完全写出 $\forall$ 前束范式，而是对由合取联结的几个部分分别求子句集，最后求并集；</strong>虽然与原子句集不一样，但它们的可满足性是一致的；</p></li><li><p>推理小结论</p><ul><li><p><a href="#diff">相关约束分配律的大小关系🔗</a></p></li><li><p>$\forall x\forall yP(x,y)$ 强于 $\exists x\forall yP(x,y)$ 强于 $\forall x\exists yP(x,y)$ 强于 $\exists x\exists yP(x,y)$</p></li><li><p>一般情况下，量词<strong>一定不具备对于等价词的分配律</strong>：因为将等价词拆为双向蕴含词的合取，如果要分配，就意味着同时对 析取、合取 两种运算分配，这无论是全称量词还是存在量词都是不可接受的；</p><blockquote><p>例如：$\exists x(P(x)\leftrightarrow Q(x))\rightarrow(\exists xP(x)\leftrightarrow\exists xQ(x))$ 不是普遍有效的；</p><p>可以将 $P(x)\leftrightarrow Q(x)$ 拆开成 $(P(x)\rightarrow Q(x))\wedge(Q(x)\rightarrow P(x))$ 理解；</p></blockquote></li></ul></li></ul><h3 id="2-3-常见题型"><a href="#2-3-常见题型" class="headerlink" title="2.3 常见题型"></a>2.3 常见题型</h3><ul><li><p>自然语言的形式化</p><p><strong>注意：如果语句中含有“不”或者其他否定的字样，建议将其提出谓词的定义中，例如：</strong></p><blockquote><p>“Qe：e 溶于水” 的定义好于：“Qe：e 不溶于水”</p></blockquote></li><li><p>谓词演算公式的改名和代入</p></li><li><p>给定一个指派，求谓词演算公式的真假值</p><p>step 1. 初步代入指派（尽可能代入谓词变元、命题变元、自由个体变元）；</p><p>step 2. <strong>由内向外</strong>逐层求<strong>由量词带头的</strong>子公式的值；<strong>如果不能求出，则转化为同一语境下同真假的式子</strong></p><blockquote><p>在子公式内部，应该将与指导变元不同的变元暂时视作自由变元；</p></blockquote><p>step 3. 遇到多个量词和指导变元针对一个作用域时，按照<strong>从左至右</strong>的顺序理解，不能交换顺序；</p></li></ul><ul><li><p>判断公式的永真性（普遍有效性）、可满足性</p><blockquote><p>但凡公式需要确认自由变元 才能判断真假的，都是仅可满足的；</p></blockquote><p><strong>只要将公式写出，那么它必然处于：永真性、仅可满足、不可满足（矛盾式）这三者特性之一！</strong></p><p><img src="rel.jpg" height="200px"></p><ul><li>想要证伪，则一般在 {1, 2} 域上列表格，“唱歌跳舞分析法”来查看，判断什么条件下能够生成反例，尤其对于蕴含式，设立一个前件正确、后件错误的才行；</li><li>想要证明，建议先看看证伪，发现无法证伪再来证明</li></ul><p>⚠易错点1：有些公式默认了自由变元的全总个体域：$\forall xP(x)\rightarrow P(y)$ 是普遍有效公式；</p><p>⚠易错点2：有些公式没有直接方法化简到 F/T，而且你记得它不是普遍有效公式，也不能直接判断，因为它可能在某些情况下成立，例如：$(\exists x P(x)\wedge\exists xQ(x))\rightarrow\exists x(P(x)\wedge Q(x))$ 是<strong>1-永真</strong>的，所以是可满足公式；</p></li></ul><ul><li>拓展：谓词演算公式的可判定性（<strong>针对一个演算系统而言，并非是对一个公式而言</strong>）</li></ul><ul><li><p>求公式对应的前束范式</p></li><li><p>求公式对应的 $\forall$ 前束范式 / $\exists$ 前束范式</p><blockquote><p>考试时注意：<strong>本教材（非主流）中除非强调，默认“skolem标准型”就是 $\forall$ 前束范式，不指 $\exists$ 前束范式</strong>；</p></blockquote><p><strong>转换为 $\exists$ 前束范式的基本思路：</strong></p><ol><li><p>将公式转换为前束范式；</p></li><li><p>以 $\exists x_1\exists x_2\cdots\exists x_i\forall x_{i+1}\exists x_{i+2}\cdots\exists x_nM(x_1,x_2,…,x_n)$ 为例（因为都可以转化为：存在量词中间夹一个全称量词的情况）：</p><p>引入 $\forall x_{i+1}$ 前的所有指导变元（<strong>默认从左到右消除全称量词</strong>），包括自己，作为新的谓词（没有出现过）的填式：$S(x_1,x_2,…,x_i,x_{i+1})$ ，其中 S 是自由变元，可以取个体域上所有谓词；这样：</p><script type="math/tex; mode=display">\begin{aligned}&\exists x_1\exists x_2\cdots\exists x_i\forall x_{i+1}\exists x_{i+2}\cdots\exists x_nM(x_1,x_2,...,x_n)\\=&\exists x_1\exists x_2\cdots\exists x_i\exists x_{i+1}\exists x_{i+2}\cdots\exists x_n(M(x_1,x_2,...,x_n)\wedge\overline S(x_1,x_2,...,x_{i+1})\vee\forall yS(x_1,x_2,...,x_i,y))\\=&\exists x_1\exists x_2\cdots\exists x_i\exists x_{i+1}\exists x_{i+2}\cdots\exists x_n\forall y(M(x_1,...,x_n)\wedge\overline S(x_1,...,x_{i+1})\vee S(x_1,...,x_i,y))\end{aligned}</script></li><li><p>如上面公式的最后一步，将任意的 y 利用结合律提出，循环此过程直至变为  $\exists$ 前束范式；</p></li></ol><p><strong>转换为 $\forall$ 前束范式的基本思路：</strong></p><ol><li>将公式转换为前束范式；</li><li>以 $\forall x_1\forall x_2\cdots\forall x_i\exists x_{i+1}\forall x_{i+2}\cdots\forall x_nM(x_1,x_2,…,x_n)$ 为例，因为都可以转化为：全称量词中间夹一个存在量词的情况）：<ul><li>如果 $x_{i+1}$ 左边没有（全称）量词（<strong>也默认从左到右消除</strong>），即 i = 0，那么只要在作用域中将所有 $x_{i+1}$ （一定是自由出现）代以一个从未出现的自由变元名，例如 y：$M(y,x_2,…,x_n)$，直接删除 $\exists x_{i+1}$ 即可；</li><li>如果 $x_{i+1}$ 左边有（全称）量词，则将 $x_{i+1}$ <strong>替换为</strong>左边出现的所有全称量词指导变元构成的自由变元-函词填式（从未出现过该名字，例如 f）：$f(x_1,x_2,…,x_i)$，构成：$M(x_1,x_2,…,x_i ,f(x_1,x_2,…,x_i),x_{i+2},…,x_n)$​，直接删除 $\exists x_{i+1}$ 即可；</li></ul></li><li>循环上面的过程直至变为  $\forall$ 前束范式；</li></ol></li></ul><ul><li><p>分析谓词演算公式证明的正确性</p></li><li><p>谓词演算公式的推理证明</p><blockquote><p>推理中如果使用到了推理结论，例如：$P(x)\wedge Q(x)\Rightarrow P(x)$，在原因一栏写“重言蕴含”，这对于<strong>命题逻辑</strong>的推理也是这样的！</p></blockquote></li></ul><h2 id="Chapter-3-集合论"><a href="#Chapter-3-集合论" class="headerlink" title="Chapter 3 集合论"></a>Chapter 3 集合论</h2><h3 id="3-1-重要概念集合"><a href="#3-1-重要概念集合" class="headerlink" title="3.1 重要概念集合"></a>3.1 重要概念集合</h3><ul><li><p>集合定义（确定性、互异性、无序性）、属于不属于定义；</p></li><li><p>⚠集合元素不能是其自身（罗素悖论）=&gt; 抽象公理错误，不能任给一个性质就能构造一个对应的集合；</p></li><li><p>集合表示法：字母约定、外延表示法（穷举）、内涵表示法（谓词描述性质）；</p></li><li><p>集合间的关系</p><ul><li><strong>外延公理：一个集合由它的元素完全确定</strong>；</li><li>相等关系：由外延公理可以写出定义，下略；</li><li><p>子集（包含关系）、否定包含关系、真子集（真包含关系）；</p><ul><li><strong>相等包含定理（证明两集合相等时常用）：$A=B\Longleftrightarrow(A\subseteq B)\wedge(B\subseteq A)$</strong>；</li><li>包含关系的三条性质：自反、反对称、传递；（属于关系没有传递的性质）</li></ul></li><li><p>相交关系：两集合是否有公共元素；没有称<strong>不相交的</strong>；</p></li></ul></li><li><p>特殊集合</p><ul><li>空集：不含任何元素的集合，记 $\phi$；<ul><li>性质1：包含于<strong>任意集合</strong>；</li><li>性质2：<strong>空集的唯一性</strong>（外延定理说明）；</li></ul></li><li>全集：在<strong>给定的问题</strong>中，所考虑所有事物的集合；</li></ul></li><li><p>集合运算</p><ul><li><p>并集、交集、差集（“差集”相对于“被差集”的相对补集）、余集（高中的“补集”）、对称差集（异或）；</p></li><li><p>广义交集、广义并集（<strong>针对集合的元素全是集合的集合</strong>）；</p><blockquote><p>规定 $\bigcup\phi=\phi$，$\bigcap\phi$ 没有意义；</p></blockquote></li><li><p>幂集：集合的幂集是该集合所有子集组成的集合，记 $P(A)$</p><ul><li>性质1：幂集的元素全部是集合，无论 A 有没有元素；</li><li>性质2：$\phi\in P(A)$、$A\in P(A)$；</li></ul></li><li><p>笛卡尔积</p><blockquote><p>定义“有序对”：两个元素 x、y（允许 x = y）按给定次序排列组成的二元组合称为一个~；</p><p><strong>有序对的集合定义：$\langle x,y\rangle=\{\{x\},\{x,y\}\}$</strong>；</p><p>有序对性质定理：</p><p>$x\ne y\space\Rightarrow\space\langle x,y\rangle\ne\langle y,x\rangle$</p><p>$\langle x,y\rangle=\langle u,v\rangle\space\Rightarrow\space x=u\wedge y=u$</p></blockquote><p>定义：集合 A 与 B 的笛卡尔积 $A\times B=\{z\space|\space x\in A\wedge y\in B\wedge z=\langle x,y\rangle\}$；</p><blockquote><p>A = B 时，可以写作：$A^2$；</p></blockquote><p>以上可以推广到 n 维空间；</p><p><strong>注意：无论多少阶，都不存在“一个集合中选多个元素作为 n 元组”的情况，参考坐标点</strong>；</p></li></ul></li><li><p>运算符优先级：大致是 <strong>集合运算符＞真值联结词＞逻辑关系符</strong>；</p></li><li><p>集合的图形表示法：韦恩图（交并补）、哈斯图（幂集）、笛卡尔坐标系图示法；</p></li><li><p><strong>集合重要运算性质（记忆）</strong></p><ul><li><p>运算律：基本运算由联结词定义，所以性质相似，此处仅补充少见的运算律</p><script type="math/tex; mode=display">A-(B\cup C)=(A-B)\cap(A-C)\\A-(B\cap C)=(A-B)\cup(A-C)</script></li><li><p>运算性质：以差集为例</p><script type="math/tex; mode=display">\begin{aligned}A-B&=A-(A\cap B)\\A\cap(B-C)&=(A\cap B)-C\\A-B&=A\cap-B\end{aligned}</script><p><strong>最后一条极其重要，常用于差集运算符消去</strong>；</p></li><li><p>基本关系运算性质</p><script type="math/tex; mode=display">A\cup B=B\Longleftrightarrow A\subseteq B\Longleftrightarrow A\cap B=A\Longleftrightarrow A-B=\phi</script><p><strong>最后一步启示我们：在证明式中含有 $\phi$ 时，建议将式中的差运算符留到最后</strong>；</p><p>例如证明：$(A-B)\oplus(A-C)=\phi\Longleftrightarrow A-B=A-C$ 的时候；</p></li><li><p>幂集性质</p><ul><li>$A\subseteq B\Longleftrightarrow P(A)\subseteq P(B)$；</li><li>$A=B\Longleftrightarrow P(A)=P(B)$；</li><li>$P(A)\in P(B)\Longrightarrow A\in B$，逆命题不成立（A={Φ}，B=）；</li><li>$P(A)\cap P(B)=P(A\cap B)$；</li><li>$P(A)\cup P(B)\subseteq P(A\cup B)$；</li><li>$P(A-B)\subseteq(P(A)-P(B))\cup\{\phi\}$；</li><li>$\bigcup P(A)=A$；（广义并集和幂集互为逆运算）</li></ul><blockquote><p>传递集合的通俗定义：满足以下 2 点的集合是传递集合</p><ol><li>A 的元素都是集合；</li><li>如果有的话，A 的元素的元素都是 A 的元素；</li></ol><p>外延定理的描述：$A为传递集合\Longleftrightarrow \forall x\forall y((x\in y\wedge y\in A)\rightarrow x\in A)$；</p><ul><li><strong>性质1：$A为传递集合\Longleftrightarrow A\subseteq P(A)$；</strong></li><li><strong>性质2：$A为传递集合\Longleftrightarrow P(A)也为传递集合$；</strong></li></ul></blockquote></li><li><p>笛卡尔积性质：不满足交换律、结合律，但满足对 $\cap$ 和 $\cup$ 的分配律；</p><ul><li>$x\in A,\space y\in A\Rightarrow\langle x,y\rangle\in PP(A)$</li><li>$A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C)\Leftrightarrow(C\times A\subseteq C\times B),\space where\space C\ne\phi$</li><li>$(A\times B\subseteq C\times D)\Leftrightarrow(A\subseteq C\wedge B\subseteq D),\space where\space A,B,C,D\ne\phi$</li></ul></li></ul></li><li><p>集合的基数（讨论有限集合）：规定 $|\phi|=0$</p></li></ul><h3 id="3-2-常见题型"><a href="#3-2-常见题型" class="headerlink" title="3.2 常见题型"></a>3.2 常见题型</h3><ul><li><p>写出给定集合的幂集</p></li><li><p>判断传递集合</p></li><li><p>给实际应用场景，求某个部分的基数</p><blockquote><p>例如：参加 A 的有 x 人，参加 B 的有 y 人……，有 z 个人同时参加了……，诸如此类；</p></blockquote><p><strong>思路：Venn 图，或者概率统计的加法公式（把求概率改成求基数即可）：$P(\bigcup\limits_{i=1}^n{A_i})=\sum\limits_{i=1}^nP(A_i)-\sum\limits_{1\le i\le j\le n}P(A_iA_j)+\cdots+(-1)^{n-1}P(A_1A_2\cdots A_n)$</strong>；</p></li><li><p>以谓词演算公式和集合定理，证明集合公式</p><p><strong>技巧总结</strong></p><ul><li><p>过于基本的式子，比如用三段论一步解决的：$A\in B\wedge B\subseteq C\Rightarrow A\in C$；</p><blockquote><p>建议直接推，如果需要改成谓词，就该，例如上面的题目的证明：</p><p>$A\in B\wedge B\subseteq C\Leftrightarrow A\in B\wedge\forall x(x\in B\rightarrow x\in C)\Rightarrow A\in C$；</p></blockquote></li><li><p>对于非定理式的、基本运算式的证明，一般采用：</p><ol><li><strong>等式证明：集合等值记忆式</strong>；</li><li>等价证明：集合常用等价关系（<strong>相等-包含关系、基本关系运算性质、幂集的性质</strong>）</li><li>重言蕴含证明：集合常用的推导方式（例如：等值运算、<strong>外延定理分解为谓词逻辑</strong>）</li></ol><p>e.g., 证明以下运算式</p><script type="math/tex; mode=display">\begin{aligned}&1.\space A\cap(B\oplus C)=(A\cap B)\oplus(A\cap C)\\&2.\space (A-B)\oplus(A-C)=\phi\Longleftrightarrow A-B=A-C\\&3.\space A\cup B=A\cup C\space且\space A\cap B=A\cap C\Longrightarrow B=C\\&4.\space P(A)\in P(B)\Longrightarrow A\in B\end{aligned}</script></li><li><p>对于定理式的证明（上一则技巧无法解决），一般采用：</p><ol><li>等式 / 重言蕴含的证明：使用外延定理分解为谓词逻辑，记得先声明 $\forall x$ ，从等式左边定义等价 / 重言蕴含推导，中途有必要可以引入新的约束变元，但量词要写在里面；（如果是关于笛卡尔积、二元组的证明，可以写 $\forall \langle x,y\rangle$）</li><li>等价证明：一般拆成双侧重言蕴含；如果是较为简单的、一眼看出的，可以一直等价到底；</li></ol><p>e.g., 证明下列各式：</p><script type="math/tex; mode=display">\begin{aligned}&1.\space A-B=A-(A\cap B)\\&2.\space A-B=A\cap-B\\&3.\space A\subseteq B\Longleftrightarrow P(A)\subseteq P(B)\\&4.\space A为传递集合\Longleftrightarrow P(A)为传递集合\end{aligned}</script></li><li><p>对于仅由集合运算符连接的式子的证明，要么一直使用等价变换，要么使用外延定理定义转化为谓词逻辑证明；</p><p>e.g., 证明以下式子：</p><script type="math/tex; mode=display">\begin{aligned}&1.\space P(A)\cup P(B)\subseteq P(A\cup B)\\&2.\space P(A-B)\subseteq(P(A)-P(B))\cup\{\phi\}\end{aligned}</script></li></ul></li></ul><h3 id="3-3-错题"><a href="#3-3-错题" class="headerlink" title="3.3 错题"></a>3.3 错题</h3><ul><li><p>证明：$A\subseteq P(\bigcup A)$</p><p><strong>错因：忘记考虑 $A=\phi$ 的情况需要分开讨论</strong>；</p></li></ul><h2 id="Chapter-4-关系"><a href="#Chapter-4-关系" class="headerlink" title="Chapter 4 关系"></a>Chapter 4 关系</h2><h3 id="4-1-重要概念集合"><a href="#4-1-重要概念集合" class="headerlink" title="4.1 重要概念集合"></a>4.1 重要概念集合</h3><ul><li><p>二元关系（<strong>有序对的集合</strong>）：若一个集合满足以下两个条件之一：</p><ol><li>集合非空，且它的元素均为有序对；</li><li>集合为空集；</li></ol><p>则称该集合为一个二元关系；记为 R，简称<strong>关系</strong>；</p></li><li><p>A 至 B 的二元关系：设 A，B 为集合，则 A × B 的<strong>任一子集</strong>所定义的二元关系，称为 <strong>A 到 B 的二元关系</strong>；</p><p>$R\subseteq\{\langle x,y\rangle|\space x\in A\wedge y\in A\}$（可以推广至 n 元关系）</p></li><li><p>特殊关系</p><ul><li>恒等关系：$I_A=\{\langle x,x\rangle|\space x\in A\}$</li><li>全域关系：$E_A=A\times A$</li><li>空关系：$\phi\subseteq A\times A$</li></ul></li><li><p>关系的定义域 $dom(R)$、值域 $ran(R)$、域 $fld(R)$（定义域和值域的并）</p></li><li><p>关系的表示</p><ul><li><p>关系矩阵：对于集合 $X=\{x_1,…,x_m\}$，$Y=\{y_1,…,y_n\}$，若 R 为从 X 到 Y 上的一个关系，则 R 的关系矩阵（bool 矩阵）为 $M(R)=(r_{ij})_{m\times n}$（如果有序对 $\langle x,y\rangle$ 在 $X\times Y$ 中，则 $r_{ij}=1$，否则为0）；</p><blockquote><p>起始集合元素为<strong>行</strong>，目的集合元素为<strong>列</strong>；</p></blockquote></li><li><p>关系图：使用<strong>有向边</strong>表示两个集合元素点的关系；</p></li></ul></li><li><p>关系的运算（设 R 为 X 到 Y 的关系，S 为 Y 到 Z 的关系）</p><ul><li><p>逆：$R^{-1}=\{\langle x,y\rangle|\space \langle y,x\rangle\in R\}$</p></li><li><p>合成：$S\circ R=\{\langle x,y\rangle|\space \exists z(\langle x,z\rangle\in R\space\wedge\langle z,y\rangle)\in S\}$</p><blockquote><p>遵循和函数复合一样的含义，内层先运算；</p></blockquote></li><li><p>A 在 R 下的象：$R[A]=\{y\space|\space\exists x(x\in A\space\wedge\langle x,y\rangle\in R)\}$</p></li><li><p>R 在 A 下的限制：$R\uparrow A=\{\langle x,y\rangle|\space \langle x,y\rangle\in R \wedge x\in A\}$</p><blockquote><p>象和限制可以理解为生物学上的“<strong>平板影印</strong>”，象是将 存在关系 R 中的元素影印在 A 上，限制是将 存在于 A 中的元素影印到 R 上；没有被影印到的元素就被抛弃；</p></blockquote></li></ul><p><strong>补充：关系矩阵和定义的联系：第一部分</strong></p><ol><li>关系的逆<strong>相当于关系矩阵的转置</strong>：$M(R^{-1})=M^T(R)$</li><li>关系的复合<strong>相当于关系矩阵逻辑乘法</strong>：$M(S\circ R)=M(R)\cdot M(S)$</li></ol></li><li><p>关系的运算性质</p><ul><li><p>逆的性质</p><ol><li>关系的逆会使定义域和值域对调；</li><li>$(R^{-1})^{-1}=R$</li><li>$(S\circ R)^{-1}=R^{-1}\circ S^{-1}$</li></ol></li><li><p>关系合成结合律：$(R\circ S)\circ Q=R\circ(S\circ Q)$</p><p><strong>关系合成不符合交换律：$R\circ S\ne S\circ R$</strong>；</p></li><li><p>关系合成对<strong>并运算</strong>满足分配律：</p><p>$R_1\circ(R_2\cup R_3)=R_1\circ R_2\cup R_1\circ R_3$</p><p>$(R_1\cup R_2)\circ R_3=R_1\circ R_3\cup R_2\circ R_3$</p><p><strong>关系合成对 交运算 不满足分配律：</strong></p><p>$R_1\circ(R_2\cap R_3)\subseteq R_1\circ R_2\cap R_1\circ R_3$</p><p>$(R_1\cap R_2)\circ R_3\subseteq  R_1\circ R_3\cap R_2\circ R_3$</p></li></ul></li><li><p>关系的性质（设 R 为集合 A 上的关系）</p><p><strong>第一组：自反性</strong></p><ul><li><p>自反性：$R在A上自反\Longleftrightarrow\forall x(x\in A\rightarrow\langle x,x\rangle\in R)$</p><p>反自反性（在有些教材里被称为非自反性）：$R在A上反自反\Longleftrightarrow \forall x(x\in A\rightarrow\langle x,x\rangle\notin R)$</p><p>非自反性（不常用）：<strong>即自反性的反面，“不自反的都算非自反”</strong>，下面将不再赘述；</p></li><li><p><strong>补充：关系矩阵和定义的关系</strong></p><ol><li>R 自反 当且仅当：M(R) <strong>全部对角线元素=1</strong>；</li><li>R 反自反 当且仅当：M(R)<strong>全部对角线元素=0</strong>；</li><li>R 非自反 当且仅当：M(R)对角线元素<strong>不全为1</strong>；</li></ol><blockquote><p>注：对于关系图而言，图上有自环；</p></blockquote></li><li><p><strong>自反性的重要结论</strong>：</p><ol><li><p>$R是自反的\Longleftrightarrow I_A\subseteq R$（反自反可以同理）</p></li><li><p>$R是自反的\Longleftrightarrow R^{-1}是自反的$</p><p>$R_1,\space R_2是自反的\Longleftrightarrow R_1\cup R_2和R_1\cap R_2是自反的$</p><p>（反自反完全相同）</p></li><li><p><strong>$R_1,R_2是自反的\Longleftrightarrow R_1\circ R_2$ </strong>（<strong>反自反不满足这个性质</strong>）</p></li></ol></li><li><p>自反关系的 Venn 图</p></li></ul><p><img src="reflective.jpg" height="200px"></p><p><strong>第二组：对称性</strong></p><ul><li><p>对称性：$R在A上对称\Longleftrightarrow \forall x\forall y(x,y\in A\rightarrow(xRy\rightarrow yRx))$</p><p>反对称性：$R在A上反对称\Longleftrightarrow\forall x\forall y(x,y\in A\rightarrow(xRy\rightarrow\neg yRx))$</p><p>非对称性：略；</p><blockquote><p>反对称性根据题目证明的要求，还可以写成：</p><p>$\forall x\forall y(x,y\in A\wedge xRy\wedge yRx\rightarrow x=y)$</p><p>$\forall x\forall y(x,y\in A\wedge xRy\wedge x\ne y\rightarrow \neg yRx)$</p><p>等</p></blockquote></li><li><p><strong>补充：关系矩阵和定义的关系</strong></p><ul><li>R 对称 当且仅当：M(R)<strong>为对称阵</strong>；</li><li>R 反对称 当且仅当：<strong>M(R) 的所有对称位不同时为1</strong>；（可以同时为0）</li><li>R 非对称 当且仅当：M(R) <strong>不为对称阵</strong>；</li></ul></li><li><p><strong>对称性重要结论</strong>：</p><ol><li><p>$R为对称的\Longleftrightarrow R=R^{-1}$</p><p>$R_1,\space R_2是对称的\Longleftrightarrow R_1\cup R_2和R_1\cap R_2是对称的$</p></li><li><p><strong>反对称有特殊</strong>：$R_1\cup R_2不一定反对称$</p><p>$R为反对称\Longrightarrow R\cap R^{-1}\subseteq I_A$</p></li><li><p><strong>复合运算完全不行！</strong></p></li></ol></li><li><p>对称关系的 Venn 图</p></li></ul><p><img src="symmetric.jpg" height="200px"></p><p><strong>第三组：传递性</strong></p><ul><li><p>传递性：$R在A上传递\Longleftrightarrow\forall x,y,z\in A(xRy\wedge yRz\rightarrow xRz)$</p><p>反传递性：$R在A上反传递\Longleftrightarrow\forall x,y,z\in A(xRy\wedge yRz\rightarrow\neg xRz)$</p><p>非传递性：略；</p></li><li><p><strong>传递性重要性质</strong>：</p><ol><li>传递性和自反性、对称性一样，满足性质的关系的<strong>逆、交</strong>都是传递的，<strong>但并运算不是</strong>；</li><li><strong>复合运算还是不行……</strong></li></ol></li></ul></li><li><p>关系性质的总结：如果 R 具有对应的关系那么……</p><table>    <tr>        <td>(是否具有？)</td>        <td>自反性</td>        <td>对称性</td>        <td>传递性</td>        <td>反自反性</td>        <td>反对称性</td>        <td>反传递性</td>    </tr>    <tr>        <td>R的逆关系</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>    </tr>    <tr>        <td>R的并关系</td>        <td>✔</td>        <td>✔</td>        <td>❌</td>        <td>✔</td>        <td>❌</td>        <td>❌</td>    </tr>    <tr>        <td>R的交关系</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>        <td>✔</td>        <td>❌</td>    </tr>    <tr>        <td>R的复合关系</td>        <td>✔</td>        <td>❌</td>        <td>❌</td>        <td>❌</td>        <td>❌</td>        <td>❌</td>    </tr></table></li><li><p>关系的闭包：某些关系不满足一些性质，为了方便研究，向关系集合中加入<strong>尽可能少的</strong>元素生成一个<strong>满足该性质的超集合</strong>，称为闭包；</p><ul><li><p>前置性质</p><ol><li><p>$R^0=I_A$</p></li><li><p>$R^{n+1}=R^n\circ R,\space R^m\circ R^n=R^{m+n},\space (R^m)^n=R^{mn}$</p></li><li><p>有限集上关系幂序列的周期性：若存在自然数 s、t 使得：$R^s=R^t$，则：</p><p>$R^{s+k}=R^{t+k},\space R^{s+kp+i}=R^{s+i}$</p><p>$B=\{R^0,R^1,…,R^{t-1}\}\Rightarrow\forall q\in N,\space R^q\in B$（思考：为何是最大的t？）</p></li></ol></li><li><p>闭包定义：设 R 为非空集合 A 上的关系，若 A 上有另一关系 R‘，满足：</p><ol><li>$R\subseteq R^\prime$（<strong>扩展得来</strong>）</li><li>$R^\prime$ 是具有对应性质的（扩展集具有性质）</li><li>对 A 上任何具有同样性质的关系 $R^{\prime\prime}$ 有：$R^\prime\subseteq R^{\prime\prime}$（<strong>扩展集最小</strong>）</li></ol></li><li><p>自反闭包记为 $r(R)$，对称闭包记为 $s(R)$，传递闭包记为 $t(R)$</p></li><li><p>闭包的性质</p><ol><li><p><strong>已有即当前</strong>：$R为自反的\Longleftrightarrow r(R)=R$（其他同理，下面不再赘述）</p></li><li><p>不同的关系可能多出“不在扩展中的元素”：$R_1\subseteq R_2\Rightarrow r(R_1)\subseteq r(R_2)$</p></li><li><p><strong>仅对并运算 + 自反/对称成立分配律</strong>：</p><p>$r(R_1)\cup r(R_2)=r(R_1\cup R_2)$</p><p>$s(R_1)\cup s(R_2)=s(R_1\cup R_2)$</p><p>$t(R_1)\cup t(R_2)\subseteq t(R_1\cup R_2)$</p></li><li><p><strong>闭包叠加</strong>：自反性“不受影响、不影响别人”，对称性“自己不受影响，只是会影响传递”，传递性“不影响别人，但会被对称性影响”</p><p>$R自反\Longrightarrow s(R),\space t(R)自反$</p><p>$R对称\Longrightarrow r(R),\space t(R)对称$</p><p>$R传递\Longrightarrow r(R)传递$</p><p>因此我们知道了，想要求叠加闭包，传递性质最脆弱，需要最后求传递闭包</p><p>$rs(R)=sr(R),\space rt(R)=tr(R),\space st(R)\subseteq ts(R)$</p><p>求“等价闭包”：$tsr(R)$ </p></li></ol></li><li><p>闭包的构造：若 R 不满足对应的性质</p><ul><li><p>$r(R)=R\cup R^0$</p></li><li><p>$s(R)=R\cup R^{-1}$</p></li><li><p>$t(R)=\bigcup\limits_{i=1}^\infty{R^i}$，特别地，对于有限非空集 A，一定存在一个正整数 $k\le|A|$，使得：$t(R)=R^+=\bigcup\limits_{i=1}^kR^i$</p><blockquote><p>这样的操作联想到图论中的<strong>求两点间是否有路径</strong>的算法，所以这里也可以使用 <a href="#Warshell">Warshell 算法 🔗</a></p></blockquote></li></ul></li></ul></li></ul><ul><li><p>等价关系、等价类、商集、划分</p><p>这一部分定义很长，这里仅仅说明一下对概念的理解：</p><ul><li><p>等价关系：<strong>同时满足自反、对称、传递的关系</strong></p></li><li><p>等价类：$[x]_R=\{y\space|\space y\in A\wedge xRy\}$，<strong>A 中所有和元素 x（包含自身）满足 R 关系的元素组成的集合</strong>；</p><p><strong>等价类的所有性质也可以理解为：相互等价的元素一定在一个集合（等价类）里，不相互等价的一定不在一个等价类里</strong>；</p></li><li><p>商集：A 的所有等价类构成的集合（是集合的集合）</p></li><li><p>划分：数学家们通过证明发现，用元素等价区分的方式刚好能够划分一个集合，也就是说，<strong>一个等价类和一个划分一一对应</strong>。数学上称为<strong>诱导</strong>，等价关系可以诱导出一个对应的划分，一个划分又可以诱导出一个对应的等价类；</p><p><strong>划分的性质</strong>：（数学形式描述请查阅资料）</p><ol><li>分块全部来自 A、且每个分块不为空；</li><li>所有分块完全覆盖 A；</li><li><strong>每个分块不重叠</strong>；</li></ol></li></ul></li><li><p>相容关系、相容类、覆盖</p><ul><li>相容关系：<strong>同时满足自反、对称（比等价关系缺少传递）的关系</strong>；</li><li>最大相容类性质：对任意不在最大相容类中的一个元素，总能找到类中的一个元素和它不满足相容关系；</li></ul><p><strong>只要理解覆盖和划分的区别，覆盖是每个分块能够重叠</strong>；</p><p><strong>完全覆盖的唯一性；覆盖能够确定一个相容关系、相容关系能够确定一个完全覆盖</strong>；</p><blockquote><p>在关系图中，找相容关系相当于找 <strong>所有的极大完全子图</strong>（这个分块内每个元素都要有相互的关系），边可以重叠</p></blockquote><ul><li><strong>由覆盖构造相容关系</strong>：给定非空集 A 上的一个覆盖 $\Omega=\{A_1,A_2,…,A_n\}$，则由其确定的关系 $R=\bigcup\limits_{i=1}^nA_i\times A_i$ 是 A 上的一个相容关系（不一定是最大相容关系）；</li></ul></li></ul><ul><li><p>偏序关系：同时满足<strong>自反、反对称、传递</strong>性质的关系</p><p>拟序关系：同时满足<strong>反自反、传递</strong>性质的关系（由这两个性质能推出<strong>反对称性</strong>）</p><blockquote><p>偏序关系能理解为抽象的 “≤” 关系</p><p>拟序关系能理解为抽象的 “＜” 关系</p></blockquote><p><strong>偏序关系和拟序关系仅在自反性上有差别，拟序和偏序讨论一个即可</strong></p><p>e.g.1, 对集合 A，在 P(A) 上的包含关系是偏序关系；在 P(A) 上的真包含关系是拟序关系；</p><p>e.g.2, 可以通过增添/删减自反性来变换两者：$R\rightarrow R-R^0\space或\space R\rightarrow R\cup R^0$</p></li><li><p>结构、偏序集</p><p>结构：集合 A 及其上的关系 R 一起称为一个<strong>结构</strong>；</p><p>偏序集：若结构中的关系 R 是偏序关系，称这个结构为<strong>偏序集</strong>，记作$\langle A,R\rangle$；</p><blockquote><p>$\langle N,\le\rangle$、$\langle P(A),\subseteq\rangle$ 都是偏序集</p></blockquote></li><li><p>哈斯图：由于偏序关系自反（自环）、反对称（两顶点间最多一条有向边），所以表达偏序关系的图可以：①省略自环；②适当安排位置（默认偏序箭头向上）不画边的方向；③不画传递得到的边，这种图称为哈斯图（描述性定义）；</p><p><strong>预定义：盖住关系，对偏序关系 $\langle A,\preccurlyeq\rangle$，若 $x,y\in A,\space x\preccurlyeq y,\space x\ne y$，且不存在 $z\in A$ 使得 $x\preccurlyeq z\wedge z\preccurlyeq y$，则称 y 盖住 x</strong>；（理解为抽象的<strong>直接后继关系</strong>）</p><p><strong>定理：对所有偏序集$\langle A,\preccurlyeq\rangle$，A 上的盖住关系 cov A 唯一</strong>；</p><p>画法：① 每个顶点代表 A 的一个元素；② 如果 $x\preccurlyeq y\wedge x\ne y$，将 y 置于 x 上方（后继在上）；③ 仅在 cov A 中有的关系才能在哈斯图上连接无向边（这保证了不画传递的边）；</p></li><li><p>可比：对于偏序集 $\langle A,\preccurlyeq\rangle$，若$\forall x,y\in A\Rightarrow x\preccurlyeq y\vee y\preccurlyeq x$，则称 x 和 y 可比；</p><blockquote><p><strong>不可比不代表不能讨论 x 和 y 的关系，只是说两者双向的 $\preccurlyeq$ 都是假而已</strong>；</p></blockquote></li><li><p>偏序关系的上下界</p><p>最小元的感性理解：必须<strong>和其他所有元素构成偏序关系，且它是所有元素的“前驱”</strong>；（最大元同理）；<strong>因此最小/大元不一定存在（不一定与所有都可比），但如果存在一定唯一</strong>；</p><p>极小元的感性理解：<strong>不能是某一个元素的“后继”就行</strong>，可以与某些元素不可比；<strong>因此极小元必然存在，可能不唯一</strong>；</p><p>上下界和上下确界：比较明显，意会一下~</p></li><li><p>全序关系的感性理解：一个偏序集 $\langle A,\preccurlyeq\rangle$ 中，所有元素间都可比，就称这个集为<strong>全序集</strong>，这个 $\preccurlyeq$ 关系称为<strong>全序关系</strong>；</p><blockquote><p>很容易理解，有限的全序集一定是有最大、最小元的；</p><p>$\langle N,\le\rangle$ 是全序集，$\langle P(A),\subseteq\rangle$ 不是；<strong>因为自然数集上所有元素对于“小于等于”两两可比，但幂集的元素——集合可能两者都没有包含关系，即对于“包含关系”不可比</strong>；</p></blockquote></li><li><p>链的感性理解：将偏序集中相互可比的元素，构成一个子集，这个子集就是<strong>链</strong>，其中元素数称为<strong>链长</strong>；</p><blockquote><p>为什么叫链？<strong>因为如果一系列元素可比，那么在哈斯图上呈现的是一条链，不会出现分支</strong>；</p><p>这也是为什么全序关系又称为“线序关系”的原因；</p><p>找全序关系就是找贯穿所有元素的链；</p></blockquote></li><li><p>良序关系：一个偏序集 $\langle A,\preccurlyeq\rangle$，A 的任意非空子集都有最小元，那么 $\preccurlyeq$ 就叫做<strong>良序关系</strong>，这个偏序集叫做<strong>良序集</strong>；</p></li></ul><h3 id="4-2-常见题型"><a href="#4-2-常见题型" class="headerlink" title="4.2 常见题型"></a>4.2 常见题型</h3><ul><li><p>求集合划分的种类数</p><blockquote><p>结论：贝尔数 $B_n$；<a href="https://oi-wiki.org/math/combinatorics/bell/">知识链接🔗</a></p><p>$B_n=C_{n-1}^0B_{n-1}+C_{n-1}^1B_{n-2}+\cdots+C_{n-1}^{n-1}B_0$；</p><p>可以用贝尔三角形每行第一个数来计算；</p><p>考到就仰仗自己的数学吧😭</p><p>帮你算几个：$B_0=B_1=1,\space B_2=2,\space B_3=5,\space B_4=15,\space B_5=52,\space B_6=203$</p><p>考场上基数大于 6 的集合的划分数，如果出到，请好好地问候出题老师！</p></blockquote></li><li><p>求各种闭包</p></li><li><p>求划分/等价类的元素和关系、由覆盖求对应的相容关系</p><p><strong>按照定义和性质，按部就班地来即可</strong></p></li><li><p>证明某个关系的性质，证明关系符合的公式</p><p><strong>思路：一般情况下，关系的元素是有序对，所以证明时一般都先声明一个 $\forall\langle x,y\rangle$</strong>，然后依次向下推理即可；</p><p><strong>特别地，如果是已定义的关系，例如等价关系，那么按照定义来</strong></p><blockquote><p>e.g.1, 设 $R,S,T$ 是 A 上的关系，证明：$R\circ(S\cup T)=(R\circ S)\cup(R\circ T)$</p><p>e.g.2, 已知 $A=Z_+\times Z_+$ 和 A 上的关系 $R=\{\langle\langle x,y\rangle,\langle u,v\rangle\rangle\space|\space xv=yu\}$； 证明 R 是等价关系；</p><p>e.g.3, 设 $\langle A,R_1\rangle,\space\langle B,R_2\rangle$ 是两个偏序集，定义 $A\times B$ 上的关系 R：对 $\forall a_1,a_2\in A,b_1,b_2\in B$，有 $\langle a_1,b_1\rangle R\langle a_2,b_2\rangle\Longleftrightarrow a_1R_1a_2\wedge b_1R_2b_2$，证明 R 是 $A\times B$ 上的偏序关系；</p></blockquote></li><li><p>给某个关于关系的公式找出反例</p><p><strong>思路：对于自反、对称而言，一般只需要找二阶关系矩阵就能发现矛盾；对于传递而言，需要从三阶关系矩阵开始找，先为每个矩阵设定一个传递关系，其他空不填，假设是0，看是否能成为反例；如果不行，在对空白处进行值的给定；</strong></p></li><li><p>判断一个结构是不是偏序关系：按定义来</p></li><li><p>考察偏序关系最大/小元、极大/小元的定义</p></li><li><p>画出偏序关系的哈斯图</p><blockquote><p>e.g., 对下列集合上的整除关系画出哈斯图，并指出在这个关系下的极大元、极小元、最大元、最小元（如果有的话）</p><p><code>A = &#123;1, 2, 3, 4, 6, 8, 12, 24&#125;</code> 和 <code>B = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</code></p><p>思考：从哈斯图上，我们能够如何更快地看出极大极小元？</p></blockquote></li><li><p>找到某个特定集合的一个全序关系</p><blockquote><p>找全序关系就是找一条贯穿集合所有元素的链</p><p>e.g., 找出在集合 <code>&#123;0, 1, 2, 3&#125;</code> 上包含 $\langle0,3\rangle$ 和 $\langle2,1\rangle$ 的全序关系；</p><p><strong>思路：将所有元素排成一条链，转化为排队问题</strong>；</p><p>如果要求包含某个元素，等价于某个元素必须排在另一个元素的前面/后面；</p><p>提示：本例共有 $C_3^1+C_3^2=6$ 种满足条件的全序关系；</p></blockquote></li></ul><h2 id="Chapter-5-函数"><a href="#Chapter-5-函数" class="headerlink" title="Chapter 5 函数"></a>Chapter 5 函数</h2><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><p>函数这章掌握几个概念和结论就行</p><ul><li><p>定义：就是一种集合 A 到集合 B 间的特殊关系；</p><blockquote><p>注意：$dom(f)=A$，不然就不是函数了</p></blockquote></li><li><p>部分函数：$dom(f)\subset A$，例如 $f:R\rightarrow R$ 的函数 $f(x)=\dfrac{1}{x}$，只有减去定义域中的 $\{0\}$ 或者在 $x=0$ 处添加定义，才能变为函数；</p></li><li><p>所有函数的集合：$A_B=\{f\space|\space f:A\rightarrow B\}$，也写作 $B^A$，<strong>基数 $|A_B|=|B|^{|A|}$</strong>；</p><blockquote><p>总数小于总关系数 $2^{|A||B|}$，<strong>因为：$A\ne \phi,\space B=\phi$ 不是函数、$A=\phi,\space B\ne\phi$ 只对应一个函数：空函数</strong>；</p></blockquote></li><li><p>单射、满射、双射的定义</p></li><li><p>常用函数的定义：常函数、恒等函数、n 元运算、泛函、特征函数、典型映射；</p></li><li><p>函数的合成</p><p><strong>着重掌握特性</strong>：</p><p><strong>定理：若 $f,g$ 满射，则$f\circ g$ 满射（单射、双射同理）</strong></p><p>逆定理：$f\circ g$ 满射则 $f$ 满射；$f\circ g$ 单射则 $g$ 单射；$f\circ g$ 双射，则 $f$ 满射、$g$ 单射；</p><p><strong>逆定理记忆：全部都是“外层满、内层单”</strong></p></li><li><p>函数的逆</p><p><strong>着重掌握左逆、右逆的性质</strong>：</p><p>定理：f 既有左逆、又有右逆，等价于 f 双射且左右逆相等；f 有左逆 $(g\circ f)$ 等价于 f 单射；f 存在右逆 $(f\circ g)$ 等价于 f 满射；</p><p><strong>记忆：还是“外层满、内层单”，函数在什么位置有逆，就是什么侧的满/单</strong>；</p></li></ul><h3 id="5-2-常见题型"><a href="#5-2-常见题型" class="headerlink" title="5.2 常见题型"></a>5.2 常见题型</h3><ul><li><p>判断单/满/双射</p></li><li><p>给定集合，要求构造集合间的 单射/满射/双射函数；</p><p><strong>一般情况都比较简单，有些不好想的需要记忆一下，例如：构造从 $N\times N$ 到 $N$ 的双射函数；答案是在点阵中有序环绕：$f(\langle m,n\rangle)=\dfrac{1}{2}(m+n)(m+n+1)+m$</strong>；大部分其他的无穷集上的构造也多采用这种方法；</p></li></ul><h3 id="5-3-错题"><a href="#5-3-错题" class="headerlink" title="5.3 错题"></a>5.3 错题</h3><ul><li><p>关于 $A\rightarrow\phi$ 的函数,下列（）是正确的</p><p>A．不存在</p><p>B．有一个空函数 $\Phi$</p><p>C．仅当 A 非空时才能有函数</p><p>D．仅当 A 为空时才能有函数</p><p><strong>事实上，$A\ne\phi,\space B=\phi$ 的函数不存在，但如果 A、B 都为空，那么可以是空函数</strong>；</p></li></ul><h2 id="Chapter-6-图论"><a href="#Chapter-6-图论" class="headerlink" title="Chapter 6 图论"></a>Chapter 6 图论</h2><h3 id="6-1-图论中的重要定义Ⅰ"><a href="#6-1-图论中的重要定义Ⅰ" class="headerlink" title="6.1 图论中的重要定义Ⅰ"></a>6.1 图论中的重要定义Ⅰ</h3><blockquote><p>图的起源：人们关心一类问题，给定的两点间是否有一条或多条连线的关系，而连接方式无关紧要。这类问题在数学上的抽象是<strong>图</strong>；</p></blockquote><ul><li><p>图的数学定义：一个图指<strong>有序三元组$(V(G),E(G),\psi_G)$</strong>，<strong>$V(G)$</strong>为<strong>非空</strong>（空图特殊，不参与讨论）顶点集，<strong>$E(G)$</strong>是不与<strong>$V(G)$</strong>相交的边集，<strong>$\psi_G$</strong>为关联函数；</p><blockquote><p>约定：对于图 G，一般用符号 <strong>$V(G)$</strong> 表示顶点集、<strong>$E(G)$</strong> 表示边集、<strong>$\nu(G)$</strong> 表示顶点数，<strong>$\varepsilon(G)$</strong> 表示边数；若上下文仅有一个图，则省略 “(G)”；</p><p>注：无向图可以表示为二元组，即 V 和 E；</p></blockquote></li><li><p>顶点对的定义：<strong>$\psi_G$</strong> 使 G 的每条边对应于 G 的 无序的<strong>顶点对</strong>；</p></li><li><p>连接、端点的定义：若 e 为 G 的一条边，u、v 是使 <strong>$\psi_G(e)=(u,v)$</strong> 的顶点，则称：e <strong>连接</strong> u、v，顶点 u、v 称为 e 的<strong>端点</strong>；</p></li><li><p>关联、相邻、自环：一条边的端点与这条边<strong>关联</strong>；与同一条边关联的两个顶点称为<strong>相邻</strong>；端点重合为一点的边称为<strong>自环</strong>；</p></li><li><p>平面图、非平面图：边仅在端点相交的图称为<strong>平面图</strong>，反之为非平面图；</p></li><li><p>平凡图、非平凡图：仅有一个顶点的图称为<strong>平凡图</strong>；</p></li><li><p>有向边、无向边：可由端点 <strong>$v_i\space和\space v_j$</strong> 表示 <strong>$e_k=(v_i,v_j)$</strong> 的边称为<strong>无向边</strong>（vi、vj互为直接前驱、直接后继）；可由有序二元组 <strong>$e_k=\langle v_i,v_j\rangle$</strong> 表示的边是<strong>有向边</strong>（vi是vj的直接前驱、vj是vi的直接后继）；</p></li><li><p>有向图、无向图：所有边都是有向边的图是<strong>有向图</strong>，反之是<strong>无向图</strong>，否则是混合图；</p><blockquote><p>可以将无向边视作双向有向边，因此此后不讨论混合图；</p></blockquote></li><li><p>简单图、有向简单图：既没有<strong>自环</strong>，又没有<strong>重边</strong>的图，如果是无向图，称为<strong>简单图</strong>；如果是有向图，称为<strong>有向简单图</strong>；</p><blockquote><ol><li><p>重边的定义：有两条及以上条边连接同一对顶点，称这个边为重边；</p><p>⚠<strong>易错警示：对有向边，A—-&gt;B 和 B—-&gt;A 组合不算重边！A—-&gt;B 和 A—-&gt;B 组合才是</strong>；</p></li><li><p>如果不强调“有向”，一般情况下“图”指“无向图”；不过在定义中，如果发现只描述无向图的，大概率对有向图也适用，不然就单独拎出来了；</p></li></ol></blockquote></li><li><p>完全图、有向完全图：每对不同顶点都有一条边相连的<strong>简单</strong>图称为<strong>完全图</strong>；有向完全图同理；</p><p><strong>特别地，将 n 个结点的完全图记作 $K_n$，但有向完全图没有这种记法；</strong></p><blockquote><p><strong>定理1：$\varepsilon(K_n)=C^2_{n}$ 且对n 个结点的有向完全图G：$\varepsilon(G)=A^2_{n}$；</strong></p><p>（因为A—-&gt;B 和 B—-&gt;A 组合不算重边） </p></blockquote></li><li><p>偶图（或者称二部图）：一个图 G 的顶点集 <strong>$V(G)$</strong> 可以分解为两个子集 X、Y，使得：每条边都有一个顶点在 X 中，另一个顶点在 Y 中；这样的一种分类 (X, Y) 称为 G 的一个<strong>二分类</strong>；</p><blockquote><p>理解：按分解的两个点集“切一刀”，所有边都被砍断的图；</p></blockquote></li><li><p>子图：若 <strong>$V(H)\subseteq V(G),\space E(H)\subseteq E(G)$</strong>，<strong>$\psi_H$</strong> 为 <strong>$\psi_G$</strong> 在 <strong>$E(H)$</strong> 上的限制，则 <strong>$H$</strong> 为 <strong>$G$</strong> 的<strong>子图</strong>，记作：<strong>$H\subseteq G$</strong>；（真子图略）</p></li><li><p>母图：若 <strong>$H\subseteq G$</strong>，称 <strong>$G$</strong> 为 <strong>$H$</strong> 的<strong>母图</strong>；</p></li><li><p>生成子图（或称支撑子图，spanning sub-graph）：<strong>$H\subseteq G\space且\space V(H)=V(G)$</strong>，称 <strong>$H$</strong> 为 <strong>$G$</strong> 的<strong>生成子图</strong>；</p></li><li><p>导出子图：有点抽象，一般用不到定义，想要形象地了解见：<a href="#graphCalc">图的运算🔗</a>；</p></li><li><p>基础简单图：一个图 G 删去所有<strong>“多余”的边</strong>，使图中恰没有重边、自环，得到的这样的<strong>简单生成子图</strong>称为<strong>基础简单图</strong>；</p></li><li><p>赋权图（或称加权图）：若给图 G 的每条边都赋以实数 <strong>$w_k$</strong> 作为该边的权，称 G 为赋权图；</p></li><li><p>顶点的度：图 G 的顶点 v 的度记为 <strong>$d_G(v)$</strong>，指 G 中与 v 相关联的数目；</p><ul><li>约定：<strong>$\delta(G)、\Delta(G)$</strong> 表示 G 的所有顶点的最小度、最大度；</li><li>度为0的点称为<strong>孤立点</strong>；</li><li><strong>对于有向图，$d(v)=d_+(v)+d_-(v)$，$d_+$ 为正度/入度，$d_-$ 为负度/出度</strong>；</li><li><strong>自环贡献一个入度、一个出度</strong>；</li></ul><blockquote><p><strong>定理2：（握手定理）$\sum\limits_{v\in V}d(v)=2\varepsilon$（所有结点的度之和为边数的2倍，有向图也是）</strong>；</p><p>推论：对任何图，度为奇数的点（称<strong>奇点</strong>）的个数为偶数；</p><p><strong>定理3：有向图中，$\sum{d_-}=\sum{d_+}=\varepsilon$（入度和=出度和=边数，是入度出度平分的意思）</strong></p><p><strong>定理4：非空简单图（$\varepsilon\gt1$）一定存在度相同的结点</strong>；</p></blockquote></li></ul><h3 id="6-2-图的同构"><a href="#6-2-图的同构" class="headerlink" title="6.2 图的同构"></a>6.2 图的同构</h3><blockquote><p>注：图同构问题分为4类：精确图完全同构、精确子图同构、不精确图完全同构、不精确子图同构；现在学界已证明后三者是 NP 完全问题；计算机离散数学-图论、数据结构（包括下面的内容）讨论的是第一种问题；</p></blockquote><ul><li><p>恒等图的定义</p></li><li><p>同构图的定义：如果存在两个<strong>一一映射（双射）$\theta:\space V(G)\rightarrow V(H),\space\phi:\space E(G)\rightarrow E(H)$</strong>，使 <strong>$\psi_G(e)=(u,v)$</strong> 当且仅当 <strong>$\psi_H(\phi(e))=\theta(u)\theta(v)$</strong>，则将这样的映射对 <strong>$(\theta,\phi)$</strong> 称为 G 和 H 间的一个同构；将 G 与 H 同构关系记为 <strong>$G\cong H$</strong>；</p><blockquote><p>理解：边边和点点必须一一相应；</p><p>就是在不添加边和点、不删除边和点的基础上<strong>任意移动顶点的相对位置、为顶点和边改名</strong>，所产生的不同形态的图；</p></blockquote></li><li><p>关于同构的定理</p><blockquote><p><strong>定理5：（同构的必要条件）两个同构图的结点度的非增序列相同</strong></p><p><strong>定理6：（同构的必要条件）若 G1 与 G2 同构，则 G1 的任意<u>导出子图</u>都有 G2 的导出子图与其同构</strong>；</p><p>其实还有一个必要条件过于明显，不作为定理：两同构图的顶点数、边数相等；</p></blockquote></li><li><p>判断方法</p><ul><li><p>判断两图同构：<strong>按定义，找到两个一一映射</strong>；</p><blockquote><p>注：根据定义，可以得出一个显然的方法：<strong>一个图的邻接矩阵经历有限次的行互换、列互换，能变成另一个图的邻接矩阵，那么这两个图同构</strong>；</p></blockquote></li><li><p>判断两图不同构：使用定理5、6（必要条件），不满足必要条件的就不是；</p></li></ul></li></ul><h3 id="6-3-图的存储实现"><a href="#6-3-图的存储实现" class="headerlink" title="6.3 图的存储实现"></a>6.3 图的存储实现</h3><ul><li><p><span id="relM">图的关联矩阵（<strong>行是顶点，列是边</strong>）：因为空间原因，不做存储图的方法；</span></p><blockquote><p>虽然不做存储方法，但在讨论<strong>树、有向连通图、电路图的某些性质</strong>时比较有用，感兴趣戳<a href="#relMDetails">这里🔗</a>（不在初级数据结构要求范围内）；</p></blockquote><ul><li>无向图的关联矩阵：可以由 bool 矩阵表示，1是有关联，0是没有关联；</li><li>有向图的关联矩阵：+1表示该边离开该结点，即正度/出度；-1表示该边进入该结点，即负度/入度；0表示没有关联；</li></ul></li><li><p>图的邻接矩阵表示法：对任意的图 G，对应一个 <strong>$\nu\times\nu$</strong> 的邻接矩阵 <strong>$A(G)=[a_{ij}]$</strong>，其中 <strong>$a_{ij}$</strong> 为 <strong>$v_i、v_j$</strong> 的连接数目；（空间：<strong>$O(|V|^2)$</strong>）</p><p><strong>进一步，在数据结构中更常用的是“加权图的邻接矩阵”存储方法，可以兼顾非加权图：</strong></p><script type="math/tex; mode=display">A[i][j]=\begin{equation}\left\{\begin{aligned}&\omega,&<i,j,w>\in E\\&0,&i=j\\&\infty,&otherwise\\\end{aligned}\right.\end{equation}</script><p><strong>C++代码实现统一放置于附录中，有需要可以前去查看，下同；</strong></p></li><li><p>图的邻接表表示法：改进了邻接矩阵表示法在面对稀疏矩阵时浪费空间、不易维护的问题；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">结点集(结点数组)：node1 &#123;结点值，与该结点相邻的直接后继(有方向)结点索引链表头指针&#125;</span><br><span class="line"> |------------------------------------------------------------|</span><br><span class="line"> v</span><br><span class="line">边集(单链表)：node2 &#123;结点索引（不能放结点值，因为无法完成后面的遍历运算, 下一node2&#125;</span><br><span class="line"></span><br><span class="line">+ 保存边数、保存结点数</span><br><span class="line">空间：O(|V|+|E|)</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-4-图的运算实现"><a href="#6-4-图的运算实现" class="headerlink" title="6.4 图的运算实现"></a>6.4 图的运算实现</h3><ul><li><p><span id="graphCalc">图的基本运算</span></p><ul><li><p>差运算：<strong>（要求 $G_2$ 为 $G_1$ 子图）$G_1-G_2=(V_1,E_1-E_2)$</strong>；</p></li><li><p>补运算：<strong>$n$</strong> 个结点的简单图的补图 <strong>$\overline{G}=K_n-G$</strong>；</p></li><li><p>删去结点 <strong>$v$</strong> 及其关联的边：<strong>$G-v$</strong></p><blockquote><p><strong>$G-v$</strong> 为 <strong>$G$</strong> 的<strong>导出子图</strong>：有助于理解导出子图的意义；</p></blockquote></li><li><p>删去边 <strong>$e$</strong>：<strong>$G-e$</strong></p><blockquote><p><strong>$G-e$</strong> 为 <strong>$G$</strong> 的<strong>生成子图</strong>：有助于理解生成子图的意义；</p></blockquote></li><li><p>增加边 <strong>$e_{ij}=(v_i,v_j)$</strong>：<strong>$G+e_{ij}$</strong></p></li></ul></li><li><p>数据结构中图的基本运算：创建、判边、增删边、查点边数、遍历（后面分开讨论）；</p></li><li><p>图的运算实现：<strong>对于不同的存储方式，图的运算时间复杂度有所不同</strong></p><ul><li><p>邻接矩阵表示的运算实现</p></li><li><p>邻接表表示的运算实现</p></li></ul></li></ul><h3 id="6-5-图论中的重要定义Ⅱ"><a href="#6-5-图论中的重要定义Ⅱ" class="headerlink" title="6.5 图论中的重要定义Ⅱ"></a>6.5 图论中的重要定义Ⅱ</h3><ul><li><p>道路和回路：在无向图 <strong>$G=(V,E)$</strong> 中，若<u>边点交替序列</u> <strong>$P=(v_{i1},e_{i1},v_{i2},e_{i2},…,e_{iq-1},v_{iq})$</strong> 满足：<strong>$v_{ik}、v_{ik+1}$</strong> 为 <strong>$e_{ik}$</strong> 的两个端点，则称 P 为 G 的一条<strong>道路</strong>；特别地，如果 <strong>$v_{i1}=v_{iq}$</strong>，那么称道路 P 为 G 的一条<strong>回路</strong>；</p><ul><li>如果 P 序列中没有重复的边，则 P 称为<strong>简单道路（或称“迹”）、简单回路（或称“闭迹”）</strong>；</li><li>更特别地，如果 P 序列中结点也不重复（结点不重复是边不重复的充分不必要条件），则称 P 为 G 的<strong>初级道路、初级回路</strong>；</li></ul></li><li><p>有向道路和有向回路：在有向图 <strong>$G=(V,E,\psi_G)$</strong> 中，若<u>边序列</u> <strong>$P=(e_{i1},e_{i2},…,e_{iq})$</strong>，其中  <strong>$e_{ik}=(v_l, v_j)$</strong>，则称 P 为 G 的<strong>有向道路</strong>；若 <strong>$e_{iq}$</strong> 终点也是 <strong>$e_{i1}$</strong> 的始点，则称 P 为 G 的<strong>有向回路</strong>；</p><ul><li>同样有：简单有向道路、简单有向回路、初级有向道路、初级有向回路的概念；</li></ul><blockquote><p>⚠易错点：<strong>平凡图一定是道路，但一定不是回路！</strong></p></blockquote></li><li><p>连通性、强连通性、弱连通性、单向连通性</p><ul><li>无向图考虑“连通”：两结点间至少存在一条道路，则这两个结点间连通；</li><li>有向图考虑：<ol><li>两结点间存在一条从 <strong>$v_i$</strong> 到 <strong>$v_j$</strong> 的有向道路 <strong><u>且</u></strong> 存在另一条从 <strong>$v_j$</strong> 到 <strong>$v_i$</strong> 的有向道路，则称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>强连通</strong>；</li><li>两结点间<strong><u>仅</u></strong>存在一条从 <strong>$v_i$</strong> 到 <strong>$v_j$</strong> 的有向道路 <strong><u>或</u></strong> <strong><u>仅</u></strong>存在另一条从 <strong>$v_j$</strong> 到 <strong>$v_i$</strong> 的有向道路，则称称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>单向连通</strong>；</li><li>两结点间 <strong>不考虑所有道路的方向（称为“有向图的底图”）</strong>，若这两个结点连通，则称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>弱连通</strong>；</li></ol></li></ul></li><li><p>连通图、连通分量（或称“连通支”）</p><ul><li>无向图 G 中任意两结点间都是连通的，则 G 为<strong>连通图</strong>；</li><li>G 的连通子图（子图且连通）H 不是 G 的任何其他连通子图的真子图，称 H 为 G 的一个<strong>极大连通子图</strong>，也称<strong>连通分量</strong>；</li></ul><blockquote><p>有些不严谨的题问有向图“是不是连通图”，就将它看成一个无向图（忽略方向）；</p></blockquote></li><li><p>强连通图、强连通分量</p><ul><li>有向图 G 中任意两结点间都是强连通的，则 G 为<strong>强连通图</strong>；</li><li>G 的强连通子图 H 不是 G 的任何其他强连通子图的真子图，称 H 为 G 的一个<strong>极大的强连通子图</strong>，也称<strong>强连通分量</strong>；</li></ul><blockquote><p>⚠易错点1：<strong>平凡图也单独算一个连通分量 / 强连通分量！</strong></p><p>⚠易错点2：因为无向边看作“双向边”，所以连通的无向图一定是强连通的；</p><p><strong>推论：图 G 的每个连通分支都是其导出子图</strong>；</p><p><strong>小结论：图 G 对应关联矩阵记为 $M(G)$，则 G 的连通分支数为 $r(M(G))-1$</strong>；</p></blockquote></li><li><p>割边与非割边、割点与非割点：删去图中某个边 / 点，图的连通分支数（连通性）改变，则称该边 / 点为<strong>割边 / 割点</strong>；</p></li><li><p>欧拉道路、欧拉回路：<strong>无向连通图</strong> G 中的一条经过<u>所有边</u>的<strong>简单道路/回路</strong>称 G 的<strong>欧拉道路/回路</strong>；</p><ul><li><p>理解：不重复地遍历所有边，不管点的情况；</p></li><li><p>注意：<strong>有向图也能讨论欧拉回路的问题，不过要遵循有向的连通性</strong>；</p></li></ul><blockquote><p><strong>定理1：（欧拉回路充要条件）无向连通图 G 存在欧拉回路 $\Longleftrightarrow$ G 的各结点度数均为偶数</strong>；</p><p><strong>推论1-1：（欧拉道路充分条件）无向连通图 G 仅有2个奇点 $\Longrightarrow$ G 存在欧拉道路</strong>；</p><p><strong>推论1-2：（有向欧拉回路充分条件）有向连通图 G 的各结点的正、负度数相等 $\Longrightarrow$ G 存在有向欧拉回路</strong>（侧面说明有向可能严格一些，不仅结点度全为偶数，而且要进出相等）；</p><p>定理2：连通图 G 有 k 个奇点（由部分Ⅰ的定理可知，k为偶数），则 E(G) 可以划分为 <strong>$\dfrac{k}{2}$</strong> 条简单道路；</p></blockquote></li><li><p>哈密顿道路、哈密顿回路：<strong>无向图</strong> G 的一条<u>经过全部结点</u>的<strong>初级道路/回路</strong>称 G 的<strong>哈密顿道路/回路（简称H道路/H回路）</strong>；</p><ul><li>理解：“不重复地遍历所有点”；</li><li>注意：H 道路 / 回路一般针对简单图，因为重边和自环对它没有什么影响，可以转换为简单图的问题；</li></ul><blockquote><p><strong>很遗憾，目前 H 道路 / 回路的判定没有充要条件！一般遍历是 NP 问题……</strong></p><p><strong>定理3：（H 回路充分条件）完全图 $K_n$ 为 H 图</strong>；</p><p><strong>定理4：（H 回路充分条件）若简单图 G 每个结点度都大于 n/2，则 G 为 H 图</strong>；</p><p>说明：平均每个点的度越大，越有可能有H道路、H回路；</p><p><strong>推论4-1：（H 道路充分条件）若简单图 G 的任两结点 $v_i,v_j$ 恒有 $d(v_i)+d(v_j)\ge n-1$，则 G 存在 H 道路；</strong></p><p>证明提示：有 H 道路一定连通，可以先证连通性；</p><p><strong>推论4-2：（H 回路充分条件）若简单图 G 的任两结点 $v_i,v_j$ 恒有 $d(v_i)+d(v_j)\ge n$，则 G 为 H 图</strong>；</p><p><strong>推论4-3：（H 回路的闭包等价关系）向图 G 中满足 “ $d(v_i)+d(v_j)\ge n$”的不相邻两结点 $v_i,v_j$ 加边，直至无法找到这样的结点对为止，形成的新图称为 G 的闭包（记为$C(G)$）；那么有：$G\space为H图\Longleftrightarrow C(G)为H图$</strong>；</p><p><strong>推论4-4：（H回路闭包充分条件）若 $C(G)=K_n$，则 G 为 H 图</strong>；</p><p><strong>定理5：（可怜为数不多的 H 回路的必要条件）若 G 为 H 图，则对任意非空顶点集 S，有：$\omega(G-S)\le|S|$</strong>；</p></blockquote><ul><li><p>补充：欧拉图、H 图的定义：有欧拉回路 / H 回路的图才叫~（只有欧拉道路 / H 道路的不是）；</p></li><li><p>判断一个图是 H 图：使用上面的充分条件/等价条件；</p></li><li><p>判断一个图不是 H 图：使用上面的必要条件；</p><blockquote><p>举例：证明 Peterson 图是极大非 H 图（有 H 道路，但没有 H 回路）</p><p>【问题：它满足定理5，能否判断一下为什么在删去任意4个顶点时，连通分支数一定小于等于3？】</p><p><strong>定理6：（必要条件）若一个点在 H 回路中，那么必定有且仅有两个相连的相异道路</strong>；</p></blockquote></li></ul></li></ul><h3 id="6-6-图的简单应用"><a href="#6-6-图的简单应用" class="headerlink" title="6.6 图的简单应用"></a>6.6 图的简单应用</h3><ul><li>【普通图】有 3L、5L、8L的三个没有刻度的量杯，现在8L的量杯装满了水，其他两个是空的；问如何操作（不撒不漏）可以让8L水分为两个4L水？</li><li>【二部图】人、狼、羊、菜过河问题</li></ul><blockquote><p>解决思路：<strong>“状态转换图”：</strong>将每一个状态抽象为一个顶点，先列出所有可能状态作为顶点，再用“一次能直接转换的关系”作为边连接，最后只需判断在起点（初态）和终点（末态）是否单向连通即可；</p></blockquote><h3 id="6-7-图论中的重要定义Ⅲ"><a href="#6-7-图论中的重要定义Ⅲ" class="headerlink" title="6.7 图论中的重要定义Ⅲ"></a>6.7 图论中的重要定义Ⅲ</h3><blockquote><p>提示：本章节不在初级数据结构要求范围内；</p></blockquote><ul><li><p>割边与非割边、割点与非割点：删去图中某个边 / 点，图的连通分支数（连通性）改变，则称该边 / 点为<strong>割边 / 割点</strong>；</p><blockquote><p><strong>定理1：e 为割边，当且仅当 e 不属于 G 的任何回路</strong>；</p></blockquote></li><li><p>普通树的数学定义：不含任何回路的连通图称为<strong>树</strong>；</p><blockquote><p><strong>定理2：“连通”、“无回路”、“有 n-1 条边”三个条件任取两个都可以作为树的定义</strong>；</p><p>推论：“连通+全为割边”、“任意两点间有唯一道路”、“无回路+加一边就一回路” 这三个与树的定义等价；</p><p><strong>定理3：树中一定有树叶结点（离散数学中没有空树的说法！只有空图）</strong></p></blockquote></li><li><p>根树的定义：若树 T 是有向树，且 T 中存在某结点 $v_0$ 的入度为0、其他结点入度为1，则称 <strong>T 是以 $v_0$ 为根的根树</strong>（或外向树），用 $\overrightarrow{T}$ 表示；</p><blockquote><p><strong>根树才是数据结构中的“树”！</strong></p></blockquote></li><li><p>生成树（或称“支撑树”）：图 G 的一个符合树定义的生成子图称为图 G 的<strong>生成树</strong>；</p><blockquote><p>余树：给定图 G 的一棵生成树 T，定义余树 $\overline{T}=G-T$；一般情况下，余树不是树；</p></blockquote></li><li><p><span id="relMDetails">基本关联矩阵：<strong>上接“<a href="#relM">关联矩阵存储🔗</a>”，虽然关联矩阵一般不作为存储方法，但有些情况讨论它的性质，可以更方便地解决某些问题</strong>；</span></p><blockquote><p>友情提醒1：这里和<strong>电路理论的电路图研究</strong>结合比较紧密；</p><p>友情提醒2：这里的讨论对象是<strong>有向连通图</strong>；</p></blockquote><ul><li>定义：在<strong>有向连通图 $G=(V, E)$</strong> 的<strong>关联矩阵 $B$</strong> 中，划去任意任意结点 $v_k$所对应的一<strong>行</strong>，得到 <strong>$(\nu-1)\times\varepsilon$</strong> 的矩阵 $B_k$，称为 <strong>G 的一个基本关联矩阵</strong>；</li><li>相关定理</li></ul><blockquote><p><strong>定理1：有向连通图 G 的关联矩阵 B 满足：$r(B)=\nu-1$</strong>；</p><p><strong>定理2：有向连通图 G 的基本关联矩阵 $B_k$ 满足：$r(B_k)=\nu-1$</strong>；</p><p>推论：n个结点树 T 的基本关联矩阵的秩为 $\nu-1$；</p><p><strong>定理3：有向连通图 G 如果存在回路 C，则 C 中各边所对应基本关联矩阵 $B_k$ 的各列线性相关</strong>；</p><p><strong>定理4：有向连通图 G 的基本关联矩阵 $B_k$，有：$B_k任意n-1阶子式M_{n-1}\ne0\Longleftrightarrow M_{n-1}各列对应边构成G的一棵生成树$</strong>；</p><p>定理4说明了<strong>可以由 $B_k$ 的非零 n-1 阶子式的数目来代表 $G$ 生成树的数目<a href="#genTCount">🔗</a></strong>；</p></blockquote></li><li><p>回路矩阵和割集矩阵；</p><blockquote><p>不说了亲，这边建议您好好复习电路理论课呢:sweat_smile:</p></blockquote></li><li><p>Huffman树（最优二叉树），详见“数据结构复习-第二部分”；</p></li></ul><h3 id="6-8-图的经典算法"><a href="#6-8-图的经典算法" class="headerlink" title="6.8 图的经典算法"></a>6.8 图的经典算法</h3><h4 id="6-8-1-图的遍历算法"><a href="#6-8-1-图的遍历算法" class="headerlink" title="6.8.1 图的遍历算法"></a>6.8.1 图的遍历算法</h4><ul><li><p>DFS 算法：类似树的前序遍历</p><p>邻接表存储 $O(|V|+|E|)$</p><p>邻接矩阵存储 $O(|V|^2)$</p></li><li><p>BFS 算法：类似树的层次遍历</p><p>邻接表存储 $O(|V|+|E|)$ </p><p>邻接矩阵存储 $O(|V|^2)$</p></li></ul><h4 id="6-8-2-两点间道路判定算法"><a href="#6-8-2-两点间道路判定算法" class="headerlink" title="6.8.2 两点间道路判定算法"></a>6.8.2 两点间道路判定算法</h4><blockquote><p>这里介绍邻接矩阵表示的算法，比较常见；</p></blockquote><ul><li><p>引入：对于一个<strong>非加权图的邻接矩阵（0&amp;1）</strong>，有 $P=(p_{ij})_{n\times n}=\sum\limits_{k=1}^n{A^k}$，则 $p_{ij}$ 为从 $v_i$ 到 $v_j$ 的<strong>道路数</strong>；实际问题只关心<strong>是否有道路</strong>，所以可以改成逻辑运算提升速度：$P=(p_{ij})_{n\times n}=\bigvee\limits_{k=1}^n{A^k}$，时间复杂度 $O(\nu^4)$；</p></li><li><p><span id="Warshell">Warshell算法 $O(\nu^3)$</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P &lt;- A</span><br><span class="line">for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">    for (int j = 1; j &lt;= n; ++j)</span><br><span class="line">        for (int k = 1; k &lt;= n; ++k)</span><br><span class="line">            p_&#123;jk&#125; &lt;- p_&#123;jk&#125; V (p_&#123;ji&#125; Λ p_&#123;ik&#125;)</span><br></pre></td></tr></table></figure></li><li><p>DFS 和 BFS $O(\varepsilon)$：和图的遍历不一样的是，它比图的遍历更简单，只需从一个点出发（减少最外层循环），用visited数组和BFS/DFS整体寻找，如果遇到终点即停止并返回true，否则返回false；</p></li></ul><h4 id="6-8-3-有向图强连通分支判断算法"><a href="#6-8-3-有向图强连通分支判断算法" class="headerlink" title="6.8.3 有向图强连通分支判断算法"></a>6.8.3 有向图强连通分支判断算法</h4><blockquote><p>思路：先从图 G 任一点开始 DFS，如果 G 不是强连通图，则可能得到一个深度优先生成森林；对森林中的每棵树按照<strong>生成次序</strong>依此进行<strong>后序遍历</strong>，并按遍历顺序给每个结点编号（从小到大）；</p><p>然后使 G 的每条边逆向，得到 Gr，再从 Gr 编号最大的结点开始 DFS，得到新的深度优先遍历森林中的<strong>每一棵树</strong>就是 G 的一个强连通分量；</p></blockquote><h4 id="6-8-4-欧拉回路的构造算法"><a href="#6-8-4-欧拉回路的构造算法" class="headerlink" title="6.8.4 欧拉回路的构造算法"></a>6.8.4 欧拉回路的构造算法</h4><blockquote><p>欧拉回路有明确的、好判断的充要条件，所以算法设计相对容易；</p><p>无论啥算法，最好先利用充要条件排除没有欧拉回路的图，能大大提高时间性能；</p><p>下面讨论<strong>如果有欧拉回路，应该怎么找</strong>的算法：</p></blockquote><ul><li>拼接法：DFS寻找回路（经过即删除），如果回路结束却仍然有未遍历的结点，则从新的未访问的结点开始遍历回路，<strong>并拼接（“8”字原理）</strong>，循环直到所有边已被访问；</li><li>Floyd算法（非割边优先遍历）</li></ul><h4 id="6-8-5-欧拉回路的应用：中国邮递员问题（CPP）"><a href="#6-8-5-欧拉回路的应用：中国邮递员问题（CPP）" class="headerlink" title="6.8.5 欧拉回路的应用：中国邮递员问题（CPP）"></a>6.8.5 欧拉回路的应用：中国邮递员问题（CPP）</h4><blockquote><p>中国邮递员问题：<strong>走遍图中的所有边</strong>后返回返回起点，要求<strong>总路程最短</strong>；</p></blockquote><ul><li><p>对于无向图 G 的结论</p><ul><li><p>如果 G 中所有结点个数都是偶数：该图的任一欧拉回路都是解；</p></li><li><p>如果 G 中有且仅有 2 个奇点 $v_i\space和\space v_j$：找到 G 从  $v_i$ 到 $v_j$ <strong>欧拉道路 $E_{ij}$</strong>，再找从  $v_j$ 到 $v_i$ 的<strong>最短路径 $P_{ji}$</strong>，则回路 <strong>$E_{ij}+P_{ji}$</strong> 就是问题的解；</p></li><li><p>如果 G 中有两个以上，共2k个奇点（由前面图的性质推论，奇点必有偶数个）：</p><script type="math/tex; mode=display">图G有最佳邮路L\Longleftrightarrow\begin{equation}\left\{\begin{aligned}&1.\space L的任一边最多重复一次\\&2.\space对G中的任一回路C，L中在C上重复边的长度之和\\&\quad不超过C总长的一半\space(必须遍历所有包含重边的回路)\\\end{aligned}\right.\end{equation}</script><p><strong>实际做法是：找出所有奇点，两两配对并依此为奇点间添加重复边（长度和原边相等），为它们配对成偶点，得到新图，也即邮路 $L_x$；再检查 $L_x$ 是否满足以上两个条件；如果违反第一条则一次性删除两条多余重边，如果违反第二条则将 $L_x$ 的该段道路改成与 $C$ 互补的道路</strong>；</p></li></ul></li></ul><h4 id="6-8-6-H-回路的应用：旅行商问题（TSP）"><a href="#6-8-6-H-回路的应用：旅行商问题（TSP）" class="headerlink" title="6.8.6 H 回路的应用：旅行商问题（TSP）"></a>6.8.6 H 回路的应用：旅行商问题（TSP）</h4><ul><li>问题描述：给定一个正权完全图，求总权最小的 H 回路；</li></ul><blockquote><p>NP 完全问题，只能寻找近似解；这里不介绍算法，仅介绍问题；提示：不建议使用贪心法，误差很大；</p></blockquote><h4 id="6-8-7-有向无环图、AOV网与拓扑排序"><a href="#6-8-7-有向无环图、AOV网与拓扑排序" class="headerlink" title="6.8.7 有向无环图、AOV网与拓扑排序"></a>6.8.7 有向无环图、AOV网与拓扑排序</h4><ul><li><p>有向无环图（DAG）：不存在回路的有向图称为<strong>有向无环图</strong>；</p></li><li><p>AOV网：<strong>有向无环图</strong>中的顶点表示活动，边表示活动间的先后关系，这样的图称为<strong>AOV网</strong>；</p></li><li><p>拓扑排序：将AOV网中的活动发生的先后次序排成一个序列（如果有一条从 u 到 v 的道路，那么 v 必须出现在 u 之后），称为<strong>拓扑排序</strong>，这个序列称为<strong>拓扑序列</strong>；</p></li><li><p>拓扑排序实现思路：类似于图的 BFS，但是<strong>只有一个结点的所有直接前驱结点都已访问后，才能访问这个结点</strong>；<strong>$O(|V|+|E|)$</strong></p><ol><li><p>计算每个结点的入度，保存在数组中；</p></li><li><p>检查入度数组中<strong>入度为零（无依赖）</strong>的对应结点索引，并将其入队；</p></li><li><p>当队伍非空时，循环出队并输出这个结点，在假设将这个结点删除，修正这个结点的所有直接结点的入度（减1），如此重复2、3步骤；</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请自行实现私有函数 int _getInDegree(int) 获取入度；</span></span><br><span class="line"><span class="comment">// 使用到了之前的seqQueue类；</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span>* adjListGraph&lt;VType, EType&gt;::<span class="built_in">topoSortIdx</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ans = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;; <span class="type">int</span> ansIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* inDegrees = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; preRequests;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        inDegrees[i] = _getInDegree(i);</span><br><span class="line">        <span class="keyword">if</span> (!inDegrees[i]) preRequests.<span class="built_in">enQueue</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!preRequests.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = preRequests.<span class="built_in">deQueue</span>();</span><br><span class="line">        ans[ansIdx++] = cur;</span><br><span class="line">        eNode* curEdge = vertices[cur].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--inDegrees[curEdge-&gt;end] == <span class="number">0</span>)</span><br><span class="line">                preRequests.<span class="built_in">enQueue</span>(curEdge-&gt;end);</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[i]) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR] A non-DAG does not support topoSort().&quot;</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] ans; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">topoSort</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* seq = <span class="built_in">topoSortIdx</span>();</span><br><span class="line">    <span class="keyword">if</span> (!seq) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        std::cout &lt;&lt; vertices[seq[i]].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-8-8-AOE网与关键路径"><a href="#6-8-8-AOE网与关键路径" class="headerlink" title="6.8.8 AOE网与关键路径"></a>6.8.8 AOE网与关键路径</h4><ul><li><p>AOE网络：活动定义在边上（持续时间），事件定义在顶点上；</p></li><li><p>AOE网络的重要两点：源点（入度为0，工程“起点”）、汇点（出度为0，工程“终点”）；</p></li><li><p>AOE网络解决的问题：完成整项任务的最少时间、哪些活动是影响工程进度的关键;</p></li><li><p>关键路径：从源点到汇点的<strong>最长</strong>路径称为<strong>关键路径</strong>；</p></li><li><p>关键活动：关键路径上的活动。<strong>推迟关键活动必定影响项目进度</strong>；</p></li><li><p>最早发生时间：用“从源点到该结点的<strong>最长路径</strong>”（因为和拓扑排序一样，只有该结点的所有直接前驱结点都访问过后，才能算访问了这个结点）表征；</p></li><li><p>最迟发生时间：用“关键路径长(定值) - 从汇点到该结点的<strong>最短路径</strong>”表征（因为是最迟，距离汇点最近才符合定义）；</p></li><li><p>时间余量：最迟发生时间 - 最早发生时间。<strong>时间余量为0的活动是关键活动（第二定义）</strong>；</p></li><li><p>找关键路径的思路：（用第二定义）<strong>就是找每个顶点的最早、最迟发生时间，进而得到关键活动、关键路径</strong>；</p><ol><li><p>找出AOE网的任一拓扑序列；</p></li><li><p>从头至尾遍历一次拓扑序列，在遍历到 u 时，更新它的<strong>所有</strong>直接后继结点 v 的最早发生时间（如果当前ee值＜u 的值+路径长，那么更新v的ee值为更大的）；</p></li><li><p>再从尾至头遍历一次拓扑序列，在遍历到 u 时，更新它的<strong>所有</strong>直接后继结点 v 的最迟发生时间（如果后继结点le值＜v 的值+路径长，那么更新为u为更小的）；</p><blockquote><p>别问为啥不和第二步相对应，找直接前驱结点，问就是找前驱结点复杂度太大了；</p><p>⚠<strong>记得更新最迟发生时间之前，要用第二步得到的关键路径长度（就是拓扑序列最后一个结点的ee值）填充最迟发生时间数组</strong>；</p></blockquote></li><li><p>找出所有“最早发生时间=最迟发生时间”的结点，按照拓扑序列的顺序依此输出，即为关键路径；</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">criticalPath</span>(<span class="type">int</span>* early, <span class="type">int</span>* late) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* topoSeq = <span class="built_in">topoSortIdx</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) early[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        eNode* curEdge = vertices[topoSeq[i]].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (early[topoSeq[i]] + curEdge-&gt;weight &gt; early[curEdge-&gt;end])</span><br><span class="line">                early[curEdge-&gt;end] = early[topoSeq[i]] + curEdge-&gt;weight;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pLen = early[topoSeq[<span class="keyword">this</span>-&gt;vertixNum - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) late[i] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">this</span>-&gt;vertixNum - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        eNode* curEdge = vertices[topoSeq[i]].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (late[topoSeq[i]] &gt; late[curEdge-&gt;end] - curEdge-&gt;weight)</span><br><span class="line">                late[topoSeq[i]] = late[curEdge-&gt;end] - curEdge-&gt;weight;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">criticalPath</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ee = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="type">int</span>* le = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="type">int</span> pathLen = <span class="built_in">criticalPath</span>(ee, le);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[INFO] The length of the critical path: &quot;</span> &lt;&lt; pathLen &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[INFO] The critical path: \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ee[i] == le[i]) std::cout &lt;&lt; vertices[i].data &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[Fin]\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-8-9-生成树的计数算法"><a href="#6-8-9-生成树的计数算法" class="headerlink" title="6.8.9 生成树的计数算法"></a>6.8.9 生成树的计数算法</h4><blockquote><p>原理：Binet-Cauchy 定理：两个矩阵 $A_{m\times n},\space B_{n\times m}\space(m\le n)$，则 $det(AB)=\sum\limits_i{A_iB_i}$ 。其中$A_i$、$B_i$ 分别是从 $A$ 中任取 $m$ 列、$B$ 中任取 $m$ 行构成的行列式；</p><p>虽然这样计算行列式有些麻烦，但它揭示了乘积矩阵行列式和各矩阵的子式之间的关系；</p><p><span id="genTCount"><strong>定理1：（有向连通图的普通生成树计数）设 $B_k$ 为有向连通图 $G=(V,E)$ 的某一基本关联矩阵，则 $G$ 中不同树的数目为 $det(B_kB_k^T)$</strong>；</span></p><ul><li>解题提示：如果要求<strong>不含</strong>某个边的生成树数目，只要求将该边删去后的生成子图对应生成树的数目；如果要求<strong>必含</strong>某个边的生成树数目，只要该边的起点终点合并为一点，求新图对应生成树的数目；</li></ul><p><strong>如果想求无向连通图的生成树个数，需要将其每条边指定一个任意方向转化为有向连通图</strong>；</p><ul><li><p>推论证明：求证<strong>完全图 $K_n$ 的不同生成树的数目为 $n^{n-2}$</strong>；</p><script type="math/tex; mode=display">det(B_kB_k^T)=\begin{vmatrix}n-1&-1&\cdots&-1\\-1&n-1&\cdots&-1\\\vdots&\vdots&\ddots&\vdots\\-1&-1&\cdots&n-1\end{vmatrix}=n^{n-2}</script></li><li><p>⚠易错警示：如果是求<strong>完全图 $K_n$ 不同构的生成树的数目</strong>，和<strong>“不同生成树”</strong>不一样！和化学上<strong>求同分异构体的做法类似</strong>；例如 $K_5$ 的不同构生成树数目为 3，对应有机化学戊烷的正戊烷、异戊烷、新戊烷的构型；</p></li></ul><p><strong>定理2：（有向连通图的根树生成树计数）设 $\overrightarrow{B_k}$ 表示将有向连通图 $G$ 的<u>关于结点 k 的</u>关联矩阵 $B_k$ 中所有的 1 元素换成 0 之后的矩阵，则 $G$ 中<u>以 k 为根的</u>不同根树数目为 $det(\overrightarrow{B_k}B_k^T)$</strong>；</p><ul><li>解题提示：如果要求<strong>不含</strong>某个边的根树生成树数目，删去这个边再算；</li><li>⚠易错警示：和普通生成树不同，如果要求<strong>必含</strong>某个边的根树生成树数目，需要先计算以 v0 为根的总根树数目，再减去不含这个边的生成树数目；<strong>或者求 $G^\prime=G-\{(t,v)|t\ne u\}$</strong> 的根树生成树数目；</li></ul></blockquote><h4 id="6-8-10-生成树的生成算法"><a href="#6-8-10-生成树的生成算法" class="headerlink" title="6.8.10 生成树的生成算法"></a>6.8.10 生成树的生成算法</h4><blockquote><p>不作介绍，有兴趣请查阅相关资料，例如《图论与代数结构》清华大学出版社 第3章 3.5节 支撑树的生成；</p></blockquote><h4 id="6-8-11-最小生成树算法"><a href="#6-8-11-最小生成树算法" class="headerlink" title="6.8.11 最小生成树算法"></a>6.8.11 最小生成树算法</h4><ul><li><p>Kruskal 算法</p><blockquote><p>思路：不断向初始化为空的根结点中加入当前未加入过的最短边，如果构成回路，一定是回路中的最长边，删除它；如果不构成回路则继续，直至达到 n-1 条边为止，此时 T 一定不含任何回路、n-1条边、包含所有图的顶点、所有权最小，在贪心法上是最小生成树；</p><p><strong>如何证明这个贪心算法的正确性？</strong></p><p>可以证明定理：$T=(V,E’)$ 是赋权连通图 $G=(V,E)$ 的最短树，当且仅当对任意的余树边 $e\in E-E’$，回路 $C^e(C^e\subseteq E’+e)$ 满足：其边权 $w(e)\ge w(a),\space a\in C^e\space(a\ne e)$；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T &lt;- Φ    // 树根结点初始化为空</span><br><span class="line">while (|T| &lt; n - 1 &amp;&amp; E(G) != Φ) &#123;</span><br><span class="line">    e &lt;- E中最短边</span><br><span class="line">    E &lt;- E - e</span><br><span class="line">    if (T + e 无回路) T &lt;- T + e</span><br><span class="line">&#125;</span><br><span class="line">if (|T| &lt; n - 1) 输出非连通的信息</span><br><span class="line">else return T</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(\varepsilon+p\space log\space\varepsilon),\space其中p为迭代次数$；适用于稀疏图（当p不大时）；</p></li><li><p>Prim 算法</p><blockquote><p>思路：在结点集中任选一个结点 v0 构成集合 V’，从 V’ 和 V-V’ 中各选一个顶点 u（来自 V-V’）、v（来自V’）使得 (u, v) 是满足条件的u、v中最短的边，将此边加入树 T，令 V’+=u，直至 V’=V；</p><p>感兴趣可以找一找定理的正确性证明；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t &lt;- v0, T &lt;- Φ, U &lt;- &#123;t&#125;</span><br><span class="line">while (U != V) &#123;</span><br><span class="line">    w(t, u) = min&#123;w(t, v)&#125; where v in (V - U)</span><br><span class="line">    T &lt;- T + e(t, u)</span><br><span class="line">    U &lt;- U + u</span><br><span class="line">    for (v in V - U) w(t, v) &lt;- min&#123;w(t, v), w(u, v)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(\nu^2)$；适用于稠密图；</p></li></ul><h3 id="6-9-常见题型和易错点"><a href="#6-9-常见题型和易错点" class="headerlink" title="6.9 常见题型和易错点"></a>6.9 常见题型和易错点</h3><p>⚠易错点</p><ul><li><p>导航适合使用<strong>有向多重图</strong>表示；</p></li><li><p>简单道路/回路<strong>可以针对非简单图</strong>，意味着可以经过自环、重边，但仅能经过一次；</p></li><li><p>平凡图一定是简单道路、初级道路，一定不是回路；</p></li><li><p>一个点很重要，虽然不知道有啥用：<strong>每个格雷码对应 n-cube $Q_n$ 上的一条 H 回路</strong>；</p></li><li><p>n 个结点的<strong>连通的简单平面图</strong>的边数 $m\le 3n-6$；</p></li><li><p>另一点涉及群论的知识，n 个结点组成的简单无向图的数目为 $2^{n(n-1)/2}$；</p><p>这些图里面互不同构的图的数量又为 $|X/G|=\sum\limits_b\dfrac{2^k}{\prod(b_i)\prod(c_i!)}$，其中 $k=\sum\limits_{i=1}^K\lfloor\dfrac{b_i}{2}\rfloor+\sum\limits_{i=1}^K\sum\limits_{j=1}^{i-1}gcd(b_i,b_j)$，$K$ 为将置换群拆为循环的个数（DFS计数）；</p><p>参考：<a href="https://oeis.org/A000088">A000088🔗</a>，计算结论：1，2，4，11，34，156，1044，……</p></li></ul><p>ℹ常见题型</p><ul><li>根据图的所有定理，判断/证明一定数量的结点度、结点数、边数等数量间的关系；</li><li>根据原图指出生成子图、导出子图；</li><li>给定一个图，判断是否有欧拉道路/回路、哈密顿回路/道路；</li><li>给定一个图，判断道路/回路、简单道路/回路、初级道路/回路；</li><li>给定一个图，判断连通分量、强连通分量；</li><li>给定一个图，找出哈夫曼编码；</li><li>给定一个图，找出最小生成树；</li></ul><h2 id="附录A：部分C-代码实现"><a href="#附录A：部分C-代码实现" class="headerlink" title="附录A：部分C++代码实现"></a>附录A：部分C++代码实现</h2><h3 id="A-1-图的存储实现"><a href="#A-1-图的存储实现" class="headerlink" title="A.1 图的存储实现"></a>A.1 图的存储实现</h3><ol><li><p>邻接矩阵存储法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjMatrixGraph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VType* vertices;    <span class="comment">// store the data of each vertex.</span></span><br><span class="line">    EType** edges;      <span class="comment">// store the data of each edge (in adjacent matrix form).</span></span><br><span class="line">    EType noEdgeFlag;    <span class="comment">// represent the no-edge area.</span></span><br><span class="line">    <span class="type">int</span> vertixNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vertexIdx</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertixNum; ++i)</span><br><span class="line">            <span class="keyword">if</span> (vertices[i] == v) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">vertexNotExists</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">bool</span> visited[])</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">adjMatrixGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">const</span> EType&amp; noEdge);</span><br><span class="line">    <span class="built_in">adjMatrixGraph</span>(<span class="type">const</span> adjMatrixGraph&lt;VType, EType&gt;&amp; cp) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">adjMatrixGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjMatrix</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_nonRecur</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>邻接表存储法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjListGraph</span>: <span class="keyword">public</span> graph&lt;VType, EType&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        EType weight;</span><br><span class="line">        eNode* next;</span><br><span class="line">        <span class="built_in">eNode</span>(): <span class="built_in">end</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">eNode</span>(<span class="type">const</span> EType&amp; w, <span class="type">int</span> e=<span class="number">0</span>, eNode* nxt=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">weight</span>(w), <span class="built_in">end</span>(e), <span class="built_in">next</span>(nxt) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">vNode</span> &#123;</span><br><span class="line">        VType data;</span><br><span class="line">        eNode* edge;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EulerNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> nodeIdx;</span><br><span class="line">        EulerNode* next;</span><br><span class="line">        <span class="built_in">EulerNode</span>(<span class="type">int</span> idx=<span class="number">0</span>, EulerNode* n=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">nodeIdx</span>(idx), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vNode* vertices;</span><br><span class="line">    <span class="type">bool</span> directed;</span><br><span class="line">    <span class="type">int</span> vertixNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vertexIdx</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertixNum; ++i)</span><br><span class="line">            <span class="keyword">if</span> (vertices[i].data == v) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">vertexNotExists</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typename</span> adjListGraph&lt;VType, EType&gt;::<span class="function">vNode* <span class="title">cloneBase</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">bool</span> visited[])</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _insert(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">const</span> EType&amp; w);</span><br><span class="line">    <span class="type">void</span> _remove(<span class="type">int</span> v1, <span class="type">int</span> v2);</span><br><span class="line">    <span class="type">int</span> _getInDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> _getOutDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> _getDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">void</span> _EulerCircuit(<span class="type">int</span> start, EulerNode*&amp; begin, EulerNode*&amp; end);</span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">topoSortIdx</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">criticalPath</span><span class="params">(<span class="type">int</span>* early, <span class="type">int</span>* late)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> prev[])</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">adjListGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">bool</span> direct=<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">adjListGraph</span>(<span class="type">const</span> adjListGraph&lt;VType, EType&gt;&amp; cp);</span><br><span class="line">    <span class="built_in">adjListGraph</span>(adjListGraph&lt;VType, EType&gt;&amp;&amp; tmp);</span><br><span class="line">    ~<span class="built_in">adjListGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getInDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getOutDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjList</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_nonRecur</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_dfs_tree</span><span class="params">(<span class="type">const</span> VType&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_bfs_tree</span><span class="params">(<span class="type">const</span> VType&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EulerCircuit</span><span class="params">(<span class="type">const</span> VType&amp; start)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">criticalPath</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// The shortest path for the graph: O(n^3)</span></span><br><span class="line">    <span class="function">VType* <span class="title">dijkstra</span><span class="params">(<span class="type">const</span> VType&amp; start, <span class="type">const</span> EType&amp; noEdge, <span class="type">bool</span> prompt=<span class="literal">false</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">VType* <span class="title">SPFA</span><span class="params">(<span class="type">const</span> VType&amp; start, <span class="type">const</span> EType&amp; noEdge)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="A-2-图的运算实现"><a href="#A-2-图的运算实现" class="headerlink" title="A.2 图的运算实现"></a>A.2 图的运算实现</h3><ol><li><p>邻接矩阵表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">adjMatrixGraph</span>(</span><br><span class="line">    <span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">const</span> EType&amp; noEdge) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = vSize; <span class="keyword">this</span>-&gt;edgeNum = <span class="number">0</span>; noEdgeFlag = noEdge;</span><br><span class="line">    vertices = <span class="keyword">new</span> VType[vSize];</span><br><span class="line">    edges = <span class="keyword">new</span> EType*[vSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vSize; ++i) &#123;</span><br><span class="line">        vertices[i] = vers[i];</span><br><span class="line">        edges[i] = <span class="keyword">new</span> EType[vSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vSize; ++j)</span><br><span class="line">            edges[i][j] = noEdge;</span><br><span class="line">        edges[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjMatrixGraph&lt;VType, EType&gt;::~<span class="built_in">adjMatrixGraph</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] vertices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] edges[i];</span><br><span class="line">    <span class="keyword">delete</span>[] edges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">bool</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">exist</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">return</span> edges[u][v] != noEdgeFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">undirected_insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    <span class="keyword">if</span> (edges[v][u] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = edges[v][u] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">remove</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] != noEdgeFlag) --<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = noEdgeFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">printAdjMatrix</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j)</span><br><span class="line">            std::cout &lt;&lt; edges[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>邻接表表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">bool</span> direct) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = vSize; directed = direct;</span><br><span class="line">    <span class="keyword">this</span>-&gt;edgeNum = <span class="number">0</span>; vertices = <span class="keyword">new</span> vNode[vSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vSize; ++i) &#123;</span><br><span class="line">        vertices[i].data = vers[i];</span><br><span class="line">        vertices[i].edge = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::~<span class="built_in">adjListGraph</span>() &#123;</span><br><span class="line">    eNode* curEdge;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curEdge = vertices[i].edge) &#123;</span><br><span class="line">            vertices[i].edge = curEdge-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> curEdge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vertices) <span class="keyword">delete</span>[] vertices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> adjListGraph&lt;VType, EType&gt;::vNode* adjListGraph&lt;VType, EType&gt;::<span class="built_in">cloneBase</span>() <span class="type">const</span> &#123;</span><br><span class="line">    vNode* newVers = <span class="keyword">new</span> vNode[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        newVers[i].data = vertices[i].data;</span><br><span class="line">        newVers[i].edge = <span class="literal">nullptr</span>;</span><br><span class="line">        eNode** curEdgeDst = &amp;(newVers[i].edge);</span><br><span class="line">        eNode* curEdgeSrc = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdgeSrc) &#123;</span><br><span class="line">            *curEdgeDst = <span class="keyword">new</span> <span class="built_in">eNode</span>(curEdgeSrc-&gt;weight, curEdgeSrc-&gt;end, <span class="number">0</span>);</span><br><span class="line">            curEdgeDst = &amp;((*curEdgeDst)-&gt;next);</span><br><span class="line">            curEdgeSrc = curEdgeSrc-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newVers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(<span class="type">const</span> adjListGraph&lt;VType, EType&gt;&amp; cp) &#123;</span><br><span class="line">    vertices = cp.<span class="built_in">cloneBase</span>(); <span class="keyword">this</span>-&gt;edgeNum = cp.edgeNum;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = cp.vertixNum; directed = cp.directed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(adjListGraph&lt;VType, EType&gt;&amp;&amp; tmp) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;edgeNum = tmp.edgeNum; <span class="keyword">this</span>-&gt;vertixNum = tmp.vertixNum; directed = tmp.directed;</span><br><span class="line">    tmp.edgeNum = tmp.vertixNum = <span class="number">0</span>; vertices = tmp.vertices; tmp.vertices = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">bool</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">exist</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="type">const</span> eNode* cur = vertices[u].edge;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;end == v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::_insert(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    eNode** cur = &amp;(vertices[v1].edge);</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;end != v2) cur = &amp;((*cur)-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (!(*cur)) &#123; ++<span class="keyword">this</span>-&gt;edgeNum; *cur = <span class="keyword">new</span> <span class="built_in">eNode</span>(w, v2); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::_remove(<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">    eNode** cur = &amp;(vertices[v1].edge);</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;end != v2) cur = &amp;((*cur)-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (*cur) &#123;</span><br><span class="line">        eNode* tmp = *cur; *cur = (*cur)-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp; --<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    _insert(u, v, w);</span><br><span class="line">    <span class="keyword">if</span> (!directed) _insert(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">remove</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    _remove(u, v);</span><br><span class="line">    <span class="keyword">if</span> (!directed) _remove(v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getInDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == v) <span class="keyword">continue</span>;</span><br><span class="line">        eNode* curEdge = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEdge-&gt;end == v) ++ans;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getOutDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    eNode* target = vertices[v].edge;</span><br><span class="line">    <span class="keyword">while</span> (target) &#123; ++ans; target = target-&gt;next; &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (directed) <span class="keyword">return</span> _getInDegree(v) + _getOutDegree(v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> _getOutDegree(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getInDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getInDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getOutDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getOutDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">printAdjList</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; vertices[i].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">const</span> eNode* cur = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;|-w=&quot;</span> &lt;&lt; cur-&gt;weight</span><br><span class="line">                &lt;&lt; <span class="string">&quot;-&gt;(&quot;</span> &lt;&lt; cur-&gt;end &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="A-3-图的遍历算法"><a href="#A-3-图的遍历算法" class="headerlink" title="A.3 图的遍历算法"></a>A.3 图的遍历算法</h3><ol><li><p>DFS：邻接表表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>(<span class="type">int</span> start, <span class="type">bool</span> visited[]) <span class="type">const</span> &#123;</span><br><span class="line">    eNode* curEdge = vertices[start].edge;</span><br><span class="line">    std::cout &lt;&lt; vertices[start].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[curEdge-&gt;end]) <span class="built_in">dfs</span>(curEdge-&gt;end, visited);</span><br><span class="line">        curEdge = curEdge-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs_nonRecur</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; tasks;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// Necessary when doing non-recursive op.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            eNode* curEdge = vertices[tmp].edge;</span><br><span class="line">            <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[curEdge-&gt;end])</span><br><span class="line">                    tasks.<span class="built_in">push</span>(curEdge-&gt;end);</span><br><span class="line">                curEdge = curEdge-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>DFS：邻接矩阵表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>(<span class="type">int</span> start, <span class="type">bool</span> visited[]) <span class="type">const</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; vertices[start] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i] &amp;&amp; edges[start][i] != noEdgeFlag)</span><br><span class="line">            <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs_nonRecur</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; tasks;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;</span><br><span class="line">            std::cout &lt;&lt; vertices[tmp] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tmp + <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; edges[tmp][j] != noEdgeFlag)</span><br><span class="line">                    tasks.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>BFS：邻接表表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">bfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; taskQ;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        taskQ.<span class="built_in">enQueue</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!taskQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = taskQ.<span class="built_in">deQueue</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// necessary.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            eNode* curEdge = vertices[tmp].edge;</span><br><span class="line">            <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[curEdge-&gt;end])</span><br><span class="line">                    taskQ.<span class="built_in">enQueue</span>(curEdge-&gt;end);</span><br><span class="line">                curEdge = curEdge-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>BFS：邻接矩阵表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">bfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; taskQ;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        taskQ.<span class="built_in">enQueue</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!taskQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = taskQ.<span class="built_in">deQueue</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// necessary when doing no-recursive op.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tmp + <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; edges[tmp][j] != noEdgeFlag)</span><br><span class="line">                    taskQ.<span class="built_in">enQueue</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="本文的-PDF-文档下载"><a href="#本文的-PDF-文档下载" class="headerlink" title="本文的 PDF 文档下载"></a>本文的 PDF 文档下载</h2><p>遇到不习惯、网页观看体验不好的，可以下载本文的 <a href="DM.pdf">PDF 文档📎</a> 进行阅读，使用时请勿传播，感谢配合！</p><p>———————————-EOF——————————-</p>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Discrete-Math </tag>
            
            <tag> Graph </tag>
            
            <tag> Logic </tag>
            
            <tag> Set-Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习-第四部分</title>
      <link href="//review/data-structure-4/"/>
      <url>//review/data-structure-4/</url>
      
        <content type="html"><![CDATA[<p><i><u>本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充</u></i></p><p><i>Written by SJTU-XHW</i></p><p><i>Reference: 张同珍老师 PPT | UNIkeEN</i></p><hr><span id="more"></span><h2 id="Chapter-8-外部查找和排序"><a href="#Chapter-8-外部查找和排序" class="headerlink" title="Chapter 8 外部查找和排序"></a>Chapter 8 外部查找和排序</h2><h3 id="8-1-零碎概念集合"><a href="#8-1-零碎概念集合" class="headerlink" title="8.1 零碎概念集合"></a>8.1 零碎概念集合</h3><ul><li><p>内存与外存的特性：外存读取访问速率 &lt;&lt; 内存访问速率；</p><p><strong>尽可能避免访问，宁可增加计算量……</strong></p></li><li><p>记录：外存上的<strong>一个数据元素</strong>通常被称为一条记录；</p></li><li><p>磁道：磁盘表面储存信息的同心圆轨道；</p></li><li><p>扇区：磁盘的磁道被分为若干段，每段被称为一个扇区；</p><blockquote><p>一个扇区相当于磁带上的一个数据块，也称<strong>磁盘块</strong>，是<strong>一次磁盘读写</strong>的单位；</p></blockquote></li></ul><h3 id="8-2-B-树"><a href="#8-2-B-树" class="headerlink" title="8.2 B 树"></a>8.2 B 树</h3><ul><li><p>定义：存储在<strong>外存</strong>上的动态查找表：</p><p>一棵 m 阶 B 树或者为空，或者满足：</p><ol><li><p>根结点的度 <strong>$d_r\in\{0\}\space\bigcup\space[2,\space m]$</strong>；</p></li><li><p>除了根结点和叶结点外，每个结点的度 <strong>$d\in[\space\lceil\dfrac{m}{2}\rceil,\space m\space]$</strong>；</p></li><li><p>度为s（s＞0）的结点具有 n = s-1 个关键字，信息存放方式： </p><script type="math/tex; mode=display">(n,\space A_0,\space(K_1, R_1),\space A_1,\space...,\space(K_n, R_n), A_n)</script><ul><li>已排序：$K_1\le K_2\le …\le K_n$</li><li><strong>$n$</strong>：关键字数；</li><li><strong>$A_i$</strong>：指向满足关键字 <strong>$K_i\lt K\lt K_{i+1}$</strong> 的后继结点 的<strong>地址（是磁盘地址编号，可以类比为为内存中的指针）</strong>；</li><li><strong>$(K_i, R_i)$</strong>：键值对，{关键字K、目标文件块的地址R}；</li></ul></li><li><p>所有叶结点在同一层，且深度相同、不存在信息（也称“失败结点”）；</p></li></ol></li><li><p>加速原理：已知访问次数 <strong>$\varpropto$</strong> 查找树高度；</p></li><li><p>运算实现</p><ul><li><p>查找：类似二叉查找树，只不过多了“在结点中查找区间的步骤”</p></li><li><p>插入</p><p><strong>step 1. 先查找，再插入：注意结点内关键字的有序性</strong></p><blockquote><p>可能违反B树定义1+2：<strong>结点的度可能会超过阶数m</strong>，因此进入第二步；</p></blockquote><p><strong>step 2. 判断当前插入位的关键字数n（在插入前的）</strong></p><ul><li><strong>$n\le m-1$</strong>，则不影响，插入结束；</li><li><strong>$n=m$</strong>，<strong>必须分裂结点，进入第三步</strong>；</li></ul><p><strong>step 3. 分裂结点</strong></p><blockquote><p>不能违反定义1：根结点的度 ≥ 2，和定义2：非根非叶结点度 <strong>$\ge\lceil\dfrac{m}{2}\rceil$</strong>；</p></blockquote><p>假设原结点<strong>插入后</strong>：</p><script type="math/tex; mode=display">(m,\space A_0,\space(K_1, R_1),\space A_1,\space...,\space(K_{m}, R_{m}), A_{m})</script><p>则<strong>对半分割结点</strong>：</p><script type="math/tex; mode=display">\begin{aligned}&(\lceil\dfrac{m}{2}\rceil-1,\space A_0,\space(K_1,\space R_1),...,(K_{\lceil\cfrac{m}{2}\rceil-1},R_{\lceil\cfrac{m}{2}\rceil-1}),\space A_{\lceil\cfrac{m}{2}\rceil-1}):\space共\lceil\dfrac{m}{2}\rceil-1个\\&(m-\lceil\dfrac{m}{2}\rceil,\space A_{\lceil\cfrac{m}{2}\rceil},\space(K_{\lceil\cfrac{m}{2}\rceil},\space R_{\lceil\cfrac{m}{2}\rceil}),...,(K_m,\space R_m),\space A_m):\space 共m-\lceil\dfrac{m}{2}\rceil个\\&注:数学上有\space m-\lceil\dfrac{m}{2}\rceil\ge\lceil\dfrac{m}{2}\rceil-1\end{aligned}</script><p>再将中间的结点：<strong>$(K_{\lceil\cfrac{m}{2}\rceil},\space R_{\lceil\cfrac{m}{2}\rceil})$</strong> 提到父结点上用以分开两个分裂结点；</p><p><strong>step 4. 提升到父结点后，对父结点递归第二步，检查是否违反定义，并及时修正</strong></p><p><img src="BTreeInsert.jpg"></p></li><li><p>删除</p><p><strong>step 1. 先查找关键字 $K_i$ 的位置，判断是否在底层（下一层为失败结点）</strong></p><blockquote><p>如果是，跳过第二步；</p></blockquote><p><strong>step 2. 找“替身”，使用右子树最左关键字（或左子树最右关键字，都位于底层）取代，然后转化为删除底层关键字</strong></p><p><strong>step 3. 删除底层结点（注意不是失败结点）</strong></p><blockquote><p>不能违反定义1、2：根节点度……非根非叶结点度……；</p></blockquote><ul><li><p>删除后，关键字个数 <strong>$n\in[\space\lceil\dfrac{m}{2}\rceil-1\space,m-1\space]$</strong>，符号定义，删除结束；</p></li><li><p>删除后，关键字个数 <strong>$n=\lceil\dfrac{m}{2}\rceil-2$</strong>，则需要向左 / 右兄弟节点借关键字；</p><blockquote><p>借的步骤（以左兄弟为例，如果左兄弟恰好<strong>$\lceil\dfrac{m}{2}\rceil-1$</strong>没法借，借右兄弟）：</p><p>将左兄弟的最大关键字上移至父结点，再将父结点中大于该关键字的最小关键字（连同左兄弟最右边的指针）下移给被删关键字所在结点的最左边。完成。</p></blockquote></li><li><p>删除后，左、右兄弟结点都是 <strong>$n^\prime=\lceil\dfrac{m}{2}\rceil-1$</strong>，没法借，那么需要<strong>合并结点</strong>；</p><blockquote><p>合并步骤（以合并左兄弟为例，右兄弟同理）：</p><p>将该结点与左兄弟合并，同时下移父结点位于这两个结点间的关键字；</p><p><strong>同时，这种情况必须递归检查父结点，如果父结点也因为减少一个关键字而不符定义，则也“先借，不行再合并”</strong></p></blockquote></li></ul></li><li><p>运算实现的形象记忆：<strong>膨胀直到分裂；太瘦吸收两侧结点；都瘦合并结点</strong></p></li></ul></li></ul><ul><li><p>常见疑问：B树的阶数怎么确定？B树的结点怎么组织？算法设计中怎么快速找父结点？</p><p>Answer：</p><ul><li><p>针对第一个问题，应该在实际应用中根据<strong>磁盘块大小、关键字长度、磁盘块地址长度</strong>共同确定B树的阶数；B树阶数的计算思路和B+树类似，可以参考后面<a href="#BPCalc">B+树的阶数计算🔗</a>；</p></li><li><p>针对第二个问题，和之前的数据结构不一样，B树存在外存上而非内存上，所以我们要定义先确定B树的阶数<strong>【没错，每棵B树的阶数在生命周期中是定值，不能变化】</strong>，然后事先在磁盘块的对应位置分配好各个结点、各个字段的空间位置，这样一棵B树就固定下来了！<strong>以后每访问B树的一个结点（在一个磁盘块大小中），就由 $A_i$ 的指引，在规定的空间完成就行</strong>；</p></li><li>针对第三个问题，在理解第二个问题后会发现，B树（包括B+树）的父结点的位置可以结合结点在磁盘上的分布（具体设计具体分析）计算出来（或者记录下来，因为存在外存的数据一定很大，一个地址的大小可以忽略不计），不用特意寻找浪费时间；</li></ul></li></ul><h3 id="8-3-B-树"><a href="#8-3-B-树" class="headerlink" title="8.3 B+ 树"></a>8.3 B+ 树</h3><blockquote><p>出现原因：B树支持快速查找某个记录，但如果要<strong>按关键字大小顺序访问文件的所有记录</strong>，那么时间效率低下；需要一个新型索引结构，来完成对于<strong>索引顺序文件（支持随机访问、按关键字顺序访问的文件）</strong>的访问；</p><ol><li><p>保证索引有序（像 B 树结点中关键字有序）</p></li><li><p>保证文件的记录有序</p></li></ol></blockquote><ul><li><p>定义：M 阶 B+ 树是满足如下条件的 M 叉树：</p><ul><li><p>根的度满足 <strong>$d_r\in\{0\}\space\bigcup\space[2,\space M]$</strong>；</p></li><li><p>除根以外的<strong>所有结点</strong>的度满足  <strong>$d\in[\space\lceil\dfrac{M}{2}\rceil,\space M\space]$</strong>；</p></li><li><p>度为 k 的结点保存 k - 1 个键来引导查找，<strong>第 i 个键代表第 i + 1 子树中的键的最小值</strong></p><blockquote><p>这意味着 B+ 树和 B 树不同，B+树中非底层（叶结点的上一层）结点存储的键都是出现在底层结点的！</p></blockquote></li><li><p>叶结点包含<strong>数据块（为了访问结点的效率，一个数据块的大小应该设计为一个磁盘块的大小，使得机器在一次 I/O 读写就能完全将内容读进内存）</strong>，其中存放若干记录（键-值对），同时叶结点按序连成单链表；</p><blockquote><p>这意味着 B+ 树的叶结点 和 非叶结点的<strong>类型不一样</strong>，即内含数据成员不一样；</p></blockquote></li><li><p>叶结点中的每个数据块至少 <strong>$\lceil\dfrac{L}{2}\rceil$</strong> 个记录，至多 L 个记录；</p></li></ul></li></ul><ul><li><p>B树、B+树重难点题</p><ul><li><p><span id="BPCalc">B+树阶数计算</span></p><blockquote><p>已知：一棵 B+ 树的一个非叶结点预分配：M-1个键、M个指针（记录磁盘地址）；叶结点预分配：L个记录、1个指针（构成单链表，但相对于L个记录可忽略不计）；</p><p><img src="BPTreeS.jpg"></p></blockquote><p>假设：一个磁盘块 W Bytes、一个记录 R Bytes、一个关键字 K Bytes、一个磁盘地址大小 A Bytes，则：</p><script type="math/tex; mode=display">\begin{equation}\left\{  \begin{aligned}&K\cdot(M-1)+A\cdot M\le W\\  &L\cdot R\le W\quad(A\ll L\cdot R)\\  \end{aligned}  \right.\end{equation}  \qquad (一般都取等、取整作最优情况)</script></li><li><p>插入/删除某个元素后，B/B+树的结构变成什么样子；</p></li><li><p><strong>含有 n（n＞0）个非叶结点的 m 阶 B 树至少包含多少个关键字、至多包含多少个关键字？</strong>；</p><blockquote><p>分析：</p><p>最少关键字时，每个结点都取最少的度；根结点最小度为2（n＞0 保证根结点不是叶结点）、其他非叶结点最小度为 $\lceil \dfrac{m}{2}\rceil$，所以最小关键字为：$(n-1)(\lceil \dfrac{m}{2}\rceil-1)+1$ ；</p><p>最多关键字时，每个结点取最多的度，所有非叶结点的最大度都是 m，所以最多关键字是 $n(m - 1)$；</p></blockquote></li><li><p>一棵 m 阶 B 树有 N 个关键字，则这棵 B 树的最大高度、最小高度（高度含叶结点）分别是？</p><blockquote><p>分析：</p><p>最大高度在所有非叶结点都取最小度时取得（根度为2，非根非叶度为 m/2 向上取整），不妨假设此时高度为 h，非叶结点所占高度为 h - 1；由于 B 树的叶结点在同一层，各个结点非常整齐，那么反推总非叶结点数（包括根结点）：</p><script type="math/tex; mode=display">\begin{aligned}n_{NL}&=1+2+2\cdot\lceil \dfrac{m}{2}\rceil+\cdots+2\cdot(\lceil\dfrac{m}{2}\rceil)^{h-3}\\&=1+2\cdot\dfrac{(\lceil\cfrac{m}{2}\rceil)^{h-2}-1}{\lceil\cfrac{m}{2}\rceil-1}\end{aligned}</script><p>结合”非根非叶度为 m/2 向上取整”的结论，所有非叶结点的关键字数（包括根结点）：</p><script type="math/tex; mode=display">\begin{aligned}N&=(n_{NL}-1)\cdot(\lceil \dfrac{m}{2}\rceil-1)+1\\&=2(\lceil \dfrac{m}{2}\rceil)^{h-2}-1\end{aligned}</script><p>所以：$h\le2+log_{\lceil\cfrac{m}{2}\rceil}(\dfrac{N+1}{2})$；</p><p>最小高度同理:</p><script type="math/tex; mode=display">\begin{aligned}n_{NL}&=1+\sum\limits_{k=1}^{h-2}{m^k}=1+\dfrac{m(m^{h-2}-1)}{m-1}\\N&=(n_{NL}-1)\cdot(m-1)+m-1=m^{h-1}-1\end{aligned}</script><p>所以：$h\ge 1+log_m(N+1)$；</p></blockquote><p>综上，得到 B 树的高度结论（其中高度 h 包含叶结点）：</p><p><strong>含 N 个关键字的 m 阶 B 树的高度 $h\in[1+log_m(N+1),\space 2+log_{\lceil\cfrac{m}{2}\rceil}(\dfrac{N+1}{2})],\space h\in \mathbf{N^*}$</strong></p></li><li><p>什么？你问 B+ 树的关键字、高度的计算呢？B+ 树的关键字都在叶结点里，非叶结点中的只是对叶结点的重复、索引，讨论的意义不大；算 B+ 树的阶数才是重点；</p></li></ul></li></ul><ul><li><p>运算实现</p><ul><li><p>查找：略</p></li><li><p>插入</p><blockquote><p>和 B 树类似，但需要注意的是，B+ 树和 B 树不同，在非叶结点中的键一定存在记录中，并且表示第 i + 1棵子树的最小值，<strong>所以在分裂结点时，没有上移的说法</strong>；</p></blockquote></li><li><p>删除：和 B 树对应的解决方案，<strong>先领养，不行再合并</strong></p></li></ul></li></ul><h3 id="8-4-外排序"><a href="#8-4-外排序" class="headerlink" title="8.4 外排序"></a>8.4 外排序</h3><blockquote><p>一般都使用归并排序，这在外排序中极其优秀；</p></blockquote><p>⚠<strong>易错警示：如果题目说：”多阶段归并是为了最大限定地提高归并的路数“是正确的。不是说多阶段归并本身能提高归并路数，是因为多阶段归并能够提高”路“的利用率（对k路，总路数2k降为k+1），这样在同样大小的内存中，可以选取更大的k值。所以多阶段归并的目的也可以说成（在一定的资源条件下）为了最大限度地提高归并的路数</strong>；</p><p><img src="ExSort.jpg"></p><p>█◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤图部分将结合离散数学-图论知识共同复习◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█</p><h2 id="Chapter-9-图"><a href="#Chapter-9-图" class="headerlink" title="Chapter 9 图"></a>Chapter 9 图</h2><h3 id="9-1-图论中的重要定义Ⅰ"><a href="#9-1-图论中的重要定义Ⅰ" class="headerlink" title="9.1 图论中的重要定义Ⅰ"></a>9.1 图论中的重要定义Ⅰ</h3><blockquote><p>图的起源：人们关心一类问题，给定的两点间是否有一条或多条连线的关系，而连接方式无关紧要。这类问题在数学上的抽象是<strong>图</strong>；</p></blockquote><ul><li><p>图的数学定义：一个图指<strong>有序三元组$(V(G),E(G),\psi_G)$</strong>，<strong>$V(G)$</strong>为<strong>非空</strong>（空图特殊，不参与讨论）顶点集，<strong>$E(G)$</strong>是不与<strong>$V(G)$</strong>相交的边集，<strong>$\psi_G$</strong>为关联函数；</p><blockquote><p>约定：对于图 G，一般用符号 <strong>$V(G)$</strong> 表示顶点集、<strong>$E(G)$</strong> 表示边集、<strong>$\nu(G)$</strong> 表示顶点数，<strong>$\varepsilon(G)$</strong> 表示边数；若上下文仅有一个图，则省略 “(G)”；</p><p>注：无向图可以表示为二元组，即 V 和 E；</p></blockquote></li><li><p>顶点对的定义：<strong>$\psi_G$</strong> 使 G 的每条边对应于 G 的 无序的<strong>顶点对</strong>；</p></li><li><p>连接、端点的定义：若 e 为 G 的一条边，u、v 是使 <strong>$\psi_G(e)=(u,v)$</strong> 的顶点，则称：e <strong>连接</strong> u、v，顶点 u、v 称为 e 的<strong>端点</strong>；</p></li><li><p>关联、相邻、自环：一条边的端点与这条边<strong>关联</strong>；与同一条边关联的两个顶点称为<strong>相邻</strong>；端点重合为一点的边称为<strong>自环</strong>；</p></li><li><p>平面图、非平面图：边仅在端点相交的图称为<strong>平面图</strong>，反之为非平面图；</p></li><li><p>平凡图、非平凡图：仅有一个顶点的图称为<strong>平凡图</strong>；</p></li><li><p>有向边、无向边：可由端点 <strong>$v_i\space和\space v_j$</strong> 表示 <strong>$e_k=(v_i,v_j)$</strong> 的边称为<strong>无向边</strong>（vi、vj互为直接前驱、直接后继）；可由有序二元组 <strong>$e_k=\lt v_i,v_j\gt$</strong> 表示的边是<strong>有向边</strong>（vi是vj的直接前驱、vj是vi的直接后继）；</p></li><li><p>有向图、无向图：所有边都是有向边的图是<strong>有向图</strong>，反之是<strong>无向图</strong>，否则是混合图；</p><blockquote><p>可以将无向边视作双向有向边，因此此后不讨论混合图；</p></blockquote></li><li><p>简单图、有向简单图：既没有<strong>自环</strong>，又没有<strong>重边</strong>的图，如果是无向图，称为<strong>简单图</strong>；如果是有向图，称为<strong>有向简单图</strong>；</p><blockquote><ol><li><p>重边的定义：有两条及以上条边连接同一对顶点，称这个边为重边；</p><p>⚠<strong>易错警示：对有向边，A—-&gt;B 和 B—-&gt;A 组合不算重边！A—-&gt;B 和 A—-&gt;B 组合才是</strong>；</p></li><li><p>如果不强调“有向”，一般情况下“图”指“无向图”；不过在定义中，如果发现只描述无向图的，大概率对有向图也适用，不然就单独拎出来了；</p></li></ol></blockquote></li><li><p>完全图、有向完全图：每对不同顶点都有一条边相连的<strong>简单</strong>图称为<strong>完全图</strong>；有向完全图同理；</p><p><strong>特别地，将 n 个结点的完全图记作 $K_n$，但有向完全图没有这种记法；</strong></p><blockquote><p><strong>定理1：$\varepsilon(K_n)=C^2_{n}$ 且对n 个结点的有向完全图G：$\varepsilon(G)=A^2_{n}$；</strong></p><p>（因为A—-&gt;B 和 B—-&gt;A 组合不算重边） </p></blockquote></li><li><p>偶图（或者称二部图）：一个图 G 的顶点集 <strong>$V(G)$</strong> 可以分解为两个子集 X、Y，使得：每条边都有一个顶点在 X 中，另一个顶点在 Y 中；这样的一种分类 (X, Y) 称为 G 的一个<strong>二分类</strong>；</p><blockquote><p>理解：按分解的两个点集“切一刀”，所有边都被砍断的图；</p></blockquote></li><li><p>子图：若 <strong>$V(H)\subseteq V(G),\space E(H)\subseteq E(G)$</strong>，<strong>$\psi_H$</strong> 为 <strong>$\psi_G$</strong> 在 <strong>$E(H)$</strong> 上的限制，则 <strong>$H$</strong> 为 <strong>$G$</strong> 的<strong>子图</strong>，记作：<strong>$H\subseteq G$</strong>；（真子图略）</p></li><li><p>母图：若 <strong>$H\subseteq G$</strong>，称 <strong>$G$</strong> 为 <strong>$H$</strong> 的<strong>母图</strong>；</p></li><li><p>生成子图（或称支撑子图，spanning sub-graph）：<strong>$H\subseteq G\space且\space V(H)=V(G)$</strong>，称 <strong>$H$</strong> 为 <strong>$G$</strong> 的<strong>生成子图</strong>；</p></li><li><p>导出子图：有点抽象，一般用不到定义，想要形象地了解见：<a href="#graphCalc">图的运算🔗</a>；</p></li><li><p>基础简单图：一个图 G 删去所有<strong>“多余”的边</strong>，使图中恰没有重边、自环，得到的这样的<strong>简单生成子图</strong>称为<strong>基础简单图</strong>；</p></li><li><p>赋权图（或称加权图）：若给图 G 的每条边都赋以实数 <strong>$w_k$</strong> 作为该边的权，称 G 为赋权图；</p></li><li><p>顶点的度：图 G 的顶点 v 的度记为 <strong>$d_G(v)$</strong>，指 G 中与 v 相关联的数目；</p><ul><li>约定：<strong>$\delta(G)、\Delta(G)$</strong> 表示 G 的所有顶点的最小度、最大度；</li><li>度为0的点称为<strong>孤立点</strong>；</li><li><strong>对于有向图，$d(v)=d_+(v)+d_-(v)$，$d_+$ 为正度/入度，$d_-$ 为负度/出度</strong>；</li><li><strong>自环贡献一个入度、一个出度</strong>；</li></ul><blockquote><p><strong>定理2：（握手定理）$\sum\limits_{v\in V}d(v)=2\varepsilon$（所有结点的度之和为边数的2倍，有向图也是）</strong>；</p><p>推论：对任何图，度为奇数的点（称<strong>奇点</strong>）的个数为偶数；</p><p><strong>定理3：有向图中，$\sum{d_-}=\sum{d_+}=\varepsilon$（入度和=出度和=边数，是入度出度平分的意思）</strong></p><p><strong>定理4：非空简单图（$\varepsilon\gt1$）一定存在度相同的结点</strong>；</p></blockquote></li></ul><h3 id="9-2-图的同构"><a href="#9-2-图的同构" class="headerlink" title="9.2 图的同构"></a>9.2 图的同构</h3><blockquote><p>注：图同构问题分为4类：精确图完全同构、精确子图同构、不精确图完全同构、不精确子图同构；现在学界已证明后三者是 NP 完全问题；计算机离散数学-图论、数据结构（包括下面的内容）讨论的是第一种问题；</p></blockquote><ul><li><p>恒等图的定义</p></li><li><p>同构图的定义：如果存在两个<strong>一一映射（双射）$\theta:\space V(G)\rightarrow V(H),\space\phi:\space E(G)\rightarrow E(H)$</strong>，使 <strong>$\psi_G(e)=(u,v)$</strong> 当且仅当 <strong>$\psi_H(\phi(e))=\theta(u)\theta(v)$</strong>，则将这样的映射对 <strong>$(\theta,\phi)$</strong> 称为 G 和 H 间的一个同构；将 G 与 H 同构关系记为 <strong>$G\cong H$</strong>；</p><blockquote><p>理解：边边和点点必须一一相应；</p><p>就是在不添加边和点、不删除边和点的基础上<strong>任意移动顶点的相对位置、为顶点和边改名</strong>，所产生的不同形态的图；</p></blockquote></li><li><p>关于同构的定理</p><blockquote><p><strong>定理5：（同构的必要条件）两个同构图的结点度的非增序列相同</strong></p><p><strong>定理6：（同构的必要条件）若 G1 与 G2 同构，则 G1 的任意<u>导出子图</u>都有 G2 的导出子图与其同构</strong>；</p><p>其实还有一个必要条件过于明显，不作为定理：两同构图的顶点数、边数相等；</p></blockquote></li><li><p>判断方法</p><ul><li><p>判断两图同构：<strong>按定义，找到两个一一映射</strong>；</p><blockquote><p>注：根据定义，可以得出一个显然的方法：<strong>一个图的邻接矩阵经历有限次的行互换、列互换，能变成另一个图的邻接矩阵，那么这两个图同构</strong>；</p></blockquote></li><li><p>判断两图不同构：使用定理5、6（必要条件），不满足必要条件的就不是；</p></li></ul></li></ul><h3 id="9-3-图的存储实现"><a href="#9-3-图的存储实现" class="headerlink" title="9.3 图的存储实现"></a>9.3 图的存储实现</h3><ul><li><p><span id="relM">图的关联矩阵（<strong>行是顶点，列是边</strong>）：因为空间原因，不做存储图的方法；</span></p><blockquote><p>虽然不做存储方法，但在讨论<strong>树、有向连通图、电路图的某些性质</strong>时比较有用，感兴趣戳<a href="#relMDetails">这里🔗</a>（不在初级数据结构要求范围内）；</p></blockquote><ul><li>无向图的关联矩阵：可以由 bool 矩阵表示，1是有关联，0是没有关联；</li><li>有向图的关联矩阵：+1表示该边离开该结点，即正度/出度；-1表示该边进入该结点，即负度/入度；0表示没有关联；</li></ul></li><li><p>图的邻接矩阵表示法：对任意的图 G，对应一个 <strong>$\nu\times\nu$</strong> 的邻接矩阵 <strong>$A(G)=[a_{ij}]$</strong>，其中 <strong>$a_{ij}$</strong> 为 <strong>$v_i、v_j$</strong> 的连接数目；（空间：<strong>$O(|V|^2)$</strong>）</p><p><strong>进一步，在数据结构中更常用的是“加权图的邻接矩阵”存储方法，可以兼顾非加权图：</strong></p><script type="math/tex; mode=display">A[i][j]=\begin{equation}\left\{\begin{aligned}&\omega,&<i,j,w>\in E\\&0,&i=j\\&\infty,&otherwise\\\end{aligned}\right.\end{equation}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjMatrixGraph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VType* vertices;    <span class="comment">// store the data of each vertex.</span></span><br><span class="line">    EType** edges;      <span class="comment">// store the data of each edge (in adjacent matrix form).</span></span><br><span class="line">    EType noEdgeFlag;    <span class="comment">// represent the no-edge area.</span></span><br><span class="line">    <span class="type">int</span> vertixNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vertexIdx</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertixNum; ++i)</span><br><span class="line">            <span class="keyword">if</span> (vertices[i] == v) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">vertexNotExists</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">bool</span> visited[])</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">adjMatrixGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">const</span> EType&amp; noEdge);</span><br><span class="line">    <span class="built_in">adjMatrixGraph</span>(<span class="type">const</span> adjMatrixGraph&lt;VType, EType&gt;&amp; cp) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">adjMatrixGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjMatrix</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_nonRecur</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>图的邻接表表示法：改进了邻接矩阵表示法在面对稀疏矩阵时浪费空间、不易维护的问题；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">结点集(结点数组)：node1 &#123;结点值，与该结点相邻的直接后继(有方向)结点索引链表头指针&#125;</span><br><span class="line"> |------------------------------------------------------------|</span><br><span class="line"> v</span><br><span class="line">边集(单链表)：node2 &#123;结点索引（不能放结点值，因为无法完成后面的遍历运算, 下一node2&#125;</span><br><span class="line"></span><br><span class="line">+ 保存边数、保存结点数</span><br><span class="line">空间：O(|V|+|E|)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjListGraph</span>: <span class="keyword">public</span> graph&lt;VType, EType&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        EType weight;</span><br><span class="line">        eNode* next;</span><br><span class="line">        <span class="built_in">eNode</span>(): <span class="built_in">end</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">eNode</span>(<span class="type">const</span> EType&amp; w, <span class="type">int</span> e=<span class="number">0</span>, eNode* nxt=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">weight</span>(w), <span class="built_in">end</span>(e), <span class="built_in">next</span>(nxt) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">vNode</span> &#123;</span><br><span class="line">        VType data;</span><br><span class="line">        eNode* edge;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EulerNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> nodeIdx;</span><br><span class="line">        EulerNode* next;</span><br><span class="line">        <span class="built_in">EulerNode</span>(<span class="type">int</span> idx=<span class="number">0</span>, EulerNode* n=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">nodeIdx</span>(idx), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vNode* vertices;</span><br><span class="line">    <span class="type">bool</span> directed;</span><br><span class="line">    <span class="type">int</span> vertixNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vertexIdx</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertixNum; ++i)</span><br><span class="line">            <span class="keyword">if</span> (vertices[i].data == v) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">vertexNotExists</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typename</span> adjListGraph&lt;VType, EType&gt;::<span class="function">vNode* <span class="title">cloneBase</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">bool</span> visited[])</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _insert(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">const</span> EType&amp; w);</span><br><span class="line">    <span class="type">void</span> _remove(<span class="type">int</span> v1, <span class="type">int</span> v2);</span><br><span class="line">    <span class="type">int</span> _getInDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> _getOutDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> _getDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">void</span> _EulerCircuit(<span class="type">int</span> start, EulerNode*&amp; begin, EulerNode*&amp; end);</span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">topoSortIdx</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">criticalPath</span><span class="params">(<span class="type">int</span>* early, <span class="type">int</span>* late)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> prev[])</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">adjListGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">bool</span> direct=<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">adjListGraph</span>(<span class="type">const</span> adjListGraph&lt;VType, EType&gt;&amp; cp);</span><br><span class="line">    <span class="built_in">adjListGraph</span>(adjListGraph&lt;VType, EType&gt;&amp;&amp; tmp);</span><br><span class="line">    ~<span class="built_in">adjListGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getInDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getOutDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjList</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_nonRecur</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_dfs_tree</span><span class="params">(<span class="type">const</span> VType&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_bfs_tree</span><span class="params">(<span class="type">const</span> VType&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EulerCircuit</span><span class="params">(<span class="type">const</span> VType&amp; start)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">criticalPath</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// The shortest path for the graph: O(n^3)</span></span><br><span class="line">    <span class="function">VType* <span class="title">dijkstra</span><span class="params">(<span class="type">const</span> VType&amp; start, <span class="type">const</span> EType&amp; noEdge, <span class="type">bool</span> prompt=<span class="literal">false</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">VType* <span class="title">SPFA</span><span class="params">(<span class="type">const</span> VType&amp; start, <span class="type">const</span> EType&amp; noEdge)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-4-图的运算实现（except-for-traverse）"><a href="#9-4-图的运算实现（except-for-traverse）" class="headerlink" title="9.4 图的运算实现（except for traverse）"></a>9.4 图的运算实现（except for traverse）</h3><ul><li><p><span id="graphCalc">图的基本运算</span></p><ul><li><p>差运算：<strong>（要求 $G_2$ 为 $G_1$ 子图）$G_1-G_2=(V_1,E_1-E_2)$</strong>；</p></li><li><p>补运算：<strong>$n$</strong> 个结点的简单图的补图 <strong>$\overline{G}=K_n-G$</strong>；</p></li><li><p>删去结点 <strong>$v$</strong> 及其关联的边：<strong>$G-v$</strong></p><blockquote><p><strong>$G-v$</strong> 为 <strong>$G$</strong> 的<strong>导出子图</strong>：有助于理解导出子图的意义；</p></blockquote></li><li><p>删去边 <strong>$e$</strong>：<strong>$G-e$</strong></p><blockquote><p><strong>$G-e$</strong> 为 <strong>$G$</strong> 的<strong>生成子图</strong>：有助于理解生成子图的意义；</p></blockquote></li><li><p>增加边 <strong>$e_{ij}=(v_i,v_j)$</strong>：<strong>$G+e_{ij}$</strong></p></li></ul></li><li><p>数据结构中图的基本运算：创建、判边、增删边、查点边数、遍历（后面分开讨论）；</p></li><li><p>图的运算实现：<strong>对于不同的存储方式，图的运算时间复杂度有所不同</strong></p><ul><li><p>邻接矩阵表示的运算实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">adjMatrixGraph</span>(</span><br><span class="line">    <span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">const</span> EType&amp; noEdge) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = vSize; <span class="keyword">this</span>-&gt;edgeNum = <span class="number">0</span>; noEdgeFlag = noEdge;</span><br><span class="line">    vertices = <span class="keyword">new</span> VType[vSize];</span><br><span class="line">    edges = <span class="keyword">new</span> EType*[vSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vSize; ++i) &#123;</span><br><span class="line">        vertices[i] = vers[i];</span><br><span class="line">        edges[i] = <span class="keyword">new</span> EType[vSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vSize; ++j)</span><br><span class="line">            edges[i][j] = noEdge;</span><br><span class="line">        edges[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjMatrixGraph&lt;VType, EType&gt;::~<span class="built_in">adjMatrixGraph</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] vertices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] edges[i];</span><br><span class="line">    <span class="keyword">delete</span>[] edges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">bool</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">exist</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">return</span> edges[u][v] != noEdgeFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">undirected_insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    <span class="keyword">if</span> (edges[v][u] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = edges[v][u] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">remove</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] != noEdgeFlag) --<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = noEdgeFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">printAdjMatrix</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j)</span><br><span class="line">            std::cout &lt;&lt; edges[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>邻接表表示的运算实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">bool</span> direct) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = vSize; directed = direct;</span><br><span class="line">    <span class="keyword">this</span>-&gt;edgeNum = <span class="number">0</span>; vertices = <span class="keyword">new</span> vNode[vSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vSize; ++i) &#123;</span><br><span class="line">        vertices[i].data = vers[i];</span><br><span class="line">        vertices[i].edge = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::~<span class="built_in">adjListGraph</span>() &#123;</span><br><span class="line">    eNode* curEdge;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curEdge = vertices[i].edge) &#123;</span><br><span class="line">            vertices[i].edge = curEdge-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> curEdge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vertices) <span class="keyword">delete</span>[] vertices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> adjListGraph&lt;VType, EType&gt;::vNode* adjListGraph&lt;VType, EType&gt;::<span class="built_in">cloneBase</span>() <span class="type">const</span> &#123;</span><br><span class="line">    vNode* newVers = <span class="keyword">new</span> vNode[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        newVers[i].data = vertices[i].data;</span><br><span class="line">        newVers[i].edge = <span class="literal">nullptr</span>;</span><br><span class="line">        eNode** curEdgeDst = &amp;(newVers[i].edge);</span><br><span class="line">        eNode* curEdgeSrc = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdgeSrc) &#123;</span><br><span class="line">            *curEdgeDst = <span class="keyword">new</span> <span class="built_in">eNode</span>(curEdgeSrc-&gt;weight, curEdgeSrc-&gt;end, <span class="number">0</span>);</span><br><span class="line">            curEdgeDst = &amp;((*curEdgeDst)-&gt;next);</span><br><span class="line">            curEdgeSrc = curEdgeSrc-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newVers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(<span class="type">const</span> adjListGraph&lt;VType, EType&gt;&amp; cp) &#123;</span><br><span class="line">    vertices = cp.<span class="built_in">cloneBase</span>(); <span class="keyword">this</span>-&gt;edgeNum = cp.edgeNum;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = cp.vertixNum; directed = cp.directed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(adjListGraph&lt;VType, EType&gt;&amp;&amp; tmp) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;edgeNum = tmp.edgeNum; <span class="keyword">this</span>-&gt;vertixNum = tmp.vertixNum; directed = tmp.directed;</span><br><span class="line">    tmp.edgeNum = tmp.vertixNum = <span class="number">0</span>; vertices = tmp.vertices; tmp.vertices = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">bool</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">exist</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="type">const</span> eNode* cur = vertices[u].edge;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;end == v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::_insert(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    eNode** cur = &amp;(vertices[v1].edge);</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;end != v2) cur = &amp;((*cur)-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (!(*cur)) &#123; ++<span class="keyword">this</span>-&gt;edgeNum; *cur = <span class="keyword">new</span> <span class="built_in">eNode</span>(w, v2); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::_remove(<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">    eNode** cur = &amp;(vertices[v1].edge);</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;end != v2) cur = &amp;((*cur)-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (*cur) &#123;</span><br><span class="line">        eNode* tmp = *cur; *cur = (*cur)-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp; --<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    _insert(u, v, w);</span><br><span class="line">    <span class="keyword">if</span> (!directed) _insert(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">remove</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    _remove(u, v);</span><br><span class="line">    <span class="keyword">if</span> (!directed) _remove(v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getInDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == v) <span class="keyword">continue</span>;</span><br><span class="line">        eNode* curEdge = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEdge-&gt;end == v) ++ans;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getOutDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    eNode* target = vertices[v].edge;</span><br><span class="line">    <span class="keyword">while</span> (target) &#123; ++ans; target = target-&gt;next; &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (directed) <span class="keyword">return</span> _getInDegree(v) + _getOutDegree(v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> _getOutDegree(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getInDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getInDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getOutDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getOutDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">printAdjList</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; vertices[i].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">const</span> eNode* cur = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;|-w=&quot;</span> &lt;&lt; cur-&gt;weight</span><br><span class="line">                &lt;&lt; <span class="string">&quot;-&gt;(&quot;</span> &lt;&lt; cur-&gt;end &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="9-5-图论中的重要定义Ⅱ"><a href="#9-5-图论中的重要定义Ⅱ" class="headerlink" title="9.5 图论中的重要定义Ⅱ"></a>9.5 图论中的重要定义Ⅱ</h3><ul><li><p>道路和回路：在无向图 <strong>$G=(V,E)$</strong> 中，若<u>边点交替序列</u> <strong>$P=(v_{i1},e_{i1},v_{i2},e_{i2},…,e_{iq-1},v_{iq})$</strong> 满足：<strong>$v_{ik}、v_{ik+1}$</strong> 为 <strong>$e_{ik}$</strong> 的两个端点，则称 P 为 G 的一条<strong>道路</strong>；特别地，如果 <strong>$v_{i1}=v_{iq}$</strong>，那么称道路 P 为 G 的一条<strong>回路</strong>；</p><ul><li>如果 P 序列中没有重复的边，则 P 称为<strong>简单道路（或称“迹”）、简单回路（或称“闭迹”）</strong>；</li><li>更特别地，如果 P 序列中结点也不重复（结点不重复是边不重复的充分不必要条件），则称 P 为 G 的<strong>初级道路、初级回路</strong>；</li></ul></li><li><p>有向道路和有向回路：在有向图 <strong>$G=(V,E,\psi_G)$</strong> 中，若<u>边序列</u> <strong>$P=(e_{i1},e_{i2},…,e_{iq})$</strong>，其中  <strong>$e_{ik}=(v_l, v_j)$</strong>，则称 P 为 G 的<strong>有向道路</strong>；若 <strong>$e_{iq}$</strong> 终点也是 <strong>$e_{i1}$</strong> 的始点，则称 P 为 G 的<strong>有向回路</strong>；</p><ul><li>同样有：简单有向道路、简单有向回路、初级有向道路、初级有向回路的概念；</li></ul><blockquote><p>⚠易错点：<strong>平凡图一定是道路，但一定不是回路！</strong></p></blockquote></li><li><p>连通性、强连通性、弱连通性、单向连通性</p><ul><li>无向图考虑“连通”：两结点间至少存在一条道路，则这两个结点间连通；</li><li>有向图考虑：<ol><li>两结点间存在一条从 <strong>$v_i$</strong> 到 <strong>$v_j$</strong> 的有向道路 <strong><u>且</u></strong> 存在另一条从 <strong>$v_j$</strong> 到 <strong>$v_i$</strong> 的有向道路，则称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>强连通</strong>；</li><li>两结点间<strong><u>仅</u></strong>存在一条从 <strong>$v_i$</strong> 到 <strong>$v_j$</strong> 的有向道路 <strong><u>或</u></strong> <strong><u>仅</u></strong>存在另一条从 <strong>$v_j$</strong> 到 <strong>$v_i$</strong> 的有向道路，则称称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>单向连通</strong>；</li><li>两结点间 <strong>不考虑所有道路的方向（称为“有向图的底图”）</strong>，若这两个结点连通，则称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>弱连通</strong>；</li></ol></li></ul></li><li><p>连通图、连通分量（或称“连通支”）</p><ul><li>无向图 G 中任意两结点间都是连通的，则 G 为<strong>连通图</strong>；</li><li>G 的连通子图（子图且连通）H 不是 G 的任何其他连通子图的真子图，称 H 为 G 的一个<strong>极大连通子图</strong>，也称<strong>连通分量</strong>；</li></ul><blockquote><p>有些不严谨的题问有向图“是不是连通图”，就将它看成一个无向图（忽略方向）；</p></blockquote></li><li><p>强连通图、强连通分量</p><ul><li>有向图 G 中任意两结点间都是强连通的，则 G 为<strong>强连通图</strong>；</li><li>G 的强连通子图 H 不是 G 的任何其他强连通子图的真子图，称 H 为 G 的一个<strong>极大的强连通子图</strong>，也称<strong>强连通分量</strong>；</li></ul><blockquote><p>⚠易错点1：<strong>平凡图也单独算一个连通分量 / 强连通分量！</strong></p><p>⚠易错点2：因为无向边看作“双向边”，所以连通的无向图一定是强连通的；</p><p><strong>推论：图 G 的每个连通分支都是其导出子图</strong>；</p><p><strong>小结论：图 G 对应关联矩阵记为 $M(G)$，则 G 的连通分支数为 $r(M(G))-1$</strong>；</p></blockquote></li><li><p>割边与非割边、割点与非割点：删去图中某个边 / 点，图的连通分支数（连通性）改变，则称该边 / 点为<strong>割边 / 割点</strong>；</p></li><li><p>欧拉道路、欧拉回路：<strong>无向连通图</strong> G 中的一条经过<u>所有边</u>的<strong>简单道路/回路</strong>称 G 的<strong>欧拉道路/回路</strong>；</p><ul><li><p>理解：不重复地遍历所有边，不管点的情况；</p></li><li><p>注意：<strong>有向图也能讨论欧拉回路的问题，不过要遵循有向的连通性</strong>；</p></li></ul><blockquote><p><strong>定理1：（欧拉回路充要条件）无向连通图 G 存在欧拉回路 $\Longleftrightarrow$ G 的各结点度数均为偶数</strong>；</p><p><strong>推论1-1：（欧拉道路充分条件）无向连通图 G 仅有2个奇点 $\Longrightarrow$ G 存在欧拉道路</strong>；</p><p><strong>推论1-2：（有向欧拉回路充分条件）有向连通图 G 的各结点的正、负度数相等 $\Longrightarrow$ G 存在有向欧拉回路</strong>（侧面说明有向可能严格一些，不仅结点度全为偶数，而且要进出相等）；</p><p>定理2：连通图 G 有 k 个奇点（由部分Ⅰ的定理可知，k为偶数），则 E(G) 可以划分为 <strong>$\dfrac{k}{2}$</strong> 条简单道路；</p></blockquote></li><li><p>哈密顿道路、哈密顿回路：<strong>无向图</strong> G 的一条<u>经过全部结点</u>的<strong>初级道路/回路</strong>称 G 的<strong>哈密顿道路/回路（简称H道路/H回路）</strong>；</p><ul><li>理解：“不重复地遍历所有点”；</li><li>注意：H 道路 / 回路一般针对简单图，因为重边和自环对它没有什么影响，可以转换为简单图的问题；</li></ul><blockquote><p><strong>很遗憾，目前 H 道路 / 回路的判定没有充要条件！一般遍历是 NP 问题……</strong></p><p><strong>定理3：（H 回路充分条件）完全图 $K_n$ 为 H 图</strong>；</p><p><strong>定理4：（H 回路充分条件）若简单图 G 每个结点度都大于 n/2，则 G 为 H 图</strong>；</p><p>说明：平均每个点的度越大，越有可能有H道路、H回路；</p><p><strong>推论4-1：（H 道路充分条件）若简单图 G 的任两结点 $v_i,v_j$ 恒有 $d(v_i)+d(v_j)\ge n-1$，则 G 存在 H 道路；</strong></p><p>证明提示：有 H 道路一定连通，可以先证连通性；</p><p><strong>推论4-2：（H 回路充分条件）若简单图 G 的任两结点 $v_i,v_j$ 恒有 $d(v_i)+d(v_j)\ge n$，则 G 为 H 图</strong>；</p><p><strong>推论4-3：（H 回路的闭包等价关系）向图 G 中满足 “ $d(v_i)+d(v_j)\ge n$”的不相邻两结点 $v_i,v_j$ 加边，直至无法找到这样的结点对为止，形成的新图称为 G 的闭包（记为$C(G)$）；那么有：$G\space为H图\Longleftrightarrow C(G)为H图$</strong>；</p><p><strong>推论4-4：（H回路闭包充分条件）若 $C(G)=K_n$，则 G 为 H 图</strong>；</p><p><strong>定理5：（可怜为数不多的 H 回路的必要条件）若 G 为 H 图，则对任意非空顶点集 S，有：$\omega(G-S)\le|S|$</strong>；</p></blockquote><ul><li><p>补充：欧拉图、H 图的定义：有欧拉回路 / H 回路的图才叫~（只有欧拉道路 / H 道路的不是）；</p></li><li><p>判断一个图是 H 图：使用上面的充分条件/等价条件；</p></li><li><p>判断一个图不是 H 图：使用上面的必要条件；</p><blockquote><p>举例：证明 Peterson 图是极大非 H 图（有 H 道路，但没有 H 回路）</p><p>【问题：它满足定理5，能否判断一下为什么在删去任意4个顶点时，连通分支数一定小于等于3？】</p><p><strong>定理6：（必要条件）若一个点在 H 回路中，那么必定有且仅有两个相连的相异道路</strong>；</p></blockquote></li></ul></li></ul><h3 id="9-6-图的简单应用"><a href="#9-6-图的简单应用" class="headerlink" title="9.6 图的简单应用"></a>9.6 图的简单应用</h3><ul><li>【普通图】有 3L、5L、8L的三个没有刻度的量杯，现在8L的量杯装满了水，其他两个是空的；问如何操作（不撒不漏）可以让8L水分为两个4L水？</li><li>【二部图】人、狼、羊、菜过河问题</li></ul><blockquote><p>解决思路：<strong>“状态转换图”：</strong>将每一个状态抽象为一个顶点，先列出所有可能状态作为顶点，再用“一次能直接转换的关系”作为边连接，最后只需判断在起点（初态）和终点（末态）是否单向连通即可；</p></blockquote><h3 id="9-7-图论中的重要定义Ⅲ"><a href="#9-7-图论中的重要定义Ⅲ" class="headerlink" title="9.7 图论中的重要定义Ⅲ"></a>9.7 图论中的重要定义Ⅲ</h3><blockquote><p>提示：本章节不在初级数据结构要求范围内；</p></blockquote><ul><li><p>割边与非割边、割点与非割点：删去图中某个边 / 点，图的连通分支数（连通性）改变，则称该边 / 点为<strong>割边 / 割点</strong>；</p><blockquote><p><strong>定理1：e 为割边，当且仅当 e 不属于 G 的任何回路</strong>；</p></blockquote></li><li><p>普通树的数学定义：不含任何回路的连通图称为<strong>树</strong>；</p><blockquote><p><strong>定理2：“连通”、“无回路”、“有 n-1 条边”三个条件任取两个都可以作为树的定义</strong>；</p><p>推论：“连通+全为割边”、“任意两点间有唯一道路”、“无回路+加一边就一回路” 这三个与树的定义等价；</p><p><strong>定理3：树中一定有树叶结点（离散数学中没有空树的说法！只有空图）</strong></p></blockquote></li><li><p>根树的定义：若树 T 是有向树，且 T 中存在某结点 $v_0$ 的入度为0、其他结点入度为1，则称 <strong>T 是以 $v_0$ 为根的根树</strong>（或外向树），用 $\overrightarrow{T}$ 表示；</p><blockquote><p><strong>根树才是数据结构中的“树”！</strong></p></blockquote></li><li><p>生成树（或称“支撑树”）：图 G 的一个符合树定义的生成子图称为图 G 的<strong>生成树</strong>；</p><blockquote><p>余树：给定图 G 的一棵生成树 T，定义余树 $\overline{T}=G-T$；一般情况下，余树不是树；</p></blockquote></li><li><p><span id="relMDetails">基本关联矩阵：<strong>上接“<a href="#relM">关联矩阵存储🔗</a>”，虽然关联矩阵一般不作为存储方法，但有些情况讨论它的性质，可以更方便地解决某些问题</strong>；</span></p><blockquote><p>友情提醒1：这里和<strong>电路理论的电路图研究</strong>结合比较紧密；</p><p>友情提醒2：这里的讨论对象是<strong>有向连通图</strong>；</p></blockquote><ul><li>定义：在<strong>有向连通图 $G=(V, E)$</strong> 的<strong>关联矩阵 $B$</strong> 中，划去任意任意结点 $v_k$所对应的一<strong>行</strong>，得到 <strong>$(\nu-1)\times\varepsilon$</strong> 的矩阵 $B_k$，称为 <strong>G 的一个基本关联矩阵</strong>；</li><li>相关定理</li></ul><blockquote><p><strong>定理1：有向连通图 G 的关联矩阵 B 满足：$r(B)=\nu-1$</strong>；</p><p><strong>定理2：有向连通图 G 的基本关联矩阵 $B_k$ 满足：$r(B_k)=\nu-1$</strong>；</p><p>推论：n个结点树 T 的基本关联矩阵的秩为 $\nu-1$；</p><p><strong>定理3：有向连通图 G 如果存在回路 C，则 C 中各边所对应基本关联矩阵 $B_k$ 的各列线性相关</strong>；</p><p><strong>定理4：有向连通图 G 的基本关联矩阵 $B_k$，有：$B_k任意n-1阶子式M_{n-1}\ne0\Longleftrightarrow M_{n-1}各列对应边构成G的一棵生成树$</strong>；</p><p>定理4说明了<strong>可以由 $B_k$ 的非零 n-1 阶子式的数目来代表 $G$ 生成树的数目<a href="#genTCount">🔗</a></strong>；</p></blockquote></li><li><p>回路矩阵和割集矩阵；</p><blockquote><p>不说了亲，这边建议您好好复习电路理论课呢:sweat_smile:</p></blockquote></li><li><p>Huffman树（最优二叉树），详见“数据结构复习-第二部分”；</p></li></ul><h3 id="9-8-图的经典算法"><a href="#9-8-图的经典算法" class="headerlink" title="9.8 图的经典算法"></a>9.8 图的经典算法</h3><h4 id="9-8-1-图的遍历算法"><a href="#9-8-1-图的遍历算法" class="headerlink" title="9.8.1 图的遍历算法"></a>9.8.1 图的遍历算法</h4><ul><li><p>DFS 算法：类似树的前序遍历</p><p>邻接表存储 $O(|V|+|E|)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>(<span class="type">int</span> start, <span class="type">bool</span> visited[]) <span class="type">const</span> &#123;</span><br><span class="line">    eNode* curEdge = vertices[start].edge;</span><br><span class="line">    std::cout &lt;&lt; vertices[start].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[curEdge-&gt;end]) <span class="built_in">dfs</span>(curEdge-&gt;end, visited);</span><br><span class="line">        curEdge = curEdge-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs_nonRecur</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; tasks;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// Necessary when doing non-recursive op.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            eNode* curEdge = vertices[tmp].edge;</span><br><span class="line">            <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[curEdge-&gt;end])</span><br><span class="line">                    tasks.<span class="built_in">push</span>(curEdge-&gt;end);</span><br><span class="line">                curEdge = curEdge-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻接矩阵存储 $O(|V|^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>(<span class="type">int</span> start, <span class="type">bool</span> visited[]) <span class="type">const</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; vertices[start] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i] &amp;&amp; edges[start][i] != noEdgeFlag)</span><br><span class="line">            <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs_nonRecur</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; tasks;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;</span><br><span class="line">            std::cout &lt;&lt; vertices[tmp] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tmp + <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; edges[tmp][j] != noEdgeFlag)</span><br><span class="line">                    tasks.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BFS 算法：类似树的层次遍历</p><p>邻接表存储 $O(|V|+|E|)$ </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">bfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; taskQ;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        taskQ.<span class="built_in">enQueue</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!taskQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = taskQ.<span class="built_in">deQueue</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// necessary.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            eNode* curEdge = vertices[tmp].edge;</span><br><span class="line">            <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[curEdge-&gt;end])</span><br><span class="line">                    taskQ.<span class="built_in">enQueue</span>(curEdge-&gt;end);</span><br><span class="line">                curEdge = curEdge-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻接矩阵存储 $O(|V|^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">bfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; taskQ;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        taskQ.<span class="built_in">enQueue</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!taskQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = taskQ.<span class="built_in">deQueue</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// necessary when doing no-recursive op.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tmp + <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; edges[tmp][j] != noEdgeFlag)</span><br><span class="line">                    taskQ.<span class="built_in">enQueue</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-8-2-两点间道路判定算法"><a href="#9-8-2-两点间道路判定算法" class="headerlink" title="9.8.2 两点间道路判定算法"></a>9.8.2 两点间道路判定算法</h4><blockquote><p>这里介绍邻接矩阵表示的算法，比较常见；</p></blockquote><ul><li><p>引入：对于一个<strong>非加权图的邻接矩阵（0&amp;1）</strong>，有 $P=(p_{ij})_{n\times n}=\sum\limits_{k=1}^n{A^k}$，则 $p_{ij}$ 为从 $v_i$ 到 $v_j$ 的<strong>道路数</strong>；实际问题只关心<strong>是否有道路</strong>，所以可以改成逻辑运算提升速度：$P=(p_{ij})_{n\times n}=\bigvee\limits_{k=1}^n{A^k}$，时间复杂度 $O(\nu^4)$；</p></li><li><p>Warshell算法 $O(\nu^3)$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P &lt;- A</span><br><span class="line">for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">    for (int j = 1; j &lt;= n; ++j)</span><br><span class="line">        for (int k = 1; k &lt;= n; ++k)</span><br><span class="line">            p_&#123;jk&#125; &lt;- p_&#123;jk&#125; V (p_&#123;ji&#125; Λ p_&#123;ik&#125;)</span><br></pre></td></tr></table></figure></li><li><p>DFS 和 BFS $O(\varepsilon)$：和图的遍历不一样的是，它比图的遍历更简单，只需从一个点出发（减少最外层循环），用visited数组和BFS/DFS整体寻找，如果遇到终点即停止并返回true，否则返回false；</p></li></ul><h4 id="9-8-3-有向图强连通分支判断算法"><a href="#9-8-3-有向图强连通分支判断算法" class="headerlink" title="9.8.3 有向图强连通分支判断算法"></a>9.8.3 有向图强连通分支判断算法</h4><blockquote><p>思路：先从图 G 任一点开始 DFS，如果 G 不是强连通图，则可能得到一个深度优先生成森林；对森林中的每棵树按照<strong>生成次序</strong>依此进行<strong>后序遍历</strong>，并按遍历顺序给每个结点编号（从小到大）；</p><p>然后使 G 的每条边逆向，得到 Gr，再从 Gr 编号最大的结点开始 DFS，得到新的深度优先遍历森林中的<strong>每一棵树</strong>就是 G 的一个强连通分量；</p></blockquote><h4 id="9-8-4-欧拉回路的构造算法"><a href="#9-8-4-欧拉回路的构造算法" class="headerlink" title="9.8.4 欧拉回路的构造算法"></a>9.8.4 欧拉回路的构造算法</h4><blockquote><p>欧拉回路有明确的、好判断的充要条件，所以算法设计相对容易；</p><p>无论啥算法，最好先利用充要条件排除没有欧拉回路的图，能大大提高时间性能；</p><p>下面讨论<strong>如果有欧拉回路，应该怎么找</strong>的算法：</p></blockquote><ul><li>拼接法：DFS寻找回路（经过即删除），如果回路结束却仍然有未遍历的结点，则从新的未访问的结点开始遍历回路，<strong>并拼接（“8”字原理）</strong>，循环直到所有边已被访问；</li><li>Floyd算法（非割边优先遍历）</li></ul><h4 id="9-8-5-欧拉回路的应用：中国邮递员问题（CPP）"><a href="#9-8-5-欧拉回路的应用：中国邮递员问题（CPP）" class="headerlink" title="9.8.5 欧拉回路的应用：中国邮递员问题（CPP）"></a>9.8.5 欧拉回路的应用：中国邮递员问题（CPP）</h4><blockquote><p>中国邮递员问题：<strong>走遍图中的所有边</strong>后返回返回起点，要求<strong>总路程最短</strong>；</p></blockquote><ul><li><p>对于无向图 G 的结论</p><ul><li><p>如果 G 中所有结点个数都是偶数：该图的任一欧拉回路都是解；</p></li><li><p>如果 G 中有且仅有 2 个奇点 $v_i\space和\space v_j$：找到 G 从  $v_i$ 到 $v_j$ <strong>欧拉道路 $E_{ij}$</strong>，再找从  $v_j$ 到 $v_i$ 的<strong>最短路径 $P_{ji}$</strong>，则回路 <strong>$E_{ij}+P_{ji}$</strong> 就是问题的解；</p></li><li><p>如果 G 中有两个以上，共2k个奇点（由前面图的性质推论，奇点必有偶数个）：</p><script type="math/tex; mode=display">图G有最佳邮路L\Longleftrightarrow\begin{equation}\left\{\begin{aligned}&1.\space L的任一边最多重复一次\\&2.\space对G中的任一回路C，L中在C上重复边的长度之和\\&\quad不超过C总长的一半\space(C必须包含所有重边)\\\end{aligned}\right.\end{equation}</script><p><strong>实际做法是：找出所有奇点，两两配对并依此为奇点间添加重复边（长度和原边相等），为它们配对成偶点，得到新图，也即邮路 $L_x$；再检查 $L_x$ 是否满足以上两个条件；如果违反第一条则一次性删除两条多余重边，如果违反第二条则将 $L_x$ 的该段道路改成与 $C$ 互补的道路</strong>；</p></li></ul></li></ul><h4 id="9-8-6-H-回路的应用：旅行商问题（TSP）"><a href="#9-8-6-H-回路的应用：旅行商问题（TSP）" class="headerlink" title="9.8.6 H 回路的应用：旅行商问题（TSP）"></a>9.8.6 H 回路的应用：旅行商问题（TSP）</h4><ul><li>问题描述：给定一个正权完全图，求总权最小的 H 回路；</li></ul><blockquote><p>NP 完全问题，只能寻找近似解；这里不介绍算法，仅介绍问题；提示：不建议使用贪心法，误差很大；</p></blockquote><h4 id="9-8-7-有向无环图、AOV网与拓扑排序"><a href="#9-8-7-有向无环图、AOV网与拓扑排序" class="headerlink" title="9.8.7 有向无环图、AOV网与拓扑排序"></a>9.8.7 有向无环图、AOV网与拓扑排序</h4><ul><li><p>有向无环图（DAG）：不存在回路的有向图称为<strong>有向无环图</strong>；</p></li><li><p>AOV网：<strong>有向无环图</strong>中的顶点表示活动，边表示活动间的先后关系，这样的图称为<strong>AOV网</strong>；</p></li><li><p>拓扑排序：将AOV网中的活动发生的先后次序排成一个序列（如果有一条从 u 到 v 的道路，那么 v 必须出现在 u 之后），称为<strong>拓扑排序</strong>，这个序列称为<strong>拓扑序列</strong>；</p></li><li><p>拓扑排序实现思路：类似于图的 BFS，但是<strong>只有一个结点的所有直接前驱结点都已访问后，才能访问这个结点</strong>；<strong>$O(|V|+|E|)$</strong></p><ol><li><p>计算每个结点的入度，保存在数组中；</p></li><li><p>检查入度数组中<strong>入度为零（无依赖）</strong>的对应结点索引，并将其入队；</p></li><li><p>当队伍非空时，循环出队并输出这个结点，在假设将这个结点删除，修正这个结点的所有直接结点的入度（减1），如此重复2、3步骤；</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请自行实现私有函数 int _getInDegree(int) 获取入度；</span></span><br><span class="line"><span class="comment">// 使用到了之前的seqQueue类；</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span>* adjListGraph&lt;VType, EType&gt;::<span class="built_in">topoSortIdx</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ans = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;; <span class="type">int</span> ansIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* inDegrees = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; preRequests;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        inDegrees[i] = _getInDegree(i);</span><br><span class="line">        <span class="keyword">if</span> (!inDegrees[i]) preRequests.<span class="built_in">enQueue</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!preRequests.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = preRequests.<span class="built_in">deQueue</span>();</span><br><span class="line">        ans[ansIdx++] = cur;</span><br><span class="line">        eNode* curEdge = vertices[cur].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--inDegrees[curEdge-&gt;end] == <span class="number">0</span>)</span><br><span class="line">                preRequests.<span class="built_in">enQueue</span>(curEdge-&gt;end);</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[i]) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR] A non-DAG does not support topoSort().&quot;</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] ans; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">topoSort</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* seq = <span class="built_in">topoSortIdx</span>();</span><br><span class="line">    <span class="keyword">if</span> (!seq) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        std::cout &lt;&lt; vertices[seq[i]].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-8-8-AOE网与关键路径"><a href="#9-8-8-AOE网与关键路径" class="headerlink" title="9.8.8 AOE网与关键路径"></a>9.8.8 AOE网与关键路径</h4><ul><li><p>AOE网络：活动定义在边上（持续时间），事件定义在顶点上；</p></li><li><p>AOE网络的重要两点：源点（入度为0，工程“起点”）、汇点（出度为0，工程“终点”）；</p></li><li><p>AOE网络解决的问题：完成整项任务的最少时间、哪些活动是影响工程进度的关键;</p></li><li><p>关键路径：从源点到汇点的<strong>最长</strong>路径称为<strong>关键路径</strong>；</p></li><li><p>关键活动：关键路径上的活动。<strong>推迟关键活动必定影响项目进度</strong>；</p></li><li><p>最早发生时间：用“从源点到该结点的<strong>最长路径</strong>”（因为和拓扑排序一样，只有该结点的所有直接前驱结点都访问过后，才能算访问了这个结点）表征；</p></li><li><p>最迟发生时间：用“关键路径长(定值) - 从汇点到该结点的<strong>最短路径</strong>”表征（因为是最迟，距离汇点最近才符合定义）；</p></li><li><p>时间余量：最迟发生时间 - 最早发生时间。<strong>时间余量为0的活动是关键活动（第二定义）</strong>；</p></li><li><p>找关键路径的思路：（用第二定义）<strong>就是找每个顶点的最早、最迟发生时间，进而得到关键活动、关键路径</strong>；</p><ol><li><p>找出AOE网的任一拓扑序列；</p></li><li><p>从头至尾遍历一次拓扑序列，在遍历到 u 时，更新它的<strong>所有</strong>直接后继结点 v 的最早发生时间（如果当前ee值＜u 的值+路径长，那么更新v的ee值为更大的）；</p></li><li><p>再从尾至头遍历一次拓扑序列，在遍历到 u 时，更新它的<strong>所有</strong>直接后继结点 v 的最迟发生时间（如果后继结点le值＜v 的值+路径长，那么更新为u为更小的）；</p><blockquote><p>别问为啥不和第二步相对应，找直接前驱结点，问就是找前驱结点复杂度太大了；</p><p>⚠<strong>记得更新最迟发生时间之前，要用第二步得到的关键路径长度（就是拓扑序列最后一个结点的ee值）填充最迟发生时间数组</strong>；</p></blockquote></li><li><p>找出所有“最早发生时间=最迟发生时间”的结点，按照拓扑序列的顺序依此输出，即为关键路径；</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">criticalPath</span>(<span class="type">int</span>* early, <span class="type">int</span>* late) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* topoSeq = <span class="built_in">topoSortIdx</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) early[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        eNode* curEdge = vertices[topoSeq[i]].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (early[topoSeq[i]] + curEdge-&gt;weight &gt; early[curEdge-&gt;end])</span><br><span class="line">                early[curEdge-&gt;end] = early[topoSeq[i]] + curEdge-&gt;weight;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pLen = early[topoSeq[<span class="keyword">this</span>-&gt;vertixNum - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) late[i] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">this</span>-&gt;vertixNum - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        eNode* curEdge = vertices[topoSeq[i]].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (late[topoSeq[i]] &gt; late[curEdge-&gt;end] - curEdge-&gt;weight)</span><br><span class="line">                late[topoSeq[i]] = late[curEdge-&gt;end] - curEdge-&gt;weight;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">criticalPath</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ee = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="type">int</span>* le = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="type">int</span> pathLen = <span class="built_in">criticalPath</span>(ee, le);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[INFO] The length of the critical path: &quot;</span> &lt;&lt; pathLen &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[INFO] The critical path: \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ee[i] == le[i]) std::cout &lt;&lt; vertices[i].data &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[Fin]\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-8-9-生成树的计数算法"><a href="#9-8-9-生成树的计数算法" class="headerlink" title="9.8.9 生成树的计数算法"></a>9.8.9 生成树的计数算法</h4><blockquote><p>原理：Binet-Cauchy 定理：两个矩阵 $A_{m\times n},\space B_{n\times m}\space(m\le n)$，则 $det(AB)=\sum\limits_i{A_iB_i}$ 。其中$A_i$、$B_i$ 分别是从 $A$ 中任取 $m$ 列、$B$ 中任取 $m$ 行构成的行列式；</p><p>虽然这样计算行列式有些麻烦，但它揭示了乘积矩阵行列式和各矩阵的子式之间的关系；</p><p><span id="genTCount"><strong>定理1：（有向连通图的普通生成树计数）设 $B_k$ 为有向连通图 $G=(V,E)$ 的某一基本关联矩阵，则 $G$ 中不同树的数目为 $det(B_kB_k^T)$</strong>；</span></p><ul><li>解题提示：如果要求<strong>不含</strong>某个边的生成树数目，只要求将该边删去后的生成子图对应生成树的数目；如果要求<strong>必含</strong>某个边的生成树数目，只要该边的起点终点合并为一点，求新图对应生成树的数目；</li></ul><p><strong>如果想求无向连通图的生成树个数，需要将其每条边指定一个任意方向转化为有向连通图</strong>；</p><ul><li><p>推论证明：求证<strong>完全图 $K_n$ 的不同生成树的数目为 $n^{n-2}$</strong>；</p><script type="math/tex; mode=display">det(B_kB_k^T)=\begin{vmatrix}n-1&-1&\cdots&-1\\-1&n-1&\cdots&-1\\\vdots&\vdots&\ddots&\vdots\\-1&-1&\cdots&n-1\end{vmatrix}=n^{n-2}</script></li><li><p>⚠易错警示：如果是求<strong>完全图 $K_n$ 不同构的生成树的数目</strong>，和<strong>“不同生成树”</strong>不一样！和化学上<strong>求同分异构体的做法类似</strong>；例如 $K_5$ 的不同构生成树数目为 3，对应有机化学戊烷的正戊烷、异戊烷、新戊烷的构型；</p></li></ul><p><strong>定理2：（有向连通图的根树生成树计数）设 $\overrightarrow{B_k}$ 表示将有向连通图 $G$ 的<u>关于结点 k 的</u>关联矩阵 $B_k$ 中所有的 1 元素换成 0 之后的矩阵，则 $G$ 中<u>以 k 为根的</u>不同根树数目为 $det(\overrightarrow{B_k}B_k^T)$</strong>；</p><ul><li>解题提示：如果要求<strong>不含</strong>某个边的根树生成树数目，删去这个边再算；</li><li>⚠易错警示：和普通生成树不同，如果要求<strong>必含</strong>某个边的根树生成树数目，需要先计算以 v0 为根的总根树数目，再减去不含这个边的生成树数目；<strong>或者求 $G^\prime=G-\{(t,v)|t\ne u\}$</strong> 的根树生成树数目；</li></ul></blockquote><h4 id="9-8-10-生成树的生成算法"><a href="#9-8-10-生成树的生成算法" class="headerlink" title="9.8.10 生成树的生成算法"></a>9.8.10 生成树的生成算法</h4><blockquote><p>不作介绍，有兴趣请查阅相关资料，例如《图论与代数结构》清华大学出版社 第3章 3.5节 支撑树的生成；</p></blockquote><h4 id="9-8-11-最小生成树算法"><a href="#9-8-11-最小生成树算法" class="headerlink" title="9.8.11 最小生成树算法"></a>9.8.11 最小生成树算法</h4><ul><li><p>Kruskal 算法</p><blockquote><p>思路：不断向初始化为空的根结点中加入当前未加入过的最短边，如果构成回路，一定是回路中的最长边，删除它；如果不构成回路则继续，直至达到 n-1 条边为止，此时 T 一定不含任何回路、n-1条边、包含所有图的顶点、所有权最小，在贪心法上是最小生成树；</p><p><strong>如何证明这个贪心算法的正确性？</strong></p><p>可以证明定理：$T=(V,E’)$ 是赋权连通图 $G=(V,E)$ 的最短树，当且仅当对任意的余树边 $e\in E-E’$，回路 $C^e(C^e\subseteq E’+e)$ 满足：其边权 $w(e)\ge w(a),\space a\in C^e\space(a\ne e)$；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T &lt;- Φ    // 树根结点初始化为空</span><br><span class="line">while (|T| &lt; n - 1 &amp;&amp; E(G) != Φ) &#123;</span><br><span class="line">    e &lt;- E中最短边</span><br><span class="line">    E &lt;- E - e</span><br><span class="line">    if (T + e 无回路) T &lt;- T + e</span><br><span class="line">&#125;</span><br><span class="line">if (|T| &lt; n - 1) 输出非连通的信息</span><br><span class="line">else return T</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(\varepsilon+p\space log\space\varepsilon),\space其中p为迭代次数$；适用于稀疏图（当p不大时）；</p></li><li><p>Prim 算法</p><blockquote><p>思路：在结点集中任选一个结点 v0 构成集合 V’，从 V 和 V-V’ 中各选一个顶点 u（来自V）、v（来自V-V’）使得 (u, v) 是满足条件的u、v中最短的边，将此边加入树 T，令 V’+=u，直至 V’=V；</p><p>感兴趣可以找一找定理的正确性证明；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t &lt;- v0, T &lt;- Φ, U &lt;- &#123;t&#125;</span><br><span class="line">while (U != V) &#123;</span><br><span class="line">    w(t, u) = min&#123;w(t, v)&#125; where v in (V - U)</span><br><span class="line">    T &lt;- T + e(t, u)</span><br><span class="line">    U &lt;- U + u</span><br><span class="line">    for (v in V - U) w(t, v) &lt;- min&#123;w(t, v), w(u, v)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(\nu^2)$；适用于稠密图；</p></li></ul><h4 id="9-8-12-最短路径算法"><a href="#9-8-12-最短路径算法" class="headerlink" title="9.8.12 最短路径算法"></a>9.8.12 最短路径算法</h4><p>正在更新中……———————————————————————</p>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data-Structure </tag>
            
            <tag> Discrete-Math </tag>
            
            <tag> External-Search </tag>
            
            <tag> B+Tree </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习-第三部分</title>
      <link href="//review/data-structure-3/"/>
      <url>//review/data-structure-3/</url>
      
        <content type="html"><![CDATA[<p><i><u>本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充</u></i></p><p><i>Written by SJTU-XHW</i></p><p><i>Reference: 张同珍老师 PPT | UNIkeEN</i></p><hr><span id="more"></span><p>注：以下所有用到的键值对定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">    KEY key;</span><br><span class="line">    VAL value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Chapter-7-集合、查找表"><a href="#Chapter-7-集合、查找表" class="headerlink" title="Chapter 7 集合、查找表"></a>Chapter 7 集合、查找表</h2><h3 id="7-1-集合的零碎概念总结"><a href="#7-1-集合的零碎概念总结" class="headerlink" title="7.1 集合的零碎概念总结"></a>7.1 集合的零碎概念总结</h3><ul><li><p>键值对（C++：pair）：由一对键、值构成的结构体，值可以有多个、可以相同；但键可以相互比较，在单重集中具有唯一性；</p></li><li><p>集合的特征：无序性（集合中元素间没有前驱后继等关系）、确定性、互异性（多重集中没有此要求，但本部分也不涉及）；</p></li><li><p>集合的建议存储方式：散列存储；</p></li><li><p>集合的基本运算形式：创、清、增（插入）删<strong>查（集合中最重要、最基本的运算）；</strong></p><hr></li><li><p>查找：确定指定关键字值的数据元素在查找表中是否存在；</p></li><li><p>查找表：用于查找的数据结构都称之为~；</p></li><li><p>静态查找表、动态查找表</p><ul><li>一般采用数组/线性结构存储、无需改变增删元素的查找表；</li><li>一般采用树形结构 / 散列结构存储、需要实时增删元素的查找表；</li></ul></li><li><p>内部查找、外部查找</p><ul><li>被查找元素全部存放于内存中的查找操作，称内部查找，否则称外部查找；</li><li><strong>内部查找以比较次数为衡量时间性能的标准；外部查找（访问速率 &lt;&lt; 比较速率）以外存访问次数为衡量时间性能的标准</strong></li></ul></li></ul><h3 id="7-2-静态查找表"><a href="#7-2-静态查找表" class="headerlink" title="7.2 静态查找表"></a>7.2 静态查找表</h3><ul><li><p>存储实现：一个数组 / 顺序表【表头指针、长度、规模】</p><blockquote><p>小特性：可以从后向前查找成功返回下标，失败返回-1</p></blockquote></li><li><p>运算实现：<strong>静态查找表因为其特性，仅关心查找运算</strong></p><ul><li>无序表的查找运算：顺序查找<strong>$O(n)$</strong></li></ul><blockquote><p>甚至为了减少比较次数，牺牲list[0]作为“哨兵”，每次查找前将target放入list[0]，这样一定能找到，并且如果停止在0上，则未找到；停止在其他序列上就找到了</p></blockquote><ul><li>有序表的查找运算：顺序查找、<strong>二分查找（$O(log\space n)$）</strong>、插值查找、分块查找；<ul><li>分块查找一定注意概念：先查找<strong>索引表（含有块内最大关键字、块起始地址）</strong>，再在块内使用顺序 / 二分查找（取决于是不是有序的）；</li></ul></li></ul><blockquote><p>提示：本部分对代码考察较少，一般考察查找次数分析、时间复杂度分析；</p></blockquote></li><li><p>例题观赏</p><ul><li><p>证明：分块查找的块大小为 <strong>$m=\sqrt{n}$</strong> 时（n为总元素个数），分块查找的平均时间性能最佳为<strong>$O(\sqrt{n})$</strong>；</p><script type="math/tex; mode=display">\begin{aligned}&假设表长为\space n,\space 被分为\space m\space 块,平均每块有\space \dfrac{n}{m}\space个元素;\\&再假定索引、块内均采用顺序查找方法;\\&则平均情况下查找次数=\dfrac{1}{m}\sum\limits_{i=1}^{m}{i}+\dfrac{1}{\cfrac{n}{m}}\sum\limits_{j=1}^{\cfrac{n}{m}}j=\dfrac{1}{2}(m+\dfrac{n}{m})+1\\&由基本不等式可知,\space当且仅当\space m=\sqrt{n}\space时取最小值\sqrt{n}+1,\space故时间复杂度O(\sqrt{n})\end{aligned}</script></li><li><p>对于一个长度为3的顺序表查找，目标是第一个元素的概率是<strong>$\dfrac{1}{2}$</strong>，目标是第二个元素的概率是<strong>$\dfrac{1}{3}$</strong>，目标是第三个元素的概率是<strong>$\dfrac{1}{6}$</strong>，问顺序查找（从前往后）的平均查找长度；若该表同时满足有序性，问二分查找的平均查找长度；</p><script type="math/tex; mode=display">\begin{aligned}&\overline{sLen}_{seq}=1\times\dfrac{1}{2}+2\times\dfrac{1}{3}+3\times\dfrac{1}{6}=\dfrac{5}{3}\\&\overline{sLen}_{bin}=1\times\dfrac{1}{3}+2\times(\dfrac{1}{2}+\dfrac{1}{6})=\dfrac{5}{3}\\\end{aligned}</script></li></ul></li></ul><h3 id="7-3-动态查找表"><a href="#7-3-动态查找表" class="headerlink" title="7.3 动态查找表"></a>7.3 动态查找表</h3><blockquote><p>考虑所有的线性结构均不合适：顺序存储=&gt;插入删除不利；链表=&gt;查找只能顺序；</p><p>解决方案：</p><ul><li>查找树：处理动态查找表的树型结构；</li><li>散列表：专用于集合查找的数据结构；</li></ul></blockquote><h4 id="7-3-1-二叉查找树"><a href="#7-3-1-二叉查找树" class="headerlink" title="7.3.1 二叉查找树"></a>7.3.1 二叉查找树</h4><ul><li><p>定义：或者是一棵空树，或者是一棵同时满足以下条件的<strong>二叉树</strong>：</p><ul><li><p>左子树不空时，<strong>左子树上所有元素</strong>的键值小于根结点的键值（右子树同理）；</p></li><li><p>它的左右子树也都是二叉查找树；</p></li></ul><blockquote><p>引申结论：<strong>一棵二叉查找树的中序序列是按键值递增排序的序列（所以二叉查找树又称<u>二叉排序树</u>）</strong></p></blockquote><p><strong>⚠极易错误的点：是左右子树上所有的点都满足键值大小关系！！！不仅仅是左右结点满足这个关系。</strong></p><p><strong>例如：“设计程序检查二叉树是否为一个二叉查找树”，应该利用中序序列的特性，初始化一个最小数据值，中序遍历同时判断；而不应该只是简单地判断当前结点、左右子结点的值关系</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBSTree</span><span class="params">(node&lt;T&gt;* cur)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> T minData;</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isBSTree</span>(cur-&gt;left) || cur-&gt;data &lt; minData)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    minData = cur-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isBSTree</span>(cur-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>存储实现：二叉树的标准存储法【根结点】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binSearchTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        pair&lt;KEY, VAL&gt; data;</span><br><span class="line">        node* left;</span><br><span class="line">        node* right;</span><br><span class="line">        <span class="built_in">node</span>(): <span class="built_in">left</span>(<span class="number">0</span>), <span class="built_in">right</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">node</span>(pair&lt;KEY, VAL&gt; p, node* L=<span class="number">0</span>, node* R=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">data</span>(p), <span class="built_in">left</span>(L), <span class="built_in">right</span>(R) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node* root;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">binSearchTree</span>();</span><br><span class="line">    ~<span class="built_in">binSearchTree</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;KEY, VAL&gt; dt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> KEY&amp; k)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;KEY, VAL&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> KEY&amp; k)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>运算实现</p><p>创建删除运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">binSearchTree</span>() &#123; root = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">clear</span>(node*&amp; target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">clear</span>(target-&gt;left);</span><br><span class="line">    <span class="built_in">clear</span>(target-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> target; target = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">binSearchTree&lt;KEY, VAL&gt;::~<span class="built_in">binSearchTree</span>() &#123; <span class="built_in">clear</span>(root); &#125;</span><br></pre></td></tr></table></figure><p>查找运算 <strong>$O(log\space n)-O(log\space n)-O(n)$</strong>，推导平均情况：（有n种形态：左0右n-1、左2右n-2、……、左n-1右0，最后包括根结点）</p><script type="math/tex; mode=display">\begin{aligned}P(n)&=\dfrac{1}{n^2}\sum\limits_{i=0}^{n-1}[1+(P(i)+1)\times i+(P(n-i-1)+1)\times(n-i-1)]\\&\le2(1+\dfrac{1}{n})\space ln\space n\space\sim1.38\space log\space n\\\end{aligned}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归既省时又省空间，用递归系统栈的开销就大啦</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">pair&lt;KEY, VAL&gt;* binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">find</span>(<span class="type">const</span> KEY&amp; k) <span class="type">const</span> &#123;</span><br><span class="line">    node* cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;data.key != k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data.key &gt; k) cur = cur-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cur ? &amp;(cur-&gt;data) : <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入运算 <strong>$O(log\space n)，实际相当于查找时间复杂度$</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt, node*&amp; target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) target = <span class="keyword">new</span> <span class="built_in">node</span>(dt);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;data.key &lt; dt.key)</span><br><span class="line">        <span class="built_in">insert</span>(dt, target-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;data.key &gt; dt.key)</span><br><span class="line">        <span class="built_in">insert</span>(dt, target-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt) &#123;</span><br><span class="line">    <span class="built_in">insert</span>(dt, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 非递归法1，这里二阶指针不能用引用代替！否则会把root值改变！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt) &#123;</span><br><span class="line">    node** cur = &amp;root;</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;data.key != dt.key) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*cur)-&gt;data.key &gt; dt.key) cur = &amp;((*cur)-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> cur = &amp;((*cur)-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(*cur)) *cur = <span class="keyword">new</span> <span class="built_in">node</span>(dt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归法2，除了用自身二阶指针保存外，更易懂的还可以用前后指针保存</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123; root = <span class="keyword">new</span> <span class="built_in">node</span>(dt); <span class="keyword">return</span>; &#125;</span><br><span class="line">    node* pre, cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;data.key != dt.key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data.key &gt; dt.key) cur = cur-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;left == cur) pre-&gt;left = <span class="keyword">new</span> <span class="built_in">node</span>(dt);</span><br><span class="line">        <span class="keyword">else</span> pre-&gt;right = <span class="keyword">new</span> <span class="built_in">node</span>(dt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除运算 <strong>$O(log\space n)，实际相当于查找时间复杂度$</strong>，注意需要在右子树中找最小 / 左子树中找最大结点作为替身再删除；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅展示递归法，非递归法可由插入运算同理得</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">remove</span>(<span class="type">const</span> KEY&amp; k, node*&amp; target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (target-&gt;data.key &lt; k) <span class="built_in">remove</span>(k, target-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;data.key &gt; k) <span class="built_in">remove</span>(k, target-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;left &amp;&amp; target-&gt;right) &#123;</span><br><span class="line">        node* sub = target-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (sub-&gt;left) sub = sub-&gt;left;</span><br><span class="line">        target-&gt;data = sub-&gt;data;</span><br><span class="line">        <span class="built_in">remove</span>(sub-&gt;data.key, target-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="comment">// 思考为何度为1和度为0的结点情况可以合并</span></span><br><span class="line">        node* tmp = target;</span><br><span class="line">        target = (target-&gt;left ? target-&gt;left : target-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">remove</span>(<span class="type">const</span> KEY&amp; k) &#123;</span><br><span class="line">    <span class="built_in">remove</span>(k, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-3-2-AVL树：平衡的二叉查找树"><a href="#7-3-2-AVL树：平衡的二叉查找树" class="headerlink" title="7.3.2 AVL树：平衡的二叉查找树"></a>7.3.2 AVL树：平衡的二叉查找树</h4><ul><li>平衡条件左右子树高度差不大于 1（也即<strong>平衡因子不大于1</strong>）<ul><li>对二叉查找树应用该平衡条件的原因：限制二叉查找树高度在对数级，避免退化为链表；</li><li>AVL 树的平衡性大于普通二叉查找树，小于完全二叉树；</li></ul></li></ul><blockquote><p>了解即可：AVL树对数级高度的理论依据</p><script type="math/tex; mode=display">\begin{aligned}&设\space S_H\space是高度为\space H\space的最小的AVL树规模，则:\\&S_H=\begin{equation}\left\{\begin{aligned}&\qquad\quad1,&H=1\\&\qquad\quad2,&H=2\\&S_{H-1}+S_{H-2}+1,\space&H\ge3\\\end{aligned}\right.\end{equation}\end{aligned}\Longrightarrow S_H\approx\dfrac{\sqrt{5}}{5}(\dfrac{1+\sqrt{5}}{2})^{H+2}-1\le N</script><script type="math/tex; mode=display">故:\space H\le1.44\space log_2(N+1)-0.328</script></blockquote><ul><li><p>AVL树存储实现：二叉树的标准存储法 + 结点类高度字段【根结点】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        pair&lt;KEY, VAL&gt; data;</span><br><span class="line">        node* left;</span><br><span class="line">        node* right;</span><br><span class="line">        <span class="type">int</span> height;</span><br><span class="line">        <span class="built_in">node</span>(): <span class="built_in">left</span>(<span class="number">0</span>), <span class="built_in">right</span>(<span class="number">0</span>), <span class="built_in">height</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">node</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt, node* L=<span class="number">0</span>, node* R=<span class="number">0</span>, <span class="type">int</span> h=<span class="number">1</span>)</span><br><span class="line">            : <span class="built_in">data</span>(dt), <span class="built_in">left</span>(L), <span class="built_in">right</span>(R), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node* root;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(node* target)</span> </span>&#123; <span class="keyword">return</span> (target ? target-&gt;height : <span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RR</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LL</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RL</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LR</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AVLTree</span>();</span><br><span class="line">    ~<span class="built_in">AVLTree</span>();</span><br><span class="line">    <span class="function">pair&lt;KEY, VAL&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> KEY&amp; k)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> KEY&amp; k)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>AVL树失衡分析</p><blockquote><p>AVL树与二叉查找树不同的是，在插入、删除后需要修正树的平衡性，下面讨论这两种操作如何修正平衡性；</p></blockquote><p><img src="AVL.jpg"></p></li><li><p>AVL树运算实现</p><p>创建、删除操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">AVLTree&lt;KEY, VAL&gt;::<span class="built_in">AVLTree</span>() &#123; root = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">clear</span>(node*&amp; target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">clear</span>(target-&gt;left);</span><br><span class="line">    <span class="built_in">clear</span>(target-&gt;left);</span><br><span class="line">    <span class="keyword">delete</span> target; target = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">AVLTree&lt;KEY, VAL&gt;::~<span class="built_in">AVLTree</span>() &#123; <span class="built_in">clear</span>(root); &#125;</span><br></pre></td></tr></table></figure><p>查找操作 <strong>$O(log\space n)$</strong>，写法同二叉查找树，但最坏时间性能好于二叉查找树；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">pair&lt;KEY, VAL&gt;* AVLTree&lt;KEY, VAL&gt;::<span class="built_in">find</span>(<span class="type">const</span> KEY&amp; k) <span class="type">const</span> &#123;</span><br><span class="line">    pair&lt;KEY, VAL&gt;* cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;data != k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data.key &gt; k) cur = cur-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cur ? &amp;(cur-&gt;data) : <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[PRIVATE] 调整操作 <strong>$O(1)$</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">LL</span>(node*&amp; target) &#123;</span><br><span class="line">    node* post = target-&gt;left;</span><br><span class="line">    target-&gt;left = post-&gt;right;</span><br><span class="line">    post-&gt;right = target;</span><br><span class="line">    <span class="type">int</span> hLeft = <span class="built_in">height</span>(target-&gt;left), hRight = <span class="built_in">height</span>(target-&gt;right);</span><br><span class="line">    target-&gt;height = (hLeft &gt; hRight ? hLeft : hRight) + <span class="number">1</span>;</span><br><span class="line">    hLeft = <span class="built_in">height</span>(post-&gt;left);</span><br><span class="line">    post-&gt;height = (hLeft &gt; target-&gt;height ? hLeft : target-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    target = post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">RR</span>(node*&amp; target) &#123;</span><br><span class="line">    node* post = target-&gt;right;</span><br><span class="line">    target-&gt;right = post-&gt;left;</span><br><span class="line">    post-&gt;left = target;</span><br><span class="line">    <span class="type">int</span> hLeft = <span class="built_in">height</span>(target-&gt;left), hRight = <span class="built_in">height</span>(target-&gt;right);</span><br><span class="line">    target-&gt;height = (hLeft &gt; hRight ? hLeft : hRight) + <span class="number">1</span>;</span><br><span class="line">    hRight = <span class="built_in">height</span>(post-&gt;right);</span><br><span class="line">    post-&gt;height = (target-&gt;height &gt; hRight ? target-&gt;height : hRight) + <span class="number">1</span>;</span><br><span class="line">    target = post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">LR</span>(node*&amp; target) &#123;</span><br><span class="line">    <span class="built_in">RR</span>(target-&gt;left); <span class="built_in">LL</span>(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">RL</span>(node*&amp; target) &#123;</span><br><span class="line">    <span class="built_in">LL</span>(target-&gt;right); <span class="built_in">RR</span>(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作 <strong>$O(log\space n)$</strong>，插入前部分与二叉查找树相同，另需回溯维持平衡；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归法，需要使用到前章节的栈类seqStack；显然可以知道递归方法怎么写，略</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123; root = <span class="keyword">new</span> <span class="built_in">node</span>(dt); <span class="keyword">return</span>; &#125;</span><br><span class="line">    seqStack&lt;node**&gt; hist; node** tmp = <span class="literal">NULL</span>;</span><br><span class="line">    hist.<span class="built_in">push</span>(&amp;root);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        tmp = hist.<span class="built_in">pop</span>(); hist.<span class="built_in">push</span>(tmp); <span class="keyword">if</span> (!(*tmp)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((*tmp)-&gt;data.key &gt; dt.key) hist.<span class="built_in">push</span>(&amp;((*tmp)-&gt;left));</span><br><span class="line">        <span class="keyword">else</span> hist.<span class="built_in">push</span>(&amp;((*tmp)-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = hist.<span class="built_in">pop</span>(); *tmp = <span class="keyword">new</span> <span class="built_in">node</span>(dt);</span><br><span class="line">    <span class="keyword">while</span> (!hist.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        node** cur = hist.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> hLeft = <span class="built_in">height</span>((*cur)-&gt;left),</span><br><span class="line">            hRight = <span class="built_in">height</span>((*cur)-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (hLeft - hRight &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>((*cur)-&gt;left-&gt;left) &gt; <span class="built_in">height</span>(*cur)-&gt;left-&gt;right)</span><br><span class="line">                &#123; <span class="built_in">LL</span>(*cur); <span class="keyword">return</span>; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="built_in">LR</span>(*cur); <span class="keyword">return</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hRight - hLeft &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>((*cur)-&gt;right-&gt;right) &gt; <span class="built_in">height</span>((*cur)-&gt;right-&gt;left))</span><br><span class="line">                &#123; <span class="built_in">RR</span>(*cur); <span class="keyword">return</span>; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="built_in">RL</span>(*cur); <span class="keyword">return</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> (*cur)-&gt;height = (hLeft &gt; hRight ? hLeft : hRight) + <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作 <strong>$O(log\space n)$</strong>，与二叉查找树的删除前部分相同，后部分需要调整平衡；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归法，需要使用到前章节的栈类seqStack；显然可以知道递归方法怎么写，略</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">remove</span>(<span class="type">const</span> KEY&amp; k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    seqStack&lt;node**&gt; hist; KEY target = k;</span><br><span class="line">    node** tmp = &amp;root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        hist.<span class="built_in">push</span>(tmp); <span class="keyword">if</span> (!(*tmp)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> ((*tmp)-&gt;data.key &lt; target) tmp = &amp;((*tmp)-&gt;right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((*tmp)-&gt;data.key &gt; target) tmp = &amp;((*tmp)-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> &#123;    <span class="comment">// 找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span> ((*tmp)-&gt;left &amp;&amp; (*tmp)-&gt;right) &#123; <span class="comment">// 要删除结点的度为2</span></span><br><span class="line">                node* sub = (*tmp)-&gt;right;</span><br><span class="line">                <span class="keyword">while</span> (sub) sub = sub-&gt;left;</span><br><span class="line">                (*tmp)-&gt;data = sub-&gt;data; target = sub-&gt;data.key;</span><br><span class="line">                tmp = &amp;((*tmp)-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;    <span class="comment">// 要删除结点的度小于2</span></span><br><span class="line">                node* rn = *tmp;</span><br><span class="line">                *tmp = ((*tmp)-&gt;left ? (*tmp)-&gt;left : (*tmp)-&gt;right);</span><br><span class="line">                <span class="keyword">delete</span> rn; hist.<span class="built_in">pop</span>(); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!hist.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        tmp = hist.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> newLH = <span class="built_in">height</span>((*tmp)-&gt;left), newRH = <span class="built_in">height</span>((*tmp)-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (newLH - newRH &gt; <span class="number">1</span>) &#123;    <span class="comment">// 高度改变且失衡</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>((*tmp)-&gt;left-&gt;left) &gt; <span class="built_in">height</span>((*tmp)-&gt;left-&gt;right)) <span class="built_in">LR</span>(*tmp);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">LL</span>(*tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newRH - newLH &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>((*tmp)-&gt;right-&gt;right) &lt; <span class="built_in">height</span>((*tmp)-&gt;right-&gt;left)) <span class="built_in">RL</span>(*tmp);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">RR</span>(*tmp);</span><br><span class="line">        &#125;    <span class="comment">// 高度未改变且未失衡</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newRH - newLH == <span class="number">1</span> || newLH - newRH == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 剩下情况是高度改变但未失衡，或者失衡调整后：需要更新高度</span></span><br><span class="line">        (*tmp)-&gt;height = (<span class="built_in">height</span>((*tmp)-&gt;left) &gt; <span class="built_in">height</span>((*tmp)-&gt;right)</span><br><span class="line">                          ? <span class="built_in">height</span>((*tmp)-&gt;left) : <span class="built_in">height</span>((*tmp)-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-3-3-散列表"><a href="#7-3-3-散列表" class="headerlink" title="7.3.3 散列表"></a>7.3.3 散列表</h4><blockquote><p>思路：将关键字对应的数据元素存储在指定位置，这个位置由关键字值运算（hash函数）映射出来。这样意味着一般情况下具有线性的查找时间；</p></blockquote><ul><li><p>散列表的存储实现：闭散列表—数组【表头指针、规模】；开散列表—链表数组【指针数组头、规模】；</p><blockquote><p>主要问题：散列函数设计尽量避免碰撞、碰撞问题解决；</p></blockquote></li><li><p>散列函数设计</p><ul><li><p>直接定址法：线性映射，适用于数据本身分布均匀，且在同一数量级中；</p><p><strong>$H(x)=ax+b$</strong></p></li><li><p>除留取余法：取余函数；</p><p><strong>$H(x)=a\space mod\space M.\space经验表明，M为素数时，分布较为均匀$</strong></p></li><li><p>数字分析法：根据数字实际特性确定哪些位作为散列函数的参数来映射；</p></li><li><p>平方取中法：适用于关键字数据各个位数上分布均匀，且关键字值域大于数组规模，可以用关键字的平方，再取中间几位（和每一位数都有关系）；</p></li><li><p>折叠法：适用于关键字长 &gt;&gt; 散列表规模的情况，按每N位折叠再相加生成；</p></li></ul></li><li><p>碰撞解决方案</p><ul><li><p>闭散列表（迟删除={空，活动，删除}）：</p><p>&#8618; 线性探测法（向后+1移动至空位置/已删除位置）；</p><p>&#8618; 二次探测法（探测 <strong>$H+i^2$</strong> 单位，数学上可以处理为前一个索引基础上 + (2i - 1)，能解决线性探测的初始聚集问题）；</p><p>&#8618; 再散列法使用两个散列函数H1、H2，H1计算应该处于的起始位置，H2计算碰撞后下一个探测的位置的步长：H1(x)、(H1(x)+H2(x)) mod M、……、(H1(x)+k H2(x)) mod M；</p></li><li><p>开散列表：拉链法，天然不存在碰撞问题；</p></li></ul></li><li><p>闭散列表可能存在的问题和优化建议</p><ul><li>如果选择除留取余作为hash函数，需要尽量保证数组长度（哪怕扩容）是素数；</li><li>负载因子（<strong>非空单元比例</strong>）过高可能会导致查找等操作时间性能下降，需要及时检查、清理迟删除的元素、进行扩容（涉及重散列）；</li></ul></li><li><p>实现示例（看看就好）：以除留取余作为hash函数、闭散列表针对上面2个问题已优化；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hash method: dividing the residual method.</span></span><br><span class="line"><span class="comment">// The solution to Hash Collision: linear detecting.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">closeHashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hashNode</span> &#123;</span><br><span class="line">        pair&lt;KEY, VAL&gt; data;</span><br><span class="line">        <span class="comment">// 0: empty, 1: active; 2: deleted</span></span><br><span class="line">        <span class="type">int</span> state;</span><br><span class="line">        <span class="built_in">hashNode</span>(): <span class="built_in">state</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">hashNode</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt, <span class="type">int</span> s=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">data</span>(dt), <span class="built_in">state</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> empty;</span><br><span class="line">    <span class="type">int</span> deleted;</span><br><span class="line">    hashNode* array;</span><br><span class="line">    <span class="built_in">int</span> (*key2int)(<span class="type">const</span> KEY&amp; key);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">defaultK2int</span><span class="params">(<span class="type">const</span> KEY&amp; k)</span> </span>&#123; <span class="keyword">return</span> k; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">minPrime</span><span class="params">(<span class="type">int</span> min)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the rate of the deleted nodes.</span></span><br><span class="line">    <span class="comment">// Return true if over half of the nodes is in deleted state.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkDeleted</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (deleted &gt; size / <span class="number">2</span>); &#125;</span><br><span class="line">    <span class="comment">// Check the rate of the active nodes.</span></span><br><span class="line">    <span class="comment">// Return true if the load factor is greater than 0.5.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkActive</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (empty + deleted &lt; size / <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash the hash table to improve its performance.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reHash</span><span class="params">(<span class="type">bool</span> expand=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">closeHashTable</span>(<span class="type">int</span> capacity=<span class="number">13</span>, <span class="built_in">int</span> (*k2int)(<span class="type">const</span> KEY&amp;)=defaultK2int);</span><br><span class="line">    ~<span class="built_in">closeHashTable</span>();</span><br><span class="line">    <span class="function">pair&lt;KEY, VAL&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> KEY&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; s)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> KEY&amp; key)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">int</span> closeHashTable&lt;KEY, VAL&gt;::<span class="built_in">minPrime</span>(<span class="type">int</span> min) &#123;</span><br><span class="line">    <span class="keyword">if</span> (min % <span class="number">2</span> == <span class="number">0</span>) ++min;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = min;; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">3</span>; j * j &lt;= min; j += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123; flag = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">closeHashTable&lt;KEY, VAL&gt;::<span class="built_in">closeHashTable</span>(<span class="type">int</span> capacity, <span class="built_in">int</span> (*k2int)(<span class="type">const</span> KEY&amp;)) &#123;</span><br><span class="line">    size = <span class="built_in">minPrime</span>(capacity);</span><br><span class="line">    array = <span class="keyword">new</span> hashNode[size];</span><br><span class="line">    key2int = k2int;</span><br><span class="line">    empty = size; deleted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">closeHashTable&lt;KEY, VAL&gt;::~<span class="built_in">closeHashTable</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (array) <span class="keyword">delete</span>[] array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">pair&lt;KEY, VAL&gt;* closeHashTable&lt;KEY, VAL&gt;::<span class="built_in">find</span>(<span class="type">const</span> KEY&amp; key) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// Why we need initPos: when the array is fully occupied, we need</span></span><br><span class="line">    <span class="comment">// to know if we have traversed the array.</span></span><br><span class="line">    <span class="type">int</span> initPos, pos;</span><br><span class="line">    initPos = pos = <span class="built_in">key2int</span>(key) % size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[pos].state == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[pos].state == <span class="number">1</span> &amp;&amp; array[pos].data.key == key)</span><br><span class="line">            <span class="keyword">return</span> &amp;(array[pos].data);</span><br><span class="line">        <span class="comment">// Attention: state == -1 means delay delete,</span></span><br><span class="line">        <span class="comment">// which means keeping searching.</span></span><br><span class="line">        pos = (pos + <span class="number">1</span>) % size;</span><br><span class="line">    &#125; <span class="keyword">while</span> (initPos != pos);</span><br><span class="line">    <span class="comment">// The array is full and we can&#x27;t find the data with &#x27;key&#x27;.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> closeHashTable&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkActive</span>()) <span class="built_in">reHash</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> initPos, pos;</span><br><span class="line">    initPos = pos = <span class="built_in">key2int</span>(s.key) % size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Attention: we can overwrite the deleted entry(state=2).</span></span><br><span class="line">        <span class="keyword">if</span> (array[pos].state != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// (array[pos].state ? --deleted : --empty);</span></span><br><span class="line">            <span class="keyword">if</span> (array[pos].state) --deleted;</span><br><span class="line">            <span class="keyword">else</span> --empty;</span><br><span class="line">            array[pos].data = s;</span><br><span class="line">            array[pos].state = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = (pos + <span class="number">1</span>) % size;</span><br><span class="line">    &#125; <span class="keyword">while</span> (initPos != pos);</span><br><span class="line">    <span class="comment">// Warning: the array is full.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> closeHashTable&lt;KEY, VAL&gt;::<span class="built_in">remove</span>(<span class="type">const</span> KEY&amp; key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkDeleted</span>()) <span class="built_in">reHash</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> initPos, pos;</span><br><span class="line">    initPos = pos = <span class="built_in">key2int</span>(key) % size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Save time.</span></span><br><span class="line">        <span class="keyword">if</span> (array[pos].state == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[pos].state == <span class="number">1</span> &amp;&amp; array[pos].data.key == key) &#123;</span><br><span class="line">            array[pos].state = <span class="number">2</span>; ++deleted; <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = (pos + <span class="number">1</span>) % size;</span><br><span class="line">    &#125; <span class="keyword">while</span> (initPos != pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> closeHashTable&lt;KEY, VAL&gt;::<span class="built_in">reHash</span>(<span class="type">bool</span> expand) &#123;</span><br><span class="line">    hashNode* tmp = array;</span><br><span class="line">    <span class="type">int</span> oldSize = size;</span><br><span class="line">    size = (expand ? <span class="built_in">minPrime</span>(<span class="number">2</span>*size) : size);</span><br><span class="line">    array = <span class="keyword">new</span> hashNode[size];</span><br><span class="line">    empty = size; deleted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; oldSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp[i].state == <span class="number">1</span>) <span class="built_in">insert</span>(tmp[i].data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">openHashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hashNode</span> &#123;</span><br><span class="line">        pair&lt;KEY, VAL&gt; data;</span><br><span class="line">        hashNode* next;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">hashNode</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; s, hashNode* n=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">data</span>(s), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    hashNode** hashTable;</span><br><span class="line">    <span class="built_in">int</span> (*key2int)(<span class="type">const</span> KEY&amp; key);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">defaultK2int</span><span class="params">(<span class="type">const</span> KEY&amp; key)</span> </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">openHashTable</span>(<span class="type">int</span> initSize=<span class="number">101</span>, <span class="built_in">int</span> (*k2int)(<span class="type">const</span> KEY&amp; k)=defaultK2int);</span><br><span class="line">    ~<span class="built_in">openHashTable</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> KEY&amp; key)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;KEY, VAL&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> KEY&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">openHashTable&lt;KEY, VAL&gt;::<span class="built_in">openHashTable</span>(<span class="type">int</span> initSize, <span class="built_in">int</span> (*k2int)(<span class="type">const</span> KEY&amp; k)) &#123;</span><br><span class="line">    size = initSize;</span><br><span class="line">    hashTable = <span class="keyword">new</span> hashNode*[size] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    key2int = k2int;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">openHashTable&lt;KEY, VAL&gt;::~<span class="built_in">openHashTable</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (hashTable[i]) &#123;</span><br><span class="line">            hashNode* tmp = hashTable[i];</span><br><span class="line">            hashTable[i] = hashTable[i]-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] hashTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> openHashTable&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(x.key)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">key2int</span>(x.key) % size;</span><br><span class="line">    hashTable[idx] = <span class="keyword">new</span> <span class="built_in">hashNode</span>(x, hashTable[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> openHashTable&lt;KEY, VAL&gt;::<span class="built_in">remove</span>(<span class="type">const</span> KEY&amp; key) &#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">key2int</span>(key) % size;</span><br><span class="line">    hashNode* cur = hashTable[idx];</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;data.key != key)</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (!(cur-&gt;next)) <span class="keyword">return</span>;</span><br><span class="line">    hashNode* tmp = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">pair&lt;KEY, VAL&gt;* openHashTable&lt;KEY, VAL&gt;::<span class="built_in">find</span>(<span class="type">const</span> KEY&amp; key) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">key2int</span>(key) % size;</span><br><span class="line">    hashNode* cur = hashTable[idx];</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;data.key != key)</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> &amp;(cur-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Chapter-8-排序"><a href="#Chapter-8-排序" class="headerlink" title="Chapter 8 排序"></a>Chapter 8 排序</h2><h3 id="8-1-零碎概念集合"><a href="#8-1-零碎概念集合" class="headerlink" title="8.1 零碎概念集合"></a>8.1 零碎概念集合</h3><ul><li>内排序和外排序：数据规模、数据存放位置、算法优化要求不一样；</li><li>排序算法的稳定性：集合中相同关键字值的元素在排序后，这些元素的相对次序不变，则称这种算法是稳定的；反之是不稳定的；（从现在开始，除非标明不稳定，其余都是稳定的）</li><li>常见应用：集合排序（便于查找）、查找序列中的重复元素；</li></ul><blockquote><p>注：本章排序算法以递增序列为目标；</p></blockquote><h3 id="8-2-插入排序"><a href="#8-2-插入排序" class="headerlink" title="8.2 插入排序"></a>8.2 插入排序</h3><h4 id="8-2-1-直接插入排序"><a href="#8-2-1-直接插入排序" class="headerlink" title="8.2.1 直接插入排序"></a>8.2.1 直接插入排序</h4><blockquote><p>每个外围循环将 a[i] 插入 a[0]~a[i-1] 的序列中，<strong>从后向前比较交换</strong></p><p><strong>如果数据是一个一个输入的（不同时间），那么直接插入排序是一个极好的选择</strong></p></blockquote><p>时间复杂度分析：</p><ul><li>最坏：a[j] 比较 j 次、a[j] 交换 j + 2 次，故<strong>$O(n^2)$</strong></li><li>最好<strong>$O(n)$</strong>、平均<strong>$O(n^2)$</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简化逻辑结构、方便应用，代码中将直接用键KEY来替换pair键值对的排序，下同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simpleInsertSort</span><span class="params">(KEY seq[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        KEY pre = seq[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[j] &gt; pre) seq[j + <span class="number">1</span>] = seq[j];</span><br><span class="line">            <span class="keyword">else</span> &#123; seq[j + <span class="number">1</span>] = pre; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-2-二分插入排序"><a href="#8-2-2-二分插入排序" class="headerlink" title="8.2.2 二分插入排序"></a>8.2.2 二分插入排序</h4><blockquote><p>将直接插入的比较改为二分查找，并没有改变时间复杂度；</p></blockquote><h4 id="8-2-3-希尔排序（不稳定）"><a href="#8-2-3-希尔排序（不稳定）" class="headerlink" title="8.2.3 希尔排序（不稳定）"></a>8.2.3 希尔排序（不稳定）</h4><blockquote><p>选定增量序列 {h1=1, h2, …, ht}，对待排序列进行 ht-排序、……、h2-排序、h1-排序；</p><ul><li>每个 hk-排序使用直接插入排序；</li><li>shell 他本人建议增量序列取定：N/2 -&gt; N/4 -&gt; …… -&gt; 1；</li><li>理论依据：<strong>hk-有序数组经过 h(k-1)-排序后仍然有序</strong>；</li></ul></blockquote><p>时间复杂度分析：</p><ul><li>对于增量序列 <strong>$\{\dfrac{N}{2},\space\dfrac{N}{4},\space…,\space1\}$</strong>（或者间距序列为 <strong>$H= \{ 2^k-1\mid k=1,2,\ldots,\lfloor\log_2 n\rfloor \}$</strong>(从大到小）)，时间复杂度为<strong>$O(n^{\tfrac{3}{2}})$</strong> ；</li><li>对于间距序列<strong>$H= \{ k=2^p\cdot 3^q\mid p,q\in \mathbb N,k\le n \}$</strong>（从大到小），时间复杂度<strong>$O(n\space log^2 n)$</strong></li><li>有兴趣参阅证明过程，请移步：<a href="https://oi-wiki.org/basic/shell-sort/#时间复杂度">希尔排序 - OI Wiki (oi-wiki.org)</a></li><li>总体的移动次数（对所有增量序列）：<strong>$n^{1.25}\sim 1.6n^{1.25}\Longrightarrow O(n^{1.25})$</strong>；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(KEY seq[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> step = size / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 对每个子序列进行直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = step; i &lt; size; ++i) &#123;</span><br><span class="line">            pre = seq[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seq[j] &gt; pre) seq[j + <span class="number">1</span>] = seq[j];</span><br><span class="line">                <span class="keyword">else</span> &#123; seq[j + <span class="number">1</span>] = pre; <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-选择排序"><a href="#8-3-选择排序" class="headerlink" title="8.3 选择排序"></a>8.3 选择排序</h3><h4 id="8-3-1-直接选择排序（特定条件下不稳定）"><a href="#8-3-1-直接选择排序（特定条件下不稳定）" class="headerlink" title="8.3.1 直接选择排序（特定条件下不稳定）"></a>8.3.1 直接选择排序（特定条件下不稳定）</h4><blockquote><p>从未排序部分<strong>顺序查找</strong>出一个最大/最小元素，与未排序部分的末尾交换，以增长排序部分；</p><p>不稳定的、平方时间复杂度的简单算法，导致它仅常用于一些小规模的排序中；</p></blockquote><p>时间复杂度分析：最好、最坏、平均：<strong>$O(n^2)$</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simpleSelectSort</span><span class="params">(KEY seq[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> minIdx = i; KEY minVal = seq[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[j] &lt; minVal) &#123;</span><br><span class="line">                minIdx = j; minVal = seq[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        seq[minIdx] = seq[i];</span><br><span class="line">        seq[i] = minVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-2-堆排序（不稳定）"><a href="#8-3-2-堆排序（不稳定）" class="headerlink" title="8.3.2 堆排序（不稳定）"></a>8.3.2 堆排序（不稳定）</h4><blockquote><p>利用之前优先级队列中，二叉堆的特性进行排序；</p><p>出队后，从数组末尾向前摆放，所以要递增排序就要构建最大化堆（反之同理）；</p><p>通常情况0号位存有数据，所以 i 结点的左右儿子分别为 2i + 1、2i + 2，父结点 floor((i-1)/2)；</p></blockquote><p>时间复杂度分析：出队N次，<strong>$O(n\space log\space n)$</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">percolateDown</span><span class="params">(KEY seq[], <span class="type">int</span> size, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> next = idx * <span class="number">2</span> + <span class="number">1</span>; KEY tmp = seq[idx];</span><br><span class="line">    <span class="keyword">while</span> (next &lt; size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next + <span class="number">1</span> &lt; size &amp;&amp; seq[next] &lt; seq[next + <span class="number">1</span>]) ++next;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; seq[next]) seq[idx] = tmp;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        idx = next; next = <span class="number">2</span> * idx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    seq[idx] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(KEY seq[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="built_in">percolateDown</span>(seq, size, i);</span><br><span class="line">    <span class="comment">// O(nlogn)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        KEY tmp = seq[<span class="number">0</span>]; seq[<span class="number">0</span>] = seq[i]; set[i] = tmp;</span><br><span class="line">        <span class="built_in">percolateDown</span>(seq, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-交换排序"><a href="#8-4-交换排序" class="headerlink" title="8.4 交换排序"></a>8.4 交换排序</h3><h4 id="8-4-1-冒泡排序"><a href="#8-4-1-冒泡排序" class="headerlink" title="8.4.1 冒泡排序"></a>8.4.1 冒泡排序</h4><blockquote><p>第 i 次循环（从前向后）安排好倒数第 i 个位置；</p><p>如果一趟起泡没有发生任何交换，则序列一定有序，可以中止；</p></blockquote><p>时间复杂度分析：最好 <strong>$O(n)$</strong>，平均、最坏均为 <strong>$O(n^2)$</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(KEY seq[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; size; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[j + <span class="number">1</span>] &lt; seq[j]) &#123;</span><br><span class="line">                KEY tmp = seq[j]; seq[j] = seq[j + <span class="number">1</span>];</span><br><span class="line">                seq[j + <span class="number">1</span>] = tmp; flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-2-快速排序（不稳定）"><a href="#8-4-2-快速排序（不稳定）" class="headerlink" title="8.4.2 快速排序（不稳定）"></a>8.4.2 快速排序（不稳定）</h4><blockquote><p>选标准元素 -&gt; 划分 -&gt; 递归（或不用递归，用栈保存划分的起始、中止序号）</p></blockquote><p>时间复杂度分析：</p><ul><li>最好：<strong>$T(N)=2T(\dfrac{N}{2})+cN\Longrightarrow T(N)=O(N\space log\space N)$</strong>；</li><li>最坏：<strong>$T(N)=T(N-1)+cN\Longrightarrow T(N)=O(N^2)$</strong>；</li><li>平均：<strong>$T(N)=2\dfrac{1}{N}\sum\limits_{i=0}^{N-1}{T(i)}+cN\Longrightarrow T(N)=O(N\space log\space N)$</strong>；</li></ul><p><strong>空间复杂度分析</strong>：和第一章说的一样，系统栈算辅助空间</p><ul><li>最好：<strong>$O(log\space n)$</strong>；最坏：<strong>$O(n)$</strong>；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(KEY seq[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    KEY pivot = seq[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; pivot &lt; seq[right]) --right;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) seq[left] = seq[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; seq[left] &lt; pivot) ++left;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) seq[right] = seq[left];</span><br><span class="line">    &#125;</span><br><span class="line">    seq[left] = pivot; <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;    <span class="comment">// 可以添加一个包装函数，或者改成非递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(KEY seq[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="built_in">divide</span>(seq, left, right);</span><br><span class="line">    <span class="built_in">quickSort</span>(seq, left, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(seq, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-5-归并排序"><a href="#8-5-归并排序" class="headerlink" title="8.5 归并排序"></a>8.5 归并排序</h3><blockquote><p>以二路归并为例，先得到2份<strong>有序序列</strong>（应用递归），另启空间分别按大小加入</p><p>考虑到C++int自动向0取整（索引偏左），<strong>故merge在分化的时候应该多留一个给左边</strong>，防止死循环；</p></blockquote><p>时间复杂度分析：<strong>时间复杂度与数据分布无关！始终为 $O(n\space log\space n)$</strong>；</p><p>空间复杂度分析：<strong>$O(n)$</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(KEY seq[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    KEY* tmp = <span class="keyword">new</span> KEY[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> leftIdx = <span class="number">0</span>, rightIdx = mid, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (leftIdx &lt; mid &amp;&amp; rightIdx &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (seq[leftIdx] &gt; seq[rightIdx])</span><br><span class="line">            tmp[idx++] = seq[rightIdx++];</span><br><span class="line">        <span class="keyword">else</span> tmp[idx++] = seq[leftIdx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (leftIdx &lt; mid) tmp[idx++] = seq[leftIdx++];</span><br><span class="line">    <span class="keyword">while</span> (rightIdx &lt;= right) tmp[idx++] = seq[rightIdx++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i)</span><br><span class="line">        seq[i] = tmp[i];</span><br><span class="line">    <span class="keyword">delete</span>[] tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;    <span class="comment">// 可以添加一个包装函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(KEY seq[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(seq, left, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(seq, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="built_in">merge</span>(seq, left, right， mid + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-6-基数排序"><a href="#8-6-基数排序" class="headerlink" title="8.6 基数排序"></a>8.6 基数排序</h3><blockquote><p>从最低位到最高位，分别放进 base（基数）个口袋中，再按口袋位置”倒出“，重复至所有数的最高位（不足的补0），排序完成；</p></blockquote><p>时间复杂度分析：<strong>$O(maxLen\times n)$</strong>；</p><p>空间复杂度分析：<strong>$O(1)$</strong>；</p><p>MSD &amp; LSD：从最高位还是最低位开始；</p><h3 id="8-EX-常用排序总结"><a href="#8-EX-常用排序总结" class="headerlink" title="8-EX 常用排序总结"></a>8-EX 常用排序总结</h3><blockquote><p>更多排序算法在算法设计/高级数据结构中进一步阐明；</p></blockquote><p><img src="sorts.png"></p><blockquote><p>⚠易错警示：算法的最好、最坏情况，与数据分布有关（除了堆【出队始终慢于入队】、归并、基数排序），但不与其完全对应（即“不一定最好情况是有序的时候”）！</p><p>当输入序列有序时：</p><p>直接插入排序 $O(n)$ 最好、常数个增量元素序列的希尔排序 $O(n)$ 最好（因为 k-排序 对应的直接插入排序线性时间复杂度）、快速排序 <strong>$O(n^2)$ 最坏</strong>、冒泡排序 $O(n)$ 最好；</p><p>当输入序列逆序时：</p><p>直接插入排序 $O(n^2)$ 最坏、希尔排序 $O(n^2)$ 最坏（因为每两个就要比较一次）、快速排序 <strong>$O(n^2)$ 最坏</strong>（因为基准元素依然在两端）、冒泡排序 $O(n^2)$ 最坏；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data-Structure </tag>
            
            <tag> Sort </tag>
            
            <tag> Hash-Table </tag>
            
            <tag> BSTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习-第二部分</title>
      <link href="//review/data-structure-2/"/>
      <url>//review/data-structure-2/</url>
      
        <content type="html"><![CDATA[<p><i><u>本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充</u></i></p><p><i>Written by SJTU-XHW</i></p><p><i>Reference: 张同珍老师 PPT | UNIkeEN</i></p><hr><span id="more"></span><p>注：默认定义异常类型<code>noElementException</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">noElementException</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noElementException</span>(<span class="type">const</span> <span class="type">char</span>* msg=<span class="string">&quot;No element in the container.&quot;</span>)</span><br><span class="line">        : <span class="built_in">message</span>(msg) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> message; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Chapter-3-栈"><a href="#Chapter-3-栈" class="headerlink" title="Chapter 3 栈"></a>Chapter 3 栈</h2><h3 id="3-1-零碎概念集合"><a href="#3-1-零碎概念集合" class="headerlink" title="3.1 零碎概念集合"></a>3.1 零碎概念集合</h3><ul><li><p>栈的地位：一种特殊的（<strong>后进先出，LIFO</strong>）的线性表，仅允许在一端插入、同一端删除；</p><blockquote><p>栈底、栈顶、空栈、进栈/压栈、出栈/弹栈的定义；</p></blockquote></li><li><p>栈的基本运算：创、进出、读头、判空；</p></li><li><p><strong>时间有序表：因为栈的元素关系和离开、到达的时间有关，所以栈又被称为时间有序表</strong></p></li></ul><h3 id="3-2-栈的顺序实现"><a href="#3-2-栈的顺序实现" class="headerlink" title="3.2 栈的顺序实现"></a>3.2 栈的顺序实现</h3><ol><li><p>存储实现：数组模拟栈，idx=0为栈底；<strong>【数组头指针、规模数、栈顶位置】</strong></p><blockquote><p>注意：栈顶位置数的地方存放有效数据，所以空栈的栈顶位置习惯为-1；</p></blockquote></li><li><p>运算实现：过于简单，一笔带过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">seqStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* data;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="type">int</span> topIdx;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doubleSpace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T* tmp = data;</span><br><span class="line">        data = <span class="keyword">new</span> T[maxSize * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= topIdx; ++i)</span><br><span class="line">            data[i] = tmp[i];</span><br><span class="line">        <span class="keyword">delete</span>[] tmp; maxSize *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">seqStack</span>(<span class="type">int</span> capacity=<span class="number">10</span>) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> T[capacity];</span><br><span class="line">        maxSize = capacity; topIdx = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">seqStack</span>() &#123; <span class="keyword">if</span> (data) <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> topIdx == <span class="number">-1</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度均摊分析：平均 O(1)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; dt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (topIdx == maxSize - <span class="number">1</span>) <span class="built_in">doubleSpace</span>();</span><br><span class="line">        data[++topIdx] = dt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (topIdx == <span class="number">-1</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> data[topIdx--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (topIdx == <span class="number">-1</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> data[topIdx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-3-顺序栈的变种：共享栈"><a href="#3-3-顺序栈的变种：共享栈" class="headerlink" title="3.3 顺序栈的变种：共享栈"></a>3.3 顺序栈的变种：共享栈</h3><blockquote><p>为了提高空间利用率，在某些实际问题中使用多个数据类型相同的栈时，在一块连续的空间中设置多个栈共享空间，其中每个栈有连续的小空间，如图所示。</p><p><strong>提示：对栈操作的函数会添加一个整型参数指定究竟对谁操作</strong></p></blockquote><p><img src="shared_stacks.png"></p><h3 id="3-4-栈的链接实现"><a href="#3-4-栈的链接实现" class="headerlink" title="3.4 栈的链接实现"></a>3.4 栈的链接实现</h3><ol><li><p>存储实现：所有操作在栈顶完成——无需头结点的单链表；<strong>【栈顶指针】</strong></p></li><li><p>运算实现：解说略；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">linkStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        T data;</span><br><span class="line">        node* next;</span><br><span class="line">        <span class="built_in">node</span>() &#123; next = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="built_in">node</span>(<span class="type">const</span> T&amp; dt, node* n=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">data</span>(dt), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node* top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">linkStack</span>() &#123; top = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    ~<span class="built_in">linkStack</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (top) &#123;</span><br><span class="line">            node* tmp = top;</span><br><span class="line">            top = top-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>[] tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> top == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; dt)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> <span class="built_in">node</span>&lt;T&gt;(dt, top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">        T ans = top-&gt;data;</span><br><span class="line">        node* tmp = top;</span><br><span class="line">        top = top-&gt;next; <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getTop</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-5-栈的应用"><a href="#3-5-栈的应用" class="headerlink" title="3.5 栈的应用"></a>3.5 栈的应用</h3><ul><li><p>判断回文序列</p></li><li><p><strong>手动消除递归</strong></p><p><strong>经典例题：Ackerman 函数非递归求解、非递归快速排序</strong></p><script type="math/tex; mode=display">\begin{aligned}&已知Ackerman函数的定义(m、n均为非负整数):\\&A(m,n)=\begin{equation}\left\{\begin{aligned}&n+1\qquad&if\space m=0\\&A(m-1,1)\quad&if\space m\gt0\space and\space n=0\\&A(m-1,A(m,n-1))&if\space m\gt0\space and\space n\gt0\\\end{aligned}\right.\end{equation}\\&\\&试用非递归方法定义Ackerman计算函数:\\\end{aligned}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ackerman</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span>;        <span class="comment">// 允许使用 seqStack 类</span></span><br></pre></td></tr></table></figure><blockquote><p>具体思路：定义栈中的元素类型为保存m、n两个数的结构体（可以使用C++内置STL pair），先将A(m, n)作为一个元素放入栈中开始循环，循环判断栈非空进入，每次弹出一个元素计算。</p><p>如果 m &gt; 0 且 n = 0，那么构建新的元素A(m-1, 1)放进栈中；</p><p>如果 m &gt; 0 且 n &gt; 0，那么<strong>不妨把用不到的负数 -1 作为未计算的结果代替 A(m, n-1)</strong>，构建元素A(m-1, -1)进栈，<strong>紧接着进栈A(m, n-1)来补充前面的-1的含义，等待计算；</strong></p><p>如果直接计算出结果（m=0），那么检查栈是否为空，如果空，说明计算完成，结束；如果非空，那么说明<strong>这个结果一定是前一个被-1代替的位置上的结果</strong>，只需再弹出一个元素，将其中-1改为当前结果再进栈即可；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ackerman</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">     <span class="type">int</span> m, n;</span><br><span class="line">     <span class="built_in">node</span>(<span class="type">int</span> m_=<span class="number">-1</span>,<span class="type">int</span> n_=<span class="number">-1</span>)</span><br><span class="line">         :<span class="built_in">m</span>(m_), <span class="built_in">n</span>(n_) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> seqStack&lt;node&gt; stk;</span><br><span class="line"> stk.<span class="built_in">push</span>(<span class="built_in">node</span>(m, n));</span><br><span class="line"> <span class="keyword">while</span> (!stk.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">     node tmp = stk.<span class="built_in">pop</span>();</span><br><span class="line">     <span class="keyword">if</span> (tmp.m == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (stk.<span class="built_in">isempty</span>())</span><br><span class="line">             <span class="keyword">return</span> tmp.n + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             node pre = stk.<span class="built_in">pop</span>();</span><br><span class="line">             stk.<span class="built_in">push</span>(<span class="built_in">node</span>(pre.m, tmp.n+<span class="number">1</span>));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (tmp.n == <span class="number">0</span>)</span><br><span class="line">         stk.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp.m<span class="number">-1</span>, <span class="number">1</span>));</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         stk.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp.m<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">         stk.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp.m, tmp.n<span class="number">-1</span>));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>括号匹配</p><blockquote><p>思路：读入开括号进栈，读入闭括号检查（如果空栈，错误；如果非空则弹出，弹出再检查，如果不匹配则有错误）；最后读取结束必须空栈，否则错误；</p></blockquote></li><li><p><strong>表达式计算</strong></p><blockquote><p>前缀表达式、中缀表达式、后缀表达式的定义；</p></blockquote><ol><li><p>中缀表达式转后缀表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 从左至右读取中缀表达式</span><br><span class="line">while (当前字符非空) &#123;</span><br><span class="line">    if (读入操作数) 直接输出到后缀表达式中</span><br><span class="line">    if (读入开括号) 直接进运算符栈</span><br><span class="line">    // 括号内的运算符优先级优先于括号外</span><br><span class="line">    if (读入闭括号) 栈内运算符依此弹出并输出，直至开括号停止</span><br><span class="line">    if (读入操作符) &#123;</span><br><span class="line">        // 最高运算符优先级，右结合</span><br><span class="line">        if (操作符是 ^ ) 直接进栈</span><br><span class="line">        // 之前同级、或更高级的运算符可以优先运算</span><br><span class="line">        if (操作符是 */ ) 可以一直出栈，直至遇到 +-或左括号或空，自己进栈</span><br><span class="line">        if (操作符是 +- ) 可以一直出栈，直至遇到左括号或空，自己进栈</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">while (栈非空) &#123;</span><br><span class="line">    运算符出栈，输出到后缀表达式中</span><br><span class="line">    if (出栈元素有括号)</span><br><span class="line">        报告表达式错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后缀表达式的计算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 从左至右读取后缀表达式</span><br><span class="line">while (当前字符非空) &#123;</span><br><span class="line">    if (读入操作数) 进操作数栈</span><br><span class="line">    if (读到运算符) 将指定元数的操作数依此（后出被运算数）出栈进行运算，结果进栈</span><br><span class="line">&#125;</span><br><span class="line">结果出栈</span><br><span class="line">if (栈非空)</span><br><span class="line">    报告表达式错误</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="Chapter-4-队列"><a href="#Chapter-4-队列" class="headerlink" title="Chapter 4 队列"></a>Chapter 4 队列</h2><h3 id="4-1-零碎概念集合"><a href="#4-1-零碎概念集合" class="headerlink" title="4.1 零碎概念集合"></a>4.1 零碎概念集合</h3><ul><li><p>队列的地位：一种特殊的、先进先出（<strong>FIFO</strong>）的线性表；允许在一端插入、另一端删除；</p><blockquote><ol><li>队尾与队头、队列长度、空队列、入队和出队的定义；</li><li>队列也是一种时间有序表；</li></ol></blockquote></li><li><p>队列的基本运算种类：创建、读头、判空、入队、出队；</p></li></ul><h3 id="4-2-队列的顺序实现"><a href="#4-2-队列的顺序实现" class="headerlink" title="4.2 队列的顺序实现"></a>4.2 队列的顺序实现</h3><blockquote><p>和栈不同，如何设计队头、队尾对性能影响极大；</p><p>&#8618; 队首位置固定方式，缺点是出队会引起大量数据移动</p><p>&#8618; 队首位置不固定方式，所有操作都是O（1），但浪费空间。</p></blockquote><ul><li><p>最好的一种存储实现之一：<strong>循环队列</strong>【队头整型、队尾整型、顺序表头指针、规模数】</p><ul><li>队头指针（int）区域<strong>不存放数据</strong>，队尾指针在非空是总是指向最后一个数；</li><li>可以使用取余的方法将队列的空间充分利用；</li></ul></li><li><p>运算实现：解说略</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">seqQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> head;</span><br><span class="line">    <span class="type">int</span> tail;</span><br><span class="line">    T* data;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doubleSpace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T* tmp = data;</span><br><span class="line">        data = <span class="keyword">new</span> T[<span class="number">2</span> * maxSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxSize; ++i) &#123;</span><br><span class="line">            data[i] = tmp[(head + i) % maxSize];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp;</span><br><span class="line">        head = <span class="number">0</span>; tail = maxSize; maxSize *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">seqQueue</span>(<span class="type">int</span> capacity=<span class="number">10</span>) &#123;</span><br><span class="line">        maxSize = capacity;</span><br><span class="line">        data = <span class="keyword">new</span> T[capacity];</span><br><span class="line">        head = tail = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">seqQueue</span>() &#123; <span class="keyword">if</span> (data) <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">       <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> head == tail; &#125;</span><br><span class="line">    <span class="function">T <span class="title">getHead</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> data[(head + <span class="number">1</span>) % maxSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(<span class="type">const</span> T&amp; dt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((tail + <span class="number">1</span>) % maxSize == head)</span><br><span class="line">            <span class="built_in">doubleSpace</span>();</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % maxSize;</span><br><span class="line">        data[tail] = dt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">        head = (head + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> data[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>易错点</strong>：doubleSpace时将顺序表扩大时注意0索引区域不放数据！</p></li></ul><h3 id="4-3-队列的链接实现"><a href="#4-3-队列的链接实现" class="headerlink" title="4.3 队列的链接实现"></a>4.3 队列的链接实现</h3><blockquote><p>法一：使用无头结点的单链表存储队列—-&gt;【队头、队尾指针】</p><p>法二：使用单循环链表—-&gt;【队尾指针】</p></blockquote><h3 id="4-4-队列的实际应用"><a href="#4-4-队列的实际应用" class="headerlink" title="4.4 队列的实际应用"></a>4.4 队列的实际应用</h3><ul><li>排队系统模拟：事件驱动模拟</li><li>火车车厢重排</li><li><strong>迷宫矩阵问题</strong><ul><li>寻找可能解【DFS】：栈消除递归进行回溯；</li><li>寻找最优解【BFS】：利用队列<strong>同步</strong>检查所有可能道路，先到终点的连通道路就是最短道路</li></ul></li></ul><h2 id="Chapter-5-二叉树、树和森林"><a href="#Chapter-5-二叉树、树和森林" class="headerlink" title="Chapter 5 二叉树、树和森林"></a>Chapter 5 二叉树、树和森林</h2><h3 id="5-1-重要概念集合"><a href="#5-1-重要概念集合" class="headerlink" title="5.1 重要概念集合"></a>5.1 重要概念集合</h3><ul><li><p>树的两种定义</p><ol><li>在一个元素集合中，如果元素呈<strong>上下层次关系</strong>。对一个结点而言，上层元素为其直接前驱且直接前驱唯一，下层元素为其直接后继且直接后继可以有多个，这样的结构就是树结构。</li><li>递归定义：树是n个结点（离散数学要求<code>n &gt; 0</code>）的有限集合，它或者是空集，或者满足：<ul><li>有一个被称为根的结点；</li><li>其余结点可分为m（m &gt; 0）个互不相交的集合 <code>T1, T2, ..., Tm</code>这些集合本身也是一棵树，并称它们为根结点的子树；</li></ul></li></ol></li><li><p><strong>各类结点的定义</strong></p><ul><li><p>根结点、叶结点、内部节点/中间结点；</p></li><li><p>子结点、父结点、祖先结点、子孙结点、兄弟结点；</p><blockquote><p>注意：兄弟结点只有同一父结点才算！！！否则叫堂兄弟结点；</p></blockquote></li></ul></li><li><p><strong>各种“度”</strong></p><ul><li>结点的度：树中一个结点的直接后继（子结点）的数目；</li><li>结点深度（层次）：从根结点（<strong>高度定为1</strong>）向下到该结点的对应数；</li><li>结点高度：以该结点为根的子树的高度；</li><li>树的高度：树中所有结点的最大深度；</li></ul></li><li><p>有序树和无序树：如果树中任意结点的子结点都被规定了一定的顺序，就称此树为有序树，反之称为无序树；</p></li><li><p>森林：M棵互不相交的树的集合</p><blockquote><p>由定义，一棵删去根的树，其子树构成的集合就是一个森林；</p></blockquote></li></ul><h3 id="5-2-二叉树的重要概念"><a href="#5-2-二叉树的重要概念" class="headerlink" title="5.2 二叉树的重要概念"></a>5.2 二叉树的重要概念</h3><ul><li><p>定义：建议将树的定义代入，只需注意二叉的特点；</p><blockquote><p><strong>注意：二叉树的子结点需要明确指明是左还是右，哪怕只有一个子结点</strong></p></blockquote></li><li><p>特殊二叉树</p><ul><li>满二叉树：k层二叉树的每一个结点数量都达最大值；</li><li>完全二叉树：k层二叉树的k-1层都是满的，k层相较于满二叉树<strong>从右至左依此去掉</strong>若干结点得到的树；</li></ul></li><li><p>二叉树性质</p><ul><li><p>一棵非空二叉树的第 i 层上<strong>最多</strong>有 <strong>$2^{i-1}$</strong> 个结点（i ≥ 1）；</p></li><li><p>一棵高度为 k 的二叉树<strong>最多</strong>有 <strong>$2^k-1$</strong> 个结点；</p></li><li><p>一棵非空二叉树，若叶结点数 <strong>$n_0$</strong>，度为 2 的结点数 <strong>$n_2$</strong>，则 <strong>$n_0=n_2+1$</strong>；</p></li><li><p>具有 n 个结点的<strong>完全二叉树</strong>的高度一定为 <strong>$k=floor(log_2n)+1$</strong></p></li><li><p>对有 n 个结点的<strong>完全二叉树</strong>的结点按层自上而下，每一层自左至右依此编号，设根结点编号为 1，那么：</p><script type="math/tex; mode=display">\begin{aligned}&1.\quad i=1\Longleftrightarrow 该二叉树根结点;\quad i\gt 1\Longrightarrow 该结点的父结点编号floor(\dfrac{i}{2})\\&2.\quad 若\space 2i\gt n,\space则编号为\space i\space的结点为叶结点,否则其左子结点编号为\space 2i\\&3.\quad若\space2i+1\gt n,\space 则编号为\space i\space的结点没有右子结点，否则其右子结点的编号为\space 2i+1\end{aligned}</script></li></ul></li><li><p>二叉树的基本运算：创清、判空、寻根、寻父、寻左儿子寻右儿子、删左儿子删右儿子、遍历</p></li><li><p>二叉树的<strong>遍历序列 和 确定</strong></p><ul><li><strong><u>二叉树的前序-中序、后序-中序、层次-中序 遍历序列都可以确定唯一一个二叉树（必须含有中序）</u></strong></li><li>完全二叉树的层次遍历能唯一确定该完全二叉树；</li><li>满二叉树的前序、中序、后序遍历序列<strong>之一</strong>就能完全确定该满二叉树；</li><li><strong>做题方法：遇到从某些序列构建完整的二叉树时，应该在过程中反复比对</strong></li></ul></li><li><p>考题分析</p><ul><li><p>一个完全二叉树的叶结点个数为124，问该树所有结点的最大个数为多少；</p><blockquote><p>分析方法一：完全二叉树的叶结点为124，先考虑满二叉树的情况（<strong>注意到在所有的、高度相同的完全二叉树中，满二叉树的叶结点最大！</strong>），满二叉树高度为7时，64个叶结点；满二叉树高度为8时，128个叶结点；满二叉树高度为9时，256个叶结点，<strong>且倒数第二层共128个内部结点</strong>；因此：</p><ul><li>该树的高度一定大于7、小于9 <strong>$\Longrightarrow$</strong> 该树的高度为8；</li></ul><p>再考虑从满二叉树减少结点，每减少两个兄弟结点中的一个，叶结点数减少1（只剩一个时不会变）；所以满足条件的完全二叉树可以：<strong>从8层满二叉树下自右至左减去 8 个或 7 个叶结点</strong>，即 <strong>$n_{max}=2^8-1-7=248$</strong></p><p><strong>分析方法二（最优解）</strong>：</p><script type="math/tex; mode=display">n=n_0+n_1+n_2\space且\space b=n-1=n_1+2n_2\Rightarrow n_2=n_0-1=123</script><p>由于<strong>完全二叉树必须有：$n_1=1或0$</strong>，故 <strong>$n_{max}=124+1+123=248$</strong></p><p>结论：该树的所有节点最大个数为 248</p></blockquote></li></ul></li></ul><h3 id="5-3-二叉树的存储和运算实现"><a href="#5-3-二叉树的存储和运算实现" class="headerlink" title="5.3 二叉树的存储和运算实现"></a>5.3 二叉树的存储和运算实现</h3><blockquote><p>顺序实现：仅建议完全二叉树 / 具有一些结点关系的树（例如哈夫曼树）/ 不需要频繁增删结点的普通二叉树采用这种存储方式，否则导致空间利用率低下；</p></blockquote><p>[x] <strong>二叉树的主要存储方式是链接实现的</strong></p><ul><li><p>标准存储结构（最常用）：二叉链表【表头指针】</p><ul><li>大多数操作简单，但寻父运算性能不佳；</li></ul></li><li><p>广义标准存储结构：三叉链表【表头指针】</p></li><li><p>二叉树运算实现</p><ul><li>寻左右儿子、删左右儿子的函数需要底层的find函数先查找；</li><li>清除、删左右儿子的函数需要底层的“删除结点及其子树”的clear函数；</li><li>深度优先的递归的消除采用栈，广度优先采用队列实现；</li></ul><blockquote><p>下面以非递归实现的标准存储的二叉树为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        T data;</span><br><span class="line">        node* left;</span><br><span class="line">        node* right;</span><br><span class="line">        <span class="built_in">node</span>(): <span class="built_in">left</span>(<span class="number">0</span>), <span class="built_in">right</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">node</span>(<span class="type">const</span> T&amp; dt, node* L=<span class="number">0</span>, node* R=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">data</span>(dt), <span class="built_in">left</span>(L), <span class="built_in">right</span>(R) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">travNode</span> &#123;</span><br><span class="line">        node* curNode;</span><br><span class="line">        <span class="type">int</span> popTimes;</span><br><span class="line">        <span class="built_in">travNode</span>(node* n=<span class="number">0</span>, <span class="type">int</span> pop=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">curNode</span>(n), <span class="built_in">popTimes</span>(pop) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    node* root;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line">    <span class="function">node* <span class="title">find</span><span class="params">(<span class="type">const</span> T&amp; dt)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">binTree</span>();</span><br><span class="line">    <span class="built_in">binTree</span>(<span class="type">const</span> T&amp; dt);</span><br><span class="line">    ~<span class="built_in">binTree</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createFromStd</span><span class="params">(<span class="type">const</span> T&amp; emptyFlag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">Root</span><span class="params">(<span class="type">const</span> T&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">father</span><span class="params">(<span class="type">const</span> T&amp; dt, <span class="type">const</span> T&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">leftChild</span><span class="params">(<span class="type">const</span> T&amp; dt, <span class="type">const</span> T&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">rightChild</span><span class="params">(<span class="type">const</span> T&amp; dt, <span class="type">const</span> T&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rmLeftChild</span><span class="params">(<span class="type">const</span> T&amp; dt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rmRightChild</span><span class="params">(<span class="type">const</span> T&amp; dt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrdTrav</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">midOrdTrav</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrdTrav</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelTrav</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常见实现</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">binTree&lt;T&gt;::<span class="built_in">binTree</span>() &#123; root = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">binTree&lt;T&gt;::<span class="built_in">binTree</span>(<span class="type">const</span> T&amp; dt) &#123; root = <span class="keyword">new</span> <span class="built_in">node</span>(dt); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">binTree&lt;T&gt;::~<span class="built_in">binTree</span>() &#123; <span class="built_in">clear</span>(root); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">createFromStd</span>(<span class="type">const</span> T&amp; emptyFlag) &#123;</span><br><span class="line">    seqQueue&lt;node*&gt; tasks;</span><br><span class="line">    T left, right;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;root: &quot;</span>; std::cin &gt;&gt; left;</span><br><span class="line">        <span class="keyword">if</span> (left != emptyFlag) tasks.<span class="built_in">enQueue</span>(root = <span class="keyword">new</span> <span class="built_in">node</span>(left));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; tasks.<span class="built_in">enQueue</span>(root); &#125;</span><br><span class="line">    <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        node* cur = tasks.<span class="built_in">deQueue</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;the left child &amp; the right child of &quot;</span> &lt;&lt; cur-&gt;data &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        std::cin &gt;&gt; left &gt;&gt; right;</span><br><span class="line">        <span class="keyword">if</span> (left != emptyFlag)</span><br><span class="line">            tasks.<span class="built_in">enQueue</span>(cur-&gt;left = <span class="keyword">new</span> <span class="built_in">node</span>(left));</span><br><span class="line">        <span class="keyword">if</span> (right != emptyFlag)</span><br><span class="line">            tasks.<span class="built_in">enQueue</span>(cur-&gt;right = <span class="keyword">new</span> <span class="built_in">node</span>(right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> binTree&lt;T&gt;::<span class="built_in">isempty</span>() <span class="type">const</span> &#123; <span class="keyword">return</span> root == <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">clear</span>() &#123; <span class="built_in">clear</span>(root); root = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T binTree&lt;T&gt;::<span class="built_in">Root</span>(<span class="type">const</span> T&amp; emptyFlag) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> emptyFlag;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T binTree&lt;T&gt;::<span class="built_in">father</span>(<span class="type">const</span> T&amp; dt, <span class="type">const</span> T&amp; emptyFlag) &#123; <span class="keyword">return</span> emptyFlag; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T binTree&lt;T&gt;::<span class="built_in">leftChild</span>(<span class="type">const</span> T&amp; dt, <span class="type">const</span> T&amp; emptyFlag) <span class="type">const</span> &#123;</span><br><span class="line">    node* cur = <span class="built_in">find</span>(dt);</span><br><span class="line">    <span class="keyword">if</span> (!cur || !(cur-&gt;left)) <span class="keyword">return</span> emptyFlag;</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;left-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T binTree&lt;T&gt;:: <span class="built_in">rightChild</span>(<span class="type">const</span> T&amp; dt, <span class="type">const</span> T&amp; emptyFlag) <span class="type">const</span> &#123;</span><br><span class="line">    node* cur = <span class="built_in">find</span>(dt);</span><br><span class="line">    <span class="keyword">if</span> (!cur || !(cur-&gt;right)) <span class="keyword">return</span> emptyFlag;</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;right-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">rmLeftChild</span>(<span class="type">const</span> T&amp; dt) &#123; </span><br><span class="line">    node* cur = <span class="built_in">find</span>(dt);</span><br><span class="line">    <span class="keyword">if</span> (!cur || !(cur-&gt;left)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">clear</span>(cur-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">rmRightChild</span>(<span class="type">const</span> T&amp; dt) &#123; </span><br><span class="line">    node* cur = <span class="built_in">find</span>(dt);</span><br><span class="line">    <span class="keyword">if</span> (!cur || !(cur-&gt;right)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">clear</span>(cur-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">preOrdTrav</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    seqStack&lt;node*&gt; tasks;</span><br><span class="line">    tasks.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        node* tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; tmp-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right) tasks.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left) tasks.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">midOrdTrav</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    seqStack&lt;travNode&gt; tasks;</span><br><span class="line">    tasks.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        travNode tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (tmp.popTimes == <span class="number">0</span>) &#123;</span><br><span class="line">            ++tmp.popTimes;</span><br><span class="line">            tasks.<span class="built_in">push</span>(tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp.curNode-&gt;left)</span><br><span class="line">                tasks.<span class="built_in">push</span>(<span class="built_in">travNode</span>(tmp.curNode-&gt;left));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; tmp.curNode-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmp.curNode-&gt;right)</span><br><span class="line">                tasks.<span class="built_in">push</span>(<span class="built_in">travNode</span>(tmp.curNode-&gt;right));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">postOrdTrav</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    seqStack&lt;travNode&gt; tasks;</span><br><span class="line">    tasks.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        travNode tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">switch</span> (tmp.popTimes) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            ++tmp.popTimes;</span><br><span class="line">            tasks.<span class="built_in">push</span>(tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp.curNode-&gt;left)</span><br><span class="line">                tasks.<span class="built_in">push</span>(<span class="built_in">travNode</span>(tmp.curNode-&gt;left));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ++tmp.popTimes;</span><br><span class="line">            tasks.<span class="built_in">push</span>(tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp.curNode-&gt;right)</span><br><span class="line">                tasks.<span class="built_in">push</span>(<span class="built_in">travNode</span>(tmp.curNode-&gt;right));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; tmp.curNode-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">levelTrav</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    seqQueue&lt;node*&gt; tasksQ;</span><br><span class="line">    tasksQ.<span class="built_in">enQueue</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!tasksQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        node* tmp = tasksQ.<span class="built_in">deQueue</span>();</span><br><span class="line">        std::cout &lt;&lt; tmp-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left) tasksQ.<span class="built_in">enQueue</span>(tmp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right) tasksQ.<span class="built_in">enQueue</span>(tmp-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> binTree&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    seqStack&lt;node*&gt; tasks;</span><br><span class="line">    tasks.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        node* tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left) tasks.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right) tasks.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-4-二叉线索树"><a href="#5-4-二叉线索树" class="headerlink" title="5.4 二叉线索树"></a>5.4 二叉线索树</h3><blockquote><p>在二叉树中利用空指针域，如果一个结点的左/右指针为空，就将<strong>某种遍历序列中的这个结点的直接前驱结点地址存在该位置</strong>，这种二叉树就叫<strong>线索树</strong></p></blockquote><ul><li>对一棵中序线索树而言，中序遍历的非递归实现可以不使用栈；</li></ul><h3 id="5-5-哈夫曼树"><a href="#5-5-哈夫曼树" class="headerlink" title="5.5 哈夫曼树"></a>5.5 哈夫曼树</h3><ul><li><p>哈夫曼树的存储方法</p><ul><li><strong>哈夫曼树只有度为2的结点和叶结点，总结点数=2*需编码字符数-1【元素数了解】</strong></li><li><strong>哈夫曼树建立后一般不会进行结点增删</strong></li></ul><blockquote><p><strong>所以采用规模数为2n的数组静态（顺序）存储</strong></p></blockquote></li><li><p>哈夫曼树的建立：哈夫曼算法</p><ul><li><p>step1：从给定权值和数据的集合中构建一片只有根结点的二叉树森林；</p><blockquote><p>将需编码数据和权值对应地加入第 n~2n-1 索引的数组内，其他位置所有数据置为0（第0索引空出）；</p></blockquote></li><li><p>step2：执行 n-1 次循环，选择每次森林中<strong>权值最小、次最小</strong>的两棵树，以这两棵树为左右子树构建出一棵新树，移除这两棵树并将新树加入；</p><blockquote><p>执行 n-1 次循环，第 i 次在下标 n + i - 1 到 2n - 1 之间寻找满足：<strong>父结点对应值为0（当前是树根）</strong>且<strong>权值最小 和 次小的结点</strong>，并且①在 n + i 的位置填入 {权值=两点权值和；左右子节点为找到的两结点} 的结点 ；②修改被找到的那两个结点的父结点为 <script type="math/tex">n+i</script>；</p><p>即：修改父子关系、置权归并；</p></blockquote></li><li><p>step3：如果只剩下一个树，那么这个树根上的结点的值即为所求；</p></li></ul><blockquote><p>⚠易错警示：注意比较森林中的最小两个权的树，不一定是”最大的“那个树，切忌惯性思维；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Huffman Tree</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hfTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hfNode</span> &#123;</span><br><span class="line">        T data;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="type">int</span> parent;</span><br><span class="line">        <span class="type">int</span> left;</span><br><span class="line">        <span class="type">int</span> right;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    hfNode* treeData;</span><br><span class="line">    <span class="comment">// The length of the treeData(hfNode*)</span></span><br><span class="line">    <span class="comment">// = 2 * numOfData.</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hfCode</span>&#123;</span><br><span class="line">        T data;</span><br><span class="line">        std::string code;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">hfTree</span>(<span class="type">const</span> T* dt, <span class="type">const</span> <span class="type">int</span>* w, <span class="type">int</span> size);</span><br><span class="line">    ~<span class="built_in">hfTree</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getCode</span><span class="params">(hfCode results[])</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">hfTree&lt;T&gt;::<span class="built_in">hfTree</span>(<span class="type">const</span> T* dt, <span class="type">const</span> <span class="type">int</span>* w, <span class="type">int</span> size) &#123;</span><br><span class="line">    length = size * <span class="number">2</span>;</span><br><span class="line">    treeData = <span class="keyword">new</span> hfNode[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt; length; ++i) &#123;</span><br><span class="line">        treeData[i].data = dt[i - size];</span><br><span class="line">        treeData[i].weight = w[i - size];</span><br><span class="line">        treeData[i].parent = treeData[i].left = treeData[i].right = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 想要提高这一段速度，可以把这个 O(n^2) 代码改成优先级队列的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> min_1, min_2, min_1_idx = <span class="number">0</span>, min_2_idx = <span class="number">0</span>;</span><br><span class="line">        min_1 = min_2 = INT32_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (treeData[j].parent == <span class="number">0</span>) &#123;<span class="comment">// The root of the subtree.</span></span><br><span class="line">                <span class="keyword">if</span> (treeData[j].weight &lt; min_1) &#123;</span><br><span class="line">                    min_2 = min_1;<span class="comment">// Give the last value of min_1 to min_2</span></span><br><span class="line">                    min_1 = treeData[j].weight;<span class="comment">// so that min_2 can be the second smallest element.</span></span><br><span class="line">                    min_2_idx = min_1_idx;</span><br><span class="line">                    min_1_idx = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (treeData[j].weight &lt; min_2) &#123;</span><br><span class="line">                    min_2 = treeData[j].weight;</span><br><span class="line">                    min_2_idx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The end of this round. Change the hier-info &amp; weight.</span></span><br><span class="line">        treeData[i].parent = <span class="number">0</span>;</span><br><span class="line">        treeData[i].weight = min_1 + min_2;</span><br><span class="line">        treeData[i].left = min_1_idx;</span><br><span class="line">        treeData[i].right = min_2_idx;</span><br><span class="line">        treeData[min_1_idx].parent = i;</span><br><span class="line">        treeData[min_2_idx].parent = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">hfTree&lt;T&gt;::~<span class="built_in">hfTree</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (treeData) <span class="keyword">delete</span>[] treeData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> hfTree&lt;T&gt;::<span class="built_in">getCode</span>(hfCode result[]) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> size = length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> step = i;</span><br><span class="line">        result[i - size].data = treeData[i].data;</span><br><span class="line">        result[i - size].code = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (step &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result[i - size].code = (</span><br><span class="line">                treeData[treeData[step].parent].left==step</span><br><span class="line">                ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span></span><br><span class="line">            ) + result[i - size].code;</span><br><span class="line">            step = treeData[step].parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>哈夫曼树的重要相关概念</p><ul><li><p>结点的带权路径长 = 路径权值 * 路径长（=深度-1）；</p></li><li><p>树的带权路径长 = 所有<strong>叶结点</strong>的带权路径之和；</p></li></ul></li><li><p>哈夫曼编码求解的时间复杂度分析</p><ul><li>树高根据情况在：<strong>$O(log_2n)\sim O(n)$</strong> 规模，循环查找所有编码，故复杂度在 <strong>$O(nlog_2n)\sim O(n^2)$</strong> 之间；</li></ul></li></ul><h3 id="5-6-二叉树、树与森林的转换"><a href="#5-6-二叉树、树与森林的转换" class="headerlink" title="5.6 二叉树、树与森林的转换"></a>5.6 二叉树、树与森林的转换</h3><ul><li><p>树的存储实现</p><ul><li><p>孩子链表示法：静态孩子链表（表头数组存储所有结点，会指向下标链表）、动态孩子链表（所有结点组成一个链表）；</p><blockquote><p>可以考虑增加一个结点字段存放父结点，称“带双亲的孩子链表示法”</p></blockquote></li><li><p><strong>孩子兄弟链表示法（最常用）</strong>：<code>左指针指向第一个儿子 | 数据 | 右指针指向第一个兄弟（不重复）</code></p><blockquote><p>转换成二叉树后，根结点一定没有右儿子；</p></blockquote></li><li><p>双亲表示法：通过指向父结点的指针将树中结点关联（不相交集可以用此方法存储）；</p></li></ul></li><li><p>森林的存储实现：每棵树孩子兄弟链 + 右子树拼接；</p></li><li><p>树的遍历：前序、后序、层次；</p></li></ul><h2 id="Chapter-6-优先级队列"><a href="#Chapter-6-优先级队列" class="headerlink" title="Chapter 6 优先级队列"></a>Chapter 6 优先级队列</h2><blockquote><p>优先级队列不宜借助线性结构实现，因为出队 / 入队一定有一个效率 为 O(n)；</p></blockquote><h3 id="6-1-重要概念集合"><a href="#6-1-重要概念集合" class="headerlink" title="6.1 重要概念集合"></a>6.1 重要概念集合</h3><ul><li>二叉堆：一棵满足<strong>结构性、有序性</strong>的二叉树（完全二叉树）；</li><li>二叉堆结构性优势：树高度尽可能小，可以采用顺序存储，最坏对数级别时间复杂度；</li><li>二叉堆有序性优势：算法上保证入队、出队的时间性能；</li><li>优先级队列的基本运算：同队列；</li></ul><h3 id="6-2-优先级队列的实现方法：树形结构"><a href="#6-2-优先级队列的实现方法：树形结构" class="headerlink" title="6.2 优先级队列的实现方法：树形结构"></a>6.2 优先级队列的实现方法：树形结构</h3><ul><li><p>存储实现：二叉堆【队长度、队容量、二叉堆根结点】</p><blockquote><p><strong>⚠ATTENTION：</strong></p><p>如果二叉堆（完全二叉树）存储在数组中，规定0号位不放元素，那么可以用之前完全二叉树的结论：i 号位的左儿子 2i、右儿子 2i+1、父结点 floor(i/2)（如果有的话）；</p><p><strong>但如果二叉堆规定0号位放元素</strong>，那么需要转换一下：左儿子2i+1、右儿子2i+2、父结点floor((i-1)/2)；</p><p>推导：左子结点映射：i -&gt; 2i，索引移动后，i - 1 -&gt; 2i - 1；现在只知道 i - 1的结点的左子结点对应 2i - 1，想要知道 i 的左子结点，需要整体换元：i -&gt; 2(i + 1)-1 = 2i+1；其他同理;</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">priorityQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* data;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doubleSpace</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 可复用：使从第n号元素开始的以下结点全部平衡</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">percolateDown</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">priorityQueue</span>(<span class="type">int</span> capacity=<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">priorityQueue</span>(T* sequence, <span class="type">int</span> size);</span><br><span class="line">    ~<span class="built_in">priorityQueue</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(<span class="type">const</span> T&amp; dt)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">deQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">getHead</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>运算实现（以使用0号元素的、最小化堆【可以添加comp模板参数以实现自定义最大/最小化堆】实现优先级队列为例）</p><p>[PRIVATE] 扩容操作：完全与线性表相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> priorityQueue&lt;T&gt;::<span class="built_in">doubleSpace</span>() &#123;</span><br><span class="line">    T* tmp = data;</span><br><span class="line">    data = <span class="keyword">new</span> T[<span class="number">2</span> * maxSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxSize; ++i)</span><br><span class="line">        data[i] = tmp[i];</span><br><span class="line">    <span class="keyword">delete</span>[] tmp; maxSize *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建、删除 <strong>$O(1)$</strong>：分配数组、设置队长和容量；释放空间；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">priorityQueue&lt;T&gt;::<span class="built_in">priorityQueue</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">    maxSize = capacity; length = <span class="number">0</span>;</span><br><span class="line">    data = <span class="keyword">new</span> T[capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">priorityQueue&lt;T&gt;::~<span class="built_in">priorityQueue</span>() &#123; <span class="keyword">if</span> (data) <span class="keyword">delete</span>[] data; &#125;</span><br></pre></td></tr></table></figure><p>读头、判空 <strong>$O(1)$</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> priorityQueue&lt;T&gt;::<span class="built_in">isempty</span>() <span class="type">const</span> &#123; <span class="keyword">return</span> length == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T priorityQueue&lt;T&gt;::<span class="built_in">getHead</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入队操作：<strong>注意：$平均\space O(1)、最差\space O(log_2n)$</strong></p><blockquote><p>采用<strong>向上过滤法</strong>，入队到末尾，检查父结点和当前结点是否违反有序性，若是，交换并继续检查；若否，插入完成；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> priorityQueue&lt;T&gt;::<span class="built_in">enQueue</span>(<span class="type">const</span> T&amp; dt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (length == maxSize) <span class="built_in">doubleSpace</span>();</span><br><span class="line">    <span class="type">int</span> idx = length;</span><br><span class="line">    <span class="keyword">while</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[(idx - <span class="number">1</span>) / <span class="number">2</span>] &gt; dt)</span><br><span class="line">            data[idx] = data[(idx - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        idx = (idx - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data[length++] = dt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[PRIVATE] 平衡操作：<strong>注意：$平均、最坏均为\space O(log_2n)$</strong></p><blockquote><p>向下过滤，保证 n 号结点以下的所有部分满足有序性；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> priorityQueue&lt;T&gt;::<span class="built_in">percolateDown</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    T tmp = data[n]; <span class="type">int</span> next;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * n + <span class="number">1</span> &lt; length) &#123;</span><br><span class="line">        next = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (next + <span class="number">1</span> &lt; length &amp;&amp; data[next] &gt; data[next + <span class="number">1</span>]) ++next;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; data[next]) data[n] = data[next];</span><br><span class="line">        n = next;</span><br><span class="line">    &#125;</span><br><span class="line">    data[n] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队操作：<strong>注意：$平均、最坏均为\space O(log_2n)$</strong></p><blockquote><p>采用<strong>向下过滤法</strong>，将尾部元素覆盖到根结点上（为了保持堆的有序性，但同时也造成平均时间复杂度没有办法保持在线性级别），并percolateDown使得根结点以下处于平衡状态</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T priorityQueue&lt;T&gt;::<span class="built_in">deQueue</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">    T ans = data[<span class="number">0</span>];</span><br><span class="line">    data[<span class="number">0</span>] = data[--length];</span><br><span class="line">    <span class="built_in">percolateDown</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体创建操作：<strong>注意：$平均、最坏均为\space O(n)$，证明：$S=\sum\limits_{i=1}^h{2^{i-1}(h-i)}=N-h$</strong></p><blockquote><p>不用n次入队的方法；转换问题，为了避免递归从逆层次（最后一个非叶节点开始）向上进行平衡操作，类似动态规划，使得遍历到顶时整个列表由“完全二叉树”变为二叉堆；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">priorityQueue&lt;T&gt;::<span class="built_in">priorityQueue</span>(T* sequence, <span class="type">int</span> size) &#123;</span><br><span class="line">    maxSize = size + <span class="number">10</span>; length = size;</span><br><span class="line">    data = <span class="keyword">new</span> T[size + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        data[i] = sequence[i];</span><br><span class="line">    <span class="comment">// Build the heap.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="built_in">percolateDown</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-3-D堆、可归并堆（左堆、斜堆、二项堆）"><a href="#6-3-D堆、可归并堆（左堆、斜堆、二项堆）" class="headerlink" title="6.3 D堆、可归并堆（左堆、斜堆、二项堆）"></a>6.3 D堆、可归并堆（左堆、斜堆、二项堆）</h3><blockquote><p>略，在高级数据结构中详细叙述</p></blockquote><h3 id="6-4-优先级队列的应用"><a href="#6-4-优先级队列的应用" class="headerlink" title="6.4 优先级队列的应用"></a>6.4 优先级队列的应用</h3><ul><li><p>多柜台排队系统</p><blockquote><p>原理是：创建一个事件优先级队列，和一个普通的等待队列；先生成所有人的到达时间进队，再逐个出队，检查事件类型：是离开类型，则检查等待队列</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">创建一个事件优先级队列epQueue</span><br><span class="line">创建一个等待队列wQueue</span><br><span class="line">时间置为0</span><br><span class="line">for (循环customerNum次) &#123;</span><br><span class="line">    按指数分布（伪随机）生成顾客到达事件时间间隔dt</span><br><span class="line">    将到达事件（上一事件时间+dt）入队epQueue</span><br><span class="line">&#125;</span><br><span class="line">while (epQueue非空) &#123;</span><br><span class="line">    epQueue队头出队</span><br><span class="line">    设置当前时间为事件时间</span><br><span class="line">    if (事件类型是到达) &#123;</span><br><span class="line">        if (空闲柜台数 &gt; 0) &#123;</span><br><span class="line">            --空闲柜台数</span><br><span class="line">            生成所需服务时间st</span><br><span class="line">            将事件类型设置为离开</span><br><span class="line">            将事件时间+st</span><br><span class="line">            入队epQueue</span><br><span class="line">        &#125;</span><br><span class="line">        else 事件入队wQueue</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (等待队列非空) &#123;</span><br><span class="line">            wQueue队头出队</span><br><span class="line">            统计等待时间</span><br><span class="line">            生成服务所需时间st</span><br><span class="line">            将事件类型设置为离开</span><br><span class="line">            将事件时间+st</span><br><span class="line">            入队epQueue</span><br><span class="line">        &#125;</span><br><span class="line">        else ++空闲柜台数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">计算平均等待时间ave_t</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data-Structure </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习-第一部分</title>
      <link href="//review/data-structure-1/"/>
      <url>//review/data-structure-1/</url>
      
        <content type="html"><![CDATA[<p><i><u>本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充</u></i></p><p><i>Written by SJTU-XHW</i></p><p><i>Reference: 张同珍老师 PPT | UNIkeEN</i></p><hr/><span id="more"></span><h2 id="Chapter-1-数据结构绪论"><a href="#Chapter-1-数据结构绪论" class="headerlink" title="Chapter 1 数据结构绪论"></a>Chapter 1 数据结构绪论</h2><h3 id="1-1-数据结构逻辑分类"><a href="#1-1-数据结构逻辑分类" class="headerlink" title="1.1 数据结构逻辑分类"></a>1.1 数据结构逻辑分类</h3><ul><li>集合结构：次序任意，重视归属关系；</li><li>线性结构：有序序列，有前驱、后继关系；</li><li>树状结构：层次关系，分根元素-其他元素；</li><li>图状结构：一般的逻辑结构，不限前驱和后继；</li></ul><h3 id="1-2-逻辑结构基本运算类型"><a href="#1-2-逻辑结构基本运算类型" class="headerlink" title="1.2 逻辑结构基本运算类型"></a>1.2 逻辑结构基本运算类型</h3><blockquote><p>创、清、增删改查、访问、遍历</p></blockquote><h3 id="1-3-逻辑结构的运算实现"><a href="#1-3-逻辑结构的运算实现" class="headerlink" title="1.3 逻辑结构的运算实现"></a>1.3 逻辑结构的运算实现</h3><blockquote><p>存储结点、数据元素间关系（顺序实现、链接实现、散列实现、索引存储）、附加信息</p></blockquote><p><strong>总结：一个数据结构就是针对某一逻辑结构讨论数据的<u>存储实现</u>和<u>运算实现</u></strong></p><h3 id="1-4-算法优劣因素分析"><a href="#1-4-算法优劣因素分析" class="headerlink" title="1.4 算法优劣因素分析"></a>1.4 算法优劣因素分析</h3><blockquote><p>正确性、易读性、健壮性、<strong>高效率（时间、空间性能）</strong></p></blockquote><ol><li><p>时间复杂度：<strong>算法所需运算量 和 问题规模 间的关系</strong></p><blockquote><ul><li><p>时间复杂度因为会与被处理数据的分布有关，所以会有最好最坏和平均的说法</p></li><li><p><u>重要易错点：答题时注意除非说明，必须同时写上：<strong>最好、最坏、平均时间复杂度，少一个都不全面</strong></u></p></li></ul></blockquote><ul><li><p>算法运算量计算：不通用性</p><script type="math/tex; mode=display">规定标准操作 \Longrightarrow 找出在n个数据规模下执行标准操作的次数\Longrightarrow 得到运算量f(n)和规模n之间的关系</script></li><li><p>渐进时间复杂度：通用性</p><script type="math/tex; mode=display">\begin{aligned}&大O表示法：若存在两个正常数\space c、N_0，当\space N\ge N_0时，有\space T(N)\le cF(N)，则记\space T(N)=O(F(N))\\&大\Omega表示法：理解为与大O表示法相反的下限\\&大\Theta表示法：理解为上下界数量级相等的表示\\&小o表示法：理解为上下界不相等的\textbf{上界}表示\\\end{aligned}</script></li><li><p>知识补充：多项式时间算法$O(1)\lt O(log\space N)\lt O(N)\lt O(N\space log\space N)\lt O(N^c),\space c\in\mathbf{R}$</p><p>和指数时间算法：$O(2^N)\lt O(N!)\lt O(N^N)$（NP问题可以认为是非多项式时间算法能解决的问题）</p></li><li><p>渐进时间复杂度计算定理</p><script type="math/tex; mode=display">\begin{aligned}&1.\space 求和定理：\textbf{串行运行}时间\space T_1(n)+T_2(n)=O(max\{f(n),g(n)\})\\&2.\space 求积定理：\textbf{嵌套循环}的时间\space T_1(n)\times T_2(n)=O(f(n)\times g(n))\\&3.\space 推论：简单语句\space O(1)、分支语句相当于【条件串行分支的最大复杂度】、循环相当于【循环体嵌套循环次数】\end{aligned}</script></li></ul></li></ol><ol><li><p>空间复杂度：<strong>辅助存储空间 与 问题规模 间的关系</strong></p><blockquote><p><strong>易错点警示：</strong></p><p><strong>1. 链表的指针所占用的空间不算辅助空间</strong>：因为这是被处理的数据结构本身的空间；</p><p><strong>2. 递归调用的系统栈算辅助空间</strong>：讨论<strong>递归算法的空间复杂度</strong>一定要注意系统栈的情况！</p></blockquote></li></ol><h2 id="Chapter-2-线性表"><a href="#Chapter-2-线性表" class="headerlink" title="Chapter 2 线性表"></a>Chapter 2 线性表</h2><h3 id="2-1-零碎概念集合"><a href="#2-1-零碎概念集合" class="headerlink" title="2.1 零碎概念集合"></a>2.1 零碎概念集合</h3><ul><li><p>线性结构的定义：n（n ≥ 0）个结点的有穷序列 $(a_0, a_1,…,a_{n-1})$</p><blockquote><p>起始结点、终端结点、元素的序号/位置、直接前驱、直接后继、<strong>空表</strong>的定义</p></blockquote></li><li><p>线性表的地位：处理线性结构的工具；</p></li><li><p>线性表的基本运算种类：创清、增删查、访问遍历、求长；</p></li><li><p><a href="#ave">均摊分析������</a>；</p></li></ul><h3 id="2-2-顺序实现的线性表"><a href="#2-2-顺序实现的线性表" class="headerlink" title="2.2 顺序实现的线性表"></a>2.2 顺序实现的线性表</h3><ol><li><p>存储实现：数组是天然的线性结构（连续空间）<strong>【数组容量、数组指针、数组长度】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">seqList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* data;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doubleSpace</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">seqList</span>(<span class="type">int</span> capacity=<span class="number">10</span>);</span><br><span class="line">    ~<span class="built_in">seqList</span>() &#123; <span class="keyword">if</span> (data) <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; dt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> i, T&amp; x)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">visit</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>运算实现</p><ul><li><p>创建运算：开辟空间、设定表长和规模</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">seqList&lt;T&gt;::<span class="built_in">seqList</span>(<span class="type">int</span> capacity): <span class="built_in">length</span>(<span class="number">0</span>), <span class="built_in">maxSize</span>(capacity) &#123;</span><br><span class="line">    data = <span class="keyword">new</span> T[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>清空运算$\textbf{O(1)}$：直接将表长置0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;T&gt;::<span class="built_in">clear</span>() &#123; length = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure></li><li><p>判空运算$\textbf{O(1)}$：直接判断表长不为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> seqList&lt;T&gt;::<span class="built_in">isempty</span>() <span class="type">const</span> &#123; <span class="keyword">return</span> length == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure></li><li><p>插入运算$\textbf{O(1)}-\textbf{O(n)}-\textbf{O(n)}$：先看空间是否够，不够扩容，够依此向后移位；<strong>记得维护长度！！！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; dt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (length == maxSize) <span class="built_in">doubleSpace</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> idx = length - <span class="number">1</span>; idx &gt;= i; --idx) &#123;</span><br><span class="line">        data[idx + <span class="number">1</span>] = data[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    data[i] = dt; ++length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容运算$\textbf{O(n)}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;T&gt;::<span class="built_in">doubleSpace</span>() &#123;</span><br><span class="line">    T tmp = data;</span><br><span class="line">    data = <span class="keyword">new</span> T[maxSize * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        data[i] = tmp[i];</span><br><span class="line">    <span class="keyword">delete</span>[] tmp;</span><br><span class="line">    maxSize *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="ave"><strong>重点：<u>均摊法分析：每过n、2n、…的时机，可能会进行 O(n) 的扩容。均摊下来，平均时间复杂度还是相当于单次插入的 O(n)。</u></strong></span></p></li></ul></li></ol><ul><li><p>删除运算$\textbf{O(1)}-\textbf{O(n)}-\textbf{O(n)}$：先看是否为空，不空则后面元素向前覆盖，<strong>记得维护表长！！！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;T&gt;::<span class="built_in">remove</span>(<span class="type">int</span> i, T&amp; x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">    x = data[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> idx = i + <span class="number">1</span>; idx &lt; length; ++idx)</span><br><span class="line">        data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">    --length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问和遍历$\textbf{O(n)}$：无需多言</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T seqList&lt;T&gt;::<span class="built_in">visit</span>(<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> data[i]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;T&gt;::<span class="built_in">traverse</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找运算$\textbf{O(n)}$：”哨兵技巧“</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> seqList&lt;T&gt;::<span class="built_in">find</span>(<span class="type">const</span> T&amp; dt) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (data[i] == dt) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>易错点</p><ul><li>表长度值忘记维护；</li><li>混淆 length 和 maxSize 的意义；</li><li>检查异常处理；</li></ul></li></ol><h3 id="2-3-链接实现的线性表"><a href="#2-3-链接实现的线性表" class="headerlink" title="2.3 链接实现的线性表"></a>2.3 链接实现的线性表</h3><blockquote><ul><li>让每个结点保存相关的结点地址+本身数据，来保存结点之间的关系；</li><li>链接实现不仅可以用来表示线性结构，还能表示许多非线性结构，例如集合、树、图等；</li><li>避免了顺序表插入、删除的元素大规模移动；</li><li>动态存储；</li></ul></blockquote><ol><li><p>单链表</p><ul><li><p>存储实现：结点 = 数据+后继指针×1；<strong>【单链表头、单链表长（不必要）】</strong></p><blockquote><p>添加”头结点“以一般化一些特殊情况！</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SLinkedList</span> &#123;    <span class="comment">//0-index.</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sNode</span> &#123;</span><br><span class="line">        T data;</span><br><span class="line">        sNode* next;</span><br><span class="line">        <span class="built_in">sNode</span>() &#123; next = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="built_in">sNode</span>(T dt, sNode* n=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">data</span>(dt), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    sNode* head;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="comment">// （注：此法无需存在，用前后指针法也行）</span></span><br><span class="line">    <span class="function">sNode* <span class="title">move</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SLinkedList</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; dt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> i, T&amp; x)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">visit</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">travese</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ~<span class="built_in">SLinkedList</span>() &#123; <span class="keyword">if</span> (head) <span class="built_in">clear</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>运算实现（含有哑结点）</p><p>创建运算：赋头指针、置表长；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">SLinkedList&lt;T&gt;::<span class="built_in">SLinkedList</span>() &#123;</span><br><span class="line">    head = <span class="keyword">new</span> <span class="built_in">sNode</span>(); length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空运算$\textbf{O(n)}$：表长置0，循环释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SLinkedList&lt;T&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        sNode* tmp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求长、判空$\textbf{O(1)}$：略</p><p>(PRIVATE) 移动指针$\textbf{O(1)}-\textbf{O(n)}-\textbf{O(n)}$（注：此法无需存在，用前后指针法也行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">sNode* SLinkedList&lt;T&gt;::<span class="built_in">move</span>(<span class="type">int</span> i) <span class="type">const</span> &#123;</span><br><span class="line">    sNode* ans = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> idx = <span class="number">0</span>; idx &lt;= i &amp;&amp; idx &lt; length; ++idx)</span><br><span class="line">        ans = ans-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入运算（复杂度取决于移动指针）：移动指针至指定位置的直接前驱，插入，<strong>记得维护表长</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SLinkedList&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; dt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= length) <span class="keyword">return</span>;</span><br><span class="line">    sNode* cur = <span class="built_in">move</span>(i - <span class="number">1</span>);</span><br><span class="line">    cur-&gt;next = <span class="keyword">new</span> <span class="built_in">sNode</span>(dt, cur-&gt;next); ++length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除运算（复杂度取决于移动指针）：移动指针至指定位置的直接前驱，删除，<strong>记得维护表长</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SLinkedList&lt;T&gt;::<span class="built_in">remove</span>(<span class="type">int</span> i, T&amp; x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= length) <span class="keyword">return</span>;</span><br><span class="line">    sNode* cur = <span class="built_in">move</span>(i - <span class="number">1</span>);</span><br><span class="line">    sNode* tmp = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = tmp-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tmp; --length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问运算（……）：移动……，返回；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T SLinkedList&lt;T&gt;::<span class="built_in">visit</span>(<span class="type">int</span> i) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= length) <span class="keyword">return</span>;</span><br><span class="line">    sNode* cur = <span class="built_in">move</span>(i);</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找运算$\textbf{O(n)}$：同顺序表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SLinkedList&lt;T&gt;::<span class="built_in">find</span>(<span class="type">const</span> T&amp; dt) <span class="type">const</span> &#123;</span><br><span class="line">    sNode* cur = head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; cur; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data == dt) <span class="keyword">return</span> i;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历运算$\textbf{O(n)}$：同~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SLinkedList&lt;T&gt;::<span class="built_in">traverse</span>() <span class="type">const</span> &#123;</span><br><span class="line">    sNode* cur = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        std::cout &lt;&lt; cur-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>易错点</p><ol><li>循环条件设置不好，导致空指针的访问；</li><li>指针操作有误，导致内存泄漏（尤其是删除结点的时候）；</li><li>操作野指针；</li></ol></li></ul></li></ol><ul><li><p><strong><u>经典考试题（以至于不放在题型板块）：单链表的逆序，要求线性时间、常数空间</u></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SLinkedList&lt;T&gt;::<span class="built_in">reverse</span>() &#123;</span><br><span class="line">    sNode* tail = head-&gt;next, pre;</span><br><span class="line">    <span class="keyword">if</span> (!tail) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (pre = tail-&gt;next) &#123;</span><br><span class="line">        tail-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = tail;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>单循环链表：循环链表<strong>可以没有头结点，但一定要有头指针（指向首个结点，空表nullptr）</strong></p><p><strong>经典考题：约瑟夫环问题</strong></p></li><li><p>双向链表、双循环链表：了解前面的思路即可知道如何完成，重要程度较轻；</p><p><strong>双向链表引入头结点、尾结点两个哑结点；</strong></p></li></ol><h3 id="2-4-顺序表和链接表-的-对比与总结"><a href="#2-4-顺序表和链接表-的-对比与总结" class="headerlink" title="2.4 顺序表和链接表 的 对比与总结"></a>2.4 顺序表和链接表 的 对比与总结</h3><table>    <tr>        <th>顺序实现</th>        <th>链接实现</th>    </tr>    <tr>        <td>空间效率高</td>        <td>插入删除效率高</td>    </tr>    <tr>        <td>定位访问灵活</td>        <td>灵活动态存储</td>    </tr>    <tr>        <td>实现简单</td>        <td>整体调度较繁琐</td>    </tr>    <tr>        <td>可随机访问</td>        <td>仅支持顺序访问</td>    </tr></table><h2 id="EX-STL-库中的线性结构"><a href="#EX-STL-库中的线性结构" class="headerlink" title="EX - STL 库中的线性结构"></a>EX - STL 库中的线性结构</h2><ul><li>容器、迭代器的概念</li><li>list：类似链接实现，仅能通过迭代器访问；</li><li>vector：类似顺序实现，可以通过迭代器，也可通过下标访问；</li><li>deque：优化的线性容器，两端插入删除像list一样快，下标访问像vector一样方便；</li></ul>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data-Structure </tag>
            
            <tag> Linear-List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>草舍夜谈</title>
      <link href="//literary/novel-night-talk/"/>
      <url>//literary/novel-night-talk/</url>
      
        <content type="html"><![CDATA[<p><div class="novel"></p><p><p>  一轮弦月倒挂在夜空中，仿佛将这漆黑的幕布刺破一般，周围也晕出模糊的光影。零散的一两颗星点钉在空中，有一阵无一阵的发出微弱的亮光。天的那一边，厚重粘稠的黑色和森林的边缘相互交融，就像是要将地面上的一切全部吞噬殆尽。</p></p><p><p>  “咔哧咔哧……”深夜的树林根部本身就足够寂静，这时急促的步点就显得无比突兀。那是一个男子，身披着类似于斗篷一样的服饰，随着他上下跃动，发出“啪嗒啪嗒”的声响。他那两条腿好似不知疲倦的机械，轮番向下杵着，搅动着落叶发出清脆的声响。男子时不时地转头，用余光瞥向后方——除了两旁的树木不断向后隐入黑暗中，什么也没有。他竭力地抑制自己不像工厂中的热风机那样剧烈的抽动，可快速的气流冲击着气道，仍然发出一阵阵尖锐的哮鸣声。如果这时有一座庙宇，甚至是一个土坡，他也极其愿意停下来歇歇脚。</p></p><p><p>  前方的树木逐渐稀疏，一个矮小的草舍的轮廓逐渐清晰起来。真是想什么来什么。男子放慢脚步，蹑手蹑脚地走到那屋子跟前，环绕了一周。从窗外看去，内部只是隐隐约约摆放着几件家具，屋内似乎空无一人。他绕到虚掩着的木门前，进屋，关门，落闩，一气呵成。但当他转过身的一刹那，整个身体立刻僵住，即便是在黑暗中也能明显感觉到他面部因惊愕而扭曲的样子。</p></p><p><p>  微弱的月光透过窗户洒在桌上，桌旁的一个人影缓缓将手伸向跟前的汽油灯，瞬间，光线包围了整个屋子。屋内二人的面庞也清晰起来。门前的男子年纪约摸二十余岁，身上的服饰甚是滑稽——裤腿高高卷起，破布鞋和胫部的泥点依稀可见；深蓝色的工装外套绽开无数道口子，一根根粗线从开口处生长出来，披在身上与斗篷无异。汗水和污渍混在他的脸上，却也没能掩盖住浓郁的稚气。他深灰色的眼睛诉说着惊异和愤恨，直勾勾地盯着眼前的男人。眼前的男人样貌讲究：西装领带黑皮鞋，尖脸厚唇鹰钩鼻。就连头顶的棕发也是精心设计的卷曲——活脱脱一只崭新的木偶。</p></p><p><p>  木偶的嘴巴咧开了一条缝隙，“嘿，彼得，我们又见面了。没想到我会在这吧？”没等彼得说出一个字，他又似笑非笑地吐出一段话，仿佛是老师在质问他的学生。“你三番五次溜进厂长的图书室这件事咱先不提，”男人顺手挪来一个木椅，拍了拍灰尘才坐下，“上午你砸坏厂子里地机器，蛊惑其他工友动乱这事，你是知道后果的吧？”</p></p><p><p>  男人的疑问如同是石子丢进了大海，甚至没有惊起男青年的一丝波澜，得到的只是沉默。“你说你干什么不好，有这种力气，在生产线上多作劳动，我给你付出相应的工资，多么平等的交易！”他继续自己的讲演，就像是要用言辞撬开男青年的嘴，“为何要做出这种事？而且明知道我厂严查工人逃窜之事，竟然明知故犯，罪加一等！”“詹森你胡说！这根本就算不上平等的交易，这是赤裸裸的剥削！”震耳欲聋的吼声从男青年的喉咙中喷薄而出，震得汽油灯的焰心也为之颤动。</p></p><p><p>  “哦？”名为詹森的男人似乎对彼得的话有些兴致，右手托腮，笑得愈发的灿烂，“那你说说，这哪里有不平等，哪里有剥削呢？既然我的时间还很充足的话。”</p></p><p><p>  彼得似乎意识到自己之前的语气有些不妥，理了理自己褴褛的上衣，“首先，你们这群资本家狡猾得很，从一开始就将自己包装的很好，从我们生产的商品交换上就开始对我们工人进行剥削。”詹森挥了挥左手，示意他继续说下去。</p></p><p><p>  “无论是古典经济学派的亚当斯密，还是马克思，都认为劳动决定商品的价值，对吧？而马克思认为，组成商品的两个重要因素便是它的使用价值和本质的‘价值’。对于使用价值而言，就可以理解为物品的有用性。这是物品自身的固有属性，用来满足人们的物质或者是精神上的需求。我们知道，物质的属性和我们为了取得它所耗费的劳动的多少无关 。</p></p><p><p>  “但同时，商品交换中的另一个不能忽视的因素就是‘价值’。价值，不能以使用价值来代替，就像容积相同的一个木桶和一个铁桶，如果把它们装水的容积作为使用价值的话，他们的价格显然不同。马克思就提出，如果把商品的使用价值撇开，就是说，将产品的使用价值的物质组成也拿走，商品作为实际物质的属性就消失了。那么商品剩下的就只是‘劳动产品’的属性了，也就是无差别的、抽象的人类劳动。”</p></p><p><p>  “等等，小兄弟，”詹森捏了捏短小的胡子，以一种戏谑的眼光盯着站着的彼得，“你了解马尔萨斯的供求论吗？他就指出，商品价值的决定取决于市场供给和需求的关系。如果供过于求，那么商品的价值就越低，反之商品价值越高。”说着詹森的身体向后仰了仰，“此外，在19世纪70年代左右，学者们还提出了边际效用价值论，它指出商品的价值是人对于物品效用的感觉和评价。而商品价值应该由商品的边际效用决定，也就是每增加购买一个单位的商品对消费者而言，满足他的欲望的能力的变化量。”</p></p><p><p>  “就以亚当斯密曾提出的‘钻石与水的价值悖论’为例 ，就是因为水的体量之巨大，导致最后一单位的水所带来的边际效应微不足道；反观钻石虽然总效用不大，但是其边际效应极高，于是决定了钻石价格高、水价低是合理的！”詹森兴致高涨，张开双臂夸夸其谈，“效用——商品满足人们欲望的能力，结合商品的稀缺性，才是价值的源泉！可这两种理论中并没有强调劳动在形成商品价值时的作用啊？”</p></p><p><p>  彼得摇了摇头，没有直接回答詹森的问题，只是向着屋子一角踱步，“你说的有一部分我的确不否认，供求关系的确是对价格有影响，但这样在是用表象代替事物的本质。就比方说，你如何解释不同商品的价格实际上是围绕着不同的价格水平上下波动？一公斤木材的价格无论如何也不会高于一匹马的价格，这是因为价格围绕着价值上下波动，供求仅仅是驱动因素之一。”他停顿了一下，“对于商品效用和稀缺性决定商品价值的看法，我认为它描述了使用价值和价值之间的关系，但并不意味着二者可以完全决定价值。”</p></p><p><p>  “这……”詹森的笑容凝固在脸上，像是在思索着什么。</p></p><p><p>  “马克思则认为，除去使用价值和商品使用价值依赖的物质属性，商品的价值就体现在完全相同的东西上——相同的人类劳动、抽象的人类劳动。为了衡量抽象的劳动，马克思就借助了社会必要劳动时间来说明：‘社会必要劳动时间是在现有的社会正常生产条件下，在社会平均的劳动熟练度和劳动强度下制造某种使用价值所需要的劳动时间 ’，因此，商品价值在可以改变的很大一部分层面上，由社会的必要劳动时间决定。这不仅仅是商品的二重性，更是劳动的二重性！我深深为马克思发现的这个规律所折服，因为这个规律支配着私有制商品经济，从生产到分配的全过程！马克思为了说明隐藏在事物背后的商品价值，使用‘货币’作为最终的价值的表现形式。”</p></p><p><p>  彼得说罢，向詹森投出坚定的目光。此时轮到詹森沉默不语了，他没有看向彼得，只是皱起了精心修剪的八字眉，望向地板。屋内的空气再一次的凝固住，只能听见窗外的鸦在黑暗中喳喳地叫出声。良久，詹森喃喃道，“你这是从哪里了解到这……”“詹森先生，你之前不是答应我不提我溜进图书馆这件事吗？”彼得揶揄道。</p></p><p><p>  “所以现在站在资本主义的价值形成过程上来看，劳动者用具体的劳动改变了对象的物质形态，使这种物质产生了使用价值，并且把生产资料的价值转移到商品中去了 。与此同时，我之前提到，商品的第二个属性，本质‘价值’，也就是使用抽象劳动来衡量的价值，也转移到商品中去，形成商品的新的价值。”</p></p><p><p>  彼得长舒了一口气，仿佛是要为自己蓄力，“到目前为止，你们资本家对于我们无产阶级的剥削就显而易见了！如果商品这部分被劳动者创造的新的价值，等于资本家支付的劳动力价值——也就是你们给我们的工资，那么就不存在剩余的价值，资本价值增殖的目的就没有实现 。”</p></p><p><p>  “可是，如果你们资本家把我们工人的劳动时间延长到补偿我们的劳动力价值以上的水平，我们创造的价值就会超过你付给我们的工资所衡量的劳动力价值，这样资本价值就会增殖！在这增殖的价值中，除去我们必要的劳动时间——也就是我们生成劳动力价值所需的时间，其余的都是剩余劳动时间。而这些剩余劳动时间中，我们创造了剩余价值，却被你们这些资本家无偿占有，这不就是一种赤裸裸的剥削吗！”彼得说到最后，已经是接近歇斯底里的咆哮，通红的脖颈和凸起的青筋也印证着彼得内心中肆意燃烧的怒火。他挥舞着双拳，好似能够砸碎这令人恼怒的现实，“你们把我们从农田强制征召进你们的工厂，每天安排给我们超过14个小时的劳动，一旦休息就会有惩罚，甚至是未成年的孩子也不放过！而你们坐在自己的位置上对工人们指手画脚，你还有什么话可以狡辩！”</p></p><p><p>  一旁的詹森一脸被欠债的债主讨债的模样，只是放下了二郎腿，缓缓地站起来，以一种看似恭敬的姿态，双手将一个放在旁边的瓷杯递给彼得，“别急，先喝口茶。”彼得立刻夺过杯子，昂起头颅，一饮而尽。“年轻人，为何要如此气愤？如果觉得不满，大可以告诉主管的经理，让他为你协调你的工作时间不就可以了吗？这样做对我们都没有好处，你说呢？”詹森的语气此时更像是一种恳求。</p></p><p><p>  “哼！休想骗到我！”彼得并没有理睬詹森所谓的协商方法，自顾自地进行下去，“马克思曾在观察简单在生产时，发现资本主义的再生产是物质资料再生产和资本主义生产关系再生产的统一 ，在此基础上，如果资本主义需要扩大再生产，那么就会把剩余价值转换为资本进行不断地积累。也就是说，你们资本家的贪婪是永无止境的！一开始，你们资本家要么是暴力地剥夺农民土地，要么是通过殖民扩张来丰富资本的原始积累，同时获得像我们一样的劳动力。你们以为生产资料一类的财富会源源不断地进入你们地腰包，可是在资本不断积累、劳动不断社会化大生产的时候，资本主义基本矛盾会不断激化，你们终会自食自己种下的恶果，资本主义必将走向灭亡！”</p></p><p><p>  说着说着，彼得开始想象起自己和工友们反抗成功的场景。在彼得一群人起义成功的同时，其他地区的工人们相互呼应，纷纷突破了资本家的黑暗统治。革命的呼声震耳欲聋，工人们团结在一起，和唯利是图的邪恶势力英勇抗争，最后建立起了属于无产阶级的共和政体。彼得笑了，他欣慰地笑了。</p></p><p><p>  “都给我起来！工厂的人手不够，你们这帮囚犯更应该上去拼命！”彼得被这粗犷沙哑的声音惊醒。一睁眼，发现自己的面前赫然矗立着囚室的大铁门。自己是什么时候被抓进监狱的？彼得扶着昏沉的脑袋从地上坐起来，想要弄个明白。透过墙上的栅栏向外看，外面的残月和星屑早已消失不见，灰蒙蒙的天空正微微发亮。昨晚自己不是正在和詹森说着马克思的《资本论》吗？怎么忽然睡着了？难不成他在那杯茶里下了药？“说你呢！还在发呆！”门外工人的管理者粗暴地敲打着囚室的铁门，把彼得从思考中唤了回来。他知道，接下来等待着他的不是工长的谩骂和惩罚，就是没日没夜的疯狂劳动。彼得苦笑，在他幻想中的无产阶级的乌托邦何时才能建成？他站起身来，迈着沉重的步伐向囚室门口走去。</p>&lt;/div&gt;</p><style>div.novel p {font-size: 15px;line-height: 30px;margin: 0 0 25px;text-indent: 2em;}</style><blockquote><p>本人的原创短篇小说，欢迎交流！                                                    </p><p>参考文献<br>[1]《马克思恩格斯文集5 · 资本论》（人民出版社）第一卷 · 商品的两个因素，第四段<br>[2]王瑶.重新解读亚当·斯密的“钻石与水之谜”[J].中国社会科学院研究生院学报,2009(02):68-74.<br>[3]《马克思恩格斯文集5 · 资本论》（人民出版社）第一卷 · 商品的两个因素，第十二段<br>[4]张雷声.从异化劳动论到剩余价值论——马克思经济思想的科学变革[J].马克思主义研究,2022,No.261(03):1-8+155.<br>[5]林炜.理论·逻辑·方法:探索资本主义生产方式运动规律——以《资本论》第一卷为例[J].学理论,2022,No.827(05):41-44.<br>[6]李连波.2021年国内《资本论》研究进展与展望[J].当代经济研究,2022,No.324(08):16-25.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> literary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> essay </tag>
            
            <tag> novel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑日梦</title>
      <link href="//literary/essay-poem-2/"/>
      <url>//literary/essay-poem-2/</url>
      
        <content type="html"><![CDATA[<p><div class="poem"></p><p><p>弦月</p></p><p><p>钩破夜的浓稠的黑</p></p><p><p>光影晕开在闇色的幕布上</p></p><p><p>窗前的你</p></p><p><p>意识像夜空中的星辰</p></p><p><p>时隐时现</p><br><br/></p><p><p>思绪飘向远方</p></p><p><p>那里</p></p><p><p>没有好坏、优劣</p></p><p><p>没有收到、已阅</p></p><p><p>没有下决心、一定</p></p><p><p>没有请批准、恳请</p></p><p><p>有的是</p></p><p><p>吮吸知识的喜悦</p></p><p><p>沉溺自然的韵律</p></p><p><p>思想和思想的交融</p></p><p><p>创造和想象的跳跃</p></p><p><p>……</p><br><br/></p><p><p>一声鸦雀的惊唳</p></p><p><p>划破死水一样的寂静</p></p><p><p>你擦净嘴角的垂涎</p></p><p><p>在电脑上打出</p></p><p><p>“恳请您的过目，</p></p><p><p>一定完成任务”</p><br><br/><br>&lt;/div&gt;</p><style>div.poem p {line-height: 35px;font-size: 15px;}</style><p>薛宏伟<br>于2023年5月</p>]]></content>
      
      
      <categories>
          
          <category> literary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem </tag>
            
            <tag> essay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车站与乡思</title>
      <link href="//literary/essay-poem-1/"/>
      <url>//literary/essay-poem-1/</url>
      
        <content type="html"><![CDATA[<p><div class="poem"></p><p><p>地铁站里</p></p><p><p>促织的歌声</p></p><p><p>时远时近</p></p><p><p>仿佛从梦中飘来</p></p><p><p>携带着故乡的泥土的芳香</p></p><p><p>我在歌手的身边坐下</p></p><p><p>“晚上好，柴斯特”</p></p><p><p>你，是在歌唱</p></p><p><p>家乡小溪旁的树桩</p></p><p><p>稻田里的蛙声鼓响</p></p><p><p>还是</p></p><p><p>庭院里被困住的溶溶月光</p></p><p><p>充满着爱和温暖的那间瓦房？</p><br><br/></p><p><p>循着电动扶梯缓缓向上</p></p><p><p>寒风先于疲惫扑向我的脸庞</p></p><p><p>捡起地面上</p></p><p><p>乍绿还黄的梧桐叶</p></p><p><p>上面分明描绘着的</p></p><p><p>我的故乡</p><br><br/><br>&lt;/div&gt;</p><style>div.poem p {line-height: 35px;font-size: 15px;}</style><p>薛宏伟<br>于2023年4月</p>]]></content>
      
      
      <categories>
          
          <category> literary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem </tag>
            
            <tag> essay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发一个极简的Java网络爬虫</title>
      <link href="//technical/java-spider/"/>
      <url>//technical/java-spider/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本人最近在学习 Java 的基础用法时，开发了一个简易的爬取网站资源的 Java 程序；</p><p>预计的实现功能和特性：</p><ul><li>选择爬取没有设置反爬措施的网站，自定义爬取资源数量；</li><li>支持保存主流资源格式，详见Source code；</li><li>test 测试用例 分别是： <a href="https://www.baidu.com">https://www.baidu.com</a> 和 <a href="https://www.vcg.com/creative-image/fengjing/；">https://www.vcg.com/creative-image/fengjing/；</a></li></ul><span id="more"></span><h2 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// written by SJTU_XHW</span></span><br><span class="line"><span class="comment">// file: MiniCrawler.java</span></span><br><span class="line"><span class="keyword">package</span> priv.testNet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiniCrawler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String webURL;</span><br><span class="line">    <span class="keyword">private</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">support_regex</span> <span class="operator">=</span> <span class="string">&quot;.*.(js|css|xml|txt|mp4|mp3|avi|wmv|mpeg|mov|rmvb|flv|&quot;</span> +</span><br><span class="line">            <span class="string">&quot;jpeg|png|jpg|gif|ico|tif|tga|bmp|svg|eps|pdf|raw|psd)&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">URLPattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(//.+?)[()&gt;&lt;&#x27;\&quot;]&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">NotAllowedName</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;[:/*?&lt;&gt;()\&quot;\\\\]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MiniCrawler</span><span class="params">(String spec)</span> <span class="keyword">throws</span> MalformedURLException &#123;</span><br><span class="line">        webURL = spec; url = <span class="keyword">new</span> <span class="title class_">URL</span>(webURL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> URL <span class="title function_">getUrl</span><span class="params">()</span> &#123; <span class="keyword">return</span> url; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String spec)</span> <span class="keyword">throws</span> java.net.MalformedURLException &#123;</span><br><span class="line">        url = <span class="keyword">new</span> <span class="title class_">URL</span>(spec); webURL = spec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEx</span><span class="params">(java.lang.Exception ex, String src)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[ERROR] &quot;</span> + ex.getMessage());</span><br><span class="line">        System.out.printf(<span class="string">&quot;[ERROR] Failed to load %s\n&quot;</span>, src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">scanSubURL</span><span class="params">(ArrayList&lt;String&gt; urls, File htmlFile)</span></span><br><span class="line">            <span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">initScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(htmlFile)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (initScanner.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">pageLine</span> <span class="operator">=</span> initScanner.nextLine();</span><br><span class="line">                <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> URLPattern.matcher(pageLine);</span><br><span class="line">                <span class="keyword">while</span> (matcher.find()) &#123; urls.add(matcher.group()); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readHTML</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[INFO] Crawling: %s\n&quot;</span>, url.toString());</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(url.openStream())) &#123;</span><br><span class="line">            <span class="keyword">while</span> (input.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">pageLine</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">                count += pageLine.length();</span><br><span class="line">                System.out.println(pageLine);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException io_ex) &#123;</span><br><span class="line">            printEx(io_ex, String.format(<span class="string">&quot;URL: %s&quot;</span>, url.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[INFO] Finishing crawling bytes: %d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">downloadResource</span><span class="params">(URL url_, File file)</span> <span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (url_.toString().matches(<span class="string">&quot;api&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(url_.openStream());</span><br><span class="line">             <span class="type">BufferedOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(</span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file)</span><br><span class="line">             )) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((tmp = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                output.write(tmp);</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.FileNotFoundException file_ex) &#123;</span><br><span class="line">            <span class="comment">// printEx(file_ex, String.format(&quot;file: %s&quot;, file.toString()));</span></span><br><span class="line">            file.createNewFile(); <span class="keyword">return</span> downloadResource(url_, file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException io_ex) &#123;</span><br><span class="line">            printEx(io_ex, String.format(<span class="string">&quot;URL: %s&quot;</span>, url_));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">scanWebsite</span><span class="params">(<span class="type">int</span> maxNum, File saveDir)</span> <span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="type">long</span> <span class="variable">written_bytes</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;String&gt; urls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(maxNum);</span><br><span class="line">        urls.add(webURL);</span><br><span class="line">        <span class="keyword">while</span> (!urls.isEmpty() &amp;&amp; count &lt;= maxNum) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">curURL</span> <span class="operator">=</span> urls.remove(<span class="number">0</span>);</span><br><span class="line">            curURL = curURL.substring(<span class="number">0</span>, curURL.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!curURL.startsWith(<span class="string">&quot;http&quot;</span>)) curURL = <span class="string">&quot;http:&quot;</span> + curURL;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Download resources.</span></span><br><span class="line">            <span class="type">Matcher</span> <span class="variable">nameMatcher</span> <span class="operator">=</span> NotAllowedName.matcher(curURL);</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> nameMatcher.replaceAll(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!fileName.matches(support_regex)) fileName += <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">            <span class="type">File</span> <span class="variable">curWebFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveDir, fileName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[INFO] Downloading: %s\n&quot;</span>, curURL);</span><br><span class="line">                written_bytes += downloadResource(<span class="keyword">new</span> <span class="title class_">URL</span>(curURL), curWebFile);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException mex) &#123;</span><br><span class="line">                printEx(mex, String.format(<span class="string">&quot;file: %s&quot;</span>, fileName));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!fileName.endsWith(<span class="string">&quot;.html&quot;</span>)) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Scanning.</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;[INFO] Scanning: %s\n&quot;</span>, curURL);</span><br><span class="line">            <span class="keyword">try</span> &#123; scanSubURL(urls, curWebFile); &#125;</span><br><span class="line">            <span class="keyword">catch</span> (java.io.IOException ex) &#123; printEx(ex, String.format(<span class="string">&quot;URL: %s&quot;</span>, curURL)); &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[INFO] Finished. Total: %d websites, %d bytes.\n&quot;</span>, count, written_bytes);</span><br><span class="line">        <span class="keyword">return</span> written_bytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: testCrawler.java</span></span><br><span class="line"><span class="comment">// written by SJTU_XHW</span></span><br><span class="line"><span class="keyword">package</span> priv.testNet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testCrawler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException, IOException &#123;</span><br><span class="line">        <span class="type">MiniCrawler</span> <span class="variable">crawler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MiniCrawler</span>(<span class="string">&quot;http://127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">File</span> <span class="variable">saveDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Please type in the saving directory &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;(ENTER without type = lastDir(initially &#x27;.&#x27;), quit = &#x27;Q&#x27;, test = &#x27;T&#x27;): &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (scanner.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">dir</span> <span class="operator">=</span> scanner.next(); <span class="keyword">if</span> (dir.equals(<span class="string">&quot;Q&quot;</span>)) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (dir.equals(<span class="string">&quot;T&quot;</span>)) &#123; test(); <span class="keyword">continue</span>; &#125;</span><br><span class="line">                saveDir = <span class="keyword">new</span> <span class="title class_">File</span>(dir);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;Please type in the website&#x27;s URL: &quot;</span>);</span><br><span class="line">            crawler.setUrl(scanner.next());</span><br><span class="line">            System.out.print(<span class="string">&quot;Please type in the maximum number of the scanning pages: &quot;</span>);</span><br><span class="line">            crawler.scanWebsite(scanner.nextInt(), saveDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">MiniCrawler</span> <span class="variable">crawler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MiniCrawler</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;[INFO] init URL: %s%n&quot;</span>, crawler.getUrl());</span><br><span class="line">        <span class="type">File</span> <span class="variable">saveDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.\\test\\&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!saveDir.exists()) saveDir.mkdir();</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">saveFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveDir, <span class="string">&quot;baidu.html&quot;</span>);</span><br><span class="line">        singlePage(crawler, saveFile);</span><br><span class="line"></span><br><span class="line">        crawler.setUrl(<span class="string">&quot;https://www.vcg.com/creative-image/fengjing/&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;[INFO] init URL: %s%n&quot;</span>, crawler.getUrl());</span><br><span class="line">        crawler.scanWebsite(<span class="number">100</span>, saveDir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">singlePage</span><span class="params">(MiniCrawler crawler, File saveFile)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MiniCrawler.downloadResource(crawler.getUrl(), saveFile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[ERROR] &quot;</span> + ex.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;[ERROR] Failed to create the file.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>以上的程序已分别打包为二进制包（jar）：<a href="./testCrawler.jar">🔗testCrawler.jar</a>、Windows可执行文件（exe）：<a href="./testCrawler.exe">🔗testCrawler.exe</a></p><p>Windows双击运行即可尝试；</p><p>其他平台须下载 JRE（version ≥ 1.7）并配置好Java环境变量后，再执行：<code>java -jar testCralwer.jar</code>；</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本人小白，如有技术问题或Bug，欢迎交流！</p><p>【WARINING】本样例很可能会停止维护⚠</p><p><u><strong>万万没想到的是，以上的代码还不如<code>wget</code>功能强大，大家可以在安装了<code>wget</code>的系统上执行：</strong></u></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c -r -np -k -L -p &lt;URl&gt;</span><br></pre></td></tr></table></figure><p><strong>一行搞定爬取！</strong>只能说GNU还是非常优秀的……</p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Java </tag>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 学习笔记（1）</title>
      <link href="//technical/java-basic/"/>
      <url>//technical/java-basic/</url>
      
        <content type="html"><![CDATA[<p><i>Attention: 本文建立在具有一定 C++基础知识的前提上</i></p><p><i>Reference: Introduction to Java Programming 10th Edition (Y. Daniel Liang)</i></p><p><u>郑重声明：本文原创，资料引用已在原文相应位置进行标注，感谢为我们无偿提供知识和技术指导的创作者们，转载请注明</u></p><hr><span id="more"></span><h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><h3 id="解释型语言和编译型语言的区别"><a href="#解释型语言和编译型语言的区别" class="headerlink" title="解释型语言和编译型语言的区别"></a>解释型语言和编译型语言的区别</h3><h4 id="编译型语言（以C-为例）的编译运行过程"><a href="#编译型语言（以C-为例）的编译运行过程" class="headerlink" title="编译型语言（以C++为例）的编译运行过程"></a>编译型语言（以C++为例）的编译运行过程</h4><ol><li>预编译（*.c/cpp &amp; *.h —&gt; *.i ）：<strong>对应gcc/g++命令：<code>gcc -E [xxx] -o [output.i]</code></strong><ul><li>展开所有宏定义#define（字符替换）；</li><li>处理所有条件预编译命令（#ifdef、#ifndef、#endif等）；</li><li>处理#include，具体操作是将指向的文件直接插入到文件的这一行（严格遵循上一步的条件）；</li><li>删除所有注释；</li><li>添加行号、文件标识，以便调试/编译出错时及时指出；</li><li>保留#pragma指令，以供编译器使用；</li></ul></li><li>编译（*.i —&gt; *.s ，即高级语言转汇编语言）：<strong>对应gcc/g++命令：<code>gcc -S [xxx] -o [output.s]</code></strong><ul><li>词法分析、语法分析、语义分析（前端）；</li><li>生成中间代码、优化，生成目标代码（解释型语言无需做此步，生成中间代码后直接对语义执行）；</li><li>编译原理入门：<a href="https://www.cnblogs.com/fisherss/p/13905395.html">https://www.cnblogs.com/fisherss/p/13905395.html</a></li></ul></li><li>汇编（*.s —&gt; *.o/obj，即汇编语言转机器语言）：<strong>对应gcc/g++命令：<code>gcc -c [xxx] -o [output.o/obj]</code></strong><ul><li>类Unix系统下生成*.o，Windows系统下生成*.obj；</li></ul></li><li>链接（*.o —&gt; *.out/exe，链接各种需要的库和其他目标文件）：<strong>对应gcc/g++命令：<code>gcc [xxx] -o [output]</code></strong></li><li>生成调试文件（供gdb使用，<strong>对应gcc/g++命令：<code>gcc [xxx] -g -o [output]</code></strong>）<ul><li>也支持<code>-o</code>参数：<code>-O</code>（默认）、<code>-O1</code>（尝试减少代码体积和代码运行时间，但是并不执行会花费大量时间的优化操作）、<code>-O2</code>（包含 -O1的优化并增加了不需要在目标文件大小和执行速度上进行折衷的优化，会花费更多的编译时间当然也会生成性能更好的代码）、<code>-O3</code></li></ul></li></ol><h4 id="解释型语言的运行过程"><a href="#解释型语言的运行过程" class="headerlink" title="解释型语言的运行过程"></a>解释型语言的运行过程</h4><p>前端分析“三件套” + 生成中间代码 + 解释器解释执行</p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="./CompileAndExplain.png"></p><blockquote><p>注：字节码是低级语言</p></blockquote><h4 id="可惜Java是“半解释型语言”！"><a href="#可惜Java是“半解释型语言”！" class="headerlink" title="可惜Java是“半解释型语言”！"></a>可惜Java是“半解释型语言”！</h4><blockquote><p>Java程序既要<strong>编译</strong>为class文件，同时class文件也要经过JVM的<strong>解释运行</strong></p><p><strong>刚入门暂时略过此处有难度的部分，详细参考黑皮书《深入了解Java虚拟机》</strong></p><p>Java虚拟机是一种解释器，是解释Java字节码（*.class）的一种程序，</p><p>简单解释过程：运行<strong>类加载器</strong>将字节码加载到内存中 —-&gt; 运行<strong>字节码验证器</strong>强制检查Java程序合法性和安全性，不符合安全规范的不予运行 —-&gt; 读取内存中的字节码逐句解释为机器码执行；</p></blockquote><ol><li><p>Java源文件编译（*.java -&gt; *.class）：<code>javac [*.java]</code></p></li><li><p>Java字节码解释运行：<code>java [className]</code></p><blockquote><p>Attention: 如果填className=”myclass.class”，那么解释器会去找<code>myclass.class.class</code>！所以搞清类名；</p><p>字节码运行提醒：</p><ul><li>Java指令默认寻找class文件通过环境变量<code>CLASSPATH</code>指定目录进行，大部分情况下当前目录不在其中，通常需要在其中添加条目<code>.;</code></li><li>Java对class文件执行强依赖于package路径。运行时严格按照<code>pwd</code>+文件中的包名+类名搜索class文件；</li><li>一般大项目没有这么运行的，因为依赖的源文件较多，建议使用IDE、Maven（管理Java库*.jar（二进制）的存储、分发）等工具；别问为什么没有CMake一样管理编译的工具，也别问为什么C++没有库管理工具（C++是头文件+*.dll/so/a/lib，一般靠官网下载）；</li></ul><p>如果类在包中，举例：<code>priv.hello.myPackage</code>（源码的包导入声明也这么写的），包存在<code>/home/xxx/src/</code>下，那么需要：</p><ul><li><code>CLASSPATH</code>中存在当前目录（可以按照上面所说添加<code>.;</code>）；</li><li>当前命令行位于src（即包名+类名整体的上一级）；</li></ul><p>此时不能写<code>java myclass</code>（包路径缺失）、不能写<code>java myclass.class</code>（后缀重复）；</p><p>此时正确写法是：<code>java priv.hello.myPackage.myclass</code></p></blockquote></li><li><p>Java的变量存储机制：既然已经充分了解C++，那么敞开天窗说亮话——</p><ul><li><p><strong>Java 中绝大多数对象都包装的比C++好，不需要指针（也没有），创建对象（new）时，由 JVM 在堆中自动分配动态空间，GC也一般不需要编写者关心。所以绝大多数情况下，接触到的类型对象都是“引用”类型，和Python很像</strong></p><blockquote><p>这种“引用”是可以更改的引用，<strong>和C++的“引用类型”不同</strong>，此后不再赘述</p></blockquote></li><li><p>方法调用及存储、方法中的局部变量等都存放于栈中；</p></li></ul></li></ol><h3 id="操作系统认知"><a href="#操作系统认知" class="headerlink" title="操作系统认知"></a>操作系统认知</h3><ul><li>控制、监视系统活动：识别输入、发送输出、跟踪文件动态、控制外部设备</li><li>分配系统资源：确定某一程序需要哪些计算机资源</li><li>调度：多道程序设计（multiprogramming）、多线程、并行处理</li></ul><h3 id="Java-认知"><a href="#Java-认知" class="headerlink" title="Java 认知"></a>Java 认知</h3><ul><li><p>常用于开发：Web应用程序、服务端应用程序、安卓应用程序等</p></li><li><p>Java版本：JavaSE（标准版，其他所有版本基础，重点）、JavaEE（企业版）、JavaME（微型版）</p><blockquote><p>目前以 JavaSE 8为例，对应的开发工具包为JDK（全部可以基于命令行），也可使用主流IDE进行编写</p></blockquote></li></ul><h2 id="Java-基本语法"><a href="#Java-基本语法" class="headerlink" title="Java 基本语法"></a>Java 基本语法</h2><h3 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h3><ol><li><p>每个Java程序都至少应该有一个class，<strong>通常大写开头</strong>（区分大小写）、驼峰命名；</p><blockquote><p><strong>Java 的 public类名必须和当前的java类文件（*.java）同名！！！</strong></p><p>这意味着一个*.java类文件中只能定义一个同名、public的类</p></blockquote></li><li><p>Java程序必须有主方法<code>main</code>、语句以分号结尾（同C++）；</p></li><li><p>Java注释方法、程序块的大括号划分同C++；</p></li><li><p>在单一的项目内，哪怕源文件很少，也建议将源文件放入“package”（实质是目录）中来组织项目；</p><ul><li><p>目的：防止同名，限制作用域；增强可读性；提升封装性；</p></li><li><p>命名：所有字符必须是小写字母，不得有特殊字符；</p></li><li><p>可以有多层；包导入的时候，每层由“.”隔开；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com一般约定俗称是公司开发的，还可以是team，或者indi（个人项目）、onem（单人项目）、pers（个人发起的项目，有其他人合作）、priv（私有项目）；这里指示包位于：项目根目录/com/hello/myPackage 中。</span></span><br><span class="line"><span class="keyword">package</span> com.hello.myPackage;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>和C++一样，有次行风格和行尾风格两种规范，各有优点，不建议混用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不良风格示范</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;<span class="comment">// 次行风格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">// 行尾风格</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基本程序设计（与C-相同部分省略）：基础与数据类型"><a href="#基本程序设计（与C-相同部分省略）：基础与数据类型" class="headerlink" title="基本程序设计（与C++相同部分省略）：基础与数据类型"></a>基本程序设计（与C++相同部分省略）：基础与数据类型</h3><h4 id="包引入、包声明"><a href="#包引入、包声明" class="headerlink" title="包引入、包声明"></a>包引入、包声明</h4><ul><li><code>import java.util.Scanner(库名);</code></li><li><code>package priv.hello.myPackage(包);</code></li><li>所有Java程序中，自动隐式导入包<code>java.lang</code>，内含<code>System</code>类、<code>Math</code>类等，无需手动添加；</li></ul><h4 id="变量命名规范、声明、定义"><a href="#变量命名规范、声明、定义" class="headerlink" title="变量命名规范、声明、定义"></a>变量命名规范、声明、定义</h4><h4 id="命名常量的定义（C-中的常量const）"><a href="#命名常量的定义（C-中的常量const）" class="headerlink" title="命名常量的定义（C++中的常量const）"></a>命名常量的定义（C++中的常量const）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// final &lt;TYPE&gt; &lt;NAME&gt; = &lt;VAL&gt;;</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159265358979</span>;</span><br></pre></td></tr></table></figure><p>等价于C++中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159265358979</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：Java的常量和C++的不同！Java常量允许仅定义，后来可以赋一次值，但C++要求常量的定义和初始化必须在一起，如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> PI;</span><br><span class="line">PI = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="comment">// 不允许第二次赋值：</span></span><br><span class="line"><span class="comment">// PI = 0;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// 不允许：</span></span><br><span class="line"><span class="comment">// const double PI;</span></span><br><span class="line"><span class="comment">// PI = 3.14;</span></span><br></pre></td></tr></table></figure><h4 id="赋值语句、赋值表达式"><a href="#赋值语句、赋值表达式" class="headerlink" title="赋值语句、赋值表达式"></a>赋值语句、赋值表达式</h4><blockquote><p>注：Java中字符串和Python一样，允许直接相加，并且存在整型—-&gt;字符串的自动类型转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span> + a + <span class="string">&quot;Java!&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><h4 id="标准输入输出（初认识）"><a href="#标准输入输出（初认识）" class="headerlink" title="标准输入输出（初认识）"></a>标准输入输出（初认识）</h4><blockquote><p>Java 使用 System.in、System.out （类）作为标准输入输出；</p><p>可惜不支持控制台直接输入，需要引入包：<code>java.util.Scanner</code>，也可通配符导入：<code>import java.util.*;</code></p><p>其中含有<code>Scanner</code>类，初始化一个实例对象，以便使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> input.nextDouble();</span><br></pre></td></tr></table></figure><p>输入不是double，或者不能自动类型转换为double时，抛出异常；</p><p>除了double以外，还接受：byte、short、int、long、float等类型，有对应的方法；</p></blockquote><ul><li>输入输出命令行重定向（类似大部分Linux命令可重定向）<ul><li><code>java [className] &lt; input.txt</code>（输入卡）</li><li><code>java [className] &gt; output.txt</code></li><li><code>java [className] &lt; input.txt &gt; output.txt</code></li></ul></li></ul><h4 id="数据类型入门"><a href="#数据类型入门" class="headerlink" title="数据类型入门"></a>数据类型入门</h4><ol><li><strong>byte</strong>：8 bit（1Byte）含符号整型（$-2^72^7-1$）;</li><li>short：16 bit（2Bytes）含符号整型；</li><li>int：32bit（4Bytes）；</li><li>long：64bit（8Bytes）；</li><li>float：32bit（4Bytes）；</li><li>double：64bit（8Bytes）；</li><li><strong>boolean</strong>：官方文档表示大小没有严格规定，有时作为int，有时作为byte，可以将其看作“最窄类型”；</li><li>char：16bit（<strong>2Bytes</strong>）；</li><li>String（java.lang类），详细内容以后叙述</li></ol><p><strong>注意：还有一点和C++类似——数值型直接量</strong>（literal），书写方法与C++相似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xFFFF</span>;</span><br><span class="line"><span class="number">2147483648L</span>;</span><br><span class="line"><span class="number">0.3F</span>/<span class="number">1.0</span>;</span><br><span class="line"><span class="number">100.2d</span>;</span><br><span class="line"><span class="number">1.23E-2</span>;</span><br><span class="line"><span class="comment">// 为提高可读性，Java中允许在数字间加入下划线，但必须置于两个数间：</span></span><br><span class="line"><span class="number">2324_4545_4519_3415L</span>;</span><br></pre></td></tr></table></figure><h4 id="数值运算符、增强赋值操作符、自加自减运算符、逻辑运算符（绝大部分与C-相同）"><a href="#数值运算符、增强赋值操作符、自加自减运算符、逻辑运算符（绝大部分与C-相同）" class="headerlink" title="数值运算符、增强赋值操作符、自加自减运算符、逻辑运算符（绝大部分与C++相同）"></a>数值运算符、增强赋值操作符、自加自减运算符、逻辑运算符（绝大部分与C++相同）</h4><blockquote><p>注：Java中有API接口库 Math，，包含方法pow进行幂运算，更多方法自行探索：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">4</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure></blockquote><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><h4 id="强制（显式）类型转换、自动类型转换，及其原则（和C-有所不同）"><a href="#强制（显式）类型转换、自动类型转换，及其原则（和C-有所不同）" class="headerlink" title="强制（显式）类型转换、自动类型转换，及其原则（和C++有所不同）"></a>强制（显式）类型转换、自动类型转换，及其原则（和C++有所不同）</h4><ol><li>支持的自动类型转换：绝大多数是宽类型=&gt;缩窄类型/同等宽窄类型<ul><li>char &lt;=&gt; int &lt;=&gt; short &lt;=&gt; byte；</li><li>double =&gt; float（反过来不行，double也不能到其他整型类型）；</li><li>boolean最窄，不支持绝大多数自动类型转换，甚至强制类型转换也不行；</li><li><strong>int/double +(operator) String =&gt; String </strong>，只有使用“+”运算符才可将数值型自动类型转换为String，也可以用专用转换函数；</li></ul></li><li>支持的强制类型转换<ul><li>char、int、short、byte、double、float间均可；</li></ul></li></ol><blockquote><p>警告：Java中不允许缩窄类型不显式指明进行初始化/类型转换（<strong>这样导致很多与C++操作不同之处，例如没法直接<code>if（&lt;int&gt;）</code>来判断整型的真假</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 不允许：</span></span><br><span class="line"><span class="comment">// float x = 1.12;</span></span><br><span class="line"><span class="comment">// byte y = x;</span></span><br><span class="line"><span class="comment">// if (x) &#123; System.out.println(x); &#125;</span></span><br><span class="line"><span class="comment">// 正确写法：</span></span><br><span class="line"><span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1.12f</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">byte</span>)x;</span><br><span class="line"><span class="keyword">if</span> (x != <span class="number">0</span>) &#123; System.out.println(x); &#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="常见错误：与C-相同"><a href="#常见错误：与C-相同" class="headerlink" title="常见错误：与C++相同"></a>常见错误：与C++相同</h4><blockquote><p>使用未声明/定义/初始化的变量、整型溢出、取整错误等；</p></blockquote><h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><ol><li><p>时间工具</p><blockquote><p>Java System类中提供<code>currentTimeMillis()</code>方法，返回从1970年1月1日 00:00:00（UNIX首次发布时间，又称UNIX时间戳-UNIX epoch）至今经历的毫秒数；</p></blockquote></li><li><p>Math类</p><p>Java Math类中提供相当多的数学支持：</p><ul><li><code>[0.0, 1.0)</code>间的均匀伪随机分布数：<code>Math.random()</code>；</li><li>sin、cos、tan、asin、acos、atan（均以弧度为单位）、toRadians、toDegrees；</li><li>exp、log、log10、pow、sqrt；</li><li>ceil（向上取整）、floor（向下取整）、rint（最接近的整数）、round（四舍五入，相当于<code>floor(x + 0.5)</code>）;</li><li>max、min、abs；</li></ul></li></ol><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ul><li>通过IDE界面调试（图形化）；</li><li>命令行调试：<code>jdb</code>程序（类似C++的<code>gdb</code>）;</li></ul><h3 id="基本程序设计：字符与字符串与格式化输出"><a href="#基本程序设计：字符与字符串与格式化输出" class="headerlink" title="基本程序设计：字符与字符串与格式化输出"></a>基本程序设计：字符与字符串与格式化输出</h3><ol><li>字符 char（2Bytes）</li></ol><blockquote><p>遵循和C++一样的内码规则（ASCII），允许比较、参与数值计算、合并打印等；</p></blockquote><ol><li>字符串类 String（java.lang包中的<strong>引用类型（和C++的引用是否相同？以后讨论）</strong>）</li></ol><blockquote><p>常用操作方法：</p><p><code>length()</code>、<code>charAt(index)</code>（和其他语言的at索引一样，越界会抛出异常）、<code>indexOf()/lastIndexOf()</code>、<code>toUpperCase()/toLowerCase()</code></p><p><code>concat(other_str)</code>：拼接字符串，返回新值（建议用“+”/“+=”，更方便）；</p><p><code>substring(begin, end)</code>：取子串；</p><p><code>trim()</code>：去掉两边空白字符，类似Python的<code>strip()</code>；</p><p>常用比较方法：</p><p><code>equals(other_str)</code>（仅看内容是否相等的话，<strong>和C++一样，不能用==操作符！</strong>因为String是引用类型，只能说明地址是否一致）、<code>equalsIgnoreCase(...)</code>、<code>compareTo(...)</code>（返回第一个不同的位置上的字符之差）、<code>startWith(prefix)</code>、<code>endWith(suffix)</code>、<code>contains(...)</code></p><p>常用转换方法：</p><p>除了之前介绍的“+”operator，还可以用内置包<code>java.lang</code>的类<code>Integer</code></p><p>、<code>Double</code>中的<code>Integer.parseInt(...)</code>、<code>Double.parseDouble(...)</code></p><p>字符串和输入输出：Scanner类中的实例方法<code>next()</code>专门捕获字符串，遇到空白字符停止（空白字符定义同C++，包括space、制表符、换行符等），<strong>不从缓冲区拿走空白字符</strong>；</p><p>还有<code>nextLine()</code>，不过遇到回车键停止，和C++一样，注意中间的联用问题；</p></blockquote><ol><li>格式化输出：<code>System.out.printf(&lt;pattern&gt; [args])</code></li></ol><blockquote><p>格式标记符与Python完全相同（例如%d、%4.2f、%s、%%等，唯一一种不同的是%c、%Nc，同时%后、数字前加负号表示<strong>左对齐</strong>），只不过不需要“%”外部标记；</p></blockquote><h3 id="基本程序设计：条件与分支"><a href="#基本程序设计：条件与分支" class="headerlink" title="基本程序设计：条件与分支"></a>基本程序设计：条件与分支</h3><h4 id="比较操作符、条件表达式和三目运算符"><a href="#比较操作符、条件表达式和三目运算符" class="headerlink" title="比较操作符、条件表达式和三目运算符"></a>比较操作符、条件表达式和三目运算符</h4><blockquote><p>由于Java中不允许缩窄类型不显式指明进行初始化/类型转换，只有boolean类型</p></blockquote><h4 id="if-else-if-else语句"><a href="#if-else-if-else语句" class="headerlink" title="if - [else if] - else语句"></a>if - [else if] - else语句</h4><h4 id="switch-case-default-语句"><a href="#switch-case-default-语句" class="headerlink" title="switch - case - [default]语句"></a>switch - case - [default]语句</h4><blockquote><p>和C++类似，只有特定数据类型才能作为switch的变量：byte、char、short、int、String等；</p></blockquote><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><blockquote><p>忘记必要的大括号、测试浮点数的相等性等；</p></blockquote><h3 id="基本程序设计：循环（全部与C-相同😂）"><a href="#基本程序设计：循环（全部与C-相同😂）" class="headerlink" title="基本程序设计：循环（全部与C++相同😂）"></a>基本程序设计：循环（全部与C++相同😂）</h3><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><h4 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h4><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><h4 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h4><blockquote><p>同样，不应该使用浮点数作为条件</p></blockquote><h3 id="基本程序设计：方法"><a href="#基本程序设计：方法" class="headerlink" title="基本程序设计：方法"></a>基本程序设计：方法</h3><blockquote><p>由于Java的函数全都包裹在类中，所以将Java的函数都称作<strong>方法</strong>！</p></blockquote><p><strong>Java不允许分支控件有部分没有返回值，会抛出编译错误。但C++只会编译警告（如果经过没有返回值的分支，则返回一个没有初始化为0/空的对应类型的对象）</strong></p><ol><li><p>定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数列表） &#123;</span><br><span class="line">    方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法签名：方法名+参数列表；</p></li><li><p>调用堆栈结构：同C++</p></li><li><p>方法重载：注意的点也同C++，注意歧义调用（可以自动类型转换的值）</p></li><li><p><strong>可惜的是，目前为止Java所有方法的参数传递都是值传递</strong></p></li><li><p><strong>更可惜的是，Java的方法参数不能指定默认值，只能使用重载实现类似效果</strong></p></li></ol><h3 id="基本程序设计：一维数组"><a href="#基本程序设计：一维数组" class="headerlink" title="基本程序设计：一维数组"></a>基本程序设计：一维数组</h3><blockquote><p>请记住，Java中没有指针，一切数组对象都是引用，其类型名为：<code>elemType[]</code></p></blockquote><ol><li><p>定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elemType[] arrayName;    <span class="comment">// 此处arrayName是引用类型变量</span></span><br><span class="line"><span class="comment">// 可以使用C++风格定义</span></span><br><span class="line">elemType arrayName[];    <span class="comment">// arrayName仍然是引用类型</span></span><br></pre></td></tr></table></figure></li><li><p>new操作符创建（<strong>和C++不同，只有new操作符才会给数组对象引用分配空间，所以说，new是对象新建的关键字</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">elemType[] arrayName = <span class="keyword">new</span> <span class="title class_">elemType</span>[size];    <span class="comment">// 这里的new仅仅是新的意思，arrayName仍然是对新对象的引用；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点：数组引用变量在没有指向具体存储空间（仅定义）是，内容是null；</span></span><br><span class="line">elemType[] arrayName2;    <span class="comment">// 此时arrayName2是null</span></span><br><span class="line">elemType[] arrayName3 = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">0</span>];     <span class="comment">// 但arrayName3不是null，只是一个长度为0的空数组，也占用空间；</span></span><br></pre></td></tr></table></figure></li><li><p>和C++不一样，一维数组是包装好的<strong>引用类型</strong>，<strong>存在长度属性</strong>：<code>arrayName.length</code>，存在<strong>自动赋初值（0）</strong>；</p></li><li><p>元素的访问：<code>arrayName[index]</code>；</p></li><li><p>赋初值（初始化语法）</p><ul><li><p>使用new操作符；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>[] array = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) array[i] = i;</span><br></pre></td></tr></table></figure></li><li><p>普通赋值（<strong>不得将定义和初始化过程分开！因为普通定义不会为数组分配空间</strong>）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,...&#125;;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>对比C++的数组/指针处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>* arr = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">10</span>];    <span class="comment">// 可以后边接上赋初值</span></span><br><span class="line"><span class="type">double</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;        <span class="comment">// 中括号中的元素个数可以省略</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>特殊的一维数组：char[]</p><blockquote><p>和C++不一样，char数组末尾<strong>不用加 ‘\\0’ 字符</strong>、<strong>支持直接标准输出打印</strong>；</p></blockquote><p><code>char[] city = &#123;&#39;D&#39;, &#39;a&#39;, &#39;l&#39;, &#39;l&#39;, &#39;a&#39;, &#39;s&#39;&#125;;</code></p></li><li><p>遍历：和C++11标准一样，允许foreach循环</p><p><code>for (double x: arrayName) &#123;...&#125;</code></p></li><li><p>复制：记住，Java中的数组对象也是引用类型，和Python一样，和C++不一样；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...(前面已定义并为list1、list2赋值)</span></span><br><span class="line"><span class="comment">// 这样的做法会让list1引用指向list2的空间，</span></span><br><span class="line"><span class="comment">// list1原来空间会被 JVM 自动回收（GC机制）</span></span><br><span class="line"><span class="comment">// list1 = list2;</span></span><br></pre></td></tr></table></figure><p>正确的方法有3种：</p><ul><li><p>循环语句复制；</p></li><li><p><code>System</code>类中的“静态方法”（是什么以后介绍）<code>arraycopy()</code>；</p><blockquote><p>该方法使用前请确保目标数组已经分配好空间！</p></blockquote></li><li><p>clone方法复制，以后介绍；</p></li></ul></li><li><p>数组作为参数传递 / 作为返回值</p><blockquote><p>Java中对数组的参数传递方式，和C++一样，都是引用传递；</p><p><strong>同时也允许数组类型作为返回值，也是引用传递（和C++只能返回指针又不一样）</strong></p><p>因为Java中的类申请空间在堆中，且有GC机制，故不存在不能返回引用类型的说法；</p></blockquote></li><li><p>和Python<code>*args</code>类似的可变参数列表</p><blockquote><ul><li><p>C++中没有此类功能；</p></li><li><p>和Python一样，可变参数需要放在普通形参后面</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">double</span>... argList)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数定义：elemType... paramName</span></span><br><span class="line"><span class="comment">// 其中的argList会作为double一维数组处理</span></span><br></pre></td></tr></table></figure></li><li><p>常用数组操作工具：位于<code>java.util.Arrays</code>类中</p><ul><li><code>sort() / parallelSort()</code>：排序与并行排序（多处理器有用）；</li><li><code>binarySearch()</code>：要求查找前<strong>升序排好</strong>、未查找到返回某一个负数：<code>-（该元素应该处于的位置下标+1）</code>；</li><li><code>equals(...)</code>、<code>fill(...)（以某种方式填充）</code>；</li><li><code>toString(...)</code>：转换的数组对应字符串含有comma、中括号；</li></ul><blockquote><p>小结：目前用到了哪些java的包？</p><p><code>java.util.Scanner</code>、<code>java.util.Arrays</code></p><p><code>java.lang.Double</code>、<code>java.lang.Integer</code>、<code>java.lang.Math</code>、<code>java.lang.String</code>、<code>java.lang.System</code></p></blockquote></li><li><p>main命令行参数</p><blockquote><p>由于传入String一维数组引用类型，和C++的指针数组不一样，所以不需要<code>int argc</code>；</p></blockquote><p>和C++不一样的是，<code>main</code>函数和普通函数一样，可以在其他类中随意调用；</p><p><strong>重要提示：Java程序的命令行和C++不同，输入*符号相当于目录通配符，想要表达乘法*的意思，使用双引号括起表示字符串</strong></p></li></ol><h3 id="基本程序设计：多维数组"><a href="#基本程序设计：多维数组" class="headerlink" title="基本程序设计：多维数组"></a>基本程序设计：多维数组</h3><blockquote><p>二维数组为例，</p><p>Java中的二维数组比C++中开放，<strong>允许每行的数组长度不一样</strong>，但需要单独创建；</p><p>可以将每行看作一个独立的数组引用，可能具有不同的length参数值，自身的length就是行数；</p><p>更高维数组同理；</p></blockquote><ol><li><p>定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elemType[][] arrayName;</span><br></pre></td></tr></table></figure></li><li><p>创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 至少指定rowNum，如果没有指定colNum，那么只为每一行的“指针分配空间，总体数组还是null组成的数组”，需要每行去new</span></span><br><span class="line"><span class="type">double</span>[][] arrayName = <span class="keyword">new</span> <span class="title class_">double</span>[rowNum][[colNum]];</span><br><span class="line"><span class="comment">// arrayName[i] = new double[j]; ...</span></span><br><span class="line"><span class="comment">// 或者普通创建：</span></span><br><span class="line"><span class="type">double</span>[][] raggedArray = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基本程序设计：面向对象初步"><a href="#基本程序设计：面向对象初步" class="headerlink" title="基本程序设计：面向对象初步"></a>基本程序设计：面向对象初步</h3><blockquote><p>Java 中所有的类都是引用类型、对象都是引用类型变量；</p><p>注意：Java的类结尾无需以分号结束类的声明；</p></blockquote><ol><li><p>统一建模语言（UML）和UML类图</p><ul><li>类和对象框图的画法；</li><li>“-”：私有修饰符；“+”：公共修饰符；“#”：保护修饰符；</li><li>下划线：静态成员（静态变量+静态方法）；</li><li>属性：<code>attrName: type</code>；</li><li>方法：<code>method(params: type): returnType</code>；</li></ul></li><li><p>主类：包含main方法的类是主类；一个*.java 文件中至多只能含有一个主类、公有类（public，含义见“Java的类可见性修饰符”）；</p><blockquote><p>每个类（哪怕不是主类）会在编译时生成对应的*.class文件；</p><p><strong>一个*.java文件中，可以没有主类：像C++的面向对象一样，只是为了描述一个类、供外部调用而创建</strong></p><p>类所书写的文件名必须和类的公有类<strong>同名</strong></p></blockquote></li><li><p>类的构造函数（在使用new操作符时被调用）和默认构造函数（同C++）</p><blockquote><p>别问为什么没有析构函数，问就是Java包装太好了，以致于编程人员几乎不涉及GC的处理；</p></blockquote></li><li><p>引用属性（引用数据域）和 Java 的 null 值 和 属性的默认值</p><blockquote><p>Java 的“引用”和C++不同，可以修改指向对象，因此可以作为类的属性；</p><p>Java 中引用类型中有直接量<code>null</code>，就像boolean数值类型有直接量<code>true</code>、<code>false</code>;</p><p><strong>和C++一样，建议一定义对象就进行初始化/赋值操作</strong></p></blockquote><ul><li>数值类型的默认值为0、false等；</li><li>引用类型的默认值为null（直接使用会抛出<code>NullPointerException</code>异常）；</li></ul></li><li><p>匿名对象：创建后不需要引用的对象，可以不用赋给引用类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Area is: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>).getArea());</span><br></pre></td></tr></table></figure></li><li><p>类的静态变量（C++中的静态数据成员、Python中的类属性）、静态常量、静态方法；</p><ul><li>声明方法与C++相同、实际的储存方法和C++也相同（与Python不同，因为整个类中共享静态数据域）；</li></ul><blockquote><p>提示1：静态常量应该在类内定义：<code>final static &lt;TYPE&gt; name = value;</code></p><p>提示2（其他编程语言一样）：调用静态属性/方法时，建议使用类名+方法名/属性，因为能够提高可读性，帮助其他维护者迅速找到静态成员；</p><p>提示3：由于Java的类的使用特殊性，类的静态变量也在类中直接初始化（C++不允许，需要类外声明赋值）；</p></blockquote></li><li><p>Java的类可见性修饰符</p><ul><li><code>private、protected、public</code>：含义与C++完全相同，但使用方法不同（Java只能声明在属性/方法一行前）；</li><li><strong>注意：Java若没有声明可见性修饰符，默认的可见范围是：<code>package-private</code>，即在所有同一个包中的所有位置都能被访问，哪怕类不同（C++默认private）</strong></li></ul><blockquote><p>Java中的包能对类本身的”可见性“进行约束（进一步实现对类的组织），可能类似C++的命名空间；</p><p>每个文件前可以声明类所处的包，表示将该类放入该包中；如果不指定，则会放入默认包中（不建议这样，因为可能会造成一些混乱）；</p></blockquote></li><li><p>类的访问器和修改器：Java中的类的封装</p><blockquote><p>这里与Python的属性装饰器中的@set、@get思路有些类似；</p></blockquote></li><li><p>对象作为方法参数传递：与前面的”数组作为方法参数传递“完全相同；</p></li><li><p>对象数组：储存引用的数组；</p></li><li><p>不可变类和不可变对象（和Python思路相似）</p><blockquote><p>不可变类的定义：一个类满足如下三个条件：</p><ul><li>所有数据域都是私有的；</li><li>没有修改器方法；</li><li>没有”返回值是指向可变数据域的引用”的访问器方法；</li></ul><p><strong>因此如果有一个类数据域都私有、没有修改器方法，但有一个方法：返回内部一个可变数据域的引用（例如数组），则这个类也是可变类</strong></p></blockquote></li><li><p>Java类中的“this”</p><ul><li><p>只可惜Java中没有指针，所以this是一个引用（使用场景和存在位置都和C++类似）；</p></li><li><p><strong>Java中和C++在这个部分中实现较大的差别是：“委托构造函数”</strong>，C++的委托构造函数有专门的语法；但Java的“委托构造函数”只能使用this实现：<code>this(...)</code>；</p><blockquote><p>其实C++中也可以使用这种方法；另外C++用这种方法可以实现“后部分的委托构造”；</p></blockquote></li></ul></li><li><p>变量作用域：和C++一样的理解；</p><blockquote><p>别问为什么和C++介绍的位置不一样（C++一般在介绍函数之后就介绍，但Java在类的知识中介绍），因为Java几乎所有的操作都在类里面；</p></blockquote></li><li><p>使用 Java 内置类型（常见）</p><ul><li><p><code>java.util.Date</code> 类：提供与系统无关的对时间、日期的封装（不是<code>java.System.currentTimeMillis()</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                    java.util.Date</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">+Date()                     // 为当前时间创建一个Date对象</span><br><span class="line">+Date(elapseTime: long)        // 从GMT 1970.1.1至今以毫秒计算的时间创建Date对象</span><br><span class="line"></span><br><span class="line">+toString(): String</span><br><span class="line">+getTime(): long            // 返回GMT 1970.1.1至今的毫秒数</span><br><span class="line">+setTime(elapseTime: long): void</span><br></pre></td></tr></table></figure></li><li><p><code>java.util.Random</code> 类：提供各种数据类型下的伪随机数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                    java.util.Random</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">+Random()                    // 以当前时间为时间种子创建一个Random对象</span><br><span class="line">+Random(seed: long)</span><br><span class="line"></span><br><span class="line">+nextInt(): int</span><br><span class="line">+nextInt(n: int): int        // 返回一个0~n间（不包含n）的随机int值</span><br><span class="line">// 类似还有nextDouble、nextLong、nextFloat、nextBoolean等</span><br></pre></td></tr></table></figure><blockquote><p>提示（其他编程语言一样）：可以指定相同种子、生成相同的伪随机序列，这种能力在软件测试中非常有用；</p></blockquote></li><li><p><code>javafx.geometry.Point2D</code>类：请自行探索；</p></li><li><p>Java的基本数据类型包装为对象（<code>java.lang.xxx</code>，可以是Double、Integer、Byte、Character、Boolean、Float、Short、Long）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, srcT&gt;</span><br><span class="line">                        java.lang.T</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">-value: srcT</span><br><span class="line">+MAX_VALUE: srcT (static)</span><br><span class="line">+MIN_VALUE: srcT (static)</span><br><span class="line">-----------------------------</span><br><span class="line">+T(value: srcT)</span><br><span class="line">+T(s: String)</span><br><span class="line">+otherSrcTValue(): otherT</span><br><span class="line">+toString(): String</span><br><span class="line">+valueOf(s: String): T (static)</span><br><span class="line">// radix: 基数</span><br><span class="line">+valueOf(s: String, radix: int): T (static)</span><br><span class="line">+parseSrcT(s: String): srcT (static)</span><br><span class="line">+parseSrcT(s: String, radix: int): srcT (static)</span><br></pre></td></tr></table></figure></li><li><p>Java内置高精度运算：<code>java.math.BigDecimal/BigInteger</code></p><blockquote><p>内部自定义运算名称（add、multiple等），可以与String转换（“”+~可以转为String）</p><p>注意<code>divide</code>：高精度数除不尽时可能触发<code>ArithmaticException</code>，需要明确给定保留小数位和舍入方式：<code>a.divide(b, 20, BigDecimal.ROUND_UP)</code></p></blockquote></li></ul></li></ol><h3 id="基本程序设计：面向对象思想和应用"><a href="#基本程序设计：面向对象思想和应用" class="headerlink" title="基本程序设计：面向对象思想和应用"></a>基本程序设计：面向对象思想和应用</h3><ol><li><p>重载：Java不支持运算符重载；</p></li><li><p>封装</p></li><li><p>关联、组合</p><ul><li><p>类的关联关系：两个类之间有特定的活动联系；</p><blockquote><p>最简单的例子是：教师类和同学类的关系（教师教授一些课程类、学生学习一些课程类，而且学生与课程、教师与课程间有数量关系限制）；</p><p>关联的实现方法：两个类使用同类数据域、相关方法；</p><p>这里的数量限制又称<strong>类的多重性</strong>；</p></blockquote><p>补充UML类图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// [near]m..n[far]: far类需要与m~n（包含）个near类建立关联</span><br><span class="line">// *: far类可以与任意个数个near类建立关联</span><br><span class="line">// x: far类必须与x个near类建立关联</span><br><span class="line">// relation ▶: 类的抽象关系</span><br><span class="line"></span><br><span class="line">             take ▶                  ◀ teach</span><br><span class="line">        3..50      *            0..3            1</span><br><span class="line">student --------------- course ------------------ teacher</span><br></pre></td></tr></table></figure></li><li><p>类的聚集和组合</p><blockquote><p>聚集：两个类之间具有归属关系（<code>has-a</code>），一个该类的对象可以被其他多个聚集类的对象所归属；</p><p>组合：如果一个类的对象仅被一个聚集类的对象所归属，则称这两个类的聚集关系为组合；</p><p>最典型的例子是：学生-ID-班级类的关系，ID对象唯一地被学生对象所归属，班级对象可以与多个学生进行聚集；</p></blockquote><p>补充UML类图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// [near]◆[far]: far和near组合，其中near是owner；（◇代表聚集）</span><br><span class="line"></span><br><span class="line">   1            1            5..60       1</span><br><span class="line">ID -------------◆ student ◇-------------- Class</span><br></pre></td></tr></table></figure></li></ul></li><li><p>继承</p><blockquote><p>UML类图中以指向父类的三角箭头来表示两个类间的继承关系；</p></blockquote><ul><li><p>继承的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[qualifiers] <span class="keyword">class</span> <span class="title class_">subClassName</span> <span class="keyword">extends</span> <span class="title class_">superClassName</span> &#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>能够继承的部分：父类所有数据域和方法；但能够访问的数据域和方法只有public（依可见性修饰符而定，同C++）——即子类包裹父类，比父类具有更多信息；</p></li><li><p>Java 中的单一继承和多重继承：<strong>和C++和Python不一样：Java不允许多重继承，仅允许单一继承，即一个Java类只能直接继承自一个父类，不能继承于多个父类；</strong></p></li><li><p>Java 的 super 关键字：<strong>和C++不同、和Python类似，Java使用<code>super</code>关键字调用父类构造方法</strong></p><blockquote><p>C++：子类构造函数自动调用父类构造函数；</p><p>Java：想要调用父类构造函数（一般情况下都需要，否则不需要继承了），必须使用super关键字，且要写在子类构造函数的最前面（不写的话编译器会添加默认的<code>super()</code>，如果父类恰好没有默认构造函数，则抛出异常）；</p><p>Python 和 Java 类似，只不过是魔法方法<code>__init__()</code>，是初始化方法而非构造函数（Python甚至比Java还要少一个考虑空间分配的问题）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>():</span><br><span class="line"><span class="built_in">super</span>().__init__(...)</span><br><span class="line">    <span class="comment"># Statement</span></span><br></pre></td></tr></table></figure><p><strong>这些语言构造父类属性时，依此调用父类构造函数的过程称为“构造方法链”</strong></p><p>Java 允许通过 super 关键字调用父类public/protected方法：<code>super.methodName(...)</code></p></blockquote></li><li><p>Java的公共基类：<code>java.lang.Object</code>（Java所有类继承于Object类）</p><blockquote><p>与C++不同，C++没有公共基类的说法；</p><p>和Python2类似，Python2的旧式类的定义就是说明具有公共基类Object；</p><p><code>java.lang.Object</code>的重要公有方法：</p><ul><li><p><code>toString()</code>返回类名+@+内存地址构成的十六进制数字符串，可以在Object的所有子类中重写这个方法，类似Python的魔法方法：<code>__str__()</code>；</p></li><li><p><code>equals(object x)</code>：返回两对象引用是否指向同一内存地址，可以在子类中重载来完成仅对内容相同的判断；</p><p><strong>易错：重写equals的时候，不能改变参数类型！！！</strong></p></li></ul></blockquote></li><li><p>方法重写（override）：和C++一样，仅覆盖子类可见的方法；</p><blockquote><p>a. 静态方法不能被覆盖，只会被隐藏；</p><p>b. 可以通过<code>super</code>关键字调用<strong>直接父类</strong>的被覆盖的方法！！！</p><p>c. 建议添加重写标注<code>@Override</code>，<strong>意义和作用与C++的<code>override</code>后置关键字完全相同</strong></p></blockquote></li><li><p>UML类图的书写</p><ul><li>子类指向父类的实线+空心三角箭头；</li><li>子类可省略父类中的同签名的方法；</li></ul></li></ul></li><li><p>多态</p><blockquote><p>请回想C++的多态实现：基类指针+虚函数（作用是让基类指针调用虚函数时检查子类有没有重写情况，有则调用重写的方法，从而实现多态）；</p><p>Java 中没有指针，那么说明Java中的父类引用可以指向子类来充当“基类指针”（<strong>声明类型和实际类型可以不一致的特性</strong>）、Java的重写直接代替“虚函数”的说法；</p><p><strong>总结：为什么Java中没有C++的虚函数说法、C++没有Java的super关键字，却都能实现对应功能（例如多态）？</strong></p><ul><li>C++默认基类指针访问非虚函数时，只能访问基类对应的方法，只有加<code>virtual</code>关键字才能实现真正检查、覆盖；</li><li>相较于Java，Java默认指向子类对象的父类引用<strong>直接可以访问子类的重写方法（即直接覆盖——这里体现Java的引用调用重写方法时完全由实际类型决定，这称为“动态绑定”，C++使用虚函数关键字实现基类指针对该方法的“动态绑定”）</strong>，但想要访问父类的被覆盖方法，需要加上super关键字指明调用父类；</li></ul><p>（tips. Python和Java的多态实现是一样的思路）</p></blockquote></li><li><p>父类-子类类型转换 和 自定义类型转换</p><ul><li><p>子类 —-&gt; 父类：直接转换，因为子类实例总是父类的实例；</p></li><li><p>父类 —-&gt; 子类：一般不支持！而且 Java不支持自定义类型转换函数！</p><blockquote><p>只有父类引用指向子类对象时才可以使用，且需要显式类型转换，而且转换前要检查是不是真的可以：<code>instanceof</code>关键字（<code>&lt;obj&gt; instanceof &lt;class&gt; -&gt; boolean</code>）</p></blockquote></li><li><p>Java 不支持自定义类型转换函数；</p></li></ul></li><li><p>阻止类扩展和重写</p><ul><li>Java 在类前的修饰符<code>final</code>表示：该类不能作为父类（禁止扩展）；</li><li>Java 在方法前的修饰符<code>final</code>表示：该方法不能被重写（与C++ 11的<code>final</code>后置关键字含义相同）；</li></ul></li><li><p>字符串类（<code>java.lang.String</code>）的进一步分析</p><ul><li><p>创建方法及其含义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串有两种创建方式：</span></span><br><span class="line"><span class="comment">// 常量赋值法：</span></span><br><span class="line"><span class="comment">// 原理（和C++一样）：在常量存储区创建常量字符串&quot;12345&quot;，并将引用对象str指向该字符串；</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="comment">// 创建对象法（普通变量使用）：</span></span><br><span class="line"><span class="comment">// 原理：在堆中创建一个字符串（也是常量，不过是动态分配的空间），并将str指向该量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;12345&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>String是一种不可变数据类型 &amp;&amp; String的限定字符串</p><blockquote><p>原理见上；</p><p>限定字符串的工作和Python一模一样。如果是使用常量赋值法定义的两个字符串值相同，那么这两个字符串引用对象共用一个字符串数据内容，称为“限定字符串”</p></blockquote></li><li><p>转换为char array：<code>String.toCharArray()</code></p></li><li><p>格式匹配：<code>replace、replaceAll、replaceFirst、split、matches、equals</code>（ 全部支持正则表达式）；</p></li><li><p>格式化生成字符串：<code>format()</code>，类似printf的作用，将不同参数的变量转化为字符串；</p></li><li><p>可修改的String区域（和C++的string、char array很像）：<code>java.lang.StringBuilder/StringBuffer</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                        java.lang.StringBuilder</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">+StringBuilder()</span><br><span class="line">+StringBuilder(capacity: int)</span><br><span class="line">+StringBuilder(s: String)</span><br><span class="line"></span><br><span class="line">// 以下操作会直接修改原数据</span><br><span class="line">+append(...): StringBuilder</span><br><span class="line">+delete(indexes...): StringBuilder</span><br><span class="line">+insert(...): StringBuilder</span><br><span class="line">+replace(...): StringBuilder</span><br><span class="line">+reverse(): StringBuilder</span><br><span class="line">+setCharAt(...): void</span><br><span class="line"></span><br><span class="line">+toString(): String</span><br><span class="line">+capacity(): int</span><br><span class="line">+charAt(index: int): char</span><br><span class="line">+length(): int</span><br><span class="line">+setLength(newLength: int): void</span><br><span class="line">+substring(...): String</span><br><span class="line">+trimToSize(): void // shrink</span><br></pre></td></tr></table></figure><blockquote><p><code>StringBuffer</code>和<code>StringBuilder</code>的使用方法相同，区别是前者支持并发操作，后者仅支持普通操作，但性能更好；</p></blockquote></li><li><p>字符串池：Java 的 String 类会维护一个独立的字符串常量池（JDK7以后，存在于堆内存中）</p><blockquote><p>Java 维护静态变量、常量的方法与C++不同，将常量池和静态变量存在于堆区，因为不用编写者考虑内存分配问题；</p><p>C++对于静态局部变量、静态数据成员、全局变量都存在于<strong>全局数据区</strong>，独立于栈区和堆区；</p></blockquote><ul><li><p>常量池存储的是引用！！！</p></li><li><p>代码中的字符串常量（“…”，类似于C++中说的常量表达式constexpr）在运行时直接加载到常量池中（用new创建就不会）；</p></li><li><p>控制局部变量（存于栈帧中）转到常量池：<code>str2 = str1.intern();</code></p><blockquote><p>如果<code>str1</code>是个局部变量（即：其指向的字符串存在于栈帧中）或者是手动new分配的String，等<strong>一切：指向数据不在字符串常量池中的<code>str1</code></strong>，那么在运行上面一句后，Java会在常量池中加入一个引用（赋给<code>str2</code>），指向<code>str1</code>所指向的数据；</p><p>否则，<code>str2</code>直接指向<code>str1</code>所指向的数据；</p></blockquote></li></ul></li></ul></li></ol><h3 id="基本程序设计：泛型类"><a href="#基本程序设计：泛型类" class="headerlink" title="基本程序设计：泛型类"></a>基本程序设计：泛型类</h3><ol><li><p>定义方法：直接在类名后加类型参数即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">stack</span>&lt;E&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>Java的泛型类运行效率极差，且仅支持引用类型E，比C++的模板类慢很多，不建议应用此方法；</strong></p></li><li><p>实例：<code>ArrayList</code>类</p><blockquote><p><code>ArrayList</code>类可以动态分配列表大小，无需关系容量问题，类似 C++ STL <strong>线性表容器</strong>；</p><p><strong>很遗憾！Java 的泛型类仅支持引用对象，而非基本数据类型作为类型参数！</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">java.util.ArrayList&lt;E&gt;</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">+ArrayList()        // 线性数据结构（线性表，甚至杂糅一些集合结构的内容在其中）</span><br><span class="line"></span><br><span class="line">+clear(): void                    // 清</span><br><span class="line">+add(obj: E): void                // 增</span><br><span class="line">+add(index: int, obj: E): void</span><br><span class="line">+remove(obj: Object): boolean    // 删</span><br><span class="line">+remove(index: int): E</span><br><span class="line">+contains(obj: Object): boolean    // 查</span><br><span class="line">+get(index: int): E</span><br><span class="line">+indexOf(obj: Object): int</span><br><span class="line">+lastIndexOf(obj: Object): int</span><br><span class="line">+set(index: int, obj: E): E        // 改</span><br><span class="line">+isEmpty(): boolean                // 判空</span><br><span class="line">+size(): int</span><br><span class="line"></span><br><span class="line">+toString(): String</span><br></pre></td></tr></table></figure><ul><li><p>从对象数组创建ArrayList：<code>java.util.Array.asList(object[] arr(是引用)) -&gt; 数组数据</code></p></li><li><p>从ArrayList复制普通数组：<code>ArrayListObj.toArray(object[] arr)</code>，要求arr已分配空间；</p></li><li><p>支持<code>ArrayList</code>的Java库：<code>java.util.Collections</code></p><blockquote><p>max / min、shuffle、sort方法等；</p></blockquote></li></ul></li></ol><h3 id="基本程序设计：异常处理"><a href="#基本程序设计：异常处理" class="headerlink" title="基本程序设计：异常处理"></a>基本程序设计：异常处理</h3><ol><li><p>抛出异常：例如：<code>throw new</code>）</p></li><li><p>try-catch 块：与C++相同；</p></li><li><p>Java 中的异常类</p><p><img src="./JavaError_and_Exception.png"></p></li></ol><blockquote><p>图中的几个重要概念：</p><ul><li><p>异常基类<code>Throwable</code>和常用异常类<code>Exception</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                        java.lang.Throwable</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">+getMessage(): String</span><br><span class="line">+toString(): String</span><br><span class="line"></span><br><span class="line">+printStackTrace(): void</span><br><span class="line"></span><br><span class="line">+getStackTrace(): StackTraceElement[]</span><br></pre></td></tr></table></figure><p><strong><code>Exception</code>类继承自<code>Throwable</code>，以上方法都具有，故省略：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                        java.lang.Exception</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">+Exception()</span><br><span class="line">+Exception(message: String)</span><br></pre></td></tr></table></figure></li><li><p>系统错误<code>system error</code>：Java虚拟机抛出的异常，内部系统有错误，遇到后必须立即终止程序不能有补救，只能有善后；</p><p>LinkageError：依赖库已修改，不兼容当前代码；</p><p>VirtualMachineError：Java虚拟机崩溃，或者运行时所需资源耗尽；</p></li><li><p>异常<code>exception</code>：可以被捕获和处理的异常</p><p>ClassNotFoundException：<code>java</code>命令运行的类无法找到；</p><p>IOException：包括子类<code>InterruptedIOException</code>、<code>EOFException</code>、<code>FileNotFoundException</code>等；</p></li><li><p>运行时异常（异常的子集）<code>runtime exception</code>；</p></li></ul></blockquote><ol><li><p>Java 异常处理机制</p><ul><li><p>声明异常（关键字<code>throws</code>）：任何方法必须尾置声明可能抛出的异常（<code>RuntimeException</code>、<code>Error</code>及其子类除外，如<code>IOException</code>、自定义类就就必须声明，除非当场使用try-catch捕获）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> IOException [, ...] &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>抛出异常（关键字<code>throw</code>）<code>throw ExceptionObj;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&#x27;...&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>捕获异常（try-catch-finally）：语法几乎与C++相同、<code>finally</code>关键字用法同Python（即使前面有return也会进行）；</p><blockquote><p>JDK 7 多捕获特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">catch</span> (exception1 | exception2 | ...) &#123; ... &#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>使用须知</p><ul><li>没有被捕获的异常会导致程序中断；</li><li>由于异常调用栈回溯繁琐，会耗费更多资源，故不应过度使用异常；</li><li>必要时重新抛出异常、设计链式异常；</li></ul></li><li><p>自定义异常类：建议基于<code>Exception</code>类做扩展（其UML类图见上）；</p></li></ol><h3 id="基本程序设计：Java的抽象类和接口"><a href="#基本程序设计：Java的抽象类和接口" class="headerlink" title="基本程序设计：Java的抽象类和接口"></a>基本程序设计：Java的抽象类和接口</h3><blockquote><p>提示：看源码的时候，关键字<code>native</code>表示这个方法不是用Java写的，但是基于JVM平台实现的；</p></blockquote><ol><li><p>抽象类的定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[qualifiers] <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">className</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象方法</p><ul><li>定义：<code>[qualifiers] abstract &lt;returnType&gt; funcName(params);</code></li><li>类似C++的纯虚函数；</li></ul></li><li><p>抽象类的构造函数</p><ul><li><p>和C++一样，逻辑上抽象类不需要定义构造函数，但如果执意要定义，那么需要声明为protected类型（C++也一样，思考为什么）；</p><blockquote><p>注意：Java 在子类中不能像C++一样自动调用父类的构造函数，所以抽象类的子类和普通类的子类一样，都需要显式super调用父类的构造函数；</p></blockquote></li></ul></li><li><p>抽象类/方法的UML类图表示：文字以 <strong><i>斜体</i></strong> 表示；</p></li><li><p>注意事项</p><ul><li><p>和C++一样，Java不允许实例化抽象类；</p></li><li><p>包含抽象方法的类一定要是抽象类；</p></li><li>与C++不同，Java因为会抽象声明的原因，其抽象类可以没有抽象方法，但建议有；</li><li>Java 的一个具体类的子类可以是抽象类（例如Object是具体类，而我们能够定义抽象子类）；</li><li>抽象方法一定不是静态的；</li></ul></li><li><p>抽象类的一些实例</p><ul><li><code>java.lang.Number</code>：Double、Float、Long、Integer、Short、Byte、BigInteger、BigDecimal都是其子类；</li><li><code>java.util.Calendar</code>：其他类型的历法方式是其子类；</li></ul></li><li><p>接口的定义和使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">[qualifiers] <span class="keyword">interface</span> <span class="title class_">InterfaceName</span> &#123;&#125;    <span class="comment">// 允许泛型接口！</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">[qualifiers] <span class="keyword">class</span> <span class="title class_">className</span> [extend ...] <span class="keyword">implements</span> <span class="title class_">InterfaceName</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>接口 的 注意事项</p><ul><li><p>和抽象类一样抽象：描述一群类的共同行为 / 常量数据，类似Python的“协议”（如上下文管理协议、序列协议等）；</p></li><li><p>仅包含常量、抽象方法：数据域全是<code>public static final</code>，方法全是<code>public abstract</code>，故<strong>接口定义中允许省略所有修饰符</strong>；</p><blockquote><p>C++ 的“接口”一般用抽象类实现就行，因为C++允许多继承；</p></blockquote></li><li><p><strong>接口允许继承：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">interfaceName</span> extend I1 [, ...] &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>类允许接口的多重扩展：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">className</span> <span class="keyword">implements</span> <span class="title class_">i1</span> [, ...] &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>UML类图：虚线+空心三角形+<code>&lt;&lt;interface&gt;&gt;</code></p></li></ul></li><li><p>接口的一些实例</p><ul><li><code>java.lang.Comparable</code>：只有一个方法<code>compareTo(E obj);</code></li><li><code>java.lang.Cloneable</code>：空接口（标记接口），标记有此接口的对象可以重写<code>Object.clone</code>以完成功能的实现；</li></ul></li></ol><h3 id="基本程序设计：文本-I-O-和网络-I-O"><a href="#基本程序设计：文本-I-O-和网络-I-O" class="headerlink" title="基本程序设计：文本 I/O 和网络 I/O"></a>基本程序设计：文本 I/O 和网络 I/O</h3><ol><li><p><code>File</code>类：<strong>此类初始化后并没有真正打开对象（占用资源）！不需要释放</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">                        java.io.File</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">+File(pathName: String)</span><br><span class="line">+File(parentDir: String, childPath: String)</span><br><span class="line">+File(parentDir: File, childPath: String)</span><br><span class="line"></span><br><span class="line">// 谓词函数，默认返回值为boolean，省略</span><br><span class="line">+exists()</span><br><span class="line">+canRead()</span><br><span class="line">+canWrite()</span><br><span class="line">+isDirectory()</span><br><span class="line">+isFile()</span><br><span class="line">+isAbsolute()    // File 对象的path数据是否是绝对路径</span><br><span class="line">+isHidden()        // Windows中的隐藏属性，Unix中文件前的“.”</span><br><span class="line"></span><br><span class="line">+getAbsolutePath(): String</span><br><span class="line">+getCanonicalPath(): String        // 将path数据转换为标准的绝对路径（没有简写）</span><br><span class="line">+getName(): String                // 相当于Python的os.path.basename(...)+后缀</span><br><span class="line">+getParent(): String            // 相当于Python的os.path.dirname(...)</span><br><span class="line">+lastModified(): long            // 文件最后修改时间（从Unix时间开始的毫秒数）</span><br><span class="line">+length(): long                    // 文件大小（如果File对象指向目录或不存在，为0）</span><br><span class="line">+listFile(): File[]                // 相当于Python的os.listdir()</span><br><span class="line"></span><br><span class="line">+delete(): boolean                // 删除File对象指向的文件/目录</span><br><span class="line">+renameTo(dst: File): boolean</span><br><span class="line">+mkdir(): boolean</span><br><span class="line">+mkdirs(): boolean</span><br></pre></td></tr></table></figure></li><li><p>文本输入：<code>java.io.PrintWriter</code>：<strong>此类对象初始化后会占用文件资源，记得及时释放</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                        java.io.PrintWriter</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">+PrintWriter(file: File)</span><br><span class="line">+PrintWriter(filename: String)</span><br><span class="line"></span><br><span class="line">+print(s: String): void</span><br><span class="line">+print(c: char): void</span><br><span class="line">+print(cArray: char[]): void</span><br><span class="line">// 注：此外还支持其他各种基本数据类型、包含println（自动换行）、printf（格式化输出）重载方法！！！</span><br><span class="line"></span><br><span class="line">+close(): void</span><br></pre></td></tr></table></figure><blockquote><p><strong>Java 中类似 Python 上下文管理器 处理I/O的工具：JDK 7 的<code>try-with-resources</code>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (声明、创建资源) &#123;</span><br><span class="line">使用资源;</span><br><span class="line">&#125;    <span class="comment">// 下面（Scanner）也能用，就是try-catch的功能之一！</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>文本输入 &amp;&amp; 控制台输入：<code>java.util.Scanner</code>（第三次介绍）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                        java.util.Scanner</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">+Scanner()    // 默认标准输入，即控制台</span><br><span class="line">+Scanner(source: File)        // 注意：可能抛出 IOException ！！！</span><br><span class="line">+Scanner(source: String)</span><br><span class="line"></span><br><span class="line">+close()    // 提示：如果是用来访问文件的，及时释放；控制台输出则不必要；</span><br><span class="line">+hasNext(): boolean</span><br><span class="line">+next(): String        // 分隔符为空格时，如果遇到换行符，则立即停止（读指针停在\n前）</span><br><span class="line">+nextXXX(): XXXX    // XXX表示各种基本数据类型</span><br><span class="line">+nextLine(): String</span><br><span class="line">+useDelimiter(pattern: String): Scanner    // 指定分隔符，默认空格</span><br></pre></td></tr></table></figure></li><li><p>Java 的网络I/O：以简单爬虫为例</p><blockquote><p>Java 的目标之一是互联网应用，所以对于网络相关部件封装的会比其他一些语言更好</p></blockquote><ul><li><p><code>java.net.URL</code>类：管理对URL的访问的类，仅介绍一个方法：<code>URL.openStream() -&gt; inputStream（和System.in一个类型，都是输入流类型，类似C++的istream）</code>，因为都是输入流，可以采用Scanner读取数据；</p></li><li><p>爬虫示例：详见我的另一篇博客《开发一个极简的 Java 网络爬虫》</p></li></ul></li></ol><h3 id="基本程序设计：二进制-I-O"><a href="#基本程序设计：二进制-I-O" class="headerlink" title="基本程序设计：二进制 I/O"></a>基本程序设计：二进制 I/O</h3><blockquote><ul><li><p>二进制I/O比文本I/O更高效：无需进行字符的编解码；</p></li><li><p>Java 的*.class文件就以二进制形式存储；</p></li><li>Java 中几乎所有 I/O 方法都可能 <code>throws IOException</code>；</li><li>个人主观感觉，Java的二进制 I/O 比Python、C++的好用…</li><li>注意<code>EOFException</code>的处理；</li></ul></blockquote><ol><li><p>Binary I/O 类：和<code>PrintWriter</code>、<code>Scanner</code>一样，会占用资源，请及时释放</p><p><img src="./bin_io.png"></p><blockquote><p><i>摘自 Introduction to Java Programming 10th Edition (Y. Daniel Liang)</i></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                    java.io.InputStream (abstract)</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">+read(): int (abstract)        // 从输入流读取下一个字节（0~255的int表示），EOF则返回-1</span><br><span class="line"></span><br><span class="line">+read(b: byte[]): int        // 从输入流读b.length()个字节，返回实际读到的字节数</span><br><span class="line">+read(b: byte[], off: int, len: int): int    // 保存在b[off], b[off+1], ..., b[off+len-1]中</span><br><span class="line"></span><br><span class="line">+available(): int            // 目前可读的字节数</span><br><span class="line">+close(): void                // 释放资源</span><br><span class="line">+skip(n: long): long        // 跳过、丢弃n个字节，返回实际跳过的字节</span><br><span class="line"></span><br><span class="line">+markSupported(): boolean    // 是否支持以下两个方法</span><br><span class="line">+mark(readlimit: int): void // 标记当前位置（默认开头）</span><br><span class="line">+reset(): void                // 将当前读指针定位到之前标记的位置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                    java.io.OutputStream (abstract)</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">+write(b: int):  void (abstract)    // 将(byte)b写入输出流</span><br><span class="line"></span><br><span class="line">+write(b: byte[]): void</span><br><span class="line">+write(b: byte[], off: int, len: int): void</span><br><span class="line"></span><br><span class="line">+close(): void</span><br><span class="line">+flush(): void                // 注：缓冲区何时自动更新和C++一样</span><br></pre></td></tr></table></figure><p><strong>向文件中读写二进制数据：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                        java.io.FileInputStream</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">// 省略同签名函数就没什么东西了，唯一不同的是构造函数（可名可File），读没有花样，简单（不存在会报错）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                        java.io.FileOutputStream</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">// 构造函数类似文件输入流（上面），只是有一个额外的参数：append，决定是否追加还是覆盖（不存在会创建）</span><br></pre></td></tr></table></figure><p><strong>过滤二进制数据（从二进制数据中翻译为基本数据类型）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                            &lt;&lt;interface&gt;&gt;</span><br><span class="line">                    java.io.DataInput (abstract)</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">+readXXX(): XXX            // 读取XXX的基本数据类型</span><br><span class="line">+readLine(): String</span><br><span class="line">+readUTF(): String        // 以UTF格式读为字符串（注：UTF-8格式中,每个字符1Byte）</span><br><span class="line">// 这个接口对标准输入也通用！</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                            &lt;&lt;interface&gt;&gt;</span><br><span class="line">                    java.io.DataOutput (abstract)</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">// 把上面接口中的read改为write</span><br><span class="line">+writeChars(s: String): void    // 每个字符2Byte</span><br></pre></td></tr></table></figure><p><code>DataInputStream</code>、<code>DataOutputStream</code>就是配备以上两个接口、以InputStream、OutputStream为间接父类的应用类；</p><p><strong>缓冲区操作二进制数据：</strong></p><p><code>BufferInputStream</code>、<code>BufferOutputStream</code>，使用见InputStream、OutputStream，唯一不同的是初始化时建议给定缓冲区大小；</p><blockquote><p>应该总是采用缓冲区来提升 I/O 速度，尤其大文件更能感受到；</p></blockquote><p><strong>随机访问文件（与之前的顺序流不同）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                        java.io.RandomAccessFile</span><br><span class="line">                    // 以DataInput、DataOutput为接口</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">+RandomAccessFile(file: File, mode: String)    // mode 与 Python规则一样</span><br><span class="line">+RandomAccessFile(name: String, mode: String)</span><br><span class="line">+close(): void</span><br><span class="line">+getFilePointer(): long                // 没有指针，只有字节数偏移量</span><br><span class="line"></span><br><span class="line">+length(): long</span><br><span class="line">+read(): int</span><br><span class="line">+read(b: byte[] [,...]): int</span><br><span class="line">+write(b: byte[] [,...]): void</span><br><span class="line"></span><br><span class="line">+seek(pos: long): void                // 设置指针为从流开始位置起的偏移量</span><br><span class="line">+skipBytes(int n): int</span><br></pre></td></tr></table></figure></li><li><p>对象 I/O 和序列化接口</p><blockquote><p><code>ObjectInputStream</code>基于接口<code>ObjectInput</code>（其基于<code>DataInput</code>）和<code>ObjectStreamConstants</code>；<code>ObjectOutputStream</code>同理；</p></blockquote><p><strong>现阶段只需会用即可：<code>readObject() -&gt; Object</code>、<code>writeObject(Object x)</code></strong></p><blockquote><p>能够序列化的对象必须配备<code>serializable</code>接口（一种标记接口）</p><p>不支持则抛出<code>NoSerializableException</code></p><p>Java 中大多数基本数据类型、数组、字符串、大数类、日期类等都可序列化；</p></blockquote><p>简单的自定义可序列化类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">example</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 必须全由可序列化的数据域组成！</span></span><br><span class="line">    <span class="comment">// 如果有不可序列化的数据域，需要使用transient关键字丢弃它</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> unSerializableClass u;</span><br><span class="line">    <span class="comment">// 不会序列化静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基本程序设计：总结"><a href="#基本程序设计：总结" class="headerlink" title="基本程序设计：总结"></a>基本程序设计：总结</h3><ol><li><p>前面使用到的所有类、包：复习回顾有哪些知识？（主要）</p><p><img src="./packages.png"></p></li><li><p>类的设计原则</p><blockquote><p>内聚性、一致性（名字一致等）、封装性、清晰性、完整性、实例静态区分、继承聚会结合、灵活使用接口和抽象类；</p></blockquote></li></ol><p>全文完——————————————————————-</p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="//technical/git-learning/"/>
      <url>//technical/git-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-0-The-history-of-version-control-systems"><a href="#Chapter-0-The-history-of-version-control-systems" class="headerlink" title="Chapter 0. The history of version control systems"></a>Chapter 0. The history of version control systems</h2><ul><li><p>Local Version Control Systems</p><blockquote><p>downsides: It is easy to forget which directory you’re in and accidentally write to the wrong file or copy over files you don’t mean to.</p></blockquote></li><li><p>Centralized Version Control Systems</p><blockquote><p>downsides: </p><ol><li><p>the single point of failure that the centralized server represents</p></li><li><p>if the hard disk the central database is on becomes corrupted, and  proper backups haven’t been kept, you lose absolutely everything (Local VCSs suffer from this same problem)</p></li></ol></blockquote></li><li><p>Distributed Version Control Systems (such as Git, Mercurial, Bazaar or Darcs)</p></li></ul><h2 id="Chapter-1-Basic-concepts"><a href="#Chapter-1-Basic-concepts" class="headerlink" title="Chapter 1. Basic concepts"></a>Chapter 1. Basic concepts</h2><h3 id="1-1-Some-concepts-of-the-Git"><a href="#1-1-Some-concepts-of-the-Git" class="headerlink" title="1.1 Some concepts of the Git"></a>1.1 Some concepts of the Git</h3><ul><li><p>How do snapshots record differences?</p><ul><li><p>Other VCS: <strong>delta-based version control</strong> (store information as a list of file-based changes);</p><p><img src="./imgs/deltas.png" height="220"></p></li><li><p>Git: takes a picture of what all your files look like at that moment and stores a reference to that snapshot. (if files have not changed, Git doesn’t store the file again, just a <strong>link</strong> to the previous identical file it has already stored)</p><p><img src="./imgs/snapshots.png" height="220"></p></li></ul></li><li><p><strong>Local operation</strong></p><blockquote><p><strong>Nearly Every Operation Is Local ! </strong></p><ol><li>to browse the history of the project (in local database);</li><li>see the changes introduced between the current version of a file and the file a month ago (do a local difference calculation);</li><li>do a little work and <strong>commit offline or off VPN</strong> (upload when online);</li></ol></blockquote></li><li><p>Integrity (For using SHA-1 hash)</p><blockquote><p>Everything in Git is checksummed before it is stored.</p><p><strong>- it’s impossible to change the contents of any file or directory without Git knowing about it.</strong></p></blockquote></li><li><p><em>Add</em> but never <em>erase/modify</em> in repository</p></li></ul><h3 id="1-2-Working-states-IMPORTANT"><a href="#1-2-Working-states-IMPORTANT" class="headerlink" title="1.2 Working states [IMPORTANT]"></a>1.2 <strong>Working states [IMPORTANT]</strong></h3><blockquote><p>Git has three main states that your files can reside in: <strong>modified</strong>, <strong>staged</strong>, and <strong>committed</strong></p><ul><li>Modified means that you have changed the file but have not committed it to your database yet.</li><li>Staged means that you have marked a modified file in its current version to go into your next commit snapshot.</li><li>Committed means that the data is safely stored in your local database.</li></ul><p><img src="./imgs/areas.png" height="300"></p><p><strong>总结</strong></p><p>工作区：放置从数据库中被取出的、在磁盘上供用户修改和使用的 文件；</p><p>中转地（staging area）：储存在Git目录中，即将进入下一个commit的选中的部分文件；</p><p>Git储存库（repository）：储存元数据、objects数据库的区域，通常 <code>clone</code> 操作也放置在这里；</p><p><strong>正确使用Git的流程</strong></p><ol><li>在工作区编辑项目文件；（modified）</li><li>选出某些需要的features/需要进入next commit中的文件，加入中转地；（staged）</li><li>commit（执行此操作时提交中转地中的文件作为一个commit（或者说一个snapshot），永久存于Git储存库中）；（committed）</li></ol></blockquote><h3 id="1-3-Git-command-line-settings-Linux"><a href="#1-3-Git-command-line-settings-Linux" class="headerlink" title="1.3 Git command line settings (Linux)"></a>1.3 Git command line settings (Linux)</h3><ol><li><p>Git 程序配置文件位置：<code>/etc/gitconfig (系统全局设置)</code>、<code>~/.gitconfig 或 ~/.config/git/config (用户个性化设置，针对某个用户的全局设置，使用--global参数指定)</code>、<code>[current repository PATH]/.git/config (项目个性化设置，针对某个用户项目的局部设置，使用--local指定)</code></p></li><li><p>级别最接近用户级的，最有效（局部设置与全局设置冲突时，服从局部设置）</p></li><li><p>检查Git当前所有设置及其定义的位置：<code>git config --list --show-origin</code></p></li><li><p>检查Git当前所有设置：<code>git config --list</code></p></li><li><p><strong>一些建议</strong></p><ul><li><p>安装git后，立即设置 “用户全局设定” 的用户名、邮箱，因为这是git commit 所有项目的目标地址（关联github）<code>git config --global user.name &quot;xxx&quot; &amp;&amp; git config --global user.email xxx@xxx.com</code></p></li><li><p>设置Git默认打开的系统编辑器 <code>git config --global core.editor [PATH/NAME, e.g., vim]</code></p></li><li><p>设置默认的新的储存库（主分支）的名字 <code>git config --global init.defaultBranch main</code></p><blockquote><p>同样的，如果某个项目需要特殊指定，那么就在项目局部设置中执行设置操作</p></blockquote></li></ul></li></ol><h2 id="Chapter-2-Git-basic-commands"><a href="#Chapter-2-Git-basic-commands" class="headerlink" title="Chapter 2. Git basic commands"></a>Chapter 2. Git basic commands</h2><h3 id="2-1-Manipulate-a-git-repository"><a href="#2-1-Manipulate-a-git-repository" class="headerlink" title="2.1 Manipulate a git repository"></a>2.1 Manipulate a git repository</h3><ol><li><p>创建Git存储库</p><blockquote><ol><li><p>You can take a local directory that is currently <strong>not under version control</strong>, and turn it into a Git repository, or</p></li><li><p>You can <em>clone</em> an existing Git repository from elsewhere.</p></li></ol></blockquote><ul><li><p>从存在的非版本控制目录创建：命令行切换到该目录下，输入<code>git init</code></p><blockquote><p>当前目录下会产生一个子目录<code>.git/</code>，其中记录这个存储库的框架，不包含任何被追踪的项目；</p><p>可以使用<code>git add [FILENAME]</code>将文件（建议放在这个目录下再进行）放入staging area（跳过追踪，下面详述），并使用<code>git commit -m [&quot;DESCRIPTION&quot;]</code>提交生成一个主分支下的commit节点</p></blockquote></li><li><p>从存在的存储库中创建（一般是别人的，位于服务器上的，也可以是自己的），输入<code>git clone &lt;url&gt; [new dirName]</code></p><blockquote><p>以URL=<a href="https://github.com/libgit2/libgit2">https://github.com/libgit2/libgit2</a> 为例，在当前目录下会生成一个子目录<code>.git/</code>和子目录<code>libgit2/</code>，后者包含原来存储库中所有内容，并且内容处于 工作区，并且属于你的master分支。</p></blockquote></li></ul></li><li><p>更改Git存储库、更改项目状态</p><blockquote><p>Each file in your working directory can be in one of two states: <strong>tracked</strong> or <strong>untracked</strong>.</p><p><img src="./imgs/lifecycle.png"></p><ul><li><p>被追踪的文件一定是：上一个提交的snapshot中的文件，或者是在中转地的文件；</p></li><li><p>未被追踪的文件是：上次snapshot中不含此文件，或者也没有staged过的文件，又或者被手动移除追踪属性（<strong>在工作区下自行新建一个文件，但没有任何操作时，也是未被追踪的文件</strong>）；</p><p><strong>这样做的好处是，不会误添加不相关的文件进入项目</strong></p></li><li><p>当刚clone完成一个存储库，其中所有文件都处于Unmodified阶段、工作区（working directory）；</p></li><li><p>一旦更改了Unmodified状态的文件，该文件立即变为Modified状态（for SHA-1）；</p></li></ul></blockquote></li></ol><ul><li><p>检查文件所属状态、所属分支（在存储库目录下）：<code>git status</code></p><blockquote><p>简短表述：<code>git status -s/--short</code></p><p>Untracked: ??</p><p>Modified: M</p><p>Staged: A</p><p>Modified &amp; stage &amp; modified later (未将更改再次写入staging area)：MM</p></blockquote></li></ul><ul><li><p>追踪Untracked状态文件，并添加进staging area（别问为什么不能加到其他状态中去，因为如果不commit的话，就没有必要追踪了啊）：<code>git add [PATH / FILENAME]</code></p><blockquote><p>若参数是 PATH，那么会递归地将该路径下所有文件加入staging area</p></blockquote></li></ul><ul><li><p>将Modified状态文件加入staging area（称为staging Modified files）：<code>git add [PATH / FILENAME]</code></p><blockquote><p><strong>注意：如果修改了staged文件，那么git仍会保留之前的staged的版本（提交时也会默认这个版本），除非将修改后的文件再次加入staging area</strong></p><p>综合上面的和这个例子可知：</p><ol><li>git永远不会将用户不指定的文件加入到staging area中</li><li>git不会将unmodified文件加入staging area，但在储存库的下一个commit中unmodified的文件仍然存在，只不过是个对上一次commit的内容的引用罢了。</li></ol></blockquote></li></ul><ul><li><p>添加需要git忽略的文件（比如程序日志、编译的中间文件，没必要上传到存储库中）：<strong>写<code>.gitignore</code>文件</strong></p><blockquote><p>使用场景列举：比如使用<code>git add .</code>来添加当前目录下所有文件（包括untracked、unmodified、modified的文件）到staging area中，但又不希望某些文件/目录被添加</p><p>建议：在创建存储库后就写这个文件，以防提交不应该被提交的文件</p><p>针对范围：此目录及其子目录（递归生效）</p><p><strong><code>.gitignore</code>文件的语法规则</strong></p><ul><li><p>注释<code>#</code></p></li><li><p>glob patterns: 一种类似正则表达式的语句</p><p><code>*</code>: 0~N个字符，<code>?</code>: 1个字符，<code>/**/</code>用于匹配任意中间目录的结构</p></li><li><p>在每行的glob patterns前加<code>/</code>取消递归和递归查找生效</p></li><li><p>在每行的glob patterns后加<code>/</code>说明前面的是目录</p></li><li><p>否定忽略策略（和UNIX系统设置一样，优先级高于肯定）：在约束名前加上<code>!</code></p></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># ignore all .a files</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># but do track lib.a, even though you&#x27;re ignoring .a files above</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># ignore all files in any directory named build</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># ignore all .pdf files in the doc/ directory and any of its subdirectories</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>查看文件（无论是staged还是unstaged，但未commit）相较于上次提交的更改情况</p><blockquote><p>比较modified文件的不同：<code>git diff</code></p><p>额外参数：<code>--staged</code>，指定比较staged文件</p><p>图形化：<code>git difftool</code></p></blockquote></li></ul><ul><li><p>提交staging area中的文件：<code>git commit</code></p><blockquote><p><strong>此举将打开默认编辑器来显示消息，并提示用户输入一些description，描述一下提交的是什么，这在团队开发中很必要</strong></p><p><strong>强烈建议：加 <code>-m &quot;[DESCRIPTION]&quot;</code> 参数，提供有效的提交信息</strong></p><p>最终输出信息中会出现<strong>本次提交的分支、SHA-1 hash code</strong>等信息</p></blockquote></li></ul><ul><li><p>跳过Staging area并提交：<code>git commit -a -m &quot;...&quot;</code></p><blockquote><p><strong>此举git将自动提交所有被追踪的文件（包括unmodified、modified），注意这样做前考虑一下，别提交了不想要的文件</strong></p></blockquote></li></ul><ul><li><p>将文件从追踪属性上移除（主要用于将文件从staging area中移出）</p><ul><li><p><code>手动将文件移出工作区(变为deleted状态) + git rm</code>：此举只会使<strong>下下次</strong>的提交没有这个文件（不再追踪），但是下次提交仍会有。如果想这次就<strong>彻底删除</strong>，使用强制参数：<code>git rm -f</code></p><blockquote><p>这样做是为了保证数据安全，防止误删将要提交的文件，并且不能恢复</p><p>这个<code>git rm</code> 移除的是处于deleted状态的文件</p></blockquote></li><li><p>如果只是想将文件移出(某个状态)，但保留在硬盘上（比如不小心忘写<code>.gitignore</code>文件，结果一大串日志/编译中间文件都放到了staging area）</p><blockquote><p><code>git rm --cached [FILENAME / PATH / glob-pattern(*需要使用转义字符)]</code></p><p>不在staging area的：<code>git rm [...]</code></p><p><strong>如果只想移出staging area，还想track这个文件，那么就撤销加入staging area的命令，详见 “Undoing things”</strong></p></blockquote></li></ul></li></ul><ul><li><p>移动文件：<code>git mv [PATH / FILENAME] [NEW_PATH / NEW_FILENAME]</code></p><blockquote><p>Git 不会知道你移动了/重命名了某个追踪的文件，会导致追踪丢失（deleted状态），如何找寻丢失的文件以后说，这次讨论<strong>如何告诉Git移动/重命名文件，防止发生追踪丢失</strong></p><p>等价于：手动移除追踪属性，改完，再追踪回去</p></blockquote></li></ul><h3 id="2-2-Viewing-changing-history"><a href="#2-2-Viewing-changing-history" class="headerlink" title="2.2 Viewing changing history"></a>2.2 Viewing changing history</h3><ul><li><p>查看提交日志（提交时间从前向后的顺序）：<code>git log</code></p><ul><li><p>额外参数：<code>-p/--patch [-&#123;number&#125;]</code>，表示展示每次提交的时候同时展示相对于上一次的修改的详细内容（指定展示commit的次数）</p></li><li><p><code>--stat</code>，表示展示每次提交相对于上一次修改的简略内容（只有修改的行号等，但也有基本信息，所以在很多commit的总览时非常有用）</p></li><li><p><code>--pretty=[oneline / short / full / fuller / format:&quot;formatStr&quot;]</code>，自定义提交日志展示的美化。</p><ul><li><p>oneline: 在看很多commit时候有用，每个commit信息浓缩在一行</p></li><li><p>short: 比oneline长一点的简短信息</p></li><li><p>full、fuller: 更全的信息</p></li><li><p>format=formatStr: 根据formatStr需求输出信息，也浓缩于一行，常用占位符如下：</p><table><tr>  <td>Specifier</td>  <td>Description of Output</td></tr><tr>  <td>`%H`</td>  <td>Commit hash</td></tr><tr>  <td>`%h`</td>  <td>Abbreviated commit hash</td></tr><tr>  <td>`%T`</td>  <td>Tree hash</td></tr><tr>  <td>`%t`</td>  <td>Abbreviated tree hash</td></tr><tr>  <td>`%P`</td>  <td>Parent hashes</td></tr><tr>  <td>`%p`</td>  <td>Abbreviated parent hashes</td></tr><tr>  <td>`%an`</td>  <td>Author name</td></tr><tr>  <td>`%ae`</td>  <td>Author email</td></tr><tr>  <td>`%ad`</td>  <td>Author date (format respects the —date=option)</td></tr><tr>  <td>`%ar`</td>  <td>Author date, relative (相对时间，如N天前)</td></tr><tr>  <td>`%cn`</td>  <td>Committer name</td></tr><tr>  <td>`%ce`</td>  <td>Committer email</td></tr><tr>  <td>`%cd`</td>  <td>Committer date</td></tr><tr>  <td>`%cr`</td>  <td>Committer date, relative</td></tr><tr>  <td>`%s`</td>  <td>Subject (commit message)</td></tr></table><blockquote><p>谁是author、committer？—-&gt; 最初自行创建这个存储库的人是author，后来加入这个项目开发的人是committer。</p><p><strong>推荐使用的formatStr：”%h - %an, %ar : %s”</strong></p></blockquote></li></ul></li><li><p><code>--graph</code>: 显示commit的可视化DAG，可以结合<strong>浓缩在一行中的指令（pretty=oneline/format）</strong></p></li><li><p><code>--name-only/--name-status</code>: 仅显示提交的文件名/状态+文件名</p></li><li><p>查找限制参数</p><ul><li><code>--author/committer=&#39;...&#39;</code>: 指定作者/贡献者</li><li><code>--grep=&#39;...&#39;</code>: 同UNIX grep</li><li><code>--since/after/until/before=&quot;yy-mm-dd&quot;</code>: 按时间查找</li><li><code>-- &lt;PATH&gt;</code>: 按文件/目录查找（中间有空格）</li></ul></li></ul></li></ul><h3 id="2-3-Undoing-things"><a href="#2-3-Undoing-things" class="headerlink" title="2.3 Undoing things"></a>2.3 Undoing things</h3><p><strong><u>警告：这里的命令是git中可能丢失数据的命令。因为用户无法撤销某些“被撤销”的操作</u></strong></p><ul><li><p>补交commit：<code>git commit --amend</code></p><blockquote><p>此举将<strong>当前</strong>staging area中的所有文件提交到<strong>上一次的commit中</strong>（不创建新的commit）；</p><p>如果当前staging area中没有文件，那么什么都不变，除非在此次提交中更新传入commit message，则会覆盖之前的commit message.</p><p>建议：只有当你修改幅度非常小的时候才建议使用这个命令，否则为何不直接提交一个新的commit呢？</p></blockquote></li><li><p>Unstaging a Staged File：<code>git reset HEAD FILENAME</code></p><blockquote><p>之后会进一步说明 reset 命令和 HEAD 的详细含义</p></blockquote></li><li><p>Unmodifying a Modified File（discard the changes you’ve made）：<code>git checkout -- FILENAME</code></p><blockquote><p><strong>[Data loss Warning]</strong>: Git just replaced that file with the last staged or committed version. Don’t ever use this command unless you absolutely know that you don’t want those unsaved local changes.</p><p>Where: modified files (working area)（由于保护机制，对staging area内的文件无效)</p><p>tips. 1. <strong>这个命令很危险，是因为：即便是—amend覆盖，也能恢复数据（因为已提交），但这个命令未提交，大概率无法找回</strong>；2. 可以用其他命令来避免这个命令的使用，例如分支来保留特性，见后面描述。</p></blockquote></li><li><p>Git 2.23.0更新：<code>git restore</code> (此命令比上面两个更好记)</p><ul><li>Unstaging a Staged File：<code>git restore --staged FILENAME</code></li><li>Unmodifying a Modified File：<code>git restore FILENAME</code></li></ul><blockquote><p>这两条命令与上面的效果相同，<strong>[Data loss Warning]</strong></p></blockquote></li></ul><h3 id="2-4-Working-with-Remotes"><a href="#2-4-Working-with-Remotes" class="headerlink" title="2.4 Working with Remotes"></a>2.4 Working with Remotes</h3><blockquote><p>这里的“远程”也可以是<strong>自己的主机</strong>！只不过这个目录不是被追踪的git目录，所以和远程的存储库的操作类似。</p><p>网络上的存放存储库的主机一般是 GitHub</p></blockquote><ol><li><p>配置远程存储库</p><ul><li><p>显示当前配置的远程主机：<code>git remote [-v]</code>（—verbose 更详细的信息，含缩略名对应的地址）</p><blockquote><p>origin 缩略名表示<strong>上一次</strong>从远程主机clone的地址</p></blockquote></li><li><p>添加存放存储库的远程主机：<code>git remote add &lt;shortname&gt; &lt;url&gt;</code></p></li></ul></li><li><p>从远程存储库获取项目</p><ul><li><p>从已记录的远程主机上获取项目：<code>git fetch &lt;shortname&gt;</code></p><blockquote><p>不会主动合并分支，具体分支的信息详见branching。</p></blockquote></li><li><p>从已记录的的远程主机上获取项目并将其合并到当前分支：<code>git pull &lt;shortname&gt;</code></p></li><li><p>从远程主机上获取项目，并将<strong>自己的master引用置于获取到的项目的默认主分支上</strong>：<code>git clone &lt;sn/url&gt;</code></p><blockquote><p>以上命令涉及变基、分支和引用的更改，详见branching。</p></blockquote></li></ul></li><li><p>向远程存储库提交、查看</p><ul><li>向remote提交（push，<strong>只有有权限才可以这么做，一般只有自己的GitHub才行，因为别人一般不会允许其他人更改的</strong>）：<code>git push &lt;remote&gt; &lt;branch&gt;</code></li><li>查看远程存储库的情况：<code>git remote show &lt;remote&gt;</code></li></ul></li><li><p>重命名、移动、删除 本地对应远程存储库的缩略名（记住：缩略名只是联系远程存储库和本地的某些存储库的纽带）</p><ul><li><code>git remote rename &lt;old&gt; &lt;new&gt;</code></li><li><code>git remote rm &lt;shortname&gt;</code></li></ul></li></ol><h3 id="2-5-Tagging（版本标签）"><a href="#2-5-Tagging（版本标签）" class="headerlink" title="2.5 Tagging（版本标签）"></a>2.5 Tagging（版本标签）</h3><ul><li>查看当前设置标签：<code>git tag [-l/--list &quot;&#123;wildcards&#125;&quot;]</code></li><li>创建标签<ul><li>Lightweight型标签（固定不变，指向特定commit的标签）：<code>git tag tagName</code></li><li>Annotated型标签（相当于是一次完整的commit，有tagging message等和commit一样多的信息）:<code>git tag -a tagName -m &quot;...&quot;</code></li></ul></li><li>将tag向远程存储库提交：由于git不主动提交标签，需要显式指定<code>git push &lt;remote&gt; &lt;tagName&gt;</code>，或在普通push时，加上参数<code>--tags(全部标签)/--follow-tags(annotated型标签)</code></li><li>删除标签：<code>git tag -d tagName</code></li><li>删除远程存储库的标签：<code>git push &lt;remote&gt; :/refs/tags/tagName</code></li><li>目前请勿轻易使用<code>git checkout tagName</code>来查询标签，因为会导致HEAD引用分离，进而在下一次提交时<strong>丢失</strong>commit！详细请参考branching章节。</li></ul><h3 id="2-6-Git-Aliases（别名设置）"><a href="#2-6-Git-Aliases（别名设置）" class="headerlink" title="2.6 Git Aliases（别名设置）"></a>2.6 Git Aliases（别名设置）</h3><blockquote><p>类似于宏替换：<code>git config --global alias.ALIASNAME sourceName</code></p><p>例如使用：</p><p><code>git config --global alias.unstage &#39;restore --staged&#39;</code>，</p><p><code>git config --global alias.last &#39;log -1 HEAD&#39;</code></p><p>这样就能用<code>git unstage FILE</code>来代替<code>git restore --staged FILE</code></p><p>用<code>git last</code>来代替<code>git log -1 HEAD</code></p><p><strong>注意：外部命令需要用“！”，例如：<code>git config --global alias.visual &#39;!gitk&#39;</code></strong></p></blockquote><h2 id="Chapter-3-Git-Branching-“killer-feature”"><a href="#Chapter-3-Git-Branching-“killer-feature”" class="headerlink" title="Chapter 3. Git Branching: “killer feature”"></a>Chapter 3. Git Branching: “killer feature”</h2><h3 id="3-1-Branches-in-a-nutshell"><a href="#3-1-Branches-in-a-nutshell" class="headerlink" title="3.1 Branches in a nutshell"></a>3.1 Branches in a nutshell</h3><ol><li><p>Look back on how Git stores its data（略，详见<a href="https://git-scm.com/book/en/v2" target="_blank">Git-book</a>）</p><p><img src="./imgs/commit-and-tree.png" height="300px"></p><p><img src="./imgs/commits-and-parents.png" height="200"></p><p><img src="./imgs/branch-and-history.png" height="300"></p><ul><li><p>A branch in Git is simply <strong>a lightweight movable pointer</strong> to one of these commits.</p><blockquote><p>branch对象在Git中，只是一个像C++的指针，只存放指向对象的hash code（40位SHA-1）</p></blockquote></li><li><p><code>Master</code>: default branch moves forward automatically (every time you commit).</p><blockquote><p>master分支指针<strong>跟随当前commit移动的指针</strong>，没什么特别，只是git init一开始设置的而已。</p><p><strong>master之所以可以跟随当前commit移动的指针，不是它特殊，是因为HEAD特殊！HEAD一开始指向mater！每次提交commit时默认移动HEAD指向的指针！一旦HEAD离开master，master就是普通分支指针，不会随当前commit移动</strong></p></blockquote></li><li><p><code>HEAD</code>：this is a pointer to the local branch you’re currently on.</p><blockquote><p>HEAD指针<strong>严格定义为当前所处的分支位置，可以把HEAD理解为指向分支指针的指针</strong>，其他分支操作默认依赖此指针，所以最好在改写它之前考虑一下后果！</p></blockquote></li></ul></li><li><p>Creating a New Branch：<code>git branch newBranchName [position=HEAD]</code></p><blockquote><p>从数据底层考虑这一步在做什么（以 <code>git branch testing</code> 为例）：</p><p><strong>补充：git log 查看参数<code>--decorate</code>可以显示在当时commit下的分支指针情况</strong></p><p><img src="./imgs/head-to-master.png" height="300px"></p><p><strong>由图，执行创建分支操作后，只生成一个指向<code>HEAD</code>（当前commit）的指针testing，并不改变其他任何数据！</strong></p></blockquote></li><li><p>Switching Branches：<code>git checkout branchName</code></p><blockquote><p>从数据底层考虑这一步在做什么（以 <code>git checkout testing</code> 为例）：</p><p><img src="./imgs/head-to-testing.png" height="300"></p><p>tips1. <strong>修改分支只是修改HEAD指向分支的指向！</strong></p><p>一旦此时commit，那么master将停留在原处，只有testing和HEAD向前移动。</p><p><strong>补充：<code>git log</code>默认不展示所有分支，如果想要展示所有分支，添加<code>--all</code>参数，所以可以这样设置参数来查看完整的分支信息：<code>git log --oneline --decorate --graph --all</code></strong></p><p>tips2. <strong>修改分支可能会改变working directory中被追踪的文件，因为HEAD可能回到一个老的版本分支上！而HEAD严格定义为当前所处的分支位置，意味着working directory中所有追踪文件必须与HEAD指向的commit相同（不然你怎么编辑其他分支的文件？）</strong></p><p>tips3. 这样可以完成分支分离(Divergent history)的操作（回到以前的版本，进行全新的提交即可）</p><p>tips4. 可以同时创建、切换分支操作，但要记住在干什么：<code>git checkout -b newBranchName</code></p><p>tips5. Git 2.23更新：可以使用<code>git switch [branchName / -c new / -(切换到上一次的分支指针)]</code></p><p>tips6. 切换分支前，请确保working area、staging area中来自上一个分支未提交的更改及时清空，否则可能遇到冲突，git不会允许切换分支。（清空的方法可以是：amend补交等）</p></blockquote></li><li><p>Merging Branches：<code>git merge targetBranch</code>（一般切换到master上再做操作，因为合并master，<strong>让master成为main主分支最新的版本是业界约定俗成的</strong>）</p><blockquote><p><strong>合并情况一：“Fast-forward”，即要master合并的分支是master的直达的子分支</strong></p><p>这种情况下一定不会出现合并冲突，只需将master向前移动若干commit即可，例如下面的例子：</p><p><img src="./imgs/basic-branching-4.png" height="180"><img src="./imgs/basic-branching-5.png" height="200"></p><p>上面的过程只需执行<code>git checkout master; git merge hotfix</code>即可，</p><p>现在即可删除多余的hotfix分支了。</p><p><strong>合并情况二：“Common Ancester”，即要合并的两个分支有共同祖先结点</strong></p><p>这种情况下，Git需要使用“<strong>三项合并</strong>”（three-way merge，即共同祖先、要合并的两个结点），生成并得到一个新commit（结点），它有两个父结点，就是刚刚合并的两个（为了防止结点丢失），现在就可以删除多余的分支指针了。</p><p><img src="./imgs/basic-merging-1.png" height="160"><img src="./imgs/basic-merging-2.png" height="150"></p><p>上面的过程只需执行<code>git checkout master; git merge iss53</code>即可</p><p><strong>警告：情况二可能出现冲突（如果同一段代码不能协调合并），此时需要修改才能合并</strong></p><p><strong>那么情况二什么时候不冲突呢？——&gt; 涉及<code>three-way merge</code>的原理：</strong></p><p><strong>通过“原件”（共同祖先结点）推断该采用谁的版本：如果文件的同一行中，三者都相同，则不变；如果文件的同一行中，一个分支与祖先结点相同，另一个更改了，那么合并后会保留更改的内容！如果三者都不相同，则会发生冲突。</strong></p></blockquote></li></ol><ol><li><p>Deleting Branches：<code>git branch -d branchName</code></p></li><li><p>Query Branches：<code>git branch [-v/--merged(已合并/存在于当前HEAD所处分支上的)/--no-merged(其他分支上的)/--all]</code></p><blockquote><p>“*” 表示HEAD指针所指向的分支.</p></blockquote></li><li><p>Rename Branches：<code>git branch --move &lt;OLD_name&gt; &lt;NEW_name&gt;</code></p><blockquote><p>Remote: <code>git push --set-upstream &lt;remote&gt; &lt;NEW_name&gt;</code>（不删除原名，相当于复制一个不同名的分支，需要手动删除旧名）</p></blockquote></li></ol><h3 id="3-2-Common-Branching-Workflows"><a href="#3-2-Common-Branching-Workflows" class="headerlink" title="3.2 Common Branching Workflows"></a>3.2 Common Branching Workflows</h3><ul><li>小项目的长期的分支建议：维护<code>master(稳定版的代码)</code>、<code>develop(测试版的代码，一旦可以稳定使用，就将master合并到这里)</code>、<code>topic(开发中的代码，确保没有bug、通过测试集，短期存在)</code></li><li>大项目如果具备多种稳定版本，可以设置多个长期稳定的分支，根据需求来；</li><li>多目标项目的分支建议：可以多设几个分支，来回切换工作，找合适的进行合并，不合适的丢弃；</li></ul><h3 id="3-3-Remote-Branches"><a href="#3-3-Remote-Branches" class="headerlink" title="3.3 Remote Branches"></a>3.3 Remote Branches</h3><blockquote><p>tips1. 参数<code>&lt;remote&gt;</code>可以是url，也可以是shortname</p><p>tips2. <code>origin</code>作为shortname并不是特殊的，和master一样，只是创建时默认的名称而已</p></blockquote><ol><li><p>Query Branches：<code>git remote show &lt;remote&gt;</code></p><blockquote><p>更加好的方法是查询 <code>Remote-tracking branches</code>，终端无法更改这个分支，由git自动维护，精确指向<strong>上次对远程存储库进行操作的分支位置</strong>；</p><p>所谓 <code>Remote-tracking branches</code>的形式是：<code>&lt;remote&gt;/&lt;branchName&gt;</code>，表示在远程存储库中的<code>&lt;branchName&gt;</code>的位置；</p><p>注意：除非手动同步，否则 <code>Remote-tracking branches</code>不会自动更新</p></blockquote></li></ol><ol><li><p>Synchronize  <code>Remote-tracking branches</code>：<code>git fetch &lt;remote&gt;</code></p><blockquote><p>注意：如果远程存储库已经在原来的基础上提交了一些commit，则在本地同步后会产生分叉，例如下图</p><p><img src="./imgs/remote-branches-1.png" height="450"></p><p><img src="./imgs/remote-branches-2.png" height="380"></p><p><img src="./imgs/remote-branches-3.png" height="450"></p><p>注意2：如果是从多个server上fetch，那么会有多种 <code>Remote-tracking branches</code>，位置视情况而定；</p><p>注意3： <code>Remote-tracking branches</code>不能作为本地的HEAD的指向对象！如果不创建新的分支就将HEAD移动到这里，会出现“detached HEAD”的情况，可能造成commit的丢失！</p></blockquote></li></ol><ol><li><p>Pushing Branches（向远程存储库commit分支）：<code>git push &lt;remote&gt; &lt;branch&gt;</code></p><blockquote><p>含义是：提取本地的branch分支上所有文件，复制到远程存储库上，并作为远程存储库的同名分支，同时，远程存储库的HEAD指针移动到当前的分支上；</p><p><strong>知识补充：git的HEAD指针、分支信息存储于<code>.git/refs/heads</code>中，所以这条指令可以这么写：<code>git push &lt;remote&gt; &lt;[refs/heads/]localBranchName:[...]remoteBranchName</code></strong></p><p><strong>补充2：如果基于 <code>Remote-tracking branches</code>创建了一个分支（不是用hash/HEAD创建），则这个分支会自动跟踪远程的对应分支，并且这个本地的分支可以修改，称为<code>Tracking branch</code>。其主要作用是：告诉<code>git pull</code>具体的合并位置在哪。</strong></p><p><strong>补充3：不建议使用<code>git pull</code>，因为这是<code>git fetch</code>+<code>git merge</code>，后者更易于理解，不易出错</strong></p></blockquote></li></ol><ol><li><p>Checking <code>tracking branches</code>：<code>git branch -vv</code></p></li><li><p>Setting a normal branch as a <code>tracking branch</code>：<code>git branch -u &lt;remote/branch&gt;</code>（针对当前分支）</p></li></ol><ol><li>Deleting Remote Branches：<code>git push &lt;remote&gt; --delete &lt;branch&gt;</code></li></ol><h3 id="3-4-Rebasing"><a href="#3-4-Rebasing" class="headerlink" title="3.4 Rebasing"></a>3.4 Rebasing</h3><blockquote><p><strong>In Git, there are two main ways to integrate changes from one branch into another: the <code>merge</code> and the <code>rebase</code>.</strong></p><p>Usage: <code>git rebase targetBranch</code></p></blockquote><ol><li><p>In a nutshell: In the picture shown below, we take the patch of the change that was introduced in <code>C4</code> and reapply it on top of <code>C3</code>. In Git, this is called <em>rebasing</em>.</p><p><img src="./imgs/basic-rebase-1.png" height="140"><img src="./imgs/basic-rebase-3.png" height="130"></p><blockquote><p><code>git checkout experiment &amp;&amp; git rebase master</code></p><p>算法原理：找到二者的公共祖先结点、找到祖先结点和这两个commit共三者的不同，将这些不同保存在临时文件中（<strong>这里的合并方式和merge是一样的</strong>），生成一个新的commit，作为targetBranch的子结点，同时将当前分支移动到新结点上，删除原分支。</p></blockquote></li><li><p>rebase和merge的区别：仅仅是rebase的历史记录呈现线性形状，比merge清晰一点而已；</p><blockquote><p>通常应用rebase的场景：可能是正在为一个不是自己维护的项目提交代码，为了防止维护者阅读和合并的麻烦，在提交前使用rebase合并。</p><p>rebase<strong>严禁使用</strong>的场景：在远程公共存储库使用此命令，修改他人正在编辑的分支（否则可能造成一些重复的commit的问题）；</p><p>从可读性、项目思路上说，应该多多使用rebase；</p><p>从存储库保留历史、无论多乱也不篡改历史的角度说，应该多多使用merge。</p><p><strong>总结：建议每次提交某个小分支前使用rebase提供良好阅读体验；但对已经提交过的部分不应该使用rebase.</strong></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU-Tutor</title>
      <link href="//technical/gnu-tutor/"/>
      <url>//technical/gnu-tutor/</url>
      
        <content type="html"><![CDATA[<h2 id="基础：C-C-的源文件编译过程"><a href="#基础：C-C-的源文件编译过程" class="headerlink" title="基础：C/C++的源文件编译过程"></a>基础：C/C++的源文件编译过程</h2><blockquote><p>想要代码在操作系统上运行，需要进行以下编译步骤，从高级语言转机器语言，以下任务gcc/g++均能完成：</p><ol><li>预编译（<em>.c/cpp &amp; </em>.h —&gt; <em>.i ）：<em>*对应gcc/g++命令：<code>gcc -E [xxx] -o [output.i]</code></em></em><ul><li>展开所有宏定义#define（字符替换）；</li><li>处理所有条件预编译命令（#ifdef、#ifndef、#endif等）；</li><li>处理#include，具体操作是将指向的文件直接插入到文件的这一行（严格遵循上一步的条件）；</li><li>删除所有注释；</li><li>添加行号、文件标识，以便调试/编译出错时及时指出；</li><li>保留#pragma指令，以供编译器使用；</li></ul></li><li>编译（<em>.i —&gt; </em>.s ，即高级语言转汇编语言）：<strong>对应gcc/g++命令：<code>gcc -S [xxx] -o [output.s]</code></strong><ul><li>词法分析、语法分析、语义分析（前端）；</li><li>生成中间代码、优化，生成目标代码（解释型语言无需做此步，生成中间代码后直接对语义执行）；</li><li>编译原理入门：<a href="https://www.cnblogs.com/fisherss/p/13905395.html">https://www.cnblogs.com/fisherss/p/13905395.html</a></li></ul></li><li>汇编（<em>.s —&gt; </em>.o/obj，即汇编语言转机器语言）：<strong>对应gcc/g++命令：<code>gcc -c [xxx] -o [output.o/obj]</code></strong><ul><li>类Unix系统下生成*.o，Windows系统下生成*.obj；</li></ul></li><li>链接（<em>.o —&gt; </em>.out/exe，链接各种需要的库和其他目标文件）：<strong>对应gcc/g++命令：<code>gcc [xxx] -o [output]</code></strong></li><li>生成调试文件（供gdb使用，<strong>对应gcc/g++命令：<code>gcc [xxx] -g -o [output]</code></strong>）<ul><li>也支持<code>-o</code>参数：<code>-O</code>（默认）、<code>-O1</code>（尝试减少代码体积和代码运行时间，但是并不执行会花费大量时间的优化操作）、<code>-O2</code>（包含 -O1的优化并增加了不需要在目标文件大小和执行速度上进行折衷的优化，会花费更多的编译时间当然也会生成性能更好的代码）、<code>-O3</code>（不建议使用）</li></ul></li></ol><p>注：以上<code>[xxx]</code>内容表示gcc接受前面的任意类型文件（比如链接命令可以直接执行使*.cc—-&gt;*.out）。</p></blockquote><h2 id="基础：GNU及其相关概念"><a href="#基础：GNU及其相关概念" class="headerlink" title="基础：GNU及其相关概念"></a>基础：GNU及其相关概念</h2><blockquote><ol><li>GNU是由Richard Stallman在1983年9月27日公开发起的一项计划，目标是创建一套完全自由的操作系统，对标商业化的Unix系统。</li><li>GNU软件可以自由地”使用、复制、修改和发布”，所有GNU软件都有一份在禁止其他人添加任何限制的情况下授权所有权利给任何人的协议条款，<strong>GNU通用公共许可证</strong>(GNU General Public License，GPL)。</li><li>GNU及其创始人：开源运动的先驱</li><li>GNU框架下的著名实现成果：GNU/Linux、GNU/GCC、GNU/make、GNU/GDB</li></ol></blockquote><ul><li>GCC（GNU Compiler Collection，GNU编译器集合），支持从预编译到链接过程的所有源码编译过程；</li><li>MinGW（Minimalist GNU for Windows），可自由使用和自由发布的Windows特定头文件和使用GNU工具集导入库的集合，允许你在Windows平台生成本地的Windows程序而不需要第三方C运行时(C Runtime)库，可以理解为C/C++在Windows上的必要库的集合；<ul><li>MSVC：微软开发的VC运行库，附在Visual Studio上，默认使用<strong>MSVC编译器</strong>；</li><li>MinGW  和  MSVC  的性质、完成目标都相同，只是开发者不同，选其一即可；</li></ul></li><li>LLVM：是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。多用于Apple平台；</li><li>make与CMake<ul><li><code>make</code>出现背景：庞大项目下，一次次使用GCC编译无比麻烦，例如库的依赖关系链接和设定。需要采用：写一个文件指导编译过程的方法。</li><li><code>make</code>的不足：对类Unix系统通用（不兼容Windows）、语法简单（功能受限）、不同编译器语法规则不同（适合GCC，却不适合MSVC）；</li><li>改进（<code>cmake</code>）：make必须编写对应编译器的makefile来实现编译；而CMake则通过<code>CMakeLists.txt</code>，结合当前系统环境、编译器构建合适的文件（可以针对make，也可以针对MSVC）；</li></ul></li><li>GDB： 全称“GNU symbolic debugger”，</li></ul><h2 id="CMake-快速入门"><a href="#CMake-快速入门" class="headerlink" title="CMake 快速入门"></a>CMake 快速入门</h2><ul><li><p>基本步骤</p><blockquote><ol><li>写 CMake 配置文件 CMakeLists.txt 。</li><li>执行命令 <code>cmake PATH</code> 或者 <code>ccmake PATH</code> 生成 Makefile（<code>ccmake</code> 和 <code>cmake</code> 的区别在于前者提供了一个交互式的界面）。其中， <code>PATH</code> 是 CMakeLists.txt 所在的目录。</li><li>使用 <code>make</code> /<code>cmake --build</code>命令进行编译。</li></ol></blockquote></li><li><p><code>CMakeLists.txt</code>语法</p><ul><li><p>普通用法（不存在链接库）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span> [FATAL_ERROR])</span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="keyword">project</span> (projectName [LANGUAGE CXX])</span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"><span class="comment"># 指定生成目标（也可以不用aux_source_directory，但是需要手动一个一个写）</span></span><br><span class="line"><span class="comment"># 如：add_executable (projectName sourceFile1 sourceFile2 ...)</span></span><br><span class="line"><span class="keyword">add_executable</span>(projectName <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p>存在链接库的用法：<strong>情况1：要编译为动态链接库的文件放在另一个目录下。</strong></p><ul><li>在main存在的目录下的CMakeList.txt：</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (projectName)</span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 subDirName 子目录（提示CMake查看该子目录下的CMakeLists.txt）</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(subDirName)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标 </span></span><br><span class="line"><span class="keyword">add_executable</span>(exeName main.cc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链接库（提示CMake和后来的make，exeName需要链接dllName的链接库）</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(exeName dllName)</span><br></pre></td></tr></table></figure><ul><li>在编译链接库的目录下的CMakeLists.txt：</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_LIB_SRCS)</span><br><span class="line"><span class="comment"># 生成链接库</span></span><br><span class="line"><span class="keyword">add_library</span> (dllName <span class="variable">$&#123;DIR_LIB_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p>存在链接库的用法：<strong>情况2：要编译为动态链接库的文件放在同一个目录下。</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (projectName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span> (dllName dllSourceFiles)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (exeName sourceFiles)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span> (exeName dllName)</span><br></pre></td></tr></table></figure></li><li><p>存在链接库的用法：<strong>情况3：第三方已编译的动态链接库（*.so/*.dll）</strong></p><ul><li><p>注：每个第三方库都必须经过如下设置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span> (libName SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span> (</span><br><span class="line">    libName</span><br><span class="line">    PROPERTIES IMPORTED_LOCATION</span><br><span class="line">    <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/[libDIR]</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span> (exeName libName)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>CMake定制安装规则：如果使用<code>make install</code>则会用到</p><ul><li><p>安装位置设置：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fileName（可以是链接库名，也可以是可执行文件名）安装到/usr/local/bin</span></span><br><span class="line"><span class="keyword">install</span> (TARGETS fileName DESTINATION bin)</span><br><span class="line"><span class="comment"># dll.h安装到/usr/local/include</span></span><br><span class="line"><span class="keyword">install</span> (FILES dll.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>CMake添加调试标记（供GDB使用）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将编译选项切换为Debug（而非Release）</span></span><br><span class="line"><span class="keyword">set</span> (CMAKE_BUILD_TYPE DEBUG)</span><br><span class="line"><span class="comment"># 以下命令如果是针对C语言，请将CXX改为C（将Debug模式下的CXXFLAGS的CMake参数加上调试符号）</span></span><br><span class="line"><span class="keyword">set</span> (CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;$&#123;CXXFLAGS&#125; -O0 -Wall -ggdb&quot;</span>)</span><br><span class="line"><span class="comment"># 一般对Release选项直接用O2优化编译即可，可以这么写：</span></span><br><span class="line"><span class="keyword">set</span> (CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;$&#123;CXXFLAGS&#125; -O2 -Wall&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="GCC-G-快速入门"><a href="#GCC-G-快速入门" class="headerlink" title="GCC/G++快速入门"></a>GCC/G++快速入门</h2><p>XP 看什么，在1. 中已经写了，详细见官方文档</p><h2 id="GDB-快速入门（以Linux环境为例）"><a href="#GDB-快速入门（以Linux环境为例）" class="headerlink" title="GDB 快速入门（以Linux环境为例）"></a>GDB 快速入门（以Linux环境为例）</h2><ul><li>常用命令</li></ul><table>    <tr>        <th>命令名称</th>        <th>命令缩写</th>        <th>命令说明</th>    </tr>    <tr>        <td>run</td>        <td>r</td>        <td>运行一个待调试的程序</td>    </tr>    <tr>        <td>continue</td>        <td>c</td>        <td>让暂停的程序继续运行（到下一个断点）</td>    </tr>    <tr>        <td>next</td>        <td>n</td>        <td>运行到下一行（逐过程）</td>    </tr>    <tr>        <td>step</td>        <td>s</td>        <td>单步执行，遇到函数会进入（逐步）</td>    </tr>    <tr>        <td>until</td>        <td>u [num]</td>        <td>运行到指定行停下来</td>    </tr>    <tr>        <td>finish</td>        <td>fi</td>        <td>结束当前调用函数，回到上一层调用函数处（跳出）</td>    </tr>    <tr>        <td>return</td>        <td>return [val]</td>        <td>结束当前调用函数并返回指定值，到上一层函数调用处</td>    </tr>    <tr>        <td>jump</td>        <td>j [num]</td>        <td>将当前程序执行流跳转到指定行或地址（VS移动执行点）</td>    </tr>    <tr>        <td>print</td>        <td>p [var_name]</td>        <td>打印变量或寄存器值</td>    </tr>    <tr>        <td>backtrace</td>        <td>bt</td>        <td>查看当前线程的调用堆栈</td>    </tr>    <tr>        <td>frame</td>        <td>f [stackName]</td>        <td>切换到当前调用线程的指定堆栈</td>    </tr>    <tr>        <td>thread</td>        <td>thread</td>        <td>切换到指定线程</td>    </tr>    <tr>        <td>break</td>        <td>b [line/funcName]</td>        <td>添加断点（行数/函数入口）</td>    </tr>    <tr>        <td>tbreak</td>        <td>tb</td>        <td>添加临时断点（一次性断点）</td>    </tr>    <tr>        <td>delete</td>        <td>d</td>        <td>删除断点</td>    </tr>    <tr>        <td>enable</td>        <td>enable</td>        <td>启用某个断点</td>    </tr>    <tr>        <td>disable</td>        <td>disable</td>        <td>禁用某个断点</td>    </tr>    <tr>        <td>watch</td>        <td>watch</td>        <td>监视某一个变量或内存地址的值是否发生变化</td>    </tr>    <tr>        <td>list</td>        <td>l</td>        <td>显示源码</td>    </tr>    <tr>        <td>info</td>        <td>i</td>        <td>查看断点 / 线程等信息</td>    </tr>    <tr>        <td>ptype</td>        <td>ptype</td>        <td>查看变量类型</td>    </tr>    <tr>        <td>disassemble</td>        <td>dis</td>        <td>查看汇编代码</td>    </tr>    <tr>        <td>set args</td>        <td>set args</td>        <td>设置程序启动命令行参数</td>    </tr>    <tr>        <td>show args</td>        <td>show args</td>        <td>查看设置的命令行参数</td>    </tr></table><p><i><u>下面正式开始快速入门的使用介绍</u></i></p><p><strong>提示：在GDB命令行中，直接回车表示执行上一条命令。</strong></p><ul><li><p>运行前部署</p><ul><li>需要使用g++/gcc/make/cmake等编译（引导）方式来设置运行模式（debug），载入断点符号；</li><li>启用调试的三种方式<ul><li>直接调试目标程序：gdb ./hello_server</li><li>附加进程id：gdb attach pid（<strong>此法在退出GDB前要detach pid</strong>）</li><li>调试core文件：gdb filename corename</li></ul></li><li>启动待调试程序：<code>run</code></li><li>进行如上步骤后，会进入gdb交互命令行，此时如果是<i>直接调试目标程序</i>，则目标程序还未启动，可以：<ul><li>设置运行参数：<code>set args [arg1 arg2 ..]</code></li><li>查看运行参数：<code>show args</code></li><li>查看运行路径：<code>show paths / pwd</code></li><li>设置当前环境变量：<code>set env name=value</code></li><li>查看环境变量：<code>show env [name]</code></li></ul></li></ul></li><li><p>设置断点（所有断点都有编号bID）</p><ul><li><p>指定函数入口出设置断点：<code>break fucnName</code></p><blockquote><p>如果此函数被重载，则会出现断点菜单。只需选择相应的重载函数设置即可（如果放弃填0；可多选，空格隔开）</p></blockquote></li><li><p>指定行号设置断点：<code>break N</code></p></li><li><p>指定源文件的上述位置设置断点：<code>break fileName:xxx</code></p></li><li><p>指定当前行前/后设置断点：<code>break +/-N</code></p></li><li><p>在下一行设置断点：<code>break</code></p></li><li><p><strong>条件断点</strong>：<code>break [...] if cond</code>（[…]可以是上述参数，cond可以含有当前scope中的任意变量名，例如：<code>break if i==100</code>）</p><blockquote><p>每个断点都有条件属性，只不过默认是true，只有if设置了才变成条件断点。</p></blockquote></li><li><p>查询指定断点的信息：<code>info break [bID]</code></p></li></ul></li><li><p>设置观察点</p><ul><li>观察表达式，一有变化立即停止：<code>watch &lt;expr&gt;</code>，例如：<code>watch i+k</code></li><li>观察变量，一旦被读，立即停止：<code>rwatch &lt;var&gt;</code>，例如：<code>rwatch j</code></li><li>观察变量，一旦被访问（读或写），立即停止：<code>awatch &lt;var&gt;</code></li><li>查询观察点信息：<code>info watchpoints [wID]</code></li></ul></li><li><p>设置捕捉点</p><ul><li><p>设置事件捕获点：<code>catch &lt;event&gt;</code></p><blockquote><p>event 可以是如下关键字：</p><ul><li><p>throw：当程序抛出异常</p></li><li><p>catch：当程序捕获到异常</p></li><li>exec：当程序调用系统shell执行</li><li>fork：当程序调用fork</li><li>vfork：当程序调用vfork</li><li>load [libName]：当程序载入共享库</li><li>unload [libName]：当程序卸载共享库</li></ul></blockquote></li><li><p>单次设置捕获点：<code>tcatch &lt;event&gt;</code></p></li></ul></li><li><p>维护上述所有的停止点</p><ul><li>清除停止点：<code>clear(全部) / clear funcName / clear N / clear fileName:xxx</code></li><li>清除断点：<code>delete [ID]</code></li><li>停用/启用停止点：<code>disable/enable [ID]</code></li><li>仅启用停止点一次：<code>enable [ID] once(会再次disable)/delete</code></li></ul></li><li><p>维护条件断点</p><ul><li>修改指定的条件断点的条件：<code>condition [bID] &lt;expr&gt;</code></li><li>清除指定的条件断点的条件（变为条件true的普通断点）：<code>condition [bID]</code></li><li>忽略指定的条件断点<strong>的条件</strong>若干次：<code>ignore [bID] &lt;count&gt;</code></li></ul></li><li><p>停止点命令：自动化调试</p><blockquote><p>和断点的条件属性一样，命令也可以是属性！在触发停止点停止后，会立即执行停止点命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 格式：</span><br><span class="line">commands [bID]</span><br><span class="line">当前语言下的代码指令</span><br><span class="line">[continue]    // 如果希望执行完停止点命令后继续断电后的指令，</span><br><span class="line">            // 在命令后、end前写continue关键字即可</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p>恢复程序运行和单步调试</p><ul><li>继续（可以指定其后忽略断点数）：<code>continue [N=0]</code></li><li>逐步（step in，前提是调用函数在编译时也加了debug符号；count表示跳过的指令行数）：<code>step [count=0]</code></li><li>逐过程（step over）：<code>next [count=0]</code></li><li>跳出当前函数：<code>finish</code></li><li>设置机器码单步跟踪：<code>set step-mode on(default=off)</code></li><li>显示跟踪模式：<code>show step-mode</code></li><li>继续到指定行：<code>until [N]</code></li><li>逐机器码：<code>stepi [count=0]</code></li></ul></li><li><p>运行时数据查看：<code>print /f &lt;expr&gt;</code></p><blockquote><p><strong>请注意：GDB不能使用程序中的宏定义</strong></p><p><code>前置知识：</code>@<code>是GDB中与数组相关的操作符、</code>::<code>是GDB中的作用域运算符、&#123;type&#125; addr 是指针相关操作符</code></p></blockquote><ul><li><p>expr为普通变量或静态数组：全局/静态全局/当前scope的局部变量都可以，也可指定<code>[&quot;fileName&quot;::][&quot;funcName&quot;::]var</code>；</p></li><li><p>expr为动态数组：使用<code>@</code>操作符，用法：第一个内存的地址<strong>的值（需要对指针取值,*）</strong>@ 显示元素长度</p><blockquote><p>例如程序定义了：<code>int* arr = new int[len] &#123;0&#125;;</code>，那么可以使用：</p><p><code>print /d *arr@len</code>来查看arr数组中的情况</p></blockquote></li><li><p>参数<code>/f</code></p><blockquote><p>x 按十六进制格式显示变量<br>d 按十进制格式显示变量<br>u 按十六进制格式显示无符号整型<br>o 按八进制格式显示变量<br>t 按二进制格式显示变量<br>a 按十六进制格式显示变量<br>c 按字符格式显示变量<br>f 按浮点数格式显示变量</p></blockquote></li><li><p>设置显示选项（只讲述部分）</p><ul><li><code>set print pretty on</code>：更优雅地显示结构体等变量；</li><li><code>set print vtbl on</code>：更优雅地显示虚函数表；</li></ul></li><li><p>查看内存：<code>examine [/n(内存长度Byte)f(同print含义)&lt;u&gt;(取地址中内容作变量值，可以取b-单字节数据，h-双字节数据，w-四字节数据，g-八字节数据)]</code></p></li><li><p>自动显示点（也有编号dID）</p><ul><li>设置：<code>display /f &lt;expr&gt;</code>，程序停止时打印该表达式的值；</li><li>删除：<code>delete [dID]</code></li><li>启用/禁用：<code>disable/enable [dID]</code></li></ul></li><li><p>查看显示的历史记录</p><blockquote><p>GDB将print过的表达式值编号，定义为环境变量：<code>$1、$2、$3、...</code></p><p>也可以用<code>show values [N]</code>查看历史</p></blockquote></li><li><p>设置、查看GDB环境变量</p><blockquote><p><strong>GDB环境变量不限类型，定义方式：<code>set $name = value</code></strong></p><p>调用方式：<code>$name</code></p><p>查看所有环境变量：<code>show env</code></p></blockquote></li><li><p>查看寄存器：<code>info [all-]registers</code>（不加all-，不包含浮点寄存器）</p></li></ul></li></ul><p><strong>以下部分以后补充。<a href="https://www.cnblogs.com/lvdongjie/p/8994092.html">https://www.cnblogs.com/lvdongjie/p/8994092.html</a></strong></p><ul><li>运行时变更执行</li><li>信号处理</li><li>线程调试</li><li>源码查看</li></ul>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="//test/hello-world/"/>
      <url>//test/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
