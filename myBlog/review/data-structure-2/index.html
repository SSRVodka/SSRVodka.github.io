<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构复习-第二部分 | SSRVodka's blog</title><meta name="author" content="SSRVodka,xhwpro@gmail.com"><meta name="copyright" content="SSRVodka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构复习-第二部分">
<meta property="og:url" content="https://blog.sjtuxhw.top/review/data-structure-2/index.html">
<meta property="og:site_name" content="SSRVodka&#39;s blog">
<meta property="og:description" content="本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/ds2.jpg">
<meta property="article:published_time" content="2023-05-19T11:37:16.000Z">
<meta property="article:modified_time" content="2024-10-25T14:03:28.480Z">
<meta property="article:author" content="SSRVodka">
<meta property="article:tag" content="Data-Structure">
<meta property="article:tag" content="Tree">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/ds2.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/review/data-structure-2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/css/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构复习-第二部分',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SSRVodka's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/ds2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SSRVodka's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构复习-第二部分</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构复习-第二部分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-19T11:37:16.000Z" title="发表于 2023-05-19 19:37:16">2023-05-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T14:03:28.480Z" title="更新于 2024-10-25 22:03:28">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/review/">review</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/review/data-structure-2/#post-comment"><span class="waline-comment-count" data-path="/review/data-structure-2/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><i><u>本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充</u></i></p>
<p><i>Written by SJTU-XHW</i></p>
<p><i>Reference: 张同珍老师 PPT | UNIkeEN</i></p>
<hr>
<span id="more"></span>
<p>注：默认定义异常类型<code>noElementException</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">noElementException</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noElementException</span>(<span class="type">const</span> <span class="type">char</span>* msg=<span class="string">&quot;No element in the container.&quot;</span>)</span><br><span class="line">        : <span class="built_in">message</span>(msg) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> message; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Chapter-3-栈"><a href="#Chapter-3-栈" class="headerlink" title="Chapter 3 栈"></a>Chapter 3 栈</h2><h3 id="3-1-零碎概念集合"><a href="#3-1-零碎概念集合" class="headerlink" title="3.1 零碎概念集合"></a>3.1 零碎概念集合</h3><ul>
<li><p>栈的地位：一种特殊的（<strong>后进先出，LIFO</strong>）的线性表，仅允许在一端插入、同一端删除；</p>
<blockquote>
<p>栈底、栈顶、空栈、进栈/压栈、出栈/弹栈的定义；</p>
</blockquote>
</li>
<li><p>栈的基本运算：创、进出、读头、判空；</p>
</li>
<li><p><strong>时间有序表：因为栈的元素关系和离开、到达的时间有关，所以栈又被称为时间有序表</strong></p>
</li>
</ul>
<h3 id="3-2-栈的顺序实现"><a href="#3-2-栈的顺序实现" class="headerlink" title="3.2 栈的顺序实现"></a>3.2 栈的顺序实现</h3><ol>
<li><p>存储实现：数组模拟栈，idx=0为栈底；<strong>【数组头指针、规模数、栈顶位置】</strong></p>
<blockquote>
<p>注意：栈顶位置数的地方存放有效数据，所以空栈的栈顶位置习惯为-1；</p>
</blockquote>
</li>
<li><p>运算实现：过于简单，一笔带过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">seqStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* data;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="type">int</span> topIdx;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doubleSpace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T* tmp = data;</span><br><span class="line">        data = <span class="keyword">new</span> T[maxSize * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= topIdx; ++i)</span><br><span class="line">            data[i] = tmp[i];</span><br><span class="line">        <span class="keyword">delete</span>[] tmp; maxSize *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">seqStack</span>(<span class="type">int</span> capacity=<span class="number">10</span>) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> T[capacity];</span><br><span class="line">        maxSize = capacity; topIdx = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">seqStack</span>() &#123; <span class="keyword">if</span> (data) <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> topIdx == <span class="number">-1</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度均摊分析：平均 O(1)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; dt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (topIdx == maxSize - <span class="number">1</span>) <span class="built_in">doubleSpace</span>();</span><br><span class="line">        data[++topIdx] = dt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (topIdx == <span class="number">-1</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> data[topIdx--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (topIdx == <span class="number">-1</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> data[topIdx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-3-顺序栈的变种：共享栈"><a href="#3-3-顺序栈的变种：共享栈" class="headerlink" title="3.3 顺序栈的变种：共享栈"></a>3.3 顺序栈的变种：共享栈</h3><blockquote>
<p>为了提高空间利用率，在某些实际问题中使用多个数据类型相同的栈时，在一块连续的空间中设置多个栈共享空间，其中每个栈有连续的小空间，如图所示。</p>
<p><strong>提示：对栈操作的函数会添加一个整型参数指定究竟对谁操作</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="shared_stacks.png"></p>
<h3 id="3-4-栈的链接实现"><a href="#3-4-栈的链接实现" class="headerlink" title="3.4 栈的链接实现"></a>3.4 栈的链接实现</h3><ol>
<li><p>存储实现：所有操作在栈顶完成——无需头结点的单链表；<strong>【栈顶指针】</strong></p>
</li>
<li><p>运算实现：解说略；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">linkStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        T data;</span><br><span class="line">        node* next;</span><br><span class="line">        <span class="built_in">node</span>() &#123; next = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="built_in">node</span>(<span class="type">const</span> T&amp; dt, node* n=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">data</span>(dt), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node* top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">linkStack</span>() &#123; top = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    ~<span class="built_in">linkStack</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (top) &#123;</span><br><span class="line">            node* tmp = top;</span><br><span class="line">            top = top-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>[] tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> top == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; dt)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> <span class="built_in">node</span>&lt;T&gt;(dt, top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">        T ans = top-&gt;data;</span><br><span class="line">        node* tmp = top;</span><br><span class="line">        top = top-&gt;next; <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getTop</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-5-栈的应用"><a href="#3-5-栈的应用" class="headerlink" title="3.5 栈的应用"></a>3.5 栈的应用</h3><ul>
<li><p>判断回文序列</p>
</li>
<li><p><strong>手动消除递归</strong></p>
<p><strong>经典例题：Ackerman 函数非递归求解、非递归快速排序</strong></p>
<script type="math/tex; mode=display">
\begin{aligned}
&已知Ackerman函数的定义(m、n均为非负整数):\\
&A(m,n)=\begin{equation}\left\{\begin{aligned}&n+1\qquad&if\space m=0\\&A(m-1,1)\quad&if\space m\gt0\space and\space n=0\\&A(m-1,A(m,n-1))&if\space m\gt0\space and\space n\gt0\\\end{aligned}\right.\end{equation}\\
&\\
&试用非递归方法定义Ackerman计算函数:\\
\end{aligned}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ackerman</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span>;        <span class="comment">// 允许使用 seqStack 类</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>具体思路：定义栈中的元素类型为保存m、n两个数的结构体（可以使用C++内置STL pair），先将A(m, n)作为一个元素放入栈中开始循环，循环判断栈非空进入，每次弹出一个元素计算。</p>
<p>如果 m &gt; 0 且 n = 0，那么构建新的元素A(m-1, 1)放进栈中；</p>
<p>如果 m &gt; 0 且 n &gt; 0，那么<strong>不妨把用不到的负数 -1 作为未计算的结果代替 A(m, n-1)</strong>，构建元素A(m-1, -1)进栈，<strong>紧接着进栈A(m, n-1)来补充前面的-1的含义，等待计算；</strong></p>
<p>如果直接计算出结果（m=0），那么检查栈是否为空，如果空，说明计算完成，结束；如果非空，那么说明<strong>这个结果一定是前一个被-1代替的位置上的结果</strong>，只需再弹出一个元素，将其中-1改为当前结果再进栈即可；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ackerman</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">     <span class="type">int</span> m, n;</span><br><span class="line">     <span class="built_in">node</span>(<span class="type">int</span> m_=<span class="number">-1</span>,<span class="type">int</span> n_=<span class="number">-1</span>)</span><br><span class="line">         :<span class="built_in">m</span>(m_), <span class="built_in">n</span>(n_) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> seqStack&lt;node&gt; stk;</span><br><span class="line"> stk.<span class="built_in">push</span>(<span class="built_in">node</span>(m, n));</span><br><span class="line"> <span class="keyword">while</span> (!stk.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">     node tmp = stk.<span class="built_in">pop</span>();</span><br><span class="line">     <span class="keyword">if</span> (tmp.m == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (stk.<span class="built_in">isempty</span>())</span><br><span class="line">             <span class="keyword">return</span> tmp.n + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             node pre = stk.<span class="built_in">pop</span>();</span><br><span class="line">             stk.<span class="built_in">push</span>(<span class="built_in">node</span>(pre.m, tmp.n+<span class="number">1</span>));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (tmp.n == <span class="number">0</span>)</span><br><span class="line">         stk.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp.m<span class="number">-1</span>, <span class="number">1</span>));</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         stk.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp.m<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">         stk.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp.m, tmp.n<span class="number">-1</span>));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>括号匹配</p>
<blockquote>
<p>思路：读入开括号进栈，读入闭括号检查（如果空栈，错误；如果非空则弹出，弹出再检查，如果不匹配则有错误）；最后读取结束必须空栈，否则错误；</p>
</blockquote>
</li>
<li><p><strong>表达式计算</strong></p>
<blockquote>
<p>前缀表达式、中缀表达式、后缀表达式的定义；</p>
</blockquote>
<ol>
<li><p>中缀表达式转后缀表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 从左至右读取中缀表达式</span><br><span class="line">while (当前字符非空) &#123;</span><br><span class="line">    if (读入操作数) 直接输出到后缀表达式中</span><br><span class="line">    if (读入开括号) 直接进运算符栈</span><br><span class="line">    // 括号内的运算符优先级优先于括号外</span><br><span class="line">    if (读入闭括号) 栈内运算符依此弹出并输出，直至开括号停止</span><br><span class="line">    if (读入操作符) &#123;</span><br><span class="line">        // 最高运算符优先级，右结合</span><br><span class="line">        if (操作符是 ^ ) 直接进栈</span><br><span class="line">        // 之前同级、或更高级的运算符可以优先运算</span><br><span class="line">        if (操作符是 */ ) 可以一直出栈，直至遇到 +-或左括号或空，自己进栈</span><br><span class="line">        if (操作符是 +- ) 可以一直出栈，直至遇到左括号或空，自己进栈</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">while (栈非空) &#123;</span><br><span class="line">    运算符出栈，输出到后缀表达式中</span><br><span class="line">    if (出栈元素有括号)</span><br><span class="line">        报告表达式错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后缀表达式的计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 从左至右读取后缀表达式</span><br><span class="line">while (当前字符非空) &#123;</span><br><span class="line">    if (读入操作数) 进操作数栈</span><br><span class="line">    if (读到运算符) 将指定元数的操作数依此（后出被运算数）出栈进行运算，结果进栈</span><br><span class="line">&#125;</span><br><span class="line">结果出栈</span><br><span class="line">if (栈非空)</span><br><span class="line">    报告表达式错误</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="Chapter-4-队列"><a href="#Chapter-4-队列" class="headerlink" title="Chapter 4 队列"></a>Chapter 4 队列</h2><h3 id="4-1-零碎概念集合"><a href="#4-1-零碎概念集合" class="headerlink" title="4.1 零碎概念集合"></a>4.1 零碎概念集合</h3><ul>
<li><p>队列的地位：一种特殊的、先进先出（<strong>FIFO</strong>）的线性表；允许在一端插入、另一端删除；</p>
<blockquote>
<ol>
<li>队尾与队头、队列长度、空队列、入队和出队的定义；</li>
<li>队列也是一种时间有序表；</li>
</ol>
</blockquote>
</li>
<li><p>队列的基本运算种类：创建、读头、判空、入队、出队；</p>
</li>
</ul>
<h3 id="4-2-队列的顺序实现"><a href="#4-2-队列的顺序实现" class="headerlink" title="4.2 队列的顺序实现"></a>4.2 队列的顺序实现</h3><blockquote>
<p>和栈不同，如何设计队头、队尾对性能影响极大；</p>
<p>&#8618; 队首位置固定方式，缺点是出队会引起大量数据移动</p>
<p>&#8618; 队首位置不固定方式，所有操作都是O（1），但浪费空间。</p>
</blockquote>
<ul>
<li><p>最好的一种存储实现之一：<strong>循环队列</strong>【队头整型、队尾整型、顺序表头指针、规模数】</p>
<ul>
<li>队头指针（int）区域<strong>不存放数据</strong>，队尾指针在非空是总是指向最后一个数；</li>
<li>可以使用取余的方法将队列的空间充分利用；</li>
</ul>
</li>
<li><p>运算实现：解说略</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">seqQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> head;</span><br><span class="line">    <span class="type">int</span> tail;</span><br><span class="line">    T* data;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doubleSpace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T* tmp = data;</span><br><span class="line">        data = <span class="keyword">new</span> T[<span class="number">2</span> * maxSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxSize; ++i) &#123;</span><br><span class="line">            data[i] = tmp[(head + i) % maxSize];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp;</span><br><span class="line">        head = <span class="number">0</span>; tail = maxSize; maxSize *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">seqQueue</span>(<span class="type">int</span> capacity=<span class="number">10</span>) &#123;</span><br><span class="line">        maxSize = capacity;</span><br><span class="line">        data = <span class="keyword">new</span> T[capacity];</span><br><span class="line">        head = tail = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">seqQueue</span>() &#123; <span class="keyword">if</span> (data) <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">       <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> head == tail; &#125;</span><br><span class="line">    <span class="function">T <span class="title">getHead</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> data[(head + <span class="number">1</span>) % maxSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(<span class="type">const</span> T&amp; dt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((tail + <span class="number">1</span>) % maxSize == head)</span><br><span class="line">            <span class="built_in">doubleSpace</span>();</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % maxSize;</span><br><span class="line">        data[tail] = dt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">        head = (head + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> data[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>易错点</strong>：doubleSpace时将顺序表扩大时注意0索引区域不放数据！</p>
</li>
</ul>
<h3 id="4-3-队列的链接实现"><a href="#4-3-队列的链接实现" class="headerlink" title="4.3 队列的链接实现"></a>4.3 队列的链接实现</h3><blockquote>
<p>法一：使用无头结点的单链表存储队列—-&gt;【队头、队尾指针】</p>
<p>法二：使用单循环链表—-&gt;【队尾指针】</p>
</blockquote>
<h3 id="4-4-队列的实际应用"><a href="#4-4-队列的实际应用" class="headerlink" title="4.4 队列的实际应用"></a>4.4 队列的实际应用</h3><ul>
<li>排队系统模拟：事件驱动模拟</li>
<li>火车车厢重排</li>
<li><strong>迷宫矩阵问题</strong><ul>
<li>寻找可能解【DFS】：栈消除递归进行回溯；</li>
<li>寻找最优解【BFS】：利用队列<strong>同步</strong>检查所有可能道路，先到终点的连通道路就是最短道路</li>
</ul>
</li>
</ul>
<h2 id="Chapter-5-二叉树、树和森林"><a href="#Chapter-5-二叉树、树和森林" class="headerlink" title="Chapter 5 二叉树、树和森林"></a>Chapter 5 二叉树、树和森林</h2><h3 id="5-1-重要概念集合"><a href="#5-1-重要概念集合" class="headerlink" title="5.1 重要概念集合"></a>5.1 重要概念集合</h3><ul>
<li><p>树的两种定义</p>
<ol>
<li>在一个元素集合中，如果元素呈<strong>上下层次关系</strong>。对一个结点而言，上层元素为其直接前驱且直接前驱唯一，下层元素为其直接后继且直接后继可以有多个，这样的结构就是树结构。</li>
<li>递归定义：树是n个结点（离散数学要求<code>n &gt; 0</code>）的有限集合，它或者是空集，或者满足：<ul>
<li>有一个被称为根的结点；</li>
<li>其余结点可分为m（m &gt; 0）个互不相交的集合 <code>T1, T2, ..., Tm</code>这些集合本身也是一棵树，并称它们为根结点的子树；</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>各类结点的定义</strong></p>
<ul>
<li><p>根结点、叶结点、内部节点/中间结点；</p>
</li>
<li><p>子结点、父结点、祖先结点、子孙结点、兄弟结点；</p>
<blockquote>
<p>注意：兄弟结点只有同一父结点才算！！！否则叫堂兄弟结点；</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>各种“度”</strong></p>
<ul>
<li>结点的度：树中一个结点的直接后继（子结点）的数目；</li>
<li>结点深度（层次）：从根结点（<strong>高度定为1</strong>）向下到该结点的对应数；</li>
<li>结点高度：以该结点为根的子树的高度；</li>
<li>树的高度：树中所有结点的最大深度；</li>
</ul>
</li>
<li><p>有序树和无序树：如果树中任意结点的子结点都被规定了一定的顺序，就称此树为有序树，反之称为无序树；</p>
</li>
<li><p>森林：M棵互不相交的树的集合</p>
<blockquote>
<p>由定义，一棵删去根的树，其子树构成的集合就是一个森林；</p>
</blockquote>
</li>
</ul>
<h3 id="5-2-二叉树的重要概念"><a href="#5-2-二叉树的重要概念" class="headerlink" title="5.2 二叉树的重要概念"></a>5.2 二叉树的重要概念</h3><ul>
<li><p>定义：建议将树的定义代入，只需注意二叉的特点；</p>
<blockquote>
<p><strong>注意：二叉树的子结点需要明确指明是左还是右，哪怕只有一个子结点</strong></p>
</blockquote>
</li>
<li><p>特殊二叉树</p>
<ul>
<li>满二叉树：k层二叉树的每一个结点数量都达最大值；</li>
<li>完全二叉树：k层二叉树的k-1层都是满的，k层相较于满二叉树<strong>从右至左依此去掉</strong>若干结点得到的树；</li>
</ul>
</li>
<li><p>二叉树性质</p>
<ul>
<li><p>一棵非空二叉树的第 i 层上<strong>最多</strong>有 <strong>$2^{i-1}$</strong> 个结点（i ≥ 1）；</p>
</li>
<li><p>一棵高度为 k 的二叉树<strong>最多</strong>有 <strong>$2^k-1$</strong> 个结点；</p>
</li>
<li><p>一棵非空二叉树，若叶结点数 <strong>$n_0$</strong>，度为 2 的结点数 <strong>$n_2$</strong>，则 <strong>$n_0=n_2+1$</strong>；</p>
</li>
<li><p>具有 n 个结点的<strong>完全二叉树</strong>的高度一定为 <strong>$k=floor(log_2n)+1$</strong></p>
</li>
<li><p>对有 n 个结点的<strong>完全二叉树</strong>的结点按层自上而下，每一层自左至右依此编号，设根结点编号为 1，那么：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&1.\quad i=1\Longleftrightarrow 该二叉树根结点;\quad i\gt 1\Longrightarrow 该结点的父结点编号floor(\dfrac{i}{2})\\
&2.\quad 若\space 2i\gt n,\space则编号为\space i\space的结点为叶结点,否则其左子结点编号为\space 2i\\
&3.\quad若\space2i+1\gt n,\space 则编号为\space i\space的结点没有右子结点，否则其右子结点的编号为\space 2i+1
\end{aligned}</script></li>
</ul>
</li>
<li><p>二叉树的基本运算：创清、判空、寻根、寻父、寻左儿子寻右儿子、删左儿子删右儿子、遍历</p>
</li>
<li><p>二叉树的<strong>遍历序列 和 确定</strong></p>
<ul>
<li><strong><u>二叉树的前序-中序、后序-中序、层次-中序 遍历序列都可以确定唯一一个二叉树（必须含有中序）</u></strong></li>
<li>完全二叉树的层次遍历能唯一确定该完全二叉树；</li>
<li>满二叉树的前序、中序、后序遍历序列<strong>之一</strong>就能完全确定该满二叉树；</li>
<li><strong>做题方法：遇到从某些序列构建完整的二叉树时，应该在过程中反复比对</strong></li>
</ul>
</li>
<li><p>考题分析</p>
<ul>
<li><p>一个完全二叉树的叶结点个数为124，问该树所有结点的最大个数为多少；</p>
<blockquote>
<p>分析方法一：完全二叉树的叶结点为124，先考虑满二叉树的情况（<strong>注意到在所有的、高度相同的完全二叉树中，满二叉树的叶结点最大！</strong>），满二叉树高度为7时，64个叶结点；满二叉树高度为8时，128个叶结点；满二叉树高度为9时，256个叶结点，<strong>且倒数第二层共128个内部结点</strong>；因此：</p>
<ul>
<li>该树的高度一定大于7、小于9 <strong>$\Longrightarrow$</strong> 该树的高度为8；</li>
</ul>
<p>再考虑从满二叉树减少结点，每减少两个兄弟结点中的一个，叶结点数减少1（只剩一个时不会变）；所以满足条件的完全二叉树可以：<strong>从8层满二叉树下自右至左减去 8 个或 7 个叶结点</strong>，即 <strong>$n_{max}=2^8-1-7=248$</strong></p>
<p><strong>分析方法二（最优解）</strong>：</p>
<script type="math/tex; mode=display">
n=n_0+n_1+n_2\space且\space b=n-1=n_1+2n_2\Rightarrow n_2=n_0-1=123</script><p>由于<strong>完全二叉树必须有：$n_1=1或0$</strong>，故 <strong>$n_{max}=124+1+123=248$</strong></p>
<p>结论：该树的所有节点最大个数为 248</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="5-3-二叉树的存储和运算实现"><a href="#5-3-二叉树的存储和运算实现" class="headerlink" title="5.3 二叉树的存储和运算实现"></a>5.3 二叉树的存储和运算实现</h3><blockquote>
<p>顺序实现：仅建议完全二叉树 / 具有一些结点关系的树（例如哈夫曼树）/ 不需要频繁增删结点的普通二叉树采用这种存储方式，否则导致空间利用率低下；</p>
</blockquote>
<p>[x] <strong>二叉树的主要存储方式是链接实现的</strong></p>
<ul>
<li><p>标准存储结构（最常用）：二叉链表【表头指针】</p>
<ul>
<li>大多数操作简单，但寻父运算性能不佳；</li>
</ul>
</li>
<li><p>广义标准存储结构：三叉链表【表头指针】</p>
</li>
<li><p>二叉树运算实现</p>
<ul>
<li>寻左右儿子、删左右儿子的函数需要底层的find函数先查找；</li>
<li>清除、删左右儿子的函数需要底层的“删除结点及其子树”的clear函数；</li>
<li>深度优先的递归的消除采用栈，广度优先采用队列实现；</li>
</ul>
<blockquote>
<p>下面以非递归实现的标准存储的二叉树为例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        T data;</span><br><span class="line">        node* left;</span><br><span class="line">        node* right;</span><br><span class="line">        <span class="built_in">node</span>(): <span class="built_in">left</span>(<span class="number">0</span>), <span class="built_in">right</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">node</span>(<span class="type">const</span> T&amp; dt, node* L=<span class="number">0</span>, node* R=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">data</span>(dt), <span class="built_in">left</span>(L), <span class="built_in">right</span>(R) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">travNode</span> &#123;</span><br><span class="line">        node* curNode;</span><br><span class="line">        <span class="type">int</span> popTimes;</span><br><span class="line">        <span class="built_in">travNode</span>(node* n=<span class="number">0</span>, <span class="type">int</span> pop=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">curNode</span>(n), <span class="built_in">popTimes</span>(pop) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    node* root;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line">    <span class="function">node* <span class="title">find</span><span class="params">(<span class="type">const</span> T&amp; dt)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">binTree</span>();</span><br><span class="line">    <span class="built_in">binTree</span>(<span class="type">const</span> T&amp; dt);</span><br><span class="line">    ~<span class="built_in">binTree</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createFromStd</span><span class="params">(<span class="type">const</span> T&amp; emptyFlag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">Root</span><span class="params">(<span class="type">const</span> T&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">father</span><span class="params">(<span class="type">const</span> T&amp; dt, <span class="type">const</span> T&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">leftChild</span><span class="params">(<span class="type">const</span> T&amp; dt, <span class="type">const</span> T&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">rightChild</span><span class="params">(<span class="type">const</span> T&amp; dt, <span class="type">const</span> T&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rmLeftChild</span><span class="params">(<span class="type">const</span> T&amp; dt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rmRightChild</span><span class="params">(<span class="type">const</span> T&amp; dt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrdTrav</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">midOrdTrav</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrdTrav</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelTrav</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常见实现</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">binTree&lt;T&gt;::<span class="built_in">binTree</span>() &#123; root = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">binTree&lt;T&gt;::<span class="built_in">binTree</span>(<span class="type">const</span> T&amp; dt) &#123; root = <span class="keyword">new</span> <span class="built_in">node</span>(dt); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">binTree&lt;T&gt;::~<span class="built_in">binTree</span>() &#123; <span class="built_in">clear</span>(root); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">createFromStd</span>(<span class="type">const</span> T&amp; emptyFlag) &#123;</span><br><span class="line">    seqQueue&lt;node*&gt; tasks;</span><br><span class="line">    T left, right;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;root: &quot;</span>; std::cin &gt;&gt; left;</span><br><span class="line">        <span class="keyword">if</span> (left != emptyFlag) tasks.<span class="built_in">enQueue</span>(root = <span class="keyword">new</span> <span class="built_in">node</span>(left));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; tasks.<span class="built_in">enQueue</span>(root); &#125;</span><br><span class="line">    <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        node* cur = tasks.<span class="built_in">deQueue</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;the left child &amp; the right child of &quot;</span> &lt;&lt; cur-&gt;data &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        std::cin &gt;&gt; left &gt;&gt; right;</span><br><span class="line">        <span class="keyword">if</span> (left != emptyFlag)</span><br><span class="line">            tasks.<span class="built_in">enQueue</span>(cur-&gt;left = <span class="keyword">new</span> <span class="built_in">node</span>(left));</span><br><span class="line">        <span class="keyword">if</span> (right != emptyFlag)</span><br><span class="line">            tasks.<span class="built_in">enQueue</span>(cur-&gt;right = <span class="keyword">new</span> <span class="built_in">node</span>(right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> binTree&lt;T&gt;::<span class="built_in">isempty</span>() <span class="type">const</span> &#123; <span class="keyword">return</span> root == <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">clear</span>() &#123; <span class="built_in">clear</span>(root); root = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T binTree&lt;T&gt;::<span class="built_in">Root</span>(<span class="type">const</span> T&amp; emptyFlag) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> emptyFlag;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T binTree&lt;T&gt;::<span class="built_in">father</span>(<span class="type">const</span> T&amp; dt, <span class="type">const</span> T&amp; emptyFlag) &#123; <span class="keyword">return</span> emptyFlag; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T binTree&lt;T&gt;::<span class="built_in">leftChild</span>(<span class="type">const</span> T&amp; dt, <span class="type">const</span> T&amp; emptyFlag) <span class="type">const</span> &#123;</span><br><span class="line">    node* cur = <span class="built_in">find</span>(dt);</span><br><span class="line">    <span class="keyword">if</span> (!cur || !(cur-&gt;left)) <span class="keyword">return</span> emptyFlag;</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;left-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T binTree&lt;T&gt;:: <span class="built_in">rightChild</span>(<span class="type">const</span> T&amp; dt, <span class="type">const</span> T&amp; emptyFlag) <span class="type">const</span> &#123;</span><br><span class="line">    node* cur = <span class="built_in">find</span>(dt);</span><br><span class="line">    <span class="keyword">if</span> (!cur || !(cur-&gt;right)) <span class="keyword">return</span> emptyFlag;</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;right-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">rmLeftChild</span>(<span class="type">const</span> T&amp; dt) &#123; </span><br><span class="line">    node* cur = <span class="built_in">find</span>(dt);</span><br><span class="line">    <span class="keyword">if</span> (!cur || !(cur-&gt;left)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">clear</span>(cur-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">rmRightChild</span>(<span class="type">const</span> T&amp; dt) &#123; </span><br><span class="line">    node* cur = <span class="built_in">find</span>(dt);</span><br><span class="line">    <span class="keyword">if</span> (!cur || !(cur-&gt;right)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">clear</span>(cur-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">preOrdTrav</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    seqStack&lt;node*&gt; tasks;</span><br><span class="line">    tasks.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        node* tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; tmp-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right) tasks.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left) tasks.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">midOrdTrav</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    seqStack&lt;travNode&gt; tasks;</span><br><span class="line">    tasks.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        travNode tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (tmp.popTimes == <span class="number">0</span>) &#123;</span><br><span class="line">            ++tmp.popTimes;</span><br><span class="line">            tasks.<span class="built_in">push</span>(tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp.curNode-&gt;left)</span><br><span class="line">                tasks.<span class="built_in">push</span>(<span class="built_in">travNode</span>(tmp.curNode-&gt;left));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; tmp.curNode-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmp.curNode-&gt;right)</span><br><span class="line">                tasks.<span class="built_in">push</span>(<span class="built_in">travNode</span>(tmp.curNode-&gt;right));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">postOrdTrav</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    seqStack&lt;travNode&gt; tasks;</span><br><span class="line">    tasks.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        travNode tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">switch</span> (tmp.popTimes) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            ++tmp.popTimes;</span><br><span class="line">            tasks.<span class="built_in">push</span>(tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp.curNode-&gt;left)</span><br><span class="line">                tasks.<span class="built_in">push</span>(<span class="built_in">travNode</span>(tmp.curNode-&gt;left));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ++tmp.popTimes;</span><br><span class="line">            tasks.<span class="built_in">push</span>(tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp.curNode-&gt;right)</span><br><span class="line">                tasks.<span class="built_in">push</span>(<span class="built_in">travNode</span>(tmp.curNode-&gt;right));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; tmp.curNode-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> binTree&lt;T&gt;::<span class="built_in">levelTrav</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    seqQueue&lt;node*&gt; tasksQ;</span><br><span class="line">    tasksQ.<span class="built_in">enQueue</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!tasksQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        node* tmp = tasksQ.<span class="built_in">deQueue</span>();</span><br><span class="line">        std::cout &lt;&lt; tmp-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left) tasksQ.<span class="built_in">enQueue</span>(tmp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right) tasksQ.<span class="built_in">enQueue</span>(tmp-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> binTree&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    seqStack&lt;node*&gt; tasks;</span><br><span class="line">    tasks.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        node* tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left) tasks.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right) tasks.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-4-二叉线索树"><a href="#5-4-二叉线索树" class="headerlink" title="5.4 二叉线索树"></a>5.4 二叉线索树</h3><blockquote>
<p>在二叉树中利用空指针域，如果一个结点的左/右指针为空，就将<strong>某种遍历序列中的这个结点的直接前驱结点地址存在该位置</strong>，这种二叉树就叫<strong>线索树</strong></p>
</blockquote>
<ul>
<li>对一棵中序线索树而言，中序遍历的非递归实现可以不使用栈；</li>
</ul>
<h3 id="5-5-哈夫曼树"><a href="#5-5-哈夫曼树" class="headerlink" title="5.5 哈夫曼树"></a>5.5 哈夫曼树</h3><ul>
<li><p>哈夫曼树的存储方法</p>
<ul>
<li><strong>哈夫曼树只有度为2的结点和叶结点，总结点数=2*需编码字符数-1【元素数了解】</strong></li>
<li><strong>哈夫曼树建立后一般不会进行结点增删</strong></li>
</ul>
<blockquote>
<p><strong>所以采用规模数为2n的数组静态（顺序）存储</strong></p>
</blockquote>
</li>
<li><p>哈夫曼树的建立：哈夫曼算法</p>
<ul>
<li><p>step1：从给定权值和数据的集合中构建一片只有根结点的二叉树森林；</p>
<blockquote>
<p>将需编码数据和权值对应地加入第 n~2n-1 索引的数组内，其他位置所有数据置为0（第0索引空出）；</p>
</blockquote>
</li>
<li><p>step2：执行 n-1 次循环，选择每次森林中<strong>权值最小、次最小</strong>的两棵树，以这两棵树为左右子树构建出一棵新树，移除这两棵树并将新树加入；</p>
<blockquote>
<p>执行 n-1 次循环，第 i 次在下标 n + i - 1 到 2n - 1 之间寻找满足：<strong>父结点对应值为0（当前是树根）</strong>且<strong>权值最小 和 次小的结点</strong>，并且①在 n + i 的位置填入 {权值=两点权值和；左右子节点为找到的两结点} 的结点 ；②修改被找到的那两个结点的父结点为 <script type="math/tex">n+i</script>；</p>
<p>即：修改父子关系、置权归并；</p>
</blockquote>
</li>
<li><p>step3：如果只剩下一个树，那么这个树根上的结点的值即为所求；</p>
</li>
</ul>
<blockquote>
<p>⚠易错警示：注意比较森林中的最小两个权的树，不一定是”最大的“那个树，切忌惯性思维；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Huffman Tree</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hfTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hfNode</span> &#123;</span><br><span class="line">        T data;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="type">int</span> parent;</span><br><span class="line">        <span class="type">int</span> left;</span><br><span class="line">        <span class="type">int</span> right;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    hfNode* treeData;</span><br><span class="line">    <span class="comment">// The length of the treeData(hfNode*)</span></span><br><span class="line">    <span class="comment">// = 2 * numOfData.</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hfCode</span>&#123;</span><br><span class="line">        T data;</span><br><span class="line">        std::string code;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">hfTree</span>(<span class="type">const</span> T* dt, <span class="type">const</span> <span class="type">int</span>* w, <span class="type">int</span> size);</span><br><span class="line">    ~<span class="built_in">hfTree</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getCode</span><span class="params">(hfCode results[])</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">hfTree&lt;T&gt;::<span class="built_in">hfTree</span>(<span class="type">const</span> T* dt, <span class="type">const</span> <span class="type">int</span>* w, <span class="type">int</span> size) &#123;</span><br><span class="line">    length = size * <span class="number">2</span>;</span><br><span class="line">    treeData = <span class="keyword">new</span> hfNode[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt; length; ++i) &#123;</span><br><span class="line">        treeData[i].data = dt[i - size];</span><br><span class="line">        treeData[i].weight = w[i - size];</span><br><span class="line">        treeData[i].parent = treeData[i].left = treeData[i].right = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 想要提高这一段速度，可以把这个 O(n^2) 代码改成优先级队列的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> min_1, min_2, min_1_idx = <span class="number">0</span>, min_2_idx = <span class="number">0</span>;</span><br><span class="line">        min_1 = min_2 = INT32_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (treeData[j].parent == <span class="number">0</span>) &#123;	<span class="comment">// The root of the subtree.</span></span><br><span class="line">                <span class="keyword">if</span> (treeData[j].weight &lt; min_1) &#123;</span><br><span class="line">                    min_2 = min_1;			<span class="comment">// Give the last value of min_1 to min_2</span></span><br><span class="line">                    min_1 = treeData[j].weight;	<span class="comment">// so that min_2 can be the second smallest element.</span></span><br><span class="line">                    min_2_idx = min_1_idx;</span><br><span class="line">                    min_1_idx = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (treeData[j].weight &lt; min_2) &#123;</span><br><span class="line">                    min_2 = treeData[j].weight;</span><br><span class="line">                    min_2_idx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The end of this round. Change the hier-info &amp; weight.</span></span><br><span class="line">        treeData[i].parent = <span class="number">0</span>;</span><br><span class="line">        treeData[i].weight = min_1 + min_2;</span><br><span class="line">        treeData[i].left = min_1_idx;</span><br><span class="line">        treeData[i].right = min_2_idx;</span><br><span class="line">        treeData[min_1_idx].parent = i;</span><br><span class="line">        treeData[min_2_idx].parent = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">hfTree&lt;T&gt;::~<span class="built_in">hfTree</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (treeData) <span class="keyword">delete</span>[] treeData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> hfTree&lt;T&gt;::<span class="built_in">getCode</span>(hfCode result[]) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> size = length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> step = i;</span><br><span class="line">        result[i - size].data = treeData[i].data;</span><br><span class="line">        result[i - size].code = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (step &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result[i - size].code = (</span><br><span class="line">                treeData[treeData[step].parent].left==step</span><br><span class="line">                ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span></span><br><span class="line">            ) + result[i - size].code;</span><br><span class="line">            step = treeData[step].parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>哈夫曼树的重要相关概念</p>
<ul>
<li><p>结点的带权路径长 = 路径权值 * 路径长（=深度-1）；</p>
</li>
<li><p>树的带权路径长 = 所有<strong>叶结点</strong>的带权路径之和；</p>
</li>
</ul>
</li>
<li><p>哈夫曼编码求解的时间复杂度分析</p>
<ul>
<li>树高根据情况在：<strong>$O(log_2n)\sim O(n)$</strong> 规模，循环查找所有编码，故复杂度在 <strong>$O(nlog_2n)\sim O(n^2)$</strong> 之间；</li>
</ul>
</li>
</ul>
<h3 id="5-6-二叉树、树与森林的转换"><a href="#5-6-二叉树、树与森林的转换" class="headerlink" title="5.6 二叉树、树与森林的转换"></a>5.6 二叉树、树与森林的转换</h3><ul>
<li><p>树的存储实现</p>
<ul>
<li><p>孩子链表示法：静态孩子链表（表头数组存储所有结点，会指向下标链表）、动态孩子链表（所有结点组成一个链表）；</p>
<blockquote>
<p>可以考虑增加一个结点字段存放父结点，称“带双亲的孩子链表示法”</p>
</blockquote>
</li>
<li><p><strong>孩子兄弟链表示法（最常用）</strong>：<code>左指针指向第一个儿子 | 数据 | 右指针指向第一个兄弟（不重复）</code></p>
<blockquote>
<p>转换成二叉树后，根结点一定没有右儿子；</p>
</blockquote>
</li>
<li><p>双亲表示法：通过指向父结点的指针将树中结点关联（不相交集可以用此方法存储）；</p>
</li>
</ul>
</li>
<li><p>森林的存储实现：每棵树孩子兄弟链 + 右子树拼接；</p>
</li>
<li><p>树的遍历：前序、后序、层次；</p>
</li>
</ul>
<h2 id="Chapter-6-优先级队列"><a href="#Chapter-6-优先级队列" class="headerlink" title="Chapter 6 优先级队列"></a>Chapter 6 优先级队列</h2><blockquote>
<p>优先级队列不宜借助线性结构实现，因为出队 / 入队一定有一个效率 为 O(n)；</p>
</blockquote>
<h3 id="6-1-重要概念集合"><a href="#6-1-重要概念集合" class="headerlink" title="6.1 重要概念集合"></a>6.1 重要概念集合</h3><ul>
<li>二叉堆：一棵满足<strong>结构性、有序性</strong>的二叉树（完全二叉树）；</li>
<li>二叉堆结构性优势：树高度尽可能小，可以采用顺序存储，最坏对数级别时间复杂度；</li>
<li>二叉堆有序性优势：算法上保证入队、出队的时间性能；</li>
<li>优先级队列的基本运算：同队列；</li>
</ul>
<h3 id="6-2-优先级队列的实现方法：树形结构"><a href="#6-2-优先级队列的实现方法：树形结构" class="headerlink" title="6.2 优先级队列的实现方法：树形结构"></a>6.2 优先级队列的实现方法：树形结构</h3><ul>
<li><p>存储实现：二叉堆【队长度、队容量、二叉堆根结点】</p>
<blockquote>
<p><strong>⚠ATTENTION：</strong></p>
<p>如果二叉堆（完全二叉树）存储在数组中，规定0号位不放元素，那么可以用之前完全二叉树的结论：i 号位的左儿子 2i、右儿子 2i+1、父结点 floor(i/2)（如果有的话）；</p>
<p><strong>但如果二叉堆规定0号位放元素</strong>，那么需要转换一下：左儿子2i+1、右儿子2i+2、父结点floor((i-1)/2)；</p>
<p>推导：左子结点映射：i -&gt; 2i，索引移动后，i - 1 -&gt; 2i - 1；现在只知道 i - 1的结点的左子结点对应 2i - 1，想要知道 i 的左子结点，需要整体换元：i -&gt; 2(i + 1)-1 = 2i+1；其他同理;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">priorityQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* data;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doubleSpace</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 可复用：使从第n号元素开始的以下结点全部平衡</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">percolateDown</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">priorityQueue</span>(<span class="type">int</span> capacity=<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">priorityQueue</span>(T* sequence, <span class="type">int</span> size);</span><br><span class="line">    ~<span class="built_in">priorityQueue</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(<span class="type">const</span> T&amp; dt)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">deQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">getHead</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运算实现（以使用0号元素的、最小化堆【可以添加comp模板参数以实现自定义最大/最小化堆】实现优先级队列为例）</p>
<p>[PRIVATE] 扩容操作：完全与线性表相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> priorityQueue&lt;T&gt;::<span class="built_in">doubleSpace</span>() &#123;</span><br><span class="line">    T* tmp = data;</span><br><span class="line">    data = <span class="keyword">new</span> T[<span class="number">2</span> * maxSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxSize; ++i)</span><br><span class="line">        data[i] = tmp[i];</span><br><span class="line">    <span class="keyword">delete</span>[] tmp; maxSize *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建、删除 <strong>$O(1)$</strong>：分配数组、设置队长和容量；释放空间；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">priorityQueue&lt;T&gt;::<span class="built_in">priorityQueue</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">    maxSize = capacity; length = <span class="number">0</span>;</span><br><span class="line">    data = <span class="keyword">new</span> T[capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">priorityQueue&lt;T&gt;::~<span class="built_in">priorityQueue</span>() &#123; <span class="keyword">if</span> (data) <span class="keyword">delete</span>[] data; &#125;</span><br></pre></td></tr></table></figure>
<p>读头、判空 <strong>$O(1)$</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> priorityQueue&lt;T&gt;::<span class="built_in">isempty</span>() <span class="type">const</span> &#123; <span class="keyword">return</span> length == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T priorityQueue&lt;T&gt;::<span class="built_in">getHead</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作：<strong>注意：$平均\space O(1)、最差\space O(log_2n)$</strong></p>
<blockquote>
<p>采用<strong>向上过滤法</strong>，入队到末尾，检查父结点和当前结点是否违反有序性，若是，交换并继续检查；若否，插入完成；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> priorityQueue&lt;T&gt;::<span class="built_in">enQueue</span>(<span class="type">const</span> T&amp; dt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (length == maxSize) <span class="built_in">doubleSpace</span>();</span><br><span class="line">    <span class="type">int</span> idx = length;</span><br><span class="line">    <span class="keyword">while</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[(idx - <span class="number">1</span>) / <span class="number">2</span>] &gt; dt)</span><br><span class="line">            data[idx] = data[(idx - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        idx = (idx - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data[length++] = dt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[PRIVATE] 平衡操作：<strong>注意：$平均、最坏均为\space O(log_2n)$</strong></p>
<blockquote>
<p>向下过滤，保证 n 号结点以下的所有部分满足有序性；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> priorityQueue&lt;T&gt;::<span class="built_in">percolateDown</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    T tmp = data[n]; <span class="type">int</span> next;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * n + <span class="number">1</span> &lt; length) &#123;</span><br><span class="line">        next = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (next + <span class="number">1</span> &lt; length &amp;&amp; data[next] &gt; data[next + <span class="number">1</span>]) ++next;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; data[next]) data[n] = data[next];</span><br><span class="line">        n = next;</span><br><span class="line">    &#125;</span><br><span class="line">    data[n] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队操作：<strong>注意：$平均、最坏均为\space O(log_2n)$</strong></p>
<blockquote>
<p>采用<strong>向下过滤法</strong>，将尾部元素覆盖到根结点上（为了保持堆的有序性，但同时也造成平均时间复杂度没有办法保持在线性级别），并percolateDown使得根结点以下处于平衡状态</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T priorityQueue&lt;T&gt;::<span class="built_in">deQueue</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">noElementException</span>();</span><br><span class="line">    T ans = data[<span class="number">0</span>];</span><br><span class="line">    data[<span class="number">0</span>] = data[--length];</span><br><span class="line">    <span class="built_in">percolateDown</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体创建操作：<strong>注意：$平均、最坏均为\space O(n)$，证明：$S=\sum\limits_{i=1}^h{2^{i-1}(h-i)}=N-h$</strong></p>
<blockquote>
<p>不用n次入队的方法；转换问题，为了避免递归从逆层次（最后一个非叶节点开始）向上进行平衡操作，类似动态规划，使得遍历到顶时整个列表由“完全二叉树”变为二叉堆；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">priorityQueue&lt;T&gt;::<span class="built_in">priorityQueue</span>(T* sequence, <span class="type">int</span> size) &#123;</span><br><span class="line">    maxSize = size + <span class="number">10</span>; length = size;</span><br><span class="line">    data = <span class="keyword">new</span> T[size + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        data[i] = sequence[i];</span><br><span class="line">    <span class="comment">// Build the heap.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="built_in">percolateDown</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-3-D堆、可归并堆（左堆、斜堆、二项堆）"><a href="#6-3-D堆、可归并堆（左堆、斜堆、二项堆）" class="headerlink" title="6.3 D堆、可归并堆（左堆、斜堆、二项堆）"></a>6.3 D堆、可归并堆（左堆、斜堆、二项堆）</h3><blockquote>
<p>略，在高级数据结构中详细叙述</p>
</blockquote>
<h3 id="6-4-优先级队列的应用"><a href="#6-4-优先级队列的应用" class="headerlink" title="6.4 优先级队列的应用"></a>6.4 优先级队列的应用</h3><ul>
<li><p>多柜台排队系统</p>
<blockquote>
<p>原理是：创建一个事件优先级队列，和一个普通的等待队列；先生成所有人的到达时间进队，再逐个出队，检查事件类型：是离开类型，则检查等待队列</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">创建一个事件优先级队列epQueue</span><br><span class="line">创建一个等待队列wQueue</span><br><span class="line">时间置为0</span><br><span class="line">for (循环customerNum次) &#123;</span><br><span class="line">    按指数分布（伪随机）生成顾客到达事件时间间隔dt</span><br><span class="line">    将到达事件（上一事件时间+dt）入队epQueue</span><br><span class="line">&#125;</span><br><span class="line">while (epQueue非空) &#123;</span><br><span class="line">    epQueue队头出队</span><br><span class="line">    设置当前时间为事件时间</span><br><span class="line">    if (事件类型是到达) &#123;</span><br><span class="line">        if (空闲柜台数 &gt; 0) &#123;</span><br><span class="line">            --空闲柜台数</span><br><span class="line">            生成所需服务时间st</span><br><span class="line">            将事件类型设置为离开</span><br><span class="line">            将事件时间+st</span><br><span class="line">            入队epQueue</span><br><span class="line">        &#125;</span><br><span class="line">        else 事件入队wQueue</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (等待队列非空) &#123;</span><br><span class="line">            wQueue队头出队</span><br><span class="line">            统计等待时间</span><br><span class="line">            生成服务所需时间st</span><br><span class="line">            将事件类型设置为离开</span><br><span class="line">            将事件时间+st</span><br><span class="line">            入队epQueue</span><br><span class="line">        &#125;</span><br><span class="line">        else ++空闲柜台数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">计算平均等待时间ave_t</span><br></pre></td></tr></table></figure>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SSRVodka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/review/data-structure-2/">https://blog.sjtuxhw.top/review/data-structure-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SSRVodka's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Data-Structure/">Data-Structure</a><a class="post-meta__tags" href="/tags/Tree/">Tree</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/ds2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/review/data-structure-3/" title="数据结构复习-第三部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds3.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数据结构复习-第三部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN   注：以下所有用到的键值对定义为： 12345template &lt;class KEY, class VAL&gt;struct pair &#123;    KEY key;    VAL value;&#125;; Chapter 7 集合、查找表7.1...</div></div></div></a><a class="pagination-related" href="/review/data-structure-1/" title="数据结构复习-第一部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数据结构复习-第一部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN    Chapter 1 数据结构绪论1.1 数据结构逻辑分类 集合结构：次序任意，重视归属关系； 线性结构：有序序列，有前驱、后继关系； 树状结构：层次关系，分根元素-其他元素； 图状结构：一般的逻辑结构，不限前驱和后继；  1.2 逻辑结构基本运算类型 创、清、增删改查、访问、遍历  1.3 逻辑结构的运算实现 存储结点、数据元素间关系（顺序实现、链接实现、散列实现、索引存储）、附加信息  总结：一个数据结构就是针对某一逻辑结构讨论数据的存储实现和运算实现 1.4 算法优劣因素分析 正确性、易读性、健壮性、高效率（时间、空间性能）   时间复杂度：算法所需运算量 和 问题规模 间的关系   时间复杂度因为会与被处理数据的分布有关，所以会有最好最坏和平均的说法  重要易错点：答题时注意除非说明，必须同时写上：最好、最坏、平均时间复杂度，少一个都不全面     算法运算量计算：不通用性  规定标准操作...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/review/data-structure-1/" title="数据结构复习-第一部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-15</div><div class="info-item-2">数据结构复习-第一部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN    Chapter 1 数据结构绪论1.1 数据结构逻辑分类 集合结构：次序任意，重视归属关系； 线性结构：有序序列，有前驱、后继关系； 树状结构：层次关系，分根元素-其他元素； 图状结构：一般的逻辑结构，不限前驱和后继；  1.2 逻辑结构基本运算类型 创、清、增删改查、访问、遍历  1.3 逻辑结构的运算实现 存储结点、数据元素间关系（顺序实现、链接实现、散列实现、索引存储）、附加信息  总结：一个数据结构就是针对某一逻辑结构讨论数据的存储实现和运算实现 1.4 算法优劣因素分析 正确性、易读性、健壮性、高效率（时间、空间性能）   时间复杂度：算法所需运算量 和 问题规模 间的关系   时间复杂度因为会与被处理数据的分布有关，所以会有最好最坏和平均的说法  重要易错点：答题时注意除非说明，必须同时写上：最好、最坏、平均时间复杂度，少一个都不全面     算法运算量计算：不通用性  规定标准操作...</div></div></div></a><a class="pagination-related" href="/review/data-structure-3/" title="数据结构复习-第三部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds3.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-21</div><div class="info-item-2">数据结构复习-第三部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN   注：以下所有用到的键值对定义为： 12345template &lt;class KEY, class VAL&gt;struct pair &#123;    KEY key;    VAL value;&#125;; Chapter 7 集合、查找表7.1...</div></div></div></a><a class="pagination-related" href="/review/data-structure-4/" title="数据结构复习-第四部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds4.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-27</div><div class="info-item-2">数据结构复习-第四部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN   Chapter 8 外部查找和排序8.1 零碎概念集合 内存与外存的特性：外存读取访问速率 &lt;&lt; 内存访问速率； 尽可能避免访问，宁可增加计算量……  记录：外存上的一个数据元素通常被称为一条记录；  磁道：磁盘表面储存信息的同心圆轨道；  扇区：磁盘的磁道被分为若干段，每段被称为一个扇区；  一个扇区相当于磁带上的一个数据块，也称磁盘块，是一次磁盘读写的单位；    8.2 B 树 定义：存储在外存上的动态查找表： 一棵 m 阶 B 树或者为空，或者满足：  根结点的度 $d_r\in\{0\}\space\bigcup\space[2,\space m]$；  除了根结点和叶结点外，每个结点的度 $d\in[\space\lceil\dfrac{m}{2}\rceil,\space m\space]$；  度为s（s＞0）的结点具有 n = s-1 个关键字，信息存放方式：...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="xhw-card-content"><div class="xhw-avatar-group"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="xhw-sticker"><img class="sticker-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/smile.avif" alt="emoji-sticker"/></div></div></div><div class="author-info-name">SSRVodka</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span><a class="service-status-badge" id="serviceStatusBadge" href="https://status.sjtuxhw.top" rel="external nofollow noreferrer" target="_blank"><span class="status-loading"></span><span class="status-text">loading...</span></a></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-%E6%A0%88"><span class="toc-text">Chapter 3 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%9B%B6%E7%A2%8E%E6%A6%82%E5%BF%B5%E9%9B%86%E5%90%88"><span class="toc-text">3.1 零碎概念集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2 栈的顺序实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%8F%98%E7%A7%8D%EF%BC%9A%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-text">3.3 顺序栈的变种：共享栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%A0%88%E7%9A%84%E9%93%BE%E6%8E%A5%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.4 栈的链接实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">3.5 栈的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-4-%E9%98%9F%E5%88%97"><span class="toc-text">Chapter 4 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%9B%B6%E7%A2%8E%E6%A6%82%E5%BF%B5%E9%9B%86%E5%90%88"><span class="toc-text">4.1 零碎概念集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.2 队列的顺序实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E6%8E%A5%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.3 队列的链接实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-text">4.4 队列的实际应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-text">Chapter 5 二叉树、树和森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E9%9B%86%E5%90%88"><span class="toc-text">5.1 重要概念集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-text">5.2 二叉树的重要概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.3 二叉树的存储和运算实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E4%BA%8C%E5%8F%89%E7%BA%BF%E7%B4%A2%E6%A0%91"><span class="toc-text">5.4 二叉线索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-text">5.5 哈夫曼树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">5.6 二叉树、树与森林的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-6-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-text">Chapter 6 优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E9%9B%86%E5%90%88"><span class="toc-text">6.1 重要概念集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-text">6.2 优先级队列的实现方法：树形结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-D%E5%A0%86%E3%80%81%E5%8F%AF%E5%BD%92%E5%B9%B6%E5%A0%86%EF%BC%88%E5%B7%A6%E5%A0%86%E3%80%81%E6%96%9C%E5%A0%86%E3%80%81%E4%BA%8C%E9%A1%B9%E5%A0%86%EF%BC%89"><span class="toc-text">6.3 D堆、可归并堆（左堆、斜堆、二项堆）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">6.4 优先级队列的应用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/2025-ccf/" title="CCF 2025 会议笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ccf-2025.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CCF 2025 会议笔记"/></a><div class="content"><a class="title" href="/technical/2025-ccf/" title="CCF 2025 会议笔记">CCF 2025 会议笔记</a><time datetime="2025-08-03T03:36:45.000Z" title="发表于 2025-08-03 11:36:45">2025-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/transformer.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Transformer 论文精读 + 代码实现"/></a><div class="content"><a class="title" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现">Transformer 论文精读 + 代码实现</a><time datetime="2025-07-20T15:15:10.000Z" title="发表于 2025-07-20 23:15:10">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/sc.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"/></a><div class="content"><a class="title" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</a><time datetime="2025-07-01T10:14:11.000Z" title="发表于 2025-07-01 18:14:11">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ml-roadmap.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识图谱：Machine Learning Roadmap"/></a><div class="content"><a class="title" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap">知识图谱：Machine Learning Roadmap</a><time datetime="2025-06-08T06:59:31.000Z" title="发表于 2025-06-08 14:59:31">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"/></a><div class="content"><a class="title" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</a><time datetime="2025-05-30T08:49:12.000Z" title="发表于 2025-05-30 16:49:12">2025-05-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SSRVodka  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-image"><a class="rightMenu-item" href="javascript:rmf.copyImageUrl();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制图片地址</span></a><a class="rightMenu-item" href="javascript:rmf.downloadImage();" rel="external nofollow noreferrer"><i class="fa-solid fa-download"></i><span>保存图片</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-link"><a class="rightMenu-item" href="javascript:rmf.copyLink();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制链接地址</span></a><a class="rightMenu-item" href="javascript:rmf.openLinkNewTab();" rel="external nofollow noreferrer"><i class="fa-solid fa-external-link-alt"></i><span>在新标签页打开</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script src="/js/status_badge.js"></script><script defer src="/js/console_welcome.js"></script><script async data-pjax src="/js/bsz.build-20250729.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>