<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构复习-第三部分 | SSRVodka's blog</title><meta name="author" content="SSRVodka,xhwpro@gmail.com"><meta name="copyright" content="SSRVodka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构复习-第三部分">
<meta property="og:url" content="https://blog.sjtuxhw.top/review/data-structure-3/index.html">
<meta property="og:site_name" content="SSRVodka&#39;s blog">
<meta property="og:description" content="本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/ds3.jpeg">
<meta property="article:published_time" content="2023-05-21T07:20:53.000Z">
<meta property="article:modified_time" content="2024-10-25T14:03:20.263Z">
<meta property="article:author" content="SSRVodka">
<meta property="article:tag" content="Data-Structure">
<meta property="article:tag" content="Sort">
<meta property="article:tag" content="Hash-Table">
<meta property="article:tag" content="BSTree">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/ds3.jpeg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/review/data-structure-3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构复习-第三部分',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SSRVodka's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">78</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/ds3.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SSRVodka's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构复习-第三部分</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构复习-第三部分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-21T07:20:53.000Z" title="发表于 2023-05-21 15:20:53">2023-05-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T14:03:20.263Z" title="更新于 2024-10-25 22:03:20">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/review/">review</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/review/data-structure-3/#post-comment"><span class="waline-comment-count" data-path="/review/data-structure-3/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><i><u>本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充</u></i></p>
<p><i>Written by SJTU-XHW</i></p>
<p><i>Reference: 张同珍老师 PPT | UNIkeEN</i></p>
<hr>
<span id="more"></span>
<p>注：以下所有用到的键值对定义为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">    KEY key;</span><br><span class="line">    VAL value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Chapter-7-集合、查找表"><a href="#Chapter-7-集合、查找表" class="headerlink" title="Chapter 7 集合、查找表"></a>Chapter 7 集合、查找表</h2><h3 id="7-1-集合的零碎概念总结"><a href="#7-1-集合的零碎概念总结" class="headerlink" title="7.1 集合的零碎概念总结"></a>7.1 集合的零碎概念总结</h3><ul>
<li><p>键值对（C++：pair）：由一对键、值构成的结构体，值可以有多个、可以相同；但键可以相互比较，在单重集中具有唯一性；</p>
</li>
<li><p>集合的特征：无序性（集合中元素间没有前驱后继等关系）、确定性、互异性（多重集中没有此要求，但本部分也不涉及）；</p>
</li>
<li><p>集合的建议存储方式：散列存储；</p>
</li>
<li><p>集合的基本运算形式：创、清、增（插入）删<strong>查（集合中最重要、最基本的运算）；</strong></p>
<hr>
</li>
<li><p>查找：确定指定关键字值的数据元素在查找表中是否存在；</p>
</li>
<li><p>查找表：用于查找的数据结构都称之为~；</p>
</li>
<li><p>静态查找表、动态查找表</p>
<ul>
<li>一般采用数组/线性结构存储、无需改变增删元素的查找表；</li>
<li>一般采用树形结构 / 散列结构存储、需要实时增删元素的查找表；</li>
</ul>
</li>
<li><p>内部查找、外部查找</p>
<ul>
<li>被查找元素全部存放于内存中的查找操作，称内部查找，否则称外部查找；</li>
<li><strong>内部查找以比较次数为衡量时间性能的标准；外部查找（访问速率 &lt;&lt; 比较速率）以外存访问次数为衡量时间性能的标准</strong></li>
</ul>
</li>
</ul>
<h3 id="7-2-静态查找表"><a href="#7-2-静态查找表" class="headerlink" title="7.2 静态查找表"></a>7.2 静态查找表</h3><ul>
<li><p>存储实现：一个数组 / 顺序表【表头指针、长度、规模】</p>
<blockquote>
<p>小特性：可以从后向前查找成功返回下标，失败返回-1</p>
</blockquote>
</li>
<li><p>运算实现：<strong>静态查找表因为其特性，仅关心查找运算</strong></p>
<ul>
<li>无序表的查找运算：顺序查找<strong>$O(n)$</strong></li>
</ul>
<blockquote>
<p>甚至为了减少比较次数，牺牲list[0]作为“哨兵”，每次查找前将target放入list[0]，这样一定能找到，并且如果停止在0上，则未找到；停止在其他序列上就找到了</p>
</blockquote>
<ul>
<li>有序表的查找运算：顺序查找、<strong>二分查找（$O(log\space n)$）</strong>、插值查找、分块查找；<ul>
<li>分块查找一定注意概念：先查找<strong>索引表（含有块内最大关键字、块起始地址）</strong>，再在块内使用顺序 / 二分查找（取决于是不是有序的）；</li>
</ul>
</li>
</ul>
<blockquote>
<p>提示：本部分对代码考察较少，一般考察查找次数分析、时间复杂度分析；</p>
</blockquote>
</li>
<li><p>例题观赏</p>
<ul>
<li><p>证明：分块查找的块大小为 <strong>$m=\sqrt{n}$</strong> 时（n为总元素个数），分块查找的平均时间性能最佳为<strong>$O(\sqrt{n})$</strong>；</p>
<script type="math/tex; mode=display">
\begin{aligned}
&假设表长为\space n,\space 被分为\space m\space 块,平均每块有\space \dfrac{n}{m}\space个元素;\\
&再假定索引、块内均采用顺序查找方法;\\
&则平均情况下查找次数=\dfrac{1}{m}\sum\limits_{i=1}^{m}{i}+\dfrac{1}{\cfrac{n}{m}}\sum\limits_{j=1}^{\cfrac{n}{m}}j=\dfrac{1}{2}(m+\dfrac{n}{m})+1\\
&由基本不等式可知,\space当且仅当\space m=\sqrt{n}\space时取最小值\sqrt{n}+1,\space故时间复杂度O(\sqrt{n})
\end{aligned}</script></li>
<li><p>对于一个长度为3的顺序表查找，目标是第一个元素的概率是<strong>$\dfrac{1}{2}$</strong>，目标是第二个元素的概率是<strong>$\dfrac{1}{3}$</strong>，目标是第三个元素的概率是<strong>$\dfrac{1}{6}$</strong>，问顺序查找（从前往后）的平均查找长度；若该表同时满足有序性，问二分查找的平均查找长度；</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\overline{sLen}_{seq}=1\times\dfrac{1}{2}+2\times\dfrac{1}{3}+3\times\dfrac{1}{6}=\dfrac{5}{3}\\
&\overline{sLen}_{bin}=1\times\dfrac{1}{3}+2\times(\dfrac{1}{2}+\dfrac{1}{6})=\dfrac{5}{3}\\
\end{aligned}</script></li>
</ul>
</li>
</ul>
<h3 id="7-3-动态查找表"><a href="#7-3-动态查找表" class="headerlink" title="7.3 动态查找表"></a>7.3 动态查找表</h3><blockquote>
<p>考虑所有的线性结构均不合适：顺序存储=&gt;插入删除不利；链表=&gt;查找只能顺序；</p>
<p>解决方案：</p>
<ul>
<li>查找树：处理动态查找表的树型结构；</li>
<li>散列表：专用于集合查找的数据结构；</li>
</ul>
</blockquote>
<h4 id="7-3-1-二叉查找树"><a href="#7-3-1-二叉查找树" class="headerlink" title="7.3.1 二叉查找树"></a>7.3.1 二叉查找树</h4><ul>
<li><p>定义：或者是一棵空树，或者是一棵同时满足以下条件的<strong>二叉树</strong>：</p>
<ul>
<li><p>左子树不空时，<strong>左子树上所有元素</strong>的键值小于根结点的键值（右子树同理）；</p>
</li>
<li><p>它的左右子树也都是二叉查找树；</p>
</li>
</ul>
<blockquote>
<p>引申结论：<strong>一棵二叉查找树的中序序列是按键值递增排序的序列（所以二叉查找树又称<u>二叉排序树</u>）</strong></p>
</blockquote>
<p><strong>⚠极易错误的点：是左右子树上所有的点都满足键值大小关系！！！不仅仅是左右结点满足这个关系。</strong></p>
<p><strong>例如：“设计程序检查二叉树是否为一个二叉查找树”，应该利用中序序列的特性，初始化一个最小数据值，中序遍历同时判断；而不应该只是简单地判断当前结点、左右子结点的值关系</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBSTree</span><span class="params">(node&lt;T&gt;* cur)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> T minData;</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isBSTree</span>(cur-&gt;left) || cur-&gt;data &lt; minData)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    minData = cur-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isBSTree</span>(cur-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储实现：二叉树的标准存储法【根结点】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binSearchTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        pair&lt;KEY, VAL&gt; data;</span><br><span class="line">        node* left;</span><br><span class="line">        node* right;</span><br><span class="line">        <span class="built_in">node</span>(): <span class="built_in">left</span>(<span class="number">0</span>), <span class="built_in">right</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">node</span>(pair&lt;KEY, VAL&gt; p, node* L=<span class="number">0</span>, node* R=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">data</span>(p), <span class="built_in">left</span>(L), <span class="built_in">right</span>(R) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node* root;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">binSearchTree</span>();</span><br><span class="line">    ~<span class="built_in">binSearchTree</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;KEY, VAL&gt; dt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> KEY&amp; k)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;KEY, VAL&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> KEY&amp; k)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运算实现</p>
<p>创建删除运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">binSearchTree</span>() &#123; root = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">clear</span>(node*&amp; target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">clear</span>(target-&gt;left);</span><br><span class="line">    <span class="built_in">clear</span>(target-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> target; target = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">binSearchTree&lt;KEY, VAL&gt;::~<span class="built_in">binSearchTree</span>() &#123; <span class="built_in">clear</span>(root); &#125;</span><br></pre></td></tr></table></figure>
<p>查找运算 <strong>$O(log\space n)-O(log\space n)-O(n)$</strong>，推导平均情况：（有n种形态：左0右n-1、左2右n-2、……、左n-1右0，最后包括根结点）</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(n)&=\dfrac{1}{n^2}\sum\limits_{i=0}^{n-1}[1+(P(i)+1)\times i+(P(n-i-1)+1)\times(n-i-1)]\\
&\le2(1+\dfrac{1}{n})\space ln\space n\space\sim1.38\space log\space n\\
\end{aligned}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归既省时又省空间，用递归系统栈的开销就大啦</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">pair&lt;KEY, VAL&gt;* binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">find</span>(<span class="type">const</span> KEY&amp; k) <span class="type">const</span> &#123;</span><br><span class="line">    node* cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;data.key != k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data.key &gt; k) cur = cur-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cur ? &amp;(cur-&gt;data) : <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入运算 <strong>$O(log\space n)，实际相当于查找时间复杂度$</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt, node*&amp; target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) target = <span class="keyword">new</span> <span class="built_in">node</span>(dt);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;data.key &lt; dt.key)</span><br><span class="line">        <span class="built_in">insert</span>(dt, target-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;data.key &gt; dt.key)</span><br><span class="line">        <span class="built_in">insert</span>(dt, target-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt) &#123;</span><br><span class="line">    <span class="built_in">insert</span>(dt, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 非递归法1，这里二阶指针不能用引用代替！否则会把root值改变！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt) &#123;</span><br><span class="line">    node** cur = &amp;root;</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;data.key != dt.key) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*cur)-&gt;data.key &gt; dt.key) cur = &amp;((*cur)-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> cur = &amp;((*cur)-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(*cur)) *cur = <span class="keyword">new</span> <span class="built_in">node</span>(dt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归法2，除了用自身二阶指针保存外，更易懂的还可以用前后指针保存</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123; root = <span class="keyword">new</span> <span class="built_in">node</span>(dt); <span class="keyword">return</span>; &#125;</span><br><span class="line">    node* pre, cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;data.key != dt.key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data.key &gt; dt.key) cur = cur-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;left == cur) pre-&gt;left = <span class="keyword">new</span> <span class="built_in">node</span>(dt);</span><br><span class="line">        <span class="keyword">else</span> pre-&gt;right = <span class="keyword">new</span> <span class="built_in">node</span>(dt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除运算 <strong>$O(log\space n)，实际相当于查找时间复杂度$</strong>，注意需要在右子树中找最小 / 左子树中找最大结点作为替身再删除；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅展示递归法，非递归法可由插入运算同理得</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">remove</span>(<span class="type">const</span> KEY&amp; k, node*&amp; target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (target-&gt;data.key &lt; k) <span class="built_in">remove</span>(k, target-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;data.key &gt; k) <span class="built_in">remove</span>(k, target-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target-&gt;left &amp;&amp; target-&gt;right) &#123;</span><br><span class="line">        node* sub = target-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (sub-&gt;left) sub = sub-&gt;left;</span><br><span class="line">        target-&gt;data = sub-&gt;data;</span><br><span class="line">        <span class="built_in">remove</span>(sub-&gt;data.key, target-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="comment">// 思考为何度为1和度为0的结点情况可以合并</span></span><br><span class="line">        node* tmp = target;</span><br><span class="line">        target = (target-&gt;left ? target-&gt;left : target-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> binSearchTree&lt;KEY, VAL&gt;::<span class="built_in">remove</span>(<span class="type">const</span> KEY&amp; k) &#123;</span><br><span class="line">    <span class="built_in">remove</span>(k, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-3-2-AVL树：平衡的二叉查找树"><a href="#7-3-2-AVL树：平衡的二叉查找树" class="headerlink" title="7.3.2 AVL树：平衡的二叉查找树"></a>7.3.2 AVL树：平衡的二叉查找树</h4><ul>
<li>平衡条件左右子树高度差不大于 1（也即<strong>平衡因子不大于1</strong>）<ul>
<li>对二叉查找树应用该平衡条件的原因：限制二叉查找树高度在对数级，避免退化为链表；</li>
<li>AVL 树的平衡性大于普通二叉查找树，小于完全二叉树；</li>
</ul>
</li>
</ul>
<blockquote>
<p>了解即可：AVL树对数级高度的理论依据</p>
<script type="math/tex; mode=display">
\begin{aligned}
&设\space S_H\space是高度为\space H\space的最小的AVL树规模，则:\\
&S_H=\begin{equation}\left\{\begin{aligned}&\qquad\quad1,&H=1\\&\qquad\quad2,&H=2\\&S_{H-1}+S_{H-2}+1,\space&H\ge3\\\end{aligned}\right.\end{equation}
\end{aligned}
\Longrightarrow S_H\approx\dfrac{\sqrt{5}}{5}(\dfrac{1+\sqrt{5}}{2})^{H+2}-1\le N</script><script type="math/tex; mode=display">
故:\space H\le1.44\space log_2(N+1)-0.328</script></blockquote>
<ul>
<li><p>AVL树存储实现：二叉树的标准存储法 + 结点类高度字段【根结点】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        pair&lt;KEY, VAL&gt; data;</span><br><span class="line">        node* left;</span><br><span class="line">        node* right;</span><br><span class="line">        <span class="type">int</span> height;</span><br><span class="line">        <span class="built_in">node</span>(): <span class="built_in">left</span>(<span class="number">0</span>), <span class="built_in">right</span>(<span class="number">0</span>), <span class="built_in">height</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">node</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt, node* L=<span class="number">0</span>, node* R=<span class="number">0</span>, <span class="type">int</span> h=<span class="number">1</span>)</span><br><span class="line">            : <span class="built_in">data</span>(dt), <span class="built_in">left</span>(L), <span class="built_in">right</span>(R), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node* root;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(node* target)</span> </span>&#123; <span class="keyword">return</span> (target ? target-&gt;height : <span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RR</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LL</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RL</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LR</span><span class="params">(node*&amp; target)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AVLTree</span>();</span><br><span class="line">    ~<span class="built_in">AVLTree</span>();</span><br><span class="line">    <span class="function">pair&lt;KEY, VAL&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> KEY&amp; k)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> KEY&amp; k)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AVL树失衡分析</p>
<blockquote>
<p>AVL树与二叉查找树不同的是，在插入、删除后需要修正树的平衡性，下面讨论这两种操作如何修正平衡性；</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="AVL.jpg"></p>
</li>
<li><p>AVL树运算实现</p>
<p>创建、删除操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">AVLTree&lt;KEY, VAL&gt;::<span class="built_in">AVLTree</span>() &#123; root = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">clear</span>(node*&amp; target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">clear</span>(target-&gt;left);</span><br><span class="line">    <span class="built_in">clear</span>(target-&gt;left);</span><br><span class="line">    <span class="keyword">delete</span> target; target = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">AVLTree&lt;KEY, VAL&gt;::~<span class="built_in">AVLTree</span>() &#123; <span class="built_in">clear</span>(root); &#125;</span><br></pre></td></tr></table></figure>
<p>查找操作 <strong>$O(log\space n)$</strong>，写法同二叉查找树，但最坏时间性能好于二叉查找树；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">pair&lt;KEY, VAL&gt;* AVLTree&lt;KEY, VAL&gt;::<span class="built_in">find</span>(<span class="type">const</span> KEY&amp; k) <span class="type">const</span> &#123;</span><br><span class="line">    pair&lt;KEY, VAL&gt;* cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;data != k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data.key &gt; k) cur = cur-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cur ? &amp;(cur-&gt;data) : <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[PRIVATE] 调整操作 <strong>$O(1)$</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">LL</span>(node*&amp; target) &#123;</span><br><span class="line">    node* post = target-&gt;left;</span><br><span class="line">    target-&gt;left = post-&gt;right;</span><br><span class="line">    post-&gt;right = target;</span><br><span class="line">    <span class="type">int</span> hLeft = <span class="built_in">height</span>(target-&gt;left), hRight = <span class="built_in">height</span>(target-&gt;right);</span><br><span class="line">    target-&gt;height = (hLeft &gt; hRight ? hLeft : hRight) + <span class="number">1</span>;</span><br><span class="line">    hLeft = <span class="built_in">height</span>(post-&gt;left);</span><br><span class="line">    post-&gt;height = (hLeft &gt; target-&gt;height ? hLeft : target-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    target = post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">RR</span>(node*&amp; target) &#123;</span><br><span class="line">    node* post = target-&gt;right;</span><br><span class="line">    target-&gt;right = post-&gt;left;</span><br><span class="line">    post-&gt;left = target;</span><br><span class="line">    <span class="type">int</span> hLeft = <span class="built_in">height</span>(target-&gt;left), hRight = <span class="built_in">height</span>(target-&gt;right);</span><br><span class="line">    target-&gt;height = (hLeft &gt; hRight ? hLeft : hRight) + <span class="number">1</span>;</span><br><span class="line">    hRight = <span class="built_in">height</span>(post-&gt;right);</span><br><span class="line">    post-&gt;height = (target-&gt;height &gt; hRight ? target-&gt;height : hRight) + <span class="number">1</span>;</span><br><span class="line">    target = post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">LR</span>(node*&amp; target) &#123;</span><br><span class="line">    <span class="built_in">RR</span>(target-&gt;left); <span class="built_in">LL</span>(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">RL</span>(node*&amp; target) &#123;</span><br><span class="line">    <span class="built_in">LL</span>(target-&gt;right); <span class="built_in">RR</span>(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入操作 <strong>$O(log\space n)$</strong>，插入前部分与二叉查找树相同，另需回溯维持平衡；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归法，需要使用到前章节的栈类seqStack；显然可以知道递归方法怎么写，略</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123; root = <span class="keyword">new</span> <span class="built_in">node</span>(dt); <span class="keyword">return</span>; &#125;</span><br><span class="line">    seqStack&lt;node**&gt; hist; node** tmp = <span class="literal">NULL</span>;</span><br><span class="line">    hist.<span class="built_in">push</span>(&amp;root);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        tmp = hist.<span class="built_in">pop</span>(); hist.<span class="built_in">push</span>(tmp); <span class="keyword">if</span> (!(*tmp)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((*tmp)-&gt;data.key &gt; dt.key) hist.<span class="built_in">push</span>(&amp;((*tmp)-&gt;left));</span><br><span class="line">        <span class="keyword">else</span> hist.<span class="built_in">push</span>(&amp;((*tmp)-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = hist.<span class="built_in">pop</span>(); *tmp = <span class="keyword">new</span> <span class="built_in">node</span>(dt);</span><br><span class="line">    <span class="keyword">while</span> (!hist.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        node** cur = hist.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> hLeft = <span class="built_in">height</span>((*cur)-&gt;left),</span><br><span class="line">            hRight = <span class="built_in">height</span>((*cur)-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (hLeft - hRight &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>((*cur)-&gt;left-&gt;left) &gt; <span class="built_in">height</span>(*cur)-&gt;left-&gt;right)</span><br><span class="line">                &#123; <span class="built_in">LL</span>(*cur); <span class="keyword">return</span>; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="built_in">LR</span>(*cur); <span class="keyword">return</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hRight - hLeft &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>((*cur)-&gt;right-&gt;right) &gt; <span class="built_in">height</span>((*cur)-&gt;right-&gt;left))</span><br><span class="line">                &#123; <span class="built_in">RR</span>(*cur); <span class="keyword">return</span>; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="built_in">RL</span>(*cur); <span class="keyword">return</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> (*cur)-&gt;height = (hLeft &gt; hRight ? hLeft : hRight) + <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除操作 <strong>$O(log\space n)$</strong>，与二叉查找树的删除前部分相同，后部分需要调整平衡；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归法，需要使用到前章节的栈类seqStack；显然可以知道递归方法怎么写，略</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;KEY, VAL&gt;::<span class="built_in">remove</span>(<span class="type">const</span> KEY&amp; k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    seqStack&lt;node**&gt; hist; KEY target = k;</span><br><span class="line">    node** tmp = &amp;root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        hist.<span class="built_in">push</span>(tmp); <span class="keyword">if</span> (!(*tmp)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> ((*tmp)-&gt;data.key &lt; target) tmp = &amp;((*tmp)-&gt;right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((*tmp)-&gt;data.key &gt; target) tmp = &amp;((*tmp)-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> &#123;    <span class="comment">// 找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span> ((*tmp)-&gt;left &amp;&amp; (*tmp)-&gt;right) &#123; <span class="comment">// 要删除结点的度为2</span></span><br><span class="line">                node* sub = (*tmp)-&gt;right;</span><br><span class="line">                <span class="keyword">while</span> (sub) sub = sub-&gt;left;</span><br><span class="line">                (*tmp)-&gt;data = sub-&gt;data; target = sub-&gt;data.key;</span><br><span class="line">                tmp = &amp;((*tmp)-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;    <span class="comment">// 要删除结点的度小于2</span></span><br><span class="line">                node* rn = *tmp;</span><br><span class="line">                *tmp = ((*tmp)-&gt;left ? (*tmp)-&gt;left : (*tmp)-&gt;right);</span><br><span class="line">                <span class="keyword">delete</span> rn; hist.<span class="built_in">pop</span>(); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!hist.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        tmp = hist.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> newLH = <span class="built_in">height</span>((*tmp)-&gt;left), newRH = <span class="built_in">height</span>((*tmp)-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (newLH - newRH &gt; <span class="number">1</span>) &#123;    <span class="comment">// 高度改变且失衡</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>((*tmp)-&gt;left-&gt;left) &gt; <span class="built_in">height</span>((*tmp)-&gt;left-&gt;right)) <span class="built_in">LR</span>(*tmp);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">LL</span>(*tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newRH - newLH &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>((*tmp)-&gt;right-&gt;right) &lt; <span class="built_in">height</span>((*tmp)-&gt;right-&gt;left)) <span class="built_in">RL</span>(*tmp);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">RR</span>(*tmp);</span><br><span class="line">        &#125;    <span class="comment">// 高度未改变且未失衡</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newRH - newLH == <span class="number">1</span> || newLH - newRH == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 剩下情况是高度改变但未失衡，或者失衡调整后：需要更新高度</span></span><br><span class="line">        (*tmp)-&gt;height = (<span class="built_in">height</span>((*tmp)-&gt;left) &gt; <span class="built_in">height</span>((*tmp)-&gt;right)</span><br><span class="line">                          ? <span class="built_in">height</span>((*tmp)-&gt;left) : <span class="built_in">height</span>((*tmp)-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-3-3-散列表"><a href="#7-3-3-散列表" class="headerlink" title="7.3.3 散列表"></a>7.3.3 散列表</h4><blockquote>
<p>思路：将关键字对应的数据元素存储在指定位置，这个位置由关键字值运算（hash函数）映射出来。这样意味着一般情况下具有线性的查找时间；</p>
</blockquote>
<ul>
<li><p>散列表的存储实现：闭散列表—数组【表头指针、规模】；开散列表—链表数组【指针数组头、规模】；</p>
<blockquote>
<p>主要问题：散列函数设计尽量避免碰撞、碰撞问题解决；</p>
</blockquote>
</li>
<li><p>散列函数设计</p>
<ul>
<li><p>直接定址法：线性映射，适用于数据本身分布均匀，且在同一数量级中；</p>
<p><strong>$H(x)=ax+b$</strong></p>
</li>
<li><p>除留取余法：取余函数；</p>
<p><strong>$H(x)=a\space mod\space M.\space经验表明，M为素数时，分布较为均匀$</strong></p>
</li>
<li><p>数字分析法：根据数字实际特性确定哪些位作为散列函数的参数来映射；</p>
</li>
<li><p>平方取中法：适用于关键字数据各个位数上分布均匀，且关键字值域大于数组规模，可以用关键字的平方，再取中间几位（和每一位数都有关系）；</p>
</li>
<li><p>折叠法：适用于关键字长 &gt;&gt; 散列表规模的情况，按每N位折叠再相加生成；</p>
</li>
</ul>
</li>
<li><p>碰撞解决方案</p>
<ul>
<li><p>闭散列表（迟删除={空，活动，删除}）：</p>
<p>&#8618; 线性探测法（向后+1移动至空位置/已删除位置）；</p>
<p>&#8618; 二次探测法（探测 <strong>$H+i^2$</strong> 单位，数学上可以处理为前一个索引基础上 + (2i - 1)，能解决线性探测的初始聚集问题）；</p>
<p>&#8618; 再散列法使用两个散列函数H1、H2，H1计算应该处于的起始位置，H2计算碰撞后下一个探测的位置的步长：H1(x)、(H1(x)+H2(x)) mod M、……、(H1(x)+k H2(x)) mod M；</p>
</li>
<li><p>开散列表：拉链法，天然不存在碰撞问题；</p>
</li>
</ul>
</li>
<li><p>闭散列表可能存在的问题和优化建议</p>
<ul>
<li>如果选择除留取余作为hash函数，需要尽量保证数组长度（哪怕扩容）是素数；</li>
<li>负载因子（<strong>非空单元比例</strong>）过高可能会导致查找等操作时间性能下降，需要及时检查、清理迟删除的元素、进行扩容（涉及重散列）；</li>
</ul>
</li>
<li><p>实现示例（看看就好）：以除留取余作为hash函数、闭散列表针对上面2个问题已优化；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hash method: dividing the residual method.</span></span><br><span class="line"><span class="comment">// The solution to Hash Collision: linear detecting.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">closeHashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hashNode</span> &#123;</span><br><span class="line">        pair&lt;KEY, VAL&gt; data;</span><br><span class="line">        <span class="comment">// 0: empty, 1: active; 2: deleted</span></span><br><span class="line">        <span class="type">int</span> state;</span><br><span class="line">        <span class="built_in">hashNode</span>(): <span class="built_in">state</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">hashNode</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; dt, <span class="type">int</span> s=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">data</span>(dt), <span class="built_in">state</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> empty;</span><br><span class="line">    <span class="type">int</span> deleted;</span><br><span class="line">    hashNode* array;</span><br><span class="line">    <span class="built_in">int</span> (*key2int)(<span class="type">const</span> KEY&amp; key);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">defaultK2int</span><span class="params">(<span class="type">const</span> KEY&amp; k)</span> </span>&#123; <span class="keyword">return</span> k; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">minPrime</span><span class="params">(<span class="type">int</span> min)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the rate of the deleted nodes.</span></span><br><span class="line">    <span class="comment">// Return true if over half of the nodes is in deleted state.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkDeleted</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (deleted &gt; size / <span class="number">2</span>); &#125;</span><br><span class="line">    <span class="comment">// Check the rate of the active nodes.</span></span><br><span class="line">    <span class="comment">// Return true if the load factor is greater than 0.5.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkActive</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (empty + deleted &lt; size / <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash the hash table to improve its performance.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reHash</span><span class="params">(<span class="type">bool</span> expand=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">closeHashTable</span>(<span class="type">int</span> capacity=<span class="number">13</span>, <span class="built_in">int</span> (*k2int)(<span class="type">const</span> KEY&amp;)=defaultK2int);</span><br><span class="line">    ~<span class="built_in">closeHashTable</span>();</span><br><span class="line">    <span class="function">pair&lt;KEY, VAL&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> KEY&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; s)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> KEY&amp; key)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">int</span> closeHashTable&lt;KEY, VAL&gt;::<span class="built_in">minPrime</span>(<span class="type">int</span> min) &#123;</span><br><span class="line">    <span class="keyword">if</span> (min % <span class="number">2</span> == <span class="number">0</span>) ++min;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = min;; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">3</span>; j * j &lt;= min; j += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123; flag = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">closeHashTable&lt;KEY, VAL&gt;::<span class="built_in">closeHashTable</span>(<span class="type">int</span> capacity, <span class="built_in">int</span> (*k2int)(<span class="type">const</span> KEY&amp;)) &#123;</span><br><span class="line">    size = <span class="built_in">minPrime</span>(capacity);</span><br><span class="line">    array = <span class="keyword">new</span> hashNode[size];</span><br><span class="line">    key2int = k2int;</span><br><span class="line">    empty = size; deleted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">closeHashTable&lt;KEY, VAL&gt;::~<span class="built_in">closeHashTable</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (array) <span class="keyword">delete</span>[] array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">pair&lt;KEY, VAL&gt;* closeHashTable&lt;KEY, VAL&gt;::<span class="built_in">find</span>(<span class="type">const</span> KEY&amp; key) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// Why we need initPos: when the array is fully occupied, we need</span></span><br><span class="line">    <span class="comment">// to know if we have traversed the array.</span></span><br><span class="line">    <span class="type">int</span> initPos, pos;</span><br><span class="line">    initPos = pos = <span class="built_in">key2int</span>(key) % size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[pos].state == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[pos].state == <span class="number">1</span> &amp;&amp; array[pos].data.key == key)</span><br><span class="line">            <span class="keyword">return</span> &amp;(array[pos].data);</span><br><span class="line">        <span class="comment">// Attention: state == -1 means delay delete,</span></span><br><span class="line">        <span class="comment">// which means keeping searching.</span></span><br><span class="line">        pos = (pos + <span class="number">1</span>) % size;</span><br><span class="line">    &#125; <span class="keyword">while</span> (initPos != pos);</span><br><span class="line">    <span class="comment">// The array is full and we can&#x27;t find the data with &#x27;key&#x27;.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> closeHashTable&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkActive</span>()) <span class="built_in">reHash</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> initPos, pos;</span><br><span class="line">    initPos = pos = <span class="built_in">key2int</span>(s.key) % size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Attention: we can overwrite the deleted entry(state=2).</span></span><br><span class="line">        <span class="keyword">if</span> (array[pos].state != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// (array[pos].state ? --deleted : --empty);</span></span><br><span class="line">            <span class="keyword">if</span> (array[pos].state) --deleted;</span><br><span class="line">            <span class="keyword">else</span> --empty;</span><br><span class="line">            array[pos].data = s;</span><br><span class="line">            array[pos].state = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = (pos + <span class="number">1</span>) % size;</span><br><span class="line">    &#125; <span class="keyword">while</span> (initPos != pos);</span><br><span class="line">    <span class="comment">// Warning: the array is full.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> closeHashTable&lt;KEY, VAL&gt;::<span class="built_in">remove</span>(<span class="type">const</span> KEY&amp; key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkDeleted</span>()) <span class="built_in">reHash</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> initPos, pos;</span><br><span class="line">    initPos = pos = <span class="built_in">key2int</span>(key) % size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Save time.</span></span><br><span class="line">        <span class="keyword">if</span> (array[pos].state == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[pos].state == <span class="number">1</span> &amp;&amp; array[pos].data.key == key) &#123;</span><br><span class="line">            array[pos].state = <span class="number">2</span>; ++deleted; <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = (pos + <span class="number">1</span>) % size;</span><br><span class="line">    &#125; <span class="keyword">while</span> (initPos != pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> closeHashTable&lt;KEY, VAL&gt;::<span class="built_in">reHash</span>(<span class="type">bool</span> expand) &#123;</span><br><span class="line">    hashNode* tmp = array;</span><br><span class="line">    <span class="type">int</span> oldSize = size;</span><br><span class="line">    size = (expand ? <span class="built_in">minPrime</span>(<span class="number">2</span>*size) : size);</span><br><span class="line">    array = <span class="keyword">new</span> hashNode[size];</span><br><span class="line">    empty = size; deleted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; oldSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp[i].state == <span class="number">1</span>) <span class="built_in">insert</span>(tmp[i].data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">openHashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hashNode</span> &#123;</span><br><span class="line">        pair&lt;KEY, VAL&gt; data;</span><br><span class="line">        hashNode* next;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">hashNode</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; s, hashNode* n=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">data</span>(s), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    hashNode** hashTable;</span><br><span class="line">    <span class="built_in">int</span> (*key2int)(<span class="type">const</span> KEY&amp; key);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">defaultK2int</span><span class="params">(<span class="type">const</span> KEY&amp; key)</span> </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">openHashTable</span>(<span class="type">int</span> initSize=<span class="number">101</span>, <span class="built_in">int</span> (*k2int)(<span class="type">const</span> KEY&amp; k)=defaultK2int);</span><br><span class="line">    ~<span class="built_in">openHashTable</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> KEY&amp; key)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;KEY, VAL&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> KEY&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">openHashTable&lt;KEY, VAL&gt;::<span class="built_in">openHashTable</span>(<span class="type">int</span> initSize, <span class="built_in">int</span> (*k2int)(<span class="type">const</span> KEY&amp; k)) &#123;</span><br><span class="line">    size = initSize;</span><br><span class="line">    hashTable = <span class="keyword">new</span> hashNode*[size] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    key2int = k2int;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">openHashTable&lt;KEY, VAL&gt;::~<span class="built_in">openHashTable</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (hashTable[i]) &#123;</span><br><span class="line">            hashNode* tmp = hashTable[i];</span><br><span class="line">            hashTable[i] = hashTable[i]-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] hashTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> openHashTable&lt;KEY, VAL&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;KEY, VAL&gt;&amp; x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(x.key)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">key2int</span>(x.key) % size;</span><br><span class="line">    hashTable[idx] = <span class="keyword">new</span> <span class="built_in">hashNode</span>(x, hashTable[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line"><span class="type">void</span> openHashTable&lt;KEY, VAL&gt;::<span class="built_in">remove</span>(<span class="type">const</span> KEY&amp; key) &#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">key2int</span>(key) % size;</span><br><span class="line">    hashNode* cur = hashTable[idx];</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;data.key != key)</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (!(cur-&gt;next)) <span class="keyword">return</span>;</span><br><span class="line">    hashNode* tmp = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>, <span class="keyword">class</span> <span class="title class_">VAL</span>&gt;</span><br><span class="line">pair&lt;KEY, VAL&gt;* openHashTable&lt;KEY, VAL&gt;::<span class="built_in">find</span>(<span class="type">const</span> KEY&amp; key) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">key2int</span>(key) % size;</span><br><span class="line">    hashNode* cur = hashTable[idx];</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;data.key != key)</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> &amp;(cur-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Chapter-8-排序"><a href="#Chapter-8-排序" class="headerlink" title="Chapter 8 排序"></a>Chapter 8 排序</h2><h3 id="8-1-零碎概念集合"><a href="#8-1-零碎概念集合" class="headerlink" title="8.1 零碎概念集合"></a>8.1 零碎概念集合</h3><ul>
<li>内排序和外排序：数据规模、数据存放位置、算法优化要求不一样；</li>
<li>排序算法的稳定性：集合中相同关键字值的元素在排序后，这些元素的相对次序不变，则称这种算法是稳定的；反之是不稳定的；（从现在开始，除非标明不稳定，其余都是稳定的）</li>
<li>常见应用：集合排序（便于查找）、查找序列中的重复元素；</li>
</ul>
<blockquote>
<p>注：本章排序算法以递增序列为目标；</p>
</blockquote>
<h3 id="8-2-插入排序"><a href="#8-2-插入排序" class="headerlink" title="8.2 插入排序"></a>8.2 插入排序</h3><h4 id="8-2-1-直接插入排序"><a href="#8-2-1-直接插入排序" class="headerlink" title="8.2.1 直接插入排序"></a>8.2.1 直接插入排序</h4><blockquote>
<p>每个外围循环将 a[i] 插入 a[0]~a[i-1] 的序列中，<strong>从后向前比较交换</strong></p>
<p><strong>如果数据是一个一个输入的（不同时间），那么直接插入排序是一个极好的选择</strong></p>
</blockquote>
<p>时间复杂度分析：</p>
<ul>
<li>最坏：a[j] 比较 j 次、a[j] 交换 j + 2 次，故<strong>$O(n^2)$</strong></li>
<li>最好<strong>$O(n)$</strong>、平均<strong>$O(n^2)$</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简化逻辑结构、方便应用，代码中将直接用键KEY来替换pair键值对的排序，下同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simpleInsertSort</span><span class="params">(KEY seq[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        KEY pre = seq[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[j] &gt; pre) seq[j + <span class="number">1</span>] = seq[j];</span><br><span class="line">            <span class="keyword">else</span> &#123; seq[j + <span class="number">1</span>] = pre; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-2-2-二分插入排序"><a href="#8-2-2-二分插入排序" class="headerlink" title="8.2.2 二分插入排序"></a>8.2.2 二分插入排序</h4><blockquote>
<p>将直接插入的比较改为二分查找，并没有改变时间复杂度；</p>
</blockquote>
<h4 id="8-2-3-希尔排序（不稳定）"><a href="#8-2-3-希尔排序（不稳定）" class="headerlink" title="8.2.3 希尔排序（不稳定）"></a>8.2.3 希尔排序（不稳定）</h4><blockquote>
<p>选定增量序列 {h1=1, h2, …, ht}，对待排序列进行 ht-排序、……、h2-排序、h1-排序；</p>
<ul>
<li>每个 hk-排序使用直接插入排序；</li>
<li>shell 他本人建议增量序列取定：N/2 -&gt; N/4 -&gt; …… -&gt; 1；</li>
<li>理论依据：<strong>hk-有序数组经过 h(k-1)-排序后仍然有序</strong>；</li>
</ul>
</blockquote>
<p>时间复杂度分析：</p>
<ul>
<li>对于增量序列 <strong>$\{\dfrac{N}{2},\space\dfrac{N}{4},\space…,\space1\}$</strong>（或者间距序列为 <strong>$H= \{ 2^k-1\mid k=1,2,\ldots,\lfloor\log_2 n\rfloor \}$</strong>(从大到小）)，时间复杂度为<strong>$O(n^{\tfrac{3}{2}})$</strong> ；</li>
<li>对于间距序列<strong>$H= \{ k=2^p\cdot 3^q\mid p,q\in \mathbb N,k\le n \}$</strong>（从大到小），时间复杂度<strong>$O(n\space log^2 n)$</strong></li>
<li>有兴趣参阅证明过程，请移步：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://oi-wiki.org/basic/shell-sort/#时间复杂度">希尔排序 - OI Wiki (oi-wiki.org)</a></li>
<li>总体的移动次数（对所有增量序列）：<strong>$n^{1.25}\sim 1.6n^{1.25}\Longrightarrow O(n^{1.25})$</strong>；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(KEY seq[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> step = size / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 对每个子序列进行直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = step; i &lt; size; ++i) &#123;</span><br><span class="line">            pre = seq[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seq[j] &gt; pre) seq[j + <span class="number">1</span>] = seq[j];</span><br><span class="line">                <span class="keyword">else</span> &#123; seq[j + <span class="number">1</span>] = pre; <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-选择排序"><a href="#8-3-选择排序" class="headerlink" title="8.3 选择排序"></a>8.3 选择排序</h3><h4 id="8-3-1-直接选择排序（特定条件下不稳定）"><a href="#8-3-1-直接选择排序（特定条件下不稳定）" class="headerlink" title="8.3.1 直接选择排序（特定条件下不稳定）"></a>8.3.1 直接选择排序（特定条件下不稳定）</h4><blockquote>
<p>从未排序部分<strong>顺序查找</strong>出一个最大/最小元素，与未排序部分的末尾交换，以增长排序部分；</p>
<p>不稳定的、平方时间复杂度的简单算法，导致它仅常用于一些小规模的排序中；</p>
</blockquote>
<p>时间复杂度分析：最好、最坏、平均：<strong>$O(n^2)$</strong>；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simpleSelectSort</span><span class="params">(KEY seq[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> minIdx = i; KEY minVal = seq[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[j] &lt; minVal) &#123;</span><br><span class="line">                minIdx = j; minVal = seq[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        seq[minIdx] = seq[i];</span><br><span class="line">        seq[i] = minVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-2-堆排序（不稳定）"><a href="#8-3-2-堆排序（不稳定）" class="headerlink" title="8.3.2 堆排序（不稳定）"></a>8.3.2 堆排序（不稳定）</h4><blockquote>
<p>利用之前优先级队列中，二叉堆的特性进行排序；</p>
<p>出队后，从数组末尾向前摆放，所以要递增排序就要构建最大化堆（反之同理）；</p>
<p>通常情况0号位存有数据，所以 i 结点的左右儿子分别为 2i + 1、2i + 2，父结点 floor((i-1)/2)；</p>
</blockquote>
<p>时间复杂度分析：出队N次，<strong>$O(n\space log\space n)$</strong>；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">percolateDown</span><span class="params">(KEY seq[], <span class="type">int</span> size, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> next = idx * <span class="number">2</span> + <span class="number">1</span>; KEY tmp = seq[idx];</span><br><span class="line">    <span class="keyword">while</span> (next &lt; size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next + <span class="number">1</span> &lt; size &amp;&amp; seq[next] &lt; seq[next + <span class="number">1</span>]) ++next;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; seq[next]) seq[idx] = tmp;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        idx = next; next = <span class="number">2</span> * idx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    seq[idx] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(KEY seq[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="built_in">percolateDown</span>(seq, size, i);</span><br><span class="line">    <span class="comment">// O(nlogn)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        KEY tmp = seq[<span class="number">0</span>]; seq[<span class="number">0</span>] = seq[i]; set[i] = tmp;</span><br><span class="line">        <span class="built_in">percolateDown</span>(seq, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-交换排序"><a href="#8-4-交换排序" class="headerlink" title="8.4 交换排序"></a>8.4 交换排序</h3><h4 id="8-4-1-冒泡排序"><a href="#8-4-1-冒泡排序" class="headerlink" title="8.4.1 冒泡排序"></a>8.4.1 冒泡排序</h4><blockquote>
<p>第 i 次循环（从前向后）安排好倒数第 i 个位置；</p>
<p>如果一趟起泡没有发生任何交换，则序列一定有序，可以中止；</p>
</blockquote>
<p>时间复杂度分析：最好 <strong>$O(n)$</strong>，平均、最坏均为 <strong>$O(n^2)$</strong>；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(KEY seq[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; size; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[j + <span class="number">1</span>] &lt; seq[j]) &#123;</span><br><span class="line">                KEY tmp = seq[j]; seq[j] = seq[j + <span class="number">1</span>];</span><br><span class="line">                seq[j + <span class="number">1</span>] = tmp; flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-2-快速排序（不稳定）"><a href="#8-4-2-快速排序（不稳定）" class="headerlink" title="8.4.2 快速排序（不稳定）"></a>8.4.2 快速排序（不稳定）</h4><blockquote>
<p>选标准元素 -&gt; 划分 -&gt; 递归（或不用递归，用栈保存划分的起始、中止序号）</p>
</blockquote>
<p>时间复杂度分析：</p>
<ul>
<li>最好：<strong>$T(N)=2T(\dfrac{N}{2})+cN\Longrightarrow T(N)=O(N\space log\space N)$</strong>；</li>
<li>最坏：<strong>$T(N)=T(N-1)+cN\Longrightarrow T(N)=O(N^2)$</strong>；</li>
<li>平均：<strong>$T(N)=2\dfrac{1}{N}\sum\limits_{i=0}^{N-1}{T(i)}+cN\Longrightarrow T(N)=O(N\space log\space N)$</strong>；</li>
</ul>
<p><strong>空间复杂度分析</strong>：和第一章说的一样，系统栈算辅助空间</p>
<ul>
<li>最好：<strong>$O(log\space n)$</strong>；最坏：<strong>$O(n)$</strong>；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(KEY seq[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    KEY pivot = seq[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; pivot &lt; seq[right]) --right;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) seq[left] = seq[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; seq[left] &lt; pivot) ++left;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) seq[right] = seq[left];</span><br><span class="line">    &#125;</span><br><span class="line">    seq[left] = pivot; <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;    <span class="comment">// 可以添加一个包装函数，或者改成非递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(KEY seq[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="built_in">divide</span>(seq, left, right);</span><br><span class="line">    <span class="built_in">quickSort</span>(seq, left, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(seq, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-归并排序"><a href="#8-5-归并排序" class="headerlink" title="8.5 归并排序"></a>8.5 归并排序</h3><blockquote>
<p>以二路归并为例，先得到2份<strong>有序序列</strong>（应用递归），另启空间分别按大小加入</p>
<p>考虑到C++int自动向0取整（索引偏左），<strong>故merge在分化的时候应该多留一个给左边</strong>，防止死循环；</p>
</blockquote>
<p>时间复杂度分析：<strong>时间复杂度与数据分布无关！始终为 $O(n\space log\space n)$</strong>；</p>
<p>空间复杂度分析：<strong>$O(n)$</strong>；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(KEY seq[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    KEY* tmp = <span class="keyword">new</span> KEY[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> leftIdx = <span class="number">0</span>, rightIdx = mid, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (leftIdx &lt; mid &amp;&amp; rightIdx &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (seq[leftIdx] &gt; seq[rightIdx])</span><br><span class="line">            tmp[idx++] = seq[rightIdx++];</span><br><span class="line">        <span class="keyword">else</span> tmp[idx++] = seq[leftIdx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (leftIdx &lt; mid) tmp[idx++] = seq[leftIdx++];</span><br><span class="line">    <span class="keyword">while</span> (rightIdx &lt;= right) tmp[idx++] = seq[rightIdx++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i)</span><br><span class="line">        seq[i] = tmp[i];</span><br><span class="line">    <span class="keyword">delete</span>[] tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">KEY</span>&gt;    <span class="comment">// 可以添加一个包装函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(KEY seq[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(seq, left, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(seq, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="built_in">merge</span>(seq, left, right， mid + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-6-基数排序"><a href="#8-6-基数排序" class="headerlink" title="8.6 基数排序"></a>8.6 基数排序</h3><blockquote>
<p>从最低位到最高位，分别放进 base（基数）个口袋中，再按口袋位置”倒出“，重复至所有数的最高位（不足的补0），排序完成；</p>
</blockquote>
<p>时间复杂度分析：<strong>$O(maxLen\times n)$</strong>；</p>
<p>空间复杂度分析：<strong>$O(1)$</strong>；</p>
<p>MSD &amp; LSD：从最高位还是最低位开始；</p>
<h3 id="8-EX-常用排序总结"><a href="#8-EX-常用排序总结" class="headerlink" title="8-EX 常用排序总结"></a>8-EX 常用排序总结</h3><blockquote>
<p>更多排序算法在算法设计/高级数据结构中进一步阐明；</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="sorts.png"></p>
<blockquote>
<p>⚠易错警示：算法的最好、最坏情况，与数据分布有关（除了堆【出队始终慢于入队】、归并、基数排序），但不与其完全对应（即“不一定最好情况是有序的时候”）！</p>
<p>当输入序列有序时：</p>
<p>直接插入排序 $O(n)$ 最好、常数个增量元素序列的希尔排序 $O(n)$ 最好（因为 k-排序 对应的直接插入排序线性时间复杂度）、快速排序 <strong>$O(n^2)$ 最坏</strong>、冒泡排序 $O(n)$ 最好；</p>
<p>当输入序列逆序时：</p>
<p>直接插入排序 $O(n^2)$ 最坏、希尔排序 $O(n^2)$ 最坏（因为每两个就要比较一次）、快速排序 <strong>$O(n^2)$ 最坏</strong>（因为基准元素依然在两端）、冒泡排序 $O(n^2)$ 最坏；</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SSRVodka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/review/data-structure-3/">https://blog.sjtuxhw.top/review/data-structure-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SSRVodka's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Data-Structure/">Data-Structure</a><a class="post-meta__tags" href="/tags/Sort/">Sort</a><a class="post-meta__tags" href="/tags/Hash-Table/">Hash-Table</a><a class="post-meta__tags" href="/tags/BSTree/">BSTree</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/ds3.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/review/data-structure-4/" title="数据结构复习-第四部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds4.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数据结构复习-第四部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN   Chapter 8 外部查找和排序8.1 零碎概念集合 内存与外存的特性：外存读取访问速率 &lt;&lt; 内存访问速率； 尽可能避免访问，宁可增加计算量……  记录：外存上的一个数据元素通常被称为一条记录；  磁道：磁盘表面储存信息的同心圆轨道；  扇区：磁盘的磁道被分为若干段，每段被称为一个扇区；  一个扇区相当于磁带上的一个数据块，也称磁盘块，是一次磁盘读写的单位；    8.2 B 树 定义：存储在外存上的动态查找表： 一棵 m 阶 B 树或者为空，或者满足：  根结点的度 $d_r\in\{0\}\space\bigcup\space[2,\space m]$；  除了根结点和叶结点外，每个结点的度 $d\in[\space\lceil\dfrac{m}{2}\rceil,\space m\space]$；  度为s（s＞0）的结点具有 n = s-1 个关键字，信息存放方式：...</div></div></div></a><a class="pagination-related" href="/review/data-structure-2/" title="数据结构复习-第二部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数据结构复习-第二部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN   注：默认定义异常类型noElementException： 12345678class noElementException &#123;private:    const char* message;public:    noElementException(const char* msg=&quot;No element in the container.&quot;)        : message(msg) &#123;&#125;    const char* what() const &#123; return message; &#125;&#125;; Chapter 3 栈3.1...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/review/data-structure-1/" title="数据结构复习-第一部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-15</div><div class="info-item-2">数据结构复习-第一部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN    Chapter 1 数据结构绪论1.1 数据结构逻辑分类 集合结构：次序任意，重视归属关系； 线性结构：有序序列，有前驱、后继关系； 树状结构：层次关系，分根元素-其他元素； 图状结构：一般的逻辑结构，不限前驱和后继；  1.2 逻辑结构基本运算类型 创、清、增删改查、访问、遍历  1.3 逻辑结构的运算实现 存储结点、数据元素间关系（顺序实现、链接实现、散列实现、索引存储）、附加信息  总结：一个数据结构就是针对某一逻辑结构讨论数据的存储实现和运算实现 1.4 算法优劣因素分析 正确性、易读性、健壮性、高效率（时间、空间性能）   时间复杂度：算法所需运算量 和 问题规模 间的关系   时间复杂度因为会与被处理数据的分布有关，所以会有最好最坏和平均的说法  重要易错点：答题时注意除非说明，必须同时写上：最好、最坏、平均时间复杂度，少一个都不全面     算法运算量计算：不通用性  规定标准操作...</div></div></div></a><a class="pagination-related" href="/review/data-structure-2/" title="数据结构复习-第二部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-19</div><div class="info-item-2">数据结构复习-第二部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN   注：默认定义异常类型noElementException： 12345678class noElementException &#123;private:    const char* message;public:    noElementException(const char* msg=&quot;No element in the container.&quot;)        : message(msg) &#123;&#125;    const char* what() const &#123; return message; &#125;&#125;; Chapter 3 栈3.1...</div></div></div></a><a class="pagination-related" href="/review/data-structure-4/" title="数据结构复习-第四部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds4.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-27</div><div class="info-item-2">数据结构复习-第四部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN   Chapter 8 外部查找和排序8.1 零碎概念集合 内存与外存的特性：外存读取访问速率 &lt;&lt; 内存访问速率； 尽可能避免访问，宁可增加计算量……  记录：外存上的一个数据元素通常被称为一条记录；  磁道：磁盘表面储存信息的同心圆轨道；  扇区：磁盘的磁道被分为若干段，每段被称为一个扇区；  一个扇区相当于磁带上的一个数据块，也称磁盘块，是一次磁盘读写的单位；    8.2 B 树 定义：存储在外存上的动态查找表： 一棵 m 阶 B 树或者为空，或者满足：  根结点的度 $d_r\in\{0\}\space\bigcup\space[2,\space m]$；  除了根结点和叶结点外，每个结点的度 $d\in[\space\lceil\dfrac{m}{2}\rceil,\space m\space]$；  度为s（s＞0）的结点具有 n = s-1 个关键字，信息存放方式：...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SSRVodka</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">78</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-7-%E9%9B%86%E5%90%88%E3%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-text">Chapter 7 集合、查找表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E9%9B%86%E5%90%88%E7%9A%84%E9%9B%B6%E7%A2%8E%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93"><span class="toc-text">7.1 集合的零碎概念总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-text">7.2 静态查找表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-text">7.3 动态查找表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text">7.3.1 二叉查找树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-AVL%E6%A0%91%EF%BC%9A%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text">7.3.2 AVL树：平衡的二叉查找树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-text">7.3.3 散列表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-8-%E6%8E%92%E5%BA%8F"><span class="toc-text">Chapter 8 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E9%9B%B6%E7%A2%8E%E6%A6%82%E5%BF%B5%E9%9B%86%E5%90%88"><span class="toc-text">8.1 零碎概念集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">8.2 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">8.2.1 直接插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">8.2.2 二分插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89"><span class="toc-text">8.2.3 希尔排序（不稳定）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">8.3 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88%E7%89%B9%E5%AE%9A%E6%9D%A1%E4%BB%B6%E4%B8%8B%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89"><span class="toc-text">8.3.1 直接选择排序（特定条件下不稳定）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89"><span class="toc-text">8.3.2 堆排序（不稳定）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-text">8.4 交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">8.4.1 冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89"><span class="toc-text">8.4.2 快速排序（不稳定）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">8.5 归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">8.6 基数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-EX-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93"><span class="toc-text">8-EX 常用排序总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/transformer/" title="Transformer 论文精读"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/transformer.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Transformer 论文精读"/></a><div class="content"><a class="title" href="/technical/transformer/" title="Transformer 论文精读">Transformer 论文精读</a><time datetime="2025-07-20T15:15:10.000Z" title="发表于 2025-07-20 23:15:10">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/sc.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"/></a><div class="content"><a class="title" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</a><time datetime="2025-07-01T10:14:11.000Z" title="发表于 2025-07-01 18:14:11">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ml-roadmap.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识图谱：Machine Learning Roadmap"/></a><div class="content"><a class="title" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap">知识图谱：Machine Learning Roadmap</a><time datetime="2025-06-08T06:59:31.000Z" title="发表于 2025-06-08 14:59:31">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"/></a><div class="content"><a class="title" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</a><time datetime="2025-05-30T08:49:12.000Z" title="发表于 2025-05-30 16:49:12">2025-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/tee-lab.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机密计算与TEE：知识整理和试验笔记"/></a><div class="content"><a class="title" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记">机密计算与TEE：知识整理和试验笔记</a><time datetime="2025-04-17T15:31:36.000Z" title="发表于 2025-04-17 23:31:36">2025-04-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SSRVodka  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Powered By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>