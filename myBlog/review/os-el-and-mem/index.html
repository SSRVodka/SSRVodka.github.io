<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OS 的特权级切换与内存管理总览：以 Linux AArch64 为例 | SSRVodka's blog</title><meta name="author" content="SSRVodka,xhwpro@gmail.com"><meta name="copyright" content="SSRVodka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="特权级切换与内存管理这两块知识一直是 OS 的极其极其重要的组成部分：特权级切换是 OS 上下文切换和调度的基石，而内存管理则是一切隔离性（进程抽象）、资源可用性的基石。可惜对于初学者而言太过庞大，并且它们通常相互涉及，以至于总是掌握不了全貌。 笔者想从尽可能全面的视角记录总结一下它们究竟在做什么，方便日后查阅笔记、快速理解，因此不会过于深入细节（例如不会介绍 Buddy System 和 SLU">
<meta property="og:type" content="article">
<meta property="og:title" content="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例">
<meta property="og:url" content="https://blog.sjtuxhw.top/review/os-el-and-mem/index.html">
<meta property="og:site_name" content="SSRVodka&#39;s blog">
<meta property="og:description" content="特权级切换与内存管理这两块知识一直是 OS 的极其极其重要的组成部分：特权级切换是 OS 上下文切换和调度的基石，而内存管理则是一切隔离性（进程抽象）、资源可用性的基石。可惜对于初学者而言太过庞大，并且它们通常相互涉及，以至于总是掌握不了全貌。 笔者想从尽可能全面的视角记录总结一下它们究竟在做什么，方便日后查阅笔记、快速理解，因此不会过于深入细节（例如不会介绍 Buddy System 和 SLU">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg">
<meta property="article:published_time" content="2025-05-30T08:49:12.000Z">
<meta property="article:modified_time" content="2025-06-11T12:27:30.268Z">
<meta property="article:author" content="SSRVodka">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/review/os-el-and-mem/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OS 的特权级切换与内存管理总览：以 Linux AArch64 为例',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SSRVodka's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">78</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SSRVodka's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-30T08:49:12.000Z" title="发表于 2025-05-30 16:49:12">2025-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-11T12:27:30.268Z" title="更新于 2025-06-11 20:27:30">2025-06-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/review/">review</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/review/os-el-and-mem/#post-comment"><span class="waline-comment-count" data-path="/review/os-el-and-mem/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>特权级切换与内存管理这两块知识一直是 OS 的极其极其重要的组成部分：特权级切换是 OS 上下文切换和调度的基石，而内存管理则是一切隔离性（进程抽象）、资源可用性的基石。可惜对于初学者而言太过庞大，并且它们通常相互涉及，以至于总是掌握不了全貌。</p>
<p>笔者想从尽可能全面的视角记录总结一下它们究竟在做什么，方便日后查阅笔记、快速理解，因此不会过于深入细节（例如不会介绍 Buddy System 和 SLUB 机制的具体内容）。</p>
<p>最后我们将总结并运用已经了解的知识，讨论一下全局视角下的 OS 内核栈。</p>
<p>如有错误，欢迎读者勘误斧正。</p>
<blockquote>
<p>下面内容将以 AArch64 为例。</p>
<p>建议复习：通用寄存器 <code>x0-x30</code>、PC 程序计数器、4 个栈寄存器 <code>SP_ELx</code>、3 个异常链接器 <code>ELR_ELx</code>（从 1 开始）、3 个程序状态寄存器 <code>SPSR_ELx</code>、2 个页表基地址寄存器 <code>TTBRx_EL1</code>（注意只有 EL1 级别）、TCR/SCTLR/SCR/TPIDR/MPIDR 这些常见寄存器的用途。</p>
</blockquote>
<h2 id="A-特权级切换"><a href="#A-特权级切换" class="headerlink" title="A. 特权级切换"></a>A. 特权级切换</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/arm_exception_level.png" width="350px" /></p>
<p><code>EL0</code>：用户态程序、<code>EL1</code>：内核、<code>EL2</code>：hypervisor、<code>EL3</code>：monitor；</p>
<p>ARM 特权级切换和 x86 一样，都需要是 Context Switch，因此需要保存一些运行时数据（通用寄存器值、系统控制和特殊寄存器值、PCB/TCB、文件描述符、内存管理结构体等等）。</p>
<p>首先 ARM 本身的特权级比 x86 的复杂（Ring 0/3），因此切换过程对应地复杂一些。寄存器的保存方法如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/priv_reg_switch.png" width="550px" /></p>
<p>总结一下 ARM CPU 在特权级切换时硬件和软件所执行的任务：</p>
<p>首先无论特权级切换是硬中断还是软中断引起的，硬件都会开始处理上下文切换的工作：</p>
<ol>
<li><p>当前使用的所有 <code>EL0</code> 寄存器全部切换到使用 <code>EL1</code> 寄存器（例如 <code>SP_EL0</code> -&gt; <code>SP_EL1</code>、<code>TTBR_EL0</code> -&gt; <code>TTBR_EL1</code>）；</p>
</li>
<li><p>备份特殊寄存器：特殊寄存器 PC 保存到 <code>ELR_EL1</code> 方便返回当前用户态进程（和 x86 相同，如果是软中断则保存中断位置下一条指令的地址，如果是硬中断则保存中断位置当前指令地址）、特殊寄存器 PSTATE 保存到 <code>SPSR_EL1</code> 方便恢复当前用户态进程程序状态；</p>
</li>
<li><p>写入系统寄存器 <code>ESR_EL1</code>：将异常事件的原因代号保存在 <code>ESR_EL1</code> 寄存器，例如是 <code>svc</code> 指令导致（对应 x86 <code>syscall</code>，trap）还是缺页导致（fault）还是其他原因；如果是 page fault，那么将触发的内存地址保存在 <code>FAR_EL1</code> 寄存器（回忆 x86 的 <strong><u>CR2</u></strong> 寄存器）</p>
</li>
<li><p>恢复特殊寄存器：通过 <code>ESR_EL1</code> 寄存器和 <code>VBAR_EL1</code> 寄存器（Vector Based Address Register，回忆 2.1.7）计算出异常处理函数的起始地址，并写入 PC；</p>
<blockquote>
<p><code>SP_EL1</code> 保持原样就行；</p>
<p><code>PSTATE</code> 按需求设置，例如会被硬件设置为目标异常级别（<code>EL1</code>）的默认状态，即 DAIF 掩码生效，这步还会受到 <code>SPSR_EL1</code> 中保存的部分状态影响；</p>
</blockquote>
</li>
</ol>
<p>然后控制流交给 OS，此时 OS 会在执行异常处理函数真正内容前进行软件上下文保存（主要意图是防止内核程序破坏了用户态的程序状态）：</p>
<ol>
<li><p>将通用寄存器（<code>x0-x30</code>）压内核栈：因为等会内核可能就要用了；</p>
<blockquote>
<p>这步是最安全、标准的做法，很多 ISA 也都会这么做，但这显然有性能影响。</p>
<p>因此 ARM 允许优化，即根据 AAPCS (ARM Procedure Call Standard)，callee-saved registers (<code>x19-x29</code> 和 <code>SP</code>) 如果异常处理函数不会修改它们，并且它调用的函数也遵守 AAPCS，理论上可以不用保存；</p>
</blockquote>
</li>
<li><p>将 <code>SP_EL0</code> 压栈：因为可能后面会调度到不同进程/线程；</p>
<blockquote>
<p>某些情况，如特定的快速中断 FIQ（而非 IRQ），或者简单的、非 I/O 的系统调用，如果不会主动调度出去，理论上可以不保存；</p>
</blockquote>
</li>
<li><p>将 <code>SPSR_EL1/ELR_EL1</code> 压栈：必须保存。除了与第二点相同的原因以外，还多了另外一个重要原因：<strong>可能会发生嵌套异常</strong>（例如处理缺页时又被中断），若不保存很可能会导致之前用户态状态丢失；</p>
<blockquote>
<p>但 <code>ESR_EL1</code> 无关紧要，用完就可以扔了；</p>
</blockquote>
</li>
</ol>
<p>而特权级切换回来的时候一般是 OS 主动，所以先软件恢复上下文：弹栈出通用寄存器、<code>SP_EL0</code>、<code>SPSR_EL1/ELR_EL1</code>；</p>
<p>然后 OS 调用 <code>eret</code> 交给硬件恢复：</p>
<ol>
<li>恢复特殊寄存器：<code>ELR_EL1 -&gt; PC</code>、<code>SPSR_EL1 -&gt; PSTATE</code>（<code>SP_EL0</code> 已经软件恢复了）；</li>
<li>当前使用的所有 <code>EL1</code> 寄存器全部切换到使用 <code>EL0</code> 寄存器；</li>
</ol>
<p>我们发现和进入特权级相比少了些步骤，一个是备份特殊寄存器（内核态有的是计算出来的、有的是保留原先的值、还有的是按需设置的，所以内核态的这些特殊寄存器不需要备份），另一个是 <code>ESR_EL1</code> 只是给内核用的，用户态不需要；</p>
<h3 id="如果涉及调度？"><a href="#如果涉及调度？" class="headerlink" title="如果涉及调度？"></a>如果涉及调度？</h3><p>现在考虑更复杂的情况，上面特权态恢复到用户态是没有发生调度的情况。如果决定调度到其他线程，步骤会有不同吗？</p>
<p>答案是会的。假设当前是进程 A 下陷到内核态了，我们上面软件保存状态压入的是 A 的内核栈。现在假设我们需要调度并恢复进程 B 的状态（而不是 A 的），那么我们需要多做一步：<u>内核找到<strong>进程 B 的内核栈</strong>，将当前 <code>SP_EL1</code> 更改为 B 对应的内核栈顶部地址，然后执行上面的软件恢复动作</u>。</p>
<p>这就够了吗？还不够。你虽然压栈了，但切换到另一个进程时，内核怎么找到 A/B 的内核栈呢？因此<strong><u>还需要把进程上下文信息保存到 PCB 中</u></strong>，将内核栈与进程关联起来。这样要调度到哪个进程，就能顺手从 PCB 中拿出内核栈地址，然后恢复状态了。</p>
<p>现在你可能又又又又有些疑惑了，每个进程都有内核栈？那么内核栈在物理内存的哪里呢？答案需要等到了解内存管理才能揭晓，读者不妨阅读完后文以后再来回顾。</p>
<p>另外，上述过程仍不完整，因为在切换用户态进程时还需要切换用户态页表（<strong><u>内核态页表不用换</u></strong>）、TLB 刷新等操作，不过它们属于内存管理的范畴，也放在内存管理介绍。</p>
<blockquote>
<p>知识补充：应用程序需要保存的运行状态称为处理器上下文处理器上下文（<strong><u>Processor Context</u></strong>）：</p>
<p>应用程序在完成切换后恢复执行所需的最小处理器状态集合。</p>
<p>处理器上下文中的寄存器具体包括：</p>
<ul>
<li>通用寄存器 <code>x0-x30</code>；</li>
<li>特殊寄存器，主要包括 PC、SP 和 PSTATE；</li>
<li>系统寄存器，包括页表基地址寄存器等；</li>
</ul>
</blockquote>
<h2 id="B-物理内存管理"><a href="#B-物理内存管理" class="headerlink" title="B. 物理内存管理"></a>B. 物理内存管理</h2><p>应用程序（用户态）和 OS 内核本身最终都需要使用物理内存。用户态程序依靠 OS 为它包装的<strong><u>虚拟内存机制</u></strong>来完成事实上的隔离和足够的资源以供访问。那 OS 依靠谁来分配物理内存？</p>
<p>首先我们知道，内核本身也需要分配内存来运行自身的代码，并且内核也不能在 MMU 开启后再绕过 MMU 翻译，因此它也只能使用虚拟内存地址！</p>
<p>内核在启动时如何拿到虚拟内存？答案是 <strong><u>DIRECT MAPPING</u></strong> 机制。这个机制的内容如下：</p>
<ul>
<li><p>在内核启动时，从低地址跳转到高地址执行前（此时还没有抛弃 bootloader 映射的低地址空间），内核会将<strong><u>物理地址的全部空间</u></strong>一口气映射到虚拟地址的高地址空间（<code>TTBR1</code>），使用大页完成映射（如果 page size 是 4K，则采用 1G 大页，主要看具体实现）。</p>
<blockquote>
<p>此时只能叫映射，不能叫分配。</p>
<p>是的，只有物理页在内核中的数据结构 <code>struct physical_page</code> 中的字段 <code>allocated</code> 被设置为 1 后才能视作被分配。</p>
<p>此时内核中被分配的空间大小只有 bootloader 载入内核镜像的大小（例如 512M）。</p>
</blockquote>
</li>
<li><p>映射完成后，内核部分的所有空间的虚拟地址和所有物理地址，只是相差一个 offset（但是由于现代处理器不支持用段管理物理内存，因此只能用页表）；</p>
</li>
</ul>
<p>DIRECT MAPPING 本身分配规整，适合使用大页的方法，这也是内核适合使用大页的原因之一。</p>
<blockquote>
<p>小贴士：历史上曾经存在 “物理地址大小大于虚拟地址”的情况。这个时候内核怎么 DIRECT MAPPING 来管理物理内存呢？</p>
<p>答案是先 DIRECT MAPPING 映射 892 MB 大小的空间，再在映射的内核空间上方加一个滑动窗口，通过不断更改内核页表的方式来写这些物理内存；</p>
</blockquote>
<hr>
<p>如果内核自己需要为自己的数据结构分配空间（一般是立即使用）怎么办？答案是 Buddy System (<code>alloc_page</code>) + SLUB 机制 (<code>kmalloc</code>)；</p>
<blockquote>
<p>这两个机制不是一开始就想出来的，这是工程学的沉淀。</p>
</blockquote>
<ul>
<li>Buddy System 高效地、高利用率地以页为粒度向内核提供各种 page size 倍大小的空间。这个算法和物理页数据结构由内核定义的数据结构 <code>struct physical_page</code> 管理，不在 VMA 中，只记录在 buddy system 空闲链表中。分配的页一般不允许 evict / swap out；</li>
<li>SLUB 机制则按照内核调用 <code>kmalloc</code> 指定的需求，从资源池 / Buddy System (如果资源池不够) 那里获得的合适大小的资源并返回，极大降低内部碎片和资源浪费。如果有一类数据结构或分配模式大量地出现（例如 <code>dentry</code>），则专门为这个大小准备一个资源池，以增强性能；</li>
<li>如果内核一次性需要 4K (一个页大小) 或更多的数据，内核应该自己懂事地调用 <code>alloc_page</code> 来申请，而不是 <code>kmalloc</code>；</li>
<li>无论是 Buddy System 还是 SLUB，分配的内存地址都是 DIRECT MAPPING 的（即它们分配的物理地址直接对应到相差 offset 的内核空间，和最开始的映射是一样的）；</li>
</ul>
<hr>
<p>如果内核自己需要分配一块超大的空间，并且希望享受用户态 on-demand paging 的性能，怎么办？答案是特殊的 <code>vmalloc</code> 方法。</p>
<p>它和用户态的分配思路一样，on-demand paging，并且这样分配的空间允许 swap out（这个 OS 可以自定义）；需要时直接从 buddy system 按页取资源；</p>
<blockquote>
<p>注意：使用 <code>kmalloc</code> 创建的空间不会被 swap，确保内核关键数据结构不会在运行时不可用。</p>
</blockquote>
<p>vmalloc 分配的虚拟内存区域一般情况会在 DIRECT MAPPING 区域更高的地址（如下图 <code>KBASE + 0xFFFF_FFFF</code> ~ <code>0xFFFF_FFFF_FFFF_FFFF</code> 区域），由内核页表管理到物理内存的映射（可以 swap out）。</p>
<hr>
<p>如果用户态应用程序通过 <code>malloc</code> 向内核申请应用程序空间，怎么办？就是 ICS 的内容了！</p>
<ul>
<li>若这块空间不大，则通过 <code>brk</code> 分配堆。那应用程序的堆空间从哪来？答案是应用程序启动时 OS 会在载入可执行程序的同时预映射一些页给到应用。<ul>
<li>如果预映射的页用完了，内核需要通过页粒度的物理内存管理找到一个空闲的物理页（就是上面说的，直接通过 buddy system 拨一个物理页）并映射好给应用程序；</li>
</ul>
</li>
<li>若这块空间很大，通过 <code>mmap</code> 直接映射。内部实现是，只是先在 VMA 记录一下，然后 on-demand paging（拨物理页的方法同上）；</li>
</ul>
<p>这样我们会发现，其实<strong><u>任何应用程序已经被分配物理地址的 VM，都有在内核空间对应的区域（映射到同一段物理内存）</u></strong>。</p>
<p>总结一下，任意一个进程虚拟内存区域应该是这样的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/chcore_start_mm.png" width="550px" /></p>
<p>从低地址到高地址分别为：用户态程序空间、设备空间（不在 user space 中）、unmapped region、direct mapping area（全量物理内存映射）、<code>vmalloc</code> 或 <code>ioremap</code> 动态占用空间、kernel 数据结构（如 kernel stack、kernel task struct 等等）、kernel code/data 区；</p>
<p>然后由于 kernel 始终有 direct mapping 的区域，就意味着它能看到物理内存上的所有数据结构。</p>
<h2 id="C-虚拟内存管理"><a href="#C-虚拟内存管理" class="headerlink" title="C. 虚拟内存管理"></a>C. 虚拟内存管理</h2><p>OS 给用户态程序提供的虚拟内存又是如何实现的？</p>
<p>在 OS 演变历史上，人们主要尝试过 3 种管理用户态程序内存方案：</p>
<ol>
<li><p>直接使用物理地址。问题是：干扰性、扩展性、安全性。因此我们需要增加一层隔离，让应用无法直接看见物理地址；</p>
</li>
<li><p>虚拟内存 + 翻译机制(地址分段)。有应用整段分配的，也有更细粒度的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/mm-seg.png" /></p>
<p>随着物理内存与虚拟内存的差距增大、应用对于资源需求日益增长，人们很快发现，这种方法对物理内存连续性的要求：物理内存也必须以段为单位进行分配，<strong><u>导致内存利用率不大</u></strong>（外部碎片，段与段间留下的碎片空间；内部碎片，段内部预留的未使用的碎片空间）；</p>
<p>因此分段机制通常存在于 x86 设备，现代操作系统不依赖于分段。</p>
</li>
<li><p>虚拟地址 + 翻译机制(分页)。依赖于页表，并且通过多级页表有效压缩页表大小。略。</p>
</li>
</ol>
<p>前面说虚拟内存的翻译机制用的是分页，但 OS 对一个用户态程序的虚拟内存内部的管理则采用段来管理。主要考虑：</p>
<ul>
<li>段的数量远少于页，如果使用页管理则应用很可能用不完；</li>
<li>通常每一段都有相同的属性，比如只读、可执行等等，可简化管理；</li>
</ul>
<p>向 VMA 中添加记录的主要途径：</p>
<ul>
<li>OS 在创建应用程序时分配（数据段 <code>.rodata</code>、代码段 <code>.text</code> 等等，也包括栈区域和部分的堆）；</li>
<li>应用程序主动向 OS 发出请求，例如 <code>brk() / mmap()</code>（不论是 file-backed 还是匿名页）；</li>
<li>用户态 <code>malloc</code>；分配小空间或一般空间，则底层一般使用 <code>brk()</code>，分配大空间，则底层一般使用 <code>mmap()</code>；</li>
</ul>
<p>考虑新的问题：VMA 是否冗余？页表本身是不是已经能够说明了 OS 给当前进程分配的虚拟内存的情况了吗？理论上是这样，页表存放了 VMA 所有保存的数据。但是有以下考量：</p>
<ul>
<li>提升性能。它本身的数据结构就足够高效（红黑树+链表，最新版的 Linux 已经开始用 maple tree 数据结构了）。如何检查应用访问的内存有效？如何实现 kernel page fault handler？总不能把应用的页表扫一遍吧？</li>
<li>极大简化 <code>mmap() / munmap() / mprotect()</code> 等函数的实现。尤其分配大空间时 <strong><u>on-demand paging</u></strong> 就必须需要 VMA（归根到底还是性能）；</li>
<li>保存额外的信息（例如是否 file-backed、shared/private mapping），便于 OS 实现其他功能；</li>
</ul>
<p>再次总结虚拟内存的优势：</p>
<ul>
<li>高效使用物理内存：使用 DRAM 作为虚拟地址空间的缓存，将离散的、有限的空间给应用抽象成连续的、充足的空间；</li>
<li>简化内存管理：每个进程看到的是统一的线性地址空间；多个进程间方便安全地分享；</li>
<li>更强的隔离与更细粒度的权限控制：<ul>
<li>（隔离性）一个进程不能访问属于其他进程的内存；</li>
<li>（安全性）用户程序不能够访问特权更高的内核信息；</li>
<li>不同内存页的读、写、执行权限可以不同；</li>
</ul>
</li>
</ul>
<p>什么时候不需要：</p>
<ul>
<li>内存地址足够大（用页表开销会逐渐增大，使用段机制访问的优势就会凸显）、性能要求足够高；</li>
</ul>
<h2 id="D-全局视角：内核栈是什么？在哪里？"><a href="#D-全局视角：内核栈是什么？在哪里？" class="headerlink" title="D. 全局视角：内核栈是什么？在哪里？"></a>D. 全局视角：内核栈是什么？在哪里？</h2><p>首先搞清楚内核栈官方定义是啥？根据 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.kernel.org/doc/html/next/x86/kernel-stacks.html">官方文档</a>：</p>
<p><code>x86_64</code> page size (PAGE_SIZE) is 4K.</p>
<p>Like all other architectures, <code>x86_64</code> has a kernel stack for every active thread. These thread stacks are <code>THREAD_SIZE</code> (<code>2*PAGE_SIZE</code>) big. These stacks contain useful data as long as a thread is alive or a zombie. While the thread is in user space the kernel stack is empty except for the <code>thread_info</code> structure at the bottom.</p>
<p>In addition to the per thread stacks, there are specialized stacks associated with each CPU. These stacks are only used while the kernel is in control on that CPU; when a CPU returns to user space the specialized stacks contain no useful data.</p>
<p>注意到，官方文档说，OS 内核对每个活动线程都有一块内存空间，称为 “thread stack”（线程栈），这就是内核栈的一部分，它的作用就是在对应线程进入内核态时内核需要用的栈。一个 <code>x86_64</code> 的 thread stack 大约 8KB（2 个页大小），当线程在用户态时，内核栈是空的（除了 <code>thread_info</code> 结构体），直到进入内核态才有用。</p>
<p>并且除了 thread stacks，实际上还有与每个 CPU 相关的专门堆栈（<strong><u>Interrupt stack</u></strong>，中断栈），这也能看作内核栈的一部分。这些堆栈只在内核控制 CPU 时使用（用于处理硬中断和 softirq）；作用是<u>为内核中断处理提供了更多空间，而无需增加每个线程栈的大小</u>。当 CPU 返回用户空间时，这个专用堆栈也就不包含有用数据了。</p>
<p>嗯？看起来有两种栈都能称为 “内核栈”？</p>
<p>没错，“内核栈” 本身的定义就极为宽泛：<strong><u>操作系统内核为执行流（无论是内核线程还是代表用户进程执行内核代码）在内核态运行时分配的专用内存区域</u></strong>。</p>
<p>而内核栈就是内核线程使用的栈。</p>
<blockquote>
<p>这里的 “内核线程” 也是很宽泛的定义，实际上有好几类，常见的例子有：</p>
<ul>
<li><strong>中断下半部处理：</strong> <code>ksoftirqd</code> 线程处理延后的软中断任务；</li>
<li><strong>内存管理：</strong> 如 <code>kswapd</code> 线程负责页面回收；</li>
<li><strong>文件系统：</strong> 如日志提交 (<code>jbd2</code>)、数据同步 (<code>flush</code> 线程)；</li>
<li><strong>工作队列机制：</strong> <code>kworker</code> 线程执行由内核其他部分提交的延迟工作项；</li>
<li><strong>实现用户线程模型：</strong> 在 1:1 线程模型（如 Linux 的 NPTL）中，每个用户线程 LWP 都直接绑定一个内核线程（LWP 即轻量级进程，也就是建立在内核之上并由内核支持的用户线程）；</li>
</ul>
<p>我们上面的 “thread stack” 其实就是 “实现用户线程模型” 的这类内核线程的栈，它一般跟随着用户线程/进程的创建来分配，因此与用户态线程强绑定；</p>
<p>而其他类型的内核线程一般和用户线程一样，都是参与调度的，和用户线程的关系不紧密（是内核通过 <code>kthread_create / kthread_run</code> 启动的线程），只不过它们一般受内核专用调度器来调度。</p>
</blockquote>
<p>最后补充一下全局视角：以 Linux 为例，内核栈在哪里？更准确地说，“<strong>实现用户线程模型</strong>” 用到的内核栈（thread stack）在哪里？</p>
<p>这个问题比较复杂，我们先从几个简单的事实出发：</p>
<ol>
<li><p>在任何时刻，一个 CPU 核心<strong>正在使用</strong>的内核栈只有一个。这是当 CPU 在 kernel mode 执行代码时（例如处理系统调用、中断、异常、调度代码）所使用的栈。这个栈的指针（例如 x86 的 <code>RSP</code> 寄存器或 AArch64 <code>SP_EL1</code>）指向当前正在使用的内核栈顶部；</p>
</li>
<li><p>但是，一个 CPU 核心会处理多个进程/线程。<strong>每个用户空间的进程/线程在陷入内核态时，都需要使用自己独立的内核栈（有且仅有对应的一个）。</strong></p>
<p>现在回顾之前的知识 “特权级切换时 CPU 和 OS 应该做什么”，我们知道如果涉及进程切换，那么在内核态需要先切换内核栈，再回用户态。</p>
<p>另外，只是压栈还不行（否则想要切换到目标进程却发现找不到对应内核栈的位置。。），<strong><u>还需要把进程上下文信息保存到 PCB 中</u></strong>。</p>
<p>然后内存管理层面还需要切换用户态页表（更新 <code>TTBR0_EL1</code>）、刷新 TLB 等等。</p>
<blockquote>
<p>注 1：从哪里更新 <code>TTBR0_EL1</code>？每个进程的页表基地址则放在进程 <code>struct task_struct</code> -&gt; <code>struct mm_struct</code> -&gt; <code>pgd_t *pgd</code> 字段中。</p>
<p>注 2：<code>struct mm_struct</code> 除了页表基地址，还会存放 VMA list、堆栈信息、其他内存映射信息、页表锁等；</p>
</blockquote>
</li>
</ol>
<p>好了，知道了我们在这些地方要用到内核栈，我们只要捋清除内核栈从创建到销毁的一系列流程，就知道它究竟在哪了。</p>
<p>我们知道，DIRECT MAPPING 是内核虚拟地址空间中一个<strong>巨大、连续</strong>的区域，提供<strong>虚拟地址到物理地址的简单线性关系的转换</strong>，它的目的就是<u>提供一种高效访问<strong>几乎任何物理内存页</strong>的方式，避免为每次访问建立复杂页表映射的开销</u>。内核需要操作内存数据结构（如上面提到的 <code>struct page</code>、SLAB 分配器对象）、Buddy System 机制、或 DMA 缓冲区时，常使用此区域；</p>
<p>但内核栈是动态的、是为每个进程/线程<strong>动态分配</strong>的（通常在进程创建时 <code>fork()</code>/<code>clone()</code>），它与特定的执行上下文（进程/线程）紧密绑定。</p>
<p>就这点上来说，内核栈就像内核使用的比较大的数据结构，分配的方法就上面两种：一个是直接用 <code>alloc_page</code> 这样的方法从 buddy system 那里拿物理页（DIRECT MAPPING），另一个是使用 <code>vmalloc</code> 分配一个大的空间，然后 on-demand paging。</p>
<blockquote>
<p>不考虑 <code>kmalloc</code> 的原因参见前文，栈的大小也不小了。</p>
</blockquote>
<p>事实上，一开始 Linux 设计者选择了使用 buddy system 而非 <code>vmalloc</code> 来分配内核栈，是因为<strong><u>性能考量</u></strong>：<code>vmalloc</code> 通常 on-demand paging 分配的连续虚拟内存，但物理内存不一定连续，这对一般情形是有用的，但内核栈使用频繁，如果每次都走虚拟地址页表的翻译，性能会很差；因此内核栈需要尽量保证物理空间上连续，能受益到 locality 的性能。</p>
<p>但在 Linux 4.14 以后，引入了 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.kernel.org/doc/html/latest/mm/vmalloced-kernel-stacks.html"><code>VMAP_STACK</code></a>（参见链接）机制，允许采用 <code>vmalloc</code> 申请的内存作为内核栈，只需要使能 <code>CONFIG_VMAP_STACK</code> 内核选项即可。这样可以利用 <code>vmalloc</code> 自身的内存边界检查的特性，提供类似 guard page 这样的栈溢出检测的能力。</p>
<p>最后在进程退出时，内核会释放其内核栈占用的物理页帧，并解除对应的虚拟地址映射（清理内核页表）。</p>
<p>所以问题解决了，内核栈要么在 DIRECT MAPPING 区域（如果直接从 buddy system 拿物理页），要么在 <code>vmalloc</code> 分配的某段连续虚拟内存中（如果启用 <code>VMAP_STACK</code>），当然如果是由 <code>vmalloc</code> 分配，那么分配时 OS 会额外标记内核栈不允许 swap-out（通过标记物理页数据结构 <code>struct page</code> 的特殊字段 <code>GFP</code> 来禁止换出）。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SSRVodka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/review/os-el-and-mem/">https://blog.sjtuxhw.top/review/os-el-and-mem/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SSRVodka's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ml-roadmap.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">知识图谱：Machine Learning Roadmap</div></div><div class="info-2"><div class="info-item-1">笔者感觉 ML 这块知识点太多，互联网上多数信息都难以结构化，尤其是一个方向的知识火起来后，每个人都写一篇博客，看的眼花缭乱。。因此笔者简单总结了一下机器学习领域的知识图谱，方便知识体系构建和回顾。 如有错误，欢迎读者勘误斧正。  </div></div></div></a><a class="pagination-related" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/tee-lab.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">机密计算与TEE：知识整理和试验笔记</div></div><div class="info-2"><div class="info-item-1">Part 1. 机密计算与 TEE 技术入门知识整理本节参考文献参见 1.5 节。 1.0 Background为了防止未经授权的访问，数据安全性是基于三种方面构建的，即静态存储数据、传输中数据、和使用中数据。 业界目睹了几项引人注目的内存抓取（例如 Target 信用卡和个人信息泄露事件）和 CPU 侧信道攻击，还有许多虚拟机管理程序（Hypervisor）漏洞也被报道出来，这些攻击和漏洞的报道显著提高了业界对  “使用中数据”的关注，另外，涉及恶意软件注入的著名攻击事件，例如 Triton 攻击和乌克兰电网袭击，更是使得保护“正在使用的数据”成为数据安全领域迫在眉睫的努力方向。 机密计算就是针对数据在使用过程中的安全问题所提出的一种解决方案。它是一种基于硬件的技术，将数据、特定功能、应用程序，同操作系统、系统管理程序或虚拟机管理器以及其他特定进程隔离开来，让数据存储在受信任的执行环境（TEE）中，即使是使用调试器，也无法从外部查看数据或者执行操作。TEE 确保只有经过授权的代码才能访问数据，如果代码被篡改，TEE...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/technical/hilog-paper/" title="OpenHarmony Hilog 架构趣读"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/hilog-paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-29</div><div class="info-item-2">OpenHarmony Hilog 架构趣读</div></div><div class="info-2"><div class="info-item-1">最近看到一篇讨论 OpenHarmony Hilog 日志子系统的设计的论文，遂进行了一番阅读。该论文发表在软件学报上。 摘要 分析当今主流日志系统的技术架构和优缺点； 基于 OpenHarmony 操作系统的异构设备互联特性，设计 HiLog 日志系统模型规范； 设计并实现第 1 个面向 OpenHarmony 的日志系统 HiLog, 并贡献到 OpenHarmony 主线； 对 HiLog 日志系统的关键指标进行测试和对比试验；  实现的 HiLog 具有以下特征：  基础性能：日志写入阶段吞吐量分别为 1 500 KB/s 和 700 KB/s，吞吐量相对 Android Log 提升 114%； 日志持久化：压缩率 3.5%，丢包率...</div></div></div></a><a class="pagination-related" href="/review/io-mul-more/" title="更多的 I&#x2F;O 多路复用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/io-mult-more.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-01</div><div class="info-item-2">更多的 I&#x2F;O 多路复用</div></div><div class="info-2"><div class="info-item-1">最近总结了一些 OS I/O 多路复用的知识。之前对 I/O Multiplexer 的认知还停留在 select 系统调用，现在是时候扩展一下视野了。 1. 从 Socket 模型开始Socket 作为一个应用层和传输层间的的抽象，支持网络层 IPv4 / IPv6，以及传输层 TCP / UDP。 双方要进行网络通信前，各自需要创建一个 Socket。 如果是基于 UDP 的套接字：  如果是基于 TCP 的套接字：  以基于 TCP 的套接字为例，首先使用 socket() 创建一个网络协议为 IPv4，以及传输协议为 TCP 的 Socket 结构体，然后使用 bind() 绑定 Server IP 和进程服务端口 port，并监听 listen() 在该端口上（listen 仅改变状态）；  之所以需要指定 Server IP，是因为一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址。Socket 允许指定监听的网卡。0.0.0.0 表示监听所有的 network interfaces； port 即为传输层信息，对应指定线程的服务。  Server 端...</div></div></div></a><a class="pagination-related" href="/technical/xpc-paper/" title="论文阅读 - XPC: Architectural Support for Secure and Efficient Cross Process Call"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/xpc-paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-28</div><div class="info-item-2">论文阅读 - XPC: Architectural Support for Secure and Efficient Cross Process Call</div></div><div class="info-2"><div class="info-item-1">这是一篇 2019 年的关于微内核 IPC 性能优化的文章。 摘要微内核有很多引人注目的 features，例如 安全性、容错性、模块化，以及可定制性，这些特性近期在学术界和工业界又再次掀起了一股研究热潮（including seL4, QNX and Google’s Fuchsia OS）。  Google’s Fuchsia’s kernel (called Zircon)  但是 IPC（进程间通信）作为微内核的 阿喀琉斯之踵，仍然是导致微内核 OS 总体性能较低的主要因素之一。同时 IPC 在宏内核中也扮演者很重要的角色，例如 Android Linux，其中的移动端程序会经常和用户态服务通过 IPC 通信。所以优化 IPC 自然是一个很重要的课题。 之前学界对 IPC 在软件层面的优化都绕不开 Kernel，因为 IPC 在这方面的主要开销就是 域切换（domain switch）和消息复制/重映射（message copying/remapping）；在硬件层面的优化方法主要是 给内存和能力打...</div></div></div></a><a class="pagination-related" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/sc.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</div></div><div class="info-2"><div class="info-item-1">这是一篇 2025 年的关于软硬协同的安全容器设计的文章。 0. Overview虚拟机级别的容器中，每个容器运行在虚拟机虚拟出的独立内核上，因此隔离性很强。但其依赖于通用虚拟机虚拟出的虚拟化硬件，与 OS 级别的容器相比，会导致不可忽略的性能开销。而在嵌套虚拟化场景下，secure container 运行在虚拟机中，这个性能的 gap 会显著地扩大。 本篇文章基于两个角度提出容器内核隔离（CKI），一个软硬协调的高效机密容器设计。  首先，Protection Keys for Supervisor（PKS）可以帮助我们构建一个新的权限级别，用于在 Host Kernel 中安全地配置多个容器内核，而不涉及 non-root ring 0（Intel 中的 Guest Kernel 所处级别）； 其次，secure container 使用的通用虚拟化技术提供很多容器实际隔离并不需要的特性，例如二阶段页表翻译，这引入了可以避免的性能开销；  因此容器内核隔离技术在跑容器内核时：  避免使用虚拟化硬件，并移除不必要的虚拟化技术（像二阶段地址翻译）。它使用 PKS...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SSRVodka</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">78</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%88%87%E6%8D%A2"><span class="toc-text">A. 特权级切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%B6%89%E5%8F%8A%E8%B0%83%E5%BA%A6%EF%BC%9F"><span class="toc-text">如果涉及调度？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">B. 物理内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">C. 虚拟内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#D-%E5%85%A8%E5%B1%80%E8%A7%86%E8%A7%92%EF%BC%9A%E5%86%85%E6%A0%B8%E6%A0%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">D. 全局视角：内核栈是什么？在哪里？</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/transformer/" title="Transformer 论文精读"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/transformer.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Transformer 论文精读"/></a><div class="content"><a class="title" href="/technical/transformer/" title="Transformer 论文精读">Transformer 论文精读</a><time datetime="2025-07-20T15:15:10.000Z" title="发表于 2025-07-20 23:15:10">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/sc.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"/></a><div class="content"><a class="title" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</a><time datetime="2025-07-01T10:14:11.000Z" title="发表于 2025-07-01 18:14:11">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ml-roadmap.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识图谱：Machine Learning Roadmap"/></a><div class="content"><a class="title" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap">知识图谱：Machine Learning Roadmap</a><time datetime="2025-06-08T06:59:31.000Z" title="发表于 2025-06-08 14:59:31">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"/></a><div class="content"><a class="title" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</a><time datetime="2025-05-30T08:49:12.000Z" title="发表于 2025-05-30 16:49:12">2025-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/tee-lab.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机密计算与TEE：知识整理和试验笔记"/></a><div class="content"><a class="title" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记">机密计算与TEE：知识整理和试验笔记</a><time datetime="2025-04-17T15:31:36.000Z" title="发表于 2025-04-17 23:31:36">2025-04-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SSRVodka  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Powered By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>