<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构复习-第四部分 | SJTU-XHW's blog</title><meta name="author" content="SJTU-XHW,sjtuxhw12345@sjtu.edu.cn"><meta name="copyright" content="SJTU-XHW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构复习-第四部分">
<meta property="og:url" content="https://blog.sjtuxhw.top/review/data-structure-4/index.html">
<meta property="og:site_name" content="SJTU-XHW&#39;s blog">
<meta property="og:description" content="本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/ds4.jpeg">
<meta property="article:published_time" content="2023-05-27T08:29:15.000Z">
<meta property="article:modified_time" content="2024-10-25T14:03:36.241Z">
<meta property="article:author" content="SJTU-XHW">
<meta property="article:tag" content="Data-Structure">
<meta property="article:tag" content="Discrete-Math">
<meta property="article:tag" content="External-Search">
<meta property="article:tag" content="B+Tree">
<meta property="article:tag" content="Graph">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/ds4.jpeg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/review/data-structure-4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构复习-第四部分',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-25 22:03:36'
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SJTU-XHW's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/ds4.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SJTU-XHW's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构复习-第四部分</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构复习-第四部分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-27T08:29:15.000Z" title="发表于 2023-05-27 16:29:15">2023-05-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T14:03:36.241Z" title="更新于 2024-10-25 22:03:36">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/review/">review</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/review/data-structure-4/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><i><u>本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充</u></i></p>
<p><i>Written by SJTU-XHW</i></p>
<p><i>Reference: 张同珍老师 PPT | UNIkeEN</i></p>
<hr>
<span id="more"></span>
<h2 id="Chapter-8-外部查找和排序"><a href="#Chapter-8-外部查找和排序" class="headerlink" title="Chapter 8 外部查找和排序"></a>Chapter 8 外部查找和排序</h2><h3 id="8-1-零碎概念集合"><a href="#8-1-零碎概念集合" class="headerlink" title="8.1 零碎概念集合"></a>8.1 零碎概念集合</h3><ul>
<li><p>内存与外存的特性：外存读取访问速率 &lt;&lt; 内存访问速率；</p>
<p><strong>尽可能避免访问，宁可增加计算量……</strong></p>
</li>
<li><p>记录：外存上的<strong>一个数据元素</strong>通常被称为一条记录；</p>
</li>
<li><p>磁道：磁盘表面储存信息的同心圆轨道；</p>
</li>
<li><p>扇区：磁盘的磁道被分为若干段，每段被称为一个扇区；</p>
<blockquote>
<p>一个扇区相当于磁带上的一个数据块，也称<strong>磁盘块</strong>，是<strong>一次磁盘读写</strong>的单位；</p>
</blockquote>
</li>
</ul>
<h3 id="8-2-B-树"><a href="#8-2-B-树" class="headerlink" title="8.2 B 树"></a>8.2 B 树</h3><ul>
<li><p>定义：存储在<strong>外存</strong>上的动态查找表：</p>
<p>一棵 m 阶 B 树或者为空，或者满足：</p>
<ol>
<li><p>根结点的度 <strong>$d_r\in\{0\}\space\bigcup\space[2,\space m]$</strong>；</p>
</li>
<li><p>除了根结点和叶结点外，每个结点的度 <strong>$d\in[\space\lceil\dfrac{m}{2}\rceil,\space m\space]$</strong>；</p>
</li>
<li><p>度为s（s＞0）的结点具有 n = s-1 个关键字，信息存放方式： </p>
<script type="math/tex; mode=display">
(n,\space A_0,\space(K_1, R_1),\space A_1,\space...,\space(K_n, R_n), A_n)</script><ul>
<li>已排序：$K_1\le K_2\le …\le K_n$</li>
<li><strong>$n$</strong>：关键字数；</li>
<li><strong>$A_i$</strong>：指向满足关键字 <strong>$K_i\lt K\lt K_{i+1}$</strong> 的后继结点 的<strong>地址（是磁盘地址编号，可以类比为为内存中的指针）</strong>；</li>
<li><strong>$(K_i, R_i)$</strong>：键值对，{关键字K、目标文件块的地址R}；</li>
</ul>
</li>
<li><p>所有叶结点在同一层，且深度相同、不存在信息（也称“失败结点”）；</p>
</li>
</ol>
</li>
<li><p>加速原理：已知访问次数 <strong>$\varpropto$</strong> 查找树高度；</p>
</li>
<li><p>运算实现</p>
<ul>
<li><p>查找：类似二叉查找树，只不过多了“在结点中查找区间的步骤”</p>
</li>
<li><p>插入</p>
<p><strong>step 1. 先查找，再插入：注意结点内关键字的有序性</strong></p>
<blockquote>
<p>可能违反B树定义1+2：<strong>结点的度可能会超过阶数m</strong>，因此进入第二步；</p>
</blockquote>
<p><strong>step 2. 判断当前插入位的关键字数n（在插入前的）</strong></p>
<ul>
<li><strong>$n\le m-1$</strong>，则不影响，插入结束；</li>
<li><strong>$n=m$</strong>，<strong>必须分裂结点，进入第三步</strong>；</li>
</ul>
<p><strong>step 3. 分裂结点</strong></p>
<blockquote>
<p>不能违反定义1：根结点的度 ≥ 2，和定义2：非根非叶结点度 <strong>$\ge\lceil\dfrac{m}{2}\rceil$</strong>；</p>
</blockquote>
<p>假设原结点<strong>插入后</strong>：</p>
<script type="math/tex; mode=display">
(m,\space A_0,\space(K_1, R_1),\space A_1,\space...,\space(K_{m}, R_{m}), A_{m})</script><p>则<strong>对半分割结点</strong>：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(\lceil\dfrac{m}{2}\rceil-1,\space A_0,\space(K_1,\space R_1),...,(K_{\lceil\cfrac{m}{2}\rceil-1},R_{\lceil\cfrac{m}{2}\rceil-1}),\space A_{\lceil\cfrac{m}{2}\rceil-1}):\space共\lceil\dfrac{m}{2}\rceil-1个\\
&(m-\lceil\dfrac{m}{2}\rceil,\space A_{\lceil\cfrac{m}{2}\rceil},\space(K_{\lceil\cfrac{m}{2}\rceil},\space R_{\lceil\cfrac{m}{2}\rceil}),...,(K_m,\space R_m),\space A_m):\space 共m-\lceil\dfrac{m}{2}\rceil个\\
&注:数学上有\space m-\lceil\dfrac{m}{2}\rceil\ge\lceil\dfrac{m}{2}\rceil-1
\end{aligned}</script><p>再将中间的结点：<strong>$(K_{\lceil\cfrac{m}{2}\rceil},\space R_{\lceil\cfrac{m}{2}\rceil})$</strong> 提到父结点上用以分开两个分裂结点；</p>
<p><strong>step 4. 提升到父结点后，对父结点递归第二步，检查是否违反定义，并及时修正</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="BTreeInsert.jpg"></p>
</li>
<li><p>删除</p>
<p><strong>step 1. 先查找关键字 $K_i$ 的位置，判断是否在底层（下一层为失败结点）</strong></p>
<blockquote>
<p>如果是，跳过第二步；</p>
</blockquote>
<p><strong>step 2. 找“替身”，使用右子树最左关键字（或左子树最右关键字，都位于底层）取代，然后转化为删除底层关键字</strong></p>
<p><strong>step 3. 删除底层结点（注意不是失败结点）</strong></p>
<blockquote>
<p>不能违反定义1、2：根节点度……非根非叶结点度……；</p>
</blockquote>
<ul>
<li><p>删除后，关键字个数 <strong>$n\in[\space\lceil\dfrac{m}{2}\rceil-1\space,m-1\space]$</strong>，符号定义，删除结束；</p>
</li>
<li><p>删除后，关键字个数 <strong>$n=\lceil\dfrac{m}{2}\rceil-2$</strong>，则需要向左 / 右兄弟节点借关键字；</p>
<blockquote>
<p>借的步骤（以左兄弟为例，如果左兄弟恰好<strong>$\lceil\dfrac{m}{2}\rceil-1$</strong>没法借，借右兄弟）：</p>
<p>将左兄弟的最大关键字上移至父结点，再将父结点中大于该关键字的最小关键字（连同左兄弟最右边的指针）下移给被删关键字所在结点的最左边。完成。</p>
</blockquote>
</li>
<li><p>删除后，左、右兄弟结点都是 <strong>$n^\prime=\lceil\dfrac{m}{2}\rceil-1$</strong>，没法借，那么需要<strong>合并结点</strong>；</p>
<blockquote>
<p>合并步骤（以合并左兄弟为例，右兄弟同理）：</p>
<p>将该结点与左兄弟合并，同时下移父结点位于这两个结点间的关键字；</p>
<p><strong>同时，这种情况必须递归检查父结点，如果父结点也因为减少一个关键字而不符定义，则也“先借，不行再合并”</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>运算实现的形象记忆：<strong>膨胀直到分裂；太瘦吸收两侧结点；都瘦合并结点</strong></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>常见疑问：B树的阶数怎么确定？B树的结点怎么组织？算法设计中怎么快速找父结点？</p>
<p>Answer：</p>
<ul>
<li><p>针对第一个问题，应该在实际应用中根据<strong>磁盘块大小、关键字长度、磁盘块地址长度</strong>共同确定B树的阶数；B树阶数的计算思路和B+树类似，可以参考后面<a href="#BPCalc">B+树的阶数计算🔗</a>；</p>
</li>
<li><p>针对第二个问题，和之前的数据结构不一样，B树存在外存上而非内存上，所以我们要定义先确定B树的阶数<strong>【没错，每棵B树的阶数在生命周期中是定值，不能变化】</strong>，然后事先在磁盘块的对应位置分配好各个结点、各个字段的空间位置，这样一棵B树就固定下来了！<strong>以后每访问B树的一个结点（在一个磁盘块大小中），就由 $A_i$ 的指引，在规定的空间完成就行</strong>；</p>
</li>
<li>针对第三个问题，在理解第二个问题后会发现，B树（包括B+树）的父结点的位置可以结合结点在磁盘上的分布（具体设计具体分析）计算出来（或者记录下来，因为存在外存的数据一定很大，一个地址的大小可以忽略不计），不用特意寻找浪费时间；</li>
</ul>
</li>
</ul>
<h3 id="8-3-B-树"><a href="#8-3-B-树" class="headerlink" title="8.3 B+ 树"></a>8.3 B+ 树</h3><blockquote>
<p>出现原因：B树支持快速查找某个记录，但如果要<strong>按关键字大小顺序访问文件的所有记录</strong>，那么时间效率低下；需要一个新型索引结构，来完成对于<strong>索引顺序文件（支持随机访问、按关键字顺序访问的文件）</strong>的访问；</p>
<ol>
<li><p>保证索引有序（像 B 树结点中关键字有序）</p>
</li>
<li><p>保证文件的记录有序</p>
</li>
</ol>
</blockquote>
<ul>
<li><p>定义：M 阶 B+ 树是满足如下条件的 M 叉树：</p>
<ul>
<li><p>根的度满足 <strong>$d_r\in\{0\}\space\bigcup\space[2,\space M]$</strong>；</p>
</li>
<li><p>除根以外的<strong>所有结点</strong>的度满足  <strong>$d\in[\space\lceil\dfrac{M}{2}\rceil,\space M\space]$</strong>；</p>
</li>
<li><p>度为 k 的结点保存 k - 1 个键来引导查找，<strong>第 i 个键代表第 i + 1 子树中的键的最小值</strong></p>
<blockquote>
<p>这意味着 B+ 树和 B 树不同，B+树中非底层（叶结点的上一层）结点存储的键都是出现在底层结点的！</p>
</blockquote>
</li>
<li><p>叶结点包含<strong>数据块（为了访问结点的效率，一个数据块的大小应该设计为一个磁盘块的大小，使得机器在一次 I/O 读写就能完全将内容读进内存）</strong>，其中存放若干记录（键-值对），同时叶结点按序连成单链表；</p>
<blockquote>
<p>这意味着 B+ 树的叶结点 和 非叶结点的<strong>类型不一样</strong>，即内含数据成员不一样；</p>
</blockquote>
</li>
<li><p>叶结点中的每个数据块至少 <strong>$\lceil\dfrac{L}{2}\rceil$</strong> 个记录，至多 L 个记录；</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>B树、B+树重难点题</p>
<ul>
<li><p><span id="BPCalc">B+树阶数计算</span></p>
<blockquote>
<p>已知：一棵 B+ 树的一个非叶结点预分配：M-1个键、M个指针（记录磁盘地址）；叶结点预分配：L个记录、1个指针（构成单链表，但相对于L个记录可忽略不计）；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="BPTreeS.jpg"></p>
</blockquote>
<p>假设：一个磁盘块 W Bytes、一个记录 R Bytes、一个关键字 K Bytes、一个磁盘地址大小 A Bytes，则：</p>
<script type="math/tex; mode=display">
\begin{equation}\left\{
  \begin{aligned}&K\cdot(M-1)+A\cdot M\le W\\
  &L\cdot R\le W\quad(A\ll L\cdot R)\\
  \end{aligned}
  \right.\end{equation}
  \qquad (一般都取等、取整作最优情况)</script></li>
<li><p>插入/删除某个元素后，B/B+树的结构变成什么样子；</p>
</li>
<li><p><strong>含有 n（n＞0）个非叶结点的 m 阶 B 树至少包含多少个关键字、至多包含多少个关键字？</strong>；</p>
<blockquote>
<p>分析：</p>
<p>最少关键字时，每个结点都取最少的度；根结点最小度为2（n＞0 保证根结点不是叶结点）、其他非叶结点最小度为 $\lceil \dfrac{m}{2}\rceil$，所以最小关键字为：$(n-1)(\lceil \dfrac{m}{2}\rceil-1)+1$ ；</p>
<p>最多关键字时，每个结点取最多的度，所有非叶结点的最大度都是 m，所以最多关键字是 $n(m - 1)$；</p>
</blockquote>
</li>
<li><p>一棵 m 阶 B 树有 N 个关键字，则这棵 B 树的最大高度、最小高度（高度含叶结点）分别是？</p>
<blockquote>
<p>分析：</p>
<p>最大高度在所有非叶结点都取最小度时取得（根度为2，非根非叶度为 m/2 向上取整），不妨假设此时高度为 h，非叶结点所占高度为 h - 1；由于 B 树的叶结点在同一层，各个结点非常整齐，那么反推总非叶结点数（包括根结点）：</p>
<script type="math/tex; mode=display">
\begin{aligned}
n_{NL}&=1+2+2\cdot\lceil \dfrac{m}{2}\rceil+\cdots+2\cdot(\lceil\dfrac{m}{2}\rceil)^{h-3}\\
&=1+2\cdot\dfrac{(\lceil\cfrac{m}{2}\rceil)^{h-2}-1}{\lceil\cfrac{m}{2}\rceil-1}
\end{aligned}</script><p>结合”非根非叶度为 m/2 向上取整”的结论，所有非叶结点的关键字数（包括根结点）：</p>
<script type="math/tex; mode=display">
\begin{aligned}
N&=(n_{NL}-1)\cdot(\lceil \dfrac{m}{2}\rceil-1)+1\\
&=2(\lceil \dfrac{m}{2}\rceil)^{h-2}-1
\end{aligned}</script><p>所以：$h\le2+log_{\lceil\cfrac{m}{2}\rceil}(\dfrac{N+1}{2})$；</p>
<p>最小高度同理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n_{NL}&=1+\sum\limits_{k=1}^{h-2}{m^k}=1+\dfrac{m(m^{h-2}-1)}{m-1}\\
N&=(n_{NL}-1)\cdot(m-1)+m-1=m^{h-1}-1
\end{aligned}</script><p>所以：$h\ge 1+log_m(N+1)$；</p>
</blockquote>
<p>综上，得到 B 树的高度结论（其中高度 h 包含叶结点）：</p>
<p><strong>含 N 个关键字的 m 阶 B 树的高度 $h\in[1+log_m(N+1),\space 2+log_{\lceil\cfrac{m}{2}\rceil}(\dfrac{N+1}{2})],\space h\in \mathbf{N^*}$</strong></p>
</li>
<li><p>什么？你问 B+ 树的关键字、高度的计算呢？B+ 树的关键字都在叶结点里，非叶结点中的只是对叶结点的重复、索引，讨论的意义不大；算 B+ 树的阶数才是重点；</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>运算实现</p>
<ul>
<li><p>查找：略</p>
</li>
<li><p>插入</p>
<blockquote>
<p>和 B 树类似，但需要注意的是，B+ 树和 B 树不同，在非叶结点中的键一定存在记录中，并且表示第 i + 1棵子树的最小值，<strong>所以在分裂结点时，没有上移的说法</strong>；</p>
</blockquote>
</li>
<li><p>删除：和 B 树对应的解决方案，<strong>先领养，不行再合并</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="8-4-外排序"><a href="#8-4-外排序" class="headerlink" title="8.4 外排序"></a>8.4 外排序</h3><blockquote>
<p>一般都使用归并排序，这在外排序中极其优秀；</p>
</blockquote>
<p>⚠<strong>易错警示：如果题目说：”多阶段归并是为了最大限定地提高归并的路数“是正确的。不是说多阶段归并本身能提高归并路数，是因为多阶段归并能够提高”路“的利用率（对k路，总路数2k降为k+1），这样在同样大小的内存中，可以选取更大的k值。所以多阶段归并的目的也可以说成（在一定的资源条件下）为了最大限度地提高归并的路数</strong>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="ExSort.jpg"></p>
<p>█◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤图部分将结合离散数学-图论知识共同复习◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█</p>
<h2 id="Chapter-9-图"><a href="#Chapter-9-图" class="headerlink" title="Chapter 9 图"></a>Chapter 9 图</h2><h3 id="9-1-图论中的重要定义Ⅰ"><a href="#9-1-图论中的重要定义Ⅰ" class="headerlink" title="9.1 图论中的重要定义Ⅰ"></a>9.1 图论中的重要定义Ⅰ</h3><blockquote>
<p>图的起源：人们关心一类问题，给定的两点间是否有一条或多条连线的关系，而连接方式无关紧要。这类问题在数学上的抽象是<strong>图</strong>；</p>
</blockquote>
<ul>
<li><p>图的数学定义：一个图指<strong>有序三元组$(V(G),E(G),\psi_G)$</strong>，<strong>$V(G)$</strong>为<strong>非空</strong>（空图特殊，不参与讨论）顶点集，<strong>$E(G)$</strong>是不与<strong>$V(G)$</strong>相交的边集，<strong>$\psi_G$</strong>为关联函数；</p>
<blockquote>
<p>约定：对于图 G，一般用符号 <strong>$V(G)$</strong> 表示顶点集、<strong>$E(G)$</strong> 表示边集、<strong>$\nu(G)$</strong> 表示顶点数，<strong>$\varepsilon(G)$</strong> 表示边数；若上下文仅有一个图，则省略 “(G)”；</p>
<p>注：无向图可以表示为二元组，即 V 和 E；</p>
</blockquote>
</li>
<li><p>顶点对的定义：<strong>$\psi_G$</strong> 使 G 的每条边对应于 G 的 无序的<strong>顶点对</strong>；</p>
</li>
<li><p>连接、端点的定义：若 e 为 G 的一条边，u、v 是使 <strong>$\psi_G(e)=(u,v)$</strong> 的顶点，则称：e <strong>连接</strong> u、v，顶点 u、v 称为 e 的<strong>端点</strong>；</p>
</li>
<li><p>关联、相邻、自环：一条边的端点与这条边<strong>关联</strong>；与同一条边关联的两个顶点称为<strong>相邻</strong>；端点重合为一点的边称为<strong>自环</strong>；</p>
</li>
<li><p>平面图、非平面图：边仅在端点相交的图称为<strong>平面图</strong>，反之为非平面图；</p>
</li>
<li><p>平凡图、非平凡图：仅有一个顶点的图称为<strong>平凡图</strong>；</p>
</li>
<li><p>有向边、无向边：可由端点 <strong>$v_i\space和\space v_j$</strong> 表示 <strong>$e_k=(v_i,v_j)$</strong> 的边称为<strong>无向边</strong>（vi、vj互为直接前驱、直接后继）；可由有序二元组 <strong>$e_k=\lt v_i,v_j\gt$</strong> 表示的边是<strong>有向边</strong>（vi是vj的直接前驱、vj是vi的直接后继）；</p>
</li>
<li><p>有向图、无向图：所有边都是有向边的图是<strong>有向图</strong>，反之是<strong>无向图</strong>，否则是混合图；</p>
<blockquote>
<p>可以将无向边视作双向有向边，因此此后不讨论混合图；</p>
</blockquote>
</li>
<li><p>简单图、有向简单图：既没有<strong>自环</strong>，又没有<strong>重边</strong>的图，如果是无向图，称为<strong>简单图</strong>；如果是有向图，称为<strong>有向简单图</strong>；</p>
<blockquote>
<ol>
<li><p>重边的定义：有两条及以上条边连接同一对顶点，称这个边为重边；</p>
<p>⚠<strong>易错警示：对有向边，A—-&gt;B 和 B—-&gt;A 组合不算重边！A—-&gt;B 和 A—-&gt;B 组合才是</strong>；</p>
</li>
<li><p>如果不强调“有向”，一般情况下“图”指“无向图”；不过在定义中，如果发现只描述无向图的，大概率对有向图也适用，不然就单独拎出来了；</p>
</li>
</ol>
</blockquote>
</li>
<li><p>完全图、有向完全图：每对不同顶点都有一条边相连的<strong>简单</strong>图称为<strong>完全图</strong>；有向完全图同理；</p>
<p><strong>特别地，将 n 个结点的完全图记作 $K_n$，但有向完全图没有这种记法；</strong></p>
<blockquote>
<p><strong>定理1：$\varepsilon(K_n)=C^2_{n}$ 且对n 个结点的有向完全图G：$\varepsilon(G)=A^2_{n}$；</strong></p>
<p>（因为A—-&gt;B 和 B—-&gt;A 组合不算重边） </p>
</blockquote>
</li>
<li><p>偶图（或者称二部图）：一个图 G 的顶点集 <strong>$V(G)$</strong> 可以分解为两个子集 X、Y，使得：每条边都有一个顶点在 X 中，另一个顶点在 Y 中；这样的一种分类 (X, Y) 称为 G 的一个<strong>二分类</strong>；</p>
<blockquote>
<p>理解：按分解的两个点集“切一刀”，所有边都被砍断的图；</p>
</blockquote>
</li>
<li><p>子图：若 <strong>$V(H)\subseteq V(G),\space E(H)\subseteq E(G)$</strong>，<strong>$\psi_H$</strong> 为 <strong>$\psi_G$</strong> 在 <strong>$E(H)$</strong> 上的限制，则 <strong>$H$</strong> 为 <strong>$G$</strong> 的<strong>子图</strong>，记作：<strong>$H\subseteq G$</strong>；（真子图略）</p>
</li>
<li><p>母图：若 <strong>$H\subseteq G$</strong>，称 <strong>$G$</strong> 为 <strong>$H$</strong> 的<strong>母图</strong>；</p>
</li>
<li><p>生成子图（或称支撑子图，spanning sub-graph）：<strong>$H\subseteq G\space且\space V(H)=V(G)$</strong>，称 <strong>$H$</strong> 为 <strong>$G$</strong> 的<strong>生成子图</strong>；</p>
</li>
<li><p>导出子图：有点抽象，一般用不到定义，想要形象地了解见：<a href="#graphCalc">图的运算🔗</a>；</p>
</li>
<li><p>基础简单图：一个图 G 删去所有<strong>“多余”的边</strong>，使图中恰没有重边、自环，得到的这样的<strong>简单生成子图</strong>称为<strong>基础简单图</strong>；</p>
</li>
<li><p>赋权图（或称加权图）：若给图 G 的每条边都赋以实数 <strong>$w_k$</strong> 作为该边的权，称 G 为赋权图；</p>
</li>
<li><p>顶点的度：图 G 的顶点 v 的度记为 <strong>$d_G(v)$</strong>，指 G 中与 v 相关联的数目；</p>
<ul>
<li>约定：<strong>$\delta(G)、\Delta(G)$</strong> 表示 G 的所有顶点的最小度、最大度；</li>
<li>度为0的点称为<strong>孤立点</strong>；</li>
<li><strong>对于有向图，$d(v)=d_+(v)+d_-(v)$，$d_+$ 为正度/入度，$d_-$ 为负度/出度</strong>；</li>
<li><strong>自环贡献一个入度、一个出度</strong>；</li>
</ul>
<blockquote>
<p><strong>定理2：（握手定理）$\sum\limits_{v\in V}d(v)=2\varepsilon$（所有结点的度之和为边数的2倍，有向图也是）</strong>；</p>
<p>推论：对任何图，度为奇数的点（称<strong>奇点</strong>）的个数为偶数；</p>
<p><strong>定理3：有向图中，$\sum{d_-}=\sum{d_+}=\varepsilon$（入度和=出度和=边数，是入度出度平分的意思）</strong></p>
<p><strong>定理4：非空简单图（$\varepsilon\gt1$）一定存在度相同的结点</strong>；</p>
</blockquote>
</li>
</ul>
<h3 id="9-2-图的同构"><a href="#9-2-图的同构" class="headerlink" title="9.2 图的同构"></a>9.2 图的同构</h3><blockquote>
<p>注：图同构问题分为4类：精确图完全同构、精确子图同构、不精确图完全同构、不精确子图同构；现在学界已证明后三者是 NP 完全问题；计算机离散数学-图论、数据结构（包括下面的内容）讨论的是第一种问题；</p>
</blockquote>
<ul>
<li><p>恒等图的定义</p>
</li>
<li><p>同构图的定义：如果存在两个<strong>一一映射（双射）$\theta:\space V(G)\rightarrow V(H),\space\phi:\space E(G)\rightarrow E(H)$</strong>，使 <strong>$\psi_G(e)=(u,v)$</strong> 当且仅当 <strong>$\psi_H(\phi(e))=\theta(u)\theta(v)$</strong>，则将这样的映射对 <strong>$(\theta,\phi)$</strong> 称为 G 和 H 间的一个同构；将 G 与 H 同构关系记为 <strong>$G\cong H$</strong>；</p>
<blockquote>
<p>理解：边边和点点必须一一相应；</p>
<p>就是在不添加边和点、不删除边和点的基础上<strong>任意移动顶点的相对位置、为顶点和边改名</strong>，所产生的不同形态的图；</p>
</blockquote>
</li>
<li><p>关于同构的定理</p>
<blockquote>
<p><strong>定理5：（同构的必要条件）两个同构图的结点度的非增序列相同</strong></p>
<p><strong>定理6：（同构的必要条件）若 G1 与 G2 同构，则 G1 的任意<u>导出子图</u>都有 G2 的导出子图与其同构</strong>；</p>
<p>其实还有一个必要条件过于明显，不作为定理：两同构图的顶点数、边数相等；</p>
</blockquote>
</li>
<li><p>判断方法</p>
<ul>
<li><p>判断两图同构：<strong>按定义，找到两个一一映射</strong>；</p>
<blockquote>
<p>注：根据定义，可以得出一个显然的方法：<strong>一个图的邻接矩阵经历有限次的行互换、列互换，能变成另一个图的邻接矩阵，那么这两个图同构</strong>；</p>
</blockquote>
</li>
<li><p>判断两图不同构：使用定理5、6（必要条件），不满足必要条件的就不是；</p>
</li>
</ul>
</li>
</ul>
<h3 id="9-3-图的存储实现"><a href="#9-3-图的存储实现" class="headerlink" title="9.3 图的存储实现"></a>9.3 图的存储实现</h3><ul>
<li><p><span id="relM">图的关联矩阵（<strong>行是顶点，列是边</strong>）：因为空间原因，不做存储图的方法；</span></p>
<blockquote>
<p>虽然不做存储方法，但在讨论<strong>树、有向连通图、电路图的某些性质</strong>时比较有用，感兴趣戳<a href="#relMDetails">这里🔗</a>（不在初级数据结构要求范围内）；</p>
</blockquote>
<ul>
<li>无向图的关联矩阵：可以由 bool 矩阵表示，1是有关联，0是没有关联；</li>
<li>有向图的关联矩阵：+1表示该边离开该结点，即正度/出度；-1表示该边进入该结点，即负度/入度；0表示没有关联；</li>
</ul>
</li>
<li><p>图的邻接矩阵表示法：对任意的图 G，对应一个 <strong>$\nu\times\nu$</strong> 的邻接矩阵 <strong>$A(G)=[a_{ij}]$</strong>，其中 <strong>$a_{ij}$</strong> 为 <strong>$v_i、v_j$</strong> 的连接数目；（空间：<strong>$O(|V|^2)$</strong>）</p>
<p><strong>进一步，在数据结构中更常用的是“加权图的邻接矩阵”存储方法，可以兼顾非加权图：</strong></p>
<script type="math/tex; mode=display">
A[i][j]=\begin{equation}\left\{\begin{aligned}&\omega,&<i,j,w>\in E\\
&0,&i=j\\
&\infty,&otherwise\\
\end{aligned}\right.\end{equation}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjMatrixGraph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VType* vertices;    <span class="comment">// store the data of each vertex.</span></span><br><span class="line">    EType** edges;      <span class="comment">// store the data of each edge (in adjacent matrix form).</span></span><br><span class="line">    EType noEdgeFlag;    <span class="comment">// represent the no-edge area.</span></span><br><span class="line">    <span class="type">int</span> vertixNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vertexIdx</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertixNum; ++i)</span><br><span class="line">            <span class="keyword">if</span> (vertices[i] == v) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">vertexNotExists</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">bool</span> visited[])</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">adjMatrixGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">const</span> EType&amp; noEdge);</span><br><span class="line">    <span class="built_in">adjMatrixGraph</span>(<span class="type">const</span> adjMatrixGraph&lt;VType, EType&gt;&amp; cp) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">adjMatrixGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjMatrix</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_nonRecur</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图的邻接表表示法：改进了邻接矩阵表示法在面对稀疏矩阵时浪费空间、不易维护的问题；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">结点集(结点数组)：node1 &#123;结点值，与该结点相邻的直接后继(有方向)结点索引链表头指针&#125;</span><br><span class="line"> |------------------------------------------------------------|</span><br><span class="line"> v</span><br><span class="line">边集(单链表)：node2 &#123;结点索引（不能放结点值，因为无法完成后面的遍历运算, 下一node2&#125;</span><br><span class="line"></span><br><span class="line">+ 保存边数、保存结点数</span><br><span class="line">空间：O(|V|+|E|)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjListGraph</span>: <span class="keyword">public</span> graph&lt;VType, EType&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        EType weight;</span><br><span class="line">        eNode* next;</span><br><span class="line">        <span class="built_in">eNode</span>(): <span class="built_in">end</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">eNode</span>(<span class="type">const</span> EType&amp; w, <span class="type">int</span> e=<span class="number">0</span>, eNode* nxt=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">weight</span>(w), <span class="built_in">end</span>(e), <span class="built_in">next</span>(nxt) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">vNode</span> &#123;</span><br><span class="line">        VType data;</span><br><span class="line">        eNode* edge;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EulerNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> nodeIdx;</span><br><span class="line">        EulerNode* next;</span><br><span class="line">        <span class="built_in">EulerNode</span>(<span class="type">int</span> idx=<span class="number">0</span>, EulerNode* n=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">nodeIdx</span>(idx), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vNode* vertices;</span><br><span class="line">    <span class="type">bool</span> directed;</span><br><span class="line">    <span class="type">int</span> vertixNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vertexIdx</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertixNum; ++i)</span><br><span class="line">            <span class="keyword">if</span> (vertices[i].data == v) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">vertexNotExists</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typename</span> adjListGraph&lt;VType, EType&gt;::<span class="function">vNode* <span class="title">cloneBase</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">bool</span> visited[])</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _insert(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">const</span> EType&amp; w);</span><br><span class="line">    <span class="type">void</span> _remove(<span class="type">int</span> v1, <span class="type">int</span> v2);</span><br><span class="line">    <span class="type">int</span> _getInDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> _getOutDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> _getDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">void</span> _EulerCircuit(<span class="type">int</span> start, EulerNode*&amp; begin, EulerNode*&amp; end);</span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">topoSortIdx</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">criticalPath</span><span class="params">(<span class="type">int</span>* early, <span class="type">int</span>* late)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> prev[])</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">adjListGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">bool</span> direct=<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">adjListGraph</span>(<span class="type">const</span> adjListGraph&lt;VType, EType&gt;&amp; cp);</span><br><span class="line">    <span class="built_in">adjListGraph</span>(adjListGraph&lt;VType, EType&gt;&amp;&amp; tmp);</span><br><span class="line">    ~<span class="built_in">adjListGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getInDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getOutDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjList</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_nonRecur</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_dfs_tree</span><span class="params">(<span class="type">const</span> VType&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_bfs_tree</span><span class="params">(<span class="type">const</span> VType&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EulerCircuit</span><span class="params">(<span class="type">const</span> VType&amp; start)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">criticalPath</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// The shortest path for the graph: O(n^3)</span></span><br><span class="line">    <span class="function">VType* <span class="title">dijkstra</span><span class="params">(<span class="type">const</span> VType&amp; start, <span class="type">const</span> EType&amp; noEdge, <span class="type">bool</span> prompt=<span class="literal">false</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">VType* <span class="title">SPFA</span><span class="params">(<span class="type">const</span> VType&amp; start, <span class="type">const</span> EType&amp; noEdge)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="9-4-图的运算实现（except-for-traverse）"><a href="#9-4-图的运算实现（except-for-traverse）" class="headerlink" title="9.4 图的运算实现（except for traverse）"></a>9.4 图的运算实现（except for traverse）</h3><ul>
<li><p><span id="graphCalc">图的基本运算</span></p>
<ul>
<li><p>差运算：<strong>（要求 $G_2$ 为 $G_1$ 子图）$G_1-G_2=(V_1,E_1-E_2)$</strong>；</p>
</li>
<li><p>补运算：<strong>$n$</strong> 个结点的简单图的补图 <strong>$\overline{G}=K_n-G$</strong>；</p>
</li>
<li><p>删去结点 <strong>$v$</strong> 及其关联的边：<strong>$G-v$</strong></p>
<blockquote>
<p><strong>$G-v$</strong> 为 <strong>$G$</strong> 的<strong>导出子图</strong>：有助于理解导出子图的意义；</p>
</blockquote>
</li>
<li><p>删去边 <strong>$e$</strong>：<strong>$G-e$</strong></p>
<blockquote>
<p><strong>$G-e$</strong> 为 <strong>$G$</strong> 的<strong>生成子图</strong>：有助于理解生成子图的意义；</p>
</blockquote>
</li>
<li><p>增加边 <strong>$e_{ij}=(v_i,v_j)$</strong>：<strong>$G+e_{ij}$</strong></p>
</li>
</ul>
</li>
<li><p>数据结构中图的基本运算：创建、判边、增删边、查点边数、遍历（后面分开讨论）；</p>
</li>
<li><p>图的运算实现：<strong>对于不同的存储方式，图的运算时间复杂度有所不同</strong></p>
<ul>
<li><p>邻接矩阵表示的运算实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">adjMatrixGraph</span>(</span><br><span class="line">    <span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">const</span> EType&amp; noEdge) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = vSize; <span class="keyword">this</span>-&gt;edgeNum = <span class="number">0</span>; noEdgeFlag = noEdge;</span><br><span class="line">    vertices = <span class="keyword">new</span> VType[vSize];</span><br><span class="line">    edges = <span class="keyword">new</span> EType*[vSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vSize; ++i) &#123;</span><br><span class="line">        vertices[i] = vers[i];</span><br><span class="line">        edges[i] = <span class="keyword">new</span> EType[vSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vSize; ++j)</span><br><span class="line">            edges[i][j] = noEdge;</span><br><span class="line">        edges[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjMatrixGraph&lt;VType, EType&gt;::~<span class="built_in">adjMatrixGraph</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] vertices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] edges[i];</span><br><span class="line">    <span class="keyword">delete</span>[] edges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">bool</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">exist</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">return</span> edges[u][v] != noEdgeFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">undirected_insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    <span class="keyword">if</span> (edges[v][u] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = edges[v][u] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">remove</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] != noEdgeFlag) --<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = noEdgeFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">printAdjMatrix</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j)</span><br><span class="line">            std::cout &lt;&lt; edges[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>邻接表表示的运算实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">bool</span> direct) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = vSize; directed = direct;</span><br><span class="line">    <span class="keyword">this</span>-&gt;edgeNum = <span class="number">0</span>; vertices = <span class="keyword">new</span> vNode[vSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vSize; ++i) &#123;</span><br><span class="line">        vertices[i].data = vers[i];</span><br><span class="line">        vertices[i].edge = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::~<span class="built_in">adjListGraph</span>() &#123;</span><br><span class="line">    eNode* curEdge;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curEdge = vertices[i].edge) &#123;</span><br><span class="line">            vertices[i].edge = curEdge-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> curEdge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vertices) <span class="keyword">delete</span>[] vertices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> adjListGraph&lt;VType, EType&gt;::vNode* adjListGraph&lt;VType, EType&gt;::<span class="built_in">cloneBase</span>() <span class="type">const</span> &#123;</span><br><span class="line">    vNode* newVers = <span class="keyword">new</span> vNode[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        newVers[i].data = vertices[i].data;</span><br><span class="line">        newVers[i].edge = <span class="literal">nullptr</span>;</span><br><span class="line">        eNode** curEdgeDst = &amp;(newVers[i].edge);</span><br><span class="line">        eNode* curEdgeSrc = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdgeSrc) &#123;</span><br><span class="line">            *curEdgeDst = <span class="keyword">new</span> <span class="built_in">eNode</span>(curEdgeSrc-&gt;weight, curEdgeSrc-&gt;end, <span class="number">0</span>);</span><br><span class="line">            curEdgeDst = &amp;((*curEdgeDst)-&gt;next);</span><br><span class="line">            curEdgeSrc = curEdgeSrc-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newVers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(<span class="type">const</span> adjListGraph&lt;VType, EType&gt;&amp; cp) &#123;</span><br><span class="line">    vertices = cp.<span class="built_in">cloneBase</span>(); <span class="keyword">this</span>-&gt;edgeNum = cp.edgeNum;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = cp.vertixNum; directed = cp.directed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(adjListGraph&lt;VType, EType&gt;&amp;&amp; tmp) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;edgeNum = tmp.edgeNum; <span class="keyword">this</span>-&gt;vertixNum = tmp.vertixNum; directed = tmp.directed;</span><br><span class="line">    tmp.edgeNum = tmp.vertixNum = <span class="number">0</span>; vertices = tmp.vertices; tmp.vertices = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">bool</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">exist</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="type">const</span> eNode* cur = vertices[u].edge;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;end == v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::_insert(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    eNode** cur = &amp;(vertices[v1].edge);</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;end != v2) cur = &amp;((*cur)-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (!(*cur)) &#123; ++<span class="keyword">this</span>-&gt;edgeNum; *cur = <span class="keyword">new</span> <span class="built_in">eNode</span>(w, v2); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::_remove(<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">    eNode** cur = &amp;(vertices[v1].edge);</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;end != v2) cur = &amp;((*cur)-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (*cur) &#123;</span><br><span class="line">        eNode* tmp = *cur; *cur = (*cur)-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp; --<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    _insert(u, v, w);</span><br><span class="line">    <span class="keyword">if</span> (!directed) _insert(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">remove</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    _remove(u, v);</span><br><span class="line">    <span class="keyword">if</span> (!directed) _remove(v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getInDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == v) <span class="keyword">continue</span>;</span><br><span class="line">        eNode* curEdge = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEdge-&gt;end == v) ++ans;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getOutDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    eNode* target = vertices[v].edge;</span><br><span class="line">    <span class="keyword">while</span> (target) &#123; ++ans; target = target-&gt;next; &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (directed) <span class="keyword">return</span> _getInDegree(v) + _getOutDegree(v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> _getOutDegree(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getInDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getInDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getOutDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getOutDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">printAdjList</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; vertices[i].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">const</span> eNode* cur = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;|-w=&quot;</span> &lt;&lt; cur-&gt;weight</span><br><span class="line">                &lt;&lt; <span class="string">&quot;-&gt;(&quot;</span> &lt;&lt; cur-&gt;end &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="9-5-图论中的重要定义Ⅱ"><a href="#9-5-图论中的重要定义Ⅱ" class="headerlink" title="9.5 图论中的重要定义Ⅱ"></a>9.5 图论中的重要定义Ⅱ</h3><ul>
<li><p>道路和回路：在无向图 <strong>$G=(V,E)$</strong> 中，若<u>边点交替序列</u> <strong>$P=(v_{i1},e_{i1},v_{i2},e_{i2},…,e_{iq-1},v_{iq})$</strong> 满足：<strong>$v_{ik}、v_{ik+1}$</strong> 为 <strong>$e_{ik}$</strong> 的两个端点，则称 P 为 G 的一条<strong>道路</strong>；特别地，如果 <strong>$v_{i1}=v_{iq}$</strong>，那么称道路 P 为 G 的一条<strong>回路</strong>；</p>
<ul>
<li>如果 P 序列中没有重复的边，则 P 称为<strong>简单道路（或称“迹”）、简单回路（或称“闭迹”）</strong>；</li>
<li>更特别地，如果 P 序列中结点也不重复（结点不重复是边不重复的充分不必要条件），则称 P 为 G 的<strong>初级道路、初级回路</strong>；</li>
</ul>
</li>
<li><p>有向道路和有向回路：在有向图 <strong>$G=(V,E,\psi_G)$</strong> 中，若<u>边序列</u> <strong>$P=(e_{i1},e_{i2},…,e_{iq})$</strong>，其中  <strong>$e_{ik}=(v_l, v_j)$</strong>，则称 P 为 G 的<strong>有向道路</strong>；若 <strong>$e_{iq}$</strong> 终点也是 <strong>$e_{i1}$</strong> 的始点，则称 P 为 G 的<strong>有向回路</strong>；</p>
<ul>
<li>同样有：简单有向道路、简单有向回路、初级有向道路、初级有向回路的概念；</li>
</ul>
<blockquote>
<p>⚠易错点：<strong>平凡图一定是道路，但一定不是回路！</strong></p>
</blockquote>
</li>
<li><p>连通性、强连通性、弱连通性、单向连通性</p>
<ul>
<li>无向图考虑“连通”：两结点间至少存在一条道路，则这两个结点间连通；</li>
<li>有向图考虑：<ol>
<li>两结点间存在一条从 <strong>$v_i$</strong> 到 <strong>$v_j$</strong> 的有向道路 <strong><u>且</u></strong> 存在另一条从 <strong>$v_j$</strong> 到 <strong>$v_i$</strong> 的有向道路，则称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>强连通</strong>；</li>
<li>两结点间<strong><u>仅</u></strong>存在一条从 <strong>$v_i$</strong> 到 <strong>$v_j$</strong> 的有向道路 <strong><u>或</u></strong> <strong><u>仅</u></strong>存在另一条从 <strong>$v_j$</strong> 到 <strong>$v_i$</strong> 的有向道路，则称称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>单向连通</strong>；</li>
<li>两结点间 <strong>不考虑所有道路的方向（称为“有向图的底图”）</strong>，若这两个结点连通，则称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>弱连通</strong>；</li>
</ol>
</li>
</ul>
</li>
<li><p>连通图、连通分量（或称“连通支”）</p>
<ul>
<li>无向图 G 中任意两结点间都是连通的，则 G 为<strong>连通图</strong>；</li>
<li>G 的连通子图（子图且连通）H 不是 G 的任何其他连通子图的真子图，称 H 为 G 的一个<strong>极大连通子图</strong>，也称<strong>连通分量</strong>；</li>
</ul>
<blockquote>
<p>有些不严谨的题问有向图“是不是连通图”，就将它看成一个无向图（忽略方向）；</p>
</blockquote>
</li>
<li><p>强连通图、强连通分量</p>
<ul>
<li>有向图 G 中任意两结点间都是强连通的，则 G 为<strong>强连通图</strong>；</li>
<li>G 的强连通子图 H 不是 G 的任何其他强连通子图的真子图，称 H 为 G 的一个<strong>极大的强连通子图</strong>，也称<strong>强连通分量</strong>；</li>
</ul>
<blockquote>
<p>⚠易错点1：<strong>平凡图也单独算一个连通分量 / 强连通分量！</strong></p>
<p>⚠易错点2：因为无向边看作“双向边”，所以连通的无向图一定是强连通的；</p>
<p><strong>推论：图 G 的每个连通分支都是其导出子图</strong>；</p>
<p><strong>小结论：图 G 对应关联矩阵记为 $M(G)$，则 G 的连通分支数为 $r(M(G))-1$</strong>；</p>
</blockquote>
</li>
<li><p>割边与非割边、割点与非割点：删去图中某个边 / 点，图的连通分支数（连通性）改变，则称该边 / 点为<strong>割边 / 割点</strong>；</p>
</li>
<li><p>欧拉道路、欧拉回路：<strong>无向连通图</strong> G 中的一条经过<u>所有边</u>的<strong>简单道路/回路</strong>称 G 的<strong>欧拉道路/回路</strong>；</p>
<ul>
<li><p>理解：不重复地遍历所有边，不管点的情况；</p>
</li>
<li><p>注意：<strong>有向图也能讨论欧拉回路的问题，不过要遵循有向的连通性</strong>；</p>
</li>
</ul>
<blockquote>
<p><strong>定理1：（欧拉回路充要条件）无向连通图 G 存在欧拉回路 $\Longleftrightarrow$ G 的各结点度数均为偶数</strong>；</p>
<p><strong>推论1-1：（欧拉道路充分条件）无向连通图 G 仅有2个奇点 $\Longrightarrow$ G 存在欧拉道路</strong>；</p>
<p><strong>推论1-2：（有向欧拉回路充分条件）有向连通图 G 的各结点的正、负度数相等 $\Longrightarrow$ G 存在有向欧拉回路</strong>（侧面说明有向可能严格一些，不仅结点度全为偶数，而且要进出相等）；</p>
<p>定理2：连通图 G 有 k 个奇点（由部分Ⅰ的定理可知，k为偶数），则 E(G) 可以划分为 <strong>$\dfrac{k}{2}$</strong> 条简单道路；</p>
</blockquote>
</li>
<li><p>哈密顿道路、哈密顿回路：<strong>无向图</strong> G 的一条<u>经过全部结点</u>的<strong>初级道路/回路</strong>称 G 的<strong>哈密顿道路/回路（简称H道路/H回路）</strong>；</p>
<ul>
<li>理解：“不重复地遍历所有点”；</li>
<li>注意：H 道路 / 回路一般针对简单图，因为重边和自环对它没有什么影响，可以转换为简单图的问题；</li>
</ul>
<blockquote>
<p><strong>很遗憾，目前 H 道路 / 回路的判定没有充要条件！一般遍历是 NP 问题……</strong></p>
<p><strong>定理3：（H 回路充分条件）完全图 $K_n$ 为 H 图</strong>；</p>
<p><strong>定理4：（H 回路充分条件）若简单图 G 每个结点度都大于 n/2，则 G 为 H 图</strong>；</p>
<p>说明：平均每个点的度越大，越有可能有H道路、H回路；</p>
<p><strong>推论4-1：（H 道路充分条件）若简单图 G 的任两结点 $v_i,v_j$ 恒有 $d(v_i)+d(v_j)\ge n-1$，则 G 存在 H 道路；</strong></p>
<p>证明提示：有 H 道路一定连通，可以先证连通性；</p>
<p><strong>推论4-2：（H 回路充分条件）若简单图 G 的任两结点 $v_i,v_j$ 恒有 $d(v_i)+d(v_j)\ge n$，则 G 为 H 图</strong>；</p>
<p><strong>推论4-3：（H 回路的闭包等价关系）向图 G 中满足 “ $d(v_i)+d(v_j)\ge n$”的不相邻两结点 $v_i,v_j$ 加边，直至无法找到这样的结点对为止，形成的新图称为 G 的闭包（记为$C(G)$）；那么有：$G\space为H图\Longleftrightarrow C(G)为H图$</strong>；</p>
<p><strong>推论4-4：（H回路闭包充分条件）若 $C(G)=K_n$，则 G 为 H 图</strong>；</p>
<p><strong>定理5：（可怜为数不多的 H 回路的必要条件）若 G 为 H 图，则对任意非空顶点集 S，有：$\omega(G-S)\le|S|$</strong>；</p>
</blockquote>
<ul>
<li><p>补充：欧拉图、H 图的定义：有欧拉回路 / H 回路的图才叫~（只有欧拉道路 / H 道路的不是）；</p>
</li>
<li><p>判断一个图是 H 图：使用上面的充分条件/等价条件；</p>
</li>
<li><p>判断一个图不是 H 图：使用上面的必要条件；</p>
<blockquote>
<p>举例：证明 Peterson 图是极大非 H 图（有 H 道路，但没有 H 回路）</p>
<p>【问题：它满足定理5，能否判断一下为什么在删去任意4个顶点时，连通分支数一定小于等于3？】</p>
<p><strong>定理6：（必要条件）若一个点在 H 回路中，那么必定有且仅有两个相连的相异道路</strong>；</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="9-6-图的简单应用"><a href="#9-6-图的简单应用" class="headerlink" title="9.6 图的简单应用"></a>9.6 图的简单应用</h3><ul>
<li>【普通图】有 3L、5L、8L的三个没有刻度的量杯，现在8L的量杯装满了水，其他两个是空的；问如何操作（不撒不漏）可以让8L水分为两个4L水？</li>
<li>【二部图】人、狼、羊、菜过河问题</li>
</ul>
<blockquote>
<p>解决思路：<strong>“状态转换图”：</strong>将每一个状态抽象为一个顶点，先列出所有可能状态作为顶点，再用“一次能直接转换的关系”作为边连接，最后只需判断在起点（初态）和终点（末态）是否单向连通即可；</p>
</blockquote>
<h3 id="9-7-图论中的重要定义Ⅲ"><a href="#9-7-图论中的重要定义Ⅲ" class="headerlink" title="9.7 图论中的重要定义Ⅲ"></a>9.7 图论中的重要定义Ⅲ</h3><blockquote>
<p>提示：本章节不在初级数据结构要求范围内；</p>
</blockquote>
<ul>
<li><p>割边与非割边、割点与非割点：删去图中某个边 / 点，图的连通分支数（连通性）改变，则称该边 / 点为<strong>割边 / 割点</strong>；</p>
<blockquote>
<p><strong>定理1：e 为割边，当且仅当 e 不属于 G 的任何回路</strong>；</p>
</blockquote>
</li>
<li><p>普通树的数学定义：不含任何回路的连通图称为<strong>树</strong>；</p>
<blockquote>
<p><strong>定理2：“连通”、“无回路”、“有 n-1 条边”三个条件任取两个都可以作为树的定义</strong>；</p>
<p>推论：“连通+全为割边”、“任意两点间有唯一道路”、“无回路+加一边就一回路” 这三个与树的定义等价；</p>
<p><strong>定理3：树中一定有树叶结点（离散数学中没有空树的说法！只有空图）</strong></p>
</blockquote>
</li>
<li><p>根树的定义：若树 T 是有向树，且 T 中存在某结点 $v_0$ 的入度为0、其他结点入度为1，则称 <strong>T 是以 $v_0$ 为根的根树</strong>（或外向树），用 $\overrightarrow{T}$ 表示；</p>
<blockquote>
<p><strong>根树才是数据结构中的“树”！</strong></p>
</blockquote>
</li>
<li><p>生成树（或称“支撑树”）：图 G 的一个符合树定义的生成子图称为图 G 的<strong>生成树</strong>；</p>
<blockquote>
<p>余树：给定图 G 的一棵生成树 T，定义余树 $\overline{T}=G-T$；一般情况下，余树不是树；</p>
</blockquote>
</li>
<li><p><span id="relMDetails">基本关联矩阵：<strong>上接“<a href="#relM">关联矩阵存储🔗</a>”，虽然关联矩阵一般不作为存储方法，但有些情况讨论它的性质，可以更方便地解决某些问题</strong>；</span></p>
<blockquote>
<p>友情提醒1：这里和<strong>电路理论的电路图研究</strong>结合比较紧密；</p>
<p>友情提醒2：这里的讨论对象是<strong>有向连通图</strong>；</p>
</blockquote>
<ul>
<li>定义：在<strong>有向连通图 $G=(V, E)$</strong> 的<strong>关联矩阵 $B$</strong> 中，划去任意任意结点 $v_k$所对应的一<strong>行</strong>，得到 <strong>$(\nu-1)\times\varepsilon$</strong> 的矩阵 $B_k$，称为 <strong>G 的一个基本关联矩阵</strong>；</li>
<li>相关定理</li>
</ul>
<blockquote>
<p><strong>定理1：有向连通图 G 的关联矩阵 B 满足：$r(B)=\nu-1$</strong>；</p>
<p><strong>定理2：有向连通图 G 的基本关联矩阵 $B_k$ 满足：$r(B_k)=\nu-1$</strong>；</p>
<p>推论：n个结点树 T 的基本关联矩阵的秩为 $\nu-1$；</p>
<p><strong>定理3：有向连通图 G 如果存在回路 C，则 C 中各边所对应基本关联矩阵 $B_k$ 的各列线性相关</strong>；</p>
<p><strong>定理4：有向连通图 G 的基本关联矩阵 $B_k$，有：$B_k任意n-1阶子式M_{n-1}\ne0\Longleftrightarrow M_{n-1}各列对应边构成G的一棵生成树$</strong>；</p>
<p>定理4说明了<strong>可以由 $B_k$ 的非零 n-1 阶子式的数目来代表 $G$ 生成树的数目<a href="#genTCount">🔗</a></strong>；</p>
</blockquote>
</li>
<li><p>回路矩阵和割集矩阵；</p>
<blockquote>
<p>不说了亲，这边建议您好好复习电路理论课呢:sweat_smile:</p>
</blockquote>
</li>
<li><p>Huffman树（最优二叉树），详见“数据结构复习-第二部分”；</p>
</li>
</ul>
<h3 id="9-8-图的经典算法"><a href="#9-8-图的经典算法" class="headerlink" title="9.8 图的经典算法"></a>9.8 图的经典算法</h3><h4 id="9-8-1-图的遍历算法"><a href="#9-8-1-图的遍历算法" class="headerlink" title="9.8.1 图的遍历算法"></a>9.8.1 图的遍历算法</h4><ul>
<li><p>DFS 算法：类似树的前序遍历</p>
<p>邻接表存储 $O(|V|+|E|)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>(<span class="type">int</span> start, <span class="type">bool</span> visited[]) <span class="type">const</span> &#123;</span><br><span class="line">    eNode* curEdge = vertices[start].edge;</span><br><span class="line">    std::cout &lt;&lt; vertices[start].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[curEdge-&gt;end]) <span class="built_in">dfs</span>(curEdge-&gt;end, visited);</span><br><span class="line">        curEdge = curEdge-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs_nonRecur</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; tasks;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// Necessary when doing non-recursive op.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            eNode* curEdge = vertices[tmp].edge;</span><br><span class="line">            <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[curEdge-&gt;end])</span><br><span class="line">                    tasks.<span class="built_in">push</span>(curEdge-&gt;end);</span><br><span class="line">                curEdge = curEdge-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>邻接矩阵存储 $O(|V|^2)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>(<span class="type">int</span> start, <span class="type">bool</span> visited[]) <span class="type">const</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; vertices[start] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i] &amp;&amp; edges[start][i] != noEdgeFlag)</span><br><span class="line">            <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs_nonRecur</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; tasks;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;</span><br><span class="line">            std::cout &lt;&lt; vertices[tmp] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tmp + <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; edges[tmp][j] != noEdgeFlag)</span><br><span class="line">                    tasks.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BFS 算法：类似树的层次遍历</p>
<p>邻接表存储 $O(|V|+|E|)$ </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">bfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; taskQ;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        taskQ.<span class="built_in">enQueue</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!taskQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = taskQ.<span class="built_in">deQueue</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// necessary.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            eNode* curEdge = vertices[tmp].edge;</span><br><span class="line">            <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[curEdge-&gt;end])</span><br><span class="line">                    taskQ.<span class="built_in">enQueue</span>(curEdge-&gt;end);</span><br><span class="line">                curEdge = curEdge-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>邻接矩阵存储 $O(|V|^2)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">bfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; taskQ;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        taskQ.<span class="built_in">enQueue</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!taskQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = taskQ.<span class="built_in">deQueue</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// necessary when doing no-recursive op.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tmp + <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; edges[tmp][j] != noEdgeFlag)</span><br><span class="line">                    taskQ.<span class="built_in">enQueue</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-8-2-两点间道路判定算法"><a href="#9-8-2-两点间道路判定算法" class="headerlink" title="9.8.2 两点间道路判定算法"></a>9.8.2 两点间道路判定算法</h4><blockquote>
<p>这里介绍邻接矩阵表示的算法，比较常见；</p>
</blockquote>
<ul>
<li><p>引入：对于一个<strong>非加权图的邻接矩阵（0&amp;1）</strong>，有 $P=(p_{ij})_{n\times n}=\sum\limits_{k=1}^n{A^k}$，则 $p_{ij}$ 为从 $v_i$ 到 $v_j$ 的<strong>道路数</strong>；实际问题只关心<strong>是否有道路</strong>，所以可以改成逻辑运算提升速度：$P=(p_{ij})_{n\times n}=\bigvee\limits_{k=1}^n{A^k}$，时间复杂度 $O(\nu^4)$；</p>
</li>
<li><p>Warshell算法 $O(\nu^3)$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P &lt;- A</span><br><span class="line">for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">    for (int j = 1; j &lt;= n; ++j)</span><br><span class="line">        for (int k = 1; k &lt;= n; ++k)</span><br><span class="line">            p_&#123;jk&#125; &lt;- p_&#123;jk&#125; V (p_&#123;ji&#125; Λ p_&#123;ik&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>DFS 和 BFS $O(\varepsilon)$：和图的遍历不一样的是，它比图的遍历更简单，只需从一个点出发（减少最外层循环），用visited数组和BFS/DFS整体寻找，如果遇到终点即停止并返回true，否则返回false；</p>
</li>
</ul>
<h4 id="9-8-3-有向图强连通分支判断算法"><a href="#9-8-3-有向图强连通分支判断算法" class="headerlink" title="9.8.3 有向图强连通分支判断算法"></a>9.8.3 有向图强连通分支判断算法</h4><blockquote>
<p>思路：先从图 G 任一点开始 DFS，如果 G 不是强连通图，则可能得到一个深度优先生成森林；对森林中的每棵树按照<strong>生成次序</strong>依此进行<strong>后序遍历</strong>，并按遍历顺序给每个结点编号（从小到大）；</p>
<p>然后使 G 的每条边逆向，得到 Gr，再从 Gr 编号最大的结点开始 DFS，得到新的深度优先遍历森林中的<strong>每一棵树</strong>就是 G 的一个强连通分量；</p>
</blockquote>
<h4 id="9-8-4-欧拉回路的构造算法"><a href="#9-8-4-欧拉回路的构造算法" class="headerlink" title="9.8.4 欧拉回路的构造算法"></a>9.8.4 欧拉回路的构造算法</h4><blockquote>
<p>欧拉回路有明确的、好判断的充要条件，所以算法设计相对容易；</p>
<p>无论啥算法，最好先利用充要条件排除没有欧拉回路的图，能大大提高时间性能；</p>
<p>下面讨论<strong>如果有欧拉回路，应该怎么找</strong>的算法：</p>
</blockquote>
<ul>
<li>拼接法：DFS寻找回路（经过即删除），如果回路结束却仍然有未遍历的结点，则从新的未访问的结点开始遍历回路，<strong>并拼接（“8”字原理）</strong>，循环直到所有边已被访问；</li>
<li>Floyd算法（非割边优先遍历）</li>
</ul>
<h4 id="9-8-5-欧拉回路的应用：中国邮递员问题（CPP）"><a href="#9-8-5-欧拉回路的应用：中国邮递员问题（CPP）" class="headerlink" title="9.8.5 欧拉回路的应用：中国邮递员问题（CPP）"></a>9.8.5 欧拉回路的应用：中国邮递员问题（CPP）</h4><blockquote>
<p>中国邮递员问题：<strong>走遍图中的所有边</strong>后返回返回起点，要求<strong>总路程最短</strong>；</p>
</blockquote>
<ul>
<li><p>对于无向图 G 的结论</p>
<ul>
<li><p>如果 G 中所有结点个数都是偶数：该图的任一欧拉回路都是解；</p>
</li>
<li><p>如果 G 中有且仅有 2 个奇点 $v_i\space和\space v_j$：找到 G 从  $v_i$ 到 $v_j$ <strong>欧拉道路 $E_{ij}$</strong>，再找从  $v_j$ 到 $v_i$ 的<strong>最短路径 $P_{ji}$</strong>，则回路 <strong>$E_{ij}+P_{ji}$</strong> 就是问题的解；</p>
</li>
<li><p>如果 G 中有两个以上，共2k个奇点（由前面图的性质推论，奇点必有偶数个）：</p>
<script type="math/tex; mode=display">
图G有最佳邮路L\Longleftrightarrow\begin{equation}\left\{\begin{aligned}&1.\space L的任一边最多重复一次\\&2.\space对G中的任一回路C，L中在C上重复边的长度之和\\&\quad不超过C总长的一半\space(C必须包含所有重边)\\\end{aligned}\right.\end{equation}</script><p><strong>实际做法是：找出所有奇点，两两配对并依此为奇点间添加重复边（长度和原边相等），为它们配对成偶点，得到新图，也即邮路 $L_x$；再检查 $L_x$ 是否满足以上两个条件；如果违反第一条则一次性删除两条多余重边，如果违反第二条则将 $L_x$ 的该段道路改成与 $C$ 互补的道路</strong>；</p>
</li>
</ul>
</li>
</ul>
<h4 id="9-8-6-H-回路的应用：旅行商问题（TSP）"><a href="#9-8-6-H-回路的应用：旅行商问题（TSP）" class="headerlink" title="9.8.6 H 回路的应用：旅行商问题（TSP）"></a>9.8.6 H 回路的应用：旅行商问题（TSP）</h4><ul>
<li>问题描述：给定一个正权完全图，求总权最小的 H 回路；</li>
</ul>
<blockquote>
<p>NP 完全问题，只能寻找近似解；这里不介绍算法，仅介绍问题；提示：不建议使用贪心法，误差很大；</p>
</blockquote>
<h4 id="9-8-7-有向无环图、AOV网与拓扑排序"><a href="#9-8-7-有向无环图、AOV网与拓扑排序" class="headerlink" title="9.8.7 有向无环图、AOV网与拓扑排序"></a>9.8.7 有向无环图、AOV网与拓扑排序</h4><ul>
<li><p>有向无环图（DAG）：不存在回路的有向图称为<strong>有向无环图</strong>；</p>
</li>
<li><p>AOV网：<strong>有向无环图</strong>中的顶点表示活动，边表示活动间的先后关系，这样的图称为<strong>AOV网</strong>；</p>
</li>
<li><p>拓扑排序：将AOV网中的活动发生的先后次序排成一个序列（如果有一条从 u 到 v 的道路，那么 v 必须出现在 u 之后），称为<strong>拓扑排序</strong>，这个序列称为<strong>拓扑序列</strong>；</p>
</li>
<li><p>拓扑排序实现思路：类似于图的 BFS，但是<strong>只有一个结点的所有直接前驱结点都已访问后，才能访问这个结点</strong>；<strong>$O(|V|+|E|)$</strong></p>
<ol>
<li><p>计算每个结点的入度，保存在数组中；</p>
</li>
<li><p>检查入度数组中<strong>入度为零（无依赖）</strong>的对应结点索引，并将其入队；</p>
</li>
<li><p>当队伍非空时，循环出队并输出这个结点，在假设将这个结点删除，修正这个结点的所有直接结点的入度（减1），如此重复2、3步骤；</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请自行实现私有函数 int _getInDegree(int) 获取入度；</span></span><br><span class="line"><span class="comment">// 使用到了之前的seqQueue类；</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span>* adjListGraph&lt;VType, EType&gt;::<span class="built_in">topoSortIdx</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ans = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;; <span class="type">int</span> ansIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* inDegrees = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; preRequests;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        inDegrees[i] = _getInDegree(i);</span><br><span class="line">        <span class="keyword">if</span> (!inDegrees[i]) preRequests.<span class="built_in">enQueue</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!preRequests.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = preRequests.<span class="built_in">deQueue</span>();</span><br><span class="line">        ans[ansIdx++] = cur;</span><br><span class="line">        eNode* curEdge = vertices[cur].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--inDegrees[curEdge-&gt;end] == <span class="number">0</span>)</span><br><span class="line">                preRequests.<span class="built_in">enQueue</span>(curEdge-&gt;end);</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[i]) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR] A non-DAG does not support topoSort().&quot;</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] ans; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">topoSort</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* seq = <span class="built_in">topoSortIdx</span>();</span><br><span class="line">    <span class="keyword">if</span> (!seq) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        std::cout &lt;&lt; vertices[seq[i]].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-8-8-AOE网与关键路径"><a href="#9-8-8-AOE网与关键路径" class="headerlink" title="9.8.8 AOE网与关键路径"></a>9.8.8 AOE网与关键路径</h4><ul>
<li><p>AOE网络：活动定义在边上（持续时间），事件定义在顶点上；</p>
</li>
<li><p>AOE网络的重要两点：源点（入度为0，工程“起点”）、汇点（出度为0，工程“终点”）；</p>
</li>
<li><p>AOE网络解决的问题：完成整项任务的最少时间、哪些活动是影响工程进度的关键;</p>
</li>
<li><p>关键路径：从源点到汇点的<strong>最长</strong>路径称为<strong>关键路径</strong>；</p>
</li>
<li><p>关键活动：关键路径上的活动。<strong>推迟关键活动必定影响项目进度</strong>；</p>
</li>
<li><p>最早发生时间：用“从源点到该结点的<strong>最长路径</strong>”（因为和拓扑排序一样，只有该结点的所有直接前驱结点都访问过后，才能算访问了这个结点）表征；</p>
</li>
<li><p>最迟发生时间：用“关键路径长(定值) - 从汇点到该结点的<strong>最短路径</strong>”表征（因为是最迟，距离汇点最近才符合定义）；</p>
</li>
<li><p>时间余量：最迟发生时间 - 最早发生时间。<strong>时间余量为0的活动是关键活动（第二定义）</strong>；</p>
</li>
<li><p>找关键路径的思路：（用第二定义）<strong>就是找每个顶点的最早、最迟发生时间，进而得到关键活动、关键路径</strong>；</p>
<ol>
<li><p>找出AOE网的任一拓扑序列；</p>
</li>
<li><p>从头至尾遍历一次拓扑序列，在遍历到 u 时，更新它的<strong>所有</strong>直接后继结点 v 的最早发生时间（如果当前ee值＜u 的值+路径长，那么更新v的ee值为更大的）；</p>
</li>
<li><p>再从尾至头遍历一次拓扑序列，在遍历到 u 时，更新它的<strong>所有</strong>直接后继结点 v 的最迟发生时间（如果后继结点le值＜v 的值+路径长，那么更新为u为更小的）；</p>
<blockquote>
<p>别问为啥不和第二步相对应，找直接前驱结点，问就是找前驱结点复杂度太大了；</p>
<p>⚠<strong>记得更新最迟发生时间之前，要用第二步得到的关键路径长度（就是拓扑序列最后一个结点的ee值）填充最迟发生时间数组</strong>；</p>
</blockquote>
</li>
<li><p>找出所有“最早发生时间=最迟发生时间”的结点，按照拓扑序列的顺序依此输出，即为关键路径；</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">criticalPath</span>(<span class="type">int</span>* early, <span class="type">int</span>* late) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* topoSeq = <span class="built_in">topoSortIdx</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) early[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        eNode* curEdge = vertices[topoSeq[i]].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (early[topoSeq[i]] + curEdge-&gt;weight &gt; early[curEdge-&gt;end])</span><br><span class="line">                early[curEdge-&gt;end] = early[topoSeq[i]] + curEdge-&gt;weight;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pLen = early[topoSeq[<span class="keyword">this</span>-&gt;vertixNum - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) late[i] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">this</span>-&gt;vertixNum - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        eNode* curEdge = vertices[topoSeq[i]].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (late[topoSeq[i]] &gt; late[curEdge-&gt;end] - curEdge-&gt;weight)</span><br><span class="line">                late[topoSeq[i]] = late[curEdge-&gt;end] - curEdge-&gt;weight;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">criticalPath</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ee = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="type">int</span>* le = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="type">int</span> pathLen = <span class="built_in">criticalPath</span>(ee, le);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[INFO] The length of the critical path: &quot;</span> &lt;&lt; pathLen &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[INFO] The critical path: \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ee[i] == le[i]) std::cout &lt;&lt; vertices[i].data &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[Fin]\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-8-9-生成树的计数算法"><a href="#9-8-9-生成树的计数算法" class="headerlink" title="9.8.9 生成树的计数算法"></a>9.8.9 生成树的计数算法</h4><blockquote>
<p>原理：Binet-Cauchy 定理：两个矩阵 $A_{m\times n},\space B_{n\times m}\space(m\le n)$，则 $det(AB)=\sum\limits_i{A_iB_i}$ 。其中$A_i$、$B_i$ 分别是从 $A$ 中任取 $m$ 列、$B$ 中任取 $m$ 行构成的行列式；</p>
<p>虽然这样计算行列式有些麻烦，但它揭示了乘积矩阵行列式和各矩阵的子式之间的关系；</p>
<p><span id="genTCount"><strong>定理1：（有向连通图的普通生成树计数）设 $B_k$ 为有向连通图 $G=(V,E)$ 的某一基本关联矩阵，则 $G$ 中不同树的数目为 $det(B_kB_k^T)$</strong>；</span></p>
<ul>
<li>解题提示：如果要求<strong>不含</strong>某个边的生成树数目，只要求将该边删去后的生成子图对应生成树的数目；如果要求<strong>必含</strong>某个边的生成树数目，只要该边的起点终点合并为一点，求新图对应生成树的数目；</li>
</ul>
<p><strong>如果想求无向连通图的生成树个数，需要将其每条边指定一个任意方向转化为有向连通图</strong>；</p>
<ul>
<li><p>推论证明：求证<strong>完全图 $K_n$ 的不同生成树的数目为 $n^{n-2}$</strong>；</p>
<script type="math/tex; mode=display">
det(B_kB_k^T)=\begin{vmatrix}n-1&-1&\cdots&-1\\-1&n-1&\cdots&-1\\\vdots&\vdots&\ddots&\vdots\\-1&-1&\cdots&n-1\end{vmatrix}=n^{n-2}</script></li>
<li><p>⚠易错警示：如果是求<strong>完全图 $K_n$ 不同构的生成树的数目</strong>，和<strong>“不同生成树”</strong>不一样！和化学上<strong>求同分异构体的做法类似</strong>；例如 $K_5$ 的不同构生成树数目为 3，对应有机化学戊烷的正戊烷、异戊烷、新戊烷的构型；</p>
</li>
</ul>
<p><strong>定理2：（有向连通图的根树生成树计数）设 $\overrightarrow{B_k}$ 表示将有向连通图 $G$ 的<u>关于结点 k 的</u>关联矩阵 $B_k$ 中所有的 1 元素换成 0 之后的矩阵，则 $G$ 中<u>以 k 为根的</u>不同根树数目为 $det(\overrightarrow{B_k}B_k^T)$</strong>；</p>
<ul>
<li>解题提示：如果要求<strong>不含</strong>某个边的根树生成树数目，删去这个边再算；</li>
<li>⚠易错警示：和普通生成树不同，如果要求<strong>必含</strong>某个边的根树生成树数目，需要先计算以 v0 为根的总根树数目，再减去不含这个边的生成树数目；<strong>或者求 $G^\prime=G-\{(t,v)|t\ne u\}$</strong> 的根树生成树数目；</li>
</ul>
</blockquote>
<h4 id="9-8-10-生成树的生成算法"><a href="#9-8-10-生成树的生成算法" class="headerlink" title="9.8.10 生成树的生成算法"></a>9.8.10 生成树的生成算法</h4><blockquote>
<p>不作介绍，有兴趣请查阅相关资料，例如《图论与代数结构》清华大学出版社 第3章 3.5节 支撑树的生成；</p>
</blockquote>
<h4 id="9-8-11-最小生成树算法"><a href="#9-8-11-最小生成树算法" class="headerlink" title="9.8.11 最小生成树算法"></a>9.8.11 最小生成树算法</h4><ul>
<li><p>Kruskal 算法</p>
<blockquote>
<p>思路：不断向初始化为空的根结点中加入当前未加入过的最短边，如果构成回路，一定是回路中的最长边，删除它；如果不构成回路则继续，直至达到 n-1 条边为止，此时 T 一定不含任何回路、n-1条边、包含所有图的顶点、所有权最小，在贪心法上是最小生成树；</p>
<p><strong>如何证明这个贪心算法的正确性？</strong></p>
<p>可以证明定理：$T=(V,E’)$ 是赋权连通图 $G=(V,E)$ 的最短树，当且仅当对任意的余树边 $e\in E-E’$，回路 $C^e(C^e\subseteq E’+e)$ 满足：其边权 $w(e)\ge w(a),\space a\in C^e\space(a\ne e)$；</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T &lt;- Φ    // 树根结点初始化为空</span><br><span class="line">while (|T| &lt; n - 1 &amp;&amp; E(G) != Φ) &#123;</span><br><span class="line">    e &lt;- E中最短边</span><br><span class="line">    E &lt;- E - e</span><br><span class="line">    if (T + e 无回路) T &lt;- T + e</span><br><span class="line">&#125;</span><br><span class="line">if (|T| &lt; n - 1) 输出非连通的信息</span><br><span class="line">else return T</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(\varepsilon+p\space log\space\varepsilon),\space其中p为迭代次数$；适用于稀疏图（当p不大时）；</p>
</li>
<li><p>Prim 算法</p>
<blockquote>
<p>思路：在结点集中任选一个结点 v0 构成集合 V’，从 V 和 V-V’ 中各选一个顶点 u（来自V）、v（来自V-V’）使得 (u, v) 是满足条件的u、v中最短的边，将此边加入树 T，令 V’+=u，直至 V’=V；</p>
<p>感兴趣可以找一找定理的正确性证明；</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t &lt;- v0, T &lt;- Φ, U &lt;- &#123;t&#125;</span><br><span class="line">while (U != V) &#123;</span><br><span class="line">    w(t, u) = min&#123;w(t, v)&#125; where v in (V - U)</span><br><span class="line">    T &lt;- T + e(t, u)</span><br><span class="line">    U &lt;- U + u</span><br><span class="line">    for (v in V - U) w(t, v) &lt;- min&#123;w(t, v), w(u, v)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(\nu^2)$；适用于稠密图；</p>
</li>
</ul>
<h4 id="9-8-12-最短路径算法"><a href="#9-8-12-最短路径算法" class="headerlink" title="9.8.12 最短路径算法"></a>9.8.12 最短路径算法</h4><p>正在更新中……———————————————————————</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SJTU-XHW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/review/data-structure-4/">https://blog.sjtuxhw.top/review/data-structure-4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SJTU-XHW's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Data-Structure/">Data-Structure</a><a class="post-meta__tags" href="/tags/Discrete-Math/">Discrete-Math</a><a class="post-meta__tags" href="/tags/External-Search/">External-Search</a><a class="post-meta__tags" href="/tags/B-Tree/">B+Tree</a><a class="post-meta__tags" href="/tags/Graph/">Graph</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/ds4.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/review/discrete-math/" title="离散数学复习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/dm.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">离散数学复习</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习离散数学过程中的知识点总结、速通，欢迎补充 written by SJTU-XHW Reference: 清华大学出版社《数理逻辑与集合论（第二版）》《图论与代数结构》 提示：大段文字阅读，点击右侧齿轮图标，进入阅读模式体验更佳 ~    Chapter 1 命题逻辑1.1 重要概念汇总 命题的定义：能判断真假的陈述句；（真假性：命题的值）  命题分类：原子命题、复合命题（成分命题 + 联结词）  真值联结词：非（否定式）、且（合取式）、或（析取式）、如果则（蕴含式）、等价（等值式）；  命题变元：以真假为变域的变元；  真值函数：以真假为定义域、真假为值域的函数；  命题演算公式的定义：（通俗）由命题变元利用真值联结词构成的式子；  命题变元是、公式的否定式是、两个公式的合取、析取式是；仅限于此；   变元组：n元公式 α 含有不同命题变元 p1、p2、……、pn，称（p1, p2, …, pn）为 α 的变元组；  完全指派：变元组任一组确定值都称为 α 关于这个变元组的一个...</div></div></div></a><a class="pagination-related" href="/review/data-structure-3/" title="数据结构复习-第三部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds3.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数据结构复习-第三部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN   注：以下所有用到的键值对定义为： 12345template &lt;class KEY, class VAL&gt;struct pair &#123;    KEY key;    VAL value;&#125;; Chapter 7 集合、查找表7.1...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/review/discrete-math/" title="离散数学复习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/dm.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-09</div><div class="info-item-2">离散数学复习</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习离散数学过程中的知识点总结、速通，欢迎补充 written by SJTU-XHW Reference: 清华大学出版社《数理逻辑与集合论（第二版）》《图论与代数结构》 提示：大段文字阅读，点击右侧齿轮图标，进入阅读模式体验更佳 ~    Chapter 1 命题逻辑1.1 重要概念汇总 命题的定义：能判断真假的陈述句；（真假性：命题的值）  命题分类：原子命题、复合命题（成分命题 + 联结词）  真值联结词：非（否定式）、且（合取式）、或（析取式）、如果则（蕴含式）、等价（等值式）；  命题变元：以真假为变域的变元；  真值函数：以真假为定义域、真假为值域的函数；  命题演算公式的定义：（通俗）由命题变元利用真值联结词构成的式子；  命题变元是、公式的否定式是、两个公式的合取、析取式是；仅限于此；   变元组：n元公式 α 含有不同命题变元 p1、p2、……、pn，称（p1, p2, …, pn）为 α 的变元组；  完全指派：变元组任一组确定值都称为 α 关于这个变元组的一个...</div></div></div></a><a class="pagination-related" href="/review/data-structure-1/" title="数据结构复习-第一部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-15</div><div class="info-item-2">数据结构复习-第一部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN    Chapter 1 数据结构绪论1.1 数据结构逻辑分类 集合结构：次序任意，重视归属关系； 线性结构：有序序列，有前驱、后继关系； 树状结构：层次关系，分根元素-其他元素； 图状结构：一般的逻辑结构，不限前驱和后继；  1.2 逻辑结构基本运算类型 创、清、增删改查、访问、遍历  1.3 逻辑结构的运算实现 存储结点、数据元素间关系（顺序实现、链接实现、散列实现、索引存储）、附加信息  总结：一个数据结构就是针对某一逻辑结构讨论数据的存储实现和运算实现 1.4 算法优劣因素分析 正确性、易读性、健壮性、高效率（时间、空间性能）   时间复杂度：算法所需运算量 和 问题规模 间的关系   时间复杂度因为会与被处理数据的分布有关，所以会有最好最坏和平均的说法  重要易错点：答题时注意除非说明，必须同时写上：最好、最坏、平均时间复杂度，少一个都不全面     算法运算量计算：不通用性  规定标准操作...</div></div></div></a><a class="pagination-related" href="/review/data-structure-3/" title="数据结构复习-第三部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds3.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-21</div><div class="info-item-2">数据结构复习-第三部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN   注：以下所有用到的键值对定义为： 12345template &lt;class KEY, class VAL&gt;struct pair &#123;    KEY key;    VAL value;&#125;; Chapter 7 集合、查找表7.1...</div></div></div></a><a class="pagination-related" href="/review/data-structure-2/" title="数据结构复习-第二部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-19</div><div class="info-item-2">数据结构复习-第二部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN   注：默认定义异常类型noElementException： 12345678class noElementException &#123;private:    const char* message;public:    noElementException(const char* msg=&quot;No element in the container.&quot;)        : message(msg) &#123;&#125;    const char* what() const &#123; return message; &#125;&#125;; Chapter 3 栈3.1...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SJTU-XHW</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-8-%E5%A4%96%E9%83%A8%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-text">Chapter 8 外部查找和排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E9%9B%B6%E7%A2%8E%E6%A6%82%E5%BF%B5%E9%9B%86%E5%90%88"><span class="toc-text">8.1 零碎概念集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-B-%E6%A0%91"><span class="toc-text">8.2 B 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-B-%E6%A0%91"><span class="toc-text">8.3 B+ 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E5%A4%96%E6%8E%92%E5%BA%8F"><span class="toc-text">8.4 外排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-9-%E5%9B%BE"><span class="toc-text">Chapter 9 图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%9B%BE%E8%AE%BA%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E2%85%A0"><span class="toc-text">9.1 图论中的重要定义Ⅰ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84"><span class="toc-text">9.2 图的同构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">9.3 图的存储实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E5%9B%BE%E7%9A%84%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%EF%BC%88except-for-traverse%EF%BC%89"><span class="toc-text">9.4 图的运算实现（except for traverse）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E5%9B%BE%E8%AE%BA%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E2%85%A1"><span class="toc-text">9.5 图论中的重要定义Ⅱ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-%E5%9B%BE%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8"><span class="toc-text">9.6 图的简单应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-%E5%9B%BE%E8%AE%BA%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E2%85%A2"><span class="toc-text">9.7 图论中的重要定义Ⅲ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-%E5%9B%BE%E7%9A%84%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95"><span class="toc-text">9.8 图的经典算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-1-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-text">9.8.1 图的遍历算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-2-%E4%B8%A4%E7%82%B9%E9%97%B4%E9%81%93%E8%B7%AF%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95"><span class="toc-text">9.8.2 两点间道路判定算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-3-%E6%9C%89%E5%90%91%E5%9B%BE%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E6%94%AF%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95"><span class="toc-text">9.8.3 有向图强连通分支判断算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-4-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="toc-text">9.8.4 欧拉回路的构造算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-5-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E4%B8%AD%E5%9B%BD%E9%82%AE%E9%80%92%E5%91%98%E9%97%AE%E9%A2%98%EF%BC%88CPP%EF%BC%89"><span class="toc-text">9.8.5 欧拉回路的应用：中国邮递员问题（CPP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-6-H-%E5%9B%9E%E8%B7%AF%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%EF%BC%88TSP%EF%BC%89"><span class="toc-text">9.8.6 H 回路的应用：旅行商问题（TSP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-7-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E3%80%81AOV%E7%BD%91%E4%B8%8E%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">9.8.7 有向无环图、AOV网与拓扑排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-8-AOE%E7%BD%91%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-text">9.8.8 AOE网与关键路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-9-%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">9.8.9 生成树的计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-10-%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="toc-text">9.8.10 生成树的生成算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-11-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="toc-text">9.8.11 最小生成树算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-12-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-text">9.8.12 最短路径算法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/python-sci-starter/" title="Python 科学计算入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/python_sci.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 科学计算入门"/></a><div class="content"><a class="title" href="/technical/python-sci-starter/" title="Python 科学计算入门">Python 科学计算入门</a><time datetime="2024-11-03T11:08:13.000Z" title="发表于 2024-11-03 19:08:13">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/hilog-paper/" title="OpenHarmony Hilog 架构趣读"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/hilog-paper.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenHarmony Hilog 架构趣读"/></a><div class="content"><a class="title" href="/technical/hilog-paper/" title="OpenHarmony Hilog 架构趣读">OpenHarmony Hilog 架构趣读</a><time datetime="2024-10-29T05:14:04.000Z" title="发表于 2024-10-29 13:14:04">2024-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/makefile-again/" title="Makefile 快速上手 (again)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/makefile-again.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Makefile 快速上手 (again)"/></a><div class="content"><a class="title" href="/review/makefile-again/" title="Makefile 快速上手 (again)">Makefile 快速上手 (again)</a><time datetime="2024-10-11T02:05:34.000Z" title="发表于 2024-10-11 10:05:34">2024-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/xss/" title="XSS 是什么？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/xss.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="XSS 是什么？"/></a><div class="content"><a class="title" href="/technical/xss/" title="XSS 是什么？">XSS 是什么？</a><time datetime="2024-10-04T04:15:33.000Z" title="发表于 2024-10-04 12:15:33">2024-10-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/xpc-paper/" title="论文阅读 - XPC: Architectural Support for Secure and Efficient Cross Process Call"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/xpc-paper.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读 - XPC: Architectural Support for Secure and Efficient Cross Process Call"/></a><div class="content"><a class="title" href="/technical/xpc-paper/" title="论文阅读 - XPC: Architectural Support for Secure and Efficient Cross Process Call">论文阅读 - XPC: Architectural Support for Secure and Efficient Cross Process Call</a><time datetime="2024-09-28T13:46:00.000Z" title="发表于 2024-09-28 21:46:00">2024-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By SJTU-XHW  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Powered By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.sjtuxhw.top',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.sjtuxhw.top',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>