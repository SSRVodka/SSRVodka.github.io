<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt | SSRVodka's blog</title><meta name="author" content="SSRVodka,xhwpro@gmail.com"><meta name="copyright" content="SSRVodka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chapter 10. The Memory Hierarchy 本章将介绍系统的内存分层架构。  之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。 正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt">
<meta property="og:url" content="https://blog.sjtuxhw.top/review/csapp-mm-cache/index.html">
<meta property="og:site_name" content="SSRVodka&#39;s blog">
<meta property="og:description" content="Chapter 10. The Memory Hierarchy 本章将介绍系统的内存分层架构。  之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。 正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/csapp-mh.jpg">
<meta property="article:published_time" content="2024-04-10T02:01:25.000Z">
<meta property="article:modified_time" content="2024-10-25T13:54:29.580Z">
<meta property="article:author" content="SSRVodka">
<meta property="article:tag" content="GNU">
<meta property="article:tag" content="CSAPP">
<meta property="article:tag" content="ICS">
<meta property="article:tag" content="Programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/csapp-mh.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/review/csapp-mm-cache/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/css/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CSAPP Notes: Memory Hierarchy & Cache & Opt',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SSRVodka's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/csapp-mh.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SSRVodka's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-10T02:01:25.000Z" title="发表于 2024-04-10 10:01:25">2024-04-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T13:54:29.580Z" title="更新于 2024-10-25 21:54:29">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/review/">review</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">23.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/review/csapp-mm-cache/#post-comment"><span class="waline-comment-count" data-path="/review/csapp-mm-cache/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Chapter-10-The-Memory-Hierarchy"><a href="#Chapter-10-The-Memory-Hierarchy" class="headerlink" title="Chapter 10. The Memory Hierarchy"></a>Chapter 10. The Memory Hierarchy</h1><blockquote>
<p>本章将介绍系统的内存分层架构。</p>
</blockquote>
<p>之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。</p>
<p>正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。</p>
<h2 id="10-1-Storage-Technologies-amp-Trends"><a href="#10-1-Storage-Technologies-amp-Trends" class="headerlink" title="10.1 Storage Technologies &amp; Trends"></a>10.1 Storage Technologies &amp; Trends</h2><p>在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。</p>
<h3 id="10-1-1-Random-Access-Memory-RAM"><a href="#10-1-1-Random-Access-Memory-RAM" class="headerlink" title="10.1.1 Random-Access Memory (RAM)"></a>10.1.1 Random-Access Memory (RAM)</h3><p>当前大多数人所熟知的 “内存” 的一部分就是<strong>随机访问存储器（RAM）</strong>，它具有以下的特征：</p>
<ul>
<li><p>RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；</p>
</li>
<li><p>RAM 常常被打包放在 CPU 芯片中；</p>
</li>
<li><p>RAM 中每一个基本的存储单元被称为 <strong>单元胞</strong>（Cell），一个单元胞中存放 1 bit 数据；</p>
</li>
<li><p>很多个 RAM 芯片共同工作，组成了计算机的 <strong>主存</strong>（主存储器）。</p>
</li>
<li><p>RAM 分为 2 类，它们之间<strong>根据存储单元胞的实现方式来区分</strong>：</p>
<ul>
<li>SRAM（Static RAM），静态随机存储器；</li>
<li>DRAM（Dynamic RAM），动态随机存储器；</li>
</ul>
<table>
    <tr>
        <td></td>
        <td>Trans. per bit</td>
        <td>Access time</td>
        <td>Needs refresh?</td>
        <td>Needs EDC?</td>
        <td>Cost</td>
        <td>Applications</td>
    </tr>
    <tr>
        <td>SRAM</td>
        <td>4 or 6</td>
        <td>1 ×</td>
        <td>No</td>
        <td>Maybe</td>
        <td>100 ×</td>
        <td>Cache Memories</td>
    </tr>
    <tr>
        <td>DRAM</td>
        <td>1</td>
        <td>10 ×</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>1 ×</td>
        <td>Main memories, frame buffers</td>
    </tr>
</table>

<blockquote>
<p>注：<code>Trans. per bit</code> 表示每 bit 需要多少根晶体管，<code>EDC</code> 指电子数据捕获。</p>
<p>从上面这张表可以得知，SRAM 比 DRAM 成本高很多，因为 SRAM 的每个储存单元胞都更加复杂。正因如此，SRAM 的访问速度远远快于 DRAM，因此常被用在 Cache Memories（高速缓存器）中（成本也是高速缓存通常大小比较小的原因之一）。</p>
<p><strong>Needs EDC</strong> 的含义是指，必须用一定的电压作用在存储单元胞的两端，否则一断电就会丢失电荷，数据也会丢失（<strong>又称 Volatile Memories</strong>）。这也是 RAM 需要插电用的原因（当然，如果把它从电源上拔下后迅速扔进液氮中，可以保留其中数据，因为电荷散失速度可以忽略）。</p>
<p>DRAM 被广泛应用于主存、图形显卡的 <strong>帧缓存（frame buffer）</strong>中。</p>
</blockquote>
</li>
</ul>
<h3 id="10-1-2-Nonvolatile-Memories"><a href="#10-1-2-Nonvolatile-Memories" class="headerlink" title="10.1.2 Nonvolatile Memories"></a>10.1.2 Nonvolatile Memories</h3><p><strong>ROMs</strong></p>
<p>除了 RAM，计算机存储系统中另一类存储器是 <strong>非易失性存储器</strong>，它们在计算机断电后仍然能保存数据。请回忆数电中介绍的几种电子元件：</p>
<ul>
<li><strong>ROM</strong>（Read-Only Memory，只读存储器），出厂时就编程完成，通常电路烧在板子上不可更改；</li>
<li><strong>PROM</strong>（Programmable ROM，可编程只读存储器），只能对电路编程一遍；</li>
<li><strong>EPROM</strong>（Erasable PROM，可清除可编程只读存储器），可以被特殊作用清除电路信息（UV / X-rays）；</li>
<li><strong>EEPROM</strong>（Electrically Erasable PROM，电驱动可清除可编程只读存储器），可以使用电路、电子清除其中信息，但只能反复清除重写 100,000 次。</li>
</ul>
<blockquote>
<p>它们的电路结构想必各位脑海中都非常清楚对吧？</p>
</blockquote>
<p>其中，大家所熟知的 <strong>闪存（Flash Memory）</strong>，就是许多 EEPROM 元件组成的。</p>
<blockquote>
<p>Tips. 计算机存储系统中的<strong>主存</strong>包括了 <strong>ROM 和 RAM</strong>，但闪存作为 ROM 的一种，<strong>也是现代最常用的 ROM</strong>，也可以和机械硬盘一起被用在<strong>外存</strong>中。</p>
</blockquote>
<p>这些 ROM 的作用很广泛，主要有以下几个方面：</p>
<ul>
<li>普通 ROM <strong>常被用作重要的、不应该被更改的数据的存储</strong>，例如 BIOS（存储计算机系统启动时的指令 + boot 引导程序）、Controllers for disks（硬盘控制器）、Network Cards（网卡）、Graphics accelerator（图形加速器）、Security subsystem（安全子系统）；</li>
<li>它们（闪存）还会被用在 <strong>固态硬盘</strong>（SSD，Solid State Disk，代替转圈易坏的机械硬盘，用在笔记本电脑、手机、mp3 播放器、平板等设备，系统会把 SSD 看成机械硬盘）中；</li>
</ul>
<p><strong>机械硬盘</strong></p>
<p>除了 ROM 一类的非易失性存储器，还有 <strong>外存</strong>（外部存储器）也是非易失性存储器。我们这里介绍有代表性的机械硬盘：</p>
<ul>
<li><p>结构包括传动臂、SCSI 连接口、盘片、盘片轴……</p>
</li>
<li><p>硬盘中包含一系列盘片（platter），每个盘片有两个面，每个面上涂有磁性材料，并且存在一圈圈同心圆（concentric rings），被称为 <strong>磁道（tracks）</strong>，每个磁道包含若干 <strong>扇区（sectors）</strong>，扇区之间会有空隙间隔（gaps），<strong>一个扇区通常的大小是 512 bytes</strong>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/disk_geometry.png" height="240px"></p>
<p>盘片轴（spindle）连接一系列盘片，<strong>每个盘片相同位置对齐的磁道称为 Aligned tracks，在垂直方向组成一个圆柱</strong>，这个相同位置的磁道所组成的元素称为 <strong>柱面</strong>，数据按照不同柱面进行存储，同一柱面的数据连续（为啥按柱面存？因为方便机械臂访问）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/disk_geometry_multi_platter.png" height="240px"></p>
</li>
<li><p>传动臂悬浮在盘片上方，隔着一层薄薄的空气。其末端读写头可以感知编码位的磁场变化；</p>
</li>
<li><p>机械磁盘内置电子设备，用于控制传动臂的移动等操作，其驱动程序一般存于 ROM 中；</p>
</li>
<li><p>机械性质决定了机械硬盘的读写速率慢于 RAM 和 ROM；</p>
</li>
<li><p>硬盘承载量取决于 <strong>数据记录密度（recording density，1 inch 磁道段中能存放多少 bit 信息）、磁道密度（track density）、面密度（Areal density，前面二者的乘积）</strong>；</p>
</li>
</ul>
<blockquote>
<p>⚠ 易错点警告：对于硬盘来说，它的承载量单位 GB 是特殊的：<strong>1 GB = $10^9$ Bytes</strong>，这与之前我们见到的衡量二进制数据大小的单位 GiB（<strong>其简称也叫 GB，1 GiB = $2^{30}$ Bytes</strong>）是不一样的。</p>
<p>这么说就明白了：<strong>承载量单位应该分开来看</strong>：1 G | B，1 吉 (Giga) = $10^9$；</p>
<p>而<strong>衡量二进制数据大小的单位是个整体</strong>： 1 | GiB，GiB 本身是 gibibyte（giga-binary byte），是 byte 单位的 $2^{30}$ 倍；</p>
<p>最常见的是计网的考题：<strong>1 MB/s 在 1 s 内传输的数据量略小于 1 MB</strong>，因为承载量速率单位 1 MB/s 是 $10^6$ Bytes / s，而数据大小 1 MiB 是 $2^{20}=1024^2$ Bytes；</p>
</blockquote>
<ul>
<li><p>在很早以前的机械硬盘中，每个磁道的扇区数目固定，这会导致大量的空间浪费。所以现代的机械磁盘<strong>将许多磁道划分为一个个不相交子集，称为记录区（recording zones）</strong>：</p>
<ul>
<li>每个处于同一记录区中的磁道含有相同的扇区数，它取决于最内侧磁道；</li>
<li>每个记录区中的磁道的扇区数不同，越靠近内圈的记录区中磁道的扇区数越少；</li>
<li><strong>因此我们使用平均扇区数 / 磁道数来计算承载量</strong>；</li>
</ul>
<p>如下图，阴影部分为一个记录区，含有许多扇区数相同的磁道：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/recording_zone.png" height="200px"></p>
<blockquote>
<p>题型：计算磁盘承载量</p>
<p><strong>承载量 = 每个扇区的 byte 数（通常 512 bytes）× 一个磁道中平均扇区数 × 一个盘面中的磁道数 × 一个盘片上表面数目（对三维生物来说=2）× 每个磁盘的盘片数</strong>；</p>
</blockquote>
</li>
<li><p>机械硬盘借助悬浮在盘面上方的传动臂进行读取，许多传动臂在磁盘同一半径处读写，其搜索读取读取速度取决于三个因素：<strong>寻道时间（一般最长，大约 3~9 ms）、旋转延迟、传输时间</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/disk_op.png" height="200px"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/disk_access_time.png" height="200px"></p>
</li>
<li><p>关于数据访问的耗时，有一些数字可以了解一下：</p>
<ul>
<li><p>一般情况下机械硬盘的 <strong>寻道时间 &gt; 旋转延迟 ≈ 4 ms &gt;&gt; 传输时间</strong>；</p>
<blockquote>
<p>机械硬盘访问扇区的第一个 bit 耗时最多，其他几乎不耗时；</p>
</blockquote>
</li>
<li><p>SRAM 访问 8 bytes 数据平均需要 4 ns，DRAM 需要 60 ns，<strong>而机械磁盘比 SRAM 慢 40000 倍，比 DRAM 慢 2500 倍</strong>；</p>
</li>
</ul>
</li>
<li><p>硬盘（机械 / SSD）的<strong>逻辑块（Logical Disk Blocks）</strong>：现代硬盘提供了一个面向 CPU 的更简单的抽象。硬盘的可用扇区被抽象为一组 b-sized 的逻辑块（编号从 0 开始）；</p>
<ul>
<li><p>每个逻辑块是<strong>扇区大小的整数倍</strong>（跳过 gaps），最简单的情况下，一个逻辑块就是一个扇区；</p>
</li>
<li><p>磁盘控制器来保持从物理扇区到逻辑块之间的<strong>映射</strong>（间接层面、抽象层面）；</p>
<blockquote>
<p>这允许磁盘控制器保留一部分 <strong>柱面</strong>（前面提到的存储信息按照同心磁道组成的柱面） 不进行映射，作为 <strong>备用柱面</strong>。</p>
<p>当某一柱面上的一个扇区损坏，那么磁盘控制器可以直接将数据复制到备用柱面，然后磁盘就能继续正常工作。</p>
<p><strong>这就是为什么磁盘的 “格式容量”（formatted capacity）比实际容量小</strong>。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>固态硬盘</strong></p>
<p>固态硬盘作为一种更新的、用来代替机械磁盘的外存形式，其控制器接口和机械磁盘一样，所以 CPU 一视同仁，不过它的速度介于 DRAM 和 机械硬盘之间。</p>
<p>其内部<strong>全部由闪存构建</strong>，并且由一个固件（firmware）称为闪存翻译层（<strong>flash translation layer</strong>）充当控制器（其作用和机械硬盘的磁盘控制器相当）；</p>
<p>数据在 SSD 中是以 <strong>页（page）</strong> 为单位从闪存中读取和写入的。页的大小 512 KB ~ 4 KB，块（block，和之前提到的 CPU 所认为的逻辑块<strong>不同</strong>，下面解释）一般包含 32 ~ 128 页，<strong>取决于 SSD 实现的技术</strong>；</p>
<blockquote>
<p>这里所说的 “块” 为啥和之前的 “逻辑块” 不同？</p>
<p>首先明确，这是个术语重叠的现象。这里的 SSD 中的 “块” 是闪存的性质导致的。目前技术下闪存的数据擦除是<strong>成块成块擦除</strong>，这意味着一次会同时擦除多个页。因此，人们把<strong>闪存一次擦除的一组页集合称为 “块”</strong>。</p>
<p>因此，想要修改某个块中的某个页，需要 <strong>将该块全部擦除（之前应该复制到其他位置）</strong> / <strong>找到一个已被擦除的块</strong> 才能写入；</p>
<p>现代的闪存翻译层中实现了很多专有算法，能够延长 SSD 的使用寿命，例如缓存技术。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/ssd_struct.png" height=240></p>
<p>固态硬盘的读写效率大致是 <strong>随机访问 300 MB/s 左右，顺序访问 500 MB/s 左右</strong>（Intel SSD 730 的数据），可以说<strong>在计算机的存储系统的层次结构中，随机访问总是比顺序访问更耗时</strong>。其中 SSD 写入速度都略低于读取速度，这是因为闪存写入前需要擦除原先数据。总的来说，SSD 的访问速度大约比机械硬盘快 10 倍左右。</p>
<p>其实，SSD 和机械硬盘各有优劣，相较于机械硬盘，SSD 具有以下特征：</p>
<ul>
<li>（优势）没有机械移动，更快、耗能更低、更结实（较不易摔坏），适合用在便携设备中；</li>
<li>（劣势）可能磨损，但问题不大，一般生命周期中可以写 100 PB+ 的数据（足够用多年）；</li>
</ul>
<p>最后看一下各种存储介质和 CPU 时钟频率的关系：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/CPU_memory_gap.png" height="400px"></p>
<blockquote>
<p>2003 年，CPU 设计达到性能能源瓶颈，其发展从增大时钟频率转向增大 CPU 内核数。</p>
</blockquote>
<h3 id="10-1-3-Traditional-Bus-Structure-Connecting-CPU-and-Memory"><a href="#10-1-3-Traditional-Bus-Structure-Connecting-CPU-and-Memory" class="headerlink" title="10.1.3 Traditional Bus Structure Connecting CPU and Memory"></a>10.1.3 Traditional Bus Structure Connecting CPU and Memory</h3><p>说完计算机存储系统的硬件，那么它们是怎么与 CPU 建立连接，进而抽象出 “内存空间” 和 “存储空间” 的呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/io_bus.png" width="600px"></p>
<blockquote>
<p>其中 I/O 桥是另外的一些芯片组，另一些芯片的集合。</p>
</blockquote>
<p><strong>CPU 访问主存</strong></p>
<p>上面的图仅仅是比较简单粗略的抽象，不要较真。在比较老的计算机架构中（因为现代系统有专有的总线设计，非常复杂），采用 <strong>总线（bus）</strong>来连接 CPU 和主存的，数据通过总线在主存和 CPU 间来回传输。<strong>并且总线通常与其他多种设备共享</strong>。</p>
<p>正常情况下，CPU 中的 ALU 根据汇编机器指令只需访问最近的寄存器就行；如果指令要求它访问内存，那么 ALU 会交由总线接口（Bus Interface）去从主存中取出相应位置的数据。</p>
<p>大家可以思考一下，在上面这幅图中，<code>movq %rax, $A</code> （A 为内存地址）和 <code>movq $A, %rax</code> 应该如何形象表示？</p>
<p>大家不难发现，<strong>寄存器离 CPU 很近，所以访问速度很快</strong>，通常在 3 个时钟周期左右就能读写到值。但是内存（图中 Memory Devices 芯片组）离 CPU 相当远，中间的步骤相当多，所以<strong>对内存读写所消耗的时间大约是对寄存器读写耗时的 100 倍左右</strong>。这就是计算机内存系统引入所发现的其中一个性能损耗。</p>
<p><strong>CPU 访问外部设备（以外存: 磁盘为例）</strong></p>
<p>再来看 I/O 总线（I/O Bus），它将各个设备与 I/O 桥连接，<strong>使得外部设备能和主存一样被 CPU 访问</strong>。I/O Bus 看起来是一条线，可实际不是如此。因为在老式的计算机中，它被称为 PCI 总线（广播总线），主干连接到各个设备，任何设备只要更改其上的数据，其他设备就能发现。</p>
<p>但现代的 I/O 总线并不是一条线了，它采用了 PCI Express 的总线结构，并不像上面画的一样，它是 <strong>点对点地连接两个设备</strong>，实现不同（我们不会深入讨论），但提供的功能就像图上画的一样。所以可以把 I/O Bus 看作一组电子线路即可。</p>
<p>其中 Disk、Mouse、Keyboard、Monitor 等设备使用细双箭头，表示它们不是焊在主板上，而是插入主板上的控制器（adapter、controller）来连接。</p>
<p>考虑如果 CPU 想要访问某个磁盘设备的某个扇区，那么会进行如下步骤：</p>
<ul>
<li>CPU 生成一个三元组（triple）：<strong>指令</strong>（read / write）、<strong>逻辑块编号</strong>、该块中的数据要放到哪个<strong>内存地址</strong>中（CPU 先从磁盘读入内存，再从内存读入 CPU 寄存器，反方向亦然），并且当前线程的程序暂停执行（如果是 I/O 阻塞的话），等待数据传输；</li>
<li>三元组通过总线接口、I / O 桥、I / O 总线传给磁盘控制器；</li>
<li>磁盘控制器通过读取与该逻辑块对应的任何扇区（一个逻辑块可能包含很多扇区）读入磁盘缓存；</li>
<li>磁盘控制器取得总线控制权，并且<strong>将数据通过 I/O 总线、I/O 桥和内存总线直接送往指定内存地址，而无需将数据传给 CPU</strong>；</li>
<li>数据传输结束后，磁盘控制器借助 “I/O 总线 - I/O 桥” 从<strong>新的通路</strong>（不经过总线接口）直接用电信号触发 CPU 的某个<strong>引脚</strong>，这个信号代表一种<strong>中断（interrupt）</strong>，通知 CPU 该扇区已被复制，此时暂停的程序继续执行；</li>
</ul>
<h2 id="10-2-Locality"><a href="#10-2-Locality" class="headerlink" title="10.2 Locality"></a>10.2 Locality</h2><p>无论是 8.1.2 中介绍的各自存储介质在物理层面上的性能约束，还是 8.1.3 中介绍的数据读取流程上的性能限制，都是计算机存储系统需要解决的重要问题，否则，在硬件上计算机就难以继续提升运行速度了。</p>
<p>其实，弥补 CPU 和内外存读写速率之间差距的机制之一就是<strong>程序的基本属性之一：局部性（locality）</strong>。</p>
<p>局部性原则：程序倾向于使用 “<strong>内存地址接近或等于最近使用过的数据/指令地址的</strong>” 那些数据和指令。</p>
<blockquote>
<p>原文：Programs tend to use data and instructions with addresses near or equal to those they have used recently.</p>
</blockquote>
<p>这个原则来源于程序编写的逻辑——<strong>当程序访问到某个内存地址上的数据，那么在不久的将来，有很大的可能程序会访问该数据项或者附近的数据项</strong>。</p>
<p>这种局部性有两种表现形式：</p>
<ul>
<li><p>时间局部性（Temporal Locality）：最近引用的存储器位置可能在不久的将来再次被引用；</p>
</li>
<li><p>空间局部性（Spatial Locality）：如果访问了一个存储器的位置，那么有很大可能在将来会访问一个临近的位置；</p>
</li>
</ul>
<blockquote>
<p>例子：识别代码中的局部性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> sum += a[i];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure>
<p>这串代码中，有对<strong>数据的引用</strong>（Data references，转为汇编后会引用数据，通常只要有变量就有数据的引用）。</p>
<p>例如上面的数组 <code>a</code>，其元素在内存上连续，索引 i 每自增一个单位就访问一下（称为 stride-1 reference pattern），属于空间局部性；上面的变量 <code>sum</code> 在循环的每次迭代中都会被引用，属于时间局部性；</p>
<p>还有对<strong>指令的引用（Instruction references）</strong>，例如循环中每一次都会执行循环体的内容，属于时间局部性；再比如程序代码顺序执行，本身就属于空间局部性。</p>
</blockquote>
<p>不同编写方法的代码，其局部性不同。这就需要开发者训练观看的能力。举一个很简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array1</span><span class="params">(<span class="type">int</span> a[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_array2</span><span class="params">(<span class="type">int</span> a[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们考虑对数据的引用，<strong>回忆 6.1 中对于 Nested Array 的内存排列的知识</strong>，数组数据连续排列且<strong>行优先</strong>，所以我们发现，使用 <code>sum_array2</code> 方式遍历数组，其<strong>数据相距距离很远</strong>，这意味着程序的局部性差于 <code>sum_array1</code>。而事实上，<code>sum_array2</code> 也真的会比 <code>sum_array1</code> 慢一个数量级；</p>
<blockquote>
<p>例题：请修改以下代码，使得它满足 stride-1 reference pattern（即更优的程序局部性）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array_3d</span><span class="params">(<span class="type">int</span> a[M][N][N])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i, j, k, sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">     <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">         <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">             sum += a[k][i][j];</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="10-3-Conclusions-for-10-1-amp-10-2"><a href="#10-3-Conclusions-for-10-1-amp-10-2" class="headerlink" title="10.3 Conclusions for 10.1 &amp; 10.2"></a>10.3 Conclusions for 10.1 &amp; 10.2</h2><p>没错，前面两节全部在为存储系统的层次结构<strong>做准备</strong>，之后我们才开始正式讨论 Memory Hierarchy。在此之前，我们先小总结一下前面的内容。</p>
<p>在本章开始，我们认识了计算机存储系统在硬件层面的两大组成：主存和外存。主存由 RAM（又分为 SRAM 和 DRAM）组成；外存则是硬盘（又分为机械硬盘、SSD）、可移动磁盘为主。</p>
<blockquote>
<p>广义的内存包括：主存（RAM）、全部 ROM、Cache（高速缓存存储器）；</p>
</blockquote>
<p>我们紧接着比较了 SRAM 和 DRAM 的特征、异同，以及它们所使用的场合；对于 ROM，我们了解了不同的 ROM 类型，还有闪存的定义。</p>
<p>在外存方面，我们详细介绍了机械磁盘的物理结构（磁盘控制器、盘面、柱面、磁道、扇区、记录区、承载量计算、访问耗时分析、逻辑块），并类比出功能相同、实现不同的固态硬盘物理结构（闪存翻译层、页、块）。</p>
<p>于是，我们从上面存储介质的物理结构中分析并得出 <strong>其数据访问模式的性能限制和优劣</strong>。</p>
<p>最后，我们分析了 <strong>CPU 访问主存</strong> 和 <strong>CPU 访问外存</strong> 的情况和流程，从中我们得知了在内存读取的流程中也存在着性能的限制或者说损失。</p>
<p>基于这些物理结构的限制，我们讨论出代码结构层面能够在一定程度上弥补这些性能鸿沟的性质：<strong>局部性</strong>。我们根据 <strong>存储设备的物理结构</strong> 和 <strong>数据存放的方式</strong>，可以设计写出更符合程序局部性的代码，这在一定程度上可以缓解 CPU 和内存之间访问的性能差距。</p>
<p>而观察代码的局部性，就需要对数据在内存中的 layout，还有储存设备的工作原理有一个很好的认识，这就是前几章、前几节的内容。</p>
<p><strong>这些存储介质的物理特性，和程序的局部性相辅相成，相得益彰，为人们提供一种 “怎样设计存储系统” 的建议和信息。</strong></p>
<p>接下来，我们将基于这些存储介质的物理性质，讨论在其上所建立的层次结构，和这些层次结构是如何抽象硬件，尽可能地为上层的计算机软件提供更连续完整的资源的。</p>
<h2 id="10-4-Memory-Hierarchy-amp-Idea-of-Caching"><a href="#10-4-Memory-Hierarchy-amp-Idea-of-Caching" class="headerlink" title="10.4 Memory Hierarchy &amp; Idea of Caching"></a>10.4 Memory Hierarchy &amp; Idea of Caching</h2><p>下图是计算机存储系统的一个层次结构图。</p>
<p>其中，寄存器是访问速度最快的存储结构，它在每个 CPU 时钟周期内都可以直接访问到（大小最小、数量很少、价格最贵、速度最快）；</p>
<p>接下来的是由 SRAM 组成的高速缓存存储器（Cache Memory），也处于 CPU 芯片内部，既不是主存，也不是寄存器；大小虽然是 MB 级，但已经比寄存器大多了。其中 3 层 Cache Memory 的具体结构将在下一章进行深入讨论；</p>
<p>再向下是 DRAM 组成的计算机的主存，一般你能看到的 “内存条” 就是它的组合结构，也是普通人经常说的 “内存”（狭义内存），一般从几个 G 到 几十 G 不等，程序运行内存（或者说后面要提到的<strong>虚拟内存</strong>）就是它的一部分；</p>
<p>最底层的像本地硬盘结构，甚至云端存储结构，空间一般都很大，但访问效率低下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/memory_hierarchy_example.png" height="400px"></p>
<p><strong>设计的核心：在 Memory Hierarchy 中，每一层都包含着从下一层所检索的数据</strong>（例如 CPU 寄存器保存着从 L1 高速缓存中取出的数据，依此类推）；</p>
<p>这样设计的原因是为了充分利用各个层级资源的特征，将整体数据访问效率最大化（<strong>底层是极大的数据池，却能够以极快的速度进行访问</strong>）。</p>
<p>这么做之所以有效，是因为 <strong>缓存思想（Caching）的存在</strong>。</p>
<p>这里所说的缓存，<strong>不是高速缓存存储器（Cache memories），而是一种思想</strong>。<strong>作为一个更小、更快的存储设备，充当更慢设备中数据的暂存区域、能更快访问的数据子集</strong>。例如，主存 可以看成是本地硬盘的 缓存，这样一旦从磁盘获取数据，就无需在磁盘上访问它，在上一个层级内存中访问，速度得到提升。依此类推，<strong>缓存的思想在 Memory Hierarchy 中逐级传播</strong>。</p>
<blockquote>
<p>第 k 层更快、更小的存储设备，就是第 k+1 层更慢、更大存储设备的 缓存。</p>
</blockquote>
<p>在真实场景中，每当程序访问一个不在缓存设备（第 k 层）中的数据，都会从第 k+1 层检索，并复制到第 k 层缓存起来。这是因为，<strong>根据程序的局部性</strong>，相较于第 k+1 层的设备，会更经常访问第 k 层设备中的数据，这就是 Memory Hierarchy 能最大化数据访问效率的原因。</p>
<hr>
<p>在详细介绍高速缓存存储器（狭义的 Cache）前，我们简单介绍一下<strong>缓存的实现</strong>，因为缓存思想存在于存储层次结构的每一层。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/general_cache_concept.png" height="240px"></p>
<p>储存数据的下层设备的空间（k+1 层）通常被分为一个个固定大小的块（blocks），缓存设备和下层设备间传输的数据以块为单位进行。</p>
<blockquote>
<p>如果第 k+1 层是 Web 云端存储介质，那么 blocks 通常以文件形式传给磁盘（第 k 层，缓存设备）；</p>
<p>如果第 k+1 层是主存，那么 blocks 可能是以某个特定大小的数据块传给高速缓存存储器（第 k 层，缓存设备）；</p>
<p>……</p>
</blockquote>
<p>在任意时间点，第 k 层的缓存设备中的数据都是第 k+1 层设备数据的一个子集。</p>
<p>对于 CPU 请求一个位于第 k+1 层的某个位置的数据这种情况，则 CPU 会先去层级最高的设备中寻找（假设找到第 k 层），则有两种情况：</p>
<ul>
<li><p>如果恰好找到了（假设请求如下图绿色块 14 的数据），那么 CPU 就直接从缓存（第 k 层）中读走这个数据，无需向下请求数据，总体提升了效率。这种情况称为 <strong>Cache Hit</strong>（缓存命中）；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/cache_hit.png" height="240px"></p>
</li>
<li><p>如果没有找到，那么 CPU 就需要从更下一层取得此数据块，并<strong>将它存放在缓存设备中</strong>。这种情况称为 <strong>Cache Miss</strong>（缓存不命中）；其本身又分为 3 个类型：</p>
<ul>
<li><p>Cold（compulsory）Miss：缓存为空，所以 Miss，不可避免；</p>
</li>
<li><p>Capacity Miss：由于较小的缓存空间而导致的不命中，通常是因为程序的工作集大于缓存空间所致。可以由增大缓存空间而减少；</p>
<blockquote>
<p>工作集（working set）：当前不断被程序访问的块，也即活跃的缓存块（active cache block）；</p>
</blockquote>
</li>
<li><p>Conflict Miss：由于大部分缓存设备（尤其硬件缓存）必须设计的比较简单，它限制了缓存块的放置位置（例如第 i 块必须放在 <code>i mod sizeof(Cache)</code> 的位置，很类似 hash table 的碰撞），这与缓存实现方式有关，也在下一章进一步讨论；</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/cache_miss.png" height="240px"></p>
</li>
</ul>
<p>最后，我们总结一下缓存在存储系统各层级的实现情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/caching_in_hierarchy.png" height="400px"></p>
<blockquote>
<p>注：TLB（Translation Lookaside Buffer，后备缓冲）是一个在虚拟内存中使用的缓存，<strong>是虚拟地址翻译为物理地址的翻译过程的缓存</strong>；</p>
</blockquote>
<p>需要注意的是，<strong>各个层级的缓存究竟是由谁实现和管理的</strong>，这是缓存思想的一个重点，也能解释早在第 3 章的疑问——<strong>汇编代码中找不到管理高速缓存存储器的代码</strong> 的原因。</p>
<p>例如，当寄存器看作缓存设备时，是编译器决定用哪个寄存器、用多少个寄存器（怎么用的 conventions 是 ABI 决定的）；</p>
<p>综上，缓存思想存在于计算机系统的几乎每个用到数据 I/O 的地方。</p>
<p>下一章将讨论 Memory Hierarchy 中一个具体的部分 <strong>高速缓存存储器</strong>，来深入了解缓存思想。</p>
<h1 id="Chapter-11-Cache-Memories"><a href="#Chapter-11-Cache-Memories" class="headerlink" title="Chapter 11. Cache Memories"></a>Chapter 11. Cache Memories</h1><blockquote>
<p>本章讲述 Memory Hierarchy 缓存思想中的重要一个体现：高速缓存存储器（Cache memories），它介于寄存器和内存之间，充当缓存设备的角色。</p>
</blockquote>
<p>回忆上一章的内容，高速缓存器本质上是一种由 SRAM 组成的、由硬件直接管理的小型缓存存储设备：<strong>Cache memories are small, fast SRAM-based memories managed automatically in hardware</strong>.</p>
<p>它一般封装于 CPU 芯片中，几乎和寄存器距离 CPU 核心同样近（只是由于电路存取特性导致其慢于寄存器），存储主存中被频繁引用的数据块。</p>
<h2 id="11-1-General-Cache-Organization"><a href="#11-1-General-Cache-Organization" class="headerlink" title="11.1 General Cache Organization"></a>11.1 General Cache Organization</h2><p>那么硬件是如何管理高速缓存存储器中的数据，在 CPU 需要的时候进行寻找呢？我们首先需要借鉴<strong>层次架构中一般的缓存模型</strong>，它们共同有一种缓存的管理方式和 layout；</p>
<p>首先，缓存本身就需要极速，这意味着设计缓存机制必须<strong>以非常严格且简单的方式去组织缓存模型</strong>，便于各个设备层级间进行查找。于是人们设计了下面的缓存数据组织形式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/general_cache_organization.png" height="350px"></p>
<p>缓存空间中一般包含 $S=2^s$ 个数据组（set），每一组又包含 $E=2^e$ 个数据行（line，图中<strong>横着排列</strong>），每一数据行由大小为 $B=2^b$ bytes（B binary digits）的数据区块和一个 tag 区、一个 valid bit 组成；现在解释一下目前可能有的疑惑：</p>
<ul>
<li>valid bit 指示当前缓存数据行中的数据实际上也真实存在于下层的存储介质中，可以直接使用（例如第一次打开机器的时候，这些数据区块位置上是随机 bits，因此这些 valid bit 会提示数据区块无效）；</li>
<li>tag 位（标记位）编码了这串数据位于下层存储介质的位置，在 CPU 搜索时有用；</li>
<li>为何无论是组数、数据行数还是每个数据行中的字节数都是 2 的幂次呢？<strong>这是一个非常重要的点。因为，缓存空间按照 内存地址的数码的各个位 来直接对应该内存数据应该存放的位置</strong>。这个比较抽象，后面的例子就会慢慢理解。</li>
</ul>
<p>其中高速缓存块的大小 <u>不包含 Tag 和 valid 部分</u>，也就是说，高速缓存的大小 $C=S\times E\times B$；</p>
<h2 id="11-2-Read-Cache"><a href="#11-2-Read-Cache" class="headerlink" title="11.2 Read Cache"></a>11.2 Read Cache</h2><p>那么缓存是如何被读取的？详细数据结构（和具体存储设备有关）又是什么样子的？</p>
<p>实际上，程序在运行中可能请求了下层存储介质中某个位置的数据，我们<strong>以高速缓存存储器和主存间查找数据的关系为例</strong>。步骤如下：</p>
<ul>
<li>假设程序指令要求引用主存中虚拟内存的某个地址（设为 <code>X</code>）的数据，那么 CPU 会向高速缓存存储器请求 <code>X</code> 地址下的值；</li>
<li>这个请求的地址会被 高速缓存存储器 <strong>直接用来查找缓存存放的位置（即这个地址的数据存放在）</strong>。其中 <code>X</code> 会被 高速缓存存储器 <strong>解析成</strong>如下图所示的结构（<strong>这就是为什么上面的 <code>S</code>、<code>E</code>、<code>B</code> 都是 2 的幂</strong>。看着这张图你能想明白吗？还不能明白的话，后面会有更具体的例子）：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/addr_B.png" height="125px"></p>
<ul>
<li>高速缓存存储器 <strong>首先 extract <code>X</code> 中 s bits 的 <code>set index</code></strong>（缓存组索引）看作为 unsigned int，用它找到缓存空间中特定的组（和数组索引很像）；</li>
<li>高速缓存存储器 接着<strong>并行检查（依赖于硬件电路的检查机制）</strong>该组中所有的数据行，将 tag 字段与每个数据行中的 tag 进行比较。如果找到了相同的 tag，那么再检查 valid bit 是否指示有效。所以会出现以下情况：<ul>
<li><strong>情况一</strong>：该组的数据行中不存在 tag 与 <code>X</code> 一致的行，<strong>说明请求的数据块不在缓存中（Cache miss）</strong>；</li>
<li><strong>情况二</strong>：该组的数据行找到了 tag 与 <code>X</code> 一致的行，但 valid bit 指示无效，<strong>说明请求的数据块无效，当前也不在缓存中（Cache miss）</strong>；</li>
<li><strong>情况三</strong>：该组的数据行找到了 tag 与 <code>X</code> 一致的行，并且 valid bit 指示有效，<strong>Cache hit</strong>！</li>
</ul>
</li>
<li>如果是 cache hit，那么<strong>extract</strong> <code>X</code> 中 b bits 的 <code>block offset</code>，从该数据行的数据区块开头地址加上这个 offset，将得到的地址再数据行中剩余部分规定大小读出，直接传给 CPU，结束查找过程；</li>
<li>如果是 cache miss，那么高速缓存存储器会放弃查找，将原本的请求地址 <code>X</code> 传给下一级存储设备（主存），那么查找工作交给主存（重复上面类似的步骤）。<strong>注意，当主存找到数据向上提交时，再次给到高速缓存存储器</strong>，将数据放在高速缓存存储器的应该是 <code>X</code> 的位置<strong>缓存起来</strong>（通常会覆盖相同位置的其他数据），然后高速缓存存储器再将数据向上提交给 CPU；</li>
</ul>
<p>总体呈现出 <strong>“逐层向上缓存数据，逐层向下查找数据”</strong> 的形式。</p>
<h3 id="11-2-1-Direct-Mapped-Cache-Simulation"><a href="#11-2-1-Direct-Mapped-Cache-Simulation" class="headerlink" title="11.2.1 Direct-Mapped Cache Simulation"></a>11.2.1 Direct-Mapped Cache Simulation</h3><p>下面详细解释上面的步骤。为了便于理解，我们首先从简单的情况讨论，<strong>当每一个缓存组只包含一个数据行的情况，这种情况被称为 “直接映射”（Direct-Mapped Cache Simulation）</strong>：</p>
<p>假设某个机器的内存空间大小 M = 16 bytes（可以用 4-bit digit 代表地址），缓存空间中含有 4 个组（S = 4），每个组含有一个数据行（E = 1），每个数据行含有 2 bytes 的数据区块（B = 2）。</p>
<p>在数据区块中，block offset 的长度为 1 byte（b = 1，因为数据区块只有 2 bytes，一般有 $B=2^b$），set index 的长度为 2 bytes（s = 2，因为缓冲区只有 4 组数据组，有 $S=2^s$）；</p>
<p>现在程序开始运行的时候，分别请求内存地址（$X$）为 0、1、7、8、0 的 1 byte 数据；</p>
<p>现在，高速缓存存储器中的所有数据行的 valid bit 都是 0（假设 0 代表无效，1 代表有效），并且开始接受 CPU 请求内存地址 $X = 0 = 0000_2$ 的数据 的请求。</p>
<p>首先，$X$ 的 block offset <strong>就是中间 2 bit</strong>，<code>00</code>，所以在 <code>set 0</code>（第 0 组）中寻找；然后，将 $X$ 的 tag 位（即最左边的 1 bit，0）与 <code>set 0</code> 的 tag 比较（是随机数），再看 valid bit 是 0，所以 cache miss（cold miss），如下动画（本人不会 Acrobat Animate，比较粗糙）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/directMappedCacheSimulation_part1.gif"></p>
<p>思考两个问题，第一个，为什这里的 tag 是 0 ？这是因为，我们在给定的 set offset 下（组相同），前面的 t bit（t=1）的 tag 位<strong>只是用来区分数据行</strong>的，<strong>借助了原内存地址 <code>X</code> 的前 t bits 数据</strong>而已，没有实际意义。</p>
<p>第二个，为什么这里要从 main memories 中同时读入 0、1 地址的数据？也就是说，为什么设定 <code>B == 2</code> 呢？<strong>这是因为，除去 set offset 的 2 bits、tag 的 1 bit，剩下内存地址 <code>X</code> 数码还有 1 bit 留给 block offset</strong>，因此 <code>X</code> 只能在该组的数据行中索引 2 bytes 的数据。</p>
<p>细细体会上面的话，你会发现这就是缓存空间如此设置、<code>X</code> 如此解析的原因（这里设计的和 IEEE 浮点数表示法一样巧妙，不容易用语言描述）。</p>
<hr>
<p>好了，又有同学会好奇了，既然这些索引本身没有意义，只是借助了原地址的数码，<strong>那为什么设计缓存索引的人一定要 <code>set index</code> 在中间、tag 在最前面、block index 在最后面呢</strong>？</p>
<p>这个问题非常有水平，这和<strong>二进制数码的变化方式有关</strong>。我们这里就分析对比 2 种解释 <code>X</code> 地址的方式：</p>
<ul>
<li>Middle Bits Indexing：就是上面的 <code>X</code> 的结构，Tag 在前、<code>Set index</code> 在中间、<code>Block index</code> 在最后；</li>
<li>High Bits Indexing：<code>Set index</code> 在前、Tag 在中间、<code>Block index</code> 在最后；</li>
</ul>
<p>我们接下来<strong>将缓存空间的组标为不同颜色，再把内存中将要分配到哪一组的数据块填上相同的颜色</strong>，发现结果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/middle_bits_indexing.png" width="360px"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/high_bits_indexing.png" width="360px"></p>
<p>我们发现，<strong>如果用 high bits indexing，那么内存地址相近的内存区域很容易被分配到相同的缓存组中，根据<u>空间局部性</u>，这样做会导致发生 conflict miss 的概率大大增加</strong>。所以，在缓存效率上，middle bits indexing 是优于 high bits indexing 的。其他情况同理。</p>
<p>这就是设计者们为什么要如此设计内存地址 <code>X</code> 在缓存中的这种解析方法。</p>
<hr>
<p>继续看接下来的过程动画：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/directMappedCacheSimulation_part2.gif"></p>
<p>我们发现，5 次访问中，有<strong>高达 4 次的 cache miss</strong>。后面 2 次的 cache miss 都是 conflict miss，完全能够由 提高每组的数据行数（<code>E</code> 的大小）来避免。<strong>因此，缓存结构中 <code>E</code> 的大小越大越好（也就是每组中的数据行越多越好）</strong>。但是我们前面提到，一个组中各个数据行<strong>使用并行比较</strong>，这个操作依赖硬件的多路判断——<strong>也就是说，<code>E</code> 越大，硬件电路越复杂，硬件越贵</strong>。所以真实计算机硬件中会进行取舍，选择一个特定的 <code>E</code> 值。</p>
<blockquote>
<p>当代（21 世纪初）市面上的常见的单组中数据行数目取值 <code>E = 8</code>，最大有 <code>E = 16</code>，是 Intel 的 16 路相联 L3 三级缓存。</p>
</blockquote>
<p>事实上，<code>B</code>（数据区块的大小，block size）也是越大越好，因为越大越可以利用局部性，提升缓存命中概率。但 <code>B</code> 受限于<strong>两个因素</strong>：一是<strong>硬件成本</strong>（例如 Cache memories 由 昂贵的 SRAM 组成），二是<strong>块复制的时间代价</strong>，因为如果想要把很大的数据区块从内存挪至缓存中，也是一个不小的开销。</p>
<p>综合上面的考虑，设计者真正确定缓存空间各个参数的步骤如下：</p>
<ol>
<li><strong>确定合适的数据区块（就是在数据行中的那个字段）大小 <code>B</code></strong>（通常被称为<strong>固定的缓存高级设计参数</strong>。Intel 一般 64 bytes）；</li>
<li>根据实际应用场景和硬件成本情况<strong>确定大致的缓存空间总大小</strong>（也是固定的缓存高级设计参数之一）；</li>
<li>根据硬件和实际情况<strong>确定数据组的关联性（associativity，即一个数据组中有多少数据行）<code>E</code></strong>；</li>
<li>由 1、2、3 就能计算出大致的<strong>缓存数据组数（<code>S</code>）</strong>。</li>
</ol>
<blockquote>
<p>最极端的情况是 <strong>全相关联高速缓存（Fully Associative Caches）</strong>，缓存空间中只有一个组（<code>S = 1</code>，所有数据行在一个组中），这个时候如果能够并行比较，那么缓存效率是极高的。但是通常由于上述原因，我们大多数时候只能在<strong>软件级别的缓存 或者 在主存和硬盘之间的缓存模式（因为硬盘读取时间开销很大，值得我们使用复杂算法来获得更高的缓存效率，我们在“虚拟内存”一章会讨论）</strong>中找到这种组织形式。</p>
</blockquote>
<h3 id="11-2-2-E-Way-Set-Associative-Cache-Simulation"><a href="#11-2-2-E-Way-Set-Associative-Cache-Simulation" class="headerlink" title="11.2.2 E-Way Set Associative Cache Simulation"></a>11.2.2 E-Way Set Associative Cache Simulation</h3><p>除了直接映射，还有一个稍微复杂点的例子，<strong>当不改变上面例子中的缓存空间大小，讨论每个缓存组包含 2 个数据行的情况，这也被称为 “2-Way Set Associative Cache（2 路相连高速缓存）Simulation”</strong>。</p>
<p>这个时候 tag 变为 2-bit，set index 变为 1-bit，block index 还是 1-bit；</p>
<p>我们有类似上面 Directed-Mapped Cache Simulation 相近的步骤，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/2_way_associative_cache_sim.png" height="300px"></p>
<blockquote>
<p>注意到一点，当关联性大于 1 的时候，同一个数据组中可能不同的数据行的 tag 可能是相同的，那么当我们想要覆盖数据的时候，就涉及到了<strong>选择覆盖</strong>的问题，它可以通过设计算法来完成。</p>
<p>根据<strong>局部性原理的逆定理（通常成立）</strong>，如果一个数据长时间不被引用，那么它在未来的某个时间也不太可能被引用。所以，最常见的算法是 <strong>“最近最少使用” 策略（Least Recently Used Strategy）</strong>，这种算法一般不需要额外的 bit 存储数据，只是从硬件层面跟踪在缓存中数据的使用频率（如按序保存虚拟时间戳），确保无效的数据行最先被覆盖，然后是使用频次更低的数据先被覆盖。</p>
</blockquote>
<p>助记：</p>
<ul>
<li><code>b</code> 位不同，<code>s</code>，<code>t</code> 位相同，也位于同一个组中；</li>
<li>每 $2^{b+s}$ bytes 就排在同一个组内；</li>
</ul>
<h2 id="11-3-Write-Cache"><a href="#11-3-Write-Cache" class="headerlink" title="11.3 Write Cache"></a>11.3 Write Cache</h2><p>事实上，真正要更改某些数据恐怕比读数据更难，因为我们的缓存机制通常会产生多份数据的复制品。例如层级从低到高：硬盘、主存、L1 / L2 / L3 高速缓存，其中可能包含了同一份数据的副本。</p>
<p>于是在程序要求修改内存（仍然以 高速缓存存储器 和 内存 这对存储同样有 2 种情况 <strong>write-hit</strong> 和 <strong>write-miss</strong>：</p>
<p>如果遇到 <strong>write-hit</strong>（要写的内存数据就在缓存设备中）的情况，由于数据分布特殊性，那么有两种处理方法：</p>
<ul>
<li><p><strong>Write-through</strong>：立即将数据写入缓存（即覆盖当前行）并主动刷新（flush）到内存；</p>
<ul>
<li>优势：内存始终是缓存的镜像，二者数据同步；</li>
<li>劣势：从 CPU 到 内存，时间开销必然很大；</li>
</ul>
</li>
<li><p><strong>Write-back</strong>：先把数据写入缓存，但不立即刷新，直到下一个数据要覆盖这个数据行的时候，才更新到内存中（defer write to memory until replacement of line，<strong>只是尽可能推迟了写入内存的时间</strong>）；</p>
<ul>
<li><p>优点：如果数据的 dirty bit 指示没有被污染时，那么覆盖这一行就不用执行 write 操作；</p>
</li>
<li><p>特点：<strong>这种方法需要一个标记（dirty bit），用来指示当前数据和内存中是否相同，即是否有被修改过</strong>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/dirty_bit.png" height="100px"></p>
</li>
<li><p>劣势：必然存在 <strong>write-miss</strong> 现象，因为如果修改的内存数据不在缓存中，那么就需要与内存交互；</p>
</li>
</ul>
</li>
</ul>
<p>如果遇到的是 <strong>write-miss</strong>，那么也有 2 种方法（<strong>和 write-hint 是对称的操作</strong>）：</p>
<ul>
<li><strong>Write-allocate</strong>：写分配，在 write-miss 后，<strong>先将原数据从内存读入缓存，转换为 write-hit 的情况，再 write-back（仅修改缓存 + dirty bit）</strong>；</li>
<li><strong>No-write-allocate</strong>：直接写入内存，不加载到缓存（缓存中没有这个数据所在的数据行，因为本来就是 write-miss）；</li>
</ul>
<p>一般情况下，由于对称性，人们一般选择 “<strong>write-back + write-allocate</strong>” 或 “write-through + no-write-allocate” 的策略中的其中一对（根据实际情况）；</p>
<h2 id="11-4-The-Hierarchy-of-Cache-Memories"><a href="#11-4-The-Hierarchy-of-Cache-Memories" class="headerlink" title="11.4 The Hierarchy of Cache Memories"></a>11.4 The Hierarchy of Cache Memories</h2><p>讨论完了缓存读写的具体的逻辑实现，我们再来看看实际上硬件是如何对应这些实现的。同样以 高速缓存存储器 为例。<strong>到目前为止，我们都假设计算机系统中只有一个高速缓存存储器的缓存空间</strong>，但是实际上，早在前面第 8 章中就介绍了，一般计算机中有 L1、L2、L3 3 类 Cache memories。它们在硬件上是如何设置和协调的呢？</p>
<p>以 Intel Core i7 芯片为例，它的高速缓存层次结构如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/intel_i7_cache_hierarchy.png" height="300px"></p>
<p>如图，一般情况下，现代 CPU 有 4（桌面系统）/ 8 ~ 12（服务器类系统）个核，<strong>每个核可以各自并行，独立执行各自的指令流</strong>，每个处理器内核可以包含<strong>各自的</strong>通用寄存器（位于存储系统层次结构 L0）.</p>
<p>在其中，每个核还会有 2 种 L1 Cache。其中一种是 <strong>d-cache（data cache，1 级数据高速缓存器）</strong>，另一种是 <strong>i-cache（instruction cache，1 级指令高速缓存器</strong>）。它们的读取时延（4 个时钟周期）仅次于寄存器，正因速度和成本的关系，它们的大小非常小，只有约 32 KB；它们的关联性一般是 8 路（一个缓存组中有 8 个数据行）；</p>
<p>在 L1 Cache 的下一层是 L2 Cache（L1 和），只有一种联合的高速缓存器（unified cache，同时包含某个核的数据和指令的缓存），读取速度稍慢（10 个时钟周期）于 L1 Cache，也是 8 路关联性，不过大小稍微大一点，有 256 KB；</p>
<p>再下层的 L3 Cache 不在 CPU 的核内，是被所有核心所共享的联合高速缓存存储器。8 bytes 大小、16 路关联性，但访问时延长达 40 ~ 75 个时钟周期；</p>
<p><strong>它们间的关系和之前所说的各个层级的缓存设备一模一样，都是 “逐层向上缓存数据，逐层向下查找数据”</strong>。</p>
<p>根据这些实际的物理结构，我们考虑一下高速缓存存储器的性能和损耗情况。我们建立如下的衡量指标（Cache Performance Metrics）：</p>
<ul>
<li>Miss Rate:  cache memories 不可避免的会发生 cache miss，这就是 cache memories 性能可能产生损耗的原因之一；<ul>
<li>定义：缓存未命中次数 / 总访问次数（ = <strong>1 - hit rate</strong>）；</li>
<li>一般情况下，L1 Cache 的 未命中率在 3 ~ 10%，L2 Cache 在 1% 左右，<strong>和缓存大小紧密相关</strong>（<strong>如此低的 Miss Rate 得益于 程序局部性</strong>）；</li>
</ul>
</li>
<li>Hit Time：虽然有时缓存成功命中，但从缓存的数据行中传输到处理器中仍然需要时间。<ul>
<li>定义：从检查标志位，到 hit 直接返回 block 中的缓存数据所需时间；</li>
</ul>
</li>
<li>Miss Penalty：由于 Miss Rate，从内存传输到缓存和 CPU 中通常会花费更多时间；<ul>
<li>定义：从检查标志位，到 miss、从内存读取数据，直到数据传回 CPU 所需时间；</li>
<li>一般情况下从主存中读取数据大约花费 50 ~ 200 个时钟周期（如果在其他的存储系统的层次中，花费可能大得多）；</li>
</ul>
</li>
</ul>
<p><strong>事实上，这些一次两次看似影响不大的 Cache miss 和 hit，对系统性能影响相当大！数学证明表明，99% 的 hit rate 的系统性能比 97% 的 hit rate 对应的系统性能迅速 2 倍</strong>！</p>
<blockquote>
<p>主要是因为 miss penalty 很大，miss rate 的权重远大于 hit rate 的权重。因此我们通常看 miss rate 而不是 hit rate；</p>
</blockquote>
<p>那么我们分析之前的 cache 参数对性能的影响：</p>
<ul>
<li>cache 总大小影响：增大同时 <strong>提高命中率，但增加 hit time</strong>;</li>
<li><p>block size ($B$) 大小影响：增大同时 <strong>更能利用程序空间局部性（提升 space locality 好的程序的 hit rate），但数据行数 $E$ 会变少（temporal locality 好的程序的 hit rate 会降低），并且会提高 miss penalty</strong>；</p>
</li>
<li><p>associativity ($E$) 大小影响：<strong>降低了 conflict miss 的可能性，但是提升了比较数据行的硬件成本、增加了命中时间、增加了 miss penalty（因为 replacement 的选择也更复杂）</strong>；</p>
</li>
</ul>
<h2 id="11-5-Performance-Impact-of-Cache"><a href="#11-5-Performance-Impact-of-Cache" class="headerlink" title="11.5 Performance Impact of Cache"></a>11.5 Performance Impact of Cache</h2><h3 id="11-5-1-Writing-Cache-Friendly-Code-Ⅰ"><a href="#11-5-1-Writing-Cache-Friendly-Code-Ⅰ" class="headerlink" title="11.5.1 Writing Cache Friendly Code Ⅰ"></a>11.5.1 Writing Cache Friendly Code Ⅰ</h3><p>考虑上一节惊人的缓存性能的情况，我们确实应该写出一些 Cache Friendly 的代码，<strong>这是优化代码性能的一个重要方面</strong>。在分析了缓存的特性和程序局部性之后，我们可以这样来充分利用高速缓存带给程序的性能提升：</p>
<ul>
<li><p>关注<strong>经常被调用的</strong>函数中<strong>执行次数最多的内层循环</strong>的性质，积极对它进行算法层面优化；</p>
</li>
<li><p>尽量使用重复的变量引用，而不是很多的全局变量（利用了时间局部性，减少 cache miss 的可能）；</p>
<blockquote>
<p>它和 第 15. 章的 CSE 优化不冲突，后者是尽量避免 Memory Alias；</p>
</blockquote>
</li>
<li><p>尽量使用 stride-1 reference patterns（或者说<strong>程序循环的步长尽量小</strong>，尤其是逐个访问数组元素，这就将 cache block 的优点发挥了出来，利用了空间局部性，减小 cache miss 的可能）；</p>
</li>
</ul>
<p><strong>总结：我们分析缓存的组织原理和特性，是进一步定量地（如上面的指标）去体现、印证程序局部性的概念</strong>。</p>
<h3 id="11-5-2-The-Memory-Mountain"><a href="#11-5-2-The-Memory-Mountain" class="headerlink" title="11.5.2 The Memory Mountain"></a>11.5.2 The Memory Mountain</h3><p>之前简单地对缓存组成的分析，让我们看到了关注缓存能够对程序带来较显著地性能影响。那么这节我们更深入地去探究缓存对程序性能的影响。</p>
<p>首先引入一个概念：</p>
<ul>
<li>Read throughput（吞吐量，或者说 read bandwidth，读带宽）：<strong>单位时间内从内存中读取数据的最大字节数</strong>，单位 MB/s；</li>
</ul>
<p>于是，我们可以绘制一个 <strong>时间局部性、空间局部性 关于 机器吞吐量的三维坐标图（存储器山）</strong>，以此展示缓存对程序性能的重要影响。</p>
<p>其中，我们以访问数组的程序为例。我们将遍历数组的步长作为衡量程序空间局部性的指标（步长越大，空间局部性越小），将一次读取数组元素数量作为衡量程序时间局部性的指标（一次取出的数据越多，访问到相同地址数据的机会越小，时间局部性越小）；</p>
<p>如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/memory_mountain.png" height="350px"></p>
<p>我们<strong>从读取数据量 size 的方向</strong>看图，会发现 memory mountain 有一个个像山脊一样的结构，这恰好对应了从 L1 到 Memories 的数据引用的平均性能（小的数据量更有可能在每次遍历时放在同一个缓存的 block 中，发生 cache miss 的机会就更小，只需要依靠更接近寄存器层级的缓存设备就能得到答案）；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/space-loc-stat.png" height="350px"></p>
<p>而<strong>从数组访问步长 stride 的方向</strong>看图，会发现随着步长的增加，整体有一个负向的斜率。而随着步长大到一定程度，负向的斜率趋于平缓，这是因为<strong>步长大过了缓存 block size，导致几乎每次都会存在 Cache miss，就很难得到缓存的增益了</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/temporal-loc-stat.png" height="350px"></p>
<h3 id="11-5-3-Writing-Cache-Friendly-Code-Ⅱ-Rearranging-loops-to-improve-spacial-locality"><a href="#11-5-3-Writing-Cache-Friendly-Code-Ⅱ-Rearranging-loops-to-improve-spacial-locality" class="headerlink" title="11.5.3 Writing Cache Friendly Code Ⅱ - Rearranging loops to improve spacial locality"></a>11.5.3 Writing Cache Friendly Code Ⅱ - Rearranging loops to improve spacial locality</h3><p>借助上面对于 memory mountain 的进一步分析，我们还可以想到更多的具体<strong>利用缓存来优化程序性能的方法</strong>。</p>
<p>例如，我们<strong>以矩阵乘法运算为例</strong>，我们假定以下的条件：</p>
<ul>
<li>N × N 方阵，元素为 double（8 bytes）类型；</li>
</ul>
<p>那么按照正确的一般矩阵相乘的方法，总单位运算次数 $O(N^3)$；</p>
<p>事实上，计算的一般方法有许多种（但都是 结果矩阵 $C=(c_{ij})_{N\times N}$ 的元素 $c_{ij}=a_{ik}\cdot b_{kj}$），我们<strong>这里着重讨论缓存的效率受代码安排的影响，也即，什么样的矩阵乘法最能充分利用缓存</strong>。</p>
<p>首先来对不同策略的矩阵乘法分析 Miss Rate：</p>
<ul>
<li>前提假设<ul>
<li>机器缓存空间的 <strong>块大小（<code>B</code>）为 32 Bytes（能够一次性放下 4 个 double 数据）</strong>；</li>
<li>矩阵维度 <code>N</code> 非常大（$\dfrac{1}{N}\approx0$）;</li>
<li>缓存空间的总大小不足以装下矩阵的多个行；</li>
</ul>
</li>
<li>分析方法：<strong>检查内层循环的函数访问模式</strong>（因为外层循环次数不可避免）；</li>
</ul>
<p>由于运算的方式固定，我们可以通过更换内外层循环顺序（共 $3!=6$ 种）来看究竟哪种方法最好。</p>
<p>在分析前，先再次回顾一下 C 中数组的 memory layout：</p>
<ul>
<li>二维数组的<strong>至少每一行的数据空间是 contiguous 的</strong>，并且<strong>行优先（row major）</strong>；</li>
<li>stride-1 逐个访问数组行的方法最能利用 spacial locality，它的 $miss\space rate=\dfrac{sizeof(a_{ij})}{B}$，其中 $B$ 是缓存空间的块大小；</li>
<li>stride-1 逐个访问较大数组列的方法完全无法利用 spacial locality，因为 每一列同一行的元素一定不在同一个缓存数据块中（之前已经假设 “缓存空间的总大小不足以装下矩阵的多个行”），因此 miss rate = 1（100% cache miss）；</li>
</ul>
<p><strong>情况 1：先固定 i（A 的行），再固定 j（B 的列），最后遍历 k（A 第 i 行每一列、B 第 j 列每一行）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/cache_analysis_matrix_multiply_ijk.png" height="200px"></p>
<p>这种情况下，<strong>对每一个最内层循环</strong>：</p>
<ul>
<li>每次要求从内存中取出 A 矩阵的同行相邻元素，<strong>miss rate = 8 / 32 = 0.25</strong>；</li>
<li>每次要求从内存中取出 B 矩阵的同列相邻元素，<strong>miss rate = 1</strong>；</li>
<li>每次要求从内存中取出 C 矩阵的一个元素，所以对单个元素而言 <strong>miss rate 近似为 0</strong>；</li>
</ul>
<p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 0 次，cache miss 次数 1.25 次</strong>；</p>
<p>这种情况与 <strong><code>jik</code></strong> 顺序的情况相同；</p>
<p> <strong>情况 2：先固定 k（B 的行），再固定 i（A 固定位置 第 i 行 第 k 列），最后遍历 j（C 的第 i 行每一列）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/cache_analysis_matrix_multiply_kij.png" height="175px"></p>
<p>这种情况下，<strong>对每一个最内层循环</strong>：</p>
<table>
    <tr>
        <th>Op Matrix</th>
        <td>A</td>
        <td>B</td>
        <td>C</td>
    </tr>
    <tr>
        <th>Miss Rate</th>
        <td>0.0</td>
        <td>0.25</td>
        <td>0.25</td>
    </tr>
</table>

<p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 1 次，cache miss 次数 0.5 次</strong>；</p>
<p>这种情况与 <strong><code>ikj</code></strong> 顺序的情况相同；</p>
<p><strong>情况 3：先固定 j（C 的第 j 列每一行），再固定 k（A 的第 k 列），最后遍历 i（固定 B 遍历 C 的 列）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/cache_analysis_matrix_multiply_jki.png" height="175px"></p>
<p>这种情况下，<strong>对每一个最内层循环</strong>：</p>
<table>
    <tr>
        <th>Op Matrix</th>
        <td>A</td>
        <td>B</td>
        <td>C</td>
    </tr>
    <tr>
        <th>Miss Rate</th>
        <td>1.0</td>
        <td>0.0</td>
        <td>1.0</td>
    </tr>
</table>

<p>ℹ 平均每次内层循环<strong>约加载 2 次数据，存储 1 次，cache miss 次数 2.0 次</strong>；</p>
<p>这种情况与 <strong><code>kji</code></strong> 顺序的情况相同；</p>
<hr>
<p>综合上面的三种情况，我们进行实际的测试，发现结果如我们所料：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/core_i7_matrix_multiply_perf.png" height="300px"></p>
<p>事实证明，<strong><code>kij/ikj</code> 遍历方法（固定 A / B 的位置，遍历剩下一个运算矩阵的行，来得到结果矩阵的行）是最能利用 cache memories 的优势的方法</strong>，而我们最常用的 <code>ijk</code> 方法却不是最好的方法。</p>
<h3 id="11-5-4-Writing-Cache-Friendly-Code-Ⅲ-Using-blocking-to-improve-temporal-locality"><a href="#11-5-4-Writing-Cache-Friendly-Code-Ⅲ-Using-blocking-to-improve-temporal-locality" class="headerlink" title="11.5.4 Writing Cache Friendly Code Ⅲ - Using blocking to improve temporal locality"></a>11.5.4 Writing Cache Friendly Code Ⅲ - Using blocking to improve temporal locality</h3><p>上一节的例子主要以矩阵乘法为例，从提升<strong>空间局部性</strong>的层面来充分利用缓存、提示程序缓存效率。本节将从另一个角度——提升程序<strong>时间局部性</strong>来讨论如何写出缓存友好的代码。</p>
<p>再举一个针对矩阵乘法的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="type">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmm</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                c[i*n + j] += a[i*n + k] * b[k*n + j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的乘法而言，我们作如下假设：</p>
<ul>
<li>机器缓存空间的 <strong>块大小（<code>B</code>）为 64 Bytes（能够一次性放下 8 个 double 数据）</strong>；</li>
<li>矩阵维度 <code>N</code> 非常大（$\dfrac{1}{N}\approx0$）;</li>
<li>缓存空间的总大小不足以装下矩阵的多个行；</li>
</ul>
<p>在这种情况下，最内层的循环中，每一个循环的 cache miss 平均次数为：$\dfrac{n}{8}+n=\dfrac{9}{8}n$，于是总的 cache miss 的数量在 $\dfrac{9n^3}{8}$ 左右，显然，这样的 cache miss 数量会显著影响程序性能和对缓存的利用。于是，一种利用时间局部性的方法就出现了：</p>
<p><strong>我们在每次内存循环取矩阵乘法的 $C$ 的单元的时候，将单独取一个改为选取一个 block（小型块），如图所示，block 的宽度为 $B$：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/multi_simple.png" height="150px"></p>
<p>改为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/multi_block.png" height="150px"></p>
<p>即计算代码改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="type">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmm</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i+=B)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j+=B)</span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k+=B)</span><br><span class="line">                    <span class="comment">/* B x B mini matrix multiplications */</span></span><br><span class="line">                    <span class="keyword">for</span> (i1 = i; i1 &lt; i+B; i1++)</span><br><span class="line">                        <span class="keyword">for</span> (j1 = j; j1 &lt; j+B; j1++)</span><br><span class="line">                            <span class="keyword">for</span> (k1 = k; k1 &lt; k+B; k1++)</span><br><span class="line">                                c[i1*n+j1] += a[i1*n + k1]*b[k1*n + j1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我们再次分析 cache miss 的情况。</p>
<p>假设选取的 $B$ 的大小能够被缓存利用：$3B^2\lt C$，那么：</p>
<ul>
<li><p>每一个 sub-block（子块）内部的 cache miss 数量：$\dfrac{B^2}{8}$；</p>
</li>
<li><p>每一次行循环的 cache miss 数：$\dfrac{2n}{B}\cdot\dfrac{B^2}{8}=\dfrac{nB}{4}\sim O(nB)$；</p>
</li>
<li>总的 cache miss 数：$\dfrac{nB}{4}\cdot(\dfrac{n}{B})^2=\dfrac{n^3}{4B}$；</li>
</ul>
<p>总而言之，这样的改进并没有根本上提升算法的时间复杂度，但是它却能确确实实地减少常数级别的 cache miss 数量（$\dfrac{9}{8}n^3\rightarrow\dfrac{1}{4B}n^3$），在一定程度上达到提升时间局部性的效果。这样，只要我们选择满足 $3B^3\lt C$ 的最大的 $B$ 的取值，就能找到这种思路的最优计算方法。</p>
<p>为什么能够引起如此大的常数优化呢？主要是以下原因：</p>
<ul>
<li>我们在选取 block 的时候，相当于加载了一个地址上更相邻的、之后能被反复使用的变量，因为我们缩小了矩阵乘法的 $N$，逐个 block 攻破，这样的矩阵乘法更能利用时间局部性；<ul>
<li>输入数据 $3n^2$，计算 $2n^3$，而每个元素需要被使用 $O(n)$ 次；</li>
</ul>
</li>
</ul>
<h3 id="11-5-5-Cache-Performance-Summary"><a href="#11-5-5-Cache-Performance-Summary" class="headerlink" title="11.5.5 Cache Performance Summary"></a>11.5.5 Cache Performance Summary</h3><p>在 11.5 节中，我们通过几个例子了解到，<strong>虽然我们无法显式控制 cache 的存储方式，但是通过对于程序局部性的分析，我们可以更高效地利用 cache，从而提升程序允许效率。</strong>这主要可以从两个方面下手：</p>
<ul>
<li>使用 stride-1 reference pattern、关注内层循环的步长和方式，以提升程序的空间局部性；</li>
<li>多次使用相同的局部变量、分块访问，以提升程序的时间局部性；</li>
</ul>
<h1 id="Chapter-12-Program-Optimization"><a href="#Chapter-12-Program-Optimization" class="headerlink" title="Chapter 12. Program Optimization"></a>Chapter 12. Program Optimization</h1><blockquote>
<p>One of the themes for this chapter: </p>
<ul>
<li>去除程序不必要的工作、编写编译器友好代码、提升运行速度；</li>
<li>利用机器代码特性，针对特定机器对程序优化；</li>
</ul>
</blockquote>
<p>编译器无法理解一些内容，例如 int 数据类型可能只用到相当小的范围、procedure call 究竟是什么意思，等待。编译器只是针对一些特定情况，对照 “cookbook” 进行有选择地优化。其遇到复杂或者特殊情况的 “保底” 方案是不对代码进行优化。</p>
<p>初始思路：查看程序汇编代码哪些地方没被优化，找到对应的源码部分进行重写，直至重构成编译器友好代码（只要不过度牺牲程序可读性就行）。</p>
<h2 id="12-1-Goals-of-Optimization"><a href="#12-1-Goals-of-Optimization" class="headerlink" title="12.1 Goals of Optimization"></a>12.1 Goals of Optimization</h2><ul>
<li>Minimize number of instructions<ul>
<li>避免重复计算；</li>
<li>避免不必要的计算；</li>
<li>避免较大计算量的操作（例如乘、除）；</li>
</ul>
</li>
<li>Avoid waiting for memory<ul>
<li>尽量将数据和运算过程放在 register 中，而非内存中；</li>
<li>使用 cache-friendly 的方式访问内存；</li>
<li>尽早从内存加载数据，并且加载次数越少越好；</li>
</ul>
</li>
<li>Avoid branching<ul>
<li>不要写出不必要的判断结构；</li>
<li>写成让 CPU 容易预测分支的代码（流水线）；</li>
<li>尽量解开循环，分摊分支的开销；</li>
</ul>
</li>
<li>Make good use of locality &amp; cache: 写出程序局部性良好的代码、充分利用缓存机制（10.2 &amp; 11.X）；</li>
</ul>
<h2 id="12-2-Limits-to-Compiler-Optimization"><a href="#12-2-Limits-to-Compiler-Optimization" class="headerlink" title="12.2 Limits to Compiler Optimization"></a>12.2 Limits to Compiler Optimization</h2><ul>
<li><p>无法优化算法的渐进时间复杂度；</p>
</li>
<li><p>绝不会改变程序语义、行为；</p>
</li>
<li><p>编译时仅仅分析每个函数一次（inline 函数除外）；</p>
<blockquote>
<p>目前 Whole-program analysis (“LTO”) 比较受欢迎，尽管开销很大；</p>
</blockquote>
</li>
<li><p>无法很好地针对运行时的输入内容进行优化</p>
<ul>
<li>可能出现最坏情况，尤其是面对非法输入的时候；</li>
</ul>
</li>
</ul>
<h2 id="12-3-Generally-Useful-Optimizations"><a href="#12-3-Generally-Useful-Optimizations" class="headerlink" title="12.3 Generally Useful Optimizations"></a>12.3 Generally Useful Optimizations</h2><blockquote>
<p>本部分的优化技巧不针对特定的编译器或者处理器，具有普适性。</p>
<p>绝大多数编译器在一定的优化等级下，都能优化本节的情况，但是我们应该学习这些方法。</p>
<p>注：一个能看到优化过程的网站：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://godbolt.org/z/Es5s8qsvj">COMPILER EXPLORER</a></p>
</blockquote>
<p>根据 12.1 中的目标，我们可以整理出一些常见的情况，这些情况下编译器能够优化，或者说具有普适性的优化策略，主要有以下两类：</p>
<ul>
<li>Local Optimizations (<strong>work inside a single basic block</strong>)<ul>
<li>Constant folding（常数折叠）</li>
<li>Strength reduction（计算强度削减）</li>
<li>Dead code elimination（死代码剔除）</li>
<li>Local CSE（Local Common Subexpression Elimination，局部的相似子表达式复用）</li>
<li>……</li>
</ul>
</li>
<li>Global Optimizations (<strong>process the entire control flow graph of a function</strong>)<ul>
<li>Loop transformations（循环结构转换）</li>
<li>Code motion（代码移动）</li>
<li>Inlining（内联化）</li>
<li>Global CSE（全局的相似子表达式复用）</li>
</ul>
</li>
</ul>
<p>这章仅仅叙述它们的思路，不涉及具体实现，因为具体实现就涉及到编译原理（AST 语法树等知识）；</p>
<h3 id="12-3-1-Constant-Folding"><a href="#12-3-1-Constant-Folding" class="headerlink" title="12.3.1 Constant Folding"></a>12.3.1 Constant Folding</h3><p>常数折叠的方法主要有以下几个方面：</p>
<ul>
<li><p>直接运算代码中的常数表达式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> mask = <span class="number">0xFF</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 优化为：</span></span><br><span class="line"><span class="type">long</span> mask = <span class="number">0xFF00</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接运算一切可以常量化的表达式，例如针对常量调用的库函数、常量输入等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> namelen = <span class="built_in">strlen</span>(<span class="string">&quot;Harry Bovik&quot;</span>);</span><br><span class="line"><span class="comment">// 优化为：</span></span><br><span class="line"><span class="type">size_t</span> namelen = <span class="number">11</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="12-3-2-Dead-Code-Elimination"><a href="#12-3-2-Dead-Code-Elimination" class="headerlink" title="12.3.2 Dead Code Elimination"></a>12.3.2 Dead Code Elimination</h3><p>死代码删除方法的思路主要来源于 12.1 中的 “Avoid Branching” 和 “Minimize number of instructions”，分为以下几种情况：</p>
<ul>
<li><p>删除语义上不可能执行到的代码（无效代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Hello, 0&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Hello, 1&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Hello, 1&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除结果被覆盖的代码（也是无效代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">23</span>; x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">x = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这类优化方式看起来很蠢，但也很重要，因为有时候这些死代码不容易被肉眼识别，或者在编译器进行其他优化过程中，在语义树上出现了，那么就需要这种方法来清理。</p>
<h3 id="12-3-3-Common-Subexpression-Elimination"><a href="#12-3-3-Common-Subexpression-Elimination" class="headerlink" title="12.3.3 Common Subexpression Elimination"></a>12.3.3 Common Subexpression Elimination</h3><p>CSE 的思路就是根据 AST 树的特征，约去<strong>重复计算</strong>，从而降低运算量，例子如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处展示的是 Local CSE */</span></span><br><span class="line"></span><br><span class="line">up = val[(i<span class="number">-1</span>)*n + j];</span><br><span class="line">down = val[(i+<span class="number">1</span>)*n + j];</span><br><span class="line">left = val[i*n + j - <span class="number">1</span>];</span><br><span class="line">right = val[i*n + j + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以改为：</span></span><br><span class="line"><span class="type">long</span> inj = i*n + j;</span><br><span class="line">up = val[inj - n];</span><br><span class="line">down = val[inj + n];</span><br><span class="line">left = val[inj - <span class="number">1</span>];</span><br><span class="line">right = val[inj + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">norm[i] = v[i].x * v[i].x + v[i].y * v[i].y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">elt = &amp;v[i];</span><br><span class="line">x = elt-&gt;x;</span><br><span class="line">y = elt-&gt;y;</span><br><span class="line">norm[i] = x * x + y * y;</span><br></pre></td></tr></table></figure>
<h3 id="12-3-4-Code-Motion"><a href="#12-3-4-Code-Motion" class="headerlink" title="12.3.4 Code Motion"></a>12.3.4 Code Motion</h3><p>I.e., reduce frequency with which computation performed（也是降低代码重复运算频率，不过是在 global 范围进行）</p>
<ul>
<li><p>If it will always produce same result（这种改动<strong>语义不变</strong>）；</p>
</li>
<li><p>Especially moving code out of loop（常见于将代码移出循环结构，但为了保持语义，要求移动的代码在每次循环中的结果不变）；</p>
</li>
<li><p>Example：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_row</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> i, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        a[n*i + j] = b[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为（将 n*i 这个与循环无关的变量提出循环，避免重复运算）：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_row</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> i, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">int</span> ni = n * i;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        a[ni + j] = b[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="12-3-5-Inlining"><a href="#12-3-5-Inlining" class="headerlink" title="12.3.5 Inlining"></a>12.3.5 Inlining</h3><p>I.e., copy body of a function into its caller(s);</p>
<p>对于一些短的、计算开销小的非递归函数，即便编程人员不指定 <code>inline</code> 关键字，编译器也应该识别到并且内联操作。这样做的好处有两点：</p>
<ul>
<li>消除函数调用的栈帧分配开销；</li>
<li>为其他许多优化方法<strong>创造条件</strong>。例如，对代码中的一些函数内联，可以被编译器找到例如 dead code elimination、constant fold 的机会；</li>
</ul>
<p>这是个例子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/inlining_example1.png"></p>
<p>缺点：</p>
<ul>
<li>这种优化方法在某些情况下（内联函数很长、开销很大）会导致整体代码空间占用变大、速度降低；</li>
<li>对调试工具、profiling 工具不友好；</li>
</ul>
<h3 id="12-3-6-Strength-Reduction"><a href="#12-3-6-Strength-Reduction" class="headerlink" title="12.3.6 Strength Reduction"></a>12.3.6 Strength Reduction</h3><p>I.e., replace costly operation with simpler one.（计算量减小）</p>
<ul>
<li>可以用移位、加法尽量代替乘法、除法（优化的比例取决于不同的机器）；</li>
</ul>
<h2 id="12-4-Obstacles-for-Compiler-to-Optimization"><a href="#12-4-Obstacles-for-Compiler-to-Optimization" class="headerlink" title="12.4 Obstacles for Compiler to Optimization"></a>12.4 Obstacles for Compiler to Optimization</h2><p>现在反过来看，有哪些操作会阻碍编译器优化？</p>
<p>阻碍编译器优化的原因之一就是期间调用了其他函数，这样 gcc 可能就无法识别到优化方法。还有一个主要原因就是 “内存别名” 的存在。</p>
<h3 id="12-4-1-Optimization-Blocker-1-Procedure-Calls"><a href="#12-4-1-Optimization-Blocker-1-Procedure-Calls" class="headerlink" title="12.4.1 Optimization Blocker #1: Procedure Calls"></a>12.4.1 Optimization Blocker #1: Procedure Calls</h3><p>典型例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到，循环判断条件中有一个函数 <code>strlen(s)</code>，我们都知道这是计算字符串长度的函数。但是<strong>编译器不知道</strong>，它认为<strong>这个函数有可能在每次循环中，返回值可能改变</strong>，所以不会把它优化为一个常数，而是保持<strong>每次循环判断时，都重新调用 <code>strlen(s)</code></strong>。</p>
<p>可是，<code>strlen(s)</code> 的复杂度是  $O(n)$ 啊！这样好端端的 $O(n)$ 能实现的函数被硬生生干成了 $O(n^2)$ ……</p>
<p>所以，正确的做法是，先把 <code>strlen(s)</code> 算出来。更好的主意是，<strong>干脆不使用 <code>strlen()</code>，因为判断字符串结束原本就是能在循环中发现的情况</strong>，并且把数组索引改成指针取值，这样还能再节省常数时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *s &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            *s -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回过头来，为什么绝大多数的编译器没法优化这种 procedure calls 的情况？主要有几点原因：</p>
<ul>
<li>Procedure may have side effects; 就像前面说的，编译器不知道运行这个 procedure 会不会改变当前环境中其他变量的值，所以不敢贸然改变 procedure 运行顺序；</li>
<li>Procedure 会出现重载、重写的情况，这些函数有不同版本，可能分布在不 同文件中，只有编译结束，链接的时候才知道最终用的函数是谁。对于虚函数而言，甚至要在运行时才知道调用的是哪一个同名函数；所以更不敢随意判断某个 procedure 的作用，也就无法解决上面的问题；</li>
<li>如果全面分析所有同名 procedure，并且找到它们的含义、作用，那么编译开销过大，非常不现实；</li>
</ul>
<p>综上，编译器一般的做法是<strong>将 procedure 看作一个黑盒，行为不确定，所以一般不会优化它的执行顺序</strong>。因此，开发者应该清楚意识到函数的作用，并且重视它执行的位置对代码性能的影响。</p>
<h3 id="12-4-2-Optimization-Blocker-2-Memory-Aliasing"><a href="#12-4-2-Optimization-Blocker-2-Memory-Aliasing" class="headerlink" title="12.4.2 Optimization Blocker #2: Memory Aliasing"></a>12.4.2 Optimization Blocker #2: Memory Aliasing</h3><p>先看示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sum rows is of n x n matrix a and store in vector b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum_rows1</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        b[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">               b[i] += a[i*n + j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码看起来性能上没什么问题，大多数人都会如此实现代码。但是我们看看对应的 x86-64 汇编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># sum_rows1 inner loop</span><br><span class="line">.L4:</span><br><span class="line">    movsd	(%rsi,%rax,8), %xmm0	# FP load</span><br><span class="line">    addsd	(%rdi), %xmm0			# FP add</span><br><span class="line">    movsd	%xmm0, (%rsi, %rax, 8)	# FP store</span><br><span class="line">    addq	$8, %rdi</span><br><span class="line">    cmpq	%rcx, %rdi</span><br><span class="line">    jne		.L4</span><br></pre></td></tr></table></figure>
<p>我们发现，小小的 <code>b[i] += a[i*n + j]</code> 竟然有两次对内存的操作（从内存读到寄存器，计算后再写回内存），为什么会这样？为什么不直接在内存中计算？</p>
<p>这是因为 <strong>Memory Alias（内存别名）在 C 中是允许的</strong>。比如，如果我这么调用 <code>sum_rows1</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> A[<span class="number">9</span>] =</span><br><span class="line">    &#123; 	<span class="number">0</span>,	<span class="number">1</span>,	<span class="number">2</span>,</span><br><span class="line">          <span class="number">4</span>,	<span class="number">8</span>,	<span class="number">16</span>,</span><br><span class="line">         <span class="number">32</span>,	<span class="number">64</span>,	<span class="number">128</span>	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* B = A+<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">sum_rows1(A, B, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>那么，第二参数 <code>B</code> 就是 <code>A</code> 的一部分的<strong>内存别名</strong>，也就是说，程序有两个指针指向一块内存地址，这样的话，在每次 <code>B[i] = 0</code> 后，就会改变 <code>A</code> 的内容，从而改变求和的值。因此编译器仍然不敢直接优化。</p>
<p>问题在于，我们知道这个函数的作用是数组列求和，我们不会传入两个内存别名。但是编译器不知道——因为要检查所有的 memory alias 开销也非常大，所以编译器默认程序中都存在内存别名。</p>
<p><strong>所以解决方法是</strong>，我们暗示编译器这里不会有内存别名导致循环中数组值的更改：<strong>在求和时不直接加到 <code>b</code> 中，而是以临时局部变量存储，求和循环结束后同一赋值给 <code>b</code></strong>，这样在一次求和循环中编译器就不会重复从内存读取信息了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sum rows is of n x n matrix a and store in vector b */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum_rows1</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">double</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">               val += a[i*n + j];</span><br><span class="line">        b[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样内层求和循环的汇编码就变得简单了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># sum_rows1 inner loop</span><br><span class="line">.L10:</span><br><span class="line">    addsd	(%rdi), %xmm0	# FP load + add</span><br><span class="line">    addq	$8, %rdi</span><br><span class="line">    cmpq	%rax, %rdi</span><br><span class="line">    jne		.L10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上，内存读写仍然是耗时大头，所以改写后性能提升不会非常明显。</p>
</blockquote>
<p>对开发者而言，应该习惯于在循环前引入一些局部变量（<strong>Accumulate in temporary</strong>），尤其是含有数组索引的循环，这样能够暗示编译器按照没有内存别名的情况处理。</p>
<p>总结一下就是：</p>
<ul>
<li>多使用临时局部变量来存放中间值，尤其是在循环中；</li>
<li>使用更严格的关键字，例如 <code>int[]</code> 好过 <code>int*</code> 来让编译器知道不会有 memory alias；</li>
</ul>
<p>上面的几种优化技巧都是比较简单和零碎的，不宜死记硬背，应该贯通在实践当中。下面从另一个角度考虑优化问题。</p>
<h2 id="12-5-Machine-Dependent-Optimization"><a href="#12-5-Machine-Dependent-Optimization" class="headerlink" title="12.5 Machine-Dependent Optimization"></a>12.5 Machine-Dependent Optimization</h2><blockquote>
<p>这类优化取决于处理器机器和系统，根据汇编处理方式进行优化。</p>
</blockquote>
<p>表面上与机器无关的优化方法都考虑得差不多了，但在机器层面还有一些优化的方法。为了考虑这些方法，我们需要先了解机器的简单组成和基本运作原理。下面是上个世纪末的处理器的大概的设计样式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/modern_CPU_design.png" height="400px"></p>
<p>底层机制过于复杂，一般人短时间内几乎不可能理解，所以这里仅仅浅浅介绍一下。</p>
<p>CPU 执行代码时，借助了多种方法和技术，构建了健全的硬件设施，使得其执行指令的速度远远快于一条一条读取执行的速度。其中一种技术被称为 “超标量乱序执行” 技术（super-scalar out of order execution），它的思路可以理解为：CPU 一次性读入大量机器指令，再将顺序的指令拆开，发现逻辑上某两句间不相互依赖，于是 CPU 可以不按顺序、尽可能多地同时执行这些代码。</p>
<blockquote>
<p>Superscalar（超标量）</p>
<ul>
<li>每个时钟周期执行多个操作；</li>
<li>指令级并行（CPU 自主发现指令间依赖关系，并行执行没有依赖关系的指令）；</li>
</ul>
<p>Out-of-order execution（乱序执行）</p>
<ul>
<li><strong>Instruction Control Unit (ICU)</strong>: Fetch / Decode / Write Back; <strong>Execution Unit (EU)</strong>: Execute / Memory;</li>
<li>Fetch Control: Branch Prediction（比 Y86-64 的更高级） + Speculative Execution;</li>
<li>Instruction Decode</li>
</ul>
</blockquote>
<p>指令的这种特性被称为 <strong>指令级并行性（instruction level parallelism）</strong>；</p>
<p>上图的 Instruction Control 展示了 CPU 如何从高速缓存中抓取指令，并放入运算单元的。<strong>注意，这里所有的操作都使用缓存和寄存器</strong>，因为其他储存介质（包括内存）都太慢了。</p>
<p>上面<strong>在一个时钟周期中处理、执行多条指令的处理器</strong>被称为 Super-scalar Processor，它们通常一次性获取一串指令流，并动态地进行调度和执行。它的好处是 <strong>充分利用了代码中的指令级并行性</strong>，所以大多数现代 CPU 都是超标量的，并且现代 CPU 的执行模型也几乎都是乱序执行的模型。</p>
<p>现代 CPU 的策略是乱序执行，固然非常复杂，比之前讨论过的按序执行的<strong>流水线（pipelining）</strong> 更复杂。</p>
<p>流水线的基本思想是，<strong>处理器将每个计算分解为一系列不同阶段，每个阶段都有一个专用硬件可以独立完成。于是，当一个计算阶段的硬件空闲下来时，就可以接受下一个数据的计算工作</strong>。</p>
<p>其中，除法运算无法被分解在流水线上进行，一次操作 3 ~ 30 个时钟周期，所以是一个昂贵的操作。</p>
<blockquote>
<p>这些并行性都是单个 CPU 的单核的并行性，不涉及多核并行。</p>
</blockquote>
<p>总的来说，在机器层面上，程序的优化上限有两点：</p>
<ol>
<li><p>Latency Bound: 当 一系列指令被执行时必须按照严格的顺序进行 时，也就是说后一条指令依赖前一条的结果，此时程序的性能会受到限制。<strong>这种瓶颈（data dependency）限制了指令级别的并行性</strong>（没有 Y86-64 的 data forwarding）；</p>
<blockquote>
<p>其计算方法就是，<strong>一条指令 / 操作 最原本的 latency 时延，与承载量无关</strong>；</p>
</blockquote>
</li>
<li><p>Throughout Bound：处理器的运算单元所能达到的最大承载量（computing capacity，通常与对应运算单元数目、运算单元种类有关），这也是程序性能的最终上界。</p>
</li>
</ol>
<hr>
<p>接下来，借助流水线的知识，我们再分析一下现代处理器内部各个模块是如何进行协作的，以便我们针对特定机器进行优化。</p>
<p>对于现代处理器，主要就分为以上的两个部分：Instruction Control Unit &amp; Execution Unit。其中  Instruction Control Unit 的主要结构如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/ICU.png" height="200px"></p>
<ul>
<li><p>对于 Fetch Control Logic，采用的技术就类似在流水线中介绍的 Branch Prediction + Speculative Execution；</p>
<blockquote>
<p>前者（branch mis-prediction）表示一种预测下一条指令位置的技术（是否选择分支的策略、预测目标分支的策略）；后者（speculative execution）表示在分支预测后，还没有确定是否正确就立即取出预测位置的指令进行执行。如果后面检查出现错误，则恢复到原先的状态；</p>
</blockquote>
</li>
<li><p>对于 Instruction Decoding Logic，它的工作就有些不一样。为了充分利用指令集并行资源，该逻辑块：</p>
<ul>
<li><p>将传入的指令数据继续分解为 primitive instructions，每个 primitive instruction 都存在更简单的算术、加载、存储的任务，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addq %rax, 8(%rdx)</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">load 8(%rdx) -&gt; t1</span><br><span class="line">addq %rax, t1 -&gt; t2</span><br><span class="line">store t2, 8(%rdx)</span><br></pre></td></tr></table></figure>
<p>下一步，为了方便交给下面的 Execution Unit 进行并行运算，中间存在一个 <strong>寄存器重命名</strong> 的步骤（后面再描述具体原因），根据原本一条指令所对应的 primitive instructions 用到的临时寄存器，<strong>按使用依赖关系对版本进行编号</strong>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">    .L25:         # Loop:</span><br><span class="line">    vmulsd (%rdx),%xmm0,%xmm0     # t *= data[i]</span><br><span class="line">    addq $8, %rdx         # Increment data+i</span><br><span class="line">    cmpq %rax,%rdx         # Comp to data+len</span><br><span class="line">    jne .L25         # if !=, goto Loop</span><br><span class="line">            |</span><br><span class="line">            v</span><br><span class="line">    load (%rdx.0)       -&gt; t.1</span><br><span class="line">    mulq t.1, %xmm0.0   -&gt; %xmm0.1</span><br><span class="line">    addq $8, %rdx.0     -&gt; %rdx.1</span><br><span class="line">    cmpq %rax, %rdx.1   -&gt; cc.1</span><br><span class="line">    jne-taken cc.1</span><br><span class="line"></span><br><span class="line">而 Execution Unit 部分的主要结构如下图所示：</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;imgs/EU.png&quot; height=&quot;200px&quot;&gt;</span><br><span class="line"></span><br><span class="line">我们发现这里存在很多单独的运算单元，可以从 ICU 部分接收更多指令（$\mu$ code，即上面的 primitive instructions），并行进行不同种类 $\mu$ code 的运算。</span><br><span class="line"></span><br><span class="line">Data Cache 是存放最近访问的 / 临时的数据的地方。遵循 Memory Hierarchy，支持 EU 运算单元的快速存取，稍晚些时候会根据情况向 ICU 的 register files  以及 memory 写入数据。</span><br><span class="line"></span><br><span class="line">此外，Branch 模块不是用来运算某个分支是否应该跳转，而是用来计算分支预测是否正确。若预测错误，则 Branch 会通知丢弃该分支中执行得到的所有数据（利用 ICU 中的 Retirement Unit 不允许错误数据写入，并通知 Data Cache 标记无效数据），否则保留数据并写入；</span><br><span class="line"></span><br><span class="line">同时，ICU 中的 Retirement Unit 跟踪当前过程所有正在执行的指令，确保数据存取符合 sequential 语义。大致逻辑如下：</span><br><span class="line"></span><br><span class="line">当一个指令被 decode，它的信息会被放入一个 FIFO 队列中，直到两种情况之一才会从队头出队：</span><br><span class="line"></span><br><span class="line">1. Retirement Unit 发现该指令的所有 primitive instructions 被执行完，并且所有涉及通向该指令的 branch prediction 都是正确的，这条指令才会被 “retired”，结果写入程序寄存器中；</span><br><span class="line">2. 如果 Retirement Unit 发现该指令途中某个 prediction 是错误的，那么这个指令会被 “flushed”，计算结果会被抛弃，不会写入寄存器中。</span><br><span class="line"></span><br><span class="line">&gt; 注：上图所描述的 “Arithmetic Operation” 单元是被特化来执行整型、浮点型的不同组合的运算的（就是说，这些单元能执行多种不同操作，例如既能整型运算又能浮点型运算）。这样不致于程序对硬件资源的利用率不好。</span><br><span class="line"></span><br><span class="line">那么，“乱序执行” 技术如何实现？很简单，在 ICU 的 Instruction Decode Logic 给出 $\mu$ code 后，由于 $\mu$ code 的临时寄存器只需要记住版本，可以随意选取，因此设计了一个类似任务队列的指派单元，将上面发出的 $\mu$ code 根据**当前 EU 硬件空余情况**分发下去执行。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;imgs/ICU-dispatch.png&quot; height=&quot;200px&quot;&gt;</span><br><span class="line"></span><br><span class="line">**为了加速一条指令到另一条指令的结果传送，处理器引入了一个机制，就是提到的 “寄存器重命名”。这些信息被共享在 renaming table 中（如上图下方的一条长横线）。当运算单元接到 $\mu$ code 后，会立即进行运算（非依赖地并行），将寄存器名、版本号组成的 二元组 $(u,t)$ 写入这个列表中**。</span><br><span class="line"></span><br><span class="line">&gt; 注：这个表维护每个寄存器 $u$ 与更新的重命名版本标记 $t$ 之间的关系。</span><br><span class="line">&gt;</span><br><span class="line">&gt; &lt;u&gt;这个表只包含未 “退役” 的寄存器条目。如果指令在表中没找到某个寄存器，那么说明值在寄存器文件中&lt;/u&gt;，需要的指令这时才会向寄存器文件请求查找。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 每当 Branch 确定了分支结果后，才会通知 retirement unit 将正确的分支上运行的结果写入寄存器。这个时候也会重整 renaming table；</span><br><span class="line"></span><br><span class="line">等待某个版本 $t$ 的指令可以在表中得到数据，这种方式就是一种形式的 “数据转发”（比 Y86-64 的 data forwarding 更快）。&lt;u&gt;通过这种机制，能让依赖前一操作的操作尽快开始，而不需要存入寄存器文件再读出来。&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">&gt; 这个 renaming table 就避开了 Y86-64 中的 control hazard，即便 branch prediction 还没有验证、不能更改程序寄存器，也依然能临时存放一些计算好的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最后，为了定性分析其中的运算效率，我们定义：</span><br><span class="line"></span><br><span class="line">- Issue Time（发送时延）：一个 $\mu$ code 从 ICU 发向 EU 的一个运算单元后，下一条 $\mu$ code 被发送到同一运算单元的时间间隔（硬件限制）；</span><br><span class="line"></span><br><span class="line">- Latency（延迟）：在一个 $\mu$ code 被发送到指定运算单元后，该运算单元需要多长时间来运算；</span><br><span class="line"></span><br><span class="line">  &gt; latency 的计算与 capacity 无关，只与这个指令运算本身的时间有关。</span><br><span class="line"></span><br><span class="line">- Capacity（硬件承载量）：一个处理器对于某种运算，运算单元的数量。</span><br><span class="line"></span><br><span class="line">- Max Throughput（最大吞吐量）：$T=\dfrac&#123;Capacity&#125;&#123;Issue\space Time&#125;$；</span><br><span class="line"></span><br><span class="line">- Throughput Bound（吞吐量界限）：最大吞吐量的倒数，描述了 **执行一条指令在吞吐量的限制下，需要的时间界限**；</span><br><span class="line"></span><br><span class="line">- Latency Bound（延迟界限）：等于延迟本身。描述了 **顺序执行一条指令（就是延迟的限制下）的时间界限**。</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;imgs/intel-instr-metrics.png&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  &gt; 如上图，我们从 `Intel Core i7 Haswell` 处理器的指标可以发现，Add / Multi 在 Latency &gt;= 1 的情况下，仍然有 Issue Time = 1，说明内置了流水线技术。并且，可以通过 Latency 反推流水线有多少个 stages。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 我们还发现，divider 没有内置流水线，因为 Issue Time = Latency Time，**这说明了一个除法运算不能被分割成多个 stages，必须等待前一个计算完成才能继续计算下一个**；</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 同时，不同种类的除法运算（如数据类型）耗时不同，相同点是耗时很长。</span><br><span class="line">  </span><br><span class="line">  &lt;img src=&quot;imgs/ops-CPE.png&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  这个图的数据就是由上一个图的信息得到的。所有运算的 latency 对应上面硬件限制的 latency time；Throughput 则是由 Capacity / Issue Time 得到的。</span><br><span class="line">  </span><br><span class="line">  **但是，虽然整型加法有 4 个运算单元，但是 Throughput 只有 0.5，主要是因为处理器最多只有 2 个 load 单元**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 12.5.0 Data-Flow Representation: Machine-level Profiling</span><br><span class="line"></span><br><span class="line">在利用我们已有对于 Modern Processor 的认识来 tuning 程序前，我们还要掌握一种分析机器指令级运算效率的图：Data-Flow 图。</span><br><span class="line"></span><br><span class="line">**它展现了不同操作间数据的 dependency 是如何限制执行顺序，并形成关键路径的**。这个关键路径就是该组机器指令的执行时间下界。</span><br><span class="line"></span><br><span class="line">以一个结构体数据类型为例：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">/* data structure for vectors */</span><br><span class="line">/* we can use different declarations for data_t */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    size_t len;</span><br><span class="line">    data_t *data;</span><br><span class="line">&#125; vec;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>其中的一个函数是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retrieve vector element and store at val. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_vec_element</span><span class="params">(vec* v, <span class="type">size_t</span>, idx, <span class="type">data_t</span>* val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= v-&gt;len) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">/* Out of range. */</span></span><br><span class="line">    *val = v-&gt;data[idx];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这个函数进行<strong>基准测试（Benchmark Computation）</strong>：</p>
<ul>
<li><p>测试函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;        <span class="comment">/* 将可能重复计算的部分提出循环 */</span></span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)    <span class="comment">/* 不使用额外的 procedure 来重复检查 v-&gt;len */</span></span><br><span class="line">        t = t OP d[i];</span><br><span class="line">    *dest = t;                    <span class="comment">/* 不直接在循环内给数组赋值，使用 local variable */</span></span><br><span class="line">&#125;                                <span class="comment">/* 暗示编译器没有 memory alias */</span></span><br></pre></td></tr></table></figure>
<p>我们将使用不同数据类型（<code>data_t</code> 分别是 <code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>），针对不同运算和值（<code>OP</code> 分别是 <code>+</code>、<code>*</code>，<code>IDENT</code> 分别是 0、1）；</p>
</li>
<li><p>测试指标：<strong>CPE (Cycle Per Element)</strong></p>
<ul>
<li>Convenient way to express performance of program that operates on vectors or lists.</li>
<li><strong>在这里，CPE 就是一个时钟周期中的进行 <code>OP</code> 运算的次数，总时长指标 <code>T = CPE * n + Overhead</code></strong>（这里 overhead 就是 n = 0 时的基础开销）；</li>
<li>tips: 在检查代码性能时，不应该以真实时间做单位（例如 nanosecond），应该使用处理器内部时钟周期作为单位更有用。因为开发者无法控制处理器频率，但是可以控制并衡量操作的时钟周期。</li>
</ul>
</li>
</ul>
<p>生成的机器指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L25:                                 # Loop:</span><br><span class="line">    vmulsd 	(%rdx), %xmm0, %xmm0	# Multiply acc by data[i]</span><br><span class="line">    addq 	$8, %rdx				 # Increment data+i</span><br><span class="line">    cmpq	%rax, %rdx				 # Compare to data+length</span><br><span class="line">    jne		.L25					 # If !=, goto Loop</span><br></pre></td></tr></table></figure>
<p>其对应的 primitive instructions 及 data-flow diagram 如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/data-flow-example.png"></p>
<p>我们能将这个 loop 中使用到的寄存器进行分类：</p>
<ul>
<li>read-only：只作为这个 iteration 的源值，例如这里是 <code>%rax</code>；</li>
<li>write-only：只作为这个 iteration 的目的地，这里没有；</li>
<li>local：这个 iteration 内部使用的寄存器（运算单元随取随用），比如这里的 <code>CC</code>；</li>
<li>loop：既作为这个 iteration 的写目的地，又作为下个 iteration 的源值，例如这里的 <code>%rdx</code>、<code>%xmm0</code>；</li>
</ul>
<p><strong>我们发现，<u>loop 类寄存器的操作链决定了这个 data-flow 的关键路径</u></strong>（因为循环不依赖的寄存器可以并在其他步骤同时执行）。</p>
<p>由此可以将 loop 类寄存器涉及的路径抽取出，根据依赖关系画出新的 data-flow：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/data-flow-example-critical.png" height="400px"></p>
<p>结合实验数据可知，这条链就是限制程序性能的关键。</p>
<p>现在我们尝试一些措施将循环 “展开”（unrolling loop），例如每个循环进行两个数组操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine5</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>)</span><br><span class="line">        t = (t OP d[i]) OP d[i+<span class="number">1</span>];        <span class="comment">/* Loop Unrolling (2x1). */</span></span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现性能结果更加接近 Latency Bound：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/comb5.png"></p>
<p>分析编译器生成的汇编代码可知，原来在一个周期中的两条运算指令的 Load 被提到前面的位置上，相当于右图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/comb5-explain.png" width="450px"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/seq1.png" width="350px"></p>
<p>由于这些乘法运算仍然前后依赖，所以尽管我们进行 unrolling loop 来减小每个 iteration 造成的开销，仍然无法超过 latency bound。</p>
<p>那么，如果我们使用 <strong>多个循环累计变量</strong>（Separate Accumulator，奇偶元素分开计算，最后合并），就能手动提高并行性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine6</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> x0 = IDENT;</span><br><span class="line">    <span class="type">data_t</span> x1 = IDENT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Combine 2 elements at a time. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        x0 = x0 OP d[i];</span><br><span class="line">        x1 = x1 OP d[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Finish any remaining elements. */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)</span><br><span class="line">        x0 = x0 OP d[i];</span><br><span class="line">    *dest = x0 OP x1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次绘制 data-flow 图会发现，关键路径变为 2 条，意味着关键路径长度被缩短，解释如右图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/comb6-explain.png" width="450px"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/seq3.png" width="350px"></p>
<p>再换一种方法，如果我们更换运算结合的顺序（被称为 <strong>Re-association Transformation</strong>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine7</span><span class="params">(vec* v, <span class="type">data_t</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = v-&gt;len;</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span>* d = v-&gt;data;</span><br><span class="line">    <span class="type">data_t</span> t = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i+=<span class="number">2</span>)</span><br><span class="line">        t = t OP (d[i] OP d[i+<span class="number">1</span>]);        <span class="comment">/* re-association */</span></span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也能发现，两条乘法指令的依赖关系改变了：每两条乘法指令只有一条在关键路径上：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/comb7-explain.png" width="450px"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/seq2.png" width=350px></p>
<p>这两种方式（separate accumulator、re-association）都能大幅度缩短关键路径，让程序性能突破 latency 瓶颈，接近吞吐量：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/combs-comp.png"></p>
<p>如果 separate accumulator 展开 10 次，就能更大限度利用机器资源。</p>
<p>但是，无论是 unrolling loop，还是 separate accumulator，都有一个界限：register spilling（寄存器溢出）。如果中间步骤展开过多，超过了已有寄存器数量，<strong>这时处理器会用内存来代替，反而会降低运行效率</strong>。</p>
<p>此外，之前我们提到了尽管整数加法有 4 个器件，但 throughput 不会超过 0.5，是因为 load/store 的约束。而我们之前看到的例子中，load 似乎不在关键路径上（因为之前的 load 只依赖于索引 i）。其实，load/store 操作也会和之前的 multiply 一样成为某些程序的关键路径，例如链表程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">long</span> data;</span><br><span class="line">&#125; list_ele, *list_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">list_len</span><span class="params">(list_ptr ls)</span> &#123;</span><br><span class="line">    <span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L3:</span><br><span class="line">    addq	$1, %rax</span><br><span class="line">    movq	(%rdi), %rdi</span><br><span class="line">    testq	%rdi, %rdi</span><br><span class="line">    jne		.L3</span><br></pre></td></tr></table></figure>
<p>这个时候加载的结果决定下一条操作的地址时，load 指令（<code>movq</code> 的其中一个 $\mu$ code）就是关键路径上的一环了。我们发现这种循环的 CPE 约 4.00，说明：<u><strong>load 的 latency 约 4.00</strong></u>。</p>
<p>除了 load，store 也会成为关键路径的一环。来看两个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_array</span><span class="params">(<span class="type">long</span>* dest, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dest[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_read</span><span class="params">(<span class="type">long</span> *src, <span class="type">long</span> *dst, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> cnt = n;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cnt) &#123;</span><br><span class="line">        *dst = val;</span><br><span class="line">        val = (*src) + <span class="number">1</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func1</code> 的 CPE 能达到 1.0，很好解释，是因为 store <strong>暂时不影响寄存器值（前面提到 pending write 到 renaming table）</strong>，不会产生数据依赖，因此可以完全流水线化，这也是最佳情况（throughput bound）。</p>
<p>但是 <code>func2</code>，如果 <code>src != dst</code>，那么 CPE 约为 1.3；但是如果 <code>src == dst</code>，那么 CPE 上升到 7.3（下降了 6 个 cycles）！这可以用 data-flow 分析出。</p>
<p>先写出汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.L3:</span><br><span class="line">    movq	%rax, (%rsi)</span><br><span class="line">    movq	(%rdi), %rax</span><br><span class="line">    addq	$1, %rax</span><br><span class="line">    subq	$1, %rdx</span><br><span class="line">    jne		.L3</span><br></pre></td></tr></table></figure>
<p><code>movq %rax, (%rsi)</code> 会被分解为两条 primitive instruction：<code>s_addr</code>（计算目标内存地址，由单独的运算单元完成）、<code>s_data</code>（数据 store）。</p>
<p>如果 store 的数据依赖于前一步的 load（read-write dependency），那么根据汇编代码可以画出：</p>
<blockquote>
<p>其中 <code>movq</code></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/data-flow-load-store.png"></p>
<p>如果 <code>src != dst</code>，那么箭头 3 不存在，关键路径将是 <code>sub</code>（CPE 约 1.3）；</p>
<p>如果 <code>src == dst</code>，那么箭头 3 的依赖关系就存在，关键路径就是 <code>s_data -&gt; load -&gt; add</code>（CPE 约 7.3）。</p>
<p>此外，还有一些在机器层面影响性能的其他因素：</p>
<h3 id="12-5-1-Branch-Misprediction-Recovery"><a href="#12-5-1-Branch-Misprediction-Recovery" class="headerlink" title="12.5.1 Branch Misprediction Recovery"></a>12.5.1 Branch Misprediction Recovery</h3><p>我们在 4.2.2 中提到过，机器层面的分支预测技术（Branch Prediction）就是为了让 CPU 流水线的效率得到充分利用而诞生的。在很多情况下，如果我们不使用条件移动的话，那么在分支预测错误的时候，很有可能整个流水线的指令和数据全部需要重新载入，这将耗费大量的运算资源和时间。</p>
<p>所以第一个思路就是从降低 <strong>Branch Misprediction Penalty</strong> 方面着手。首先了解一下分支预测技术的大概原理是啥。分支预测技术在早期使用的是简单的 heuristic：向后分支（backwards branches）经常是判断（if），向前分支（forwards branches）经常是循环（loop）。我们可以通过一些算法<strong>跟踪这些分支（尤其是循环）的历史行为，如果它经常通过某一分支，那么以后预测该分支的可能性会大一点</strong>。</p>
<p>这种预测方法在有些代码中效果显著，但是另一些代码（<strong>例如强数据依赖、强随机数据</strong>）中效果极差，甚至导致更多的 Branch Misprediction Penalty；</p>
<p>因此接近这个方面问题的可能途径如下：</p>
<ul>
<li>减少分支结构的数量：<ul>
<li>Transform loops（尽量转换、消除不必要的循环）</li>
<li>Unroll loops（下面介绍）</li>
<li>Use Conditional Moves（4.2.2）</li>
</ul>
</li>
<li>使得分支<strong>更容易被分支预测器预测</strong><ul>
<li>为循环中的数据排序（需要权衡）</li>
<li>尽量避免间接的分支结构（因为间接分支基本上都没有预测依据）<ul>
<li>函数指针判断跳转</li>
<li>虚函数运行时判断跳转</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这里介绍一下 unroll loops 的思路。unroll loops 就是<strong>将循环中的代码成倍数展开，达到均摊 Branch Misprediction Penalty 的目的</strong>。同时，这种方法还能为其他的优化方法创造条件（例如 CSE、Code Motion、Scheduling 等）。方法的示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts; i++)</span><br><span class="line">    A[i] = B[i]*k + C[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    A[i  ] = B[i  ]*k + C[i  ];</span><br><span class="line">    A[i+<span class="number">1</span>] = B[i+<span class="number">1</span>]*k + C[i+<span class="number">1</span>];</span><br><span class="line">    A[i+<span class="number">2</span>] = B[i+<span class="number">2</span>]*k + C[i+<span class="number">2</span>];</span><br><span class="line">    A[i+<span class="number">3</span>] = B[i+<span class="number">3</span>]*k + C[i+<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种方法有两个明显的缺陷，一是如果过度展开，会增长代码长度，同样会影响性能。所以需要根据数据量进行权衡；二是在某些循环中，依赖 i 进行判断的场合，这种展开就不适用了。</p>
<h3 id="12-5-2-Scheduling"><a href="#12-5-2-Scheduling" class="headerlink" title="12.5.2 Scheduling"></a>12.5.2 Scheduling</h3><p>在上面的流程中，除了 Branch Misprediction Penalty，还有一种会影响 CPU 运算性能的情况——数据读取和写入。I/O 操作的开销一直是处理器设计者头疼的地方，尽管现在有高速缓存器来进行弥补，但数据的存取在运算过程中还是尽量能少就少。</p>
<p>因此，<strong>将源代码中读取、写入的部分和运算的部分分开（最好在运算前就读入所有必需的数据、在所有运算后才写入必要的数据），能够让处理器的性能发挥到最大</strong>（这个优化也可以由编译器完成）。这种方法就称为代码调度（Scheduling）。</p>
<p>例如 12.5.1 中的代码还可以继续优化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nelts - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    B0 = B[i]; B1 = B[i + <span class="number">1</span>]; B2 = B[i + <span class="number">2</span>]; B3 = B[i + <span class="number">3</span>];</span><br><span class="line">    C0 = C[i]; C1 = C[i + <span class="number">1</span>]; C2 = C[i + <span class="number">2</span>]; C3 = C[i + <span class="number">3</span>];</span><br><span class="line">    A[i  ] = B0*k + C0;</span><br><span class="line">    A[i+<span class="number">1</span>] = B1*k + C1;</span><br><span class="line">    A[i+<span class="number">2</span>] = B2*k + C2;</span><br><span class="line">    A[i+<span class="number">3</span>] = B3*k + C3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，这样的操作对于有些情况也不适用，比如在一些业务逻辑下，读取操作必须在一群算数运算之间出现。</p>
<h2 id="12-6-Summary"><a href="#12-6-Summary" class="headerlink" title="12.6 Summary"></a>12.6 Summary</h2><p>本章讲述了一些程序优化的基本思路，主要从两个方向描述。</p>
<p>一个是与机器无关方向的优化小技巧，而这些技巧也常常会内置在编译器中，成为编译工作的一个部分。它们大致可以分为以下几类：</p>
<ul>
<li>局部的优化：例如 <strong>常数折叠、计算强度减小（通过更换运算符实现）、死代码剔除、局部的相近表达式复用消除</strong>；</li>
<li>全局的优化：例如 <strong>循环结构转换、代码移动（减少不必要的运算）、内联化、全局的相近表达式复用消除</strong>；</li>
</ul>
<p>在这个方面，我们考虑了相反的情况——什么样的编码会阻碍编译器帮助我们进行上面的优化。</p>
<ul>
<li>Procedure Calls：我们应该在代码设计时，充分考虑函数调用的位置对于性能影响；</li>
<li>Memory Alias：尤其是在循环结构中，多使用局部变量暂存中间结果，或者使用更严格的关键字；</li>
</ul>
<p>这都在提醒我们编码时，能尽早确定的定值，尽量存在局部变量中，以防编译器认为中间存在变数，而不敢于进行优化。</p>
<p>另一个是与具体机器有关方向的优化技巧（但是目前世界上的机器种类就这些，所以理论上也有一定的普适性，例如 ARM 架构和 x86 架构都能使用这种优化来提升性能），编译器不一定会帮你做这些优化，这是因为这些方法有着各自的局限性。</p>
<p>我们分析了现代 CPU 的结构特性，找到了 3 处可以进行优化的地方，一个是分支预测的部分，一个是代码中的 I/O 调度，另一个是运算顺序和方法。</p>
<p>首先我们了解了分支预测器的原理和性质，我们发现想要弥补 Branch Misprediction Penalty，就需要从两个方面入手：</p>
<ol>
<li>让它少预测点，就少错一点（减少分支结构）。这方面的方法大致有 <strong>循环转换、unrolling loops 和 conditional moves（回想之前的 General Condition Translation）</strong>；</li>
<li>提升它预测的正确率。依从分支预测器的原理，我们可以让每次产生的分支判断的结果有迹可循。总的来说，我们可以通过<strong>为需要的判断数据排序</strong>（局限性强）、<strong>减少编码一些难以预测的结构</strong>（例如函数指针判断、虚函数）。</li>
</ol>
<p>在 I/O 调度方面我们发现，CPU 频繁地从高速缓存器中读入和写出数据也会降低程序性能，因此在编码过程中写出能够让汇编码中读内存次数越少的源码越好。因此，这里的重要建议是<strong>将源代码中读取、写入的部分和运算的部分分开（最好在运算前就读入所有必需的数据、在所有运算后才写入必要的数据）</strong>。</p>
<p>本章最后以一个计算例子说明，通过<strong>分析关键路径</strong>，使用 Re-association Transformation、Separate Accumulator 来让更多的乘法运算并行起来。</p>
<p>当然，当我们利用以上技术（例如 loop unrolling）优化到一定程度后，其他方面的问题就变成了关键路径上的问题。例如 unrolling 过多时，发生 register spilling（寄存器用完了，开始使用内存）影响性能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/ch15-summary.png" height="250px"></p>
<p>最后介绍一个优化的规则：Amdahl‘s Law</p>
<script type="math/tex; mode=display">
S=\dfrac{T_{old}}{T_{new}}=\dfrac{1}{(1-\alpha)+\dfrac{\alpha}{K}}\Longrightarrow S_{\infty}=\dfrac{1}{1-\alpha}</script><p>$(1-\alpha)$ 代表不能被优化的部分，$K$ 代表能被优化的部分最快被优化多少倍。</p>
<p>当能优化的部分优化到极限后，加速比极限为 $S_\infty$。<strong>表达式说明一个通俗的道理：选择优化时间占比更大的部分（$\alpha$ 更大），优化的效果、优化的极限就更好（$S_\infty$ 更大）</strong>。</p>
<p>也就是说，我们应该在优化时找关键路径、找 hot spot（热点位置）。这就是 profiling。</p>
<p>当今的 profiling 工具有哪些？Unix 上有 <code>gprof</code>、<code>perf</code>，它们的思路是 <strong>random sampling</strong>，间隔一定时间进行指令中断，统计函数执行的次数、统计当前调用栈（可以发现调用关系、递归情况），用频率代表出现总时长占比。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SSRVodka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/review/csapp-mm-cache/">https://blog.sjtuxhw.top/review/csapp-mm-cache/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SSRVodka's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GNU/">GNU</a><a class="post-meta__tags" href="/tags/CSAPP/">CSAPP</a><a class="post-meta__tags" href="/tags/ICS/">ICS</a><a class="post-meta__tags" href="/tags/Programming/">Programming</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/csapp-mh.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/review/csapp-ecf-io/" title="CSAPP Notes: ECF &amp; I/O"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-ecf.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CSAPP Notes: ECF & I/O</div></div><div class="info-2"><div class="info-item-1">Chapter 13. Exceptional Control Flow 对应书中第 8 章。  异常控制流是现代计算机系统的一个相当重要的部分。 13.1 Control Flow 控制流：从机器打开到关闭的过程中，处理器只做一件事：读指令、执行指令，一个周期做一个指令。多核的机器则每个核心依次交替执行指令。这些指令序列被称为控制流。硬件正在执行的实际指令序列就被称为物理控制流。  改变内存中控制流的方法：分支 &amp; 跳转，过程调用 &amp; 返回（Branches &amp; Jumps &amp; Procedure call and return）；  都是对于程序状态变化的处理。    但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）； 什么是 “系统级别的状态变化”？  数据从磁盘 / 网卡到达内存中； I/O 设备输入...</div></div></div></a><a class="pagination-related" href="/technical/typescript-basic/" title="TypeScript笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/typescript.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TypeScript笔记</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference:  MDN Doc &amp;&amp; TypeScript Doc 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 1. 与 JS 比较：类型声明 与 作用域TypeScript 是个静态类型语言，变量类型/对象成员/函数签名 在定义后就不能更改！  定义变量时，请使用规范的类型声明定义方式： 1234567/* Variable */var foo: number;var bar: string = &quot;Hello, TypeScript!&quot;;/* Function */function toString(num: number): string &#123;    return String(num);&#125;  天大的福音：只声明变量、不赋值就使用会报错！这下不用担心讨厌的 undefined 了； 12let x: number;console.log(x); // TypeError 而且开启了编译选项 strictNullChecks...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/review/csapp-basic/" title="CSAPP Notes Basic"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="info-item-2">CSAPP Notes Basic</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference:  CMU - 213, Computer Systems A Programmer’s Perspective 3rd Edition by Randal Bryant, David O’Hallaron 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 内容很长，写起来很慢 😳   Chapter 0. Intro0.1 Ints are not Integers, Floats are not Reals $x^2\ge 0$：int（32-bit）may overflow； $a+(b+c)=(a+b)+c$：floats may discard some “unsignificant” digits；  0.2 Learn Assembly but never write it0.3 Memory Matters: Unbounded1234567891011121314typedef struct &#123;    int a[2];    double d;&#125;...</div></div></div></a><a class="pagination-related" href="/review/csapp-ecf-io/" title="CSAPP Notes: ECF &amp; I&#x2F;O"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-ecf.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-16</div><div class="info-item-2">CSAPP Notes: ECF &amp; I&#x2F;O</div></div><div class="info-2"><div class="info-item-1">Chapter 13. Exceptional Control Flow 对应书中第 8 章。  异常控制流是现代计算机系统的一个相当重要的部分。 13.1 Control Flow 控制流：从机器打开到关闭的过程中，处理器只做一件事：读指令、执行指令，一个周期做一个指令。多核的机器则每个核心依次交替执行指令。这些指令序列被称为控制流。硬件正在执行的实际指令序列就被称为物理控制流。  改变内存中控制流的方法：分支 &amp; 跳转，过程调用 &amp; 返回（Branches &amp; Jumps &amp; Procedure call and return）；  都是对于程序状态变化的处理。    但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）； 什么是 “系统级别的状态变化”？  数据从磁盘 / 网卡到达内存中； I/O 设备输入...</div></div></div></a><a class="pagination-related" href="/review/csapp-sched-arch/" title="CSAPP Notes: Scheduler &amp; Arch"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_p2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-11</div><div class="info-item-2">CSAPP Notes: Scheduler &amp; Arch</div></div><div class="info-2"><div class="info-item-1">Chapter 8. Scheduler in OS为操作系统的调度环境作出假设：  Each job runs for the same amount of time All jobs arrive at the same time Once started, each job runs to completion All jobs only use the CPU  i.e., they perform no I/O   The run-time of each job is known  引入调度优劣衡量指标：周转时间，$T_{turnaround}=T_{completion}-T_{arrival}$； Strategy 1: FIFO（FCFS，First Come First Served） Implementation: queue； 消除假设 1：若短时任务排在长时任务之后，则平均周转时间效果很差；  Strategy 2 : SJF（Shortest Job First） 内容：对于同时到达的任务，优先选择总时长小的任务。 作用：（应对假设 1...</div></div></div></a><a class="pagination-related" href="/technical/semaphore-mutex-and-cv/" title="Semaphore, Mutex, CV"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/smc.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-11</div><div class="info-item-2">Semaphore, Mutex, CV</div></div><div class="info-2"><div class="info-item-1">学习 ICS 的并行一章之后，笔者有些疑惑，semaphore（信号量）、mutex（互斥锁）、conditional variables（条件变量）这 3 者之间究竟该怎么区分它们的使用场景？ 首先我们需要去阐述清楚它们各自的定义和效果。 学术界认为 mutex 是 semaphore 的特例，因此像著名的书籍 CSAPP 就先以 semaphore 为例讲了讲并发程序的资源控制问题。但是实际上有相当一部分实践派和语义派认为二者不应该混为一谈。像 Linus 本人在一次将 Linux 内核的一部分 semaphore 重构为 mutex 后，发现不仅改善了代码语义，还在一定程度上提升了性能。这件事也说明了，虽然在理论上一方可以替代另一方，但实践上它们各有所长。 Semaphore vs Mutex我们先讨论 semaphore。 CSAPP 中先从 “线程间变量共享” 的情况说起，它指出，程序对内存的更改并不直接在内存上完成，在汇编中可以看到，大致经历了 load（从内存到 CPU 寄存器）、update（在 CPU 寄存器内更新数据）、store（将 CPU...</div></div></div></a><a class="pagination-related" href="/technical/gnu-tutor/" title="GNU-Tutor"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/GNU-Tutor.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="info-item-2">GNU-Tutor</div></div><div class="info-2"><div class="info-item-1">基础：C/C++的源文件编译过程 想要代码在操作系统上运行，需要进行以下编译步骤，从高级语言转机器语言，以下任务gcc/g++均能完成：  预编译（.c/cpp &amp; .h —&gt; .i ）：*对应gcc/g++命令：gcc -E [xxx] -o [output.i] 展开所有宏定义#define（字符替换）； 处理所有条件预编译命令（#ifdef、#ifndef、#endif等）； 处理#include，具体操作是将指向的文件直接插入到文件的这一行（严格遵循上一步的条件）； 删除所有注释； 添加行号、文件标识，以便调试/编译出错时及时指出； 保留#pragma指令，以供编译器使用；   编译（.i —&gt; .s ，即高级语言转汇编语言）：对应gcc/g++命令：gcc -S [xxx] -o...</div></div></div></a><a class="pagination-related" href="/review/makefile-again/" title="Makefile 快速上手 (again)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/makefile-again.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-11</div><div class="info-item-2">Makefile 快速上手 (again)</div></div><div class="info-2"><div class="info-item-1">说来惭愧，之前笔者还认为 Makefile 这种工具已经过时，只需要学 CMake 就行。 但最近在写 boot loader 时遇到了一些问题：我既不是在编译可执行文件，也不是在编译库，这样 CMake 就显得比较无力了，因为总是用 add_custom_* 也不是办法，非常臃肿——毕竟不是在管理一个 C/C++ 应用的项目嘛。所以决定再整理一下 Makefile 的写法。 本文充当一个 Makefile cheat sheet 的作用，自己有点遗忘的时候回来查一查。  Define a Target在 Makefile 中定义一个可以构建的 target： 12345&lt;target&gt;: dependency1 dependency2 ... dependency3    command1    command2    ...    commandM 这样可以使用 make &lt;target&gt; 来执行它。 注意哦，make 会认为 &lt;target&gt; 是一个需要构建的目标文件名。最终按照 commands 生成的文件会被命名为...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="xhw-card-content"><div class="xhw-avatar-group"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="xhw-sticker"><img class="sticker-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/smile.avif" alt="emoji-sticker"/></div></div></div><div class="author-info-name">SSRVodka</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span><a class="service-status-badge" id="serviceStatusBadge" href="https://status.sjtuxhw.top" rel="external nofollow noreferrer" target="_blank"><span class="status-loading"></span><span class="status-text">loading...</span></a></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-10-The-Memory-Hierarchy"><span class="toc-text">Chapter 10. The Memory Hierarchy</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-Storage-Technologies-amp-Trends"><span class="toc-text">10.1 Storage Technologies &amp; Trends</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-1-Random-Access-Memory-RAM"><span class="toc-text">10.1.1 Random-Access Memory (RAM)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-2-Nonvolatile-Memories"><span class="toc-text">10.1.2 Nonvolatile Memories</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-3-Traditional-Bus-Structure-Connecting-CPU-and-Memory"><span class="toc-text">10.1.3 Traditional Bus Structure Connecting CPU and Memory</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-Locality"><span class="toc-text">10.2 Locality</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-Conclusions-for-10-1-amp-10-2"><span class="toc-text">10.3 Conclusions for 10.1 &amp; 10.2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-Memory-Hierarchy-amp-Idea-of-Caching"><span class="toc-text">10.4 Memory Hierarchy &amp; Idea of Caching</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-11-Cache-Memories"><span class="toc-text">Chapter 11. Cache Memories</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-General-Cache-Organization"><span class="toc-text">11.1 General Cache Organization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-Read-Cache"><span class="toc-text">11.2 Read Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-Direct-Mapped-Cache-Simulation"><span class="toc-text">11.2.1 Direct-Mapped Cache Simulation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-E-Way-Set-Associative-Cache-Simulation"><span class="toc-text">11.2.2 E-Way Set Associative Cache Simulation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-Write-Cache"><span class="toc-text">11.3 Write Cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-The-Hierarchy-of-Cache-Memories"><span class="toc-text">11.4 The Hierarchy of Cache Memories</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-Performance-Impact-of-Cache"><span class="toc-text">11.5 Performance Impact of Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-1-Writing-Cache-Friendly-Code-%E2%85%A0"><span class="toc-text">11.5.1 Writing Cache Friendly Code Ⅰ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-2-The-Memory-Mountain"><span class="toc-text">11.5.2 The Memory Mountain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-3-Writing-Cache-Friendly-Code-%E2%85%A1-Rearranging-loops-to-improve-spacial-locality"><span class="toc-text">11.5.3 Writing Cache Friendly Code Ⅱ - Rearranging loops to improve spacial locality</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-4-Writing-Cache-Friendly-Code-%E2%85%A2-Using-blocking-to-improve-temporal-locality"><span class="toc-text">11.5.4 Writing Cache Friendly Code Ⅲ - Using blocking to improve temporal locality</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-5-Cache-Performance-Summary"><span class="toc-text">11.5.5 Cache Performance Summary</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-12-Program-Optimization"><span class="toc-text">Chapter 12. Program Optimization</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-Goals-of-Optimization"><span class="toc-text">12.1 Goals of Optimization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-Limits-to-Compiler-Optimization"><span class="toc-text">12.2 Limits to Compiler Optimization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-Generally-Useful-Optimizations"><span class="toc-text">12.3 Generally Useful Optimizations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1-Constant-Folding"><span class="toc-text">12.3.1 Constant Folding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-2-Dead-Code-Elimination"><span class="toc-text">12.3.2 Dead Code Elimination</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-3-Common-Subexpression-Elimination"><span class="toc-text">12.3.3 Common Subexpression Elimination</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-4-Code-Motion"><span class="toc-text">12.3.4 Code Motion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-5-Inlining"><span class="toc-text">12.3.5 Inlining</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-6-Strength-Reduction"><span class="toc-text">12.3.6 Strength Reduction</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-Obstacles-for-Compiler-to-Optimization"><span class="toc-text">12.4 Obstacles for Compiler to Optimization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-1-Optimization-Blocker-1-Procedure-Calls"><span class="toc-text">12.4.1 Optimization Blocker #1: Procedure Calls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-2-Optimization-Blocker-2-Memory-Aliasing"><span class="toc-text">12.4.2 Optimization Blocker #2: Memory Aliasing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-Machine-Dependent-Optimization"><span class="toc-text">12.5 Machine-Dependent Optimization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-1-Branch-Misprediction-Recovery"><span class="toc-text">12.5.1 Branch Misprediction Recovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-2-Scheduling"><span class="toc-text">12.5.2 Scheduling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-6-Summary"><span class="toc-text">12.6 Summary</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/2025-ccf/" title="CCF 2025 会议笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ccf-2025.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CCF 2025 会议笔记"/></a><div class="content"><a class="title" href="/technical/2025-ccf/" title="CCF 2025 会议笔记">CCF 2025 会议笔记</a><time datetime="2025-08-03T03:36:45.000Z" title="发表于 2025-08-03 11:36:45">2025-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/transformer.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Transformer 论文精读 + 代码实现"/></a><div class="content"><a class="title" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现">Transformer 论文精读 + 代码实现</a><time datetime="2025-07-20T15:15:10.000Z" title="发表于 2025-07-20 23:15:10">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/sc.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"/></a><div class="content"><a class="title" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</a><time datetime="2025-07-01T10:14:11.000Z" title="发表于 2025-07-01 18:14:11">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ml-roadmap.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识图谱：Machine Learning Roadmap"/></a><div class="content"><a class="title" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap">知识图谱：Machine Learning Roadmap</a><time datetime="2025-06-08T06:59:31.000Z" title="发表于 2025-06-08 14:59:31">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"/></a><div class="content"><a class="title" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</a><time datetime="2025-05-30T08:49:12.000Z" title="发表于 2025-05-30 16:49:12">2025-05-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SSRVodka  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-image"><a class="rightMenu-item" href="javascript:rmf.copyImageUrl();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制图片地址</span></a><a class="rightMenu-item" href="javascript:rmf.downloadImage();" rel="external nofollow noreferrer"><i class="fa-solid fa-download"></i><span>保存图片</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-link"><a class="rightMenu-item" href="javascript:rmf.copyLink();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制链接地址</span></a><a class="rightMenu-item" href="javascript:rmf.openLinkNewTab();" rel="external nofollow noreferrer"><i class="fa-solid fa-external-link-alt"></i><span>在新标签页打开</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script src="/js/status_badge.js"></script><script defer src="/js/console_welcome.js"></script><script async data-pjax src="/js/bsz.build-20250729.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>