<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>离散数学复习 | SJTU-XHW's blog</title><meta name="author" content="SJTU-XHW,sjtuxhw12345@sjtu.edu.cn"><meta name="copyright" content="SJTU-XHW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本系列文章为作者复习离散数学过程中的知识点总结、速通，欢迎补充 written by SJTU-XHW Reference: 清华大学出版社《数理逻辑与集合论（第二版）》《图论与代数结构》 提示：大段文字阅读，点击右侧齿轮图标，进入阅读模式体验更佳 ~">
<meta property="og:type" content="article">
<meta property="og:title" content="离散数学复习">
<meta property="og:url" content="https://blog.sjtuxhw.top/review/discrete-math/index.html">
<meta property="og:site_name" content="SJTU-XHW&#39;s blog">
<meta property="og:description" content="本系列文章为作者复习离散数学过程中的知识点总结、速通，欢迎补充 written by SJTU-XHW Reference: 清华大学出版社《数理逻辑与集合论（第二版）》《图论与代数结构》 提示：大段文字阅读，点击右侧齿轮图标，进入阅读模式体验更佳 ~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/dm.jpg">
<meta property="article:published_time" content="2023-06-09T14:45:15.000Z">
<meta property="article:modified_time" content="2024-10-25T14:04:01.319Z">
<meta property="article:author" content="SJTU-XHW">
<meta property="article:tag" content="Discrete-Math">
<meta property="article:tag" content="Graph">
<meta property="article:tag" content="Logic">
<meta property="article:tag" content="Set-Theory">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/dm.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/review/discrete-math/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '离散数学复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SJTU-XHW's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/dm.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SJTU-XHW's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">离散数学复习</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">离散数学复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-09T14:45:15.000Z" title="发表于 2023-06-09 22:45:15">2023-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T14:04:01.319Z" title="更新于 2024-10-25 22:04:01">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/review/">review</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">26.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>100分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/review/discrete-math/#post-comment"><span class="waline-comment-count" data-path="/review/discrete-math/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><i><u>本系列文章为作者复习离散数学过程中的知识点总结、速通，欢迎补充</u></i></p>
<p><i>written by SJTU-XHW</i></p>
<p><i>Reference: 清华大学出版社《数理逻辑与集合论（第二版）》《图论与代数结构》</i></p>
<p><i>提示：大段文字阅读，点击右侧齿轮图标，进入阅读模式体验更佳 ~ </i></p>
<span id="more"></span>
<hr>
<h2 id="Chapter-1-命题逻辑"><a href="#Chapter-1-命题逻辑" class="headerlink" title="Chapter 1 命题逻辑"></a>Chapter 1 命题逻辑</h2><h3 id="1-1-重要概念汇总"><a href="#1-1-重要概念汇总" class="headerlink" title="1.1 重要概念汇总"></a>1.1 重要概念汇总</h3><ul>
<li><p>命题的定义：能判断真假的陈述句；（真假性：命题的值）</p>
</li>
<li><p>命题分类：原子命题、复合命题（成分命题 + 联结词）</p>
</li>
<li><p>真值联结词：非（否定式）、且（合取式）、或（析取式）、如果则（蕴含式）、等价（等值式）；</p>
</li>
<li><p>命题变元：以真假为变域的变元；</p>
</li>
<li><p>真值函数：以真假为定义域、真假为值域的函数；</p>
</li>
<li><p>命题演算公式的定义：（通俗）由命题变元利用真值联结词构成的式子；</p>
<blockquote>
<p>命题变元是、公式的否定式是、两个公式的合取、析取式是；仅限于此；</p>
</blockquote>
</li>
<li><p>变元组：n元公式 α 含有不同命题变元 p1、p2、……、pn，称（p1, p2, …, pn）为 α 的变元组；</p>
</li>
<li><p>完全指派：变元组任一组确定值都称为 α 关于这个变元组的一个 ~；</p>
</li>
<li><p>部分指派：仅对变元组部分变元赋以确定值，另外一部分不赋值（X），称……；</p>
<blockquote>
<p>完全、部分指派举例：(p, q, r, s) = (T, T, F, T)；(p, q, r, s) = (T, X, X, F)</p>
</blockquote>
</li>
<li><p>成真指派、成假指派；</p>
<p><strong>一个公式的性质</strong></p>
</li>
<li><p>重言式：该公式的所有完全指派都是成真指派；</p>
</li>
<li><p>矛盾式：该公式的所有完全指派都是成假指派；</p>
</li>
<li><p>可满足公式：该公式存在成真指派；</p>
<blockquote>
<p>又可以分为：仅可满足公式、重言式；</p>
</blockquote>
</li>
<li><p>非永真式：该公式存在成假指派；</p>
<blockquote>
<p>又可分为：仅可满足公式、矛盾式；</p>
</blockquote>
<p><strong>两个公式的关系</strong></p>
</li>
<li><p>逻辑等值（<strong>同真假</strong>）：两个公式在它们的合成变元组的任何完全指派下，有完全相同的真假性；</p>
<blockquote>
<p>相对地，有<strong>互相矛盾性</strong>，~都取不同的真假值；</p>
<p>推论：α = β $\Longleftrightarrow$ α $\leftrightarrow$ β 为永真式；</p>
</blockquote>
<p><strong>需要记忆的同真假式变换：</strong></p>
<ul>
<li>交换律、结合律：<strong>蕴含词不满足</strong>；</li>
<li>分配律：<strong>等值词不满足、蕴含词分配后不变：$p\rightarrow(q\rightarrow r)=(p\rightarrow q)\rightarrow(p\rightarrow r)$</strong>；</li>
<li>摩根律、双重否定律、幂等律（与自身运算）、同一律和零律；</li>
<li><strong>联结词化归结论：$p\rightarrow q=\overline{p}\vee q$、$p\leftrightarrow q=p\wedge q \vee \overline{p}\wedge\overline{q}$</strong>；</li>
</ul>
</li>
</ul>
<ul>
<li><p>同永真性：若 α 永真当且仅当 β 永真，则称~；</p>
</li>
<li><p>同可满足性</p>
<blockquote>
<p>推论：α、β 同真假 $\Longrightarrow$ α、β 既同永真性，又同可满足性；</p>
</blockquote>
</li>
<li><p>对偶式：将任一<strong>不含蕴含词、等价词</strong>的 α 中所有 $\wedge$、$\vee$ 互换得到的公式称为 α 的对偶式，记为 $\alpha^*$；</p>
<blockquote>
<p>注：永真（T）、永假（F）看作 $p\vee\overline{p}$、$p\wedge\overline{p}$；</p>
</blockquote>
</li>
<li><p>内否式：将任一 α 中各变元（<strong>不能是子公式</strong>）的所有肯定形式和否定形式互换，得到的公式称为 α 的内否式，记为 $\alpha^-$；</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\alpha=(\overline{p\wedge q}\space\vee\space \overline{p\wedge r})\space\wedge\space(p\vee(\overline{q}\wedge\overline{r}))\\
&\alpha^*=(\overline{p\vee q}\wedge\overline{p\vee r})\space\vee\space(p\wedge(\overline{q}\vee\overline{r}))\\
&\alpha^-=(\overline{\overline{p}\wedge\overline{q}}\vee\overline{\overline{p}\wedge\overline{r}})\space\wedge\space(\overline{p}\wedge(q\vee r))
\end{aligned}</script><p>常用性质：</p>
<ul>
<li>$\alpha^-\wedge\beta^-=(\alpha\wedge\beta)^-$（对各种真值联结词适应，甚至蕴含词）</li>
<li>$(P\vee Q\wedge R)^*=P\wedge(Q\vee R)$（变换后不改变原来运算次序）</li>
<li>$\overline{\alpha^*}=\overline{\alpha}^*$、$\overline{\alpha^-}=\overline{\alpha}^-$（对偶、内否都可与否定交换运算顺序）</li>
<li>$\overline{\alpha}=\alpha^{*-}$（内否、对偶同时取即为取反）</li>
</ul>
<p>推论：</p>
<ul>
<li>$\alpha$ 与 $\alpha^-$ 既同永真性，又同可满足性（不一定同真假）；</li>
<li>$\overline{\alpha}$ 与 $\alpha^*$ 既同永真性，又同可满足性；</li>
<li>【对偶定理】$\alpha\rightarrow\beta$ 与 $\beta^*\rightarrow\alpha^*$ 既同永真性，又同可满足性、$\alpha\leftrightarrow \beta$ 与 $\alpha^*\leftrightarrow \beta^*$ 既同永真性，又同可满足性；</li>
</ul>
</li>
<li><p><strong>置换规则和代入规则的异同</strong>：</p>
<ul>
<li><p>置换规则：对公式的子公式，用与之等值的公式进行替换，得到的新公式与原公式同真假；</p>
<blockquote>
<p>可以只对某一个子公式替换；</p>
</blockquote>
</li>
<li><p>代入规则：对公式中出现的所有同一个命题变元代入一个公式，得到的新公式与原公式同真假；</p>
<blockquote>
<p>必须处处代入、必须对变元代入；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>范式：一个公式到真假指派的<strong>逆过程</strong>——如何从真假指派构造出公式</p>
</li>
<li><p>简单合取式：命题变元，或（可兼得）其否定，或（可兼得）由它们利用联结词 $\wedge$ 组成的公式；</p>
<p>简单析取式：……联结词 $\vee$ ……；</p>
</li>
<li><p>实合取式、虚合取式：某一变元的否定及其自身<strong>最多仅出现一次</strong>的简单合取式称为<strong>实合取式</strong>，否则为<strong>虚合取式（即：永假合取式）</strong>；</p>
<p>实析取式、虚析取式：……简单析取式……（<strong>永真析取式</strong>）；</p>
</li>
<li><p>（极大项极小项）唯一指派定理：对一个确定的变元组而言，任一实合取式有且仅有一个成真指派、任一个实析取式有且仅有一个成假指派（回顾数电中的极大项、极小项）；</p>
<blockquote>
<p>变元组 (p, q, r) = (T, X, F) 是一个成真指派 对应：$p\wedge\overline{q}$；</p>
<p>变元组 (p, q, r) = (F, F, T) 是一个成假指派 对应：$p\vee q\vee \overline{r}$；</p>
</blockquote>
</li>
<li><p>范式表示定理：<strong>任一公式 $\alpha$ 恒可以表示为简单合取式的 析取，称为 $\alpha$ 的析取范式（即逻辑代数中的 SOP）</strong>，也可以表示为<strong>简单析取式的 合取，称为 $\alpha$ 的合取范式（POS）</strong>；</p>
<blockquote>
<p>合取范式和析取范式不唯一；</p>
</blockquote>
</li>
<li><p>主析取范式、主合取范式：析合范式、合析范式中的简单合取式、简单析取式全为最小项、最大项；（标准SOP和标准POS）</p>
<p>主析/合取范式定理：任一个 n 元公式，都存在一个唯一的与之等值的、恰含这 n 个变元的主析/合取范式；</p>
<p><strong>最小项的表示：$m_i$ 指 使最小项为真的各变元组成的二进制数代表 i 的那个组合</strong>；</p>
<p><strong>最大项的表示：$M_i$ 指 使最大项为真（这里和主流教材不一样）的各变元组成的二进制数代表 i 的那个组合</strong>；</p>
<p><strong>最小项的性质：</strong></p>
<ul>
<li>n 元公式的最小项共 $2^n$ 种；</li>
<li>在公式的变元组任意完全指派中，有且仅有一种最小项 为真；</li>
<li>全体最小项析取为1，任意两个最小项合取为0；</li>
</ul>
<p><strong>最大项的性质</strong>：</p>
<ul>
<li>n 元公式的最大项共 $2^n$ 种；</li>
<li>在公式的变元组任意完全指派中，有且仅有一个最大项 为假；</li>
<li>全体最大项合取为0，任意两个最大项析取为1；</li>
</ul>
</li>
<li><p>范式表示定理的延伸：联结词的完备集；</p>
</li>
</ul>
<h3 id="1-2-命题逻辑的推理形式"><a href="#1-2-命题逻辑的推理形式" class="headerlink" title="1.2 命题逻辑的推理形式"></a>1.2 命题逻辑的推理形式</h3><ul>
<li><p>判断A 和 B是否重言蕴含：<strong>判断 $A\rightarrow B$ 是否永真，即在 A 所有的成真指派下，B是否都为真</strong>；</p>
</li>
<li><p>重言蕴含的性质</p>
<ul>
<li>若 $A\Rightarrow B$，则：若 A 永真，则 B 永真；</li>
<li>若 $A\Rightarrow B$、 $B\Rightarrow A$，则 A、B 等价；</li>
<li>若 $A\Rightarrow B$ 且 $A\Rightarrow C$，则 $A\Rightarrow(B\wedge C)$（归并合取）；</li>
<li>若 $A\Rightarrow C$ 且 $B\Rightarrow C$，则 $(A\vee B)\Rightarrow C$（归并析取）；</li>
</ul>
</li>
<li><p>基本推理公式</p>
<ul>
<li><p>$P\wedge Q\Rightarrow P$（从严格到一般）；</p>
</li>
<li><p>$P\Rightarrow(P\vee Q)$（从一般到模糊）；</p>
</li>
<li><p>$P\wedge(P\rightarrow Q)\Rightarrow Q$（分离规则）；</p>
<p>$\overline{Q}\wedge(P\rightarrow Q)\Rightarrow\overline{P}$（分离规则的逆否命题）；</p>
</li>
<li><p>$(P\rightarrow Q)\space\wedge\space(Q\rightarrow R)\Rightarrow P\rightarrow R$（三段论）；</p>
<p>$(P\leftrightarrow Q)\space\wedge\space(Q\leftrightarrow R)\Rightarrow P\leftrightarrow R$</p>
</li>
</ul>
</li>
<li><p>如何证明推理公式</p>
<ul>
<li>可以使用<strong>重言蕴含</strong>的定义（$A\rightarrow B$ 为永真式）——永真推理 / 假设推理；</li>
<li>使用<strong>重言蕴含</strong>定义的反面（$A\wedge\overline{B}$ 为永假式）——归结推理；</li>
<li>证明推理公式本身的<strong>逆否命题</strong>；</li>
<li>按三段论拆分；</li>
<li>真值表法；</li>
</ul>
</li>
<li><p>推理演算规则</p>
<ul>
<li><p>前提引入：推理过程中可以随时引入前提；</p>
</li>
<li><p>结论引入：推论过程中获得的结论可以作为后续推理的前提；</p>
</li>
<li><p>代入规则、置换规则</p>
<blockquote>
<p><strong>代入：对命题变元、代入的必须是重言式、所有出现都要代入</strong>；</p>
<p><strong>置换：子公式，置换部分需要等值，可以仅一部分</strong>；</p>
</blockquote>
</li>
<li><p>分离规则；</p>
</li>
<li><p>条件证明规则：<strong>$A_1\wedge A_2\Rightarrow B\Longleftrightarrow A_1\Rightarrow A_2\rightarrow B$</strong>（将条件移动到另一边）；</p>
</li>
</ul>
</li>
<li><p>归结推理法</p>
<p>为证明 $A\rightarrow B$ 重言，从 $A\wedge\overline{B}$ 开始：</p>
<p>step 1. 将 $A\wedge\overline{B}$ 化为<strong>合取范式</strong>，并由其中的子句（析取式+）构成子句集 S；</p>
<p>step 2. 对 S 中的子句做归结：<strong>消互补对（$C_1=L\vee C_1^\prime$ 和 $C_2=\overline{L}\vee C_2^\prime$ 归结为 $R(C_1,C_2)=C_1^\prime\vee C_2^\prime$）</strong>；</p>
<p>step 3. 重复step2，直至得到空子句（矛盾）；</p>
</li>
</ul>
<h3 id="1-3-考点和常见题型"><a href="#1-3-考点和常见题型" class="headerlink" title="1.3 考点和常见题型"></a>1.3 考点和常见题型</h3><ul>
<li><p>命题的判断</p>
<blockquote>
<ol>
<li>必定为陈述句，否则没有真假；</li>
<li>必须可以辨别真假；</li>
<li>未证明的定理算，因为最终是有真假的；</li>
<li>悖论不算：“这句话是假话”；</li>
</ol>
</blockquote>
</li>
<li><p>真值联结词和自然语言的差异</p>
<ul>
<li>并列“和”、并且“和”；</li>
<li>可兼得“或”、不可兼得“或”；</li>
<li>不关心因果的“如果……则……”；</li>
</ul>
</li>
<li><p>波兰表达式（前缀表达式）、逆波兰表达式（后缀表达式）、中缀表达式的转换</p>
<p><strong>前缀式书写思路：找到当前最后运算的运算符，先放到当前区块的最前面，以此为分割，分别处理左右边的式子</strong>；</p>
</li>
<li><p>给定一个公式，确定其成真指派、成假指派</p>
<p>step 1. 应用等值运算将否定词深入到变元上；</p>
<p>step 2. 随机指定一个变元（建议选出现次数多、对它指派能轻松得到结果的变元），对其分别做 T、 F 指派（分类讨论），得到两个不含该变元，但有真假值的公式；</p>
<p>step 3. 化简这两个公式，如果仍存在变元，重复上面的操作，直至能够直接判断真假为止；</p>
<blockquote>
<p>e.g., 判定 $(p\vee\overline{r})\rightarrow\overline{((p\rightarrow q)\leftrightarrow\overline{(p\wedge\overline{(q\leftrightarrow r)})})}$ 的永真性和可满足性；</p>
</blockquote>
</li>
<li><p>判断联结词的完备集、联结词相互转化</p>
<ul>
<li><p>否定、析取、合取：$\neg$ 和 $\vee$ 、$\neg$ 和 $\wedge$ 构成<strong>最小完备集</strong>，但 $\wedge$ 和 $\vee$ 不行！！！</p>
</li>
<li><p>与非（$\uparrow$）、或非（$\downarrow$）：各自独立构成<strong>最小完备集</strong>；</p>
</li>
<li><p><strong>否定和蕴含（$\rightarrow$）构成一个最小完备集</strong>，但否定和等价<strong>甚至连完备集都不是</strong>！！！</p>
</li>
<li><p>除了以上提到的最小完备集，及其扩充，其他任何联结词组成的集合都不是完备集；</p>
<blockquote>
<p>e.g., $\{\wedge,\leftrightarrow\},\{\vee,\rightarrow\},\{\neg,\leftrightarrow\}$ 等，都不是完备集；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>n 元联结词的数量：$2^{2^n}$个；</p>
</li>
<li><p>将一个公式转换为对应的主析取范式、主合取范式、最简析合范式、最简合析范式；</p>
<blockquote>
<p>e.g.1, 将 主析取范式 $A=\bigvee_{0,1,4,5,7}$ 转换为主合取范式；</p>
<p>e.g.2, 将 合取范式$P\vee Q$ 转换为析取范式；</p>
</blockquote>
</li>
<li><p>证明推理公式：例题略</p>
</li>
<li><p>判断推理式是否正确：<strong>从重言蕴含化为蕴含运算，看是否为永真式</strong>；</p>
</li>
<li><p>自然语言到命题公式的形式化和证明</p>
<p>⚠<strong>极易出错点：只有……才、除非……否则、或者……或者的形式化</strong></p>
<ul>
<li>“只有P-才Q”：只有满足P，才满足Q，<strong>言外之意，P 是 Q 的必要不充分条件！（如果不满足P，那么并不影响 Q）</strong>，所以翻译为：$Q\rightarrow P$；</li>
<li>“除非P-否则Q”：等价于只有满足 $P$，才满足 $\neg Q$，所以翻译为 $\neg Q\rightarrow P$；</li>
<li>“或者P-或者Q”：<strong>有两种理解方式：可兼得或、不可兼得或</strong>，视语境而定；可兼得或，和“……可以，……也可以”的意义相同，这个时候翻译成 $P\vee Q$；不可兼得或，和“要么……要么……”的意义相同，这个时候翻译成 $P\oplus Q=P\wedge\neg Q\vee\neg P\wedge Q$；</li>
</ul>
</li>
</ul>
<h3 id="1-4-错题"><a href="#1-4-错题" class="headerlink" title="1.4 错题"></a>1.4 错题</h3><ul>
<li><p>形式化语句：如果水是清的，那么或者张三能见到池底或者他是个近视眼；</p>
<p><strong>错因：读题问题</strong></p>
<p><strong>“或者……或者……”在这里是不可兼得或，表示“要么……要么……”</strong></p>
<blockquote>
<p>设 P: 水清；Q: 张三能见池底；R: 张三是近视眼；</p>
<p>$P\rightarrow(Q\wedge\overline{R}\vee\overline{Q}\wedge R)$</p>
</blockquote>
</li>
<li><p>将公式写为波兰表达式、逆波兰表达式：$P\rightarrow Q\vee R\vee S$、$\neg\neg P\vee(W\wedge R)\vee\neg Q$、$P\wedge\neg R\leftrightarrow P\vee R$；</p>
<p><strong>错因：运算符优先级判断错误（$\neg\gt\wedge\gt\vee\gt\rightarrow\gt\leftrightarrow$）</strong></p>
<p>$\rightarrow P\vee\vee QRS$、$PQR\vee S\vee$、$\leftrightarrow \wedge P\space\neg R\vee P Q$（其他略）</p>
</li>
</ul>
<h2 id="Chapter-2-谓词逻辑（一阶）"><a href="#Chapter-2-谓词逻辑（一阶）" class="headerlink" title="Chapter 2 谓词逻辑（一阶）"></a>Chapter 2 谓词逻辑（一阶）</h2><blockquote>
<p>将原子命题进一步分析为<strong>个体</strong>和<strong>谓词</strong>；</p>
</blockquote>
<h3 id="2-1-重要概念集合"><a href="#2-1-重要概念集合" class="headerlink" title="2.1 重要概念集合"></a>2.1 重要概念集合</h3><ul>
<li><p>个体：可以指具体/抽象的独立存在的对象；</p>
<blockquote>
<p>如：字母R，XX公司，1，2，-1，张三等；</p>
</blockquote>
</li>
<li><p>个体域：由个体组成的集合；</p>
<p>全总个体域：所有个体聚合在一起所组成的集合；</p>
</li>
<li><p>个体变元：以某个个体域 I 中的个体为变域的变元，称为<strong>个体域 I 上的个体变元</strong>；</p>
</li>
<li><p>谓词：个体、命题所具有的性质，或者若干个体、若干命题之间的关系；</p>
<ul>
<li>一元谓词：指明个体/命题的性质；</li>
<li>二元谓词：指明两个个体/一个个体和一个命题间的关系；</li>
</ul>
<p><strong>谓词实际上是一个以个体/命题（目前仅讨论以个体为变域的一阶谓词）为变域、命题为值的函数</strong>；</p>
<blockquote>
<p>真值函数是个以命题为变目、命题为值的函数，所以也是谓词；（真值联结词同理）</p>
</blockquote>
<p>⚠<strong>注意：谓词与个体域紧密相关，例如一元谓词”是质数“相对于自然数域而言</strong>；</p>
</li>
<li><p>谓词变元：以谓词为变域的变元；</p>
<blockquote>
<p>约定：小写字母为（pqr）命题变元、大写字母（PQR）为命题、小写字母（abc）为个体变元、大写字母（ABC）为特定谓词、大写字母（XYZ）为谓词变元；</p>
</blockquote>
</li>
<li><p>谓词填式：将谓词后面填以<strong>个体变元</strong>所得的式子；</p>
<blockquote>
<p>谓词和谓词填式是两个完全不同的概念；</p>
</blockquote>
</li>
<li><p>命名变元：为了了解谓词的元数，一般在谓词后写<strong>命名变元</strong>来说明元数（类似函数形参）；</p>
</li>
<li><p>谓词命名式：谓词后填以<strong>命名变元</strong>的式子（类似函数声明）；</p>
<blockquote>
<p><strong>谓词命名式 等价于 谓词</strong>，所以谓词命名式和谓词填式完全不同；</p>
</blockquote>
</li>
<li><p>谓词的严格定义：以某个个体域 I 为定义域，以真假为值域的谓词，称为<strong>个体域 I 上的谓词</strong>；</p>
<p>谓词变元的严格定义：以个体域 I 上的谓词为变域的变元，称为<strong>个体域 I 上的谓词变元</strong>；</p>
<p><strong>结论：k 个个体组成的个体域 I 上的 m 元谓词共有 $2^{k^m}$ 个</strong>；</p>
</li>
<li><p>量词：仅有个体、谓词，还是无法描述一些问题—-&gt;<strong>措施：使用新的变元 + 约定新的变元的个体域 + 规定新的变元的性质 来处理</strong></p>
<p>新的变元：</p>
<ul>
<li>全称性变元：表示<strong>任意一个</strong>的变元，都称~；</li>
<li>存在性变元：表示<strong>确定的一个，但现在可能不知道/无需指明的一个</strong>，都称~；</li>
</ul>
<p>引入谓词约束新的个体域：</p>
<ul>
<li><p>谓词配合全称性量词+蕴含前件约束：</p>
<blockquote>
<p>所有实数，要么大于0，要么小于0，要么等于0</p>
<p>$Ay\rightarrow(y\gt0\vee y=0\vee y\lt 0)$，y是<strong>以全总个体域为变域的全称性变元</strong>，A表”是实数“；</p>
</blockquote>
</li>
<li><p>谓词配合存在性量词+合取约束：</p>
<blockquote>
<p>一个中国人来了（Ae表示e来了）</p>
<p>$Bu\wedge Au$，u是<strong>以全总个体域为变域的存在性变元</strong>，B表”是中国人“；</p>
</blockquote>
</li>
</ul>
<p>引入<strong>量词</strong>规定新的变元的性质：$\forall x$（全称量词）、$\exists x$（存在量词）；</p>
</li>
<li><p>细小概念：对两种公式：$\forall x\alpha(x),\space\exists x\alpha(x)$</p>
<ul>
<li>$\forall x、\exists x$ 中的 x 是相应量词的<strong>指导变元</strong>；</li>
<li>$\alpha(x)$ 为相应量词的<strong>作用域（或辖域）</strong>；</li>
<li>在作用域中，但不与指导变元同名的其他变元称为<strong>参数</strong>；</li>
</ul>
</li>
<li><p><strong>谓词演算公式（定义和主流教材不一样！有争议，应该不考定义，这里写主流教材的）</strong>：由命题变元、谓词填式利用真值联结词和量词作成的如下式子：</p>
<ul>
<li>命题公式是公式；</li>
<li>填以个体变元的谓词填式也是公式；</li>
<li>公式的否定是公式；</li>
<li>两个公式的合取、析取、蕴含、等价也是公式；</li>
<li>若 α 是公式，x 是个体变元，则 $\forall x\alpha,\space\exists x\alpha$ 也是公式；</li>
</ul>
<blockquote>
<p>提示，本教程中不主流，认为$\forall xF(x)\wedge G(x)$ 不是公式；</p>
</blockquote>
</li>
<li><p>自由出现和约束出现：设 α 为一个谓词演算公式，Qxβ是 α 的一个子公式（Q为量词的一种，x 为变元，β 为公式），则在Qxβ 中：变元 x 的一切出现都称为 x 在 α 中的<strong>约束出现</strong>；而 α 中的 x 除了约束出现以外的一切出现都称 x 在 α 中的<strong>自由出现</strong>；</p>
<blockquote>
<p>$\forall x((Xxy\wedge\exists yYy)\rightarrow\exists y(\overline{X}xy\leftrightarrow\exists y\overline{X}y))$中，</p>
<p>第一个 y 是公式中 y 的自由出现，第2、3、4、5、6、7都是公式中 y 的约束出现；</p>
</blockquote>
</li>
<li><p>约束关系：各个量词和变元的出现间的约束上的关系；</p>
<p>确定约束关系的过程：确定”公式中哪个变元的哪些出现受哪个量词的约束“的过程；</p>
</li>
<li><p>自由变元、约束变元；</p>
<p><strong>同一变元在一个公式中可能既是自由变元，又是约束变元</strong>；</p>
<p><strong>在一阶谓词逻辑中，认为命题变元、谓词变元都是自由变元，不受量词约束</strong>；</p>
</li>
<li><p>改名：将一个变元改为另一个变元，并要求改名后的式子与原来的式子语义相同</p>
<ul>
<li>改名<strong>针对约束变元</strong>而言，不能对自由变元改名；</li>
<li>改名必须同时对原式中该变元的一切受<strong>某个量词约束</strong>的约束出现<strong>均</strong>改名（<strong>同约束全替换</strong>）；</li>
<li>改名后的名字不允许和作用域中其他自由变元同名；（会改变约束关系）</li>
<li>改名后，<strong>一般</strong>不与作用域中约束变元同名，因为容易混；</li>
</ul>
</li>
<li><p>代入：将一个变元代以式子（式子的变域与变元变域要相同），要求代入后的式子是原式的特例；（不要求等值）</p>
<ul>
<li>代入<strong>针对自由变元</strong>而言，约束变元不允许代入；</li>
<li>代入式当中的变量名不能与原式作用域中的约束变量同名；</li>
<li>同一自由变元出现<strong>全部替换</strong>；</li>
</ul>
<blockquote>
<p>可以的：命题变元代入公式、个体变元代入项、谓词变元代入同元谓词；</p>
</blockquote>
</li>
</ul>
<p><strong>总结：1、只要没改变约束关系的、不引发歧义的改名、代入都行；</strong></p>
<p>​            <strong>2、要改全改，要代全代</strong>；</p>
<blockquote>
<p>$\forall y(p\rightarrow Ay)$ 可以将 p（命题变元）代入为 $\exists yBxy$，因为没有歧义、没有改变约束关系；</p>
</blockquote>
<p>​    <strong>一个公式的关系</strong></p>
<ul>
<li><p>谓词演算公式的永真性、可满足性</p>
<p>【POINT 1】<strong>谓词演算公式的真假与：个体域、自由变元（自由个体变元、谓词变元、命题变元）有关</strong>，和约束变元无关；</p>
<ul>
<li><p>谓词演算公式的成真指派、成假指派、有缺指派</p>
<p>一个一阶谓词演算公式 α，其自由个体变元 $x_1,x_2,…,x_h$，命题变元 $p_1,p_2,…,p_k$，谓词变元 $X_1,X_2,…,X_r$，则将 α 表示为：$\alpha(x_1,x_2,…,x_h;\space p_1,p_2,…,p_k;\space X_1,X_2,…,X_r)$；</p>
<p>若对其个体域 $I$ 的指派为 $I_0$（约束变元的全总个体域也变为 $I_0$），</p>
<p>对  $x_1,x_2,…,x_h$ 指派为： $\alpha_1,\alpha_2,…,\alpha_h$ 、对 $p_1,p_2,…,p_k$ 指派为 $p_1^0,p_2^0,…,p_k^0$、对  $X_1,X_2,…,X_r$ 指派为 $A_1,A_2,…,A_r$，则称对 α 作一个个体域 $I_0$ 上的指派 $(\alpha_1,\alpha_2,…,\alpha_h;\space p_1^0,p_2^0,…,p_k^0;\space A_1,A_2,…,A_r)$；</p>
<p><strong>在一个确定的个体域、自由个体变元、命题变元、谓词变元的指派下，公式 α 的真假值确定</strong>；</p>
<p>若该指派下公式的值为真，则称为成真指派，否则为成假指派；</p>
<p>若仅对 α 中的部分自由变元指派，则称该指派为 α 的一个有缺指派（有缺指派下公式不一定有确定的真假值）；</p>
</li>
</ul>
<p>【POINT 2】谓词演算公式的真假值确定的<strong>关键</strong>在于<strong>确定 $\forall x\alpha(x)$ 和 $\exists x \alpha(x)$ 的真假</strong>；</p>
<blockquote>
<p> $\forall x\alpha(x)$ 为真，当且仅当 I 中每个个体都使公式为真；</p>
<p> $\exists x \alpha(x)$ 为真，当且仅当 I 中至少有一个个体使公式为真；</p>
</blockquote>
<ul>
<li><p><strong>永真性（普遍有效性）、可满足性</strong>：若公式 α 对于个体域 I 中任何指派均取真值，则称 α 在 I 中永真；若 α 在每一个非空个体域中均永真，则称 α <strong>永真（普遍有效公式）</strong>；</p>
<blockquote>
<ol>
<li>可满足性的定义同理；</li>
<li>此处许多定理，例如 α、β 同真假 $\Longleftrightarrow$ α $\leftrightarrow$ β 永真，和命题逻辑类似，略去；</li>
</ol>
</blockquote>
<p><strong>重要定理：有限域上，公式的永真性、可满足性仅取决于个体域中的个体数</strong>；</p>
<blockquote>
<p>感性理解：如果公式的永真性取决于个体域中的不同个体的<strong>特征</strong>的话，那么就不是永真了；</p>
</blockquote>
<p>因此，将 $\{1,2,3,…,k\}$ 作为具有 k 个个体的个体域的代表（仅与数量有关，所以元素是啥都行），命名为 “k-域”，α 在 k 域上永真称为<strong>k-永真</strong>；</p>
</li>
<li><p>同永真性、同可满足性：α 永真当且仅当 β 永真，则称 α、β <strong>同永真性</strong>；</p>
</li>
</ul>
</li>
<li><p>有限域下的公式表示法：有限域 $D=\{1,2,3,…,k\}$ 不失一般性；</p>
</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
&\forall xP(x)=P(1)\wedge P(2)\wedge\cdots\wedge P(k)\\
&\exists xP(x)=P(1)\vee P(2)\vee\cdots\vee P(k)
\end{aligned}</script><blockquote>
<p><strong>当发现某些谓词演算公式难以理解时，尝试在 {1, 2} 域下展开</strong>；</p>
</blockquote>
<ul>
<li><p>全称封闭式、存在封闭式：将公式中的一切自由个体变元，构造出对应的全称量词并置于全式之前，则称得到的新公式为 α 的全称封闭式，记作$\Delta\alpha$；（存在封闭式同理）</p>
<p><strong>重要定理：α 与它的全称封闭式在每个域中同永真性、与它的存在封闭式在每个域中同可满足性</strong>；</p>
<blockquote>
<p>感性理解：一个公式一旦确定为永真，那么他的所有自由个体变元的所有取值都不影响它的真，所以它的全称封闭式也为真；</p>
</blockquote>
<p><strong>引入存在封闭式，可以将公理50 $\Delta(\forall x\alpha(x)\rightarrow\alpha(\xi))$、公理51 $\Delta(\alpha(\xi)\rightarrow\exists x\alpha(x))$ 没有歧义地表述，不容易造成误解和错用</strong>；</p>
</li>
</ul>
<p>​    <strong>两个公式的关系</strong></p>
<ul>
<li><p>谓词演算公式的同真假性、在 I 上同真假性（或者说<strong>等值</strong>）：设有公式 α、β，若对个体域 I 的每一指派，α、β 均取相同真假值，则称 α、β <strong>在 I 上同真假</strong>；若 α、β 在每个非空域上同真假，则称二者<strong>同真假</strong>；</p>
<p><strong>谓词演算公式同真假公式记忆：</strong></p>
<ul>
<li><p>$\overline{\forall}x\alpha(x)=\exists x\overline\alpha(x)$、$\overline{\exists}x\alpha(x)=\forall x\overline\alpha(x)$；（<strong>量词否定的同真假变换</strong>）</p>
</li>
<li><p>$\overline\forall x\exists y\alpha(x)=\exists x\forall y\overline\alpha(x)$（<strong>对多个量词的否定同真假变换，多少个量词都一样</strong>）</p>
</li>
<li><p>$\forall x(\alpha(x)\vee\gamma)=\forall x\alpha(x)\vee\gamma$、$\forall x(\alpha(x)\wedge\gamma)=\forall x\alpha(x)\wedge\gamma$</p>
<p>$\exists x(\alpha(x)\vee\gamma)=\exists x\alpha(x)\vee\gamma$、$\exists x(\alpha(x)\wedge\gamma)=\exists x\alpha(x)\wedge\gamma$；（<strong>量词与”自由公式“的结合律</strong>）</p>
<p>（γ 为<strong>不含自由变元 x </strong>的公式）</p>
<p><strong>请注意：如果涉及蕴含符号，请自行推导，结论是不同的！</strong></p>
</li>
</ul>
<p><strong>第二组重要的等值公式：相关约束分配律</strong></p>
<ul>
<li><p>$\forall x(P(x)\wedge Q(x))=\forall xP(x)\wedge\forall xQ(x)$</p>
<p>$\exists x(P(x)\vee Q(x))=\exists xP(x)\vee\exists xQ(x)$</p>
<p><strong>分开个体不必相同，原因在于：理解为有限域下公式表示，是否展开为连续的 $\wedge$ 和 $\vee$</strong>；</p>
</li>
<li><p>$(\forall x)P(x)\vee(\forall x)Q(x)=\forall x\forall y(P(x)\vee Q(y))$</p>
<p>$(\exists x)P(x)\wedge(\exists x)Q(x)=\exists x\exists y(P(x)\wedge Q(y))$</p>
<p><span id="diff"><strong>分开不一定相同，一般情况是 $(\forall x)P(x)\vee(\forall x)Q(x)$、$\exists x(P(x)\wedge Q(x))$ 更强一些：</strong></span></p>
<p>$\forall xP(x)\vee \forall xQ(x)\Rightarrow \forall x(P(x)\vee Q(x))$</p>
<p>$\exists x(P(x)\wedge Q(x))\Rightarrow\exists xP(x)\wedge\exists xQ(x)$</p>
<p>记忆方法可以采用<strong>“唱歌跳舞解释法”</strong>：例如，班里所有人都会唱歌 或 班里所有人都会跳舞 <strong>强于</strong> 班里所有人都会唱歌或跳舞（因为可能恰好一部分人只会唱歌、另一部分人只会跳舞，这样满足后者，却不满足前者）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>前束型公式、准前束型公式：一个公式的量词都在开头，它们的作用域延伸到全式的末尾，称这样的公式为<strong>前束型公式</strong>；由前束型公式利用真值联结词作成的公式称为<strong>准前束型公式</strong>；</p>
<blockquote>
<p>$\forall x\exists y\forall z(Xxy\rightarrow Yyz)$ 为前束型公式，$\forall x\exists yXxy\wedge\forall y\exists zYyz$ 为准前束型公式；</p>
</blockquote>
</li>
<li><p><strong>前束范式定理：任何一个谓词演算公式都与一个前束型公式同真假（称此前束型公式为前束范式）</strong></p>
<blockquote>
<p><strong>前束范式不唯一！</strong></p>
</blockquote>
<p>⚠<strong>完全不建议、甚至禁止将蕴含词、等价词留在式中，因为考虑否定深入，需要将这些属性的词展开，有时甚至不展开是错误的！因为量词在进出这些运算符时可能多了一层否定</strong></p>
<p><strong>将公式转化为前束范式的思路：</strong></p>
<p>step 1. 否定深入，将量词上的否定转移到作用域内部（利用前面两条同真假公式）；</p>
<p>step 2. 适当改名：规避将量词提出时的重名错误；（考虑约束关系会不会在提出后有歧义或改变）</p>
<p>step 3. 根据同真假公式，依此提出内层的量词开头的公式；</p>
</li>
<li><p>Skolem 标准型：一阶谓词逻辑的任一公式 α，若：</p>
<ol>
<li>其前束范式中所有的存在量词都在全称量词的左边（<strong>$\exists$ 前束范式</strong>），</li>
<li>或者，仅保留全称量词而消去存在量词（<strong>$\forall$ 前束范式</strong>）</li>
</ol>
<p>则得到的 α 的新公式称为 <strong>skolem 标准型</strong>；</p>
<p>⚠<strong>skolem 标准型一定无法像前束范式一样，与原式保持完全等值的关系，只能保持一定意义上的“关系”</strong></p>
<ul>
<li><p>$\exists$ 前束范式：$\exists x_1\exists x_2\cdots\exists x_i\forall x_{i+1}\cdots\forall x_nM(x_1,x_2,…,x_n)$，保证 i ≥ 1且 M 内<strong>不含量词和自由个体变元</strong>；</p>
<p><strong>$\exists$ 前束范式定理：FOL（一阶谓词逻辑）的任一公式 α 都能写成与之对应的（不一定等值）$\exists$ 前束范式，且 <u>α 和 其 $\exists$ 前束范式同永真性</u></strong></p>
<blockquote>
<p>所以 一般当 α 永真时，或者想要进行<strong>同永真转换</strong>时，才使用 $\exists$ 前束范式；</p>
</blockquote>
</li>
<li><p>$\forall$ 前束范式：仅保留全称量词的前束范式</p>
<p><strong>$\forall$ 前束范式定理：FOL 的任一公式 α 都能写成与之对应的（不一定等值）$\forall$ 前束范式，且 <u>α 和 其 $\forall$ 前束范式同可满足性</u></strong></p>
<blockquote>
<p>所以 一般当 α 永假时，或者想要进行<strong>同不可满足转换（通常是谓词演算公式的归结推理）</strong>时，才使用 $\forall$ 前束范式；</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-谓词演算公式的推理演算"><a href="#2-2-谓词演算公式的推理演算" class="headerlink" title="2.2 谓词演算公式的推理演算"></a>2.2 谓词演算公式的推理演算</h3><ul>
<li><p>较之命题演算新增 4 个规则：</p>
<ol>
<li><p>全称量词消去（公理50）${\forall xP(x)}\over{\therefore\space P(y)}$ 和 ${\forall xP(x)}\over{\therefore\space P(c)}$</p>
<ul>
<li>要求取代的自由变元不能在原式中约束出现（否则改变约束关系，这个一般不会违反）</li>
<li>必须取代所有的 该变元（消去全称量词的指导变元对应的变元，一般也不会违反）</li>
</ul>
<blockquote>
<p>提示：全称量词的消去有两种使用方法，一种是左边的消去为全域的自由变量 y，另一种是消去为个体常量 c； </p>
</blockquote>
</li>
<li><p>全称量词引入（全“0”规则）${P(y)}\over{\therefore\space\forall xP(x)}$</p>
<ul>
<li><p><strong>要求左式 $P(y)$ 中的 y 是使公式为真的<u>自由个体变元</u></strong></p>
<blockquote>
<p>具体是要求查找前面所有<strong>假设</strong>中，y 是否自由出现，如果是，一定<strong>不满足</strong>这个条件；</p>
</blockquote>
</li>
<li><p>取代 y 的 x 约束变元不能在 P(y) 中约束出现（否则改变约束关系，这个一般不违反）</p>
</li>
</ul>
</li>
<li><p>存在量词消去（<strong>存在假设</strong>）${\exists xP(x)}\over{\therefore\space P(e)}$</p>
<ul>
<li>要求右式的 e 必须是使公式为真的<strong>个体常项</strong>，不在 P 中出现；</li>
<li>要求 P <strong>不能有自由个体变元</strong>，会导致个体域混淆；</li>
</ul>
</li>
<li><p>存在量词引入（公理51）${P(c)}\over{\therefore\space\exists xP(x)}$</p>
<ul>
<li>要求个体常项 c 不在 P 中其他地方出现；</li>
</ul>
</li>
</ol>
</li>
<li><p>归结推理：在命题逻辑处理的基础上，将“同不可满足公式”转换为 $\forall$ 前束范式，略去全称量词、$\wedge$ 以逗号相连，构成子句集，归结方法：<strong>$R(x)\vee Q(x)$ 和 $\overline R(a)\vee P(y)$ 归结为 $Q(a)\vee P(y)$</strong>（不是x 的原因是：在子句集中，看起来是自由变元的都是全称变元），直至空子句；</p>
<p><strong>为了方便起见，一般不完全写出 $\forall$ 前束范式，而是对由合取联结的几个部分分别求子句集，最后求并集；</strong>虽然与原子句集不一样，但它们的可满足性是一致的；</p>
</li>
<li><p>推理小结论</p>
<ul>
<li><p><a href="#diff">相关约束分配律的大小关系🔗</a></p>
</li>
<li><p>$\forall x\forall yP(x,y)$ 强于 $\exists x\forall yP(x,y)$ 强于 $\forall x\exists yP(x,y)$ 强于 $\exists x\exists yP(x,y)$</p>
</li>
<li><p>一般情况下，量词<strong>一定不具备对于等价词的分配律</strong>：因为将等价词拆为双向蕴含词的合取，如果要分配，就意味着同时对 析取、合取 两种运算分配，这无论是全称量词还是存在量词都是不可接受的；</p>
<blockquote>
<p>例如：$\exists x(P(x)\leftrightarrow Q(x))\rightarrow(\exists xP(x)\leftrightarrow\exists xQ(x))$ 不是普遍有效的；</p>
<p>可以将 $P(x)\leftrightarrow Q(x)$ 拆开成 $(P(x)\rightarrow Q(x))\wedge(Q(x)\rightarrow P(x))$ 理解；</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-常见题型"><a href="#2-3-常见题型" class="headerlink" title="2.3 常见题型"></a>2.3 常见题型</h3><ul>
<li><p>自然语言的形式化</p>
<p><strong>注意：如果语句中含有“不”或者其他否定的字样，建议将其提出谓词的定义中，例如：</strong></p>
<blockquote>
<p>“Qe：e 溶于水” 的定义好于：“Qe：e 不溶于水”</p>
</blockquote>
</li>
<li><p>谓词演算公式的改名和代入</p>
</li>
<li><p>给定一个指派，求谓词演算公式的真假值</p>
<p>step 1. 初步代入指派（尽可能代入谓词变元、命题变元、自由个体变元）；</p>
<p>step 2. <strong>由内向外</strong>逐层求<strong>由量词带头的</strong>子公式的值；<strong>如果不能求出，则转化为同一语境下同真假的式子</strong></p>
<blockquote>
<p>在子公式内部，应该将与指导变元不同的变元暂时视作自由变元；</p>
</blockquote>
<p>step 3. 遇到多个量词和指导变元针对一个作用域时，按照<strong>从左至右</strong>的顺序理解，不能交换顺序；</p>
</li>
</ul>
<ul>
<li><p>判断公式的永真性（普遍有效性）、可满足性</p>
<blockquote>
<p>但凡公式需要确认自由变元 才能判断真假的，都是仅可满足的；</p>
</blockquote>
<p><strong>只要将公式写出，那么它必然处于：永真性、仅可满足、不可满足（矛盾式）这三者特性之一！</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="rel.jpg" height="200px"></p>
<ul>
<li>想要证伪，则一般在 {1, 2} 域上列表格，“唱歌跳舞分析法”来查看，判断什么条件下能够生成反例，尤其对于蕴含式，设立一个前件正确、后件错误的才行；</li>
<li>想要证明，建议先看看证伪，发现无法证伪再来证明</li>
</ul>
<p>⚠易错点1：有些公式默认了自由变元的全总个体域：$\forall xP(x)\rightarrow P(y)$ 是普遍有效公式；</p>
<p>⚠易错点2：有些公式没有直接方法化简到 F/T，而且你记得它不是普遍有效公式，也不能直接判断，因为它可能在某些情况下成立，例如：$(\exists x P(x)\wedge\exists xQ(x))\rightarrow\exists x(P(x)\wedge Q(x))$ 是<strong>1-永真</strong>的，所以是可满足公式；</p>
</li>
</ul>
<ul>
<li>拓展：谓词演算公式的可判定性（<strong>针对一个演算系统而言，并非是对一个公式而言</strong>）</li>
</ul>
<ul>
<li><p>求公式对应的前束范式</p>
</li>
<li><p>求公式对应的 $\forall$ 前束范式 / $\exists$ 前束范式</p>
<blockquote>
<p>考试时注意：<strong>本教材（非主流）中除非强调，默认“skolem标准型”就是 $\forall$ 前束范式，不指 $\exists$ 前束范式</strong>；</p>
</blockquote>
<p><strong>转换为 $\exists$ 前束范式的基本思路：</strong></p>
<ol>
<li><p>将公式转换为前束范式；</p>
</li>
<li><p>以 $\exists x_1\exists x_2\cdots\exists x_i\forall x_{i+1}\exists x_{i+2}\cdots\exists x_nM(x_1,x_2,…,x_n)$ 为例（因为都可以转化为：存在量词中间夹一个全称量词的情况）：</p>
<p>引入 $\forall x_{i+1}$ 前的所有指导变元（<strong>默认从左到右消除全称量词</strong>），包括自己，作为新的谓词（没有出现过）的填式：$S(x_1,x_2,…,x_i,x_{i+1})$ ，其中 S 是自由变元，可以取个体域上所有谓词；这样：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\exists x_1\exists x_2\cdots\exists x_i\forall x_{i+1}\exists x_{i+2}\cdots\exists x_nM(x_1,x_2,...,x_n)\\
=&\exists x_1\exists x_2\cdots\exists x_i\exists x_{i+1}\exists x_{i+2}\cdots\exists x_n(M(x_1,x_2,...,x_n)\wedge\overline S(x_1,x_2,...,x_{i+1})\vee\forall yS(x_1,x_2,...,x_i,y))\\
=&\exists x_1\exists x_2\cdots\exists x_i\exists x_{i+1}\exists x_{i+2}\cdots\exists x_n\forall y(M(x_1,...,x_n)\wedge\overline S(x_1,...,x_{i+1})\vee S(x_1,...,x_i,y))
\end{aligned}</script></li>
<li><p>如上面公式的最后一步，将任意的 y 利用结合律提出，循环此过程直至变为  $\exists$ 前束范式；</p>
</li>
</ol>
<p><strong>转换为 $\forall$ 前束范式的基本思路：</strong></p>
<ol>
<li>将公式转换为前束范式；</li>
<li>以 $\forall x_1\forall x_2\cdots\forall x_i\exists x_{i+1}\forall x_{i+2}\cdots\forall x_nM(x_1,x_2,…,x_n)$ 为例，因为都可以转化为：全称量词中间夹一个存在量词的情况）：<ul>
<li>如果 $x_{i+1}$ 左边没有（全称）量词（<strong>也默认从左到右消除</strong>），即 i = 0，那么只要在作用域中将所有 $x_{i+1}$ （一定是自由出现）代以一个从未出现的自由变元名，例如 y：$M(y,x_2,…,x_n)$，直接删除 $\exists x_{i+1}$ 即可；</li>
<li>如果 $x_{i+1}$ 左边有（全称）量词，则将 $x_{i+1}$ <strong>替换为</strong>左边出现的所有全称量词指导变元构成的自由变元-函词填式（从未出现过该名字，例如 f）：$f(x_1,x_2,…,x_i)$，构成：$M(x_1,x_2,…,x_i ,f(x_1,x_2,…,x_i),x_{i+2},…,x_n)$​，直接删除 $\exists x_{i+1}$ 即可；</li>
</ul>
</li>
<li>循环上面的过程直至变为  $\forall$ 前束范式；</li>
</ol>
</li>
</ul>
<ul>
<li><p>分析谓词演算公式证明的正确性</p>
</li>
<li><p>谓词演算公式的推理证明</p>
<blockquote>
<p>推理中如果使用到了推理结论，例如：$P(x)\wedge Q(x)\Rightarrow P(x)$，在原因一栏写“重言蕴含”，这对于<strong>命题逻辑</strong>的推理也是这样的！</p>
</blockquote>
</li>
</ul>
<h2 id="Chapter-3-集合论"><a href="#Chapter-3-集合论" class="headerlink" title="Chapter 3 集合论"></a>Chapter 3 集合论</h2><h3 id="3-1-重要概念集合"><a href="#3-1-重要概念集合" class="headerlink" title="3.1 重要概念集合"></a>3.1 重要概念集合</h3><ul>
<li><p>集合定义（确定性、互异性、无序性）、属于不属于定义；</p>
</li>
<li><p>⚠集合元素不能是其自身（罗素悖论）=&gt; 抽象公理错误，不能任给一个性质就能构造一个对应的集合；</p>
</li>
<li><p>集合表示法：字母约定、外延表示法（穷举）、内涵表示法（谓词描述性质）；</p>
</li>
<li><p>集合间的关系</p>
<ul>
<li><strong>外延公理：一个集合由它的元素完全确定</strong>；</li>
<li>相等关系：由外延公理可以写出定义，下略；</li>
<li><p>子集（包含关系）、否定包含关系、真子集（真包含关系）；</p>
<ul>
<li><strong>相等包含定理（证明两集合相等时常用）：$A=B\Longleftrightarrow(A\subseteq B)\wedge(B\subseteq A)$</strong>；</li>
<li>包含关系的三条性质：自反、反对称、传递；（属于关系没有传递的性质）</li>
</ul>
</li>
<li><p>相交关系：两集合是否有公共元素；没有称<strong>不相交的</strong>；</p>
</li>
</ul>
</li>
<li><p>特殊集合</p>
<ul>
<li>空集：不含任何元素的集合，记 $\phi$；<ul>
<li>性质1：包含于<strong>任意集合</strong>；</li>
<li>性质2：<strong>空集的唯一性</strong>（外延定理说明）；</li>
</ul>
</li>
<li>全集：在<strong>给定的问题</strong>中，所考虑所有事物的集合；</li>
</ul>
</li>
<li><p>集合运算</p>
<ul>
<li><p>并集、交集、差集（“差集”相对于“被差集”的相对补集）、余集（高中的“补集”）、对称差集（异或）；</p>
</li>
<li><p>广义交集、广义并集（<strong>针对集合的元素全是集合的集合</strong>）；</p>
<blockquote>
<p>规定 $\bigcup\phi=\phi$，$\bigcap\phi$ 没有意义；</p>
</blockquote>
</li>
<li><p>幂集：集合的幂集是该集合所有子集组成的集合，记 $P(A)$</p>
<ul>
<li>性质1：幂集的元素全部是集合，无论 A 有没有元素；</li>
<li>性质2：$\phi\in P(A)$、$A\in P(A)$；</li>
</ul>
</li>
<li><p>笛卡尔积</p>
<blockquote>
<p>定义“有序对”：两个元素 x、y（允许 x = y）按给定次序排列组成的二元组合称为一个~；</p>
<p><strong>有序对的集合定义：$\langle x,y\rangle=\{\{x\},\{x,y\}\}$</strong>；</p>
<p>有序对性质定理：</p>
<p>$x\ne y\space\Rightarrow\space\langle x,y\rangle\ne\langle y,x\rangle$</p>
<p>$\langle x,y\rangle=\langle u,v\rangle\space\Rightarrow\space x=u\wedge y=u$</p>
</blockquote>
<p>定义：集合 A 与 B 的笛卡尔积 $A\times B=\{z\space|\space x\in A\wedge y\in B\wedge z=\langle x,y\rangle\}$；</p>
<blockquote>
<p>A = B 时，可以写作：$A^2$；</p>
</blockquote>
<p>以上可以推广到 n 维空间；</p>
<p><strong>注意：无论多少阶，都不存在“一个集合中选多个元素作为 n 元组”的情况，参考坐标点</strong>；</p>
</li>
</ul>
</li>
<li><p>运算符优先级：大致是 <strong>集合运算符＞真值联结词＞逻辑关系符</strong>；</p>
</li>
<li><p>集合的图形表示法：韦恩图（交并补）、哈斯图（幂集）、笛卡尔坐标系图示法；</p>
</li>
<li><p><strong>集合重要运算性质（记忆）</strong></p>
<ul>
<li><p>运算律：基本运算由联结词定义，所以性质相似，此处仅补充少见的运算律</p>
<script type="math/tex; mode=display">
A-(B\cup C)=(A-B)\cap(A-C)\\
A-(B\cap C)=(A-B)\cup(A-C)</script></li>
<li><p>运算性质：以差集为例</p>
<script type="math/tex; mode=display">
\begin{aligned}
A-B&=A-(A\cap B)\\
A\cap(B-C)&=(A\cap B)-C\\
A-B&=A\cap-B
\end{aligned}</script><p><strong>最后一条极其重要，常用于差集运算符消去</strong>；</p>
</li>
<li><p>基本关系运算性质</p>
<script type="math/tex; mode=display">
A\cup B=B\Longleftrightarrow A\subseteq B\Longleftrightarrow A\cap B=A\Longleftrightarrow A-B=\phi</script><p><strong>最后一步启示我们：在证明式中含有 $\phi$ 时，建议将式中的差运算符留到最后</strong>；</p>
<p>例如证明：$(A-B)\oplus(A-C)=\phi\Longleftrightarrow A-B=A-C$ 的时候；</p>
</li>
<li><p>幂集性质</p>
<ul>
<li>$A\subseteq B\Longleftrightarrow P(A)\subseteq P(B)$；</li>
<li>$A=B\Longleftrightarrow P(A)=P(B)$；</li>
<li>$P(A)\in P(B)\Longrightarrow A\in B$，逆命题不成立（A={Φ}，B=）；</li>
<li>$P(A)\cap P(B)=P(A\cap B)$；</li>
<li>$P(A)\cup P(B)\subseteq P(A\cup B)$；</li>
<li>$P(A-B)\subseteq(P(A)-P(B))\cup\{\phi\}$；</li>
<li>$\bigcup P(A)=A$；（广义并集和幂集互为逆运算）</li>
</ul>
<blockquote>
<p>传递集合的通俗定义：满足以下 2 点的集合是传递集合</p>
<ol>
<li>A 的元素都是集合；</li>
<li>如果有的话，A 的元素的元素都是 A 的元素；</li>
</ol>
<p>外延定理的描述：$A为传递集合\Longleftrightarrow \forall x\forall y((x\in y\wedge y\in A)\rightarrow x\in A)$；</p>
<ul>
<li><strong>性质1：$A为传递集合\Longleftrightarrow A\subseteq P(A)$；</strong></li>
<li><strong>性质2：$A为传递集合\Longleftrightarrow P(A)也为传递集合$；</strong></li>
</ul>
</blockquote>
</li>
<li><p>笛卡尔积性质：不满足交换律、结合律，但满足对 $\cap$ 和 $\cup$ 的分配律；</p>
<ul>
<li>$x\in A,\space y\in A\Rightarrow\langle x,y\rangle\in PP(A)$</li>
<li>$A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C)\Leftrightarrow(C\times A\subseteq C\times B),\space where\space C\ne\phi$</li>
<li>$(A\times B\subseteq C\times D)\Leftrightarrow(A\subseteq C\wedge B\subseteq D),\space where\space A,B,C,D\ne\phi$</li>
</ul>
</li>
</ul>
</li>
<li><p>集合的基数（讨论有限集合）：规定 $|\phi|=0$</p>
</li>
</ul>
<h3 id="3-2-常见题型"><a href="#3-2-常见题型" class="headerlink" title="3.2 常见题型"></a>3.2 常见题型</h3><ul>
<li><p>写出给定集合的幂集</p>
</li>
<li><p>判断传递集合</p>
</li>
<li><p>给实际应用场景，求某个部分的基数</p>
<blockquote>
<p>例如：参加 A 的有 x 人，参加 B 的有 y 人……，有 z 个人同时参加了……，诸如此类；</p>
</blockquote>
<p><strong>思路：Venn 图，或者概率统计的加法公式（把求概率改成求基数即可）：$P(\bigcup\limits_{i=1}^n{A_i})=\sum\limits_{i=1}^nP(A_i)-\sum\limits_{1\le i\le j\le n}P(A_iA_j)+\cdots+(-1)^{n-1}P(A_1A_2\cdots A_n)$</strong>；</p>
</li>
<li><p>以谓词演算公式和集合定理，证明集合公式</p>
<p><strong>技巧总结</strong></p>
<ul>
<li><p>过于基本的式子，比如用三段论一步解决的：$A\in B\wedge B\subseteq C\Rightarrow A\in C$；</p>
<blockquote>
<p>建议直接推，如果需要改成谓词，就该，例如上面的题目的证明：</p>
<p>$A\in B\wedge B\subseteq C\Leftrightarrow A\in B\wedge\forall x(x\in B\rightarrow x\in C)\Rightarrow A\in C$；</p>
</blockquote>
</li>
<li><p>对于非定理式的、基本运算式的证明，一般采用：</p>
<ol>
<li><strong>等式证明：集合等值记忆式</strong>；</li>
<li>等价证明：集合常用等价关系（<strong>相等-包含关系、基本关系运算性质、幂集的性质</strong>）</li>
<li>重言蕴含证明：集合常用的推导方式（例如：等值运算、<strong>外延定理分解为谓词逻辑</strong>）</li>
</ol>
<p>e.g., 证明以下运算式</p>
<script type="math/tex; mode=display">
\begin{aligned}
&1.\space A\cap(B\oplus C)=(A\cap B)\oplus(A\cap C)\\
&2.\space (A-B)\oplus(A-C)=\phi\Longleftrightarrow A-B=A-C\\
&3.\space A\cup B=A\cup C\space且\space A\cap B=A\cap C\Longrightarrow B=C\\
&4.\space P(A)\in P(B)\Longrightarrow A\in B
\end{aligned}</script></li>
<li><p>对于定理式的证明（上一则技巧无法解决），一般采用：</p>
<ol>
<li>等式 / 重言蕴含的证明：使用外延定理分解为谓词逻辑，记得先声明 $\forall x$ ，从等式左边定义等价 / 重言蕴含推导，中途有必要可以引入新的约束变元，但量词要写在里面；（如果是关于笛卡尔积、二元组的证明，可以写 $\forall \langle x,y\rangle$）</li>
<li>等价证明：一般拆成双侧重言蕴含；如果是较为简单的、一眼看出的，可以一直等价到底；</li>
</ol>
<p>e.g., 证明下列各式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&1.\space A-B=A-(A\cap B)\\
&2.\space A-B=A\cap-B\\
&3.\space A\subseteq B\Longleftrightarrow P(A)\subseteq P(B)\\
&4.\space A为传递集合\Longleftrightarrow P(A)为传递集合
\end{aligned}</script></li>
<li><p>对于仅由集合运算符连接的式子的证明，要么一直使用等价变换，要么使用外延定理定义转化为谓词逻辑证明；</p>
<p>e.g., 证明以下式子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&1.\space P(A)\cup P(B)\subseteq P(A\cup B)\\
&2.\space P(A-B)\subseteq(P(A)-P(B))\cup\{\phi\}
\end{aligned}</script></li>
</ul>
</li>
</ul>
<h3 id="3-3-错题"><a href="#3-3-错题" class="headerlink" title="3.3 错题"></a>3.3 错题</h3><ul>
<li><p>证明：$A\subseteq P(\bigcup A)$</p>
<p><strong>错因：忘记考虑 $A=\phi$ 的情况需要分开讨论</strong>；</p>
</li>
</ul>
<h2 id="Chapter-4-关系"><a href="#Chapter-4-关系" class="headerlink" title="Chapter 4 关系"></a>Chapter 4 关系</h2><h3 id="4-1-重要概念集合"><a href="#4-1-重要概念集合" class="headerlink" title="4.1 重要概念集合"></a>4.1 重要概念集合</h3><ul>
<li><p>二元关系（<strong>有序对的集合</strong>）：若一个集合满足以下两个条件之一：</p>
<ol>
<li>集合非空，且它的元素均为有序对；</li>
<li>集合为空集；</li>
</ol>
<p>则称该集合为一个二元关系；记为 R，简称<strong>关系</strong>；</p>
</li>
<li><p>A 至 B 的二元关系：设 A，B 为集合，则 A × B 的<strong>任一子集</strong>所定义的二元关系，称为 <strong>A 到 B 的二元关系</strong>；</p>
<p>$R\subseteq\{\langle x,y\rangle|\space x\in A\wedge y\in A\}$（可以推广至 n 元关系）</p>
</li>
<li><p>特殊关系</p>
<ul>
<li>恒等关系：$I_A=\{\langle x,x\rangle|\space x\in A\}$</li>
<li>全域关系：$E_A=A\times A$</li>
<li>空关系：$\phi\subseteq A\times A$</li>
</ul>
</li>
<li><p>关系的定义域 $dom(R)$、值域 $ran(R)$、域 $fld(R)$（定义域和值域的并）</p>
</li>
<li><p>关系的表示</p>
<ul>
<li><p>关系矩阵：对于集合 $X=\{x_1,…,x_m\}$，$Y=\{y_1,…,y_n\}$，若 R 为从 X 到 Y 上的一个关系，则 R 的关系矩阵（bool 矩阵）为 $M(R)=(r_{ij})_{m\times n}$（如果有序对 $\langle x,y\rangle$ 在 $X\times Y$ 中，则 $r_{ij}=1$，否则为0）；</p>
<blockquote>
<p>起始集合元素为<strong>行</strong>，目的集合元素为<strong>列</strong>；</p>
</blockquote>
</li>
<li><p>关系图：使用<strong>有向边</strong>表示两个集合元素点的关系；</p>
</li>
</ul>
</li>
<li><p>关系的运算（设 R 为 X 到 Y 的关系，S 为 Y 到 Z 的关系）</p>
<ul>
<li><p>逆：$R^{-1}=\{\langle x,y\rangle|\space \langle y,x\rangle\in R\}$</p>
</li>
<li><p>合成：$S\circ R=\{\langle x,y\rangle|\space \exists z(\langle x,z\rangle\in R\space\wedge\langle z,y\rangle)\in S\}$</p>
<blockquote>
<p>遵循和函数复合一样的含义，内层先运算；</p>
</blockquote>
</li>
<li><p>A 在 R 下的象：$R[A]=\{y\space|\space\exists x(x\in A\space\wedge\langle x,y\rangle\in R)\}$</p>
</li>
<li><p>R 在 A 下的限制：$R\uparrow A=\{\langle x,y\rangle|\space \langle x,y\rangle\in R \wedge x\in A\}$</p>
<blockquote>
<p>象和限制可以理解为生物学上的“<strong>平板影印</strong>”，象是将 存在关系 R 中的元素影印在 A 上，限制是将 存在于 A 中的元素影印到 R 上；没有被影印到的元素就被抛弃；</p>
</blockquote>
</li>
</ul>
<p><strong>补充：关系矩阵和定义的联系：第一部分</strong></p>
<ol>
<li>关系的逆<strong>相当于关系矩阵的转置</strong>：$M(R^{-1})=M^T(R)$</li>
<li>关系的复合<strong>相当于关系矩阵逻辑乘法</strong>：$M(S\circ R)=M(R)\cdot M(S)$</li>
</ol>
</li>
<li><p>关系的运算性质</p>
<ul>
<li><p>逆的性质</p>
<ol>
<li>关系的逆会使定义域和值域对调；</li>
<li>$(R^{-1})^{-1}=R$</li>
<li>$(S\circ R)^{-1}=R^{-1}\circ S^{-1}$</li>
</ol>
</li>
<li><p>关系合成结合律：$(R\circ S)\circ Q=R\circ(S\circ Q)$</p>
<p><strong>关系合成不符合交换律：$R\circ S\ne S\circ R$</strong>；</p>
</li>
<li><p>关系合成对<strong>并运算</strong>满足分配律：</p>
<p>$R_1\circ(R_2\cup R_3)=R_1\circ R_2\cup R_1\circ R_3$</p>
<p>$(R_1\cup R_2)\circ R_3=R_1\circ R_3\cup R_2\circ R_3$</p>
<p><strong>关系合成对 交运算 不满足分配律：</strong></p>
<p>$R_1\circ(R_2\cap R_3)\subseteq R_1\circ R_2\cap R_1\circ R_3$</p>
<p>$(R_1\cap R_2)\circ R_3\subseteq  R_1\circ R_3\cap R_2\circ R_3$</p>
</li>
</ul>
</li>
<li><p>关系的性质（设 R 为集合 A 上的关系）</p>
<p><strong>第一组：自反性</strong></p>
<ul>
<li><p>自反性：$R在A上自反\Longleftrightarrow\forall x(x\in A\rightarrow\langle x,x\rangle\in R)$</p>
<p>反自反性（在有些教材里被称为非自反性）：$R在A上反自反\Longleftrightarrow \forall x(x\in A\rightarrow\langle x,x\rangle\notin R)$</p>
<p>非自反性（不常用）：<strong>即自反性的反面，“不自反的都算非自反”</strong>，下面将不再赘述；</p>
</li>
<li><p><strong>补充：关系矩阵和定义的关系</strong></p>
<ol>
<li>R 自反 当且仅当：M(R) <strong>全部对角线元素=1</strong>；</li>
<li>R 反自反 当且仅当：M(R)<strong>全部对角线元素=0</strong>；</li>
<li>R 非自反 当且仅当：M(R)对角线元素<strong>不全为1</strong>；</li>
</ol>
<blockquote>
<p>注：对于关系图而言，图上有自环；</p>
</blockquote>
</li>
<li><p><strong>自反性的重要结论</strong>：</p>
<ol>
<li><p>$R是自反的\Longleftrightarrow I_A\subseteq R$（反自反可以同理）</p>
</li>
<li><p>$R是自反的\Longleftrightarrow R^{-1}是自反的$</p>
<p>$R_1,\space R_2是自反的\Longleftrightarrow R_1\cup R_2和R_1\cap R_2是自反的$</p>
<p>（反自反完全相同）</p>
</li>
<li><p><strong>$R_1,R_2是自反的\Longleftrightarrow R_1\circ R_2$ </strong>（<strong>反自反不满足这个性质</strong>）</p>
</li>
</ol>
</li>
<li><p>自反关系的 Venn 图</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="reflective.jpg" height="200px"></p>
<p><strong>第二组：对称性</strong></p>
<ul>
<li><p>对称性：$R在A上对称\Longleftrightarrow \forall x\forall y(x,y\in A\rightarrow(xRy\rightarrow yRx))$</p>
<p>反对称性：$R在A上反对称\Longleftrightarrow\forall x\forall y(x,y\in A\rightarrow(xRy\rightarrow\neg yRx))$</p>
<p>非对称性：略；</p>
<blockquote>
<p>反对称性根据题目证明的要求，还可以写成：</p>
<p>$\forall x\forall y(x,y\in A\wedge xRy\wedge yRx\rightarrow x=y)$</p>
<p>$\forall x\forall y(x,y\in A\wedge xRy\wedge x\ne y\rightarrow \neg yRx)$</p>
<p>等</p>
</blockquote>
</li>
<li><p><strong>补充：关系矩阵和定义的关系</strong></p>
<ul>
<li>R 对称 当且仅当：M(R)<strong>为对称阵</strong>；</li>
<li>R 反对称 当且仅当：<strong>M(R) 的所有对称位不同时为1</strong>；（可以同时为0）</li>
<li>R 非对称 当且仅当：M(R) <strong>不为对称阵</strong>；</li>
</ul>
</li>
<li><p><strong>对称性重要结论</strong>：</p>
<ol>
<li><p>$R为对称的\Longleftrightarrow R=R^{-1}$</p>
<p>$R_1,\space R_2是对称的\Longleftrightarrow R_1\cup R_2和R_1\cap R_2是对称的$</p>
</li>
<li><p><strong>反对称有特殊</strong>：$R_1\cup R_2不一定反对称$</p>
<p>$R为反对称\Longrightarrow R\cap R^{-1}\subseteq I_A$</p>
</li>
<li><p><strong>复合运算完全不行！</strong></p>
</li>
</ol>
</li>
<li><p>对称关系的 Venn 图</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="symmetric.jpg" height="200px"></p>
<p><strong>第三组：传递性</strong></p>
<ul>
<li><p>传递性：$R在A上传递\Longleftrightarrow\forall x,y,z\in A(xRy\wedge yRz\rightarrow xRz)$</p>
<p>反传递性：$R在A上反传递\Longleftrightarrow\forall x,y,z\in A(xRy\wedge yRz\rightarrow\neg xRz)$</p>
<p>非传递性：略；</p>
</li>
<li><p><strong>传递性重要性质</strong>：</p>
<ol>
<li>传递性和自反性、对称性一样，满足性质的关系的<strong>逆、交</strong>都是传递的，<strong>但并运算不是</strong>；</li>
<li><strong>复合运算还是不行……</strong></li>
</ol>
</li>
</ul>
</li>
<li><p>关系性质的总结：如果 R 具有对应的关系那么……</p>
<table>
    <tr>
        <td>(是否具有？)</td>
        <td>自反性</td>
        <td>对称性</td>
        <td>传递性</td>
        <td>反自反性</td>
        <td>反对称性</td>
        <td>反传递性</td>
    </tr>
    <tr>
        <td>R的逆关系</td>
        <td>✔</td>
        <td>✔</td>
        <td>✔</td>
        <td>✔</td>
        <td>✔</td>
        <td>✔</td>
    </tr>
    <tr>
        <td>R的并关系</td>
        <td>✔</td>
        <td>✔</td>
        <td>❌</td>
        <td>✔</td>
        <td>❌</td>
        <td>❌</td>
    </tr>
    <tr>
        <td>R的交关系</td>
        <td>✔</td>
        <td>✔</td>
        <td>✔</td>
        <td>✔</td>
        <td>✔</td>
        <td>❌</td>
    </tr>
    <tr>
        <td>R的复合关系</td>
        <td>✔</td>
        <td>❌</td>
        <td>❌</td>
        <td>❌</td>
        <td>❌</td>
        <td>❌</td>
    </tr>
</table>
</li>
<li><p>关系的闭包：某些关系不满足一些性质，为了方便研究，向关系集合中加入<strong>尽可能少的</strong>元素生成一个<strong>满足该性质的超集合</strong>，称为闭包；</p>
<ul>
<li><p>前置性质</p>
<ol>
<li><p>$R^0=I_A$</p>
</li>
<li><p>$R^{n+1}=R^n\circ R,\space R^m\circ R^n=R^{m+n},\space (R^m)^n=R^{mn}$</p>
</li>
<li><p>有限集上关系幂序列的周期性：若存在自然数 s、t 使得：$R^s=R^t$，则：</p>
<p>$R^{s+k}=R^{t+k},\space R^{s+kp+i}=R^{s+i}$</p>
<p>$B=\{R^0,R^1,…,R^{t-1}\}\Rightarrow\forall q\in N,\space R^q\in B$（思考：为何是最大的t？）</p>
</li>
</ol>
</li>
<li><p>闭包定义：设 R 为非空集合 A 上的关系，若 A 上有另一关系 R‘，满足：</p>
<ol>
<li>$R\subseteq R^\prime$（<strong>扩展得来</strong>）</li>
<li>$R^\prime$ 是具有对应性质的（扩展集具有性质）</li>
<li>对 A 上任何具有同样性质的关系 $R^{\prime\prime}$ 有：$R^\prime\subseteq R^{\prime\prime}$（<strong>扩展集最小</strong>）</li>
</ol>
</li>
<li><p>自反闭包记为 $r(R)$，对称闭包记为 $s(R)$，传递闭包记为 $t(R)$</p>
</li>
<li><p>闭包的性质</p>
<ol>
<li><p><strong>已有即当前</strong>：$R为自反的\Longleftrightarrow r(R)=R$（其他同理，下面不再赘述）</p>
</li>
<li><p>不同的关系可能多出“不在扩展中的元素”：$R_1\subseteq R_2\Rightarrow r(R_1)\subseteq r(R_2)$</p>
</li>
<li><p><strong>仅对并运算 + 自反/对称成立分配律</strong>：</p>
<p>$r(R_1)\cup r(R_2)=r(R_1\cup R_2)$</p>
<p>$s(R_1)\cup s(R_2)=s(R_1\cup R_2)$</p>
<p>$t(R_1)\cup t(R_2)\subseteq t(R_1\cup R_2)$</p>
</li>
<li><p><strong>闭包叠加</strong>：自反性“不受影响、不影响别人”，对称性“自己不受影响，只是会影响传递”，传递性“不影响别人，但会被对称性影响”</p>
<p>$R自反\Longrightarrow s(R),\space t(R)自反$</p>
<p>$R对称\Longrightarrow r(R),\space t(R)对称$</p>
<p>$R传递\Longrightarrow r(R)传递$</p>
<p>因此我们知道了，想要求叠加闭包，传递性质最脆弱，需要最后求传递闭包</p>
<p>$rs(R)=sr(R),\space rt(R)=tr(R),\space st(R)\subseteq ts(R)$</p>
<p>求“等价闭包”：$tsr(R)$ </p>
</li>
</ol>
</li>
<li><p>闭包的构造：若 R 不满足对应的性质</p>
<ul>
<li><p>$r(R)=R\cup R^0$</p>
</li>
<li><p>$s(R)=R\cup R^{-1}$</p>
</li>
<li><p>$t(R)=\bigcup\limits_{i=1}^\infty{R^i}$，特别地，对于有限非空集 A，一定存在一个正整数 $k\le|A|$，使得：$t(R)=R^+=\bigcup\limits_{i=1}^kR^i$</p>
<blockquote>
<p>这样的操作联想到图论中的<strong>求两点间是否有路径</strong>的算法，所以这里也可以使用 <a href="#Warshell">Warshell 算法 🔗</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>等价关系、等价类、商集、划分</p>
<p>这一部分定义很长，这里仅仅说明一下对概念的理解：</p>
<ul>
<li><p>等价关系：<strong>同时满足自反、对称、传递的关系</strong></p>
</li>
<li><p>等价类：$[x]_R=\{y\space|\space y\in A\wedge xRy\}$，<strong>A 中所有和元素 x（包含自身）满足 R 关系的元素组成的集合</strong>；</p>
<p><strong>等价类的所有性质也可以理解为：相互等价的元素一定在一个集合（等价类）里，不相互等价的一定不在一个等价类里</strong>；</p>
</li>
<li><p>商集：A 的所有等价类构成的集合（是集合的集合）</p>
</li>
<li><p>划分：数学家们通过证明发现，用元素等价区分的方式刚好能够划分一个集合，也就是说，<strong>一个等价类和一个划分一一对应</strong>。数学上称为<strong>诱导</strong>，等价关系可以诱导出一个对应的划分，一个划分又可以诱导出一个对应的等价类；</p>
<p><strong>划分的性质</strong>：（数学形式描述请查阅资料）</p>
<ol>
<li>分块全部来自 A、且每个分块不为空；</li>
<li>所有分块完全覆盖 A；</li>
<li><strong>每个分块不重叠</strong>；</li>
</ol>
</li>
</ul>
</li>
<li><p>相容关系、相容类、覆盖</p>
<ul>
<li>相容关系：<strong>同时满足自反、对称（比等价关系缺少传递）的关系</strong>；</li>
<li>最大相容类性质：对任意不在最大相容类中的一个元素，总能找到类中的一个元素和它不满足相容关系；</li>
</ul>
<p><strong>只要理解覆盖和划分的区别，覆盖是每个分块能够重叠</strong>；</p>
<p><strong>完全覆盖的唯一性；覆盖能够确定一个相容关系、相容关系能够确定一个完全覆盖</strong>；</p>
<blockquote>
<p>在关系图中，找相容关系相当于找 <strong>所有的极大完全子图</strong>（这个分块内每个元素都要有相互的关系），边可以重叠</p>
</blockquote>
<ul>
<li><strong>由覆盖构造相容关系</strong>：给定非空集 A 上的一个覆盖 $\Omega=\{A_1,A_2,…,A_n\}$，则由其确定的关系 $R=\bigcup\limits_{i=1}^nA_i\times A_i$ 是 A 上的一个相容关系（不一定是最大相容关系）；</li>
</ul>
</li>
</ul>
<ul>
<li><p>偏序关系：同时满足<strong>自反、反对称、传递</strong>性质的关系</p>
<p>拟序关系：同时满足<strong>反自反、传递</strong>性质的关系（由这两个性质能推出<strong>反对称性</strong>）</p>
<blockquote>
<p>偏序关系能理解为抽象的 “≤” 关系</p>
<p>拟序关系能理解为抽象的 “＜” 关系</p>
</blockquote>
<p><strong>偏序关系和拟序关系仅在自反性上有差别，拟序和偏序讨论一个即可</strong></p>
<p>e.g.1, 对集合 A，在 P(A) 上的包含关系是偏序关系；在 P(A) 上的真包含关系是拟序关系；</p>
<p>e.g.2, 可以通过增添/删减自反性来变换两者：$R\rightarrow R-R^0\space或\space R\rightarrow R\cup R^0$</p>
</li>
<li><p>结构、偏序集</p>
<p>结构：集合 A 及其上的关系 R 一起称为一个<strong>结构</strong>；</p>
<p>偏序集：若结构中的关系 R 是偏序关系，称这个结构为<strong>偏序集</strong>，记作$\langle A,R\rangle$；</p>
<blockquote>
<p>$\langle N,\le\rangle$、$\langle P(A),\subseteq\rangle$ 都是偏序集</p>
</blockquote>
</li>
<li><p>哈斯图：由于偏序关系自反（自环）、反对称（两顶点间最多一条有向边），所以表达偏序关系的图可以：①省略自环；②适当安排位置（默认偏序箭头向上）不画边的方向；③不画传递得到的边，这种图称为哈斯图（描述性定义）；</p>
<p><strong>预定义：盖住关系，对偏序关系 $\langle A,\preccurlyeq\rangle$，若 $x,y\in A,\space x\preccurlyeq y,\space x\ne y$，且不存在 $z\in A$ 使得 $x\preccurlyeq z\wedge z\preccurlyeq y$，则称 y 盖住 x</strong>；（理解为抽象的<strong>直接后继关系</strong>）</p>
<p><strong>定理：对所有偏序集$\langle A,\preccurlyeq\rangle$，A 上的盖住关系 cov A 唯一</strong>；</p>
<p>画法：① 每个顶点代表 A 的一个元素；② 如果 $x\preccurlyeq y\wedge x\ne y$，将 y 置于 x 上方（后继在上）；③ 仅在 cov A 中有的关系才能在哈斯图上连接无向边（这保证了不画传递的边）；</p>
</li>
<li><p>可比：对于偏序集 $\langle A,\preccurlyeq\rangle$，若$\forall x,y\in A\Rightarrow x\preccurlyeq y\vee y\preccurlyeq x$，则称 x 和 y 可比；</p>
<blockquote>
<p><strong>不可比不代表不能讨论 x 和 y 的关系，只是说两者双向的 $\preccurlyeq$ 都是假而已</strong>；</p>
</blockquote>
</li>
<li><p>偏序关系的上下界</p>
<p>最小元的感性理解：必须<strong>和其他所有元素构成偏序关系，且它是所有元素的“前驱”</strong>；（最大元同理）；<strong>因此最小/大元不一定存在（不一定与所有都可比），但如果存在一定唯一</strong>；</p>
<p>极小元的感性理解：<strong>不能是某一个元素的“后继”就行</strong>，可以与某些元素不可比；<strong>因此极小元必然存在，可能不唯一</strong>；</p>
<p>上下界和上下确界：比较明显，意会一下~</p>
</li>
<li><p>全序关系的感性理解：一个偏序集 $\langle A,\preccurlyeq\rangle$ 中，所有元素间都可比，就称这个集为<strong>全序集</strong>，这个 $\preccurlyeq$ 关系称为<strong>全序关系</strong>；</p>
<blockquote>
<p>很容易理解，有限的全序集一定是有最大、最小元的；</p>
<p>$\langle N,\le\rangle$ 是全序集，$\langle P(A),\subseteq\rangle$ 不是；<strong>因为自然数集上所有元素对于“小于等于”两两可比，但幂集的元素——集合可能两者都没有包含关系，即对于“包含关系”不可比</strong>；</p>
</blockquote>
</li>
<li><p>链的感性理解：将偏序集中相互可比的元素，构成一个子集，这个子集就是<strong>链</strong>，其中元素数称为<strong>链长</strong>；</p>
<blockquote>
<p>为什么叫链？<strong>因为如果一系列元素可比，那么在哈斯图上呈现的是一条链，不会出现分支</strong>；</p>
<p>这也是为什么全序关系又称为“线序关系”的原因；</p>
<p>找全序关系就是找贯穿所有元素的链；</p>
</blockquote>
</li>
<li><p>良序关系：一个偏序集 $\langle A,\preccurlyeq\rangle$，A 的任意非空子集都有最小元，那么 $\preccurlyeq$ 就叫做<strong>良序关系</strong>，这个偏序集叫做<strong>良序集</strong>；</p>
</li>
</ul>
<h3 id="4-2-常见题型"><a href="#4-2-常见题型" class="headerlink" title="4.2 常见题型"></a>4.2 常见题型</h3><ul>
<li><p>求集合划分的种类数</p>
<blockquote>
<p>结论：贝尔数 $B_n$；<a target="_blank" rel="noopener external nofollow noreferrer" href="https://oi-wiki.org/math/combinatorics/bell/">知识链接🔗</a></p>
<p>$B_n=C_{n-1}^0B_{n-1}+C_{n-1}^1B_{n-2}+\cdots+C_{n-1}^{n-1}B_0$；</p>
<p>可以用贝尔三角形每行第一个数来计算；</p>
<p>考到就仰仗自己的数学吧😭</p>
<p>帮你算几个：$B_0=B_1=1,\space B_2=2,\space B_3=5,\space B_4=15,\space B_5=52,\space B_6=203$</p>
<p>考场上基数大于 6 的集合的划分数，如果出到，请好好地问候出题老师！</p>
</blockquote>
</li>
<li><p>求各种闭包</p>
</li>
<li><p>求划分/等价类的元素和关系、由覆盖求对应的相容关系</p>
<p><strong>按照定义和性质，按部就班地来即可</strong></p>
</li>
<li><p>证明某个关系的性质，证明关系符合的公式</p>
<p><strong>思路：一般情况下，关系的元素是有序对，所以证明时一般都先声明一个 $\forall\langle x,y\rangle$</strong>，然后依次向下推理即可；</p>
<p><strong>特别地，如果是已定义的关系，例如等价关系，那么按照定义来</strong></p>
<blockquote>
<p>e.g.1, 设 $R,S,T$ 是 A 上的关系，证明：$R\circ(S\cup T)=(R\circ S)\cup(R\circ T)$</p>
<p>e.g.2, 已知 $A=Z_+\times Z_+$ 和 A 上的关系 $R=\{\langle\langle x,y\rangle,\langle u,v\rangle\rangle\space|\space xv=yu\}$； 证明 R 是等价关系；</p>
<p>e.g.3, 设 $\langle A,R_1\rangle,\space\langle B,R_2\rangle$ 是两个偏序集，定义 $A\times B$ 上的关系 R：对 $\forall a_1,a_2\in A,b_1,b_2\in B$，有 $\langle a_1,b_1\rangle R\langle a_2,b_2\rangle\Longleftrightarrow a_1R_1a_2\wedge b_1R_2b_2$，证明 R 是 $A\times B$ 上的偏序关系；</p>
</blockquote>
</li>
<li><p>给某个关于关系的公式找出反例</p>
<p><strong>思路：对于自反、对称而言，一般只需要找二阶关系矩阵就能发现矛盾；对于传递而言，需要从三阶关系矩阵开始找，先为每个矩阵设定一个传递关系，其他空不填，假设是0，看是否能成为反例；如果不行，在对空白处进行值的给定；</strong></p>
</li>
<li><p>判断一个结构是不是偏序关系：按定义来</p>
</li>
<li><p>考察偏序关系最大/小元、极大/小元的定义</p>
</li>
<li><p>画出偏序关系的哈斯图</p>
<blockquote>
<p>e.g., 对下列集合上的整除关系画出哈斯图，并指出在这个关系下的极大元、极小元、最大元、最小元（如果有的话）</p>
<p><code>A = &#123;1, 2, 3, 4, 6, 8, 12, 24&#125;</code> 和 <code>B = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</code></p>
<p>思考：从哈斯图上，我们能够如何更快地看出极大极小元？</p>
</blockquote>
</li>
<li><p>找到某个特定集合的一个全序关系</p>
<blockquote>
<p>找全序关系就是找一条贯穿集合所有元素的链</p>
<p>e.g., 找出在集合 <code>&#123;0, 1, 2, 3&#125;</code> 上包含 $\langle0,3\rangle$ 和 $\langle2,1\rangle$ 的全序关系；</p>
<p><strong>思路：将所有元素排成一条链，转化为排队问题</strong>；</p>
<p>如果要求包含某个元素，等价于某个元素必须排在另一个元素的前面/后面；</p>
<p>提示：本例共有 $C_3^1+C_3^2=6$ 种满足条件的全序关系；</p>
</blockquote>
</li>
</ul>
<h2 id="Chapter-5-函数"><a href="#Chapter-5-函数" class="headerlink" title="Chapter 5 函数"></a>Chapter 5 函数</h2><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><p>函数这章掌握几个概念和结论就行</p>
<ul>
<li><p>定义：就是一种集合 A 到集合 B 间的特殊关系；</p>
<blockquote>
<p>注意：$dom(f)=A$，不然就不是函数了</p>
</blockquote>
</li>
<li><p>部分函数：$dom(f)\subset A$，例如 $f:R\rightarrow R$ 的函数 $f(x)=\dfrac{1}{x}$，只有减去定义域中的 $\{0\}$ 或者在 $x=0$ 处添加定义，才能变为函数；</p>
</li>
<li><p>所有函数的集合：$A_B=\{f\space|\space f:A\rightarrow B\}$，也写作 $B^A$，<strong>基数 $|A_B|=|B|^{|A|}$</strong>；</p>
<blockquote>
<p>总数小于总关系数 $2^{|A||B|}$，<strong>因为：$A\ne \phi,\space B=\phi$ 不是函数、$A=\phi,\space B\ne\phi$ 只对应一个函数：空函数</strong>；</p>
</blockquote>
</li>
<li><p>单射、满射、双射的定义</p>
</li>
<li><p>常用函数的定义：常函数、恒等函数、n 元运算、泛函、特征函数、典型映射；</p>
</li>
<li><p>函数的合成</p>
<p><strong>着重掌握特性</strong>：</p>
<p><strong>定理：若 $f,g$ 满射，则$f\circ g$ 满射（单射、双射同理）</strong></p>
<p>逆定理：$f\circ g$ 满射则 $f$ 满射；$f\circ g$ 单射则 $g$ 单射；$f\circ g$ 双射，则 $f$ 满射、$g$ 单射；</p>
<p><strong>逆定理记忆：全部都是“外层满、内层单”</strong></p>
</li>
<li><p>函数的逆</p>
<p><strong>着重掌握左逆、右逆的性质</strong>：</p>
<p>定理：f 既有左逆、又有右逆，等价于 f 双射且左右逆相等；f 有左逆 $(g\circ f)$ 等价于 f 单射；f 存在右逆 $(f\circ g)$ 等价于 f 满射；</p>
<p><strong>记忆：还是“外层满、内层单”，函数在什么位置有逆，就是什么侧的满/单</strong>；</p>
</li>
</ul>
<h3 id="5-2-常见题型"><a href="#5-2-常见题型" class="headerlink" title="5.2 常见题型"></a>5.2 常见题型</h3><ul>
<li><p>判断单/满/双射</p>
</li>
<li><p>给定集合，要求构造集合间的 单射/满射/双射函数；</p>
<p><strong>一般情况都比较简单，有些不好想的需要记忆一下，例如：构造从 $N\times N$ 到 $N$ 的双射函数；答案是在点阵中有序环绕：$f(\langle m,n\rangle)=\dfrac{1}{2}(m+n)(m+n+1)+m$</strong>；大部分其他的无穷集上的构造也多采用这种方法；</p>
</li>
</ul>
<h3 id="5-3-错题"><a href="#5-3-错题" class="headerlink" title="5.3 错题"></a>5.3 错题</h3><ul>
<li><p>关于 $A\rightarrow\phi$ 的函数,下列（）是正确的</p>
<p>A．不存在</p>
<p>B．有一个空函数 $\Phi$</p>
<p>C．仅当 A 非空时才能有函数</p>
<p>D．仅当 A 为空时才能有函数</p>
<p><strong>事实上，$A\ne\phi,\space B=\phi$ 的函数不存在，但如果 A、B 都为空，那么可以是空函数</strong>；</p>
</li>
</ul>
<h2 id="Chapter-6-图论"><a href="#Chapter-6-图论" class="headerlink" title="Chapter 6 图论"></a>Chapter 6 图论</h2><h3 id="6-1-图论中的重要定义Ⅰ"><a href="#6-1-图论中的重要定义Ⅰ" class="headerlink" title="6.1 图论中的重要定义Ⅰ"></a>6.1 图论中的重要定义Ⅰ</h3><blockquote>
<p>图的起源：人们关心一类问题，给定的两点间是否有一条或多条连线的关系，而连接方式无关紧要。这类问题在数学上的抽象是<strong>图</strong>；</p>
</blockquote>
<ul>
<li><p>图的数学定义：一个图指<strong>有序三元组$(V(G),E(G),\psi_G)$</strong>，<strong>$V(G)$</strong>为<strong>非空</strong>（空图特殊，不参与讨论）顶点集，<strong>$E(G)$</strong>是不与<strong>$V(G)$</strong>相交的边集，<strong>$\psi_G$</strong>为关联函数；</p>
<blockquote>
<p>约定：对于图 G，一般用符号 <strong>$V(G)$</strong> 表示顶点集、<strong>$E(G)$</strong> 表示边集、<strong>$\nu(G)$</strong> 表示顶点数，<strong>$\varepsilon(G)$</strong> 表示边数；若上下文仅有一个图，则省略 “(G)”；</p>
<p>注：无向图可以表示为二元组，即 V 和 E；</p>
</blockquote>
</li>
<li><p>顶点对的定义：<strong>$\psi_G$</strong> 使 G 的每条边对应于 G 的 无序的<strong>顶点对</strong>；</p>
</li>
<li><p>连接、端点的定义：若 e 为 G 的一条边，u、v 是使 <strong>$\psi_G(e)=(u,v)$</strong> 的顶点，则称：e <strong>连接</strong> u、v，顶点 u、v 称为 e 的<strong>端点</strong>；</p>
</li>
<li><p>关联、相邻、自环：一条边的端点与这条边<strong>关联</strong>；与同一条边关联的两个顶点称为<strong>相邻</strong>；端点重合为一点的边称为<strong>自环</strong>；</p>
</li>
<li><p>平面图、非平面图：边仅在端点相交的图称为<strong>平面图</strong>，反之为非平面图；</p>
</li>
<li><p>平凡图、非平凡图：仅有一个顶点的图称为<strong>平凡图</strong>；</p>
</li>
<li><p>有向边、无向边：可由端点 <strong>$v_i\space和\space v_j$</strong> 表示 <strong>$e_k=(v_i,v_j)$</strong> 的边称为<strong>无向边</strong>（vi、vj互为直接前驱、直接后继）；可由有序二元组 <strong>$e_k=\langle v_i,v_j\rangle$</strong> 表示的边是<strong>有向边</strong>（vi是vj的直接前驱、vj是vi的直接后继）；</p>
</li>
<li><p>有向图、无向图：所有边都是有向边的图是<strong>有向图</strong>，反之是<strong>无向图</strong>，否则是混合图；</p>
<blockquote>
<p>可以将无向边视作双向有向边，因此此后不讨论混合图；</p>
</blockquote>
</li>
<li><p>简单图、有向简单图：既没有<strong>自环</strong>，又没有<strong>重边</strong>的图，如果是无向图，称为<strong>简单图</strong>；如果是有向图，称为<strong>有向简单图</strong>；</p>
<blockquote>
<ol>
<li><p>重边的定义：有两条及以上条边连接同一对顶点，称这个边为重边；</p>
<p>⚠<strong>易错警示：对有向边，A—-&gt;B 和 B—-&gt;A 组合不算重边！A—-&gt;B 和 A—-&gt;B 组合才是</strong>；</p>
</li>
<li><p>如果不强调“有向”，一般情况下“图”指“无向图”；不过在定义中，如果发现只描述无向图的，大概率对有向图也适用，不然就单独拎出来了；</p>
</li>
</ol>
</blockquote>
</li>
<li><p>完全图、有向完全图：每对不同顶点都有一条边相连的<strong>简单</strong>图称为<strong>完全图</strong>；有向完全图同理；</p>
<p><strong>特别地，将 n 个结点的完全图记作 $K_n$，但有向完全图没有这种记法；</strong></p>
<blockquote>
<p><strong>定理1：$\varepsilon(K_n)=C^2_{n}$ 且对n 个结点的有向完全图G：$\varepsilon(G)=A^2_{n}$；</strong></p>
<p>（因为A—-&gt;B 和 B—-&gt;A 组合不算重边） </p>
</blockquote>
</li>
<li><p>偶图（或者称二部图）：一个图 G 的顶点集 <strong>$V(G)$</strong> 可以分解为两个子集 X、Y，使得：每条边都有一个顶点在 X 中，另一个顶点在 Y 中；这样的一种分类 (X, Y) 称为 G 的一个<strong>二分类</strong>；</p>
<blockquote>
<p>理解：按分解的两个点集“切一刀”，所有边都被砍断的图；</p>
</blockquote>
</li>
<li><p>子图：若 <strong>$V(H)\subseteq V(G),\space E(H)\subseteq E(G)$</strong>，<strong>$\psi_H$</strong> 为 <strong>$\psi_G$</strong> 在 <strong>$E(H)$</strong> 上的限制，则 <strong>$H$</strong> 为 <strong>$G$</strong> 的<strong>子图</strong>，记作：<strong>$H\subseteq G$</strong>；（真子图略）</p>
</li>
<li><p>母图：若 <strong>$H\subseteq G$</strong>，称 <strong>$G$</strong> 为 <strong>$H$</strong> 的<strong>母图</strong>；</p>
</li>
<li><p>生成子图（或称支撑子图，spanning sub-graph）：<strong>$H\subseteq G\space且\space V(H)=V(G)$</strong>，称 <strong>$H$</strong> 为 <strong>$G$</strong> 的<strong>生成子图</strong>；</p>
</li>
<li><p>导出子图：有点抽象，一般用不到定义，想要形象地了解见：<a href="#graphCalc">图的运算🔗</a>；</p>
</li>
<li><p>基础简单图：一个图 G 删去所有<strong>“多余”的边</strong>，使图中恰没有重边、自环，得到的这样的<strong>简单生成子图</strong>称为<strong>基础简单图</strong>；</p>
</li>
<li><p>赋权图（或称加权图）：若给图 G 的每条边都赋以实数 <strong>$w_k$</strong> 作为该边的权，称 G 为赋权图；</p>
</li>
<li><p>顶点的度：图 G 的顶点 v 的度记为 <strong>$d_G(v)$</strong>，指 G 中与 v 相关联的数目；</p>
<ul>
<li>约定：<strong>$\delta(G)、\Delta(G)$</strong> 表示 G 的所有顶点的最小度、最大度；</li>
<li>度为0的点称为<strong>孤立点</strong>；</li>
<li><strong>对于有向图，$d(v)=d_+(v)+d_-(v)$，$d_+$ 为正度/入度，$d_-$ 为负度/出度</strong>；</li>
<li><strong>自环贡献一个入度、一个出度</strong>；</li>
</ul>
<blockquote>
<p><strong>定理2：（握手定理）$\sum\limits_{v\in V}d(v)=2\varepsilon$（所有结点的度之和为边数的2倍，有向图也是）</strong>；</p>
<p>推论：对任何图，度为奇数的点（称<strong>奇点</strong>）的个数为偶数；</p>
<p><strong>定理3：有向图中，$\sum{d_-}=\sum{d_+}=\varepsilon$（入度和=出度和=边数，是入度出度平分的意思）</strong></p>
<p><strong>定理4：非空简单图（$\varepsilon\gt1$）一定存在度相同的结点</strong>；</p>
</blockquote>
</li>
</ul>
<h3 id="6-2-图的同构"><a href="#6-2-图的同构" class="headerlink" title="6.2 图的同构"></a>6.2 图的同构</h3><blockquote>
<p>注：图同构问题分为4类：精确图完全同构、精确子图同构、不精确图完全同构、不精确子图同构；现在学界已证明后三者是 NP 完全问题；计算机离散数学-图论、数据结构（包括下面的内容）讨论的是第一种问题；</p>
</blockquote>
<ul>
<li><p>恒等图的定义</p>
</li>
<li><p>同构图的定义：如果存在两个<strong>一一映射（双射）$\theta:\space V(G)\rightarrow V(H),\space\phi:\space E(G)\rightarrow E(H)$</strong>，使 <strong>$\psi_G(e)=(u,v)$</strong> 当且仅当 <strong>$\psi_H(\phi(e))=\theta(u)\theta(v)$</strong>，则将这样的映射对 <strong>$(\theta,\phi)$</strong> 称为 G 和 H 间的一个同构；将 G 与 H 同构关系记为 <strong>$G\cong H$</strong>；</p>
<blockquote>
<p>理解：边边和点点必须一一相应；</p>
<p>就是在不添加边和点、不删除边和点的基础上<strong>任意移动顶点的相对位置、为顶点和边改名</strong>，所产生的不同形态的图；</p>
</blockquote>
</li>
<li><p>关于同构的定理</p>
<blockquote>
<p><strong>定理5：（同构的必要条件）两个同构图的结点度的非增序列相同</strong></p>
<p><strong>定理6：（同构的必要条件）若 G1 与 G2 同构，则 G1 的任意<u>导出子图</u>都有 G2 的导出子图与其同构</strong>；</p>
<p>其实还有一个必要条件过于明显，不作为定理：两同构图的顶点数、边数相等；</p>
</blockquote>
</li>
<li><p>判断方法</p>
<ul>
<li><p>判断两图同构：<strong>按定义，找到两个一一映射</strong>；</p>
<blockquote>
<p>注：根据定义，可以得出一个显然的方法：<strong>一个图的邻接矩阵经历有限次的行互换、列互换，能变成另一个图的邻接矩阵，那么这两个图同构</strong>；</p>
</blockquote>
</li>
<li><p>判断两图不同构：使用定理5、6（必要条件），不满足必要条件的就不是；</p>
</li>
</ul>
</li>
</ul>
<h3 id="6-3-图的存储实现"><a href="#6-3-图的存储实现" class="headerlink" title="6.3 图的存储实现"></a>6.3 图的存储实现</h3><ul>
<li><p><span id="relM">图的关联矩阵（<strong>行是顶点，列是边</strong>）：因为空间原因，不做存储图的方法；</span></p>
<blockquote>
<p>虽然不做存储方法，但在讨论<strong>树、有向连通图、电路图的某些性质</strong>时比较有用，感兴趣戳<a href="#relMDetails">这里🔗</a>（不在初级数据结构要求范围内）；</p>
</blockquote>
<ul>
<li>无向图的关联矩阵：可以由 bool 矩阵表示，1是有关联，0是没有关联；</li>
<li>有向图的关联矩阵：+1表示该边离开该结点，即正度/出度；-1表示该边进入该结点，即负度/入度；0表示没有关联；</li>
</ul>
</li>
<li><p>图的邻接矩阵表示法：对任意的图 G，对应一个 <strong>$\nu\times\nu$</strong> 的邻接矩阵 <strong>$A(G)=[a_{ij}]$</strong>，其中 <strong>$a_{ij}$</strong> 为 <strong>$v_i、v_j$</strong> 的连接数目；（空间：<strong>$O(|V|^2)$</strong>）</p>
<p><strong>进一步，在数据结构中更常用的是“加权图的邻接矩阵”存储方法，可以兼顾非加权图：</strong></p>
<script type="math/tex; mode=display">
A[i][j]=\begin{equation}\left\{\begin{aligned}&\omega,&<i,j,w>\in E\\
&0,&i=j\\
&\infty,&otherwise\\
\end{aligned}\right.\end{equation}</script><p><strong>C++代码实现统一放置于附录中，有需要可以前去查看，下同；</strong></p>
</li>
<li><p>图的邻接表表示法：改进了邻接矩阵表示法在面对稀疏矩阵时浪费空间、不易维护的问题；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">结点集(结点数组)：node1 &#123;结点值，与该结点相邻的直接后继(有方向)结点索引链表头指针&#125;</span><br><span class="line"> |------------------------------------------------------------|</span><br><span class="line"> v</span><br><span class="line">边集(单链表)：node2 &#123;结点索引（不能放结点值，因为无法完成后面的遍历运算, 下一node2&#125;</span><br><span class="line"></span><br><span class="line">+ 保存边数、保存结点数</span><br><span class="line">空间：O(|V|+|E|)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-4-图的运算实现"><a href="#6-4-图的运算实现" class="headerlink" title="6.4 图的运算实现"></a>6.4 图的运算实现</h3><ul>
<li><p><span id="graphCalc">图的基本运算</span></p>
<ul>
<li><p>差运算：<strong>（要求 $G_2$ 为 $G_1$ 子图）$G_1-G_2=(V_1,E_1-E_2)$</strong>；</p>
</li>
<li><p>补运算：<strong>$n$</strong> 个结点的简单图的补图 <strong>$\overline{G}=K_n-G$</strong>；</p>
</li>
<li><p>删去结点 <strong>$v$</strong> 及其关联的边：<strong>$G-v$</strong></p>
<blockquote>
<p><strong>$G-v$</strong> 为 <strong>$G$</strong> 的<strong>导出子图</strong>：有助于理解导出子图的意义；</p>
</blockquote>
</li>
<li><p>删去边 <strong>$e$</strong>：<strong>$G-e$</strong></p>
<blockquote>
<p><strong>$G-e$</strong> 为 <strong>$G$</strong> 的<strong>生成子图</strong>：有助于理解生成子图的意义；</p>
</blockquote>
</li>
<li><p>增加边 <strong>$e_{ij}=(v_i,v_j)$</strong>：<strong>$G+e_{ij}$</strong></p>
</li>
</ul>
</li>
<li><p>数据结构中图的基本运算：创建、判边、增删边、查点边数、遍历（后面分开讨论）；</p>
</li>
<li><p>图的运算实现：<strong>对于不同的存储方式，图的运算时间复杂度有所不同</strong></p>
<ul>
<li><p>邻接矩阵表示的运算实现</p>
</li>
<li><p>邻接表表示的运算实现</p>
</li>
</ul>
</li>
</ul>
<h3 id="6-5-图论中的重要定义Ⅱ"><a href="#6-5-图论中的重要定义Ⅱ" class="headerlink" title="6.5 图论中的重要定义Ⅱ"></a>6.5 图论中的重要定义Ⅱ</h3><ul>
<li><p>道路和回路：在无向图 <strong>$G=(V,E)$</strong> 中，若<u>边点交替序列</u> <strong>$P=(v_{i1},e_{i1},v_{i2},e_{i2},…,e_{iq-1},v_{iq})$</strong> 满足：<strong>$v_{ik}、v_{ik+1}$</strong> 为 <strong>$e_{ik}$</strong> 的两个端点，则称 P 为 G 的一条<strong>道路</strong>；特别地，如果 <strong>$v_{i1}=v_{iq}$</strong>，那么称道路 P 为 G 的一条<strong>回路</strong>；</p>
<ul>
<li>如果 P 序列中没有重复的边，则 P 称为<strong>简单道路（或称“迹”）、简单回路（或称“闭迹”）</strong>；</li>
<li>更特别地，如果 P 序列中结点也不重复（结点不重复是边不重复的充分不必要条件），则称 P 为 G 的<strong>初级道路、初级回路</strong>；</li>
</ul>
</li>
<li><p>有向道路和有向回路：在有向图 <strong>$G=(V,E,\psi_G)$</strong> 中，若<u>边序列</u> <strong>$P=(e_{i1},e_{i2},…,e_{iq})$</strong>，其中  <strong>$e_{ik}=(v_l, v_j)$</strong>，则称 P 为 G 的<strong>有向道路</strong>；若 <strong>$e_{iq}$</strong> 终点也是 <strong>$e_{i1}$</strong> 的始点，则称 P 为 G 的<strong>有向回路</strong>；</p>
<ul>
<li>同样有：简单有向道路、简单有向回路、初级有向道路、初级有向回路的概念；</li>
</ul>
<blockquote>
<p>⚠易错点：<strong>平凡图一定是道路，但一定不是回路！</strong></p>
</blockquote>
</li>
<li><p>连通性、强连通性、弱连通性、单向连通性</p>
<ul>
<li>无向图考虑“连通”：两结点间至少存在一条道路，则这两个结点间连通；</li>
<li>有向图考虑：<ol>
<li>两结点间存在一条从 <strong>$v_i$</strong> 到 <strong>$v_j$</strong> 的有向道路 <strong><u>且</u></strong> 存在另一条从 <strong>$v_j$</strong> 到 <strong>$v_i$</strong> 的有向道路，则称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>强连通</strong>；</li>
<li>两结点间<strong><u>仅</u></strong>存在一条从 <strong>$v_i$</strong> 到 <strong>$v_j$</strong> 的有向道路 <strong><u>或</u></strong> <strong><u>仅</u></strong>存在另一条从 <strong>$v_j$</strong> 到 <strong>$v_i$</strong> 的有向道路，则称称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>单向连通</strong>；</li>
<li>两结点间 <strong>不考虑所有道路的方向（称为“有向图的底图”）</strong>，若这两个结点连通，则称 <strong>$v_i$</strong> 和 <strong>$v_j$</strong> <strong>弱连通</strong>；</li>
</ol>
</li>
</ul>
</li>
<li><p>连通图、连通分量（或称“连通支”）</p>
<ul>
<li>无向图 G 中任意两结点间都是连通的，则 G 为<strong>连通图</strong>；</li>
<li>G 的连通子图（子图且连通）H 不是 G 的任何其他连通子图的真子图，称 H 为 G 的一个<strong>极大连通子图</strong>，也称<strong>连通分量</strong>；</li>
</ul>
<blockquote>
<p>有些不严谨的题问有向图“是不是连通图”，就将它看成一个无向图（忽略方向）；</p>
</blockquote>
</li>
<li><p>强连通图、强连通分量</p>
<ul>
<li>有向图 G 中任意两结点间都是强连通的，则 G 为<strong>强连通图</strong>；</li>
<li>G 的强连通子图 H 不是 G 的任何其他强连通子图的真子图，称 H 为 G 的一个<strong>极大的强连通子图</strong>，也称<strong>强连通分量</strong>；</li>
</ul>
<blockquote>
<p>⚠易错点1：<strong>平凡图也单独算一个连通分量 / 强连通分量！</strong></p>
<p>⚠易错点2：因为无向边看作“双向边”，所以连通的无向图一定是强连通的；</p>
<p><strong>推论：图 G 的每个连通分支都是其导出子图</strong>；</p>
<p><strong>小结论：图 G 对应关联矩阵记为 $M(G)$，则 G 的连通分支数为 $r(M(G))-1$</strong>；</p>
</blockquote>
</li>
<li><p>割边与非割边、割点与非割点：删去图中某个边 / 点，图的连通分支数（连通性）改变，则称该边 / 点为<strong>割边 / 割点</strong>；</p>
</li>
<li><p>欧拉道路、欧拉回路：<strong>无向连通图</strong> G 中的一条经过<u>所有边</u>的<strong>简单道路/回路</strong>称 G 的<strong>欧拉道路/回路</strong>；</p>
<ul>
<li><p>理解：不重复地遍历所有边，不管点的情况；</p>
</li>
<li><p>注意：<strong>有向图也能讨论欧拉回路的问题，不过要遵循有向的连通性</strong>；</p>
</li>
</ul>
<blockquote>
<p><strong>定理1：（欧拉回路充要条件）无向连通图 G 存在欧拉回路 $\Longleftrightarrow$ G 的各结点度数均为偶数</strong>；</p>
<p><strong>推论1-1：（欧拉道路充分条件）无向连通图 G 仅有2个奇点 $\Longrightarrow$ G 存在欧拉道路</strong>；</p>
<p><strong>推论1-2：（有向欧拉回路充分条件）有向连通图 G 的各结点的正、负度数相等 $\Longrightarrow$ G 存在有向欧拉回路</strong>（侧面说明有向可能严格一些，不仅结点度全为偶数，而且要进出相等）；</p>
<p>定理2：连通图 G 有 k 个奇点（由部分Ⅰ的定理可知，k为偶数），则 E(G) 可以划分为 <strong>$\dfrac{k}{2}$</strong> 条简单道路；</p>
</blockquote>
</li>
<li><p>哈密顿道路、哈密顿回路：<strong>无向图</strong> G 的一条<u>经过全部结点</u>的<strong>初级道路/回路</strong>称 G 的<strong>哈密顿道路/回路（简称H道路/H回路）</strong>；</p>
<ul>
<li>理解：“不重复地遍历所有点”；</li>
<li>注意：H 道路 / 回路一般针对简单图，因为重边和自环对它没有什么影响，可以转换为简单图的问题；</li>
</ul>
<blockquote>
<p><strong>很遗憾，目前 H 道路 / 回路的判定没有充要条件！一般遍历是 NP 问题……</strong></p>
<p><strong>定理3：（H 回路充分条件）完全图 $K_n$ 为 H 图</strong>；</p>
<p><strong>定理4：（H 回路充分条件）若简单图 G 每个结点度都大于 n/2，则 G 为 H 图</strong>；</p>
<p>说明：平均每个点的度越大，越有可能有H道路、H回路；</p>
<p><strong>推论4-1：（H 道路充分条件）若简单图 G 的任两结点 $v_i,v_j$ 恒有 $d(v_i)+d(v_j)\ge n-1$，则 G 存在 H 道路；</strong></p>
<p>证明提示：有 H 道路一定连通，可以先证连通性；</p>
<p><strong>推论4-2：（H 回路充分条件）若简单图 G 的任两结点 $v_i,v_j$ 恒有 $d(v_i)+d(v_j)\ge n$，则 G 为 H 图</strong>；</p>
<p><strong>推论4-3：（H 回路的闭包等价关系）向图 G 中满足 “ $d(v_i)+d(v_j)\ge n$”的不相邻两结点 $v_i,v_j$ 加边，直至无法找到这样的结点对为止，形成的新图称为 G 的闭包（记为$C(G)$）；那么有：$G\space为H图\Longleftrightarrow C(G)为H图$</strong>；</p>
<p><strong>推论4-4：（H回路闭包充分条件）若 $C(G)=K_n$，则 G 为 H 图</strong>；</p>
<p><strong>定理5：（可怜为数不多的 H 回路的必要条件）若 G 为 H 图，则对任意非空顶点集 S，有：$\omega(G-S)\le|S|$</strong>；</p>
</blockquote>
<ul>
<li><p>补充：欧拉图、H 图的定义：有欧拉回路 / H 回路的图才叫~（只有欧拉道路 / H 道路的不是）；</p>
</li>
<li><p>判断一个图是 H 图：使用上面的充分条件/等价条件；</p>
</li>
<li><p>判断一个图不是 H 图：使用上面的必要条件；</p>
<blockquote>
<p>举例：证明 Peterson 图是极大非 H 图（有 H 道路，但没有 H 回路）</p>
<p>【问题：它满足定理5，能否判断一下为什么在删去任意4个顶点时，连通分支数一定小于等于3？】</p>
<p><strong>定理6：（必要条件）若一个点在 H 回路中，那么必定有且仅有两个相连的相异道路</strong>；</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="6-6-图的简单应用"><a href="#6-6-图的简单应用" class="headerlink" title="6.6 图的简单应用"></a>6.6 图的简单应用</h3><ul>
<li>【普通图】有 3L、5L、8L的三个没有刻度的量杯，现在8L的量杯装满了水，其他两个是空的；问如何操作（不撒不漏）可以让8L水分为两个4L水？</li>
<li>【二部图】人、狼、羊、菜过河问题</li>
</ul>
<blockquote>
<p>解决思路：<strong>“状态转换图”：</strong>将每一个状态抽象为一个顶点，先列出所有可能状态作为顶点，再用“一次能直接转换的关系”作为边连接，最后只需判断在起点（初态）和终点（末态）是否单向连通即可；</p>
</blockquote>
<h3 id="6-7-图论中的重要定义Ⅲ"><a href="#6-7-图论中的重要定义Ⅲ" class="headerlink" title="6.7 图论中的重要定义Ⅲ"></a>6.7 图论中的重要定义Ⅲ</h3><blockquote>
<p>提示：本章节不在初级数据结构要求范围内；</p>
</blockquote>
<ul>
<li><p>割边与非割边、割点与非割点：删去图中某个边 / 点，图的连通分支数（连通性）改变，则称该边 / 点为<strong>割边 / 割点</strong>；</p>
<blockquote>
<p><strong>定理1：e 为割边，当且仅当 e 不属于 G 的任何回路</strong>；</p>
</blockquote>
</li>
<li><p>普通树的数学定义：不含任何回路的连通图称为<strong>树</strong>；</p>
<blockquote>
<p><strong>定理2：“连通”、“无回路”、“有 n-1 条边”三个条件任取两个都可以作为树的定义</strong>；</p>
<p>推论：“连通+全为割边”、“任意两点间有唯一道路”、“无回路+加一边就一回路” 这三个与树的定义等价；</p>
<p><strong>定理3：树中一定有树叶结点（离散数学中没有空树的说法！只有空图）</strong></p>
</blockquote>
</li>
<li><p>根树的定义：若树 T 是有向树，且 T 中存在某结点 $v_0$ 的入度为0、其他结点入度为1，则称 <strong>T 是以 $v_0$ 为根的根树</strong>（或外向树），用 $\overrightarrow{T}$ 表示；</p>
<blockquote>
<p><strong>根树才是数据结构中的“树”！</strong></p>
</blockquote>
</li>
<li><p>生成树（或称“支撑树”）：图 G 的一个符合树定义的生成子图称为图 G 的<strong>生成树</strong>；</p>
<blockquote>
<p>余树：给定图 G 的一棵生成树 T，定义余树 $\overline{T}=G-T$；一般情况下，余树不是树；</p>
</blockquote>
</li>
<li><p><span id="relMDetails">基本关联矩阵：<strong>上接“<a href="#relM">关联矩阵存储🔗</a>”，虽然关联矩阵一般不作为存储方法，但有些情况讨论它的性质，可以更方便地解决某些问题</strong>；</span></p>
<blockquote>
<p>友情提醒1：这里和<strong>电路理论的电路图研究</strong>结合比较紧密；</p>
<p>友情提醒2：这里的讨论对象是<strong>有向连通图</strong>；</p>
</blockquote>
<ul>
<li>定义：在<strong>有向连通图 $G=(V, E)$</strong> 的<strong>关联矩阵 $B$</strong> 中，划去任意任意结点 $v_k$所对应的一<strong>行</strong>，得到 <strong>$(\nu-1)\times\varepsilon$</strong> 的矩阵 $B_k$，称为 <strong>G 的一个基本关联矩阵</strong>；</li>
<li>相关定理</li>
</ul>
<blockquote>
<p><strong>定理1：有向连通图 G 的关联矩阵 B 满足：$r(B)=\nu-1$</strong>；</p>
<p><strong>定理2：有向连通图 G 的基本关联矩阵 $B_k$ 满足：$r(B_k)=\nu-1$</strong>；</p>
<p>推论：n个结点树 T 的基本关联矩阵的秩为 $\nu-1$；</p>
<p><strong>定理3：有向连通图 G 如果存在回路 C，则 C 中各边所对应基本关联矩阵 $B_k$ 的各列线性相关</strong>；</p>
<p><strong>定理4：有向连通图 G 的基本关联矩阵 $B_k$，有：$B_k任意n-1阶子式M_{n-1}\ne0\Longleftrightarrow M_{n-1}各列对应边构成G的一棵生成树$</strong>；</p>
<p>定理4说明了<strong>可以由 $B_k$ 的非零 n-1 阶子式的数目来代表 $G$ 生成树的数目<a href="#genTCount">🔗</a></strong>；</p>
</blockquote>
</li>
<li><p>回路矩阵和割集矩阵；</p>
<blockquote>
<p>不说了亲，这边建议您好好复习电路理论课呢:sweat_smile:</p>
</blockquote>
</li>
<li><p>Huffman树（最优二叉树），详见“数据结构复习-第二部分”；</p>
</li>
</ul>
<h3 id="6-8-图的经典算法"><a href="#6-8-图的经典算法" class="headerlink" title="6.8 图的经典算法"></a>6.8 图的经典算法</h3><h4 id="6-8-1-图的遍历算法"><a href="#6-8-1-图的遍历算法" class="headerlink" title="6.8.1 图的遍历算法"></a>6.8.1 图的遍历算法</h4><ul>
<li><p>DFS 算法：类似树的前序遍历</p>
<p>邻接表存储 $O(|V|+|E|)$</p>
<p>邻接矩阵存储 $O(|V|^2)$</p>
</li>
<li><p>BFS 算法：类似树的层次遍历</p>
<p>邻接表存储 $O(|V|+|E|)$ </p>
<p>邻接矩阵存储 $O(|V|^2)$</p>
</li>
</ul>
<h4 id="6-8-2-两点间道路判定算法"><a href="#6-8-2-两点间道路判定算法" class="headerlink" title="6.8.2 两点间道路判定算法"></a>6.8.2 两点间道路判定算法</h4><blockquote>
<p>这里介绍邻接矩阵表示的算法，比较常见；</p>
</blockquote>
<ul>
<li><p>引入：对于一个<strong>非加权图的邻接矩阵（0&amp;1）</strong>，有 $P=(p_{ij})_{n\times n}=\sum\limits_{k=1}^n{A^k}$，则 $p_{ij}$ 为从 $v_i$ 到 $v_j$ 的<strong>道路数</strong>；实际问题只关心<strong>是否有道路</strong>，所以可以改成逻辑运算提升速度：$P=(p_{ij})_{n\times n}=\bigvee\limits_{k=1}^n{A^k}$，时间复杂度 $O(\nu^4)$；</p>
</li>
<li><p><span id="Warshell">Warshell算法 $O(\nu^3)$</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P &lt;- A</span><br><span class="line">for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">    for (int j = 1; j &lt;= n; ++j)</span><br><span class="line">        for (int k = 1; k &lt;= n; ++k)</span><br><span class="line">            p_&#123;jk&#125; &lt;- p_&#123;jk&#125; V (p_&#123;ji&#125; Λ p_&#123;ik&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>DFS 和 BFS $O(\varepsilon)$：和图的遍历不一样的是，它比图的遍历更简单，只需从一个点出发（减少最外层循环），用visited数组和BFS/DFS整体寻找，如果遇到终点即停止并返回true，否则返回false；</p>
</li>
</ul>
<h4 id="6-8-3-有向图强连通分支判断算法"><a href="#6-8-3-有向图强连通分支判断算法" class="headerlink" title="6.8.3 有向图强连通分支判断算法"></a>6.8.3 有向图强连通分支判断算法</h4><blockquote>
<p>思路：先从图 G 任一点开始 DFS，如果 G 不是强连通图，则可能得到一个深度优先生成森林；对森林中的每棵树按照<strong>生成次序</strong>依此进行<strong>后序遍历</strong>，并按遍历顺序给每个结点编号（从小到大）；</p>
<p>然后使 G 的每条边逆向，得到 Gr，再从 Gr 编号最大的结点开始 DFS，得到新的深度优先遍历森林中的<strong>每一棵树</strong>就是 G 的一个强连通分量；</p>
</blockquote>
<h4 id="6-8-4-欧拉回路的构造算法"><a href="#6-8-4-欧拉回路的构造算法" class="headerlink" title="6.8.4 欧拉回路的构造算法"></a>6.8.4 欧拉回路的构造算法</h4><blockquote>
<p>欧拉回路有明确的、好判断的充要条件，所以算法设计相对容易；</p>
<p>无论啥算法，最好先利用充要条件排除没有欧拉回路的图，能大大提高时间性能；</p>
<p>下面讨论<strong>如果有欧拉回路，应该怎么找</strong>的算法：</p>
</blockquote>
<ul>
<li>拼接法：DFS寻找回路（经过即删除），如果回路结束却仍然有未遍历的结点，则从新的未访问的结点开始遍历回路，<strong>并拼接（“8”字原理）</strong>，循环直到所有边已被访问；</li>
<li>Floyd算法（非割边优先遍历）</li>
</ul>
<h4 id="6-8-5-欧拉回路的应用：中国邮递员问题（CPP）"><a href="#6-8-5-欧拉回路的应用：中国邮递员问题（CPP）" class="headerlink" title="6.8.5 欧拉回路的应用：中国邮递员问题（CPP）"></a>6.8.5 欧拉回路的应用：中国邮递员问题（CPP）</h4><blockquote>
<p>中国邮递员问题：<strong>走遍图中的所有边</strong>后返回返回起点，要求<strong>总路程最短</strong>；</p>
</blockquote>
<ul>
<li><p>对于无向图 G 的结论</p>
<ul>
<li><p>如果 G 中所有结点个数都是偶数：该图的任一欧拉回路都是解；</p>
</li>
<li><p>如果 G 中有且仅有 2 个奇点 $v_i\space和\space v_j$：找到 G 从  $v_i$ 到 $v_j$ <strong>欧拉道路 $E_{ij}$</strong>，再找从  $v_j$ 到 $v_i$ 的<strong>最短路径 $P_{ji}$</strong>，则回路 <strong>$E_{ij}+P_{ji}$</strong> 就是问题的解；</p>
</li>
<li><p>如果 G 中有两个以上，共2k个奇点（由前面图的性质推论，奇点必有偶数个）：</p>
<script type="math/tex; mode=display">
图G有最佳邮路L\Longleftrightarrow\begin{equation}\left\{\begin{aligned}&1.\space L的任一边最多重复一次\\&2.\space对G中的任一回路C，L中在C上重复边的长度之和\\&\quad不超过C总长的一半\space(必须遍历所有包含重边的回路)\\\end{aligned}\right.\end{equation}</script><p><strong>实际做法是：找出所有奇点，两两配对并依此为奇点间添加重复边（长度和原边相等），为它们配对成偶点，得到新图，也即邮路 $L_x$；再检查 $L_x$ 是否满足以上两个条件；如果违反第一条则一次性删除两条多余重边，如果违反第二条则将 $L_x$ 的该段道路改成与 $C$ 互补的道路</strong>；</p>
</li>
</ul>
</li>
</ul>
<h4 id="6-8-6-H-回路的应用：旅行商问题（TSP）"><a href="#6-8-6-H-回路的应用：旅行商问题（TSP）" class="headerlink" title="6.8.6 H 回路的应用：旅行商问题（TSP）"></a>6.8.6 H 回路的应用：旅行商问题（TSP）</h4><ul>
<li>问题描述：给定一个正权完全图，求总权最小的 H 回路；</li>
</ul>
<blockquote>
<p>NP 完全问题，只能寻找近似解；这里不介绍算法，仅介绍问题；提示：不建议使用贪心法，误差很大；</p>
</blockquote>
<h4 id="6-8-7-有向无环图、AOV网与拓扑排序"><a href="#6-8-7-有向无环图、AOV网与拓扑排序" class="headerlink" title="6.8.7 有向无环图、AOV网与拓扑排序"></a>6.8.7 有向无环图、AOV网与拓扑排序</h4><ul>
<li><p>有向无环图（DAG）：不存在回路的有向图称为<strong>有向无环图</strong>；</p>
</li>
<li><p>AOV网：<strong>有向无环图</strong>中的顶点表示活动，边表示活动间的先后关系，这样的图称为<strong>AOV网</strong>；</p>
</li>
<li><p>拓扑排序：将AOV网中的活动发生的先后次序排成一个序列（如果有一条从 u 到 v 的道路，那么 v 必须出现在 u 之后），称为<strong>拓扑排序</strong>，这个序列称为<strong>拓扑序列</strong>；</p>
</li>
<li><p>拓扑排序实现思路：类似于图的 BFS，但是<strong>只有一个结点的所有直接前驱结点都已访问后，才能访问这个结点</strong>；<strong>$O(|V|+|E|)$</strong></p>
<ol>
<li><p>计算每个结点的入度，保存在数组中；</p>
</li>
<li><p>检查入度数组中<strong>入度为零（无依赖）</strong>的对应结点索引，并将其入队；</p>
</li>
<li><p>当队伍非空时，循环出队并输出这个结点，在假设将这个结点删除，修正这个结点的所有直接结点的入度（减1），如此重复2、3步骤；</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请自行实现私有函数 int _getInDegree(int) 获取入度；</span></span><br><span class="line"><span class="comment">// 使用到了之前的seqQueue类；</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span>* adjListGraph&lt;VType, EType&gt;::<span class="built_in">topoSortIdx</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ans = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;; <span class="type">int</span> ansIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* inDegrees = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; preRequests;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        inDegrees[i] = _getInDegree(i);</span><br><span class="line">        <span class="keyword">if</span> (!inDegrees[i]) preRequests.<span class="built_in">enQueue</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!preRequests.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = preRequests.<span class="built_in">deQueue</span>();</span><br><span class="line">        ans[ansIdx++] = cur;</span><br><span class="line">        eNode* curEdge = vertices[cur].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--inDegrees[curEdge-&gt;end] == <span class="number">0</span>)</span><br><span class="line">                preRequests.<span class="built_in">enQueue</span>(curEdge-&gt;end);</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[i]) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR] A non-DAG does not support topoSort().&quot;</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] ans; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">topoSort</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* seq = <span class="built_in">topoSortIdx</span>();</span><br><span class="line">    <span class="keyword">if</span> (!seq) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        std::cout &lt;&lt; vertices[seq[i]].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-8-8-AOE网与关键路径"><a href="#6-8-8-AOE网与关键路径" class="headerlink" title="6.8.8 AOE网与关键路径"></a>6.8.8 AOE网与关键路径</h4><ul>
<li><p>AOE网络：活动定义在边上（持续时间），事件定义在顶点上；</p>
</li>
<li><p>AOE网络的重要两点：源点（入度为0，工程“起点”）、汇点（出度为0，工程“终点”）；</p>
</li>
<li><p>AOE网络解决的问题：完成整项任务的最少时间、哪些活动是影响工程进度的关键;</p>
</li>
<li><p>关键路径：从源点到汇点的<strong>最长</strong>路径称为<strong>关键路径</strong>；</p>
</li>
<li><p>关键活动：关键路径上的活动。<strong>推迟关键活动必定影响项目进度</strong>；</p>
</li>
<li><p>最早发生时间：用“从源点到该结点的<strong>最长路径</strong>”（因为和拓扑排序一样，只有该结点的所有直接前驱结点都访问过后，才能算访问了这个结点）表征；</p>
</li>
<li><p>最迟发生时间：用“关键路径长(定值) - 从汇点到该结点的<strong>最短路径</strong>”表征（因为是最迟，距离汇点最近才符合定义）；</p>
</li>
<li><p>时间余量：最迟发生时间 - 最早发生时间。<strong>时间余量为0的活动是关键活动（第二定义）</strong>；</p>
</li>
<li><p>找关键路径的思路：（用第二定义）<strong>就是找每个顶点的最早、最迟发生时间，进而得到关键活动、关键路径</strong>；</p>
<ol>
<li><p>找出AOE网的任一拓扑序列；</p>
</li>
<li><p>从头至尾遍历一次拓扑序列，在遍历到 u 时，更新它的<strong>所有</strong>直接后继结点 v 的最早发生时间（如果当前ee值＜u 的值+路径长，那么更新v的ee值为更大的）；</p>
</li>
<li><p>再从尾至头遍历一次拓扑序列，在遍历到 u 时，更新它的<strong>所有</strong>直接后继结点 v 的最迟发生时间（如果后继结点le值＜v 的值+路径长，那么更新为u为更小的）；</p>
<blockquote>
<p>别问为啥不和第二步相对应，找直接前驱结点，问就是找前驱结点复杂度太大了；</p>
<p>⚠<strong>记得更新最迟发生时间之前，要用第二步得到的关键路径长度（就是拓扑序列最后一个结点的ee值）填充最迟发生时间数组</strong>；</p>
</blockquote>
</li>
<li><p>找出所有“最早发生时间=最迟发生时间”的结点，按照拓扑序列的顺序依此输出，即为关键路径；</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">criticalPath</span>(<span class="type">int</span>* early, <span class="type">int</span>* late) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* topoSeq = <span class="built_in">topoSortIdx</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) early[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        eNode* curEdge = vertices[topoSeq[i]].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (early[topoSeq[i]] + curEdge-&gt;weight &gt; early[curEdge-&gt;end])</span><br><span class="line">                early[curEdge-&gt;end] = early[topoSeq[i]] + curEdge-&gt;weight;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pLen = early[topoSeq[<span class="keyword">this</span>-&gt;vertixNum - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) late[i] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">this</span>-&gt;vertixNum - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        eNode* curEdge = vertices[topoSeq[i]].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (late[topoSeq[i]] &gt; late[curEdge-&gt;end] - curEdge-&gt;weight)</span><br><span class="line">                late[topoSeq[i]] = late[curEdge-&gt;end] - curEdge-&gt;weight;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">criticalPath</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ee = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="type">int</span>* le = <span class="keyword">new</span> <span class="type">int</span>[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="type">int</span> pathLen = <span class="built_in">criticalPath</span>(ee, le);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[INFO] The length of the critical path: &quot;</span> &lt;&lt; pathLen &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[INFO] The critical path: \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ee[i] == le[i]) std::cout &lt;&lt; vertices[i].data &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[Fin]\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-8-9-生成树的计数算法"><a href="#6-8-9-生成树的计数算法" class="headerlink" title="6.8.9 生成树的计数算法"></a>6.8.9 生成树的计数算法</h4><blockquote>
<p>原理：Binet-Cauchy 定理：两个矩阵 $A_{m\times n},\space B_{n\times m}\space(m\le n)$，则 $det(AB)=\sum\limits_i{A_iB_i}$ 。其中$A_i$、$B_i$ 分别是从 $A$ 中任取 $m$ 列、$B$ 中任取 $m$ 行构成的行列式；</p>
<p>虽然这样计算行列式有些麻烦，但它揭示了乘积矩阵行列式和各矩阵的子式之间的关系；</p>
<p><span id="genTCount"><strong>定理1：（有向连通图的普通生成树计数）设 $B_k$ 为有向连通图 $G=(V,E)$ 的某一基本关联矩阵，则 $G$ 中不同树的数目为 $det(B_kB_k^T)$</strong>；</span></p>
<ul>
<li>解题提示：如果要求<strong>不含</strong>某个边的生成树数目，只要求将该边删去后的生成子图对应生成树的数目；如果要求<strong>必含</strong>某个边的生成树数目，只要该边的起点终点合并为一点，求新图对应生成树的数目；</li>
</ul>
<p><strong>如果想求无向连通图的生成树个数，需要将其每条边指定一个任意方向转化为有向连通图</strong>；</p>
<ul>
<li><p>推论证明：求证<strong>完全图 $K_n$ 的不同生成树的数目为 $n^{n-2}$</strong>；</p>
<script type="math/tex; mode=display">
det(B_kB_k^T)=\begin{vmatrix}n-1&-1&\cdots&-1\\-1&n-1&\cdots&-1\\\vdots&\vdots&\ddots&\vdots\\-1&-1&\cdots&n-1\end{vmatrix}=n^{n-2}</script></li>
<li><p>⚠易错警示：如果是求<strong>完全图 $K_n$ 不同构的生成树的数目</strong>，和<strong>“不同生成树”</strong>不一样！和化学上<strong>求同分异构体的做法类似</strong>；例如 $K_5$ 的不同构生成树数目为 3，对应有机化学戊烷的正戊烷、异戊烷、新戊烷的构型；</p>
</li>
</ul>
<p><strong>定理2：（有向连通图的根树生成树计数）设 $\overrightarrow{B_k}$ 表示将有向连通图 $G$ 的<u>关于结点 k 的</u>关联矩阵 $B_k$ 中所有的 1 元素换成 0 之后的矩阵，则 $G$ 中<u>以 k 为根的</u>不同根树数目为 $det(\overrightarrow{B_k}B_k^T)$</strong>；</p>
<ul>
<li>解题提示：如果要求<strong>不含</strong>某个边的根树生成树数目，删去这个边再算；</li>
<li>⚠易错警示：和普通生成树不同，如果要求<strong>必含</strong>某个边的根树生成树数目，需要先计算以 v0 为根的总根树数目，再减去不含这个边的生成树数目；<strong>或者求 $G^\prime=G-\{(t,v)|t\ne u\}$</strong> 的根树生成树数目；</li>
</ul>
</blockquote>
<h4 id="6-8-10-生成树的生成算法"><a href="#6-8-10-生成树的生成算法" class="headerlink" title="6.8.10 生成树的生成算法"></a>6.8.10 生成树的生成算法</h4><blockquote>
<p>不作介绍，有兴趣请查阅相关资料，例如《图论与代数结构》清华大学出版社 第3章 3.5节 支撑树的生成；</p>
</blockquote>
<h4 id="6-8-11-最小生成树算法"><a href="#6-8-11-最小生成树算法" class="headerlink" title="6.8.11 最小生成树算法"></a>6.8.11 最小生成树算法</h4><ul>
<li><p>Kruskal 算法</p>
<blockquote>
<p>思路：不断向初始化为空的根结点中加入当前未加入过的最短边，如果构成回路，一定是回路中的最长边，删除它；如果不构成回路则继续，直至达到 n-1 条边为止，此时 T 一定不含任何回路、n-1条边、包含所有图的顶点、所有权最小，在贪心法上是最小生成树；</p>
<p><strong>如何证明这个贪心算法的正确性？</strong></p>
<p>可以证明定理：$T=(V,E’)$ 是赋权连通图 $G=(V,E)$ 的最短树，当且仅当对任意的余树边 $e\in E-E’$，回路 $C^e(C^e\subseteq E’+e)$ 满足：其边权 $w(e)\ge w(a),\space a\in C^e\space(a\ne e)$；</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T &lt;- Φ    // 树根结点初始化为空</span><br><span class="line">while (|T| &lt; n - 1 &amp;&amp; E(G) != Φ) &#123;</span><br><span class="line">    e &lt;- E中最短边</span><br><span class="line">    E &lt;- E - e</span><br><span class="line">    if (T + e 无回路) T &lt;- T + e</span><br><span class="line">&#125;</span><br><span class="line">if (|T| &lt; n - 1) 输出非连通的信息</span><br><span class="line">else return T</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(\varepsilon+p\space log\space\varepsilon),\space其中p为迭代次数$；适用于稀疏图（当p不大时）；</p>
</li>
<li><p>Prim 算法</p>
<blockquote>
<p>思路：在结点集中任选一个结点 v0 构成集合 V’，从 V’ 和 V-V’ 中各选一个顶点 u（来自 V-V’）、v（来自V’）使得 (u, v) 是满足条件的u、v中最短的边，将此边加入树 T，令 V’+=u，直至 V’=V；</p>
<p>感兴趣可以找一找定理的正确性证明；</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t &lt;- v0, T &lt;- Φ, U &lt;- &#123;t&#125;</span><br><span class="line">while (U != V) &#123;</span><br><span class="line">    w(t, u) = min&#123;w(t, v)&#125; where v in (V - U)</span><br><span class="line">    T &lt;- T + e(t, u)</span><br><span class="line">    U &lt;- U + u</span><br><span class="line">    for (v in V - U) w(t, v) &lt;- min&#123;w(t, v), w(u, v)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(\nu^2)$；适用于稠密图；</p>
</li>
</ul>
<h3 id="6-9-常见题型和易错点"><a href="#6-9-常见题型和易错点" class="headerlink" title="6.9 常见题型和易错点"></a>6.9 常见题型和易错点</h3><p>⚠易错点</p>
<ul>
<li><p>导航适合使用<strong>有向多重图</strong>表示；</p>
</li>
<li><p>简单道路/回路<strong>可以针对非简单图</strong>，意味着可以经过自环、重边，但仅能经过一次；</p>
</li>
<li><p>平凡图一定是简单道路、初级道路，一定不是回路；</p>
</li>
<li><p>一个点很重要，虽然不知道有啥用：<strong>每个格雷码对应 n-cube $Q_n$ 上的一条 H 回路</strong>；</p>
</li>
<li><p>n 个结点的<strong>连通的简单平面图</strong>的边数 $m\le 3n-6$；</p>
</li>
<li><p>另一点涉及群论的知识，n 个结点组成的简单无向图的数目为 $2^{n(n-1)/2}$；</p>
<p>这些图里面互不同构的图的数量又为 $|X/G|=\sum\limits_b\dfrac{2^k}{\prod(b_i)\prod(c_i!)}$，其中 $k=\sum\limits_{i=1}^K\lfloor\dfrac{b_i}{2}\rfloor+\sum\limits_{i=1}^K\sum\limits_{j=1}^{i-1}gcd(b_i,b_j)$，$K$ 为将置换群拆为循环的个数（DFS计数）；</p>
<p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://oeis.org/A000088">A000088🔗</a>，计算结论：1，2，4，11，34，156，1044，……</p>
</li>
</ul>
<p>ℹ常见题型</p>
<ul>
<li>根据图的所有定理，判断/证明一定数量的结点度、结点数、边数等数量间的关系；</li>
<li>根据原图指出生成子图、导出子图；</li>
<li>给定一个图，判断是否有欧拉道路/回路、哈密顿回路/道路；</li>
<li>给定一个图，判断道路/回路、简单道路/回路、初级道路/回路；</li>
<li>给定一个图，判断连通分量、强连通分量；</li>
<li>给定一个图，找出哈夫曼编码；</li>
<li>给定一个图，找出最小生成树；</li>
</ul>
<h2 id="附录A：部分C-代码实现"><a href="#附录A：部分C-代码实现" class="headerlink" title="附录A：部分C++代码实现"></a>附录A：部分C++代码实现</h2><h3 id="A-1-图的存储实现"><a href="#A-1-图的存储实现" class="headerlink" title="A.1 图的存储实现"></a>A.1 图的存储实现</h3><ol>
<li><p>邻接矩阵存储法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjMatrixGraph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VType* vertices;    <span class="comment">// store the data of each vertex.</span></span><br><span class="line">    EType** edges;      <span class="comment">// store the data of each edge (in adjacent matrix form).</span></span><br><span class="line">    EType noEdgeFlag;    <span class="comment">// represent the no-edge area.</span></span><br><span class="line">    <span class="type">int</span> vertixNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vertexIdx</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertixNum; ++i)</span><br><span class="line">            <span class="keyword">if</span> (vertices[i] == v) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">vertexNotExists</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">bool</span> visited[])</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">adjMatrixGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">const</span> EType&amp; noEdge);</span><br><span class="line">    <span class="built_in">adjMatrixGraph</span>(<span class="type">const</span> adjMatrixGraph&lt;VType, EType&gt;&amp; cp) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">adjMatrixGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjMatrix</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_nonRecur</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>邻接表存储法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjListGraph</span>: <span class="keyword">public</span> graph&lt;VType, EType&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        EType weight;</span><br><span class="line">        eNode* next;</span><br><span class="line">        <span class="built_in">eNode</span>(): <span class="built_in">end</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">eNode</span>(<span class="type">const</span> EType&amp; w, <span class="type">int</span> e=<span class="number">0</span>, eNode* nxt=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">weight</span>(w), <span class="built_in">end</span>(e), <span class="built_in">next</span>(nxt) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">vNode</span> &#123;</span><br><span class="line">        VType data;</span><br><span class="line">        eNode* edge;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EulerNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> nodeIdx;</span><br><span class="line">        EulerNode* next;</span><br><span class="line">        <span class="built_in">EulerNode</span>(<span class="type">int</span> idx=<span class="number">0</span>, EulerNode* n=<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">nodeIdx</span>(idx), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vNode* vertices;</span><br><span class="line">    <span class="type">bool</span> directed;</span><br><span class="line">    <span class="type">int</span> vertixNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vertexIdx</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertixNum; ++i)</span><br><span class="line">            <span class="keyword">if</span> (vertices[i].data == v) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">vertexNotExists</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typename</span> adjListGraph&lt;VType, EType&gt;::<span class="function">vNode* <span class="title">cloneBase</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">bool</span> visited[])</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _insert(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">const</span> EType&amp; w);</span><br><span class="line">    <span class="type">void</span> _remove(<span class="type">int</span> v1, <span class="type">int</span> v2);</span><br><span class="line">    <span class="type">int</span> _getInDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> _getOutDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> _getDegree(<span class="type">int</span> v) <span class="type">const</span>;</span><br><span class="line">    <span class="type">void</span> _EulerCircuit(<span class="type">int</span> start, EulerNode*&amp; begin, EulerNode*&amp; end);</span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">topoSortIdx</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">criticalPath</span><span class="params">(<span class="type">int</span>* early, <span class="type">int</span>* late)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> prev[])</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">adjListGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">bool</span> direct=<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">adjListGraph</span>(<span class="type">const</span> adjListGraph&lt;VType, EType&gt;&amp; cp);</span><br><span class="line">    <span class="built_in">adjListGraph</span>(adjListGraph&lt;VType, EType&gt;&amp;&amp; tmp);</span><br><span class="line">    ~<span class="built_in">adjListGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getInDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getOutDegree</span><span class="params">(<span class="type">const</span> VType&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjList</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_nonRecur</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_dfs_tree</span><span class="params">(<span class="type">const</span> VType&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_bfs_tree</span><span class="params">(<span class="type">const</span> VType&amp; emptyFlag)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EulerCircuit</span><span class="params">(<span class="type">const</span> VType&amp; start)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">criticalPath</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// The shortest path for the graph: O(n^3)</span></span><br><span class="line">    <span class="function">VType* <span class="title">dijkstra</span><span class="params">(<span class="type">const</span> VType&amp; start, <span class="type">const</span> EType&amp; noEdge, <span class="type">bool</span> prompt=<span class="literal">false</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">VType* <span class="title">SPFA</span><span class="params">(<span class="type">const</span> VType&amp; start, <span class="type">const</span> EType&amp; noEdge)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="A-2-图的运算实现"><a href="#A-2-图的运算实现" class="headerlink" title="A.2 图的运算实现"></a>A.2 图的运算实现</h3><ol>
<li><p>邻接矩阵表示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">adjMatrixGraph</span>(</span><br><span class="line">    <span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">const</span> EType&amp; noEdge) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = vSize; <span class="keyword">this</span>-&gt;edgeNum = <span class="number">0</span>; noEdgeFlag = noEdge;</span><br><span class="line">    vertices = <span class="keyword">new</span> VType[vSize];</span><br><span class="line">    edges = <span class="keyword">new</span> EType*[vSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vSize; ++i) &#123;</span><br><span class="line">        vertices[i] = vers[i];</span><br><span class="line">        edges[i] = <span class="keyword">new</span> EType[vSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vSize; ++j)</span><br><span class="line">            edges[i][j] = noEdge;</span><br><span class="line">        edges[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjMatrixGraph&lt;VType, EType&gt;::~<span class="built_in">adjMatrixGraph</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] vertices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] edges[i];</span><br><span class="line">    <span class="keyword">delete</span>[] edges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">bool</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">exist</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">return</span> edges[u][v] != noEdgeFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">undirected_insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    <span class="keyword">if</span> (edges[v][u] == noEdgeFlag) ++<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = edges[v][u] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">remove</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> (edges[u][v] != noEdgeFlag) --<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    edges[u][v] = noEdgeFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">printAdjMatrix</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j)</span><br><span class="line">            std::cout &lt;&lt; edges[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>邻接表表示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(<span class="type">int</span> vSize, <span class="type">const</span> VType vers[], <span class="type">bool</span> direct) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = vSize; directed = direct;</span><br><span class="line">    <span class="keyword">this</span>-&gt;edgeNum = <span class="number">0</span>; vertices = <span class="keyword">new</span> vNode[vSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vSize; ++i) &#123;</span><br><span class="line">        vertices[i].data = vers[i];</span><br><span class="line">        vertices[i].edge = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::~<span class="built_in">adjListGraph</span>() &#123;</span><br><span class="line">    eNode* curEdge;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curEdge = vertices[i].edge) &#123;</span><br><span class="line">            vertices[i].edge = curEdge-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> curEdge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vertices) <span class="keyword">delete</span>[] vertices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> adjListGraph&lt;VType, EType&gt;::vNode* adjListGraph&lt;VType, EType&gt;::<span class="built_in">cloneBase</span>() <span class="type">const</span> &#123;</span><br><span class="line">    vNode* newVers = <span class="keyword">new</span> vNode[<span class="keyword">this</span>-&gt;vertixNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        newVers[i].data = vertices[i].data;</span><br><span class="line">        newVers[i].edge = <span class="literal">nullptr</span>;</span><br><span class="line">        eNode** curEdgeDst = &amp;(newVers[i].edge);</span><br><span class="line">        eNode* curEdgeSrc = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdgeSrc) &#123;</span><br><span class="line">            *curEdgeDst = <span class="keyword">new</span> <span class="built_in">eNode</span>(curEdgeSrc-&gt;weight, curEdgeSrc-&gt;end, <span class="number">0</span>);</span><br><span class="line">            curEdgeDst = &amp;((*curEdgeDst)-&gt;next);</span><br><span class="line">            curEdgeSrc = curEdgeSrc-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newVers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(<span class="type">const</span> adjListGraph&lt;VType, EType&gt;&amp; cp) &#123;</span><br><span class="line">    vertices = cp.<span class="built_in">cloneBase</span>(); <span class="keyword">this</span>-&gt;edgeNum = cp.edgeNum;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertixNum = cp.vertixNum; directed = cp.directed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line">adjListGraph&lt;VType, EType&gt;::<span class="built_in">adjListGraph</span>(adjListGraph&lt;VType, EType&gt;&amp;&amp; tmp) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;edgeNum = tmp.edgeNum; <span class="keyword">this</span>-&gt;vertixNum = tmp.vertixNum; directed = tmp.directed;</span><br><span class="line">    tmp.edgeNum = tmp.vertixNum = <span class="number">0</span>; vertices = tmp.vertices; tmp.vertices = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">bool</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">exist</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    <span class="type">const</span> eNode* cur = vertices[u].edge;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;end == v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::_insert(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    eNode** cur = &amp;(vertices[v1].edge);</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;end != v2) cur = &amp;((*cur)-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (!(*cur)) &#123; ++<span class="keyword">this</span>-&gt;edgeNum; *cur = <span class="keyword">new</span> <span class="built_in">eNode</span>(w, v2); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::_remove(<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">    eNode** cur = &amp;(vertices[v1].edge);</span><br><span class="line">    <span class="keyword">while</span> (*cur &amp;&amp; (*cur)-&gt;end != v2) cur = &amp;((*cur)-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (*cur) &#123;</span><br><span class="line">        eNode* tmp = *cur; *cur = (*cur)-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp; --<span class="keyword">this</span>-&gt;edgeNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">insert</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2, <span class="type">const</span> EType&amp; w) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    _insert(u, v, w);</span><br><span class="line">    <span class="keyword">if</span> (!directed) _insert(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">remove</span>(<span class="type">const</span> VType&amp; v1, <span class="type">const</span> VType&amp; v2) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">vertexIdx</span>(v1), v = <span class="built_in">vertexIdx</span>(v2);</span><br><span class="line">    _remove(u, v);</span><br><span class="line">    <span class="keyword">if</span> (!directed) _remove(v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getInDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == v) <span class="keyword">continue</span>;</span><br><span class="line">        eNode* curEdge = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEdge-&gt;end == v) ++ans;</span><br><span class="line">            curEdge = curEdge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getOutDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    eNode* target = vertices[v].edge;</span><br><span class="line">    <span class="keyword">while</span> (target) &#123; ++ans; target = target-&gt;next; &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::_getDegree(<span class="type">int</span> v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (directed) <span class="keyword">return</span> _getInDegree(v) + _getOutDegree(v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> _getOutDegree(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getInDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getInDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">int</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">getOutDegree</span>(<span class="type">const</span> VType&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getOutDegree(<span class="built_in">vertexIdx</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">printAdjList</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; vertices[i].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">const</span> eNode* cur = vertices[i].edge;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;|-w=&quot;</span> &lt;&lt; cur-&gt;weight</span><br><span class="line">                &lt;&lt; <span class="string">&quot;-&gt;(&quot;</span> &lt;&lt; cur-&gt;end &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="A-3-图的遍历算法"><a href="#A-3-图的遍历算法" class="headerlink" title="A.3 图的遍历算法"></a>A.3 图的遍历算法</h3><ol>
<li><p>DFS：邻接表表示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>(<span class="type">int</span> start, <span class="type">bool</span> visited[]) <span class="type">const</span> &#123;</span><br><span class="line">    eNode* curEdge = vertices[start].edge;</span><br><span class="line">    std::cout &lt;&lt; vertices[start].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[curEdge-&gt;end]) <span class="built_in">dfs</span>(curEdge-&gt;end, visited);</span><br><span class="line">        curEdge = curEdge-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">dfs_nonRecur</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; tasks;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// Necessary when doing non-recursive op.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            eNode* curEdge = vertices[tmp].edge;</span><br><span class="line">            <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[curEdge-&gt;end])</span><br><span class="line">                    tasks.<span class="built_in">push</span>(curEdge-&gt;end);</span><br><span class="line">                curEdge = curEdge-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>DFS：邻接矩阵表示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>(<span class="type">int</span> start, <span class="type">bool</span> visited[]) <span class="type">const</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; vertices[start] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i] &amp;&amp; edges[start][i] != noEdgeFlag)</span><br><span class="line">            <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, visited);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">dfs_nonRecur</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; tasks;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;</span><br><span class="line">            std::cout &lt;&lt; vertices[tmp] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tmp + <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; edges[tmp][j] != noEdgeFlag)</span><br><span class="line">                    tasks.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>BFS：邻接表表示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjListGraph&lt;VType, EType&gt;::<span class="built_in">bfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; taskQ;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        taskQ.<span class="built_in">enQueue</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!taskQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = taskQ.<span class="built_in">deQueue</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// necessary.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp].data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            eNode* curEdge = vertices[tmp].edge;</span><br><span class="line">            <span class="keyword">while</span> (curEdge) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[curEdge-&gt;end])</span><br><span class="line">                    taskQ.<span class="built_in">enQueue</span>(curEdge-&gt;end);</span><br><span class="line">                curEdge = curEdge-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>BFS：邻接矩阵表示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">VType</span>, <span class="keyword">class</span> <span class="title class_">EType</span>&gt;</span><br><span class="line"><span class="type">void</span> adjMatrixGraph&lt;VType, EType&gt;::<span class="built_in">bfs</span>() <span class="type">const</span> &#123;</span><br><span class="line">    seqQueue&lt;<span class="type">int</span>&gt; taskQ;</span><br><span class="line">    <span class="type">bool</span>* visited = <span class="keyword">new</span> <span class="type">bool</span>[<span class="keyword">this</span>-&gt;vertixNum] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;vertixNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        taskQ.<span class="built_in">enQueue</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!taskQ.<span class="built_in">isempty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = taskQ.<span class="built_in">deQueue</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[tmp]) <span class="keyword">continue</span>;     <span class="comment">// necessary when doing no-recursive op.</span></span><br><span class="line">            std::cout &lt;&lt; vertices[tmp] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            visited[tmp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tmp + <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;vertixNum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; edges[tmp][j] != noEdgeFlag)</span><br><span class="line">                    taskQ.<span class="built_in">enQueue</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="本文的-PDF-文档下载"><a href="#本文的-PDF-文档下载" class="headerlink" title="本文的 PDF 文档下载"></a>本文的 PDF 文档下载</h2><p>遇到不习惯、网页观看体验不好的，可以下载本文的 <a href="DM.pdf">PDF 文档📎</a> 进行阅读，使用时请勿传播，感谢配合！</p>
<p>———————————-EOF——————————-</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SJTU-XHW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/review/discrete-math/">https://blog.sjtuxhw.top/review/discrete-math/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SJTU-XHW's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Discrete-Math/">Discrete-Math</a><a class="post-meta__tags" href="/tags/Graph/">Graph</a><a class="post-meta__tags" href="/tags/Logic/">Logic</a><a class="post-meta__tags" href="/tags/Set-Theory/">Set-Theory</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/dm.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/chat/planning-flag/" title="一个FLAG"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/flag.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">一个FLAG</div></div><div class="info-2"><div class="info-item-1">最近期末考试终于结束了，想到又能将自己的时间分配在自己需要的方面（例如写博客），又是一件令人振奋人心的事情！只可惜大学生的暑假竟然会被老师布置的作业充斥，这真是从未想到 😂  在前天最后一门考试结束后，我迅速进入放松状态，和室友打了整整两天的 MC（感觉有点放纵……于是，在导师的建议下，我得快速开始制定一些计划，防止我过于颓废 [doge]. 咳咳，好的朋友们，我现在要立下一个大 flag：我将在暑假结束前完成我制定的所有计划和任务，鼓足干劲，绝不颓废！ 下定决心，以此博客为证！ </div></div></div></a><a class="pagination-related" href="/review/data-structure-4/" title="数据结构复习-第四部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds4.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数据结构复习-第四部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN   Chapter 8 外部查找和排序8.1 零碎概念集合 内存与外存的特性：外存读取访问速率 &lt;&lt; 内存访问速率； 尽可能避免访问，宁可增加计算量……  记录：外存上的一个数据元素通常被称为一条记录；  磁道：磁盘表面储存信息的同心圆轨道；  扇区：磁盘的磁道被分为若干段，每段被称为一个扇区；  一个扇区相当于磁带上的一个数据块，也称磁盘块，是一次磁盘读写的单位；    8.2 B 树 定义：存储在外存上的动态查找表： 一棵 m 阶 B 树或者为空，或者满足：  根结点的度 $d_r\in\{0\}\space\bigcup\space[2,\space m]$；  除了根结点和叶结点外，每个结点的度 $d\in[\space\lceil\dfrac{m}{2}\rceil,\space m\space]$；  度为s（s＞0）的结点具有 n = s-1 个关键字，信息存放方式：...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/review/data-structure-4/" title="数据结构复习-第四部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ds4.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-27</div><div class="info-item-2">数据结构复习-第四部分</div></div><div class="info-2"><div class="info-item-1">本系列文章为作者复习数据结构过程中的知识点总结、速通，欢迎补充 Written by SJTU-XHW Reference: 张同珍老师 PPT | UNIkeEN   Chapter 8 外部查找和排序8.1 零碎概念集合 内存与外存的特性：外存读取访问速率 &lt;&lt; 内存访问速率； 尽可能避免访问，宁可增加计算量……  记录：外存上的一个数据元素通常被称为一条记录；  磁道：磁盘表面储存信息的同心圆轨道；  扇区：磁盘的磁道被分为若干段，每段被称为一个扇区；  一个扇区相当于磁带上的一个数据块，也称磁盘块，是一次磁盘读写的单位；    8.2 B 树 定义：存储在外存上的动态查找表： 一棵 m 阶 B 树或者为空，或者满足：  根结点的度 $d_r\in\{0\}\space\bigcup\space[2,\space m]$；  除了根结点和叶结点外，每个结点的度 $d\in[\space\lceil\dfrac{m}{2}\rceil,\space m\space]$；  度为s（s＞0）的结点具有 n = s-1 个关键字，信息存放方式：...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SJTU-XHW</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-1-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91"><span class="toc-text">Chapter 1 命题逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E6%B1%87%E6%80%BB"><span class="toc-text">1.1 重要概念汇总</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9A%84%E6%8E%A8%E7%90%86%E5%BD%A2%E5%BC%8F"><span class="toc-text">1.2 命题逻辑的推理形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%80%83%E7%82%B9%E5%92%8C%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B"><span class="toc-text">1.3 考点和常见题型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E9%94%99%E9%A2%98"><span class="toc-text">1.4 错题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-2-%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91%EF%BC%88%E4%B8%80%E9%98%B6%EF%BC%89"><span class="toc-text">Chapter 2 谓词逻辑（一阶）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E9%9B%86%E5%90%88"><span class="toc-text">2.1 重要概念集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%B0%93%E8%AF%8D%E6%BC%94%E7%AE%97%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E7%90%86%E6%BC%94%E7%AE%97"><span class="toc-text">2.2 谓词演算公式的推理演算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B"><span class="toc-text">2.3 常见题型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-%E9%9B%86%E5%90%88%E8%AE%BA"><span class="toc-text">Chapter 3 集合论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E9%9B%86%E5%90%88"><span class="toc-text">3.1 重要概念集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B"><span class="toc-text">3.2 常见题型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%94%99%E9%A2%98"><span class="toc-text">3.3 错题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-4-%E5%85%B3%E7%B3%BB"><span class="toc-text">Chapter 4 关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E9%9B%86%E5%90%88"><span class="toc-text">4.1 重要概念集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B"><span class="toc-text">4.2 常见题型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-5-%E5%87%BD%E6%95%B0"><span class="toc-text">Chapter 5 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">5.1 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B"><span class="toc-text">5.2 常见题型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%94%99%E9%A2%98"><span class="toc-text">5.3 错题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-6-%E5%9B%BE%E8%AE%BA"><span class="toc-text">Chapter 6 图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%9B%BE%E8%AE%BA%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E2%85%A0"><span class="toc-text">6.1 图论中的重要定义Ⅰ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84"><span class="toc-text">6.2 图的同构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.3 图的存储实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E5%9B%BE%E7%9A%84%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.4 图的运算实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%9B%BE%E8%AE%BA%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E2%85%A1"><span class="toc-text">6.5 图论中的重要定义Ⅱ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E5%9B%BE%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8"><span class="toc-text">6.6 图的简单应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E5%9B%BE%E8%AE%BA%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E2%85%A2"><span class="toc-text">6.7 图论中的重要定义Ⅲ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E5%9B%BE%E7%9A%84%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95"><span class="toc-text">6.8 图的经典算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-1-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-text">6.8.1 图的遍历算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-2-%E4%B8%A4%E7%82%B9%E9%97%B4%E9%81%93%E8%B7%AF%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95"><span class="toc-text">6.8.2 两点间道路判定算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-3-%E6%9C%89%E5%90%91%E5%9B%BE%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E6%94%AF%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95"><span class="toc-text">6.8.3 有向图强连通分支判断算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-4-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="toc-text">6.8.4 欧拉回路的构造算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-5-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E4%B8%AD%E5%9B%BD%E9%82%AE%E9%80%92%E5%91%98%E9%97%AE%E9%A2%98%EF%BC%88CPP%EF%BC%89"><span class="toc-text">6.8.5 欧拉回路的应用：中国邮递员问题（CPP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-6-H-%E5%9B%9E%E8%B7%AF%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%EF%BC%88TSP%EF%BC%89"><span class="toc-text">6.8.6 H 回路的应用：旅行商问题（TSP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-7-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E3%80%81AOV%E7%BD%91%E4%B8%8E%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">6.8.7 有向无环图、AOV网与拓扑排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-8-AOE%E7%BD%91%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-text">6.8.8 AOE网与关键路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-9-%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">6.8.9 生成树的计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-10-%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="toc-text">6.8.10 生成树的生成算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-11-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="toc-text">6.8.11 最小生成树算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%E5%92%8C%E6%98%93%E9%94%99%E7%82%B9"><span class="toc-text">6.9 常见题型和易错点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95A%EF%BC%9A%E9%83%A8%E5%88%86C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">附录A：部分C++代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-1-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">A.1 图的存储实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-2-%E5%9B%BE%E7%9A%84%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">A.2 图的运算实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-text">A.3 图的遍历算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E7%9A%84-PDF-%E6%96%87%E6%A1%A3%E4%B8%8B%E8%BD%BD"><span class="toc-text">本文的 PDF 文档下载</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ml-roadmap.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识图谱：Machine Learning Roadmap"/></a><div class="content"><a class="title" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap">知识图谱：Machine Learning Roadmap</a><time datetime="2025-06-08T06:59:31.000Z" title="发表于 2025-06-08 14:59:31">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"/></a><div class="content"><a class="title" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</a><time datetime="2025-05-30T08:49:12.000Z" title="发表于 2025-05-30 16:49:12">2025-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/tee-lab.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机密计算与TEE：知识整理和试验笔记"/></a><div class="content"><a class="title" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记">机密计算与TEE：知识整理和试验笔记</a><time datetime="2025-04-17T15:31:36.000Z" title="发表于 2025-04-17 23:31:36">2025-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/rust-owner/" title="另一个角度看 Rust 所有权和借用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/rust-owner.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="另一个角度看 Rust 所有权和借用"/></a><div class="content"><a class="title" href="/technical/rust-owner/" title="另一个角度看 Rust 所有权和借用">另一个角度看 Rust 所有权和借用</a><time datetime="2025-04-06T12:20:14.000Z" title="发表于 2025-04-06 20:20:14">2025-04-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/io-mul-more/" title="更多的 I/O 多路复用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/io-mult-more.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="更多的 I/O 多路复用"/></a><div class="content"><a class="title" href="/review/io-mul-more/" title="更多的 I/O 多路复用">更多的 I/O 多路复用</a><time datetime="2025-04-01T04:13:25.000Z" title="发表于 2025-04-01 12:13:25">2025-04-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SJTU-XHW  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Powered By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>