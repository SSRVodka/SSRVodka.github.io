<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CSAPP Notes: Scheduler &amp; Arch | SJTU-XHW's blog</title><meta name="author" content="SJTU-XHW,sjtuxhw12345@sjtu.edu.cn"><meta name="copyright" content="SJTU-XHW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chapter 8. Scheduler in OS为操作系统的调度环境作出假设：  Each job runs for the same amount of time All jobs arrive at the same time Once started, each job runs to completion All jobs only use the CPU  i.e., they pe">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP Notes: Scheduler &amp; Arch">
<meta property="og:url" content="https://blog.sjtuxhw.top/review/csapp-sched-arch/index.html">
<meta property="og:site_name" content="SJTU-XHW&#39;s blog">
<meta property="og:description" content="Chapter 8. Scheduler in OS为操作系统的调度环境作出假设：  Each job runs for the same amount of time All jobs arrive at the same time Once started, each job runs to completion All jobs only use the CPU  i.e., they pe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/csapp_p2.png">
<meta property="article:published_time" content="2023-11-11T01:18:11.000Z">
<meta property="article:modified_time" content="2024-10-25T13:54:37.791Z">
<meta property="article:author" content="SJTU-XHW">
<meta property="article:tag" content="GNU">
<meta property="article:tag" content="CSAPP">
<meta property="article:tag" content="ICS">
<meta property="article:tag" content="Programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/csapp_p2.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/review/csapp-sched-arch/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CSAPP Notes: Scheduler & Arch',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><link rel="stylesheet" href="/css/talk.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SJTU-XHW's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/csapp_p2.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SJTU-XHW's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">CSAPP Notes: Scheduler &amp; Arch</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CSAPP Notes: Scheduler &amp; Arch</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-11T01:18:11.000Z" title="发表于 2023-11-11 09:18:11">2023-11-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T13:54:37.791Z" title="更新于 2024-10-25 21:54:37">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/review/">review</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/review/csapp-sched-arch/#post-comment"><span class="waline-comment-count" data-path="/review/csapp-sched-arch/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Chapter-8-Scheduler-in-OS"><a href="#Chapter-8-Scheduler-in-OS" class="headerlink" title="Chapter 8. Scheduler in OS"></a>Chapter 8. Scheduler in OS</h1><p>为操作系统的调度环境作出假设：</p>
<ol>
<li>Each job runs for the same amount of time</li>
<li>All jobs arrive at the same time</li>
<li>Once started, each job runs to completion</li>
<li>All jobs only use the CPU <ul>
<li>i.e., they perform no I/O</li>
</ul>
</li>
<li>The run-time of each job is known</li>
</ol>
<p><u>引入调度优劣衡量指标：周转时间</u>，<strong>$T_{turnaround}=T_{completion}-T_{arrival}$</strong>；</p>
<h2 id="Strategy-1-FIFO（FCFS，First-Come-First-Served）"><a href="#Strategy-1-FIFO（FCFS，First-Come-First-Served）" class="headerlink" title="Strategy 1: FIFO（FCFS，First Come First Served）"></a>Strategy 1: FIFO（FCFS，First Come First Served）</h2><ul>
<li>Implementation: queue；</li>
<li>消除假设 1：若短时任务排在长时任务之后，则平均周转时间效果很差；</li>
</ul>
<h2 id="Strategy-2-SJF（Shortest-Job-First）"><a href="#Strategy-2-SJF（Shortest-Job-First）" class="headerlink" title="Strategy 2 : SJF（Shortest Job First）"></a>Strategy 2 : SJF（Shortest Job First）</h2><ul>
<li>内容：对于<strong>同时到达的</strong>任务，优先选择总时长小的任务。</li>
<li>作用：（应对假设 1 的消除）缓解了<strong>短时任务排在长时任务之后所造成的较差的平均周转时间</strong>；</li>
<li>消除假设 2：不同任务到达的时间不一样。如果短时任务出现在长时任务开始后的很短的时间内，那么平均周转时间也很差（<strong>一般没有竞争抢占机制，具体请看题目要求</strong>）；</li>
</ul>
<h2 id="Strategy-3-STCF（Shortest-Time-to-Completion-First）"><a href="#Strategy-3-STCF（Shortest-Time-to-Completion-First）" class="headerlink" title="Strategy 3 : STCF（Shortest Time-to-Completion First）"></a>Strategy 3 : STCF（Shortest Time-to-Completion First）</h2><ul>
<li>内容和作用：（应对假设 2 的消除）竞争抢占机制（<strong>preemptive</strong>），晚到达的短时任务如果<strong>执行剩余时间</strong>短于长时任务的剩余时间，则进行抢占切换；</li>
<li><u><strong>添加一个衡量标准</strong>：Response Time（反应时间）</u>；<ul>
<li>the time from when the job arrives in a system to the first time it is scheduled;</li>
<li><strong>$T_{resp}=T_{firstturn}-T_{arrival}$</strong>;</li>
</ul>
</li>
<li>STCF 在 Response Time 中，如果恰好各个任务消耗的时间相近，它们无法抢占，但是抢占时间会很大；</li>
</ul>
<h2 id="Strategy-4-Round-Robin（时间片轮转）"><a href="#Strategy-4-Round-Robin（时间片轮转）" class="headerlink" title="Strategy 4 : Round Robin（时间片轮转）"></a>Strategy 4 : Round Robin（时间片轮转）</h2><ul>
<li>作用：（提升 Response Time）设计<strong>时间片（Time slice）</strong>，每个任务最多只能执行一段时间的代码，超时则切换到其他进程，使用上面的切换策略；</li>
<li>注意点：合理设计时间片长度（10ms），防止频繁的切换操作占用大量资源（switching cost）；</li>
<li>与 SJF 策略比较：有利有弊；</li>
<li>消除假设 4：任务可能存在 I/O 操作，耗时操作导致该进程很多时间片空闲；</li>
</ul>
<h2 id="Strategy-5-Overlap-when-performing-I-O-operation"><a href="#Strategy-5-Overlap-when-performing-I-O-operation" class="headerlink" title="Strategy 5 : Overlap when performing I/O operation"></a>Strategy 5 : Overlap when performing I/O operation</h2><ul>
<li>内容：当发生 I/O 操作时，应用必然调用系统调用，操作系统可以将此任务 block 进入 stopped 状态，并进行 context switch；</li>
<li>作用：在进行 I/O 操作时发生 switch，充分利用 I/O 操作的空隙，进行有效的 overlap；</li>
<li>消除假设 5：任务的运转时间未知，相当于无法比较任务是短时任务还是长时任务（例如交互式任务）；</li>
</ul>
<h2 id="Strategy-6-Multi-Level-Feedback-Queue-Scheduler（MLFQ）"><a href="#Strategy-6-Multi-Level-Feedback-Queue-Scheduler（MLFQ）" class="headerlink" title="Strategy 6 : Multi-Level Feedback Queue Scheduler（MLFQ）"></a>Strategy 6 : Multi-Level Feedback Queue Scheduler（MLFQ）</h2><ul>
<li><p>作用：1. <strong>优化未知任务时长（without a priority knowledge of job length）情况下的周转时间</strong>；2. <strong>最小化响应时间（在用户交互式应用中很重要）</strong>；</p>
</li>
<li><p>如何在<strong>没有先验知识</strong>的情况下，做出最合适的任务调度？</p>
<ol>
<li><p><strong>Learning from history</strong>：从系统运行程序的特性中做出猜测（类似分支预测器）；</p>
<ul>
<li>the multi-level feedback queue;</li>
</ul>
</li>
<li><p><strong>优先级预测队列</strong>策略：</p>
<p>Rule 1：任务队列使用<strong>多个队列，每个队列的优先级不同，同样队列中的任务优先级相同</strong>，<strong>优先级高的队列中的任务请求资源时，先于优先级低的任务</strong>；</p>
<p>Rule 2：如果两个任务处于同一优先级，则二者使用 <strong>Round Robin</strong> 策略；</p>
<blockquote>
<p>接下来需要考虑优先级的设置和改变问题。</p>
<p>考虑到 workload 同时含有 <strong>交互式任务</strong>（interactive jobs，CPU 使用时间一般很短，例如用户交互）和 <strong>CPU 密集型任务</strong>（CPU-bound，CPU 使用时间一般很长，例如矩阵计算，一般对 response time 要求不高）；</p>
</blockquote>
<p>Rule 3：当一个任务进入系统任务队列时，<strong>最先总是放到最高优先级</strong>；</p>
<p>Rule 4a：如果一个任务耗尽了一个周期中的所有时间片，那么 CPU 可以认为这个任务<strong>更有可能</strong>是个 CPU-bound job，那么<strong>先降低一个优先级，直到最低优先级</strong>；</p>
<p>Rule 4b：如果一个任务没有耗尽一个周期的时间片就释放 CPU 资源，那么 CPU 可以认为这个任务<strong>更有可能</strong>是一个 interactive job，那么<strong>保持在当前优先级</strong>；</p>
</li>
</ol>
</li>
<li><p>缺陷：</p>
<ol>
<li><strong>Starvation</strong>：如果有非常多的 interactive jobs 同时运行在最高优先级，那么<strong>很有可能导致最低优先级的 CPU-bound jobs 始终无法得到 CPU 资源</strong>；</li>
<li><strong>Gaming scheduler attack</strong>：一些恶意程序可能利用这个策略，设计占用大部分时间片内容，但在结束前释放 CPU 资源，这样会一直保持最高优先级，并且妨碍其他程序运行；</li>
<li><strong>Programs may change its behavior overtime</strong>：一些任务可能在 interactive 与 CPU-bound 的特性间相互转换；</li>
</ol>
</li>
<li><p>改进</p>
<ul>
<li><p>Rule 5（<strong>Priority Boost</strong>）：当某个时间周期 <strong>S</strong> 后，将所有任务都移动到<strong>最高优先级</strong>；</p>
<blockquote>
<p>好处 1：解决缺陷 1，消除 starvation 现象，保证每个进程都会被调度到；</p>
<p>好处 2：解决缺陷 3，方便 MLFQ 重新评定各个进程的 priority（保证 interactive / CPU-bound 相互转换的程序被分配到合适的优先级）；</p>
</blockquote>
</li>
<li><p><strong>Refined</strong> Rule 4（<strong>Better Accounting</strong>）：任务在<strong>当前优先级中的全部运行时间累积计算</strong>，以累积的时间长短作为是否降低优先级的评判标准；</p>
<blockquote>
<p>好处：解决缺陷 2，故意保留一个时间片剩余时间的程序，如果总 CPU 用时很长，也会被降低优先级；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>具体实现：MLFQ 具体的参数是怎样的？怎么落实它的参数？</p>
<ul>
<li>MLFQ 应该有几个队列（几个优先级）？</li>
<li>时间片长短的设计：每个优先级的任务的时间片长度应该多长？</li>
<li>进行 Priority Boost 的频率应该如何？（既能保证不过度更新浪费资源，又能保证减小 starvation 和 changes in behavior 导致运行效率减慢的可能？）</li>
</ul>
</li>
<li><p>Tuning 与 微调</p>
<p>针对以上 tuning MLFQ 使其最大化系统性能的过程<strong>没有一个固定的最优解</strong>。大多数情况需要进行调参、凭借经验取定。</p>
<p>不过有一些通识的点，满足这些点的参数设计一定能够更好提升 MLFQ 的性能：</p>
<ul>
<li><p>对于<strong>高优先级的</strong>任务，分配给其的时间片时间应该更<strong>短</strong>些为佳；</p>
<p>它们通常较少地使用 CPU 资源，可能是 interactive 类型地任务，切换得更频繁；</p>
</li>
<li><p>对于<strong>低优先级的</strong>任务，分配给其的时间片时间应该更<strong>长</strong>些为佳；</p>
<p>它们通常是 CPU-bound 类型任务，分配更长的时间片能够更好地完成任务；</p>
</li>
</ul>
</li>
</ul>
<h1 id="Chapter-9-Y86-64-A-self-defined-ISA"><a href="#Chapter-9-Y86-64-A-self-defined-ISA" class="headerlink" title="Chapter 9. Y86-64: A self-defined ISA"></a>Chapter 9. Y86-64: A self-defined ISA</h1><blockquote>
<p>Y86-64 是由 CMU 教授设计，SJTU 老师改进的一种教学用指令集架构，实际生产中没有处理器使用此架构。</p>
<p>学习它的目的是 <strong>更好地了解 CPU 与 ISA 间的关系和实现思路，剥离开复杂的细节，从抽象角度帮助我们理解 CPU 与 ISA、软件之间的交融</strong>。</p>
<p>最后，为我们自己设计模拟器（simulator）、汇编器（assembler）、计算机处理器（CPU）打下基础。</p>
</blockquote>
<h2 id="9-1-Y86-64-Processor-State"><a href="#9-1-Y86-64-Processor-State" class="headerlink" title="9.1 Y86-64 Processor State"></a>9.1 Y86-64 Processor State</h2><p>我们定义 Y86-64 架构下，用于保存处理器状态（或者说程序执行状态）的由以下部件构成：</p>
<ul>
<li><p>15 只寄存器（Registers），每个大小 64 bits（除了不存在 <code>%r15</code>，其他与 x86-64 相同）；</p>
<blockquote>
<p>每个寄存器有独立且唯一的 4-bit ID：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/y86-regs.png" height="125px"></p>
<p><code>0xF</code> 代表不使用寄存器（None），在 Y86-64 中有特殊用途。</p>
</blockquote>
</li>
<li><p>程序计数器（Program Counter，PC），64-bit size；</p>
</li>
<li><p>Conditional Codes，共 3 个，每个 1-bit（比 x86-64 少 CarryFlag 等 5 个 CC）；</p>
<ul>
<li><code>OF</code>: Overflow Flag，当且仅当上一次运算出现溢出时设置该位；</li>
<li><code>ZF</code>: Zero Flag，当且仅当上一次运算结果为 0 时设置该位；</li>
<li><code>SF</code>：Negative（Signed）Flag，当且仅当上一次运算结果为负数时设置该位；</li>
</ul>
</li>
<li><p>Status Code：记录程序运行状态的寄存器，存放一些有含义的数；</p>
<ul>
<li><code>AOK</code>: the program is executing normally (<strong>Continue</strong>).</li>
<li><code>HLT</code>: the processor has executed a halt instruction (<strong>Normal exit</strong>).</li>
<li><code>ADR</code>: the processor attempted to access <strong>an invalid memory address</strong> (<strong>Segmentation Fault</strong>).</li>
<li><code>INS</code>: <strong>an invalid instruction</strong> code has been encountered (<strong>IoT</strong>).</li>
</ul>
</li>
<li><p>Memory：程序内存。简单定义为使用 Byte 索引的存储数组。<strong>使用小端序（little-endian）存储</strong>；</p>
</li>
</ul>
<h2 id="9-2-Y86-64-Instructions"><a href="#9-2-Y86-64-Instructions" class="headerlink" title="9.2 Y86-64 Instructions"></a>9.2 Y86-64 Instructions</h2><p>Y86-64 下定义了 12 类处理器指令：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/y86-inst.png"></p>
<p>Tips 1. Generic Form &amp; Encoded Representation</p>
<p>Tips 2. Instruction Code (first 4 bits) &amp; Function Code (second 4 bits)</p>
<h3 id="9-2-1-程序终止指令类-halt：0x00"><a href="#9-2-1-程序终止指令类-halt：0x00" class="headerlink" title="9.2.1 程序终止指令类 halt：0x00"></a>9.2.1 程序终止指令类 <code>halt</code>：<code>0x00</code></h3><h3 id="9-2-2-空指令类-nop：0x10"><a href="#9-2-2-空指令类-nop：0x10" class="headerlink" title="9.2.2 空指令类 nop：0x10"></a>9.2.2 空指令类 <code>nop</code>：<code>0x10</code></h3><h3 id="9-2-3-寄存器移动指令类"><a href="#9-2-3-寄存器移动指令类" class="headerlink" title="9.2.3 寄存器移动指令类"></a>9.2.3 寄存器移动指令类</h3><p><code>rrmovq rA, rB</code>：<code>0x20 0x&lt;rA&gt;&lt;rB&gt;</code>（看作无条件的 conditional move）</p>
<p><code>cmov&lt;XX&gt; rA, rB</code>：<code>0x2&lt;X&gt; 0x&lt;rA&gt;&lt;rB&gt;</code></p>
<h3 id="9-2-4-直接量-寄存器移动指令类"><a href="#9-2-4-直接量-寄存器移动指令类" class="headerlink" title="9.2.4 直接量-寄存器移动指令类"></a>9.2.4 直接量-寄存器移动指令类</h3><p><code>irmovq V, rB</code>：<code>0x30 0xF&lt;rB&gt; &lt;V&gt;</code>（2+8 bytes）</p>
<h3 id="9-2-5-寄存器-内存移动指令类"><a href="#9-2-5-寄存器-内存移动指令类" class="headerlink" title="9.2.5 寄存器-内存移动指令类"></a>9.2.5 寄存器-内存移动指令类</h3><p><code>rmmovq rA, D(rB)</code>：<code>0x40 0x&lt;rA&gt;&lt;rB&gt; &lt;D&gt;</code>（2+8 bytes）</p>
<h3 id="9-2-6-内存-寄存器移动指令类"><a href="#9-2-6-内存-寄存器移动指令类" class="headerlink" title="9.2.6 内存-寄存器移动指令类"></a>9.2.6 内存-寄存器移动指令类</h3><p><code>mrmovq D(rB), rA</code>：<code>0x50 0x&lt;rA&gt;&lt;rB&gt; &lt;D&gt;</code>（2+8 bytes）</p>
<p>⚠⚠ <u><strong>在 encoded representation 中，用于存储内存基地址的寄存器（在 9.2.5 和 9.2.6 中都用 <code>rB</code> 表示）ID 必须在目标寄存器 ID 之后！ </strong></u> ⚠⚠</p>
<h3 id="9-2-7-运算指令类"><a href="#9-2-7-运算指令类" class="headerlink" title="9.2.7 运算指令类"></a>9.2.7 运算指令类</h3><p><code>&lt;OP&gt;q rA, rB</code>：<code>0x6&lt;X&gt; 0x&lt;rA&gt;&lt;rB&gt;</code></p>
<h3 id="9-2-8-跳转指令类"><a href="#9-2-8-跳转指令类" class="headerlink" title="9.2.8 跳转指令类"></a>9.2.8 跳转指令类</h3><p><code>j&lt;XX&gt; Dst</code>：<code>0x7&lt;X&gt; &lt;Dst&gt;</code>（1+8 bytes）</p>
<p><u><strong>不支持直接跳转的 PC-relative 表示法</strong></u>，下同。</p>
<h3 id="9-2-9-调用指令类"><a href="#9-2-9-调用指令类" class="headerlink" title="9.2.9 调用指令类"></a>9.2.9 调用指令类</h3><p><code>call Dst</code>：<code>0x80 &lt;Dst&gt;</code> (1+8 bytes)</p>
<h3 id="9-2-10-返回指令类-ret：0x90"><a href="#9-2-10-返回指令类-ret：0x90" class="headerlink" title="9.2.10 返回指令类 ret：0x90"></a>9.2.10 返回指令类 <code>ret</code>：<code>0x90</code></h3><h3 id="9-2-11-寄存器进栈指令类"><a href="#9-2-11-寄存器进栈指令类" class="headerlink" title="9.2.11 寄存器进栈指令类"></a>9.2.11 寄存器进栈指令类</h3><p><code>pushq rA</code>：<code>0xA0 0x&lt;rA&gt;F</code></p>
<p>（在 9.3 中详细介绍）</p>
<h3 id="9-2-12-寄存器出栈指令类"><a href="#9-2-12-寄存器出栈指令类" class="headerlink" title="9.2.12 寄存器出栈指令类"></a>9.2.12 寄存器出栈指令类</h3><p><code>popq rA</code>：<code>0xB0 0x&lt;rA&gt;F</code></p>
<p>我们根据上面的定义总结出几点有价值的信息：</p>
<ul>
<li><p>Y86-64 指令集是比 x86-64 更精简的变长指令集，但每类指令内的长度固定。</p>
<blockquote>
<p>因此，机器在读指令的第一个 byte 后，就能根据指令种类确定当前指令的长度。</p>
</blockquote>
</li>
<li><p>条件移动指令存在于寄存器移动指令类，因为它们都是在寄存器间移动数据，<strong>它们共享前 4-bit Instruction Code</strong>；</p>
</li>
<li><p><strong>只有运算指令类可以隐式改变 Conditional Codes</strong>、运算指令也<strong>只能操作寄存器，直接量都不行</strong>；</p>
</li>
</ul>
<h2 id="9-3-Y86-64-Program-Stack"><a href="#9-3-Y86-64-Program-Stack" class="headerlink" title="9.3 Y86-64 Program Stack"></a>9.3 Y86-64 Program Stack</h2><p>Y86-64 架构下的程序栈与 x86-64 相近，遵循相似的 ABI：</p>
<ul>
<li>栈地址<strong>从高地址向低地址增长</strong>；</li>
<li>栈在 Y86-64 中也用于处理 Procedure Call 等工作；</li>
<li><code>%rsp</code> 寄存器仍然用作保存当前栈顶地址；</li>
</ul>
<p>此外，在 Y86-64 中的两种对栈操作的指令：</p>
<ul>
<li><code>pushq rA</code>（<code>0xA0 0x&lt;rA&gt;F</code>）:<ol>
<li>先减小 <code>%rsp</code>（8）；</li>
<li>再将 <code>rA</code> 中的数据存放到 <code>%rsp</code> 所指的位置；</li>
<li><strong>例外：如果 <code>pushq %rsp</code>，那么将先存放旧的 <code>%rsp</code>，再减小 <code>%rsp</code></strong>；</li>
</ol>
</li>
<li><code>popq rA</code>（<code>0xB0 0x&lt;rA&gt;F</code>）：<ol>
<li>先从 <code>%rsp</code> 指向的地址读取数据到 <code>rA</code>；</li>
<li>再增加 <code>%rsp</code>（8）；</li>
<li>例外：<strong>如果 <code>popq %rsp</code>，那么先增加 <code>%rsp</code>，再读取原来位置的数据</strong>；</li>
</ol>
</li>
</ul>
<p>⚠⚠ <u><strong>注意，无论是 <code>pushq</code> 还是 <code>popq</code>（读出还是写入）寄存器，寄存器都在 Encoded Representation 的 Function Code 的前 4-bit 内容</strong></u> ⚠⚠</p>
<blockquote>
<p>总之注意三个地方的指令的编写位置：</p>
<ol>
<li>在寄存器 - 内存间转移的 Load-Store 指令的 <code>rA</code> 和 <code>rB</code> 位置；</li>
<li>操作栈指令的 <code>rA</code> 与 <code>F</code> 的位置始终是寄存器位于 Function Code first 4-bit；</li>
<li>在直接量 - 寄存器转移的指令中，Function Code 却遵循 <code>F&lt;rA&gt;</code> 的规律；</li>
</ol>
</blockquote>
<h2 id="9-4-半章小结"><a href="#9-4-半章小结" class="headerlink" title="9.4 半章小结"></a>9.4 半章小结</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/y86-isa1.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/y86-isa2.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/y86-inst-struct.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/y86-reg-id.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/y86-status-code.png"></p>
<h2 id="9-5-CPU-Design-CISC-vs-RISC"><a href="#9-5-CPU-Design-CISC-vs-RISC" class="headerlink" title="9.5 CPU Design: CISC vs RISC"></a>9.5 CPU Design: CISC vs RISC</h2><div class="table-container">
<table>
<thead>
<tr>
<th>TYPE</th>
<th>CISC</th>
<th>Early RISC</th>
</tr>
</thead>
<tbody>
<tr>
<td>指令数</td>
<td>极多</td>
<td>&lt;100$^1$</td>
</tr>
<tr>
<td>指令耗时</td>
<td>差距较大</td>
<td>都很少$^2$</td>
</tr>
<tr>
<td>指令长度</td>
<td>可变长$^3$</td>
<td>定长</td>
</tr>
<tr>
<td>指令表示</td>
<td>一种运算有多种指令</td>
<td>仅表示运算最小完备集</td>
</tr>
<tr>
<td>load &amp; store</td>
<td>算术、逻辑运算允许内存-寄存器间</td>
<td>算术、逻辑运算仅允许寄存器间</td>
</tr>
<tr>
<td>机器级细节</td>
<td>hidden</td>
<td>exposed$^4$</td>
</tr>
<tr>
<td>条件判断</td>
<td>Conditional Codes</td>
<td>Test Instruction + Normal Registers</td>
</tr>
<tr>
<td>procedure call</td>
<td>少量使用 registers，集中在栈上传递$^5$</td>
<td>大多数交给 registers</td>
</tr>
</tbody>
</table>
</div>
<p>$^1$ : 很少的指令数会导致编译得到的汇编码增多；</p>
<p>$^2$ : RISC 指令数少、指令执行时长普遍很短，所以它们的执行时长接近，很适合 pipeline 的设计；</p>
<p>$^3$ : x86-64 一条指令长度在 1 ~ 15 bytes 间；</p>
<p>$^4$ : 将硬件层面的细节暴露给上面的软件层开发者有利有弊。由于 RISC 的精简指令简化了编译器的工作，编译器得以投入到更深层的优化上来。另一方面暴露硬件细节也会损失一定的兼容性；</p>
<p>$^5$ : 主要是 CISC 考虑了兼容性。因为早期的机器寄存器数量不多，使用内存栈传递参数是个明智的选择；</p>
<hr>
<p>根据上面的线索，我们能总结出 Early RISC 相对于 CISC 的优劣势：</p>
<ul>
<li>优势在于能够高效结合 Pipeline 技术、编译器开发更简单、更容易学习和通过它理解指令集架构等等；</li>
<li>劣势在于同一高级语言编译得到的更多汇编指令、暴露机器级细节破坏了 ISA 的封装性和程序兼容性等等；</li>
</ul>
<p>如今，新指令集没法明确地分出它属于哪一种，它们会借鉴两者的特点和原则；</p>
<p>例如这里的 Y86-64：</p>
<ul>
<li>既采用了 CISC 原则: Conditional Codes、变长指令；</li>
<li>又采用了 RISC 原则: Load/Store Arch、通过寄存器完成 Procedure Call；</li>
</ul>
<h2 id="9-5-CPU-Design-Logic-Design-amp-HCL"><a href="#9-5-CPU-Design-Logic-Design-amp-HCL" class="headerlink" title="9.5 CPU Design: Logic Design &amp; HCL"></a>9.5 CPU Design: Logic Design &amp; HCL</h2><p>复习：数字电子电路基础 - 组合时序逻辑电路。例如：</p>
<ul>
<li>多路相等比较器；</li>
<li>多路选择器（<code>Multiplexor</code>）；</li>
</ul>
<h3 id="Hardware-Control-Language-Syntax"><a href="#Hardware-Control-Language-Syntax" class="headerlink" title="Hardware Control Language Syntax"></a>Hardware Control Language Syntax</h3><ul>
<li><p>支持普通逻辑运算符；</p>
</li>
<li><p>选择器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Out = [</span><br><span class="line">    s: A;</span><br><span class="line">    1: B:	// Default</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Arithmetic-Logic-Unit-Design"><a href="#Arithmetic-Logic-Unit-Design" class="headerlink" title="Arithmetic Logic Unit Design"></a>Arithmetic Logic Unit Design</h3><ul>
<li>Input: X (8 bytes)、Y（8 bytes）；</li>
<li>Conditional Codes：<code>ZF / OF / SF</code>；</li>
<li>Output: Z（8 bytes）；</li>
</ul>
<h3 id="Register-Storage-Design"><a href="#Register-Storage-Design" class="headerlink" title="Register(Storage) Design"></a>Register(Storage) Design</h3><ul>
<li><p>Latch &amp; Flip-flop</p>
<blockquote>
<p>这里只需要知道：某种锁存器在 clock 上升沿写入输入的信号、仅输出写入的信号；</p>
</blockquote>
</li>
<li><p>Register File</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/register-design.png" height="200px"></p>
<p>特征：两个读端口（因为指令存在双寄存器操作），一个写端口，时钟引脚控制读写时机；<code>srcA/srcB</code> 表示读取的 register ID（4-bit），<code>valA/valB</code> 表示对应的 register 中的值；写端口 <code>dstW</code> 表示要写入的 register ID，而 <code>valW</code> 表示要写入的值；</p>
</li>
<li><p>Memory</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/memory-design.png" height="200px"></p>
<p>特征：读写端口各一个（因为不允许从内存到内存的操作），<code>error</code> 端口提示非法地址等错误，<code>read</code>、<code>write</code> 端口决定当前是读还是写（不会同时出现），时钟引脚控制读写周期；</p>
</li>
</ul>
<h2 id="9-6-CPU-Design-SEQ-General"><a href="#9-6-CPU-Design-SEQ-General" class="headerlink" title="9.6 CPU Design: SEQ General"></a>9.6 CPU Design: SEQ General</h2><p>本节我们在前几节电路基础、Y86-64 ISA 理论基础上构建 Y86-64 微架构，实现串行（sequential）处理器。</p>
<blockquote>
<p><code>icode</code> 不在 0 ～ B 间说明非法指令；</p>
<p><code>ifun</code> 也要检查，不在指令列表中的也需要报错；</p>
<p>但 <code>icode:ifunc</code> 以后的内容 “编码错误” 不是非法指令，因为 CPU 能够识别，应该属于软件层面的错误。</p>
</blockquote>
<h3 id="9-6-1-General-Principle"><a href="#9-6-1-General-Principle" class="headerlink" title="9.6.1 General Principle"></a>9.6.1 General Principle</h3><p>首先要知道，一个汇编指令需要很多步电路操作，所以我们设计时应该遵循如下原则：</p>
<ol>
<li>采用 Multi-stages Design，<strong>即分几步来完成一个汇编指令，思想类似函数包装</strong><span id="principle1">；</span></li>
<li>为了更好地利用硬件，不应该为每个指令设计一个电路，而是考虑<strong>如何让所有指令共用一套电路</strong><span id="principle2">。</span></li>
</ol>
<h3 id="9-6-2-Basic-Framework"><a href="#9-6-2-Basic-Framework" class="headerlink" title="9.6.2 Basic Framework"></a>9.6.2 Basic Framework</h3><blockquote>
<p>本节是上完课后总结的内容，叙述顺序进行了综合。</p>
</blockquote>
<p>根据前人的经验，Y86-64 串行处理器设计的 stage 应该分为这几个：</p>
<ul>
<li><p>Fetch：<strong>从指令内存中读取指令</strong>；</p>
<blockquote>
<p>该步允许使用的 <strong>微架构内容</strong> 如下：</p>
<p>值（<code>var</code>）：</p>
<ul>
<li><strong><code>PC</code></strong>：当前 PC 的值；</li>
<li><strong><code>icode:ifun</code></strong>：组合读入的 Instruction Code &amp; Function Code；</li>
<li><strong><code>rA:rB</code></strong>：组合读入的 <strong>寄存器 ID 值存放变量</strong>；</li>
<li><strong><code>valC</code></strong>：约定俗成认为是常数存放变量，存放 Displacement、Destination、Immediate；</li>
<li><strong><code>valP</code></strong>：约定俗成认为是<strong>下一个完整指令</strong>的地址，一般所有指令都要操作这个变量；</li>
</ul>
<p>表达式（<code>exp</code>）：</p>
<ul>
<li><strong>$var\leftarrow M_x[PC+\delta]$：表示将 $PC+\delta$ 地址的内存中 $x$ bytes 的指令数据取到值 $var$ 中</strong>；例如 $rA:rB\leftarrow M_1[PC+1]$；</li>
<li>$var\leftarrow PC+\delta$：表示将 $PC+\delta$ 的值（也就是地址）赋给值 $var$；</li>
</ul>
</blockquote>
</li>
<li><p>Decode：<strong>将寄存器值读到变量值中</strong>；</p>
<blockquote>
<p>该步允许使用的 微架构内容 如下：</p>
<p>值（<code>var</code>）：</p>
<ul>
<li><strong><code>rA</code>、<code>rB</code></strong>：上步取得的寄存器 ID；</li>
<li><strong><code>valA</code>、<code>valB</code></strong>：<strong>新的用于存放寄存器内值的 <code>var</code></strong>；</li>
<li><strong><code>%rsp</code></strong>：该步允许直接使用 <code>%rsp</code> 指代该寄存器内的值；</li>
</ul>
<p>表达式（<code>exp</code>）：</p>
<ul>
<li><strong><code>valA/varB &lt;- R[rA/rB/%rsp]</code>：从指定寄存器中取值到某个变量中</strong>；</li>
</ul>
</blockquote>
</li>
<li><p>Execute：<strong>进行计算地址 / 值的操作</strong>；</p>
<blockquote>
<p>该步允许使用的 微架构内容 如下：</p>
<p>值（<code>var</code>）：</p>
<ul>
<li><strong><code>valE</code></strong>：约定俗成存放 <strong>ALU 计算结果的 <code>var</code></strong>;</li>
<li><strong><code>CC</code></strong>：Condition Code；</li>
<li><strong><code>Cnd</code></strong>：<strong>存放本次 Condition Flag（条件是否成立信息）的 <code>var</code></strong>；</li>
<li><strong><code>ifun</code></strong>：此处用于判断 Function Code 的条件语义，例如确定 <code>CC</code>、确定运算符；</li>
</ul>
<p>表达式（<code>exp</code>）：</p>
<ul>
<li><strong><code>valE &lt;- valB/0 + valA/valC/8/-8</code></strong>：将运算结果写到 <code>valE</code> 中，<strong>至于为什么左边是 <code>valB/0</code>，右边是 <code>valA/valC/8/-8</code>，主要是考虑所有指令后，为了最大程度上复用电路的主意；</strong></li>
<li><strong><code>valE &lt;- valB ifun valA</code></strong>：表示按 <code>ifun</code> 选择，将 <code>valB</code>、<code>valA</code> 运算后赋给 <code>valE</code>（显然这个表达式是专门为了 <code>opq</code> 指令的）；</li>
<li><strong><code>Set CC</code></strong>：根据运算结果设置 Condition Codes，在 Y86-64 中，只有 <code>opq</code> 可以使用；</li>
<li><strong><code>Cnd &lt;- Cond(CC, ifun)</code></strong>：表示按 <code>ifun</code> 预期条件、<code>CC</code> 当前条件，将是否应该进行的 Condition Flag 赋给 <code>Cnd</code>；</li>
</ul>
</blockquote>
</li>
<li><p>Memory：<strong>向内存中读 / 写数据</strong>；</p>
<blockquote>
<p>该步允许使用的 微架构内容 如下：</p>
<p>值（<code>var</code>）：</p>
<ul>
<li><strong><code>valM</code></strong>：约定俗成用于<strong>存放从内存中取出的值</strong>；</li>
<li><strong><code>valA / valE / valP</code></strong>：根据代码逻辑可能会用到的 <code>var</code>（也是考虑所有指令后，为了最大程度上复用电路的主意）；</li>
</ul>
<p>表达式（<code>exp</code>）：</p>
<ul>
<li><strong>$varM \leftarrow M_x[var]$</strong>：表示以 $var$ 的值为地址，从 Memory 中取 $x$ bytes 数据放入 <code>varM</code> 中；</li>
<li><strong>$M_x[var_2]\leftarrow var_1$</strong>：表示将 $var_1$ 中的数据放入到 以 $var_2$ 为地址、长度为 $x$ bytes 的内存中；</li>
</ul>
</blockquote>
</li>
<li><p>Write Back：<strong>向寄存器写入数据</strong>；</p>
<blockquote>
<p> 该步允许使用的 微架构内容 如下：</p>
<p> 值（<code>var</code>）：</p>
<ul>
<li><strong><code>varE / varM</code></strong>：根据代码逻辑可能会用到的 <code>var</code>（也是考虑所有指令后，为了最大程度上复用电路的主意）；</li>
<li><strong><code>rA / rB</code></strong>：本步想要写入寄存器，必须要用到寄存器 ID 值；</li>
<li><strong><code>Cnd</code></strong>：可能会根据 Condition Flag 进行不同动作（例如 <code>cmovXX</code> 类指令）；</li>
<li><p><strong><code>%rsp</code></strong>：本步允许直接使用此符号指代该寄存器；</p>
<p>表达式（<code>exp</code>）：</p>
</li>
<li><p><strong><code>R[rA/rB/%rsp] &lt;- valE/valM</code></strong>：将指定位置的值赋给指定的寄存器；</p>
</li>
<li><p><strong><code>Cnd ? exp : -</code></strong>：根据 Condition Flag 决定是否执行 本步允许的表达式 <code>exp</code>；</p>
</li>
</ul>
</blockquote>
</li>
<li><p>PC Update：<strong>更新 PC</strong>；</p>
<blockquote>
<p>该步允许使用的 微架构内容 如下：</p>
<p>值（<code>var</code>）：</p>
<ul>
<li><strong><code>valP / valC / valM</code></strong>：根据代码逻辑可能会用到的 <code>var</code>（也是考虑所有指令后，为了最大程度上复用电路的主意）；</li>
<li><strong><code>PC</code></strong>：本步的目的就是改变它；</li>
<li><strong><code>Cnd</code></strong>：可能会用 Condition Flag 决定赋给 <code>PC</code> 的内容（例如 <code>jXX</code> 类指令）；</li>
</ul>
<p>表达式（<code>exp</code>）：</p>
<ul>
<li><strong><code>PC &lt;- var</code></strong>：将各种本步允许的 <code>var</code> 传给 <code>PC</code>；</li>
<li><strong><code>PC &lt;- Cnd ? valC : valP</code></strong>：根据 Condition Flag 决定将何种 <code>var</code> 赋给 <code>PC</code>；</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="9-6-3-Describe-Assembly-with-Framework"><a href="#9-6-3-Describe-Assembly-with-Framework" class="headerlink" title="9.6.3 Describe Assembly with Framework"></a>9.6.3 Describe Assembly with Framework</h3><p>有了上面的知识，我们可以把各个指令对应的微架构过程描述出来了。</p>
<p><code>rrmovq rA, rB</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- 0 + valA    // Save line in Write Back (We shouldn&#x27;t add &quot;valB &lt;- R[rA]&quot;)</span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[rB] &lt;- valE    // No valA in Write Back</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure>
<p><code>cmovXX rA, rB</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- 0 + valA    // Save line in Write Back (We can&#x27;t add &quot;valB &lt;- R[rA]&quot;)</span><br><span class="line">Cnd &lt;- Cond(CC, ifun)</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">Cnd ? R[rB] &lt;- valE : -    // No valA in Write Back</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure>
<p><code>irmovq V, rB</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valC &lt;- M8[PC + 2]</span><br><span class="line">valP &lt;- PC + 10</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">NONE</span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- 0 + valC    // Save line in Write Back</span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[rB] &lt;- valE    // No valC in Write Back</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure>
<p><code>rmmovq rA, D(rB)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valC &lt;- M8[PC + 2]</span><br><span class="line">valP &lt;- PC + 10</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line">valB &lt;- R[rB]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + valC</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">M8[valE] &lt;- valA</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure>
<p><code>mrmovq D(rB), rA</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valC &lt;- M8[PC + 2]</span><br><span class="line">valP &lt;- PC + 10</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valB &lt;- R[rB]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + valC</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">valM &lt;- M8[valE]</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[rA] &lt;- valM</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure>
<p><code>opq rA, rB</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line">valB &lt;- R[rB]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB ifun valA</span><br><span class="line">Set CC</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[rB] &lt;- valE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure>
<p><code>jXX Dest</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">valC &lt;- M8[PC + 1]</span><br><span class="line">valP &lt;- PC + 9</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">Cnd &lt;- Cond(CC, ifun)</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">NONE</span><br><span class="line"># Write Back</span><br><span class="line">NONE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">Cnd ? PC &lt;- valC : valP</span><br></pre></td></tr></table></figure>
<p><code>call Dest</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">valC &lt;- M8[PC + 1]</span><br><span class="line">valP &lt;- PC + 9</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valB &lt;- R[%rsp]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + -8</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">M8[valE] &lt;- valP</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[%rsp] &lt;- valE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valC</span><br></pre></td></tr></table></figure>
<p><code>ret</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[%rsp]  // Save line in Memory</span><br><span class="line">valB &lt;- R[%rsp]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + 8</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">valM &lt;- M8[valA]    // No valB in Memory</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[%rsp] &lt;- valE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valM</span><br></pre></td></tr></table></figure>
<p><code>pushq rA</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[rA]</span><br><span class="line">valB &lt;- R[%rsp]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + -8</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">M8[valE] &lt;- valA</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[%rsp] &lt;- valE</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure>
<p><code>popq rA</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Fetch</span><br><span class="line">icode:ifun &lt;- M1[PC]</span><br><span class="line">rA:rB &lt;- M1[PC + 1]</span><br><span class="line">valP &lt;- PC + 2</span><br><span class="line"></span><br><span class="line"># Decode</span><br><span class="line">valA &lt;- R[%rsp]    // save line in Memory</span><br><span class="line">valB &lt;- R[%rsp]</span><br><span class="line"></span><br><span class="line"># Execute</span><br><span class="line">valE &lt;- valB + 8</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">valM &lt;- M8[valA]    // No valB in Memory</span><br><span class="line"></span><br><span class="line"># Write Back</span><br><span class="line">R[%rsp] &lt;- valE</span><br><span class="line">R[rA] &lt;- valM</span><br><span class="line"></span><br><span class="line"># PC Update</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure>
<hr>
<p>其中有几个要点需要着重掌握：</p>
<ul>
<li><p>Memory 中化简了 <code>valB</code>，Write Back 中化简了 <code>valA</code> 和 <code>valC</code>；</p>
</li>
<li><p><code>popq</code> 的 Write Back Stage 要保证 <code>R[rA] &lt;- valM</code> 在 <code>R[%rsp] &lt;- valE</code> 之后执行并覆盖；</p>
</li>
<li><p>电路的结果是充满管线之间的，<strong>但是只有时钟上升延才会被写入</strong>；</p>
<blockquote>
<p>这能解释为什么在 <code>opq rA, rB</code> 的 Execute Stage 中，前一步的运算不会影响到 <code>Set CC</code>：<strong>一个汇编指令执行在一个时钟周期内，一定不会相互影响</strong>。</p>
</blockquote>
</li>
</ul>
<p>再总结一下以上各个 Stage 实际用到的值情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/used-var.png" height="350px"></p>
<h3 id="9-6-4-Advantages-amp-Disadvantages"><a href="#9-6-4-Advantages-amp-Disadvantages" class="headerlink" title="9.6.4 Advantages &amp; Disadvantages"></a>9.6.4 Advantages &amp; Disadvantages</h3><ul>
<li>简单，容易实现；</li>
<li>指令无法设计复杂，否则耽误其他指令时间（快指令 等 慢指令）；</li>
<li>电路 propagate 需要时间，导致时钟周期无法很快，进而注定了 SEQ 处理器的速度不会很快（前 stage 等 后 stage）；</li>
</ul>
<h2 id="9-7-Principles-of-Pipeline"><a href="#9-7-Principles-of-Pipeline" class="headerlink" title="9.7 Principles of Pipeline"></a>9.7 Principles of Pipeline</h2><p>Some Ideas:</p>
<ul>
<li>Multi-Stage Design：和串行处理器的思路一样，分多个独立的 Stage 完成一个 Process；</li>
<li>Move objects through stages <strong>in sequence</strong>；</li>
<li>At any given times, <strong>multiple objects being processed</strong>；</li>
</ul>
<p>我们定义：</p>
<ul>
<li><p>从头至尾执行一条指令所需的时间（不讨论 capacity），称为这条指令的 <strong>延迟（latency）</strong>；</p>
</li>
<li><p>单位时间内完成指令的数量（讨论了 capacity），称这个流水线的 <strong>吞吐量（throughput）</strong>，通常的计算方法是 1 / 时钟周期长度 / 承载量（这里 “时钟周期长度” 会受到流水线分级方法的影响）；</p>
<blockquote>
<p>吞吐量常用单位是 <code>GIPS</code>（每秒千兆条），可以用每 1 ns 内执行的指令数量进行计算。</p>
</blockquote>
</li>
</ul>
<h3 id="9-7-1-Time-Analysis-SEQ"><a href="#9-7-1-Time-Analysis-SEQ" class="headerlink" title="9.7.1 Time Analysis: SEQ"></a>9.7.1 Time Analysis: SEQ</h3><p>从之前的串行处理器开始讨论，一条指令执行的耗时情况如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/comb-version.png"></p>
<ul>
<li>组合逻辑电路在输入后，等到电路稳定需要 300 ps（记作 “<strong>Computation Delay</strong>”）；</li>
<li>时钟上升沿到达后，需要 20 ps 才能确保写入 registers（记作 “<strong>Save Delay</strong>”）；</li>
</ul>
<p><strong>因此这种情况下，每个时钟周期至少 320 ps</strong>；</p>
<h3 id="9-7-2-Time-Analysis-N-Way-Pipelined"><a href="#9-7-2-Time-Analysis-N-Way-Pipelined" class="headerlink" title="9.7.2 Time Analysis: N-Way-Pipelined"></a>9.7.2 Time Analysis: N-Way-Pipelined</h3><p>我们考虑如下流水线的思想，将组合逻辑电路拆成多个 stage，以便使用流水线：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/pipeline-idea.png" height="300px"></p>
<p>如果将组合逻辑电路按照流水线的 ideas，变为 <strong>3-Way Pipelined</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/3-way-pipeline-version.png"></p>
<ul>
<li><p>将组合逻辑电路拆分为 3 个独立的 stage（每个 stage 平均 latency 100 ps）；</p>
</li>
<li><p>虽然 latency <strong>略微增长</strong>（由于寄存器状态切换的时间开销）：360 ps，但 Throughput 提升了；</p>
</li>
<li><p><strong>因为根据流水线思想，在一个 operation 穿过一个 stage 后，其他部分就空闲下来，并且状态已经进入中间状态 registers，因此下一条指令可以立即进入</strong>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/3-way-pipeline-state.png" height="400px"></p>
</li>
</ul>
<h4 id="Limitation-1-Nonuniform-Delays"><a href="#Limitation-1-Nonuniform-Delays" class="headerlink" title="Limitation 1: Nonuniform Delays"></a>Limitation 1: Nonuniform Delays</h4><p><strong>但是，我们没有考虑一个重要问题：逻辑电路划分为 stage 后，每个 stage 的 Delay 时长不一致（Nonuniform Delays）。</strong></p>
<p>这个时候，有些耗时短的 stage 就要等待耗时长的 stage，例如：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/ununiform-delay.png"></p>
<p>这样我们考虑几个问题：</p>
<p>根据组合逻辑电路的设计，有些部分是无法继续切分的，这就告诉我们无法无限向下切分 stage。假设有一种设计如下，各个部分不能继续切分：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/pipeline-example.png"></p>
<p>那么，考虑不同 stage 数量下的 CPU 情况：</p>
<ul>
<li>当 stage 数量为 2 时，最好的划分方法是 <code>A B C | D E F</code>，这个时候总 <code>latency = 190 * 2 ps = 380 ps</code>，<code>throughput = 1 / 190 * 1000 GIPS = 5.26 GIPS</code>；</li>
<li>当 stage 数量为 3 时，最好的划分方法是 <code>A B | C D | E F</code>，这个时候总 <code>latency = 130 * 3 ps = 390 ps</code>，<code>throughput = 1 / 130 * 1000 GIPS = 7.69 GIPS</code>；</li>
<li>当 stage 数量为 4 时，最好的划分方法是 <code>A | B C | D | E F</code>，这个时候总 <code>latency = 110 * 4 ps = 440 ps</code>，<code>throughput = 1 / 110 * 1000 GIPS = 9.09 GIPS</code>；</li>
<li>当 stage 数量为 5 时，最好的划分方法是 <code>A | B | C | D | E F</code>，这个时候总 <code>latency = 100 * 5 ps = 500 ps</code>，<code>throughput = 1 / 100 * 1000 GIPS = 10 GIPS</code>；</li>
<li>当 stage 数量大于 5 时，<code>throughput</code> 不可能比 5 个 stage 更好了，因为最大不可分割的单元已经达到 80 ps 了，意味着再增加 stage，不仅不会提升 throughput，还会延长 latency；</li>
</ul>
<p>于是我们能得到结论：</p>
<ul>
<li>最大的 throughput 不一定是在最大的 Stage 切分数取得，<strong>而是取决于 <u>最大的、不可分割的部分耗时 + 寄存器状态写入的 latency</u></strong>；</li>
</ul>
<h4 id="Limitation-2-Register-Overhead"><a href="#Limitation-2-Register-Overhead" class="headerlink" title="Limitation 2: Register Overhead"></a>Limitation 2: Register Overhead</h4><p>另外，当我们将过程切分成更多的 stage 后，loading registers 所占的时长比例愈发的大，这是我们所不希望的。</p>
<h4 id="Limitation-3-Data-Dependency-amp-Data-Hazard"><a href="#Limitation-3-Data-Dependency-amp-Data-Hazard" class="headerlink" title="Limitation 3: Data Dependency &amp; Data Hazard"></a>Limitation 3: Data Dependency &amp; Data Hazard</h4><p>既然使用流水线，就不可避免要考虑前后 stage 的依赖问题，例如 <strong>前一条指令的结果是后一条指令的运算数（数据依赖）、前一条指令决定后一条指令的执行位置（控制依赖）</strong>。</p>
<p>对于数据依赖而言：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">irmovq $50, %rax</span><br><span class="line">addq %rax, %rbx</span><br><span class="line">mrmovq 100(%rbx), %rdx</span><br></pre></td></tr></table></figure>
<p>因此，这三条指令在流水线上的时间顺序必须是这样的，才能保证运算结果的正确性：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/data-dep.png"></p>
<p>但是，这样又没法使用流水线，因此可以采用 <strong>中间插入其他指令</strong> 的方式缓解这种问题，具体会在实现的时候进一步讨论：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/data-dep-sol.png"></p>
<h4 id="Limitation-4-Control-Dependency"><a href="#Limitation-4-Control-Dependency" class="headerlink" title="Limitation 4: Control Dependency"></a>Limitation 4: Control Dependency</h4><p>同样，对于控制依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">    subq %rdx, %rbx</span><br><span class="line">    jne targ</span><br><span class="line">    irmovq $10, %rdx</span><br><span class="line">    jmp loop</span><br><span class="line">targ:</span><br><span class="line">    halt</span><br></pre></td></tr></table></figure>
<p>于是，我们分析了实现流水线的优势、可能遇到的问题。接下来我们会在实现的介绍中，依次解决上面的几个顾虑。</p>
<h2 id="9-8-Pipeline-Implementation"><a href="#9-8-Pipeline-Implementation" class="headerlink" title="9.8 Pipeline Implementation"></a>9.8 Pipeline Implementation</h2><p>首先同样，根据前人的经验，我们作出如下强调：</p>
<ul>
<li><p>SEQ+ Implementations：<strong>将 <code>PC Update</code> Stage 的工作移动到 Fetch Stage（根据上一条指令的寄存器结果得到当前指令的 PC）</strong>，而 PC 不再存在一个真实寄存器中，因为只需要根据上一条指令的寄存器状态就能计算 next PC（变成了组合逻辑电路）。<strong>至此形成经典 5 级流水线的逻辑电路基础</strong>；</p>
<blockquote>
<p>New Fetch:</p>
<ul>
<li>Select current PC;</li>
<li>Read instruction;</li>
<li>Compute incremented PC.</li>
</ul>
</blockquote>
</li>
<li><p>Naïve PIPE Implementation：先忽略 Control / Data Hazard，只用 <code>nop</code> 解决；</p>
</li>
<li><p>Pipeline Feedback</p>
</li>
</ul>
<h3 id="9-8-1-Hardware"><a href="#9-8-1-Hardware" class="headerlink" title="9.8.1 Hardware"></a>9.8.1 Hardware</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/5-stage-pipeline-impl.png" height="800px"></p>
<p>有几点值得注意；</p>
<ul>
<li><p>和 SEQ Implementation 不一样，每个 stage 间多了要保存的<strong>状态寄存器</strong>；</p>
</li>
<li><p>小写字母前缀表示当前 stage 阶段由控制逻辑块生成的数据，大写字母前缀表示流水线寄存器的一个字段（从上个 stage 接受的数据）；</p>
<p>例如：<code>D_stat</code> 表示 Decode Stage 接受上个阶段的状态输入值，<code>m_valA</code> 表示 Memory Stage 计算出的 <code>valA</code> 值；</p>
</li>
<li><p>Fetch 部分增加了 <strong>用于猜测下一条指令的寄存器 <code>predPC</code></strong>；</p>
</li>
<li><p>Decode 部分增加了 <code>Select A</code> 部件，原因是：</p>
<ul>
<li>现象：只有 call 指令会在 memory 阶段用到 <code>valP</code>，只有 jump 指令会在 execute 阶段用到 <code>valP</code>（准确说是“携带”）。这两种指令都不需要用到寄存器 A；<strong>还有一点是我们已经将 PC Update 转移到 Fetch 中，在 Fetch 阶段本身就有 Predict PC 部件。这样 <code>valP</code> 在其他场合也不需要传播到 Fetch 阶段之外的场合去</strong>；</li>
<li>作用：减少控制信号和寄存器的数目。即可以将这两个控制信号合并。</li>
</ul>
</li>
</ul>
<p>那么这个 implementation 是如何解决 Data / Control Hazard 的？</p>
<h3 id="9-8-2-Resolve-Data-Hazard-Data-Forwarding-amp-Stalling"><a href="#9-8-2-Resolve-Data-Hazard-Data-Forwarding-amp-Stalling" class="headerlink" title="9.8.2 Resolve Data Hazard: Data Forwarding &amp; Stalling"></a>9.8.2 Resolve Data Hazard: Data Forwarding &amp; Stalling</h3><p>首先对于 Data Hazard，主要的问题是：<strong>Read-after-write</strong>（write 在 read 后面则不会出现问题）。</p>
<p>可能引发这个问题的指令有：<code>opq</code>、<code>ir/rr/mr/rm movq</code>、<code>popq</code>。</p>
<p>例如对这样几条汇编而言：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># demo-h0.ys</span><br><span class="line">0x000:irmovq $10,%rdx</span><br><span class="line">0x00a:irmovq $3,%rax</span><br><span class="line">0x014:addq %rdx,%rax</span><br><span class="line">0x016:halt</span><br></pre></td></tr></table></figure>
<p>直接考虑 5 个 stage 流水线形式进入会出现问题，如下左图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/data-hazard-example.png" width="350px"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/data-hazard-nop.png" width="350px"></p>
<p>因为在第 3 条指令在 Decode 阶段会读取紧邻的前两条指令计算结果，而前两条指令此时正处于 Memory 和 Execute 阶段，都没有到 Write Back 阶段，这时存在 read-after-write dependency，读取数据一定是错误的。</p>
<p><strong>第一种尝试方法是之前提到的 插入 <code>nop</code></strong>（Naïve Design）；</p>
<p>一般如果 Fetch 读入一个改变下一个指令所用寄存器的指令，那么等到该指令更改寄存器位于 Write Back Stage，前后相差 3 个 stage，因此<strong>在有 Data Hazard 的两指令间插入 3 个 <code>nop</code></strong>就能解决问题，如上右图。</p>
<blockquote>
<p>考虑一下，如果只插入 2 个 <code>nop</code>，那么第三条指令只能读到 <code>%rdx</code> 中正确的值，因为第二条指令还在 Write Back 阶段没有结束；</p>
<p>如果只插入一个 <code>nop</code>，那么两个寄存器正确的值都读不到！</p>
</blockquote>
<p>虽然这种解决方法非常简单，可以由编译器、硬件处理器，甚至开发者来解决。但是弊端是 <strong>这会严重拖慢流水线速度</strong>。因此我们得想办法尽可能让底层硬件解决这个问题。</p>
<hr>
<p><strong>第二种尝试方法是 stalling（拖延住）</strong>；</p>
<p>这种方法是在 CPU 执行指令时实时进行的，具体以例子说明。假设有个程序在 Y86-64 编译器上编译后长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># demo-h2.ys</span><br><span class="line">0x000:irmovq $10,%rdx</span><br><span class="line">0x00a:irmovq $3,%rax</span><br><span class="line">0x014:nop    # 先考虑简单的情况，假设这中间有两条完全无关、不会出现 data dependency 的指令，</span><br><span class="line">0x015:nop    # 我们假装它们就是 nop 来讨论</span><br><span class="line">    # Bubble</span><br><span class="line">0x016:addq %rdx,%rax</span><br><span class="line">0x018:halt</span><br></pre></td></tr></table></figure>
<p>我们根据上一种方法的分析可知，现在 <code>0x016</code> 位置上的指令仍然无法读到正确的 <code>%rax</code>，还需要再等一个 clock 才行。这个时候，我们在 <code>0x015</code> 和 <code>0x016</code> 之间插入一个 “Bubble”。</p>
<p><strong>这个 Bubble 不会在汇编代码中出现，而是 CPU 进行了以下操作</strong>：</p>
<ol>
<li>向 <code>0x016</code> 指令（依赖未取得的指令）所在的 Stage（Decode）输入状态寄存器发送 Stalling 信号，<strong>暂停一个 clock 不允许被修改</strong>；</li>
<li>在向 <code>0x016</code> 指令之前的所有 stage（这里只有 Fetch）的输入状态寄存器发送 Stalling 信号（<strong>防止后来的指令 “撞到” stalling 寄存器上消失</strong>）；</li>
<li>由于 <code>0x016</code> 指令只是状态寄存器定住了，不正确的信号仍然会向前传递，因此 CPU 还要 <strong>将前进到 Execute Stage、但没来得及修改 CC 和 后继状态寄存器的错误指令的 <code>icode</code> 修改为 <code>1</code>，表示 <code>nop</code>，使它彻底失去作用</strong>；</li>
</ol>
<p>这种 “将其他指令的 <code>icode</code> 改为 <code>1</code> 使其成为 <code>nop</code>” 的动作所产生的不在汇编码上的 <code>nop</code> 就叫 bubble。</p>
<p>这样从 <code>0x015</code> 后的所有指令都会暂停一个 clock，等待 <code>0x00a</code> 指令写入寄存器。</p>
<p>这种方法只是将插入 <code>nop</code> 的工作移交给了硬件，没有解决速度上的问题。</p>
<hr>
<p><strong>第三种尝试方法是 data forwarding</strong>（利用 feedback paths 将后面的结果给到前面的 decode stage）；</p>
<p>就是说，我们让最终结果未出现前，让正确 / 可能正确的值先通过传输线传递给读的 decode 阶段；这个方法能实现，主要是因为 <strong>能读到信号要早于写入信号</strong>（前者在一个 Clock 开始的一段时间后就可读到，而后者则需要这个 Clock 结束）。</p>
<p>例如：</p>
<ul>
<li><code>irmovq</code> 在 Fetch 阶段就一定可以得到正确的值，后面的任意 stage 都能找到值；</li>
<li><code>opq</code> 在 Execute 阶段后期一定可以得到正确的值，后面的任意 stage 都能找到值；</li>
<li><code>ret</code> 在 Memory 阶段结束一定可以得到正确的值；</li>
</ul>
<blockquote>
<p>但是 Feedback Paths 不会出现在 Fetch 阶段，因为太早了，后面的指令没进入 Decode 阶段前很难使用这个结果。</p>
</blockquote>
<p>一般用 feedback paths 去解决 data hazard，主要作用在 Decode 阶段，因为这个阶段才可能会用到没有写入的寄存器值。</p>
<p>再考虑简单的情况，假设 <code>0x00a</code> 和 <code>0x016</code> 之间有两条无关的指令，就假设为 <code>nop</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># demo-h2.ys</span><br><span class="line">0x000:irmovq $10,%rdx</span><br><span class="line">0x00a:irmovq $3,%rax</span><br><span class="line">0x014:nop</span><br><span class="line">0x015:nop</span><br><span class="line">0x016:addq %rdx,%rax</span><br><span class="line">0x018:halt</span><br></pre></td></tr></table></figure>
<p>这个时候 <code>%rdx</code> 能正确读到，如果我们把 Write Back 阶段的 <code>W_valE</code>（<code>0x00a</code> 的 Write Back Stage 状态寄存器值）通过 feedback path 将信息告诉 Decode Stage 呢？比如在这种情况下，我们把 <code>W_valE</code> 接给 <code>valB</code>，就能够读到正确的值了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/data-hazard-2nop-forward.png" width="280px"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/data-hazard-1nop-forward.png" width="240px"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/data-hazard-forward.png" width="280px"></p>
<p>那我们乘胜追击，假设中间只空 1 个 <code>nop</code> 呢？这个时候产生 <code>%rax</code> 的值还在 Memory 阶段！没事，因为 <code>irmovq</code> 的结果在 Fetch 阶段就知道了嘛，我们把 <code>M_valE</code> 的值给它；</p>
<p>然后另一个寄存器也无法获取正确的值，就类似上个情况的 “从 Write Back 阶段 <code>W_valE</code> 到 <code>valA</code>“ 接线就行。如上中图所示。</p>
<p>太好了，更极限一点的话，<code>irmovq</code> 写和 <code>opq</code> 读指令不隔 <code>nop</code>，是否也能用 data forward 解决？</p>
<p>同样是可以的：在上一条指令处于 Execute Stage 时，我们直接将运算结果 <code>e_valE</code> 给 <code>valB</code>。来的及吗？之前都是给状态寄存器（在 Clock 开始前就等待在外），这次给结果值（Clock 开始后一段时间才能稳定），<strong>是来得及的。因为 <u>Deocde 阶段可以等，直到这个 Clock 快结束才得到都是没问题的</u>。</strong>如上右图。</p>
<blockquote>
<p>更进一步考虑，假如上面的指令不是 <code>addq %rdx,%rax</code>，而是 <code>addq %rax, %rbx</code>（前两条指令也对应变），那么寄存器情况是不是一样能这么做？</p>
</blockquote>
<p>于是我们发现，只要多加几个 feedback paths，就能解决以 <code>irmovq</code> / <code>opq</code> 为首的 RAW-Dependency 问题，不需要插入 Bubble 或者 <code>nop</code>。我们将这个成功经验拓展到其他指令上，再总结一下：</p>
<p>首先我们可以从这些位置提前得到寄存器的结果（Forwarding Sources）：</p>
<ul>
<li><p>Execute Stage 的计算结果 <code>valE</code>（<code>e_valE</code>）；</p>
<blockquote>
<p><strong>不能比这个早，因为上面我们讨论 <code>irmovq</code> 只是一种情况，有些指令例如 <code>opq</code> 必须等到 Execute 结束才能拿到正确的值</strong>。</p>
</blockquote>
</li>
<li><p>Memory Stage 的状态寄存器 <code>valE</code>、<code>valM</code>（<code>M_valE</code>、<code>M_valM</code>）；</p>
</li>
<li><p>Write Back Stage 的状态寄存器 <code>valE</code>、<code>valM</code>（<code>W_valE</code>、<code>W_valM</code>）；</p>
</li>
</ul>
<p>其次，我们需要判断是否应该接受 forwarding data，即分情况选择 <code>valA</code>、<code>valB</code> 的来源。<strong>哪些情况应该和平常一样直接使用寄存器的值，哪些时候又应该选择 Forwarding Sources</strong>。</p>
<p>为了分情况选择，我们向电路里加入了两个逻辑电路用于选择不同情况下 <code>valA</code> 和 <code>valB</code> 的取值，纠正 data hazard 问题：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/data-forward-impl.png" height="800px"></p>
<p>这种 data forwarding 方法看似解决了问题，并且无需使用 bubble 和 <code>nop</code>，但是它还是没有考虑完全。</p>
<p>我们上面讨论的情况 “以 <code>irmovq</code> 写、<code>opq</code> 读为首的 RAW-Dependency” 有个前提是，<u><strong>直接相邻的两个存在 data dependency 的指令，所使用的有依赖的数据产生阶段不能晚于 Execute Stage</strong></u>，因为直接相邻说明只间隔了一个 stage。</p>
<p>那么可能构成 data dependency 的指令中（<code>opq</code>、<code>ir/rr/mr/rm movq</code>、<code>popq</code>），有一类是没法在 Execute Stage结束前拿到结果：<strong>从 memory 中取值的 <code>mrmovq</code>、<code>popq</code></strong>。它们必定要等到 Memory Stage 结束才能取到值！</p>
<p>我们将 “在取 Memory 后，立即使用此值” 的行为称作 “Load / Use Hazard”，这种情况使用 Data Forward 是无法纠正寄存器的读错误。<strong>我们必须要借助前面介绍的 Bubble 让这种连续 Load / Use 分开一个 Cycle</strong>。</p>
<hr>
<p>于是，Y86-64 针对 Data Hazard 的解决方法总结如下：</p>
<ul>
<li>对于一般的连续两条指令（分开的就更好办）数据依赖，我们可以直接使用 Data Forwarding 设计的 Feedback Paths，选择正确的值就能纠正；</li>
<li>对于 Load / Use Hazard（连续的从内存读、使用），我们需要在使用 Data Forwarding 的同时，<strong>向 Execute 阶段插入一个 Bubble（同时要将 Decode 和 Fetch stall 住一个 Clock 防止指令损失），以将 Load 和 Use 指令分开一个 Cycle</strong>；这两种方式结合的方法就叫 load interlock（加载互锁）。</li>
</ul>
<h3 id="9-8-3-Resolve-Control-Hazard-Part-Ⅰ-Predicting-the-PC"><a href="#9-8-3-Resolve-Control-Hazard-Part-Ⅰ-Predicting-the-PC" class="headerlink" title="9.8.3 Resolve Control Hazard Part Ⅰ: Predicting the PC"></a>9.8.3 Resolve Control Hazard Part Ⅰ: Predicting the PC</h3><p>其次，针对 Control Hazard 的解决方案也是 <strong>Feedback Paths</strong>。根据指令的特点，有几种数据能决定 next PC：</p>
<ul>
<li>Next Instruction for most cases（<code>valP</code>，一定可以预测正确）；</li>
<li>Call destination（<code>valC</code>，一定可以预测正确）；</li>
<li>Branch information，由有条件的 <code>jmp</code> 指令触发，<strong>可能预测正确</strong>；</li>
<li>Return point，由 <code>ret</code> 指令触发，地址位于内存，<strong>几乎一定不可预测</strong>；</li>
</ul>
<p><strong>所以可以根据这些寄存器中的值进行预先推测，猜测可能下一步可能的指令地址</strong>。</p>
<blockquote>
<p>由于上一条指令在 Fetch 之后就要读下一条指令了，所以猜测的可靠性不能保证。</p>
<p>如果猜测错误，就需要<strong>恢复到猜测前的状态</strong>（如何实现？后面提及）。</p>
</blockquote>
<p>对应这几种数据的特点和成功率，我们相应的有<strong>猜测策略</strong>：</p>
<ul>
<li><p>对于前两种情况而言，我们直接选择 Fetch 阶段得到的或者计算出的 <code>valC / valP</code>，一定不会出错；</p>
</li>
<li><p>对于 Conditional Jumps，<strong>我们总是猜测可能是寄存器 <code>valC</code> 中的地址（即赌本次跳转条件一定成立）</strong>。</p>
<blockquote>
<p>为什么？原因有 2 条：</p>
<ol>
<li>因为大量数据统计在 60% 的情况下的条件是成立的（Unconditional 和 Conditional Jump 只是 <code>ifun</code> 的区别；还有 <code>while</code>、<code>for</code> 循环翻译成的 <code>jmp</code> 跳转的概率更大）；</li>
<li>携带 <code>valP</code> 和 <code>valC</code> 的电路设计的复杂程度不一样。人们发现选择 <code>valC</code> 时电路更简单；</li>
</ol>
<p><strong>也可以通过一些数据分析的手段来精确这个过程</strong>；</p>
</blockquote>
<p>另外，我们还需要知道这次猜测是否正确，如果猜测错误还需要进行恢复。我们可以将 <code>M_Cnd</code>（Memory stage 计算得出的 Cnd flag）、<code>M_valA</code>（Memory 阶段<strong>存储的 <code>valP</code></strong>，因为有 Select A 所以放在这里）两个值通过 Feedback Paths 回接给 Select PC，让它判断是否该相信 <code>predPC</code>；</p>
</li>
<li><p>对于 Return 而言，几乎一定无法预测，那么就彻底不预测，也就是不使用 Predict PC，和其他情况一样默认 <code>valP</code>；</p>
<p>最终的纠错阶段就是真正的返回地址被取出的时候（Write Back state registers）；</p>
</li>
</ul>
<p>现在，我们根据猜测策略，将各种情况下 Next PC 的猜测值全部汇总到 Select PC 原件，让这个逻辑电路根据情况判断正确的下一条指令是什么，如下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/pred-PC.png" height="300px"></p>
<h3 id="9-8-4-Resolve-Control-Hazard-Part-Ⅱ-Fix-Wrong-Predictions"><a href="#9-8-4-Resolve-Control-Hazard-Part-Ⅱ-Fix-Wrong-Predictions" class="headerlink" title="9.8.4 Resolve Control Hazard Part Ⅱ: Fix Wrong Predictions"></a>9.8.4 Resolve Control Hazard Part Ⅱ: Fix Wrong Predictions</h3><p>但是有个问题，我们按照上一节的猜测策略暂时得到了<u>可能的</u>下一条指令的执行位置，我们又如何在得到结果后发现、修复错误的猜测结果呢？</p>
<p><code>ret</code> 指令的结果数据在 Memory 结束、Write Back 状态寄存器才能知道，<code>jmp</code> 类指令的结果数据也要在 Execute 结束、Memory 状态寄存器才能知道。这两种指令紧邻的下一条指令在 Fetch 时（哪怕有 Data Forward）也没法得知结果，怎么办？</p>
<p>根据猜测策略，<code>jmp</code> 直接先猜测按照 <code>valC</code> 跳转，但是检查 <code>M_Cnd</code> 时，<code>jmp</code> 已经向前前进了 2 个 Stage 了（Fetch Finish -&gt; Execute Finish），如果 <code>M_Cnd</code> 指示符合跳转条件，那么继续执行没有问题，但是如果出错，应该怎么办？<strong>我们发现检查 <code>M_Cnd</code> 的时候，中间两个指令分别在 Decode 起点、Execute 起点，还有下一条指令刚要进入 Fetch 阶段 —— 即便 <code>jmp</code> 错误，当前也并没有产生影响（如更改 CC、写入下一个 stage 的状态寄存器）。</strong>因此很好解决：</p>
<p><code>jmp</code> 如果发现 <code>M_Cnd</code> 指示不应该跳转，说明预测错误，立即进行以下措施：</p>
<ol>
<li>由于 <code>jmp</code> 以后的错误指令只有两条（位于 Decode 和 Execute 开始阶段），并且没产生影响，只需要在时钟上升沿时将它们的 <code>icode</code> 改为 <code>1</code>（<code>nop</code>），就能解决错误执行的问题；</li>
<li>同样是上升沿阶段，将 <code>M_Cnd</code> 给到 Fetch 阶段，这个时候 Fetch 阶段就能读到正确的下一条指令；</li>
</ol>
<p><strong>所以就算 <code>jmp</code> 预测错误，有了上面的措施，也就浪费 2 个 Cycles 而已，不会造成执行语义错误</strong>！</p>
<p>再来看 <code>ret</code> 的跳转错误如何修复。</p>
<p>根据策略，<code>ret</code> 不会做猜测（一般行为遵从 Predict PC 拿到的 <code>valP</code>），直接接着这条指令向下读。但是 <code>ret</code> 和 <code>jmp</code> 不一样，不能按照原来 feedback paths 解决，因为 <code>ret</code> 拿到结果 <code>W_valM</code> <strong>要到 Memory Stage 结束，而这个时候 <code>ret</code> 向前前进了 3 个 Stage，紧跟 <code>ret</code> 的指令 Execute 已经执行结束 —— 也就是说，错误的指令改变了 CC 和后续状态寄存器，这是不允许的！</strong></p>
<blockquote>
<p>你可能会问，我们能不能早一点拿到 <code>valM</code>，比如 <code>m_valM</code>？不行，因为 <code>m_valM</code> 产生在 Clock 很后面的阶段（尤其是从内存读），Clock 时钟来不及。</p>
</blockquote>
<p>因此，我们只能采取 <strong>填充 3 个 Bubbles</strong> 的方法，避免出现错误：</p>
<ul>
<li><p>当 CPU 检测到 <code>ret</code> 指令结束 Fetch、进入 Decode Stage 时，<strong>立即向 Fetch Stage 发送 Stalling 信号，不允许 Fetch Stage 的状态寄存器被写入</strong>；</p>
<blockquote>
<p>为什么处理 <code>ret</code> 需要把 Fetch Stage Stall 住？因为任由 fetch stage 向下取的话，可能取到非法指令，改变了状态（stat）信息，给后面增添判断的麻烦，所以索性 stall 住。</p>
</blockquote>
</li>
<li><p>将输出到 Decode Stage 的 <code>icode</code> 改为 <code>nop</code> 的；</p>
</li>
<li><p>重复以上两个措施共 3 个 Cycles，直至 <code>ret</code> 结束 Memory Stage；</p>
</li>
</ul>
<p>这样，当 <code>ret</code> 结束 Memory Stage 时，时钟上升延会推动正确的返回地址数据到 Write Back Stage 的状态寄存器 <code>W_valM</code> 中，此时利用 Select PC，在 Fetch 阶段就能读到正确的下一条指令的地址了。</p>
<p>所以，无论如何，<code>ret</code> 后面总是要被 CPU 追加 3 个 bubble 的空隙。</p>
<p>综上，根据我们的<u><strong>猜测策略 和 修复措施</strong></u>，Select PC 的工作逻辑应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int f_PC = [</span><br><span class="line">#mispredicted branch. Fetch at incremented PC</span><br><span class="line">      M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;</span><br><span class="line">#completion of RET instruciton</span><br><span class="line">      W_icode == IRET : W_valM;</span><br><span class="line">#default: Use predicted value of PC</span><br><span class="line">      1: F_predPC</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们发现之前一条指令是 <code>jmp</code> 类，并且条件有效时，选 <code>M_valA</code>（即原封不动的 <code>valP</code> 值）；</li>
<li>当我们发现之前一条指令是 <code>ret</code> 时，意味着 Memory 结束、发送给 Write Back 的状态寄存器才是正确的地址（<code>W_valM</code>）；</li>
<li>其他的情况选择 <code>F_predPC</code>（也就是 Fetch 阶段自己算好的 <code>valP</code>）。</li>
</ul>
<hr>
<p>最后，总结一下 Y86-64 是如何解决 Control Hazard 的问题的：</p>
<ul>
<li>对于一般指令（不含 <code>jmp</code>、<code>call</code>、<code>ret</code>），只要让 Select PC 默认读 <code>valP</code>（在 Fetch 阶段就计算好的）就行，此后也无需检查、不存在 Wasted Cycles，因为下一条指令的位置一定是正确的；</li>
<li>对于 <code>call</code> 指令，只要将 Select PC 默认读 <code>valC</code>（在 Fetch 阶段就读到的）就行，此后也无需检查、不存在 Wasted Cycles，因为下一条指令的位置一定是正确的；</li>
<li>对于 <code>jmp</code> 指令，读到时默认跳转 <code>valC</code>，继续执行，但在 2 个 Cycles 后检查 <code>M_Cnd</code>，正确就什么都不做，不正确就将中间两条错误指令改为 <code>nop</code>，Fetch 阶段自动会读入正确地址。这种情况总共浪费 2 个 Cycles；</li>
<li>对于 <code>ret</code> 指令，读到时不作猜测，默认 <code>valP</code>，但是当 <code>ret</code> 进入 Decode Stage 时，Stalling Fetch Stage，并且将传给 Decode 的指令的 <code>icode</code> 改为 <code>nop</code> 的，持续 3 个 Cycles。这样 Fetch 就能通过 <code>W_valM</code> 读到正确的下一条地址。这种情况一定浪费 3 个 Cycles；</li>
</ul>
<h3 id="9-8-5-Exception-Handling-in-Pipeline"><a href="#9-8-5-Exception-Handling-in-Pipeline" class="headerlink" title="9.8.5 Exception Handling in Pipeline"></a>9.8.5 Exception Handling in Pipeline</h3><p>在之前的章节，我们介绍了 x86-64 的 Exception Control Flow，它是 OS 与硬件配合改变执行流的动作。</p>
<p>如果在 SEQ 设计中，我们只需更改 PC 寄存器即可。但是在 Pipeline 设计中，我们需要清理一些寄存器的值、某些 stage 的状态寄存器，才能转到指定的 ECF 地址。主要的步骤如下：</p>
<ol>
<li>打断当前程序执行流；</li>
<li>根据出现的事件，填入 Exception Table Base Register，找到 Exception Table 对应的 Exception Handler 地址，跳入新的执行流；</li>
<li>（可能）回到原来的执行流；</li>
</ol>
<p>我们这里先只考虑 <strong>同步异常（Synchronous Exceptions）</strong>。</p>
<p>那么可能导致同步异常的硬件层面原因有：</p>
<ul>
<li><code>halt</code> 指令；</li>
<li>指令请求错误的指令地址 / 数据地址；</li>
<li>非法指令；</li>
</ul>
<p>为了处理问题，我们还要讨论错误可能发现的位置：</p>
<ul>
<li>能在 Fetch Stage 检测的 Exceptions：<ul>
<li><code>jmp $-1</code>：<code>jmp</code> 非法地址；</li>
<li><code>.byte 0xFF</code>：非法指令；</li>
<li><code>halt</code>：程序终止；</li>
</ul>
</li>
<li>能在 Memory Stage 检测的 Exceptions：<ul>
<li><code>rmmovq %rax, 0x10000000000(%rax)</code>：非法内存地址；</li>
</ul>
</li>
</ul>
<p>但是，pipeline 的设计导致一些奇怪的情况：</p>
<p><strong>Situation 1. 异常检测顺序倒置</strong>：代码的执行流中两个错误，但是后一条错误发现时间（Fetch Stage）在前一条错误发现时间（Memory Stage）之前。导致后一条指令会先报错；</p>
<p><strong>Situation 2. 不应该触发的异常</strong>：异常的代码不在程序执行流内（例如 halt 以后不全是 0，有没擦干净的乱码；或者 <code>jmp</code> 的另一个不会执行的分支），但是 CPU 仍然可能读入并报错；</p>
<p>你可能会想，我们要模仿 SEQ，<strong>先检测到错误没事，只要我们在这条指令完全结束后（该指令到 Write Back Stage 结束）再报出错误，就能避免上面两种情况的发生</strong>。但这样做可能引发另一类问题：</p>
<p><strong>Situation 3. 异常指令的 Side Effect</strong>：错误指令和正常指令一起在流水线中向上传播，可能会导致 CC 被错误地修改（例如<strong>在错误指令后面的指令不应该被执行，但是它仍然更改了 CC</strong>，这会影响 Dump 的数据）；</p>
<p>综合以上的情况，我们总结出了解决方案：</p>
<ul>
<li><p>类比 Program Status，<strong>在每个 stage 的状态（除了 fetch）寄存器中加入 <code>stat</code> 寄存器，表示当前指令的执行情况。<code>AOK</code> 表示指令正常，<code>ADR</code> 表示指令访问错误地址，<code>HTL</code> 表示 <code>halt</code> 终止指令（方便阻止 <code>halt</code> 以后的指令的执行），<code>INS</code> 表示非法指令</strong>；</p>
</li>
<li><p>Fetch Stage 或 Memory Stage 如果能检测出错误，那么就设置到下一个阶段的 <code>stat</code> 寄存器；其余阶段（<code>Decode</code>、<code>Execute</code>）直接传递 <code>stat</code> 寄存器；</p>
<p>即：当异常出现时，仅仅设置状态寄存器（stat），其他正常；</p>
</li>
<li><p>如果异常到达 Memory 阶段，则为了防止错误指令影响状态寄存器或 CC，进行以下措施：</p>
<ol>
<li><p>对于非法指令，接下来向 Memory 阶段插 bubbles：即对于非法的内存操作，不允许写入内存；</p>
</li>
<li><p>立即关闭之后的 Execute 阶段写入 CC；</p>
</li>
</ol>
</li>
<li><p>如果异常到达 Write Back 阶段，则将该阶段 stall 住，抛出错误（只有在 Write-Back 阶段被触发，保证异常触发的顺序）。</p>
<blockquote>
<p>检查 <code>W_stall</code> 的条件，只需要检查 <code>W_stat</code> 就行，不需要管 <code>m_stat</code>；</p>
</blockquote>
</li>
<li><p>最后打断当前执行流：</p>
<ol>
<li>将 next PC 值 / 触发异常的指令 PC 压入栈中（通常和 exception <code>stat</code> 一起传递）；</li>
<li>使用事先固定在 ISA 中的 Exception Handler Address 跳转到 handler 中执行。</li>
</ol>
</li>
</ul>
<h3 id="9-8-5-Final-Implementation"><a href="#9-8-5-Final-Implementation" class="headerlink" title="9.8.5 Final Implementation"></a>9.8.5 Final Implementation</h3><p>我们将前几节的 Pipeline 设计的思想和注意要点结合起来，考虑设计一个 Y86-64 pipeline 处理器的最终版本。</p>
<h3 id="9-8-6-Performance-Analysis-Metrics"><a href="#9-8-6-Performance-Analysis-Metrics" class="headerlink" title="9.8.6 Performance Analysis: Metrics"></a>9.8.6 Performance Analysis: Metrics</h3><ul>
<li><p>Clock Rate</p>
</li>
<li><p>CPI (Cycles per instruction): On average, how many clock cycles does each instruction require?</p>
<script type="math/tex; mode=display">
CPI=\dfrac{C}{I}=\dfrac{I+B}{I}=1+\dfrac{B}{I}</script><p>其中 $C$ 表示时钟 cycle 数，$I$ 为在 $C$ 个时钟 cycles 下执行的指令数，$B$ 为在 $C$ 个时钟 cycles 下插入的 bubble 数（$C=B+I$）；如果 $LP$、$MP$、$RP$ 分别代表 Load/Use Hazard、Misprediction Hazard、Return Hazard <strong>平均一条指令中出现的次数</strong>，那么：</p>
<script type="math/tex; mode=display">
\dfrac{B}{I}=LP+MP+RP</script></li>
</ul>
<p>比如我们利用 Metrics 的指引进行优化：Speculation Execution in Fetch Logic；</p>
<p>考虑 PIPE CPU 的关键路径：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/pipe-criticalpath.png" height="150px"></p>
<p>我们发现 increment 阶段是关键路径上较大的部分，它要等待 regids、valC 结果，然后执行 64-bits 的加法运算（最多 +10），所以我们可以先将前 60 bits 的数据 +1（同时保留不加、+1 的数据），然后另一部分仅仅是 4 bits 数的相加，这样可以节省串行进位加法所耗费的时间，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs2/pc-improve.png" height="300px"></p>
<p>这样指令总体的速度都会快上一些。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SJTU-XHW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/review/csapp-sched-arch/">https://blog.sjtuxhw.top/review/csapp-sched-arch/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SJTU-XHW's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GNU/">GNU</a><a class="post-meta__tags" href="/tags/CSAPP/">CSAPP</a><a class="post-meta__tags" href="/tags/ICS/">ICS</a><a class="post-meta__tags" href="/tags/Programming/">Programming</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/csapp_p2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/chat/summer-rest/" title="放假！吐槽！"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/tease.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">放假！吐槽！</div></div><div class="info-2"><div class="info-item-1">Hooray !家人们，经历了大半个月的期末周，终于来到假期了！我又活过来了😭 上个学期的时间安排实在是不太充裕，我想我得调整下节奏了🤔 ツッコミ吐槽一下，在准备考试的时候，我和同学们为了分数反复写一些固定的题型，尤其是物理题。不是说我们不应该做物理题，而是这样的做法时间利用的效率真的不高。 之前看到过一篇文章说的感觉挺有道理的。我们常常听一些教育专家说，现在的学生要全面培养学科交叉能力，我无比赞同这句话，毕竟学科交叉既能开阔我们的专业视野，了解到很多其他方面的学识，又能提升我们的综合素质和学术能力，这是毋庸置疑的。 另一方面，我认为这个学科交叉是需要说明限度和范围的，而不是学科课表的 “自由组合”。以工科类专业举例，很多人会想，工科嘛，那不得来一整套大学物理，一直学到量子力学，加一点 “金课”，再加五花八门的大学物理实验；末了，再添一点理论力学、甚至大学化学，entitled “学科交叉素养的培养”。 这个本意是好的，但：每当我看到有些工科同学（惭愧地说，包括笔者）拿着学长学姐留下的...</div></div></div></a><a class="pagination-related" href="/chat/anime-bokumachi/" title="《只有我不在的城市》番评"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/anime_bokumachi.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">《只有我不在的城市》番评</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference:  维基百科词条、只有我不在的街道 (豆瓣) 声明：本文仅代表个人主观观点，侵删。 【重要】本文除去剧透警戒线下部分，其他内容不含具体故事情节。  在我看过的一百多来部的番剧中，有的能真正扣住我心弦，这大抵是少数；现在看来大多却是 “食之无味，弃之可惜”。初中时期的我曾经浅浅尝试过一部，但是由于开头比较惊悚的画面，还有网友打上的 NTR 标签，让我一直敬而远之、束之高阁。这部番的名字是《只有我不在的城市》(僕だけがいない街) 。 距离我第一次接触它已经过了好几年的时间，我也不是当年看番只看 HE...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/review/csapp-basic/" title="CSAPP Notes Basic"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="info-item-2">CSAPP Notes Basic</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference:  CMU - 213, Computer Systems A Programmer’s Perspective 3rd Edition by Randal Bryant, David O’Hallaron 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 内容很长，写起来很慢 😳   Chapter 0. Intro0.1 Ints are not Integers, Floats are not Reals $x^2\ge 0$：int（32-bit）may overflow； $a+(b+c)=(a+b)+c$：floats may discard some “unsignificant” digits；  0.2 Learn Assembly but never write it0.3 Memory Matters: Unbounded1234567891011121314typedef struct &#123;    int a[2];    double d;&#125;...</div></div></div></a><a class="pagination-related" href="/review/csapp-ecf-io/" title="CSAPP Notes: ECF &amp; I&#x2F;O"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-ecf.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-16</div><div class="info-item-2">CSAPP Notes: ECF &amp; I&#x2F;O</div></div><div class="info-2"><div class="info-item-1">Chapter 13. Exceptional Control Flow 对应书中第 8 章。  异常控制流是现代计算机系统的一个相当重要的部分。 13.1 Control Flow 控制流：从机器打开到关闭的过程中，处理器只做一件事：读指令、执行指令，一个周期做一个指令。多核的机器则每个核心依次交替执行指令。这些指令序列被称为控制流。硬件正在执行的实际指令序列就被称为物理控制流。  改变内存中控制流的方法：分支 &amp; 跳转，过程调用 &amp; 返回（Branches &amp; Jumps &amp; Procedure call and return）；  都是对于程序状态变化的处理。    但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）； 什么是 “系统级别的状态变化”？  数据从磁盘 / 网卡到达内存中； I/O 设备输入...</div></div></div></a><a class="pagination-related" href="/review/csapp-mm-cache/" title="CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-mh.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-10</div><div class="info-item-2">CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt</div></div><div class="info-2"><div class="info-item-1">Chapter 10. The Memory Hierarchy 本章将介绍系统的内存分层架构。  之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。 正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。 10.1 Storage Technologies &amp; Trends在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。 10.1.1 Random-Access Memory (RAM)当前大多数人所熟知的 “内存” 的一部分就是随机访问存储器（RAM），它具有以下的特征：  RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；  RAM 常常被打包放在 CPU 芯片中；  RAM 中每一个基本的存储单元被称为 单元胞（Cell），一个单元胞中存放 1 bit 数据；  很多个 RAM 芯片共同工作，组成了计算机的...</div></div></div></a><a class="pagination-related" href="/technical/semaphore-mutex-and-cv/" title="Semaphore, Mutex, CV"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/smc.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-11</div><div class="info-item-2">Semaphore, Mutex, CV</div></div><div class="info-2"><div class="info-item-1">学习 ICS 的并行一章之后，笔者有些疑惑，semaphore（信号量）、mutex（互斥锁）、conditional variables（条件变量）这 3 者之间究竟该怎么区分它们的使用场景？ 首先我们需要去阐述清楚它们各自的定义和效果。 学术界认为 mutex 是 semaphore 的特例，因此像著名的书籍 CSAPP 就先以 semaphore 为例讲了讲并发程序的资源控制问题。但是实际上有相当一部分实践派和语义派认为二者不应该混为一谈。像 Linus 本人在一次将 Linux 内核的一部分 semaphore 重构为 mutex 后，发现不仅改善了代码语义，还在一定程度上提升了性能。这件事也说明了，虽然在理论上一方可以替代另一方，但实践上它们各有所长。 Semaphore vs Mutex我们先讨论 semaphore。 CSAPP 中先从 “线程间变量共享” 的情况说起，它指出，程序对内存的更改并不直接在内存上完成，在汇编中可以看到，大致经历了 load（从内存到 CPU 寄存器）、update（在 CPU 寄存器内更新数据）、store（将 CPU...</div></div></div></a><a class="pagination-related" href="/technical/gnu-tutor/" title="GNU-Tutor"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/GNU-Tutor.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="info-item-2">GNU-Tutor</div></div><div class="info-2"><div class="info-item-1">基础：C/C++的源文件编译过程 想要代码在操作系统上运行，需要进行以下编译步骤，从高级语言转机器语言，以下任务gcc/g++均能完成：  预编译（.c/cpp &amp; .h —&gt; .i ）：*对应gcc/g++命令：gcc -E [xxx] -o [output.i] 展开所有宏定义#define（字符替换）； 处理所有条件预编译命令（#ifdef、#ifndef、#endif等）； 处理#include，具体操作是将指向的文件直接插入到文件的这一行（严格遵循上一步的条件）； 删除所有注释； 添加行号、文件标识，以便调试/编译出错时及时指出； 保留#pragma指令，以供编译器使用；   编译（.i —&gt; .s ，即高级语言转汇编语言）：对应gcc/g++命令：gcc -S [xxx] -o...</div></div></div></a><a class="pagination-related" href="/review/makefile-again/" title="Makefile 快速上手 (again)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/makefile-again.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-11</div><div class="info-item-2">Makefile 快速上手 (again)</div></div><div class="info-2"><div class="info-item-1">说来惭愧，之前笔者还认为 Makefile 这种工具已经过时，只需要学 CMake 就行。 但最近在写 boot loader 时遇到了一些问题：我既不是在编译可执行文件，也不是在编译库，这样 CMake 就显得比较无力了，因为总是用 add_custom_* 也不是办法，非常臃肿——毕竟不是在管理一个 C/C++ 应用的项目嘛。所以决定再整理一下 Makefile 的写法。 本文充当一个 Makefile cheat sheet 的作用，自己有点遗忘的时候回来查一查。  Define a Target在 Makefile 中定义一个可以构建的 target： 12345&lt;target&gt;: dependency1 dependency2 ... dependency3    command1    command2    ...    commandM 这样可以使用 make &lt;target&gt; 来执行它。 注意哦，make 会认为 &lt;target&gt; 是一个需要构建的目标文件名。最终按照 commands 生成的文件会被命名为...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SJTU-XHW</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-8-Scheduler-in-OS"><span class="toc-text">Chapter 8. Scheduler in OS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Strategy-1-FIFO%EF%BC%88FCFS%EF%BC%8CFirst-Come-First-Served%EF%BC%89"><span class="toc-text">Strategy 1: FIFO（FCFS，First Come First Served）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Strategy-2-SJF%EF%BC%88Shortest-Job-First%EF%BC%89"><span class="toc-text">Strategy 2 : SJF（Shortest Job First）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Strategy-3-STCF%EF%BC%88Shortest-Time-to-Completion-First%EF%BC%89"><span class="toc-text">Strategy 3 : STCF（Shortest Time-to-Completion First）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Strategy-4-Round-Robin%EF%BC%88%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%EF%BC%89"><span class="toc-text">Strategy 4 : Round Robin（时间片轮转）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Strategy-5-Overlap-when-performing-I-O-operation"><span class="toc-text">Strategy 5 : Overlap when performing I&#x2F;O operation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Strategy-6-Multi-Level-Feedback-Queue-Scheduler%EF%BC%88MLFQ%EF%BC%89"><span class="toc-text">Strategy 6 : Multi-Level Feedback Queue Scheduler（MLFQ）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-9-Y86-64-A-self-defined-ISA"><span class="toc-text">Chapter 9. Y86-64: A self-defined ISA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-Y86-64-Processor-State"><span class="toc-text">9.1 Y86-64 Processor State</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-Y86-64-Instructions"><span class="toc-text">9.2 Y86-64 Instructions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E7%A8%8B%E5%BA%8F%E7%BB%88%E6%AD%A2%E6%8C%87%E4%BB%A4%E7%B1%BB-halt%EF%BC%9A0x00"><span class="toc-text">9.2.1 程序终止指令类 halt：0x00</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-%E7%A9%BA%E6%8C%87%E4%BB%A4%E7%B1%BB-nop%EF%BC%9A0x10"><span class="toc-text">9.2.2 空指令类 nop：0x10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%BB%E5%8A%A8%E6%8C%87%E4%BB%A4%E7%B1%BB"><span class="toc-text">9.2.3 寄存器移动指令类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-4-%E7%9B%B4%E6%8E%A5%E9%87%8F-%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%BB%E5%8A%A8%E6%8C%87%E4%BB%A4%E7%B1%BB"><span class="toc-text">9.2.4 直接量-寄存器移动指令类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-5-%E5%AF%84%E5%AD%98%E5%99%A8-%E5%86%85%E5%AD%98%E7%A7%BB%E5%8A%A8%E6%8C%87%E4%BB%A4%E7%B1%BB"><span class="toc-text">9.2.5 寄存器-内存移动指令类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-6-%E5%86%85%E5%AD%98-%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%BB%E5%8A%A8%E6%8C%87%E4%BB%A4%E7%B1%BB"><span class="toc-text">9.2.6 内存-寄存器移动指令类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-7-%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4%E7%B1%BB"><span class="toc-text">9.2.7 运算指令类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-8-%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E7%B1%BB"><span class="toc-text">9.2.8 跳转指令类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-9-%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4%E7%B1%BB"><span class="toc-text">9.2.9 调用指令类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-10-%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4%E7%B1%BB-ret%EF%BC%9A0x90"><span class="toc-text">9.2.10 返回指令类 ret：0x90</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-11-%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9B%E6%A0%88%E6%8C%87%E4%BB%A4%E7%B1%BB"><span class="toc-text">9.2.11 寄存器进栈指令类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-12-%E5%AF%84%E5%AD%98%E5%99%A8%E5%87%BA%E6%A0%88%E6%8C%87%E4%BB%A4%E7%B1%BB"><span class="toc-text">9.2.12 寄存器出栈指令类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-Y86-64-Program-Stack"><span class="toc-text">9.3 Y86-64 Program Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E5%8D%8A%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-text">9.4 半章小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-CPU-Design-CISC-vs-RISC"><span class="toc-text">9.5 CPU Design: CISC vs RISC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-CPU-Design-Logic-Design-amp-HCL"><span class="toc-text">9.5 CPU Design: Logic Design &amp; HCL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hardware-Control-Language-Syntax"><span class="toc-text">Hardware Control Language Syntax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arithmetic-Logic-Unit-Design"><span class="toc-text">Arithmetic Logic Unit Design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Register-Storage-Design"><span class="toc-text">Register(Storage) Design</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-CPU-Design-SEQ-General"><span class="toc-text">9.6 CPU Design: SEQ General</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-1-General-Principle"><span class="toc-text">9.6.1 General Principle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-2-Basic-Framework"><span class="toc-text">9.6.2 Basic Framework</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-3-Describe-Assembly-with-Framework"><span class="toc-text">9.6.3 Describe Assembly with Framework</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-4-Advantages-amp-Disadvantages"><span class="toc-text">9.6.4 Advantages &amp; Disadvantages</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-Principles-of-Pipeline"><span class="toc-text">9.7 Principles of Pipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-1-Time-Analysis-SEQ"><span class="toc-text">9.7.1 Time Analysis: SEQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-2-Time-Analysis-N-Way-Pipelined"><span class="toc-text">9.7.2 Time Analysis: N-Way-Pipelined</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Limitation-1-Nonuniform-Delays"><span class="toc-text">Limitation 1: Nonuniform Delays</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Limitation-2-Register-Overhead"><span class="toc-text">Limitation 2: Register Overhead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Limitation-3-Data-Dependency-amp-Data-Hazard"><span class="toc-text">Limitation 3: Data Dependency &amp; Data Hazard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Limitation-4-Control-Dependency"><span class="toc-text">Limitation 4: Control Dependency</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-Pipeline-Implementation"><span class="toc-text">9.8 Pipeline Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-1-Hardware"><span class="toc-text">9.8.1 Hardware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-2-Resolve-Data-Hazard-Data-Forwarding-amp-Stalling"><span class="toc-text">9.8.2 Resolve Data Hazard: Data Forwarding &amp; Stalling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-3-Resolve-Control-Hazard-Part-%E2%85%A0-Predicting-the-PC"><span class="toc-text">9.8.3 Resolve Control Hazard Part Ⅰ: Predicting the PC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-4-Resolve-Control-Hazard-Part-%E2%85%A1-Fix-Wrong-Predictions"><span class="toc-text">9.8.4 Resolve Control Hazard Part Ⅱ: Fix Wrong Predictions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-5-Exception-Handling-in-Pipeline"><span class="toc-text">9.8.5 Exception Handling in Pipeline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-5-Final-Implementation"><span class="toc-text">9.8.5 Final Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-6-Performance-Analysis-Metrics"><span class="toc-text">9.8.6 Performance Analysis: Metrics</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/java-adv-3/" title="Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/java-adv-3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI"/></a><div class="content"><a class="title" href="/technical/java-adv-3/" title="Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI">Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI</a><time datetime="2025-01-06T05:44:06.000Z" title="发表于 2025-01-06 13:44:06">2025-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/algo-desgin-table/" title="算法设计知识点自查表"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/algo-design-table.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法设计知识点自查表"/></a><div class="content"><a class="title" href="/review/algo-desgin-table/" title="算法设计知识点自查表">算法设计知识点自查表</a><time datetime="2024-12-31T14:47:03.000Z" title="发表于 2024-12-31 22:47:03">2024-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/redis-starter/" title="Redis 入门：从实践到理论"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/redis.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 入门：从实践到理论"/></a><div class="content"><a class="title" href="/technical/redis-starter/" title="Redis 入门：从实践到理论">Redis 入门：从实践到理论</a><time datetime="2024-11-12T13:05:37.000Z" title="发表于 2024-11-12 21:05:37">2024-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/python-sci-starter/" title="Python 科学计算入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/python_sci.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 科学计算入门"/></a><div class="content"><a class="title" href="/technical/python-sci-starter/" title="Python 科学计算入门">Python 科学计算入门</a><time datetime="2024-11-03T11:08:13.000Z" title="发表于 2024-11-03 19:08:13">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/hilog-paper/" title="OpenHarmony Hilog 架构趣读"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/hilog-paper.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenHarmony Hilog 架构趣读"/></a><div class="content"><a class="title" href="/technical/hilog-paper/" title="OpenHarmony Hilog 架构趣读">OpenHarmony Hilog 架构趣读</a><time datetime="2024-10-29T05:14:04.000Z" title="发表于 2024-10-29 13:14:04">2024-10-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SJTU-XHW  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Powered By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>