<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CSAPP Notes Chapter1~3 | SJTU-XHW's blog</title><meta name="author" content="SJTU-XHW,sjtuxhw12345@sjtu.edu.cn"><meta name="copyright" content="SJTU-XHW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="written by SJTU-XHW Reference:  CMU - 213, Computer Systems A Programmer’s Perspective 3rd Edition by Randal Bryant, David O’Hallaron 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 内容很长，写起来很慢 😳">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP Notes Chapter1~3">
<meta property="og:url" content="https://sjtuxhw.asia/2023/09/17/CSAPP-Notes-Chapter1-3/index.html">
<meta property="og:site_name" content="SJTU-XHW&#39;s blog">
<meta property="og:description" content="written by SJTU-XHW Reference:  CMU - 213, Computer Systems A Programmer’s Perspective 3rd Edition by Randal Bryant, David O’Hallaron 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 内容很长，写起来很慢 😳">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg">
<meta property="article:published_time" content="2023-09-17T23:47:15.000Z">
<meta property="article:modified_time" content="2023-09-19T05:18:35.682Z">
<meta property="article:author" content="SJTU-XHW">
<meta property="article:tag" content="GNU">
<meta property="article:tag" content="CSAPP">
<meta property="article:tag" content="ICS">
<meta property="article:tag" content="Programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg"><link rel="shortcut icon" href="/myBlog/img/favicon.ico"><link rel="canonical" href="https://sjtuxhw.asia/2023/09/17/CSAPP-Notes-Chapter1-3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/myBlog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?64dd3b0c09c8af7b916f8249d32097e2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/myBlog/',
  algolia: undefined,
  localSearch: {"path":"/myBlog/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CSAPP Notes Chapter1~3',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-19 01:18:35'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/myBlog/css/mouseConfig.css"><link rel="stylesheet" href="/myBlog/css/valineBg.css"><link rel="stylesheet" href="/myBlog/css/rightmenu.css"><link rel="stylesheet" href="/myBlog/css/custom_music.css"><link rel="stylesheet" href="/myBlog/css/addFonts.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/myBlog/atom.xml" title="SJTU-XHW's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/myBlog/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/myBlog/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/myBlog/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/myBlog/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/myBlog/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/myBlog/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/myBlog/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/update-log/v0.3.0-Beta.html"><i class="fa-fw fa fa-arrow-circle-up"></i><span> Update</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg')"><nav id="nav"><span id="blog-info"><a href="/myBlog/" title="SJTU-XHW's blog"><img class="site-icon" src="/myBlog/img/head_icon.png"/><span class="site-name">SJTU-XHW's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/myBlog/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/myBlog/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/myBlog/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/update-log/v0.3.0-Beta.html"><i class="fa-fw fa fa-arrow-circle-up"></i><span> Update</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CSAPP Notes Chapter1~3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-17T23:47:15.000Z" title="发表于 2023-09-17 19:47:15">2023-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-19T05:18:35.682Z" title="更新于 2023-09-19 01:18:35">2023-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/myBlog/categories/review/">review</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">36.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>133分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/myBlog/2023/09/17/CSAPP-Notes-Chapter1-3/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><i>written by SJTU-XHW</i></p>
<p><i>Reference: </i> <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cs.cmu.edu/~213/schedule.html">CMU - 213</a>, <i>Computer Systems A Programmer’s Perspective 3rd Edition</i> by Randal Bryant, David O’Hallaron</p>
<p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p>
<p><i>内容很长，写起来很慢</i> 😳</p>
<hr>
<span id="more"></span>
<h2 id="Chapter-0-Intro"><a href="#Chapter-0-Intro" class="headerlink" title="Chapter 0. Intro"></a>Chapter 0. Intro</h2><h3 id="0-1-Ints-are-not-Integers-Floats-are-not-Reals"><a href="#0-1-Ints-are-not-Integers-Floats-are-not-Reals" class="headerlink" title="0.1 Ints are not Integers, Floats are not Reals"></a>0.1 Ints are not Integers, Floats are not Reals</h3><ul>
<li>$x^2\ge 0$：int（32-bit）may overflow；</li>
<li>$a+(b+c)=(a+b)+c$：floats may discard some “unsignificant” digits；</li>
</ul>
<h3 id="0-2-Learn-Assembly-but-never-write-it"><a href="#0-2-Learn-Assembly-but-never-write-it" class="headerlink" title="0.2 Learn Assembly but never write it"></a>0.2 Learn Assembly but never write it</h3><h3 id="0-3-Memory-Matters-Unbounded"><a href="#0-3-Memory-Matters-Unbounded" class="headerlink" title="0.3 Memory Matters: Unbounded"></a>0.3 Memory Matters: Unbounded</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125; <span class="type">struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">struct_t</span> t;</span><br><span class="line">    t.d = <span class="number">3.14</span>;</span><br><span class="line">    t.a[i] = <span class="number">109390032</span>;</span><br><span class="line">    <span class="keyword">return</span> t.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// func(0)/func(1) -&gt; 3.14</span></span><br><span class="line"><span class="comment">// func(2)    -&gt; 3.13...</span></span><br><span class="line"><span class="comment">// func(6)    -&gt; segment fault</span></span><br></pre></td></tr></table></figure>
<ul>
<li>C/C++ don’t provide <strong>any</strong> memory protection（out of bounds/invalid pointer/abuse of malloc-free）: can lead to nasty bugs.</li>
</ul>
<h3 id="0-4-There’s-more-to-performance-than-asymtotic-complexity"><a href="#0-4-There’s-more-to-performance-than-asymtotic-complexity" class="headerlink" title="0.4 There’s more to performance than asymtotic complexity"></a>0.4 There’s more to performance than asymtotic complexity</h3><p>(有比渐进复杂度更能够优化性能的做法)</p>
<ul>
<li>渐进复杂度中没有体现的“常数”也很重要；</li>
<li>应该在多方面优化性能：算法、数据结构表示、代码过程、循环等；</li>
<li><strong>Understand system to optimize performance</strong>;</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyij</span><span class="params">(<span class="type">int</span> src[<span class="number">2048</span>][<span class="number">2048</span>], dst[<span class="number">2048</span>][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2048</span>; ++j)</span><br><span class="line">            dst[i][j] = src[i][j];        <span class="comment">// Row first.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyji</span><span class="params">(<span class="type">int</span> src[<span class="number">2048</span>][<span class="number">2048</span>], dst[<span class="number">2048</span>][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2048</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; ++i)</span><br><span class="line">            dst[i][j] = src[i][j];        <span class="comment">// Column first.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In a particular machine it was about close to 20 times difference in performance! (4.3ms vs 81.8ms) </span></span><br><span class="line"><span class="comment">// Memory hierachy: Cache memory</span></span><br></pre></td></tr></table></figure>
<h3 id="0-5-Computers-do-more-than-execute-programs"><a href="#0-5-Computers-do-more-than-execute-programs" class="headerlink" title="0.5 Computers do more than execute programs"></a>0.5 Computers do more than execute programs</h3><ul>
<li>They need to get data in &amp; out: I/O system;</li>
<li>They communicate with each other over network;</li>
</ul>
<h2 id="Chapter-1-Bits-Bytes-and-Integers"><a href="#Chapter-1-Bits-Bytes-and-Integers" class="headerlink" title="Chapter 1. Bits, Bytes and Integers"></a>Chapter 1. Bits, Bytes and Integers</h2><h3 id="1-1-Everythings-is-bits"><a href="#1-1-Everythings-is-bits" class="headerlink" title="1.1 Everythings is bits"></a>1.1 Everythings is bits</h3><blockquote>
<p>本部分知识零碎，应该在数电 + 初级数据结构中接触。</p>
</blockquote>
<ul>
<li>Each bit is 0 or 1;</li>
<li>By encoding/interpreting sets of bits in various ways;</li>
<li>Why bits? - Electronic Implemetation.<ul>
<li><strong>Easy to store</strong> with bistable elements.</li>
<li><strong>Reliably transmitted</strong> on noisy and inaccurate wires.</li>
</ul>
</li>
<li><strong>Base 2 Number Representation</strong></li>
<li><p>1 Byte = 8 bits；</p>
<ul>
<li>Binary：$00000000_2$ to $11111111_2$；</li>
<li>Decimal：$0_{10}$ to $255_{10}$；</li>
<li>Hexadecimal：$00_{16}$ to $FF_{16}$；<ul>
<li>掌握快速 16 进制转 2 进制：$1010=A,\space1100=C,\space1111=F$，B/D/E 在其中；</li>
</ul>
</li>
</ul>
</li>
<li><p>Data Representation in C language</p>
<table>
    <tr>
        <td>C Data Type</td>
        <td>Typical 32-bit</td>
        <td>Typical 64-bit</td>
        <td>x86-64</td>
    </tr>
    <tr>
        <td>char</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
    </tr>
    <tr>
        <td>short</td>
        <td>2</td>
        <td>2</td>
        <td>2</td>
    </tr>
    <tr>
        <td>int</td>
        <td>4</td>
        <td>4</td>
        <td>4</td>
    </tr>
    <tr>
        <td>long</td>
        <td>4</td>
        <td>8</td>
        <td>8</td>
    </tr>
    <tr>
        <td>float</td>
        <td>4</td>
        <td>4</td>
        <td>4</td>
    </tr>
    <tr>
        <td>double</td>
        <td>8</td>
        <td>8</td>
        <td>8</td>
    </tr>
    <tr>
        <td>long double</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>10 / 16</td>
    </tr>
    <tr>
        <td>pointer</td>
        <td>4</td>
        <td>8</td>
        <td>8</td>
    </tr>
</table>

<ul>
<li><strong>注：单位 bytes，CSAPP 关注 x86-64 架构</strong>；</li>
<li><strong>注2：Intel x86-64 处理器的 <code>long double</code> 定为 10 bytes，但数据增量是 16 bytes，意味着会浪费 6 bytes 的存储空间</strong>；</li>
<li><strong>注3：pointer 值就是虚拟空间的地址，上面也正说明了 32 位和 64 位的名字的来源：这些虚拟内存的地址是 32 bits / 64 bits 长度的值</strong>；我们常说的 32 位机器、64 位机器就是指对应地址值的长度是 32/64 bits；</li>
</ul>
</li>
</ul>
<h3 id="1-2-Boolean-Algebra"><a href="#1-2-Boolean-Algebra" class="headerlink" title="1.2 Boolean Algebra"></a>1.2 Boolean Algebra</h3><ul>
<li><p>Developed by George boole in 19C, “True”: 1, “False”: 0;</p>
</li>
<li><p>Operations: And(<strong>\&amp;</strong>) / Or(<strong>|</strong>) / Not(<strong>~</strong>) / Exclusive-or(<strong>Xor, ^</strong>);</p>
<ul>
<li>Exercise: Operate on Bit Vectors;</li>
</ul>
</li>
<li><p><strong>Example: Representing &amp; Manipulating Sets</strong></p>
<ul>
<li><p>Representation: <strong>Width <code>w</code> bit vector can represent subsets of <code>&#123;0,...,w-1&#125;</code></strong>;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp; &lt;=&gt; Intersection</span><br><span class="line">| &lt;=&gt; Union</span><br><span class="line">^ &lt;=&gt; Symmetric Difference</span><br><span class="line">~ &lt;=&gt; Complement</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Shift Operations</p>
<ul>
<li>left shift、right shift；</li>
<li>logic shift：Fill with “0”；</li>
<li>arithmetic shift：if (negetive) Fill with “1”，else Fill with “0”；</li>
<li><strong>Undefined Behavior</strong>: shift amount <strong>&lt; 0</strong> or shift amount <strong>≥ word size</strong>；</li>
</ul>
</li>
</ul>
<h3 id="1-3-原码-true-form-、反码-1’s-complement-、补码-2’s-complement"><a href="#1-3-原码-true-form-、反码-1’s-complement-、补码-2’s-complement" class="headerlink" title="1.3 原码(true form)、反码(1’s complement)、补码(2’s complement)"></a>1.3 原码(true form)、反码(1’s complement)、补码(2’s complement)</h3><ul>
<li><p>补码速译：<strong>最高位权重变为负值</strong>；</p>
</li>
<li><p>Unsigned range：$0\sim 2^w-1$；</p>
<p>Two’s complement range：$-2^{w-1}\sim2^{w-1}-1$；</p>
</li>
<li><p><strong>模 8 运算：保留补码后三位</strong>；</p>
</li>
<li><p>Exercise 1: <strong>Mapping between signed &amp; unsigned</strong></p>
<p>（将同一个数码看作不同的数，例如 11111111 可以表示 unsigned 的 255，也可以表示 signed -1，这两者相同的数码被称为 “<strong>相同的位模式（bit pattern）</strong>”）</p>
<blockquote>
<p>这对计算机很重要，因为它原本不知道是 signed 还是 unsigned；</p>
</blockquote>
</li>
<li><p>Exercise 2: <strong>Casting Surprises</strong>（模糊的常数给定，什么时候类型转换？怎么转换？）</p>
<ul>
<li><p>什么时候：C++ 书中说，在赋值、比较时进行<strong>隐式类型转换（implicit casting）</strong>，还可以进行强制类型转换；</p>
</li>
<li><p>怎么转换：</p>
<ol>
<li>占用空间小的类型向大的类型转换：<strong>同时有 unsigned int 和 int，则向 unsigned int 转换</strong>（隐式类型转换）；</li>
<li>Bit pattern（位模式）保持不变；</li>
</ol>
</li>
<li><p>编程的麻烦：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// situation 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="built_in">func</span>(a[i]);</span><br><span class="line"><span class="comment">// situation 2</span></span><br><span class="line"><span class="comment">// 提示：sizeof 的返回值会被编译器认为是 size_t (unsigned long)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i - <span class="built_in">sizeof</span>(<span class="type">char</span>) &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="built_in">func</span>(a[i]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Exercise 3: <strong>Sign Extension</strong>（在不改变值的情况下，将 w-bit 数变为 w+k-bit (k∈Z) 数）</p>
<ul>
<li><p><strong>Expanding Conclusion: Make k copies of MSB in signed, but fill “0” in unsigned.</strong></p>
<blockquote>
<p>想想为什么。</p>
</blockquote>
</li>
<li><p><strong>Truncating Conclusion: mod $2^w$ in unsigned,  很像 mod $2^w$ 但不是 in signed (negative or positive)</strong>;</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-4-Operations"><a href="#1-4-Operations" class="headerlink" title="1.4 Operations"></a>1.4 Operations</h3><ul>
<li><p>Unsigned Addition: $sum=UAdd_w(u,v)=u+v\mod2^w$（为什么成立？<strong>Truncating Conclusion</strong>）；</p>
<ul>
<li>一种溢出，这种溢出是模运算可以描述的；</li>
</ul>
<blockquote>
<p>e.g., $(unsigned)13+5=1101_2+0101_2\Rightarrow0010_2$ (<strong>Truncated</strong>)</p>
</blockquote>
</li>
<li><p>Two’s complement Addition: $sum=TAdd_w(u,v)=UAdd_w(u,v)$（<strong>equal in bit pattern</strong>, <strong>Truncating Conclusion</strong>）;</p>
<ul>
<li>两种溢出：负溢出（$sum\le-2^{w-1}$ 时）和 正溢出（$sum\ge w^{w-1}$ 时）;</li>
</ul>
</li>
<li><p>Unsigned Multiplication: $multi=UMult_w(u,v)=u\cdot v\mod2^w$（与加法同理）;</p>
</li>
<li><p>Signed Multiplication Multiplication: $multi=TMulti_w(u,v)=UMulti_w(u,v)$（与加法同理）;</p>
</li>
</ul>
<blockquote>
<p>这意味着计算机的乘法、加法可以共用硬件；</p>
</blockquote>
<ul>
<li><p>Shift &amp; Power-of-2 Multiply / Divide: 原因可以看作改变权重；</p>
<ul>
<li><p>Unsigned: no problem；</p>
</li>
<li><p>Signed: <strong>Use arithmetic shift. Add a bias（偏移量 1）to bit pattern and then shift</strong></p>
<blockquote>
<ol>
<li><p>为什么用 <strong>算数移位</strong>？因为 <strong>Expanding Conclusion</strong>；至于什么移位，C++ 标准没有明确说，但绝大多数机器都会算术移位；</p>
</li>
<li><p>为什么要偏移量？使结果向大数舍入；</p>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>Negative（取相反数，当然只有 signed 做得到）：<strong>flip all the bits and then add 1</strong>（“~” 取反 + 1）</p>
</li>
<li><p>在介绍完移位运算后，回忆 1.3 中的 “编程麻烦”，能不能不用 unsigned，通通用 signed （全用补码表示）不就不会出现这些 casting suprises 了吗？确实，C++ 中尽量别用 unsigned，容易出问题；</p>
<blockquote>
<p>Java 就是这么做的。取消了 unsigned 的类型，<strong>并且禁止了某些隐式类型转换</strong>。但因为某些其他的需求，Java 不得不引入算数移位（&gt;&gt;&gt; 和 &lt;&lt;&lt;），就是 C++ 中处理 signed divide 的运算符;</p>
</blockquote>
<p><strong>但 unsigned 也有用处</strong>：</p>
<ul>
<li>取模运算：利用 unsigned 加法溢出特性；</li>
<li>使用 bits 来代表集合（1.2）；</li>
</ul>
</li>
</ul>
<h3 id="1-5-Miscellaneous"><a href="#1-5-Miscellaneous" class="headerlink" title="1.5 Miscellaneous"></a>1.5 Miscellaneous</h3><ul>
<li><p><strong>2 的幂次数大小估算</strong>：因为 $2^{10}\approx10^3$，这意味着每 3 位十进制数和 10 位二进制数相当，所以 $2^{20}\approx10^6$；</p>
</li>
<li><p>segmentation fault 的产生：64-bits pointer 让程序认为真的有 $2^{64}$ bit 的内存空间，但实际上并不是。所以当程序访问到操作系统未给它分配的内存时，会抛出 segmentation fault；</p>
</li>
<li><p><strong>字长究竟是多大</strong>：不确定。一般是由一种语言中指针表示的范围、存储器上最大存储块大小决定。例如 64 位机器就是擅长 64-bits 计算、指针大小 64-bits 的机器；<strong>因此一个程序的位数是由硬件和编译器共同决定的</strong>；</p>
<blockquote>
<p>所以 64 位机器可以运行 32 位程序（向后兼容）；</p>
<p>为了内存对齐，32-bits 下字长相当于 4 bytes，64-bits 下字长相当于 8 bytes；</p>
</blockquote>
</li>
<li><p>Byte Ordering</p>
<ul>
<li><p>Big Endian（大端序）：<strong>现在常出现的地方就是 Internet，即当发送 32-bits 数据包时</strong></p>
<ul>
<li>Least significant byte has highest address（前面的 bits 排在地址靠前的位置，符合人类习惯）；</li>
</ul>
</li>
<li><p>Little Endian（小端序）：<strong>目前支持主流操作系统的处理器都能用小端序</strong></p>
<ul>
<li>Least significant byte has lowest address（前面的 bits 排在地址靠后的位置）</li>
</ul>
</li>
<li><p>Representing of integers</p>
<ul>
<li><p>Example of <code>01234567</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address: 0x100 0x101 0x102 0x103</span><br><span class="line">big       :  01	23	  45	67</span><br><span class="line">little :  67    45	  23	01</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Representing of pointers</p>
</li>
<li><p>Representing of strings: Every machine is <strong>the same</strong>; (ended by ‘\\0’);</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-6-Puzzles"><a href="#1-6-Puzzles" class="headerlink" title="1.6 Puzzles"></a>1.6 Puzzles</h3><p>Initialization:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">foo</span>();</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">bar</span>();</span><br><span class="line"><span class="type">unsigned</span> ux = x;</span><br><span class="line"><span class="type">unsigned</span> uy = y;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>$x\lt0\Rightarrow(x*2\lt0)$ ? </p>
<blockquote>
<p>False, $x=TMin$ (negative overflow) ?</p>
</blockquote>
</li>
<li><p>$ux\ge0$ ?</p>
<blockquote>
<p>True;</p>
</blockquote>
</li>
<li><p>$x\space\And\space7==7\Rightarrow(x&lt;&lt;30)\lt0$ ?</p>
<blockquote>
<p>True, $(x&lt;&lt;30)==-2^{31}+2^{30}\lt0$;</p>
</blockquote>
</li>
<li><p>$ux\gt-1$ ?</p>
<blockquote>
<p>Always False, implicit casting：$(unsigned)(-1)=(\sum\limits_{k=0}^{31}2^k)_{10}\Longrightarrow\forall x((unsigned)x\le(unsigned)(-1))$;</p>
</blockquote>
</li>
<li><p>$x\gt y\Rightarrow-x\lt-y$ ?</p>
<blockquote>
<p>False, $y==TMin\Rightarrow-y==TMin$.</p>
<p>So: $\forall x(y==TMin\rightarrow -x\ge-y)$</p>
</blockquote>
</li>
<li><p>$x*x\ge0$ ?</p>
<blockquote>
<p>False. Positive overflow.</p>
</blockquote>
</li>
<li><p>$x\gt0\space\And\And\space y\gt0\Rightarrow x+y\gt0$ ?</p>
<blockquote>
<p>False. Positive overflow.</p>
</blockquote>
</li>
<li><p>$x\ge0\Rightarrow-x\le0$ ?</p>
<blockquote>
<p>True.</p>
</blockquote>
</li>
<li><p>$x\le0\Rightarrow-x\ge0$ ?</p>
<blockquote>
<p>False, $x==TMin\Rightarrow-x==TMin$.</p>
</blockquote>
</li>
<li><p>$(x|-x)&gt;&gt;31==-1$ ?</p>
<blockquote>
<p>False. $x==0$ ?</p>
</blockquote>
</li>
</ul>
<h2 id="Chapter-2-Floating-Point"><a href="#Chapter-2-Floating-Point" class="headerlink" title="Chapter 2. Floating Point"></a>Chapter 2. Floating Point</h2><h3 id="2-1-Fractional-Binary-Numbers"><a href="#2-1-Fractional-Binary-Numbers" class="headerlink" title="2.1 Fractional Binary Numbers"></a>2.1 Fractional Binary Numbers</h3><ul>
<li><p>Limitations: Can only exactly represent numbers of the form $x/2^k$; Other rational number have repeating bit representations.</p>
</li>
<li><p>IEEE Floating Point</p>
<ul>
<li><p>Numerical form: $(-1)^s\cdot M\cdot2^E$;</p>
<blockquote>
<ul>
<li>Sign bit $s$ determines whether number is positive or negative;</li>
<li>Significand（尾数，Mantissa） M normally a fractional value in $[1.0,2.0)$;</li>
<li>Exponent E weights value by power of 2;</li>
</ul>
</blockquote>
</li>
<li><p>Single precision: 32-bits</p>
<p>$s$: 1-bit; $exp$: 8-bits; $frac$: 23-bits;（$s$、$exp$、$frac$ 代表对应的数据域而已，下略）</p>
</li>
<li><p>Double precision: 64-bits</p>
<p>$s$: 1-bit; $exp$: 11-bits; $frac$: 52-bits;</p>
</li>
<li><p><strong>Normalized values</strong>:</p>
<ul>
<li><p>$exp$ 不全为 0，也不全为 1；</p>
</li>
<li><p>$exp$ coded as a biased value: $E=Exp-Bias$;</p>
<p>$Exp$: <strong>unsigned</strong> value of exp field.</p>
<p>$Bias=2^{k-1}-1$, where <strong>$k$ is number of exponent bits</strong>（当前 $exp$ 字段的 bit 长度，非常巧妙）</p>
<blockquote>
<p>为什么这么设定 Bias？</p>
<p>Single precision’s bias: 127（Exp: 1…254, E: -126…127）</p>
<p>Double precision’s bias: 1023（Exp: 1…2046, E: -1022…1023）</p>
</blockquote>
<p><strong>考虑为什么 $E$ 要这么表达？因为这么做比较起来非常方便</strong>（$Exp$ 0000… 最小，1111…最大）；</p>
</li>
<li><p>Significand $M$ coded with implied leading 1: $M = (1.xxxx…x)_2$</p>
<p>$xxxx…x$: bits of $frac$ field（0000…0最小，此时 M = 1；1111…1最大，此时 $M=2-\varepsilon$）</p>
<blockquote>
<p><strong>由于前导 1，normalized value 只能表示绝对值 $[2^{1-Bias},(2-2^{-bitsOfFrac})\cdot2^{Bias})$ 范围的 floating point</strong>；</p>
</blockquote>
</li>
<li><p>理解：像科学计数法，$2^E$ 相当于十进制中的 $10^E$，用于移位，前面的 $M$ 规定具体数值；</p>
</li>
</ul>
</li>
<li><p><strong>Denormalized values</strong>:</p>
<ul>
<li><p>$exp$ 全为 0；</p>
</li>
<li><p>$exp$ coded as: $E=1-Bias$;（<strong>可以理解为此时 $exp$ 字段全 0 本身没意义，它们的个数来表示 $Bias$ 进而表示 $E$</strong>）</p>
</li>
<li><p>Significand $M$ coded with implied leading 0: $M=(0.xxx…x)_2$;</p>
<p>$xxx…x$: bits of $frac$ field;</p>
<blockquote>
<p>注意，这里会发现可以表示 “+0” 和 “-0”；</p>
<p><strong>denormalized value 只能表示绝对值 $[0,2^{1-Bias})$ 范围的 floating point</strong>；</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>Special values</strong>:</p>
<ul>
<li>$exp$ 全为 1；</li>
<li>这种编码<strong>只有两种情况</strong>：<ol>
<li>$frac$ 域全为 0：代表 $\infty$;</li>
<li>$frac$ 域不全为 0：代表 $NaN$（not a number），例如 $\sqrt{-1}$、$\infty-\infty$、$\infty\times0$ 等；</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>这样规定就会发现，浮点数<strong>恰好可以溢出到 $\pm\infty$</strong>，而且错误数恰为 $NaN$；</p>
<p>Visualization： <img src="imgs/float_visualization.png"></p>
<p>想要理解上面规定的原因还可以用少量的数位来模拟，<strong>你会发现之前的设定非常巧妙</strong>：</p>
<p>（这里以 $s$: 1-bit，$exp$: 4-bits，$frac$: 3-bits 为例）</p>
<p><img src="imgs/float_range.png" height="350"></p>
</blockquote>
</li>
<li><p>Special Properties of IEEE Encoding</p>
<ul>
<li>FP（Floating Point）zero same as Integer zero（<strong>All bits = 0</strong>）；</li>
<li>Can <strong>almost（except NaN）</strong> use <strong>unsigned integer comparison</strong>；<ul>
<li>Must first compare sign bits；</li>
<li>Must consider <strong>-0 = +0</strong>；</li>
<li>What should comparison with NaN yield？</li>
<li><strong>Otherwise OK ($+\infty$ 和 $-\infty$ 都能与数比较)</strong>；</li>
</ul>
</li>
</ul>
</li>
<li><p>Exercise: <strong>write float pointing in bit-level representation</strong>;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> F = <span class="number">15213.0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>$15213_{10}=11101101101101_2=1.1101101101101_2\times2^{13}$</li>
<li>$M=1.1101101101101_2$, $frac=11011011011010000000000_2$</li>
<li>$E=13$, $Bias=127$, $Exp=E+Bias=140_{10}=10001100_2$;</li>
<li>$Normalized\space value=01000110011011011011010000000000$</li>
</ul>
</li>
</ul>
<h3 id="2-2-The-Operations-for-Floating-Point"><a href="#2-2-The-Operations-for-Floating-Point" class="headerlink" title="2.2 The Operations for Floating Point"></a>2.2 The Operations for Floating Point</h3><ul>
<li><p>Basic idea</p>
<ol>
<li>First compute exact result;</li>
<li>Make it fit into desired precision<ul>
<li>possibly overflow if exponent too large;</li>
<li>possibly <strong>round</strong> to fit into $frac$;</li>
</ul>
</li>
</ol>
</li>
<li><p>Rounding for base 10 numbers</p>
<ul>
<li><p>Towards zero（向 0 舍入）；</p>
</li>
<li><p>Round down（向下舍入）；</p>
</li>
<li><p>Round up（向上舍入）；</p>
</li>
<li><p>Nearest Even（default）</p>
<blockquote>
<p>即 <strong>四舍六入五成双</strong>，见概率统计；</p>
<p>超过一半都是 “六” 的情况，少于一半都是 “四” 的情况，正好一半看最后保留位的奇偶；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Rounding Binary number: Nearest Even 与 普通十进制数思路相同；</p>
<blockquote>
<p>举例：Round to nearest 1/4（2 bits right of binary point）：</p>
<p>$10.00011_2\Rightarrow 10.00_2$，$10.00110_2\Rightarrow10.01_2$，</p>
<p>$10.11100_2\Rightarrow11.00_2$，$10.10100_2\Rightarrow10.10_2$；</p>
</blockquote>
</li>
<li><p>FP Multiplication: $multi=(-1)^s\cdot M\cdot2^E=(-1)^{s1}\cdot M_1\cdot 2^{E1}\cdot(-1)^{s2}\cdot M_2\cdot2^{E2}$</p>
<ul>
<li>Sign $s=s_1\space^\wedge\space s_2$;</li>
<li>Significand $M=M_1\times M_2$;</li>
<li>Exponent $E=E_1+E_2$;</li>
<li><strong>Fixing</strong><ol>
<li>If $M\ge2$，shift $M$ right, increment $E$; (<strong>That’s why  $M\lt 2$</strong>) </li>
<li>If $E$ out of range ($Exp$ out of range), overflow;</li>
<li>Round $M$ to fit $frac$ precision;</li>
</ol>
</li>
</ul>
</li>
<li><p>FP Addition: $sum=(-1)^s\cdot M\cdot2^E=(-1)^{s_1}\cdot M_1\cdot2^{E_1}+(-1)^{s_2}\cdot M_2\cdot2^{E_2}$. (assume $E_1\gt E_2$)</p>
<ul>
<li>Sign $s$, Significand $M$: <strong>Result of signed align &amp; add</strong>;</li>
<li>Exponent $E$: <strong>the same as $E_1$, which means $E_2$ will be ignored if $E_1\gt\gt E_2$</strong>;</li>
<li><strong>Fixing</strong><ol>
<li>If $M\ge2$, shift $M$ right, increment $E$;</li>
<li>If $M\lt1$, shift $M$ left $k$ positions, decrement $E$ by $k$; (<strong>The difference between multiplication</strong>)</li>
<li>If $E$ out of range, overflow;</li>
<li>Round $M$ to fit $frac$ precision;</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>Mathematical Properties of FP addition / multiplication</strong>:</p>
<ul>
<li>具备交换律 (commutative)，不具备结合性 (associative)：舍入的不准确性和溢出、大数和小数之和会丢失小数、大数和大数乘积会变为 $\infty$；</li>
<li>Every element has additive inverse (相反数) <strong>except for infinites \&amp; NaNs</strong>；</li>
<li>几乎具备单调性 (Monotonicity): $a\ge b\Rightarrow a+x\ge b+c$ <strong>except for infinites \&amp; NaNs</strong>;</li>
</ul>
<blockquote>
<p><strong>总而言之，在考试时，忘记这些问题不大，想要快速判断是否满足某个定律，只需找特殊：$\infty$、$NaN$、overflow、0，这四者是大多数特例的来源</strong>；</p>
</blockquote>
</li>
</ul>
<h3 id="2-3-Floating-Point-in-C"><a href="#2-3-Floating-Point-in-C" class="headerlink" title="2.3 Floating Point in C"></a>2.3 Floating Point in C</h3><ul>
<li><p><code>float</code>（single precision），<code>double</code>（double precision）；</p>
</li>
<li><p>Conversions / Casting:</p>
<ul>
<li><p><strong><code>int</code>、<code>double</code>、<code>float</code> 间的转换会改变 bit representation</strong>；</p>
<blockquote>
<p>回忆 signed 和 unsigned 间的转换，不改变 bit pattern，只是改变某些位置的解释方式；</p>
</blockquote>
</li>
<li><p>implicit casting 发生在占用小空间的类型（int）向占用大空间类型（double）转换，也可显式声明；</p>
<ul>
<li><code>int -&gt; double</code>: <strong>准确转换。因为 <code>int</code> 大小小于 53-bits</strong>；</li>
<li><code>int -&gt; float</code>: <strong>Will rounding according to rounding mode</strong>；</li>
</ul>
</li>
<li><p>显式类型转换 <code>double/float -&gt; int</code></p>
<ul>
<li>Truncates (截断) fractional part;</li>
<li>Like rounding toward 0 (<strong>可以看作向 0 舍入</strong>);</li>
<li>Not defined when out of range / NaN: <strong>Generally sets to <code>TMin</code></strong>;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-Puzzles"><a href="#2-4-Puzzles" class="headerlink" title="2.4 Puzzles"></a>2.4 Puzzles</h3><p>initialization:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = ...;</span><br><span class="line"><span class="type">float</span> f = ...;</span><br><span class="line"><span class="type">double</span> d = ...;</span><br><span class="line"><span class="comment">// Assume neither d nor f is NaN;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>$x==(int)(float)x$ ?</p>
<blockquote>
<p>False; (int)x -&gt; (float)x (rounded)</p>
</blockquote>
</li>
<li><p>$x==(int)(double)x$ ?</p>
<blockquote>
<p>True;</p>
</blockquote>
</li>
<li><p>$f==(float)(double)f$ ?</p>
<blockquote>
<p>True;</p>
</blockquote>
</li>
<li><p>$d==(double)(float)d$ ?</p>
<blockquote>
<p>False; (double)d -&gt; (float)d (rounded)</p>
</blockquote>
</li>
<li><p>$f==-(-f)$ ?</p>
<blockquote>
<p><strong>True. Even $f==\pm\infty$ is true.</strong></p>
</blockquote>
</li>
<li><p>$2/3==2/3.0$ ?</p>
<blockquote>
<p>False; $(int)2/3=0$, $(double)2/3.0=0.666…67$;</p>
</blockquote>
</li>
<li><p>$d\lt0.0\Rightarrow(d*2\lt0.0)$ ?</p>
<blockquote>
<p><strong>True; Even $d*2==-\infty$ is true.</strong></p>
</blockquote>
</li>
<li><p>$d\gt f\Rightarrow-f\gt-d$ ?</p>
<blockquote>
<p>False; $d==+\infty$ or $f==-\infty$ ?</p>
</blockquote>
</li>
<li><p>$d*d\ge0.0$ ?</p>
<blockquote>
<p><strong>True. Even $d==\pm\infty\Rightarrow d*d==+\infty$ is true.</strong></p>
</blockquote>
</li>
<li><p>$(d+f)-d==f$ ?</p>
<blockquote>
<p>False; $d&gt;&gt;f\Rightarrow(d+f)\approx d$;</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>C1 &amp; C2 结束，请完成 Data Lab！</p>
</blockquote>
<h2 id="Chapter-3-Machine-Level-Programming-Ⅰ-Basics"><a href="#Chapter-3-Machine-Level-Programming-Ⅰ-Basics" class="headerlink" title="Chapter 3. Machine-Level Programming Ⅰ- Basics"></a>Chapter 3. Machine-Level Programming Ⅰ- Basics</h2><blockquote>
<p>和前面说的一样，本章不会教学一段段写汇编，只要求看懂 GCC 输出的汇编代码即完成任务；</p>
<p><strong>本章涉及的机器语言运行在 Intel x86-64 机器上</strong>；</p>
</blockquote>
<ul>
<li><p>两种机器代码</p>
<ul>
<li>计算机实际运行的目标代码（一串字节编码处理器执行的指令，难以阅读）；</li>
<li>汇编代码：过去用于直接对机器进行编程，现在是编译器输出的目标。</li>
</ul>
<blockquote>
<p>以后说 “机器代码”，有时指第一种（目标代码），有时指第二种（文本格式的汇编代码），它们两者概念几乎相同，可替换。不过为了防止混淆以后对第二种会说 “汇编代码”。</p>
</blockquote>
</li>
</ul>
<h3 id="3-1-History-of-Intel-processors-and-architectures"><a href="#3-1-History-of-Intel-processors-and-architectures" class="headerlink" title="3.1 History of Intel processors and architectures"></a>3.1 History of Intel processors and architectures</h3><ul>
<li><p>什么是 Intel 的 x86-64？</p>
<blockquote>
<p>x86 是指 Intel 自己的 x86 processors，因为 Intel 这个系列的第一张处理器芯片的代号是 8086（产于 1978）。</p>
<p>随着时间推移，这个系列的芯片不断添加特性、升级演进；Intel 自己跳过了 81 系列，推出过 8286、8386系列等，都是以 86 结尾，所以被称为 x86。</p>
<p>后面的 64 表示这是 64-bits 的机器；</p>
</blockquote>
</li>
<li><p>什么是 <code>CISC</code> 和 <code>RISC</code>？</p>
<ul>
<li>Reduced Instruction Set Computer（<code>RISC</code>，精简指令集计算机）：一类装备改良的机器指令集的计算机，思想较新；</li>
<li>Complex Instruction Set Computer（<code>CISC</code>，复杂指令集计算机）：在 <code>RISC</code> 出现后，<code>RISC</code> 开发者把之前的使用旧指令集的计算机统称为 <code>CISC</code>，所以这个概念出现在本体之后，带有贬义；</li>
</ul>
<blockquote>
<p>Intel 采用的是 <code>CISC</code>，CSAPP 中介绍的这方面的知识还是不全面，想要进一步了解 <code>CISC</code> 需要自己阅读 <code>CISC</code> 手册；</p>
</blockquote>
</li>
<li><p>Intel 芯片的进化</p>
<ul>
<li><p>8086: 1978, 5-10 MHz;</p>
<blockquote>
<p>First 16-bit Intel processor.</p>
<p>1 MB Address space.</p>
</blockquote>
</li>
<li><p>386: 1985, 16-33 MHz</p>
<blockquote>
<p>First 32-bit Intel processor, referred to as IA32（Intel Architecture 32），占据了极大市场份额；<strong>现在不教它了，因为有更新的 x86-64</strong>;</p>
<p>Added “flat addressing”，capable of running <strong>UNIX</strong>；</p>
</blockquote>
</li>
<li><p>Pentium 4E（奔腾 4E）: 2004, 2800-3800 MHz</p>
<blockquote>
<p>First 64-bit Intel x86 processor, referred to as x86-64;</p>
<p><strong>收到了产品反馈：性能功耗问题，发热严重，不能无限制增加处理器时钟频率</strong>，开始着手多核处理器（一个芯片上放多个独立处理器）；</p>
</blockquote>
</li>
<li><p>Core 2: 2006, 1060-3500 MHz</p>
<blockquote>
<p>First multi-core Intel processor;</p>
</blockquote>
</li>
<li><p>Core i7: 2008, 1700-3900 MHz</p>
<blockquote>
<p>Four cores processor;（至今性能也不错）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>什么是缓存？<strong>大致定义是 a temporary memory used to hold the most recently accessed data</strong>;</p>
</li>
<li><p>2015 年的 Intel 芯片架构</p>
<p><img src="imgs/chip_in_2015.png" height="400"></p>
<ul>
<li><code>DDR</code> 接口是连接到主存储器（DRAM，Dynamic Random Access Memory）的通道；</li>
<li><code>PCI</code> 接口是与外围设备（peripheral devices）的连接通道；</li>
<li><code>SATA</code> 接口是与不同类型硬盘的连接通道；</li>
<li><code>Ethernet</code> 接口是网络接口；</li>
</ul>
<blockquote>
<p>结论：集成到单个芯片上的不仅仅是处理器本身，还有很多逻辑单元所组合起的有机整体；</p>
</blockquote>
</li>
<li><p>Intel 的竞争对手：AMD（Advanced Micro Devices）</p>
<ul>
<li>总是跟在 Intel 后面发展，同级别的芯片稍微有点慢，但便宜的多；</li>
</ul>
</li>
<li>什么是 ARM？<ul>
<li>除了 Intel 公司的 x86 类型的处理器，当前常用的、比较主流的另一类处理器是 ARM（Acron RISC Machine），CSAPP 不会深入涉及；</li>
<li>创造这种处理器及其对应指令集（RISC）的原公司已经破产，但指令集写的很棒，能自定义，功耗比同水准的 x86 处理器更低。</li>
<li>所以后继者建立了一个公司，但这个公司不销售处理器，只向众多公司销售 ARM 的设计许可权。因此，ARM 处理器是很多芯片厂商（尤其 Intel）生产的芯片的<strong>一部分</strong>，因为 ARM 的优势而被用在方方面面；</li>
</ul>
</li>
</ul>
<h3 id="3-2-C-Assembly-Machine-code"><a href="#3-2-C-Assembly-Machine-code" class="headerlink" title="3.2 C, Assembly, Machine code"></a>3.2 C, Assembly, Machine code</h3><blockquote>
<p>本节只是概述一下整个 C、汇编语言、机器语言的<strong>产生过程</strong> 和 <strong>宏观样貌</strong>。</p>
<p>具体对汇编代码的学习内容在下一节。</p>
</blockquote>
<h4 id="3-2-1-Definitions"><a href="#3-2-1-Definitions" class="headerlink" title="3.2.1 Definitions"></a>3.2.1 Definitions</h4><ul>
<li><strong>Architecture (also ISA: Instruction Set Architecture)</strong>: The <strong>parts</strong> of a processor design that  one needs to understand or write assembly/machine code.<ul>
<li>架构是处理器设计的一部分。开发硬件的人员在考虑设计机器和对应机器语言的时候，想到了将 “指令集架构” 这层抽象出来。<strong>例如针对某个寄存器，特定的指令集等</strong>，相当于驱动硬件的接口，将<strong>微架构</strong>和机器码隔离开。这样，硬件设计者只需要关心微架构，上层的设计者需要关注机器语言以及更抽象的语言就行。</li>
<li>开发人员需要了解，以此来编写对应的汇编码、机器语言，以至对应平台的编译器；</li>
<li>examples:<ul>
<li>Intel: x86, IA32, Itanium, x86-64;</li>
<li>ARM: (Name is itself) Used in almost all mobile phones.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Microarchitecture: Implementation of the architecture.</strong><ul>
<li>例如：缓存大小设计、内核频率设计。CSAPP 中也涉及的很少；</li>
</ul>
</li>
<li>Code Form<ul>
<li>Machine Code: The byte-level programs that a processor executes;</li>
<li>Assembly Code: A text representation of machine code.</li>
</ul>
</li>
</ul>
<h4 id="3-2-2-Assembly-Machine-Code-View"><a href="#3-2-2-Assembly-Machine-Code-View" class="headerlink" title="3.2.2 Assembly/Machine Code View"></a>3.2.2 Assembly/Machine Code View</h4><ul>
<li><p>Programmer-Visible State（在机器语言中需要开发者了解、操作的一些量，含有与真实硬件相关的细节）：</p>
<ul>
<li><p>PC (Program Counter, 程序计数器)</p>
<ol>
<li>Get the address of next instruction;</li>
<li>Called “RIP” (in x86-64);</li>
</ol>
</li>
<li><p>Register file: <strong>Heavily used program data</strong>（汇编程序中绝大多数数据存放的位置）;</p>
</li>
<li><p>Condition Codes（状态代码，存放于<strong>状态寄存器</strong>）</p>
<ol>
<li>存储绝大多数当前最近的算数/逻辑运算的状态信息；</li>
<li>数据用来判断状态分支；</li>
</ol>
</li>
<li><p>Memory</p>
<ol>
<li>由地址组织的 byte 数组，<strong>实际上是用一种不同方式（这个实现的方式以后的章节会详细介绍）实现的虚构对象，完成操作系统和硬件间的协作，因此称为虚拟内存（Virtual Memory）</strong>，所以这使得虽然内存（硬件上实际的内存又称为<strong>物理内存，Physical Memory</strong>）在硬件上可能是零碎的，但汇编开发者看起来的却是一大块可以按地址成块使用的。每个程序都有自己独立的字节数组来访问数据。</li>
<li>存放代码、用户信息；</li>
<li>使用堆栈数据结构来支持步骤；</li>
</ol>
<blockquote>
<p>这里解释一下经常提到的<strong>缓存（Cache）</strong>，缓存是指一个动作，就是将最近访问的数据存储到<strong>高速缓存器</strong>（I/O 远快于普通寄存器和外存储器，但造价高，所以容量小）中。下一次访问<strong>相同</strong>数据时，会直接进入高速缓存器中，速度会更快。</p>
<p>但是<strong>“缓存”</strong>这个动作对汇编开发者而言<strong>也是不可见（invisible）的</strong>，这是写在硬件中的动作（前面说的 microarchitecture），即使在汇编层面也没有专门的指令，无法操作。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>C 代码如何转变为 <code>Object Code</code></p>
<ul>
<li>在 GNU Tutor 中曾经介绍过从源文件到目标文件的过程；</li>
<li><strong>C 源文件（*.c, text）</strong> <u>编译器（compiler, C 一般用 gcc）</u>编译为 <strong>ASM 源文件（*.s, text）</strong>，再交给<u>汇编器（assembler，一般用 gcc/as）</u> 汇编为 <strong>目标文件（*.o, binary）</strong>，最后交给<u>链接器（linker，一般用 gcc/ld）</u> 链接用到的第三方静态库，最终变为可执行文件；</li>
<li>剩余还有一部分是动态链接库，要么自己写并且编译，放置在指定位置，要么用的是系统环境中的库，在程序运行时动态加载。</li>
</ul>
</li>
<li><p>举例说明：下面以一个简单的 C 程序为例，演示其汇编代码及含义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: sum.c</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">plus</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sumstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span>* dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = plus(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">long</span> y = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">long</span> z;</span><br><span class="line">    sumstore(x, y, &amp;z);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld + %ld --&gt; %ld\n&quot;</span>, x, y, z);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在运行 <code>gcc -Og -S sum.c</code>。</p>
<ul>
<li><code>-Og</code> 参数是较新的参数，与 <code>-On</code>（n=0，1，2，3） 优化不一样，为开发人员提供了易读的中间汇编码；另外，如果不加 <code>-O</code> 参数，就什么都不优化，那么代码同样难以阅读；</li>
<li><code>-S</code> 参数意味着 <code>gcc</code> 套件将仅运行到产生汇编代码（<code>*.s</code>）就停止；</li>
</ul>
<p>找到代表 <code>sumstore</code> 函数的 asm 代码，以函数名 + 冒号开头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sumstore:</span><br><span class="line">    pushq	%rbx</span><br><span class="line">    .seh_pushreg	%rbx</span><br><span class="line">    subq	$32, %rsp</span><br><span class="line">    .seh_stackalloc	32</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    movq	%r8, %rbx</span><br><span class="line">    call	plus</span><br><span class="line">    movl	%eax, (%rbx)</span><br><span class="line">    addq	$32, %rsp</span><br><span class="line">    popq	%rbx</span><br><span class="line">    ret</span><br><span class="line">    .seh_endproc</span><br><span class="line">    .def	__main;	.scl	2;	.type	32;	.endef</span><br><span class="line">    .section .rdata,&quot;dr&quot;</span><br></pre></td></tr></table></figure>
<p>这里注意开头含有 <code>.</code> 的操作<strong>实际不是原先代码的部分，它们与一些其他信息有关</strong>。例如为调试器提供行号的、为链接器提供信息表示全局函数的等等。一开始可以不用太过于在意这些，为了演示方便，这里直接删掉说明，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sumstore:</span><br><span class="line">    pushq	%rbx	; %rbx 表示访问名为 rbx 的寄存器，pushd 表示数据压入memory栈</span><br><span class="line">    subq	$32, %rsp	</span><br><span class="line">    movq	%r8, %rbx</span><br><span class="line">    call	plus	; 调用函数名为 plus 的函数</span><br><span class="line">    movl	%eax, (%rbx)	; 移动值</span><br><span class="line">    addq	$32, %rsp</span><br><span class="line">    popq	%rbx	; 将栈中值弹出到 名为 rbx 的寄存器中</span><br><span class="line">    ret				; 当前函数结束，返回</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2-3-Assembly-Characteristics-Data-Types"><a href="#3-2-3-Assembly-Characteristics-Data-Types" class="headerlink" title="3.2.3 Assembly Characteristics: Data Types"></a>3.2.3 Assembly Characteristics: Data Types</h4><ul>
<li>“Integer” data of 1,2,4, or 8 bytes（不同的整型数据类型，不区分符号）<ul>
<li>Data types / Address（untyped pointers）</li>
</ul>
</li>
<li>Floating point data of 4,8, or 10 bytes（浮点数处理方式不同，使用不同的寄存器组，之后详细提）</li>
<li><strong>在汇编层面不存在聚合结构（aggregate types）</strong>，例如数组、结构体，因为它们是在编译器层面人工设计的，本质上就是连续的一段内存，以后也会实现；</li>
</ul>
<h4 id="3-2-4-Assembly-Characteristics-Operations"><a href="#3-2-4-Assembly-Characteristics-Operations" class="headerlink" title="3.2.4 Assembly Characteristics: Operations"></a>3.2.4 Assembly Characteristics: Operations</h4><ul>
<li>Perform arithmetic function on register or memory data（<strong>算术运算</strong>在存储器上的数据）</li>
<li>Transfer data between memory and register（在内存和寄存器间<strong>转移数据</strong>）<ul>
<li>load data from memory to register</li>
<li>store register data into memory</li>
</ul>
</li>
<li>Transfer control（汇编代码<strong>流程控制</strong>）<ul>
<li>Unconditional jumps to/from procedures</li>
<li>Conditional branches</li>
</ul>
</li>
</ul>
<h4 id="3-2-5-Assembling-amp-Disassembling-Object-Code-At-first-glance"><a href="#3-2-5-Assembling-amp-Disassembling-Object-Code-At-first-glance" class="headerlink" title="3.2.5 Assembling &amp; Disassembling Object Code: At first glance"></a>3.2.5 Assembling &amp; Disassembling Object Code: At first glance</h4><p><strong>先来看 C code 到 汇编语言/机器语言的过程</strong>。</p>
<p>当汇编代码被 assembler（汇编器）汇编为目标代码时，这时所能看到的就只有二进制序列了。接下来还以之前的 <code>sum.c</code> 中的 <code>sumstore</code> 函数为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x0400595:    # 表示本函数段从 0x0400595 处开始</span><br><span class="line">    0x53	# 每一条指令长为 1/3/5 bytes，整段函数的长度为 14 bytes</span><br><span class="line">    0x48</span><br><span class="line">    0x89</span><br><span class="line">    0xd3</span><br><span class="line">    0xe8</span><br><span class="line">    0xf2</span><br><span class="line">    0xff</span><br><span class="line">    0xff</span><br><span class="line">    0xff</span><br><span class="line">    0x48</span><br><span class="line">    0x89</span><br><span class="line">    0x03</span><br><span class="line">    0x5b</span><br><span class="line">    0xc3</span><br></pre></td></tr></table></figure>
<p>这里每条指令只做一件事。以 <code>sumstore</code> 函数中的一个语句为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*dest = t;    <span class="comment">/* Store value t where designated by dest. */</span></span><br><span class="line">            <span class="comment">/* 这里加信号的含义是取 dest 所指向的地址 */</span></span><br></pre></td></tr></table></figure>
<p>对应这条汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq %rax, (%rbx)</span><br></pre></td></tr></table></figure>
<p>对应这条目标代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x40059e:    48 89 03</span><br></pre></td></tr></table></figure>
<p>这里 <code>t</code> 或某些 local variables 会存储于寄存器中（例如上面表示它在寄存器 <code>%rax</code> 中），而 <code>dest</code> 指针值自己也被存储于寄存器中（上面表示 <code>dest</code> 自身的值存于 <code>%rbx</code> 中）；</p>
<p>这里的 <code>(%rbx)</code> 表示 <code>Memory[%rbx]</code>，即 <code>%rbx</code> 值所代表的地址在 <code>Memory</code> 中的位置；</p>
<p><code>mov A, B</code> 指令就是将值从 A 处移动到 B 处。上面的汇编语句连起来就是：<strong>将存放于 <code>%rax</code> 中的值移动到 <code>%rbx</code> 所代表 Memory 地址的位置上</strong>；</p>
<p>根据汇编器翻译，这条指令只用了 3 bytes 来编码：<code>48 89 03</code>；</p>
<hr>
<p><strong>再来看机器语言到汇编语言的反汇编过程（disassembling）</strong>。</p>
<p>反汇编的实现和汇编一样，后者是将文本版本（汇编代码）转换为字节码（机器代码）的形式表示，前者将字节码对应解释成易读的文本即可。</p>
<p>如果当前没有源文件，甚至没有汇编代码，那么可以由<strong>反汇编器（disassembler）</strong>来将目标代码（*.o）<strong>或者</strong>可执行程序（已链接库的目标代码）转换成汇编代码（*.s）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d <span class="built_in">sum</span> &gt; sum.d <span class="comment"># 反编译之前的 sum 程序，-d 将可执行部分反汇编显示到 stdout</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，在汇编代码的层次下，<strong>无法</strong>再向上还原到源文件（*.c），因为其中的函数/变量名、都在汇编过程丢失了，只剩下一些寄存器的名称和 Memory 地址。</p>
<p>上面使用 <code>objdump</code> 可以得到真正意义上的汇编代码（从机器代码转换而来），此外还有一种方法：使用 <code>gdb</code>。</p>
<p>如果使用 <code>gdb</code> 打开目标可执行文件，运行 <code>disassemble &lt;funcName&gt;</code> 就可以对可执行文件中对应的函数区域进行反汇编。但只显示这些指令的地址 + 翻译指令，不显示字节级的编码。</p>
<h3 id="3-3-Assembly-Basics"><a href="#3-3-Assembly-Basics" class="headerlink" title="3.3 Assembly Basics"></a>3.3 Assembly Basics</h3><h4 id="3-3-1-The-names-for-integer-registers"><a href="#3-3-1-The-names-for-integer-registers" class="headerlink" title="3.3.1 The names for integer registers"></a>3.3.1 The names for integer registers</h4><p>下面列举 x86-64 architecture 的 <strong>整数型寄存器（Integer Register）</strong>。</p>
<p><img src="imgs/registers_in_x86_64.png" height="400px"></p>
<p>如图，这些寄存器共有 16 个，名字大致分为 2 类，一类是字母表示的（ax/bx/…），另一类是数字表示的（8/9/…）。</p>
<p>目前一个 x86-64 架构的 integer register 总大小有 64-bit。鉴于对以前 32-bit 机器和程序的向前兼容（backwards compatibility），汇编语言允许使用一个寄存器的<strong>不同部分</strong>，怎么用取决于指令。</p>
<p>对于字母类名称的寄存器（如上图左），如果使用<strong>前缀 <code>%r</code></strong>（例如 <code>%rax</code>），那么这个整型寄存器将保存 <strong>64-bit</strong> 大小的整型数据（即使用全部空间）；如果使用<strong>前缀 <code>%e</code></strong>（例如 <code>%eax</code>），那么这个整型寄存器将保存 <strong>32-bit</strong> 大小的整型数据（即从低位开始使用 32 bits，又称为 <strong>low-order 32-bit</strong>）。</p>
<p>对于数字类名称的寄存器（如上图右），前缀必须是 <code>%r</code>。如果不加后缀，表示保存 <strong>64-bit</strong> 大小的整型；如果使用<strong>后缀 <code>d</code></strong>，那么将保存 <strong>32-bit</strong> 大小的整型。</p>
<p>在这些寄存器中，可以使用指令存取数据，<strong>而且这些是机器级编程，和具体机器的型号密切相关，每步即必须清楚指出从哪个寄存器到哪个寄存器</strong>。</p>
<p>在 x86-64 架构下，最常见的是 64-bit register 的使用，其次是 low-order 8-bit 的使用（用在条件控制中，这个会在下一章介绍）。因此，除非提及，下面默认的 register 全部是以 <code>%r</code> 为前缀的 16 个寄存器。</p>
<hr>
<p>下面补充一些历史信息，帮助理解这些寄存器奇怪的（quirky）名字：</p>
<p>在早期 IA32 架构下 32-bit 处理器只用到了 8 个寄存器，它们的名字分别是：</p>
<p><code>%eax</code>、<code>%ecx</code>、<code>%edx</code>、<code>%ebx</code>、<code>%esi</code>、<code>%edi</code>、<code>%esp</code>、<code>%ebp</code>（都是 <code>%e</code> 前缀,意味着存 32-bit 整型）</p>
<p>此位，这些寄存器还能引用 <strong>low-order 16-bits</strong>（它们是最开始出现的 16-bit 寄存器，没有 <code>e/r</code> 前缀，引用的名称为 <code>%ax</code>、<code>%cx</code>、<code>%bx</code>……），甚至是 <strong>low-order 8-bits 和 high-order 8-bits</strong>（分别是 <code>%al</code> 和 <code>%ah</code> 等，如下图）。这里不讲述这些旧版本机器的低位寄存器位置的操作指令，不过在下一章会提到操作 <strong>low-order 8-bits</strong> 的操作指令，因为会涉及汇编条件控制。</p>
<p><img src="imgs/IA32_registers.png" height="350px"></p>
<p>很早以前，各个寄存器的名字有特定含义，代表它们的目的。例如 <code>a</code> 代表 accumulate，<code>c</code> 代表 counter，<code>d</code> 代表 data，<code>b</code> 代表 base，<code>si</code> 代表 source index，<code>di</code> 代表 destination index，<code>sp</code> 代表 stack pointer，<code>bp</code> 代表 base pointer。</p>
<p>现在这些寄存器就是普通的存取数据的结构，名字也就没有特定的含义了——<strong>除了名字是 <code>sp</code> 的寄存器</strong>。它在目前的 x86-64 架构中也有一个非常具体的目的，就是上面说的，stack pointer，<strong>栈指针</strong>。</p>
<p>至于后面数字表示的寄存器，<strong>是后来从 IA32 架构升级到 64 位（x86-64）时，芯片可以在一个时钟周期处理 64-bit 的数据了，旧的寄存器设计不够用了，所以新添加上去的，因为没有特定用途，就以数字进行命名</strong>。</p>
<p>⚠ 说是没什么“特殊用途”，但还是有约定俗成的使用方法的！</p>
<p>例如，这些寄存器分为 “<strong>Callee-Saved Register</strong>” 和 “<strong>Caller-Saved Register</strong>”。</p>
<p>其中，Callee-Saved Register 是<strong>被调用方管使用的</strong>寄存器，数据内容只会在被调方的函数内有效、有意义。属于这类的寄存器有：<code>%rbx</code>、<code>%r12-14</code>、<code>%rbp</code> 和 <code>%rsp</code>，后两者是有特殊含义的，前面的寄存器是供被调方存储临时数据（Temporaries）；</p>
<p>Caller-Saved Register 是<strong>调用方保管使用的</strong>寄存器，它的作用大多数是沟通调用方和被调方的数据信息。例如 <code>%rax</code> 一般存放返回值，<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rcx</code>、<code>%r8</code>、<code>%r9</code> 依此存放调用函数的第 1 ~ 第 6 参数；<code>%r10</code>、<code>%r11</code> 供存储调用方临时数据。</p>
<p>在下面的部分中，你会一遍遍加深对这个说法的印象的。上面的内容在第五章会进一步提及。</p>
<p>至于为什么要有 Callee-Saved 和 Caller-Saved Register，这也会在 5.4 中详细说明。</p>
<hr>
<h4 id="3-3-2-Move-Operands-and-usage"><a href="#3-3-2-Move-Operands-and-usage" class="headerlink" title="3.3.2 Move, Operands, and usage"></a>3.3.2 Move, Operands, and usage</h4><p>接下来介绍整型寄存器在汇编代码中的使用。</p>
<h5 id="Moving-Data-Command-movq-lt-SrcR-gt-lt-DstR-gt"><a href="#Moving-Data-Command-movq-lt-SrcR-gt-lt-DstR-gt" class="headerlink" title="Moving Data Command: movq &lt;SrcR&gt;, &lt;DstR&gt;"></a>Moving Data Command: <code>movq &lt;SrcR&gt;, &lt;DstR&gt;</code></h5><blockquote>
<p>为什么命令名中有 “q” ？因为在 Intel 公司设定中，q 代表 quad，是 4 个字，而在 8086 系列中，1 个字被约定为 16 bits（2 bytes），所以 <strong><code>movq</code> 指令操作的必须是 64 bits 的寄存器</strong>；</p>
<p>⚠ <strong>另外请格外注意，Intel 和 Microsoft 使用的 x86-64 架构的汇编语言的这些参数和 Linux 使用的 x86-64 架构的参数顺序不一样！CSAPP 教授的指令语法按照 Linux 来，请不要弄错！不要在 Windows 环境下尝试这些指令！</strong></p>
</blockquote>
<h5 id="Operands"><a href="#Operands" class="headerlink" title="Operands"></a>Operands</h5><ul>
<li><p>Immediate（数据直接量，例如常量整型）: <strong>定义和 C 语言一样，但是需要加上前缀 <code>$</code></strong>;</p>
<blockquote>
<p>例如：<code>$0x400</code>、<code>$-523</code> 等等；</p>
</blockquote>
</li>
<li><p>Register Name: 16 个中任意一个整型寄存器的名称。</p>
<blockquote>
<p><strong>注意：保留作其他用途的寄存器也不应该被手动使用。前面说了，例如在 x86-64 架构中，<code>%rsp</code> 保留做特殊用途</strong>，因为栈中保存其他重要的状态信息，只能由机器内部进行修改。</p>
</blockquote>
</li>
<li><p>Memory: <strong>8 consecutive bytes</strong> of memory <strong>at address</strong> given by registers.</p>
</li>
<li><p><strong>汇编代码简单访问 Memory 的方法</strong>：</p>
<ul>
<li><p>法 1: Normal <code>(%&lt;registerName&gt;)</code></p>
<p>即保存在寄存器中的、8 bytes 连续的地址数据对应的 memory 位置。</p>
<p><strong>也就是说，当把寄存器名称放在括号里时，就是表示把寄存器中数据看作 memory 地址（无论是什么），并用这个地址来引用对应的内存位置</strong>。</p>
<p>例如：<code>(%rax)</code> 就是代表取存放在 <code>%rax</code> 寄存器中的数据对应 memory 位置的引用；</p>
<p><u>请牢牢记住</u>，这种在括号内找地址的形式被称为 <strong>Simple Memory Addressing Modes</strong>（简单内存寻址模式），表示这个模式下，寄存器被看作指针，括号相当于取地址并找到 memory 对应的引用。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>法 2: Displacement <code>&lt;D&gt;(%&lt;registerName&gt;)</code></p>
<p>即保存在寄存器中的、8 bytes 连续的地址对应 memory 的某个位置，以这个位置为基准，向后偏移 <code>D</code> 个 bytes 所对应的内存位置的引用。<strong>因此，<code>D</code> 一般只取 1，2，4</strong>；</p>
<p>例如：<code>8(%rbp)</code> 就是代表取存放在 <code>%rbp</code> 寄存器中的数据向后偏移 <code>D</code> 个 bytes 的位置对应 memory 的引用；</p>
</li>
</ul>
<ul>
<li><p><strong>法 3: Most General Form <code>D(&lt;Rbase&gt;, &lt;Rindex&gt;, &lt;Scale&gt;)</code></strong></p>
<p>等价于 <code>Memory[Reg[Rb] + S * Reg[Ri] + D]</code>，指使用寄存器 <code>Rb</code> 中的数据为基，加上 <code>S</code> 倍率的寄存器 <code>Ri</code> 中的数据（<strong>因此 <code>S</code> 只取 1，2，4，8 这几个之一</strong>），最后总体偏移 <code>D</code> bytes；</p>
<p><strong>注意，<code>Ri</code> 不建议为寄存器 <code>%rsp</code></strong>;</p>
<p><strong>法 3 就是原始意义上的数组自然引用的方式</strong>；</p>
<p>可以思考为什么 <code>S</code> 只取 1、2、4、8 中的一个。原因很简单，这和它存在的意义有关。我们想在引用数组时，<strong>一定希望根据数据类型来缩放索引值</strong>，例如 <code>int</code> 需要缩放 4 倍（4 bytes），<code>long</code> 需要缩放 8 倍；小于这些数，则会导致数据错误，大于这些数据会导致空间浪费。</p>
</li>
</ul>
<ul>
<li><p>Rules：以上有些 operand 的组合是不允许的。例如：</p>
<ul>
<li>直接量作为 destination，没有意义；</li>
<li>为了方便硬件设计，不允许直接从一个内存位置复制到另一个内存位置，必须 2 步：从内存存入指定寄存器，再由指定寄存器存入另一块内存（<strong>内存到内存必须经过寄存器</strong>）；</li>
</ul>
</li>
<li><p>Examples：</p>
<ul>
<li><p>例如 <code>movq $0x4,%rax</code> 可能对应的就是 <code>tmp = 0x4;</code></p>
</li>
<li><p>例如 <code>movq $-147,(%rax)</code>可能对应 <code>*p = -147;</code></p>
</li>
<li><p>例如 <code>movq %raw,%rdx</code> 可能对应 <code>tmp2 = tmp1;</code></p>
</li>
<li><p>例如 <code>movq $rax,(%rdx)</code> 可能对应 <code>*p = tmp;</code></p>
</li>
<li><p>例如 <code>movq (%rax),%rdx</code> 可能对应 <code>tmp = *p;</code></p>
</li>
<li><p>例如假设下面这段程序可能的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t0 = *xp;</span><br><span class="line">    <span class="type">long</span> t1 = *yp;</span><br><span class="line">    *xp = t1;</span><br><span class="line">    *yp = t0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">swap:</span><br><span class="line">    movq	(%rdi), %rax</span><br><span class="line">    movq	(%rsi), %rdx</span><br><span class="line">    movq	%rdx, (%rdi)</span><br><span class="line">    movq	%rax, (%rsi)</span><br><span class="line">    ret						; 回到之前调用 swap 函数的位置，结束当前函数执行</span><br></pre></td></tr></table></figure>
<p><strong>在上面这个函数体中，<code>%rdi</code> 是保存第一个参数的寄存器，<code>%rsi</code> 是第二个参数寄存器，最多用 6 个</strong>，这是在执行此函数前就设置好的。剩下寄存器的选择是由编译器自己决定的，每次编译都可能不太一样；</p>
</li>
</ul>
</li>
<li><p>Exercises: Address Computation Examples（根据信息填写下表）</p>
<p>已知寄存器 <code>%rdx</code> 存放数据 0xf000，寄存器 <code>%rcx</code> 存放数据 0x0100。</p>
<table>
    <tr style="text-align: center;">
        <th>Expression</th>
        <th>Address Computation</th>
        <th>Address</th>
    </tr>
    <tr>
        <td>0x8(%rdx)</td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>(%rdx,%rcx)</td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>(%rdx,%rcx,4)</td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>0x80(,%rdx,2)</td>
        <td></td>
        <td></td>
    </tr>
</table>

<p>第一行，就是普通 displacement，<code>0xF000 + 0x8 = 0xF008</code>;</p>
<p>第二行，省略的 general displacement，<code>0xF000 + 0x0100 = 0xF100</code>;</p>
<p>第三行，省略的 general displacement，<code>0xF000 + 4 * 0x0100 = 0xF400</code>;</p>
<p>第四行，省略的 general displacement，<code>0 + 2 * 0xF000 + 0x80 = 0x1E080</code>;</p>
</li>
</ul>
<h4 id="3-3-3-Arithmetic-amp-logical-operations"><a href="#3-3-3-Arithmetic-amp-logical-operations" class="headerlink" title="3.3.3 Arithmetic &amp; logical operations"></a>3.3.3 Arithmetic &amp; logical operations</h4><h5 id="Address-Computation-Instruction-leaq-lt-Src-gt-lt-Dst-gt"><a href="#Address-Computation-Instruction-leaq-lt-Src-gt-lt-Dst-gt" class="headerlink" title="Address Computation Instruction: leaq &lt;Src&gt;, &lt;Dst&gt;"></a>Address Computation Instruction: <code>leaq &lt;Src&gt;, &lt;Dst&gt;</code></h5><blockquote>
<p>指令含义：load effective address（加载有效地址）；</p>
<p>指令目标（很抽象，等会慢慢解释）：<strong>相当于 C 的 <code>&amp;</code>（ampersand）符号来计算地址</strong>，基于想要计算的地址的一些内容（一般是指定内存引用）。<strong>同时也作为一种非常方便的算术运算方式</strong>。</p>
<p>指令的大致过程：通俗来说就是<strong>传入的内存引用 <code>Src</code>，<code>leaq</code> 会找到这个引用的地址值，并把这个地址传给 <code>Dst</code></strong>，最后 <code>Dst</code> 的值是 <code>Src</code> 引用的地址，相当于 <code>Dst</code> 变成了指针，指向了 <code>Src</code>；</p>
<p><code>Dst</code> 参数<strong>必须是寄存器名称</strong>，不能是直接量、内存引用；</p>
<p><code>Src</code> 参数<strong>必须是内存引用</strong>，<strong>允许使用之前的 Simple Memory Addressing Mode</strong>，不能是直接量、寄存器名称；</p>
</blockquote>
<p>下面举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">m12</span><span class="params">(<span class="type">long</span> x)</span> &#123; <span class="keyword">return</span> x * <span class="number">12</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数对应的汇编代码可以是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m21:</span><br><span class="line">    leaq (%rdi,%rdi,2), %rax</span><br><span class="line">    salq $2, $rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>首先解释 <code>(%rdi,%rdi,2)</code>，这是上面要求记住的 <strong>Simple Memory Addressing Mode</strong>，它代表，把 <code>%rdi</code>（即这里存放函数第一参数 <code>x</code> 的寄存器）中的内容看成地址，进行一个 general displacement：<code>%rdi 的值 + 2 * %rdi 的值</code>，这里<strong>巧妙地完成了找到 3 倍的 <code>%rdi</code> 的值，把它作为索引，其对应的 memory 地址引用</strong>（注：这个地址很可能<strong>不能</strong>被程序使用，这里只是借助它进行算术计算）；</p>
<p>然后 <code>leaq</code> 将第一参数（3 倍 <code>%rdi</code> 值索引所对应 memory 的引用位置）<strong>对应的地址</strong>赋给了 <code>%rax</code> 寄存器。<strong>到此为止，<code>%rax</code> 中成功获得了 <code>%rdi</code> 中的 3 倍值，中间的方法虽然用到了指针的概念，但本质不是指针操作，是算数操作</strong>（慢慢领悟吧）。</p>
<p>最后使用的 <code>salq</code> 指令很简单，就是底层的移位指令（在后面介绍），将 <code>%rax</code> 的二进制值向左移动 2 位，相当于 × 4，总的来说 <code>%rax</code> 的值就相当于原来 <code>%rdi</code> 的值 × 12，完成了 × 12 的操作。</p>
<blockquote>
<p>有同学可能会问，为什么不全都给 <code>leaq</code> 来计算 × 12 呢？其实移位在效率上会更快一些。一般 C/C++ 程序在乘常数操作时，会被编译器优化，分解出 $2^k$ 的因子，一部分用 <code>leaq</code> 计算，另一部分用 <code>salq</code> 移位。</p>
</blockquote>
<h5 id="Some-Arithmetic-Operations"><a href="#Some-Arithmetic-Operations" class="headerlink" title="Some Arithmetic Operations"></a>Some Arithmetic Operations</h5><ul>
<li><code>addq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst + Src</code></li>
<li><code>subq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst - Src</code></li>
<li><code>imulq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst * Src</code></li>
<li><code>salq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &lt;&lt; Src</code></li>
<li><code>sarq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &gt;&gt; Src</code>（<strong>算术右移，arithmetic right shift</strong>）</li>
<li><p><code>shrq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &gt;&gt; Src</code>（<strong>逻辑右移，logical right shift</strong>）</p>
</li>
<li><p><code>xorq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst ^ Src</code></p>
</li>
<li><code>andq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst &amp; Src</code></li>
<li><code>orq &lt;Src&gt;, &lt;Dst&gt;</code>：相当于 <code>Dst = Dst | Src</code></li>
</ul>
<p><strong>切记，别搞错 operands 的顺序！<code>Src</code> 在前，<code>Dst</code> 在后</strong>；</p>
<ul>
<li><code>incq &lt;Dst&gt;</code>：相当于 <code>Dst = Dst + 1</code></li>
<li><code>decq &lt;Dst&gt;</code>：相当于 <code>Dst = Dst - 1</code></li>
<li><code>negq &lt;Dst&gt;</code>：相当于 <code>Dst = -Dst</code></li>
<li><code>notq &lt;Dst&gt;</code>：相当于 <code>Dst = ~Dst</code>（注意是<strong>按位否</strong>）</li>
</ul>
<p>更多指令请参阅 x86-64 指令手册。</p>
<hr>
<p>下面是个 <strong>example</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">arith</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t1 = x + y;</span><br><span class="line">    <span class="type">long</span> t2 = z + t1;</span><br><span class="line">    <span class="type">long</span> t3 = x + <span class="number">4</span>;</span><br><span class="line">    <span class="type">long</span> t4 = y * <span class="number">48</span>;</span><br><span class="line">    <span class="type">long</span> t5 = t3 + t4;</span><br><span class="line">    <span class="type">long</span> rval = t2 * t5;</span><br><span class="line">    <span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arith:</span><br><span class="line">    leaq	(%rdi,%rsi), %rax</span><br><span class="line">    addq	%rdx, %rax</span><br><span class="line">    leaq	(%rsi,%rsi,2), %rdx</span><br><span class="line">    salq	$4, %rdx</span><br><span class="line">    leaq	4(%rdi,%rdx), %rcx</span><br><span class="line">    imulq	%rcx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>这里 <code>%rdi</code> 存放了函数第一参数 x，<code>%rsi</code> 存放了函数第二参数 <code>y</code>，<code>%rdx</code> 存放了函数第三参数 <code>z</code>；</p>
<p>第一步，可以理解为将 <code>%rdi</code> 和 <code>%rsi</code> 值看作地址，找到 <code>%rdi 值 + %rsi 值</code> 对应的 memory 引用，并利用 <code>leaq</code> 将引用代表的地址赋给 <code>%rax</code>，使得 <code>%rax</code> 获得了 <code>%rdi</code> 和 <code>%rsi</code> 值之和的值，<strong>之所以不用 <code>addq</code>，是因为 <code>addq</code>  会把结果加到 <code>Dst</code> 上，但这里显然不想修改任何寄存器中的值，只是想把值给到新的寄存器</strong>（此步对应 <code>long t1 = x + y;</code>，相当于这里 <code>%rax</code> 存的是 <code>t1</code>）；</p>
<p>第二步，把 <code>%rdx</code> 的值（x）加到 <code>%rax</code> 上，这时的 <code>%rax</code> 存的是 <code>t2</code>（<code>t1</code> 以后不会用了，所以编译器抛弃了，直接用 <code>addq</code> 操作 <code>%rax</code>，这么做可以提升效率，对应 <code>long t2 = z + t1;</code>）；</p>
<p>第三步、第四步，前面说了好几遍，这里说简单一点，就是把 <code>%rdx</code> （原先存 <code>z</code> 的寄存器，抛弃 <code>z</code> 也是因为之后不用 <code>z</code> 变量了，编译器进行了优化）赋以 3 倍的 <code>%rsi</code> 值，并且把 <code>%rdx</code> 的值乘以 $2^4=16$，总的来说，<code>%rdx</code> 被赋以 48 倍的 <code>%rsi</code>（y）的值，对应 <code>long t4 = y * 48;</code>，这时 <code>%rdx</code> 存放的就是 <code>t4</code> 了；</p>
<p>第五步，简单说就是 <code>%rcx</code> 被赋以 <code>%rdi 的值（x） + %rdx 的值（t4） + 4</code>，可以看到，这里编译器想尽一切办法，把 <code>long t3 = x + 4;</code> 和 <code>long t5 = t3 + t4;</code> 这步合起来了，整整省下来了一个 <code>t3</code> 的操作，可谓优化到极致。所以，<code>%rcx</code> 存的是 <code>t5</code>；</p>
<p>最后一步，编译器实在想不到更好的优化方法，只能勉为其难地调用了唯一一次 <code>imulq</code>，把 <code>%rcx</code> 的值（<code>t5</code>）乘到 <code>%rax</code> 上，对应 <code>long rval = t2 * t5;</code>，函数结束，最后存放 <code>rval</code> 的寄存器是 <code>%rax</code>。</p>
<hr>
<h2 id="Chapter-4-Machine-Level-Programming-Ⅱ-Control"><a href="#Chapter-4-Machine-Level-Programming-Ⅱ-Control" class="headerlink" title="Chapter 4. Machine Level Programming Ⅱ - Control"></a>Chapter 4. Machine Level Programming Ⅱ - Control</h2><h3 id="4-1-Introduction-to-Condition-Codes"><a href="#4-1-Introduction-to-Condition-Codes" class="headerlink" title="4.1 Introduction to Condition Codes"></a>4.1 Introduction to Condition Codes</h3><h4 id="4-1-1-Processor-State-of-x86-64-partial"><a href="#4-1-1-Processor-State-of-x86-64-partial" class="headerlink" title="4.1.1 Processor State of x86-64, partial"></a>4.1.1 Processor State of x86-64, partial</h4><p>前面介绍过，x86-64 架构具有 16 个寄存器，其中 8 个沿用旧 x86 架构的名称，另外 8 个从 8 ~ 15 命名。可以总结一下，从这些寄存器 / flags 可以看出处理器当前的状态：</p>
<ul>
<li><p>Temporary data：除去 <code>%rsp</code> 的所有 15 个寄存器都是处理器运算时存储临时数据的位置；</p>
</li>
<li><p>Location of runtime stack：<code>%rsp</code>;（在以后的章节会涉及运行时栈）</p>
</li>
<li><p><strong>Location of current code control point</strong>：<code>%rip</code></p>
<blockquote>
<p>之前没有见过的寄存器，instruction point，和 <code>%rsp</code> 一样有特殊用途。</p>
<p><strong>它包含了当前正在执行指令的地址</strong>，也不能手动修改，一般是通过获取它的值来进行一些操作；</p>
<p><strong>它一般由 <code>call</code> 指令 和 <code>ret</code> 指令等修改</strong>；</p>
</blockquote>
</li>
<li><p>Status of recent tests: <strong>Condition Code</strong></p>
<ul>
<li>一共 8 种， 现在只说四种，其他的用到再说：<code>CF</code>、<code>ZF</code>、<code>SF</code>、<code>OF</code>;</li>
<li>它们都是 1-bit flag，不是被直接手动设置，而是根据其他指令操作后的结果进行设置（<strong>implicit setting</strong>）；</li>
<li>是汇编条件操作的基础；</li>
</ul>
</li>
</ul>
<h4 id="4-1-2-The-meanings-for-Condition-Codes"><a href="#4-1-2-The-meanings-for-Condition-Codes" class="headerlink" title="4.1.2 The meanings for Condition Codes"></a>4.1.2 The meanings for Condition Codes</h4><ul>
<li>Single bit register: 这种寄存器不是之前介绍的整型寄存器，它仅存储 1-bit 数据，专门用于存放 condition codes，它们的名称就是对应的 flag 的名称。先介绍其中 4 种的含义：<ul>
<li><code>CF</code>: Carry Flag (for unsigned, 将两个 unsigned 相加，MSB 的进位)；</li>
<li><code>SF</code>: Sign Flag (for signed, 当 signed 运算结果的 MSB = 1，说明结果是负值，此位会被置 1);</li>
<li><code>ZF</code>: Zero Flag (上一个计算结果为 0 时，此位会被置 1。依靠算术指令内部实现);</li>
<li><code>OF</code>: Overflow Flag (signed 运算溢出的位。<strong>因此可以将 <code>CF</code> 理解为“unsigned 运算溢出的位</strong>”);</li>
</ul>
</li>
<li><strong>注意：之前说的 <code>leaq</code> 不会设置这些 flags</strong>；但之前介绍的算术运算指令会。</li>
<li><strong>注意2：也有专门利用计算结果值来设置 flags 的指令：<code>compare 和 test</code></strong> (explicit setting)</li>
</ul>
<h4 id="4-1-3-Condition-Codes-Explicit-Setting"><a href="#4-1-3-Condition-Codes-Explicit-Setting" class="headerlink" title="4.1.3 Condition Codes: Explicit Setting"></a>4.1.3 Condition Codes: Explicit Setting</h4><h5 id="Compare-cmpq-lt-Src2-Src1-gt"><a href="#Compare-cmpq-lt-Src2-Src1-gt" class="headerlink" title="Compare: cmpq &lt;Src2, Src1&gt;"></a>Compare: <code>cmpq &lt;Src2, Src1&gt;</code></h5><ul>
<li>作用：几乎和 <code>subq</code> 一样，但不修改结果值，因为它计算 <code>Src1 - Src2</code> 并且不会对 <code>Src1/2</code> 进行任何操作，但会由此设置上面 4 个介绍到的 condition codes；</li>
<li>内部如何设置 condition codes：主要依据 <code>Src1 - Src2</code> 减法操作。<ul>
<li><code>CF</code> set if carry out from MSB (used for unsigned comparisons);</li>
<li><code>ZF</code> set if <code>Src1 == Src2</code>（即 <code>Src1 - Src2</code> 运算结果结果是否为 0）;</li>
<li><code>SF</code> set if <code>(Src1 - Src2) &lt; 0</code>（即 <code>Src1 - Src2</code> 运算结果的 sign 位是否为 1）;</li>
<li><code>OF</code> set if <code>(Src1 - Src2)</code> in two’s complement (signed) overflow（即 <code>(Src1 &gt; 0 &amp;&amp; Src2 &lt; 0 &amp;&amp; (Src1 - Src2) &lt; 0) || (Src1 &lt; 0 &amp;&amp; Src2 &gt; 0 &amp;&amp; (Src1 - Src2) &gt; 0)</code>，用的就是判断 signed 溢出的条件：两个同号 signed 相加为异号，说明正/负溢出）;</li>
</ul>
</li>
</ul>
<h5 id="Test-testq-lt-Src2-Src1-gt"><a href="#Test-testq-lt-Src2-Src1-gt" class="headerlink" title="Test: testq &lt;Src2, Src1&gt;"></a>Test: <code>testq &lt;Src2, Src1&gt;</code></h5><ul>
<li>作用：几乎和 <code>andq</code> 一样，但不修改结果值，只计算 <code>Src1 &amp; Src2</code>，并由此设置 condition codes；</li>
<li>内部如何设置 condition codes：<ul>
<li><code>ZF</code> set when <code>Src1 &amp; Src2 == 0</code>;</li>
<li><code>SF</code> set when <code>Src1 &amp; Src2 &lt; 0</code>;</li>
<li>因为按位且不会导致任何的进位，所以不设置 <code>CF/OF</code>;</li>
</ul>
</li>
<li>和上面的 Compare 相比，Test 指令可以进行一个参数的判断，例如 <code>testq %rax, %rax</code>，也把一个参数写成 mask，例如 <code>testq $0x22, %rax</code>;</li>
</ul>
<h4 id="4-1-4-Condition-Codes-Reading"><a href="#4-1-4-Condition-Codes-Reading" class="headerlink" title="4.1.4 Condition Codes: Reading"></a>4.1.4 Condition Codes: Reading</h4><p>前面说完如何设置，现在称述一下如何读取使用。这里一般不允许直接访问 flags 对应的寄存器，而是用一系列的 <code>SetX</code> instructions 来读取并操作。</p>
<p><code>SetX</code> Instructions 的作用就是<strong>按照当前的 condition codes，来将指定的单个寄存器的单个 byte 设置为 1 或 0</strong>；</p>
<p><code>SetX</code> Instructions 具体的类型如下：</p>
<table>
    <tr style="text-align: center;">
        <th>SetX</th>
        <th>Condition</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>sete</td>
        <td>ZF</td>
        <td>Equal/Zero</td>
    </tr>
    <tr>
        <td>setne</td>
        <td>~ZF</td>
        <td>Not Equal/Not Zero</td>
    </tr>
    <tr>
        <td>sets</td>
        <td>SF</td>
        <td>Negative</td>
    </tr>
    <tr>
        <td>setns</td>
        <td>~SF</td>
        <td>Nonegative</td>
    </tr>
    <tr>
        <td>setg</td>
        <td>~(SF^OF)&amp;~ZF</td>
        <td>Greater (signed)</td>
    </tr>
    <tr>
        <td>setge</td>
        <td>~(SF^OF)</td>
        <td>Greater or Equal (signed)</td>
    </tr>
    <tr>
        <td>setl</td>
        <td>(SF^OF)</td>
        <td>Less (signed)</td>
    </tr>
    <tr>
        <td>setle</td>
        <td>(SF^OF) | ZF</td>
        <td>Less or Equal (signed)</td>
    </tr>
    <tr>
        <td>seta</td>
        <td>~CF &amp; ~ZF</td>
        <td>Above (unsigned)</td>
    </tr>
    <tr>
        <td>setb</td>
        <td>CF</td>
        <td>Below (unsigned)</td>
    </tr>
</table>

<blockquote>
<p><code>SetX</code> Instructions 都有唯一参数（<strong>语法 <code>setX &lt;Dst&gt;</code></strong>），要求是单个寄存器的 low-order 8-bit 的引用名称，这是由这条指令的作用决定的。</p>
</blockquote>
<p>看上面的表，就解释一个。以 <code>setl</code> 为例，因为大多数时候我们使用 <code>cmpq</code> 对 condition codes 进行设置，所以当 <code>SF</code> 为 1 时，很可能是 <code>Src1 - Src2 &lt; 0</code> 的情况。但是需要排除 <code>Src1 - Src2</code> 正溢出的情况——正溢出也可能导致结果为负，因此是 <code>SF ^ OF</code>；</p>
<p>最后还有一个问题。<code>setX</code> 是为单个寄存器的<strong>单个 low-order 8-bit 设置 0/1</strong>，但之前<strong>在 3.3.1 中明确说过</strong>，我们在 x86-64 架构下一般都讨论 64-bit register 的使用，而那些访问寄存器的 low-order 32-bit（例如 <code>%eax</code>）、low-order 16-bit 的方法用的比较少（在 32 位架构下会多一点）。</p>
<p>而这里，为了条件控制，我们必须访问 64-bit register 的 low-order 8-bit 的位置，这些位置可以由以下名称给出：</p>
<ul>
<li>字母类型命名的 register，不使用前缀 <code>r</code>，而使用后缀 <code>l</code> 就能代表对应的 low-order 8-bit 位置；例如：<code>%rax</code> 的 low-order 1-bit 位置是 <code>%al</code>、<code>%rbx</code> 是 <code>%bl</code>、<code>%rcx</code> 是 <code>%cl</code>、<code>%rdx</code>是 <code>%dl</code>、<code>%rsi</code> 是 <code>%sil</code>、<code>%rdi</code> 是 <code>%dil</code>、<code>%rsp</code> 是 <code>%spl</code>、<code>%rbp</code> 是 <code>%bpl</code>；</li>
<li>数字类型命名的 register，使用后缀 <code>b</code> 就代表对应的 low-order 8-bit 位置；例如 <code>%r8b</code>、<code>%r15b</code> 等；</li>
</ul>
<p>这样操作 64-bit integer register 的 low-order 8-bit，不会影响到其他位的信息；</p>
<hr>
<p>下面是 <strong>example</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gt</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br></pre></td></tr></table></figure>
<p>其对应的汇编代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gt:</span><br><span class="line">    cmpq	%rsi, %rdi</span><br><span class="line">    setg	%al</span><br><span class="line">    movzbl	%al, %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>已知 <code>%rdi</code> 存放了函数的第一参数 x 的值，<code>%rsi</code> 存放了函数第二参数 y 的值，函数返回的结果就放在 <code>%rax</code> 中。下面逐步分析：</p>
<p>第一步使用了 <code>cmpq</code> 将 <code>%rdi 值 - %rsi 值</code>（即 <code>x - y</code>）计算，并为 4 个 condition codes 进行修改；</p>
<p>第二步，<code>setg</code> 对 <code>%al</code> 操作，这是 <code>%rax</code>  的 low-order 8-bit 的位置，表明如果 <code>~(SF ^ OF) &amp; ~ZF</code> 成立，即 <code>x &gt; y</code> 成立，那么为 <code>%rax</code> 的 low-order 8-bit 位置置为 1，否则置为 0；<strong>显然，这里的 <code>%rax</code> 还需要把前面 7 bytes 全部置为 0，才能成为我要返回的值（(int)0/1）</strong>，我们应该怎么做呢？</p>
<p>第三步用到了新的指令 <code>movzbl</code>（<strong>move with zero extension byte to long</strong>）</p>
<blockquote>
<p>语法：<code>movzbl &lt;Src&gt;, &lt;Dst&gt;</code>;</p>
<p>作用：把一个 <code>Src</code> 数据引用大小的 <strong>0 数据</strong> 扩展到 <code>Dst</code> 中（会改变 <code>Dst</code>，但不会改变 <code>Src</code>）;</p>
</blockquote>
<p>那么好，问题又来了，为什么我们明明要把 <code>%rax</code> 剩下的所有 7 bytes 全部置 0，但是汇编中写的却是对 <code>%eax</code>（之前提到的，register 的 low-order 32-bit 位置）置 0，剩下的 high-order 32-bit 不管了吗？</p>
<p>⚠ 实际上，这是 x86-64 架构内部令人迷惑的特性。当一个 64-bit register 从 low-order 只被修改 32-bit 数据时，<strong>会自动将剩下的 high-order 32-bit 全部置 0</strong>。（但是如果只是修改 low-order 16-bit、low-order 8-bit 时，却<strong>不会</strong>为前面的部分置 0）</p>
<p>到此为止，<code>%rax</code> 中的数据应该长这样：<code>0x000000000000000?</code>（最后一位取决于 <code>setg</code> 到底 set 了什么），这就是我们需要返回的 <code>x &gt; y</code> 表达式的值，所以函数结束。</p>
<hr>
<h3 id="4-2-Conditional-Branches"><a href="#4-2-Conditional-Branches" class="headerlink" title="4.2 Conditional Branches"></a>4.2 Conditional Branches</h3><p>前一节的例子描述了如何依靠 condition codes 来修改某个寄存器的 low-order 8-bit 的值，这是实现条件分支的基础。</p>
<p>这一节将利用 condition code 来组织条件分支，本质上也是 reading condition codes；</p>
<h4 id="4-2-1-JX-Instructions-【Old】"><a href="#4-2-1-JX-Instructions-【Old】" class="headerlink" title="4.2.1 JX Instructions 【Old】"></a>4.2.1 JX Instructions 【Old】</h4><ul>
<li><p>语法：<code>jX &lt;LABEL&gt;</code>，这里的 <code>&lt;LABEL&gt;</code> 是汇编程序中的一个<strong>段落标签</strong>，在具体例子中会展示。</p>
<blockquote>
<p>还有一种语法，会在 4.4 中介绍。</p>
</blockquote>
</li>
<li><p>作用：有条件（根据 condition codes）/ 无条件跳转到指定部分的汇编代码继续执行；</p>
</li>
<li><p>具体类型（和 <code>SetX</code> Instructions 使用名称类似）：</p>
<table>
    <tr style="text-align: center;">
        <th>jX</th>
        <th>Condition</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>jmp</td>
        <td>1</td>
        <td>Unconditional</td>
    </tr>
    <tr>
        <td>je</td>
        <td>ZF</td>
        <td>Equal/Zero</td>
    </tr>
    <tr>
        <td>jne</td>
        <td>~ZF</td>
        <td>Not Equal/Not Zero</td>
    </tr>
    <tr>
        <td>js</td>
        <td>SF</td>
        <td>Negative</td>
    </tr>
    <tr>
        <td>jns</td>
        <td>~SF</td>
        <td>Nonegative</td>
    </tr>
    <tr>
        <td>jg</td>
        <td>~(SF^OF)&amp;~ZF</td>
        <td>Greater (signed)</td>
    </tr>
    <tr>
        <td>jge</td>
        <td>~(SF^OF)</td>
        <td>Greater or Equal (signed)</td>
    </tr>
    <tr>
        <td>jl</td>
        <td>(SF^OF)</td>
        <td>Less (signed)</td>
    </tr>
    <tr>
        <td>jle</td>
        <td>(SF^OF) | ZF</td>
        <td>Less or Equal (signed)</td>
    </tr>
    <tr>
        <td>ja</td>
        <td>~CF &amp; ~ZF</td>
        <td>Above (unsigned)</td>
    </tr>
    <tr>
        <td>jb</td>
        <td>CF</td>
        <td>Below (unsigned)</td>
    </tr>
</table>
</li>
<li><p>Example：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">absdiff</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) result = x - y;</span><br><span class="line">    <span class="keyword">else</span> result = y - x;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">    cmpq	%rsi, %rdi</span><br><span class="line">    jle		.L4</span><br><span class="line">    movq	%rdi, %rax</span><br><span class="line">    subq	%rsi, %rax</span><br><span class="line">    ret</span><br><span class="line">.L4:</span><br><span class="line">    movq	%rsi, %rax</span><br><span class="line">    subq	%rdi, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>已知 <code>%rdi</code> 保存的是函数第一参数 x，<code>%rsi</code> 保存的是函数第二参数 y，<code>%rax</code> 保存函数返回值。</p>
<blockquote>
<p>再次说一下，<strong>汇编函数返回前只需要把返回值放在特定的寄存器中就行</strong>，只要调用方清除你放在哪就行。比如这里放在 <code>%rax</code>，那么函数结束后，调用方会去 <code>%rax</code> 访问结果。</p>
</blockquote>
<p>第一步 <code>cmpq</code> 根据 <code>%rdi 值 - %rsi 值</code> 来设置 condition codes；</p>
<p>第二步的 <code>jle</code> 对应的条件是 <code>(SF ^ OF) | ZF</code>，结合上一步也就是 <code>x ≤ y</code> 时，跳至 <code>.L4</code> 标签标记的位置继续执行。</p>
<p>这里 <code>.L4</code> 是一个标签，<code>.</code> 开头表示它是<strong>内部的</strong>操作或标签，只会出现在汇编代码中，不会出现在目标代码（机器代码）中，所以不会被当作独立的函数。</p>
<blockquote>
<p>有同学会说，不是说汇编代码就是机器代码的文本表示吗？为啥还有差别？</p>
<p>其实是这样的，汇编代码相对于机器代码，在转换为易读的文本同时，会把一些<strong>指令地址</strong>设置成内部标签。在汇编转机器代码时，会再计算代入回去。不然你读 <code>jle 0x0F0E2310</code> 肯定没有 <code>jle .L4</code> 好读。</p>
</blockquote>
<p>后两步的含义已经比较简单了，不再赘述。</p>
<p>上面的内容<strong>类似 C/C++ 中的 goto 语句，不建议在 C/C++ 中使用</strong>；</p>
</li>
</ul>
<h4 id="4-2-2-General-Conditional-Expression-Translation-amp-Conditional-Moves"><a href="#4-2-2-General-Conditional-Expression-Translation-amp-Conditional-Moves" class="headerlink" title="4.2.2 General Conditional Expression Translation &amp; Conditional Moves"></a>4.2.2 General Conditional Expression Translation &amp; Conditional Moves</h4><blockquote>
<p>本小节介绍了 “条件移动” 这种编译器优化的方式，告诉我们在有些情况下，编译器将条件控制一味地翻译成 <code>JX</code> Instructions 不见得是最好的；同时也指明了不应该使用 “条件移动” 优化的情形。</p>
</blockquote>
<p>上面介绍的 <code>JX</code> Instructions 真的适合编译器使用吗？效率是最高的吗？如果仔细看上一节标题会发现有一个 “【Old】” 的标志，这说明现在不经常用到它了。如果效率不佳，那么有哪些方法可以考虑呢？为什么呢？</p>
<p>如果编译器将 C++ 代码翻译为上面的 <code>JX</code> Instructions，那么这种翻译被称为 <strong>General Conditional Expression Translation</strong>，这也是最自然的方法：如果满足某个条件就跳转到哪里执行，否则如何如何。</p>
<p>还有一种方法被称为 <strong>条件移动（Conditional Moves）</strong>，是将 C/C++ 代码中的条件分支（if-else）的 “then” 分支和 “else” 分支<strong>全部执行</strong>，最后按照条件再决定将谁移动到结果寄存器中。</p>
<p>伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result    = the value of Then_Expr</span><br><span class="line">eval    = the value of Else_Expr</span><br><span class="line">cond    = !(the value of Test)</span><br><span class="line">if (cond) result = eval</span><br><span class="line"></span><br><span class="line">return result</span><br></pre></td></tr></table></figure>
<p>有人说，这把 then 子句和 else 子句都运行了，平均的时间复杂度上不是会比之前的 General Condition Expression 更浪费时间吗？其实不然，这里的知识和后面章节的 “流水线” 有关。</p>
<p>因为现代处理器采用 “流水线（pipeline）” 的运行方式，在到达一行代码时会关联甚至运行下面几行的代码。现代处理器大概可以同时处理 20 行左右的指令深度（主要取决于事先读入的指令条数）。当运行到含有分支的部分时，处理器会采取 “<strong>分支预测技术</strong>”，根据上下文猜测会运行到哪个分支，并将猜测的分支事先读入流水线。</p>
<p>如果猜对，那么执行非常迅速，直接读取流水线上的信息，并离开这个分支；但是如果猜错，那么将停止执行当前流水线上的代码，并重新读入另一段分支。这是个耗时操作，较差情况下会花费 40 个时钟周期（40 步普通指令执行时间）。</p>
<p>因此，<strong>在某些情况下</strong>，使用 Conditional Moves 的条件判断方法可能会比 General Conditional Expression 更高效。</p>
<p><strong>正因如此，大多数编译器在<u>某些情况下</u>都选择 Conditional Moves，而不是上面的 <code>JX</code> 指令（代表 General Condition Expression），所以你几乎看不到 4.2.1 中的汇编代码。</strong>如果实在想看到，那么在用 gcc 编译时，给定参数 <code>-fno-if-conversion</code>，这样不允许编译器使用条件移动。</p>
<hr>
<p>所以在 4.2.1 中大多数情况下的汇编代码应该长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">    movq	%rdi, %rax</span><br><span class="line">    subq	%rsi, %rax</span><br><span class="line">    movq	%rsi, %rdx</span><br><span class="line">    subq	%rdi, %rdx</span><br><span class="line">    cmpq	%rsi, %rdi</span><br><span class="line">    cmovle	%rdx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>再稍微解释一下，第一步是将 <code>%rdi</code> 的值（即函数第一参数 x）赋给 <code>%rax</code>；</p>
<p>从第二步开始就是条件移动的方法了：第二步先把 <code>%rax</code> 的值（x）减去 <code>%rsi</code>（y），相当于先做了 then 分支的内容；</p>
<p>第三步是将 <code>%rsi</code> 的值（y）移动到 <code>%rdx</code> 中，并再第四步把 <code>%rdx</code> 的值减去 <code>%rdi</code>（x），相当于完成了 else 分支的内容；</p>
<p>到目前为止，<code>%rax</code> 中存放 <code>x - y</code> 的值，<code>%rdx</code> 中存放 <code>y - x</code> 的值；</p>
<p>第五步才是按照 x、y 的值来设置 condition codes；</p>
<p>最后一步是一个<strong>新指令：<code>cmovle</code></strong>;</p>
<ul>
<li>语法：<code>cmovle &lt;Src&gt;, &lt;Dst&gt;</code>；</li>
<li>作用：条件移动，按照当前 condition codes 的状态进行移动。其中 <code>cmove</code> 就是 conditional moves，<code>le</code> 就是之前的 <code>X</code> 情况（小于等于情况），所以猜测还有 <code>cmovel</code>、<code>cmovege</code>、<code>cmoveg</code>……</li>
</ul>
<hr>
<p>但是，上面说 <strong>Conditional Moves 更快是在“某些情况下”</strong>，那么什么是 “另外的情况”？</p>
<p>现在介绍在什么时候，汇编的翻译不应该用 Conditional Moves：</p>
<p><strong>Situation 1: Expensive Computations</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = Test(x) ? Hard1(x) : Hard2(x);</span><br></pre></td></tr></table></figure>
<p>这种 then 子句和 else 子句都非常难以计算的时候，不应该用条件移动。因为重新读入流水线的时间很可能会少于把两个子句都计算一遍的时间；</p>
<p><strong>Situation 2: Risky Computations</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = p ? *p : <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>上面的判断语句必须先判断再进行执行，否则会出现程序错误，尤其是在指针的判断上；</p>
<p><strong>Situation 3: Computations with side effects</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = x &gt; <span class="number">0</span> ? x*=<span class="number">7</span> : x+=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>上面的 then 和 else 子句一旦执行，会破坏程序的原义，造成意想不到的后果。</p>
<h3 id="4-3-Loops"><a href="#4-3-Loops" class="headerlink" title="4.3 Loops"></a>4.3 Loops</h3><h4 id="4-3-1-Do-While-Loop"><a href="#4-3-1-Do-While-Loop" class="headerlink" title="4.3.1 Do-While Loop"></a>4.3.1 Do-While Loop</h4><p>对于一个计算 x 代表的二进制代码中的 1 的个数的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pcount_do</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result += x &amp; <span class="number">0x1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的汇编代码非常简单，<strong>就可以用 General Conditional Expression 的方法，结合 <code>JX</code> Instructions 实现</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pcount_do:</span><br><span class="line">    movl	$0, %eax</span><br><span class="line">.L2:</span><br><span class="line">    movq	%rdi, %rdx</span><br><span class="line">    andl	$1, %edx</span><br><span class="line">    addq	%rdx, %rax</span><br><span class="line">    shrq	%rdi</span><br><span class="line">    jne		.L2</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure>
<p>对应的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    preparations</span><br><span class="line">loop:</span><br><span class="line">    Body</span><br><span class="line">    if (Test)</span><br><span class="line">        goto loop</span><br></pre></td></tr></table></figure>
<p>这里注意一下，<code>movl</code> 和 <code>andl</code> 都不算新的指令——之前说过 <code>q</code> 的含义代表操作数的位数，quad 指 4 字（4 × 16 bits），<code>l</code> 就指 2 字，2 × 16 bits；</p>
<h4 id="4-3-2-General-While-Loop-Translation-1-“Jump-to-Middle”-Translation"><a href="#4-3-2-General-While-Loop-Translation-1-“Jump-to-Middle”-Translation" class="headerlink" title="4.3.2 General While Loop Translation #1 - “Jump to Middle” Translation"></a>4.3.2 General While Loop Translation #1 - “Jump to Middle” Translation</h4><p>从 do-while 到 while 只需要更改一下测试条件的顺序就行。例如上一节的代码改成 while 循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pcount_do</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        result += x &amp; <span class="number">0x1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么对应的汇编伪代码<strong>可以是</strong>（一般在编译器优化等级 <code>-Og</code> 时出现）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    goto test;		// 先测试</span><br><span class="line">loop:</span><br><span class="line">    Body</span><br><span class="line">test:</span><br><span class="line">    if (Test)</span><br><span class="line">        goto loop;	// 通过再进循环体</span><br><span class="line">done:</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure>
<h4 id="4-3-3-General-While-Loop-Translation-2-“Do-while”-Conversion"><a href="#4-3-3-General-While-Loop-Translation-2-“Do-while”-Conversion" class="headerlink" title="4.3.3 General While Loop Translation #2 - “Do-while” Conversion"></a>4.3.3 General While Loop Translation #2 - “Do-while” Conversion</h4><p>如果把编译器的优化等级调至 <code>-O1</code>，那么编译器在处理 while 循环时不会采用上面的 ”Jump to Middle“ 的翻译策略，而是采用 <strong>转换为 do-while 循环</strong> 的策略，这样会更加高效。</p>
<p>这相当于把 C/C++ 代码中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test) &#123;</span><br><span class="line">    Body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换成了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Test)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Body</span><br><span class="line">&#125; <span class="keyword">while</span> (Test);</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>具体的汇编伪代码会变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    if (!Test)		// 仅进入前判断一下，接下来就变成 do-while</span><br><span class="line">        goto done;</span><br><span class="line">loop:</span><br><span class="line">    Body</span><br><span class="line">    if (Test)</span><br><span class="line">        goto loop;</span><br><span class="line">done:</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure>
<p>从这个优化上可以看出，其实 do-while 循环会比 while 循环更高效，但现在的编译器比较智能，只要优化等级不低，这个方面会帮你优化掉的。</p>
<h4 id="4-3-4-For-Loop"><a href="#4-3-4-For-Loop" class="headerlink" title="4.3.4 For Loop"></a>4.3.4 For Loop</h4><p>for loop 的汇编实现没那么简单，我们可能需要向 while 或 do-while 上看齐。比如对如下 for 循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Init; Test; Update) &#123;</span><br><span class="line">    Body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器可以转换成 while 循环，如果使用了 <code>-O1</code> 优化，会优化到 do-while：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Init;</span><br><span class="line"><span class="keyword">while</span> (Test) &#123;</span><br><span class="line">    Body</span><br><span class="line">    Update;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"></span><br><span class="line">Init;</span><br><span class="line"><span class="keyword">if</span> (!Test) &#123;    <span class="comment">// do-while 前的测试块（Initial Test）</span></span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Body</span><br><span class="line">    Update;</span><br><span class="line">&#125; <span class="keyword">while</span> (Test);</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>很多时候，<code>-O1</code> 下的编译器甚至可以识别 <code>Init</code> 块 和 do-while 前的测试块的关联，并且合理舍弃前置的测试块。</p>
<h3 id="4-4-Switch-Statements"><a href="#4-4-Switch-Statements" class="headerlink" title="4.4 Switch Statements"></a>4.4 Switch Statements</h3><p>将 C/C++ 的 switch 语句翻译为汇编是相当有难度的。首先应该弄清楚 switch 语句在 C/C++ 中的一系列特性：</p>
<ul>
<li><p>Match integer values；</p>
</li>
<li><p>Fall through cases：当 case 中不存在 break 时，会一直向下运行；</p>
</li>
<li>Merge cases：当一个 case 中没有任何内容时，相当于并入下一个 case（上一点的特例）；</li>
<li>Default case：对于没有匹配的 cases，会进入最后的 default case（如果有的话）；</li>
</ul>
<p>当然，现代的编译器对于 switch 语句的翻译绝不是一系列的 if-else 语句的翻译，而是利用了一个数据结构：<strong>跳表（Jump Table Structure）</strong>；</p>
<p>如下图，switch-case 语句就像一串代码块，每个 case 就是一个块。编译时，switch-case 块会整体一起编译（如下图 Jump Targets），转为汇编指令后，每个块的汇编指令所对应的<strong>地址</strong>会被存储在一个跳表中（如下图 Jump Table）。这样在根据条件调用相应代码块时，只需要 goto 跳表中的对应地址（ray indexing）就能完成任务，无需一个个比对条件。</p>
<p><img src="imgs/jump_table.png" height="300px"></p>
<p>那么，汇编代码是如何在跳表中找到合适的地址的呢？举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_eg</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        w = y * z;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        w = y / z;</span><br><span class="line">        <span class="comment">/* Fall Through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        w += z;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        w -= z;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        w = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子对应的汇编代码可以是（一部分代码）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch_eg:</span><br><span class="line">    movq	%rdx, %rcx</span><br><span class="line">    cmpq	$6, %rdi</span><br><span class="line">    ja		.L8</span><br><span class="line">    jmp		*.L4(,%rdi,8)</span><br></pre></td></tr></table></figure>
<p>逐步解释：</p>
<p>第一步将 <code>%rdx</code>（第三参数 z）赋值到 <code>%rcx</code> 寄存器中；</p>
<p>第二步就将 <code>%rdi</code>（第一参数 x）与常数 6 进行做差比较（为什么是 6？因为在源码中 6 是最大的 case），以此修改 condition codes；</p>
<p>第三步 <code>ja</code> 表示只要 <code>%rdi</code>（x）的值（<strong>看作 unsigned</strong>）在 6 之上，那么就跳至 <code>.L8</code>（看来是 default 片段），否则第四步会无条件跳至某个位置；</p>
<blockquote>
<p>这里编译器处理的非常巧妙：使用 <code>ja</code>（unsigned above）而不是 <code>jg</code>（signed greater），这样同时把 <code>x &gt; 6</code> 和 <code>x &lt; 0</code> 的情况都算入 <code>ja</code> 的条件中，进一步提高了效率；</p>
</blockquote>
<p>这里还需要解释一下，之前没有提到的 <code>JX</code> Instructions 的使用语法。除了 <code>jX &lt;LABEL&gt;</code> 直接跳转至对应标签（direct jump），另一种方法是<strong>间接跳转（indirect jump）：<code>jX &lt;effectiveAddress&gt;</code></strong>；</p>
<p>参数是有效地址，可以是寄存器名称，也可以是右值，例如这个例子中 <code>jmp *.L4(,%rdi,8)</code>，后面的部分 <code>.L4(,%rdi,8)</code> 应该很熟悉了：因为标签会被汇编器翻译为代码段的地址，所以它就是 <code>.L4地址 + 8 * x</code>（<code>%rdi</code> 的值是 x），并把这个值看作 memory 的地址。前面的 <code>*</code> 星号就是直接取地址上内容的意思（和 C/C++ 的相同），可以理解为 <code>leaq</code> 相反的过程；<strong>这个 memory 地址中的值就是跳表中的一个代码段的地址</strong>，所以取出来的也是地址；</p>
<p>第四步跳转的位置如何，我们需要看看剩下来的汇编代码（跳表部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            ; read only data</span><br><span class="line">.section    .rodata	; 这行和下一行是为了构造跳表的基本结构</span><br><span class="line">    .align	8		; 伪对齐指令，指明下面的变量必须从下一个能被 8 整除的地址开始</span><br><span class="line">.L4:                ; 代码块按照 x 的值的顺序进行排列</span><br><span class="line">    .quad	.L8		; x = 0 的情况</span><br><span class="line">    .quad	.L3		; x = 1</span><br><span class="line">    .quad	.L5		; x = 2</span><br><span class="line">    .quad	.L9		; x = 3</span><br><span class="line">    .quad	.L8		; x = 4</span><br><span class="line">    .quad	.L7		; x = 5</span><br><span class="line">    .quad	.L7		; x = 6</span><br></pre></td></tr></table></figure>
<p>如上所示，跳表的结构是由汇编代码指定的，如何填这个表是<strong>汇编器的工作</strong>，不是编译器的工作；</p>
<p>在编译器生成的汇编代码中，<code>.quad</code> 只是个声明，标记表示这里是一个 4 字（4 × 16 bits）的数据，以后汇编器需要填上后面指定标签指令段的地址；</p>
<p>我们可以发现，<code>x &lt; 0</code> 和 <code>x &gt; 6</code> 的情况在之前的代码中被 <code>ja</code> 处理，跳至 <code>.L8</code>（default 代码段），剩余在 switch 中整数缺省的情况（<code>x = 4</code> 和 <code>x = 0</code>）也会自动转至 <code>.L8</code>;</p>
<p>主干看完了，继续看之前提到的各个代码段的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.L3:                    ; 对应 x = 1 的情况的代码段</span><br><span class="line">    movq	%rsi, %rax</span><br><span class="line">    imulq	%rdx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>接下来，编译器的行为就很迷惑了。大家是否还记得，之前在源码的第一行有 <code>long w = 1;</code> 的初始化操作？但编译器不做，因为在很多 case 下并没有用到这个值，所以赋值被推迟了，直到有一个 case—— <code>x = 3</code>，它的代码段是 <code>w += z;</code> 需要用到之前的值，这个时候编译器才开始赋值 1，这么做只是为了提高效率……如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.L5:                    ; 对应 x = 2 的代码段</span><br><span class="line">    movq	%rsi, %rax</span><br><span class="line">    cqto</span><br><span class="line">    idivq	%rcx		; %rcx 中存放 z，这里是 y/z</span><br><span class="line">    jmp	.L6</span><br><span class="line">.L9:                    ; 对应 x = 3 的代码段之前的 x = 1 的赋值操作，也是x = 3入口</span><br><span class="line">    movl	$1, %eax</span><br><span class="line">.L6:                    ; 对应 x = 3 的代码段主体</span><br><span class="line">    addq	%rcx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>其中 <code>cqto</code> 是 Convert Quadword to Octoword，意为 64-bit 扩展至 128-bit，没有参数，作用是将 <code>%rax</code> 中的 MSB 复制到整个 <code>%rdx</code> 寄存器中（这么做的原因是 <strong>Expanding Conclusion</strong>），一般紧接着 <code>idivq &lt;dividerR&gt;</code>，将 <code>rdx:rax</code> 中的 128-bit 数作为被除数，<code>divderR</code> 作为除数，进行 signed 除法，商存在 <code>%rax</code>，余数存在 <code>%rdx</code>；</p>
<p>继续：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.L7:                    ; x = 5</span><br><span class="line">    movl	$1, %rax</span><br><span class="line">    subq	%rdx, %rax</span><br><span class="line">    ret</span><br><span class="line">.L8:                    ; x = 6</span><br><span class="line">    movl	$2, %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>明白了跳表的原理，这下明白了为啥 C/C++ 要求 switch 的量必须是可以转换为整型的常量了吧？</p>
<p>无论如何，编译器都会找出你写的所有 case 的最大值、最小值，在此之外的情况会在进入跳表前进行跳转至 default 块；在最值之间的，会出现在跳表中（也就是说 case 的最大值、最小值决定了跳表的大小）；但是在范围中有缺省的情况的，也会补充在跳表中，跳转到 default 块。</p>
<blockquote>
<p>小机灵可能会问，诶，如果这些 case 全是负数咋整？或者最小值很大咋整？还能不能建立跳表、用索引了？因为咱之前的 <code>jmp *.L4(,%rdi,8)</code> 不就直接把 x 做跳表索引了吗？</p>
<p>实际编译器会确保最小值不会低于 0，也不会太大。为此，编译器可能会加上偏置值（bias）让 case 变成小的正数。</p>
<p>还有小机灵可能会问，如果一个 case 是 0， 另一个是 10000，难度在这之中的全部要建表吗？也就是说，如果 case 的间隔很稀疏、很大怎么办？</p>
<p>这个时候编译器会把这些 switch-case 转换成 if-else 语句，再建立 if-else 树，由于稀疏的数据，所以这个树大概率是平衡树，让比对的时间复杂度保持在 $O(log_2(n))$；</p>
</blockquote>
<p>综合上面的讨论，无论如何 switch-case 所依赖的跳表的时间复杂度会在 $O(1)\sim O(log_2(n))$ 之间，总是比 if-else 的线性时间复杂度要好。</p>
<h3 id="4-5-Summary-for-Chapter-4"><a href="#4-5-Summary-for-Chapter-4" class="headerlink" title="4.5 Summary for Chapter 4"></a>4.5 Summary for Chapter 4</h3><p>这章的知识点比较多，在这里总结一下 Chapter 4 的主要内容。</p>
<p>在一开始，我们先复习了之前的寄存器及其代表的处理器的状态，再初步了解了汇编中的重要 flags: condition codes（目前只认识了 4 个：<code>CF/OF/SF/ZF</code>），它们可以看作一个个 1-bit 数据，不能被手动更改，但可以通过特定的方式进行访问。</p>
<p>例如 <code>cmpq</code> 和 <code>testq</code> 能根据计算结果修改 flags，<code>setX</code> Instructions 能根据当前 flags 设置特定的 8-bit 位。我们还了解了几个特殊的指令，例如 <code>movzbl</code>；了解了 x86-64 的 low-order 32-bit 填充特性。</p>
<p>我们不满足于借助 condition codes 仅仅填充几个 bits，我们进一步学习了根据 condition codes 进行流程控制的方法。</p>
<p>首先是比较低效的 <code>JX</code> Instructions，它代表着 General Conditional Expression，利用汇编<strong>条件跳转</strong>初步实现条件分支；进一步从流水线层面，我们认识到 <strong>Conditional Moves</strong> 可能是更好、更快的选择，但一定要搞清 3 个禁忌条件。我们还认识了 <code>cmovle</code> 等一系列<strong>条件移动的指令</strong>，让过程更加方便。</p>
<p>在循环控制方面，我们掌握了 do-while 结构的翻译方法，通过 <code>JX</code> 指令轻松解决；针对 while 循环时，我们想到两种方法：“Jump to Middle” 把判断条件放 loop 的中间，开始循环前跳进去；还有一种是转换为 do-while 的 “set guardian” 方法，效率更高。对于 for 循环，我们也可以容易地将其转换为 while 循环，进一步优化为 do-while，通过合理舍弃 “guardian” 进一步加快运行效率。</p>
<p>在比较繁琐的 switch-case 语句的翻译上，聪明的人们为它引入了<strong>跳表</strong>的数据结构，利用 <code>jX</code> 的间接跳转在 $O(1)\sim O(log_2(n))$ 的复杂度下完成了分支，远胜 if-else 结构的线性复杂度。</p>
<p>不过上面的几乎所有内容都是在汇编层面<strong>实现了一些小的 “tricks”</strong> 来帮助提升运行效率，这只是在将代码流程控制的翻译这个 procedure 上加一点东西，或者是<strong>改变流程的方法</strong>。这都是底层指令逐步堆砌实现更高级指令的实例。</p>
<p>下一章节我们将系统学习汇编运行的整个 procedure，知识点将更为复杂，做好准备！</p>
<h2 id="Chapter-5-Machine-Level-Programming-Ⅲ-Procedure"><a href="#Chapter-5-Machine-Level-Programming-Ⅲ-Procedure" class="headerlink" title="Chapter 5. Machine Level Programming Ⅲ - Procedure"></a>Chapter 5. Machine Level Programming Ⅲ - Procedure</h2><blockquote>
<p>本章所指的 Procedure 既可以是 function，method，也可以是 normal procedure；</p>
</blockquote>
<p>知识补充：什么是 ABI ？</p>
<p>虽然 CSAPP 讲述的是基于 x86 硬件及其运行方式，但更重要的是我们采用了一套被普遍承认的约定—— ABI（Application Binary Interface），这是个<strong>机器程序级别的接口</strong>。这个接口在第一台 x86 机器被制造出来的时候就出现了，尤其是为 Linux 制定的。它规定了，所有二进制程序、操作系统各个组件、编译器都要对于管理机器上的资源有共同的理解，并且遵守使用规则。</p>
<p><strong>例如之前说的，约定俗成哪些寄存器用来传递函数参数、哪些寄存器用来传递返回值，哪些是 “Caller-Saved Register”，哪些又是 “Callee-Saved Register”</strong>，这些都是 ABI 规定的；</p>
<p>到目前，Windows 和 OSX 等操作系统也有自己的 ABI；</p>
<h3 id="5-1-Mechanisms-in-Procedures"><a href="#5-1-Mechanisms-in-Procedures" class="headerlink" title="5.1 Mechanisms in Procedures"></a>5.1 Mechanisms in Procedures</h3><blockquote>
<p>过程机理的概览，下几节会一一回答这些问题；</p>
</blockquote>
<ul>
<li>Passing control<ul>
<li>To beginning of procedure code（运行过程如何进入一个函数？）</li>
<li>Back to return point（函数运行结束如何跳转到之前调用位置的下一行？）</li>
</ul>
</li>
<li>Passing data<ul>
<li>Procedure argument（如何向被调方传递参数？）</li>
<li>Return value（被调方如何返回数据给调用方？）</li>
</ul>
</li>
<li>Memory management<ul>
<li>Allocate during procedure execution（某过程开始执行时，内存如何分配以供过程使用？）</li>
<li>Deallocate upon return（某过程结束后，内存如何销毁？）</li>
</ul>
</li>
<li>Mechanisms all implemented with machine instructions（以上机理如何在机器代码中实现？）</li>
<li>x86-64 implementation of a procedure uses only those mechanisms required（示例）</li>
</ul>
<h3 id="5-2-x86-64-Stack"><a href="#5-2-x86-64-Stack" class="headerlink" title="5.2 x86-64 Stack"></a>5.2 x86-64 Stack</h3><blockquote>
<p>在此之前，先介绍 x86-64 architecture 的内存栈的机制；</p>
</blockquote>
<p>程序总是使用栈来<strong>管理过程中调用和返回状态</strong>，这主要是利用了栈 LIFO 的性质，这和调用-返回的思想很相似。因此它可以被用于：<strong>传递潜在信息、控制信息，分配 local 数据</strong>；</p>
<p>x86 的程序栈也存在于内存中，<strong>栈底位于 high numbered address（高位地址）</strong>，而栈顶位于 low numbered address；</p>
<p>前面说的 <strong><code>%rsp</code> 寄存器</strong>就是位于栈顶来管理这个过程的。<code>%rsp</code> 寄存器存储的是<strong>栈顶的地址</strong>，当有数据需要进栈时，<strong>通过递减栈指针来完成进栈操作</strong>；</p>
<p>之前还说过，<code>%rsp</code> 不应该被手动更改，那么有哪些方法能够使用这个栈呢？</p>
<p>第一个是 <code>pushq</code> 指令。</p>
<ul>
<li><p>语法：<code>pushq &lt;Src&gt;</code>;</p>
</li>
<li><p>作用：先从 <code>Src</code> 中取得操作数，再将 <code>%rsp</code> 值减 8（quadword，即 4 × 16 bits，64 bits，8 bytes），最后将从 <code>Src</code> 处获得的操作数写入到 <code>%rsp</code> 对应的 memory 地址中；</p>
<blockquote>
<p>⚠ 需要注意的点：<strong>这个栈是先移动指针再往里面写的</strong>；</p>
</blockquote>
</li>
<li><p><code>Src</code> 可以是直接量、寄存器名称、内存引用；</p>
</li>
</ul>
<p>与之对应的是 <code>popq</code> 指令。</p>
<ul>
<li><p>语法：<code>popq &lt;Dst&gt;</code>;</p>
</li>
<li><p>作用：先将 <code>%rsp</code> 值所代表的 memory 地址中的值读进，再将 <code>%rsp</code> 的值加 8，最后将读到的值写入 <code>Dst</code>;</p>
<blockquote>
<p>⚠ 需要注意的点：<strong>这个 <code>Dst</code> 只能是寄存器</strong>，因为前面说了，不允许从内存到内存，也不允许存入直接量；</p>
</blockquote>
</li>
</ul>
<h3 id="5-3-Calling-Conventions"><a href="#5-3-Calling-Conventions" class="headerlink" title="5.3 Calling Conventions"></a>5.3 Calling Conventions</h3><h4 id="5-3-1-Passing-Control"><a href="#5-3-1-Passing-Control" class="headerlink" title="5.3.1 Passing Control"></a>5.3.1 Passing Control</h4><p>以一个例子说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = mult2(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">    <span class="type">long</span> s = a * b;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是上面的源码经过汇编得到的结果（稍微删除了一些无关紧要的部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">    push	%rbx</span><br><span class="line">    mov		%rdx, %rbx</span><br><span class="line">    callq	400550 &lt;mult2&gt;</span><br><span class="line">    mov		%rax, (%rbx)</span><br><span class="line">    pop		%rbx</span><br><span class="line">    retq</span><br><span class="line"></span><br><span class="line">mult2:</span><br><span class="line">    mov		%rdi, %rax</span><br><span class="line">    imul	%rsi, %rax</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>
<p>这里注意一下 <strong>Passing Control</strong> 是怎么完成的：</p>
<ul>
<li><p>使用了程序栈来支持 procedure 的数据；</p>
</li>
<li><p>使用 <code>call &lt;LABEL&gt;</code> 指令来完成：</p>
<ol>
<li>把 <strong>return address</strong>（调用结束，返回时的位置）加入到栈中；</li>
<li>跳至 <code>LABEL</code> 执行；</li>
</ol>
</li>
<li><p>使用 <code>ret</code> 指令来完成：</p>
<ol>
<li>将栈中的地址弹出读取；</li>
<li>跳转到读取的地址；</li>
</ol>
<blockquote>
<p>有的时候会看到 <code>rep; ret</code> 的指令行，不用管，它和 <code>ret</code> 作用一样；</p>
</blockquote>
</li>
</ul>
<p>因此，Passing Control 的过程主要由两个特殊寄存器、一个栈支持；运行的动态如下（地址信息是虚拟的）：</p>
<p><img src="imgs/procedure_control_1.png" height="200px"><img src="imgs/procedure_control_2.png" height="200px"><img src="imgs/procedure_control_3.png" height="200px"><img src="imgs/procedure_control_4.png" height="200px"></p>
<h4 id="5-3-2-Passing-Data"><a href="#5-3-2-Passing-Data" class="headerlink" title="5.3.2 Passing Data"></a>5.3.2 Passing Data</h4><p>其实在此之前的前几章，我们已经看到了，汇编程序使用约定俗称的寄存器（“Caller-Saved Resgiter”）来完成函数参数、返回值的传递：</p>
<ul>
<li><p><code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rcx</code>、<code>%r8</code>、<code>%r9</code> 这都是 Caller-Saved Register，约定<strong>从前到后</strong>（顺序可以记下来）用来存放函数的六个参数，供被调用方使用；</p>
<blockquote>
<p>这里是 integer registers，如果参数不是整型 / 指针，那么会用<strong>浮点数寄存器</strong>来存放，以后说。</p>
<p>注：在 IA-32 时期，甚至所有参数都放在栈里，这会大大降低程序运行速度的。</p>
</blockquote>
</li>
<li><p>如果函数多于 6 个参数那么从第 7 个参数开始，将按顺序存放在栈里，仅需要才会分配栈（<strong>这个栈也用 <code>%rsp</code> 访问，每 8 bytes 一个参数，但是位于另一个栈帧，和调用方的栈帧互不干扰。具体情况见下一节</strong>）</p>
</li>
<li><p><code>%rax</code> 是 Callee-Saved Register，约定是用于存放函数的返回值，供调用方读取；</p>
</li>
</ul>
<h4 id="5-3-3-Managing-Local-Data"><a href="#5-3-3-Managing-Local-Data" class="headerlink" title="5.3.3 Managing Local Data"></a>5.3.3 Managing Local Data</h4><p>早在 5.2 中就介绍了 x86 栈的作用之一就是<strong>分配 local 数据</strong>。那么调用和返回的功能之一就是可以对函数进行嵌套调用。</p>
<p>此外，我们将栈上<strong>用于特定 call 的每个内存块称为栈帧（stack frame）</strong>，它是特定 procedure、特定 instance 的栈帧。单线程程序共用一个栈，因此通过栈帧来管理各个函数的 Local data；</p>
<p>栈帧的结构如何？是如何管理的？其中究竟放了些什么？</p>
<ul>
<li><p>Structure：大家在 C++ 程序设计课程上应该接触过 “变量作用域”，这个时候应该强调了不同函数的局部变量会存在它的栈帧中。所以可以想象，栈帧就是一段一段堆叠在 stack 上的片段，每个未返回的函数独享一个栈帧；</p>
<p><img src="imgs/stack_structure.png" height="300px"></p>
<p><strong>并且 <code>%rsp</code> 就在之前说的栈顶，还有一个普通寄存器 <code>%rbp</code> 可以用来存放两个栈帧交界的位置（只有在一些特殊情况下编译器才会使用它，平时会当作普通寄存器使用）</strong>；</p>
<p>所以大多数情况下，没有 <code>%rbp</code> 指示，汇编程序员甚至不知道下一层栈帧在哪里，<strong>这只能靠代码自身管理（大部分情况下编译器知道需要分配多少栈帧、销毁多少栈帧），并且正确释放栈帧（本节的一个例子会演示代码如何自身管理栈帧）</strong>；</p>
<blockquote>
<p>编译器不知道应该分配多少栈帧的特殊情况：<strong>分配可变大小的数组 / 内存缓冲区</strong> 等情况，这时编译器会无奈选择使用 <code>%rbp</code> 管理；</p>
</blockquote>
<p>也正因如此，递归所需的所有基础结构都由栈的原则所保证；</p>
<p>对于 <strong>x86-64 Linux</strong> 这一特定机器 + 操作系统而言，栈帧的<strong>详细结构</strong>应该是这样的：</p>
<p><img src="imgs/stack_structure_detail.png" height="350px"></p>
<ul>
<li><p>之前在 <strong>Passing Control</strong> 中提到 <code>call</code> 指令压入的返回地址存在 Caller Frame 的最上层，下面压着 Caller 的参数；</p>
</li>
<li><p>在两个栈帧之间有空间为可选的旧 <code>%rbp</code>（上一层栈帧的 <code>%rdp</code>）空间，当前的 <code>%rbp</code> 就指向这里（如果有的话）；</p>
</li>
<li><p>在当前 Callee Frame 中，最底层是 <strong>Callee-Saved Register</strong>（保存 Temporaries）和内存中的<strong>局部变量</strong>；向上就是在 <strong>Pass Data</strong> 中提到的<strong>多于 6 个的传入参数</strong>存放的位置。</p>
</li>
<li><p><strong>之前说的 “代码自身管理的方式” 就是在函数返回前将 <code>%rsp</code> 回到一开始的地方（上一层栈帧）</strong>；</p>
</li>
</ul>
</li>
<li><p>Management：为正在执行、没有返回的函数保留一个栈帧</p>
<ul>
<li>Space allocated <strong>when enter procedure</strong><ul>
<li>“Set-up” code</li>
<li>Include push by <code>call</code> instruction</li>
</ul>
</li>
<li>Deallocated <strong>when return</strong><ul>
<li>“Finish” code</li>
<li>Include pop by <code>ret</code> instruction</li>
</ul>
</li>
</ul>
</li>
<li><p>Contents</p>
<ul>
<li>Return information</li>
<li>Local storage（only if necessary）</li>
<li>Temporary space（only if necessary）</li>
</ul>
</li>
</ul>
<hr>
<p>为了演示这一部分，下面列举一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">incr</span><span class="params">(<span class="type">long</span> *p, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = *p;</span><br><span class="line">    <span class="type">long</span> y = x + val;</span><br><span class="line">    *p = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">call_incr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> v1 = <span class="number">15213</span>;</span><br><span class="line">    <span class="type">long</span> v2 = incr(&amp;v1, <span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">incr:</span><br><span class="line">    movq	(%rdi), %rax</span><br><span class="line">    addq	%rax, %rsi</span><br><span class="line">    movq	%rsi, (%rdi)</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">call_incr:</span><br><span class="line">    subq	$16, %rsp</span><br><span class="line">    movq	$15213, 8(%rsp)</span><br><span class="line">    movl	$3000, %esi</span><br><span class="line">    leaq	8(%rsp), %rdi</span><br><span class="line">    call	incr</span><br><span class="line">    addq	8(%rsp), %rax</span><br><span class="line">    addq	$16, %rsp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>其实函数 <code>incr</code> 的汇编代码很简单，重点不在这，而是调用它的函数 <code>call_incr</code> 以及过程中的处理情况。我们将一步步分析其中的情况。</p>
<p>首先，当上层的 caller 刚刚调用 <code>call call_incr</code> 指令、还没有为 <code>call_incr</code> 分配栈帧时，栈中的情况如下图所示：</p>
<p><img src="imgs/procedure_example_1.png" height="150px"></p>
<p>此时栈顶仍然是上层 caller 的 <code>call</code> 指令刚压入的 return address；随后机器读取 <code>%rip</code> 中保存的 <code>call_incr</code> 的地址开始执行 <code>call_incr</code> 函数；</p>
<p>现在请注意上面的 <code>call_incr</code> 汇编代码。</p>
<p>第一步是将 <code>%rsp</code> 的值减去 16，这意味着一口气在栈中分配了 16 bytes 空间，作为 <code>call_incr</code> 的栈帧（此时 <code>%rsp</code> 理所当然在最上层）；</p>
<blockquote>
<p>程序一般在栈上分配的空间会比实际需求多一点，这是因为有一些内部的约定，要求保持内存对齐，例如汇编中典型的 <code>.align</code> 伪指令。这个分配的值是由编译器计算得出的。</p>
</blockquote>
<p>第二步向 <code>%rsp + 8</code> 的 memory 地址写入常数 15213，这就相当于向栈顶的下面 8 bytes 的位置写入该常数；现在栈中的情况如下图所示：</p>
<p><img src="imgs/procedure_example_2.png" height="150px"></p>
<p>以上的第 1~2 步对应着源码的 <code>long v1 = 15213;</code> 这一步。</p>
<p>第三步将 <code>%rsi</code>（<code>%esi</code>）写入 32-bit 的 3000 整型（还记得之前说的特性吗？高 32-bit 会自动被置 0），因为 <code>%rsi</code> 将来会作为调用函数的第二参数；</p>
<p>第四步还记得吗？找到 <code>%rsp + 8</code> 作为地址对应的 memory 引用（这里就是之前栈中存放常数 15213 的位置）<strong>的地址</strong>（也就是存放 15213 的地址）赋给 <code>%rdi</code>，这就相当于 <code>&amp;v1</code> 给了调用函数的第一参数；</p>
<p>上面的第 3~4 步对应源码中的 <code>long v2 = incr(&amp;v1, 3000);</code> 的 <strong>Passing Data 部分</strong>；</p>
<p>而在过程中大家发现，代码是不是自身就管理了 <code>%rsp</code> 的位置和栈的分配？</p>
<p>在完成函数调用的 Passing Data 部分，我们继续进行 <code>long v2 = incr(&amp;v1, 3000);</code> 这一步的 <strong>Passing Control 部分</strong>：</p>
<p>接下来汇编调用了 <code>call incr</code>，干了 3 件事：<code>%rsp</code> 减 8，存储 return address（这里的是 <code>call incr</code> 下一行指令的地址），并且向 <code>%rip</code> 写入 <code>incr</code> 的起始地址。</p>
<p>于是程序进入了 <code>incr</code> 函数，这比较简单，其中的内存分配、变量设置就不说了。直接跳到 <code>incr</code> 函数的 <code>ret</code> 指令，此时经过内部的代码控制，<code>%rsp</code> 应该回到了之前 <code>call_incr</code> 函数栈帧的顶部（存放 return address 的位置）。于是 <code>ret</code> 也做了 3 件事：将 return address 取出来，<code>%rsp</code> 加 8，并向 <code>%rip</code> 写入刚刚取得的地址——也就是 <code>call_incr</code> 函数中 <code>call incr</code> 指令的下一行。</p>
<p>此时，栈的情况如下图所示（18213 是因为 <code>incr</code> 函数修改了 <code>long *p</code> 参数，还有，别搞混了，这个图里的 return address 是调用 <code>call_incr</code> 的上层 caller 的栈帧中的东西）：</p>
<p><img src="imgs/procedure_example_3.png" height="150px"></p>
<p>程序进入 <code>call_incr</code> 汇编的最后两步：把 <code>%rax</code>（<code>incr</code> 函数返回值，也就是 <code>v2</code>）加上 <code>%rsp + 8</code> 地址上的内容（18213，也就是新的 <code>v1</code>）作为函数返回值，<strong>并且把 <code>%rsp</code> 加上 16，释放了之前分配给 <code>call_incr</code> 函数的栈帧</strong>（所以你看看，编译器是不是知道之前分配了多少栈帧空间？是不是不需要 <code>%rbp</code> 的指示？）。函数到此结束，栈中的情况如下：</p>
<p><img src="imgs/procedure_example_4.png" height="100px"></p>
<p>最后的一句 <code>ret</code> 会读取上层 caller 放的 return address，将 <code>%rsp</code> 减 8，并且将 <code>%rip</code> 写入 return address，下一步程序将回到调用 <code>call_incr</code> 的上层 caller 的函数体中。栈的情况如下：</p>
<p><img src="imgs/procedure_example_5.png" height="100px"></p>
<hr>
<h3 id="5-4-Register-Saving-Conventions"><a href="#5-4-Register-Saving-Conventions" class="headerlink" title="5.4 Register Saving Conventions"></a>5.4 Register Saving Conventions</h3><p>之前无论是 5.3.2 讲述传递数据的方法，还是介绍 ABI 的约定，又或是早在 3.3.1 中介绍寄存器的使用，我们无数次提及 register 约定俗成的用法。为了加深印象、补充更多内容，我们这里再梳理一遍。</p>
<p>传递数据的时候，调用方（caller）和被调用方（callee）共同使用这所有的 16 个寄存器。那么，怎么保证 “在 caller 中保存特定数据的某些寄存器，在调用 callee 之后，callee 没有改变这些寄存器，并且还能看作原来的值，继续使用” 呢？</p>
<p>这就是约定 Callee-Saved 和 Caller-Saved Register 的作用了。它们的定义是：</p>
<ul>
<li><p>Caller-Saved: Caller saves temporaries values in its frame before the call <strong>but can be modified by procedures</strong>;</p>
</li>
<li><p>Callee-Saved: Callee saves temporaries values in its frame before using <strong>and restore them before returning to caller</strong>;</p>
<p><strong>（所以如果程序在某个 procedure 中使用了 <code>%rbp</code> 作为普通寄存器，那么能够保证这个函数 return 前 <code>%rbp</code> 会恢复到上一层的值，不会影响把 <code>%rbp</code> 当作 base pointer 使用的函数）</strong></p>
</li>
</ul>
<blockquote>
<p>回忆一下它们分别有哪些？</p>
</blockquote>
<p>所以，如果 caller 真的想要寄存器中的某些值不会被 callee 修改，在调用函数后仍然能使用，那么就应该把值放在 caller-saved register 当中。</p>
<p>此外，ABI 还规定了，callee 在返回前，需要把 callee-saved register 中的值恢复到原来的样子。</p>
<p>此外，一个介于特殊和普通之间的寄存器需要强调一下——<code>%rbp</code>，由于它有时作为分隔栈帧的 base pointer，所以如果有 callee 想要看作普通寄存器来使用它，那么需要在 return 前恢复到原来的状态。</p>
<blockquote>
<p>考虑一个问题，为什么 caller-saved register 一般没有要求 restore？</p>
<p>因为首先， caller-saved register 中保存函数参数的寄存器就是为了给 callee 读取的，所以调用前 caller 会设置这些寄存器的值，没有必要保持数据；另外如果 caller 真的想在调用之后使用这些值，那么可以<strong>把它的值放在自己的 callee-saved register 中，进而，因为 caller 自己也会是 callee，所以在 caller return 前也要恢复这个 callee-saved register</strong>（main 函数除外）；</p>
</blockquote>
<hr>
<p>那么这些约定在一般的代码中是如何体现的呢？下面以之前的 <code>incr</code> 函数为例子，我们加入一个 <code>call_incr2</code> 函数来展示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incr 函数见 5.3.3 的例子</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">call_incr2</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> v1 = <span class="number">15213</span>;</span><br><span class="line">    <span class="type">long</span> v2 = incr(&amp;v1, <span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> x + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">call_incr2:</span><br><span class="line">    pushq	%rbx</span><br><span class="line">    subq	$16, %rsp</span><br><span class="line">    movq	%rdi, %rbx</span><br><span class="line">    movq	$15213, 8(%rsp)</span><br><span class="line">    movl	$3000, %esi</span><br><span class="line">    leaq	8(%rsp), %rdi</span><br><span class="line">    call	incr</span><br><span class="line">    addq	%rbx, %rax</span><br><span class="line">    addq	$16, %rsp</span><br><span class="line">    popq	%rbx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>在上层 caller 进入 <code>call_incr2</code> 的第一件事就是把 <code>%rbx</code> 的值放到 <code>call_incr2</code> 的栈帧中。这是为什么？</p>
<p>原来，这个 <code>call_incr2</code> 函数有一个参数 <code>long x</code>，一开始存在 <code>%rdi</code> 中。但是，<code>call_incr2</code> 想要调用 <code>incr</code> 函数，后者要求两个参数，意味着 callee 会用到 <code>%rdi</code> 或更改。而在 <code>call_incr2</code> 的最后，<code>return x + v2;</code> 说明了等会还要用到现在 <code>%rdi</code> 中的值 x。所以，<code>call_incr2</code> 为了能够继续使用 x 这个值，需要将 x 存到 callee-saved register 中，<strong>因为调用 <code>incr</code> 之后，无论如何 <code>incr</code> 会将 callee-saved register 恢复到原来的数据的！</strong> 而在此之前，为了能够将这里使用的 callee-saved register 在返回前恢复到上一层调用前的状态，需要将原来的数据存在栈中。</p>
<blockquote>
<p>所以现在的情况是，</p>
<p>① caller 为了保留 caller-saved register（<code>%rdi</code>）的数据（因为要设置新的值给下一层 callee 来 passing data）所以要把 <code>%rdi</code> 数据放到 callee-saved register 中，这样调用后不变 ；</p>
<p>② 想要改变 callee-saved register，就需要保存之前的值，以保证上一层调用方在其中的值不变，而这个 callee-saved register 原先的值就放到了当前 caller 的栈帧中。</p>
<p><strong>考虑一个问题，为什么当前函数不把想要保存的数据直接保存在栈中，而是保存在 callee-saved register 中，完事还要为这个 callee-saved register 原先的值保存在自己的栈帧中？</strong></p>
<p>这是因为，直接保存在栈里不方便。如果有多个需要保存的数据，而且都放在栈里，那么读取方式、读取效率（可能会读很多次）都不佳；而且就没有必要设置 callee-saved register 了。</p>
<p>相反，如果保存在 callee-saved register 中，那么 caller 被调用后一开始统一保存上一层的 callee-saved register 的值，caller 返回前统一恢复上一层的 callee-saved register 的值，中间 caller 还能自由使用这些 callee-saved register，多次使用速度快，并且不用担心调用下一层函数会影响其中的值，岂不美哉！</p>
</blockquote>
<p>因此，在 <code>call_incr2</code> 调用 <code>incr</code> 之前，栈的情况如下图所示：</p>
<p><img src="imgs/procedure_example2_1.png" height="150px"></p>
<hr>
<p>总结：<strong>什么时候栈上会出现 Saved-Register 数据？答：当 caller 需要修改 callee-saved register 来保存某些值的时候，caller 会把数据保存到它的栈帧上。</strong>仅此一种情况。</p>
<h3 id="5-5-Illustration-of-Recursion"><a href="#5-5-Illustration-of-Recursion" class="headerlink" title="5.5 Illustration of Recursion"></a>5.5 Illustration of Recursion</h3><blockquote>
<p>本节将详细阐释 “递归” 这个技术在汇编层面的样貌。你会发现，因为有了之前所有的 mechanisms 的支持，C 编译器编译递归函数会和普通函数一样简单。</p>
</blockquote>
<p>以一个例子开始，这个 <code>pcount_r</code> 函数就是之前 “计算二进制数中有几个 1”（例子在 4.3）的递归版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Recursive popcount */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">pcount_r</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (x &amp; <span class="number">1</span>) + pcount_r(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个 trick，就是参数是 unsigned long 类型，这是为了让 <code>x &gt;&gt; 1</code> 运算是<strong>逻辑右移</strong>，千万不能用 signed 的类型，因为 <code>x &gt;&gt; 1</code> 是算数右移，所以对于负数而言永远不会停下；</p>
<p>下面是对应的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pcount_r:</span><br><span class="line">    movl	$0, %eax</span><br><span class="line">    testq	%rdi, %rdi</span><br><span class="line">    je		.L6</span><br><span class="line">    pushq	%rbx</span><br><span class="line">    movq	%rdi, %rbx</span><br><span class="line">    andl	$1, %ebx</span><br><span class="line">    shrq	%rdi</span><br><span class="line">    call	pcount_r</span><br><span class="line">    addq	%rbx, %rax</span><br><span class="line">    popq	%rbx</span><br><span class="line">.L6:</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure>
<p>你会发现递归版本的源码编译出的汇编代码可能稍微比之前迭代循环版本（loop）的汇编代码更长，这是因为递归版本需要额外管理栈的情况。</p>
<p>学完了前面几章节，你会发现这些代码就比较好懂了：</p>
<p>第一步将 <code>%rax</code>（<code>%eax</code>）置零，因为等会可能要 return 0；然后第二步按照 <code>x == 0</code> 的是真是假的答案来设置 condition codes，交由第三步判断并跳转。这是之前的 General Conditional Expression 的翻译方法；</p>
<p>接下来，将 <code>%rbx</code> 这个 callee-saved register 原来的值备份到当前栈帧中，是因为之后要用这个寄存器保存参数 x；果不其然，下一步就是把 <code>%rdi</code>（x）的值复制到 <code>%rbx</code> 中。</p>
<p>接下来用到 x 的地方，除了传给下一层 callee 的第一参数，就只有 <code>x &amp; 1</code> 了，所以直接在 <code>%rbx</code> 上与 1 按位且。下一步也直接在 <code>%rdi</code> 上逻辑右移 1 个单位，这就是传给下一层 callee 的第一参数（<code>x &gt;&gt; 1</code>）;</p>
<p>准备好 passing data 后，进行 passing control，调用 <code>call pcount_r</code> 进行跳转递归。</p>
<p>如果递归结束，那么紧接着就是把 <code>(x &amp; 1)</code>（即 <code>%rbx</code> 中的值）加到 callee 的结果（<code>%rax</code>）中，得到本函数的结果。最后别忘了在返回前从当前栈帧中恢复 callee-saved register <code>%rbx</code>，函数结束。</p>
<p>举完这个例子你会发现，这就是前几章所提到所有技巧的综合，它们使用了同一个约定——参数怎么传、可以用哪些寄存器、寄存器怎么用（还有是否要恢复）、如何参与计算等等。这个约定防止了不同函数在调用时相互摧毁寄存器中重要的值的异常情况。总之按照上面的方法使用寄存器，可以让生活更美好！</p>
<blockquote>
<p>补充一句，有些函数不依赖栈的结构来完成上述的机制，它们会采用堆或者其他数据结构来完成（例如 SML）。</p>
</blockquote>
<p>说了这么多，只有自己上手实践、自己亲自编译、调试这些代码，才能体会到各个部分、tricks、mechanisms 组合起来发挥的作用。</p>
<h3 id="5-5-Summary-for-Chapter-5"><a href="#5-5-Summary-for-Chapter-5" class="headerlink" title="5.5 Summary for Chapter 5"></a>5.5 Summary for Chapter 5</h3><p>本章的内容也是相当之多。为了进一步加深对于汇编 procedure 的认识，我们现在总结一下本章接触到的内容。</p>
<p>在本章开头，我们了解一种规范（接口）被称为 ABI，主要围绕 Linux ABI 展开介绍。ABI 规定了所有二进制程序、操作系统各个组件、编译器对于管理机器上的资源的使用规则，例如寄存器使用的场合和管理方法等等，这在之前的章节中也或多或少的提到过。</p>
<p>想要了解程序运行的总体 procedure，就不得不回答 3 个问题：<strong>程序是如何切换运行控制权的</strong>，<strong>程序如何传递数据的</strong>，还有<strong>程序如何在运行中管理 Memory 内存的</strong>；</p>
<p>为了搞清以上的问题，我们先了解了 x86 架构下的系统栈的简单结构。因为 C/C++ 是依赖于栈来管理程序上下文的语言，并且根据栈 LIFO 的原则，可以被用于：<strong>传递潜在信息、控制信息，分配 local 数据</strong>。正因如此，栈可以胜任<strong>管理过程中调用和返回状态</strong>的任务，也能隔离各个 procedure 示例之间的数据，为递归提供了坚实高效的结构基础。</p>
<p>x86 的栈需要注意的点有 3 个：</p>
<ul>
<li>栈就是在<strong>内存中的</strong>一段连续的数据结构，栈顶位于 low numbered address，栈底位于 high numbered address（头脑里有张图）；</li>
<li>栈顶指针由 <strong><code>%rsp</code></strong> 保存，一般不能手动修改，指向最上层被使用的空间，这意味着<strong>要先减小指针，再放入数据</strong>（或先取出数据，再增大指针）；</li>
<li>想要管理栈中的数据，依靠 <code>pushq</code> 和 <code>popq</code> 这两条指令，这两条指令的参数要求也有重大区别，可以思考一下为什么；</li>
</ul>
<p>随后考虑<strong>程序控制权切换的问题</strong>（Passing Control），具体表现就是<strong>调用时 caller 如何跳转到 callee、如何从 callee 返回到 caller</strong>。通过分析，passing control 由 3 个方面实现：</p>
<ul>
<li>系统<strong>栈</strong>提供数据结构存储层面的支持；</li>
<li>指令 <code>call &lt;LABLE&gt;</code> 通过：<strong>向栈中添加 return address</strong>、<strong>改变 <code>%rip</code> 的值来跳转至 callee</strong> 这两大工作来完成 caller 至 callee 的跳转；</li>
<li>指令 <code>ret</code> 通过：<strong>从栈中取出 return address</strong>、<strong>改变 <code>%rip</code> 的值来跳回 caller</strong> 这两大工作完成 callee 重新返回 caller 的控制流程。</li>
</ul>
<p>第二个点就是<strong>程序数据传输问题</strong>（Passing Data），在单线程程序中具体表现为 <strong>caller 如何向 callee 传递参数</strong>、<strong>callee 如何给 caller 返回值</strong>。在前几章的铺垫下，我们进一步记住了各个整型寄存器在 procedure 及其切换时的约定行为，例如 Caller-Saved / Callee-Saved、传入的函数参数由哪个寄存器  / 给出、函数的返回值由哪个寄存器传输。</p>
<p>前两个问题相对好解决，不过对于 <strong>程序如何在运行中管理 Memory 内存</strong> 这一部分而言，具体表现在进入 procedure 前如何为其分配空间、结束 procedure 前如何释放空间，需要较为详细地了解 x86 栈和<strong>栈帧</strong>的基本结构。对于 x86-64 Linux 而言，一个程序栈在<strong>当前函数实例</strong>中的栈帧从栈底到栈顶应该分别是：</p>
<ul>
<li>old <code>%rbp</code>（上一层 base pointer，如果本层也使用 <code>%rbp</code> 做 base pointer 的话，就指向此位置）；</li>
<li>上层 callee-saved register 备份值（Saved-Register）、local variables（函数局部变量）；</li>
<li>本函数作为 callee 时传入的超过 6 个的参数存放位置（依次）；</li>
<li>return address（如果本层函数是 caller，并且正好运行到 <code>call</code> 指令结束时）；</li>
</ul>
<p>每个函数结束后能否完全释放栈帧并回到原位、调用其他函数时能否准确分配足够的空间，则<strong>依赖代码的自身管理</strong>。</p>
<p>搞清了总体 procedure 的样貌，我们进一步讨论了各个寄存器的细节层面的管理约定。包括以下问题：</p>
<ul>
<li>Caller-Saved Register 和 Callee-Saved Register 各自有哪些种类和定义；</li>
<li>什么时候使用 Caller/Callee-Saved Register，在使用前后应该做哪些处理工作；</li>
<li>为什么要使用 Caller/Callee-Saved Register，栈中的 “Save-Register” 数据是怎么回事。</li>
</ul>
<p>到了本章结束，我们已经能从大致轮廓上认识一个程序运行的 procedure，仅限于整数、长整数、指针的数据传递的工作。</p>
<p>更多的细节，例如之前提到的<strong>浮点数如何传递、保存（浮点寄存器的行为）</strong>，<strong>聚合数据结构在汇编层面如何实现</strong>，等问题，会在下一章进行介绍。</p>
<h2 id="Chapter-6-Machine-Level-Programming-Ⅳ-Data"><a href="#Chapter-6-Machine-Level-Programming-Ⅳ-Data" class="headerlink" title="Chapter 6. Machine Level Programming Ⅳ - Data"></a>Chapter 6. Machine Level Programming Ⅳ - Data</h2><p>之前我们所见到的程序都是操纵正数 / 长整数 / 指针，它们都是<strong>标量整型数据</strong>。本章将讨论浮点寄存器的情形和聚合数据结构在汇编代码中的实现。</p>
<h3 id="6-1-Arrays-in-Assembly"><a href="#6-1-Arrays-in-Assembly" class="headerlink" title="6.1 Arrays in Assembly"></a>6.1 Arrays in Assembly</h3><h4 id="6-1-1-Array-Access-Normal-Array"><a href="#6-1-1-Array-Access-Normal-Array" class="headerlink" title="6.1.1 Array Access: Normal Array"></a>6.1.1 Array Access: Normal Array</h4><p>众所周知，数组在 C/C++ 中声明的语法为 <code>T A[L];</code>，表示 Array of data type <code>T</code> and length <code>L</code>；</p>
<p>这说明了 2 件事：</p>
<ol>
<li>数组应该在内存中分配的方式：<strong>Contiguously allocated region of <code>L * sizeof(T)</code> bytes in memory</strong>;</li>
<li>identifier <code>A</code> 可以被用作<strong>指向数组开头位置的指针（类型 <code>T*</code>）</strong>；</li>
</ol>
<blockquote>
<p>下面的方法都是合理的，请试着分析表达式的含义（<code>val</code> 的类型是 <code>int*</code>）：</p>
<p><code>val[4]</code>、<code>val</code>、<code>val + 1</code>、<code>&amp;val[2]</code>、<code>*(val + 1)</code>、<code>*val + 1</code>;</p>
<p>提示：对于指针类型 <code>T*</code> 的增、减运算而言，单位 1 会是 <strong><code>sizeof(T)</code></strong>，也就是说，对这个指针增加 1，那么指针的值实际增加 <code>sizeof(T)</code>；</p>
<p><strong>补充 C/C++ 基础-1</strong>：指针和数组变量的区别之一是，改变数组变量 <code>val</code> 不是正确的，因为 <code>val</code> 是指针常量；</p>
</blockquote>
<hr>
<p>现在看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZLEN 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> zip_dig[ZLEN];</span><br><span class="line"></span><br><span class="line">zip_dig cmu = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">zip_dig mit = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">zip_dig ucb = &#123; <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一些编程建议：① 不要将常数随便写死在程序的各个角落，这被称为 magic number，不但不利于阅读，也不利于维护；② 对于 C/C++ 中复杂的数据类型的定义，建议使用 <code>typedef</code> 关键字，这样可以提升可读性；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_digit</span><span class="params">(zip_dig z, <span class="type">int</span> digit)</span> &#123; <span class="keyword">return</span> z[digit]; &#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_digit:</span><br><span class="line">    movl	(%rdi, %rsi, 4), %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>由于数组标识符也是指针，因此传入的方式和之前的相同。上面的指令含义是找到地址为 <code>%rdi + 4 * %rsi</code> 的 memory 引用，并将这里的值赋给 <code>%rax</code> 的 low-order 32-bit（<code>%eax</code>）;</p>
<p>4  就是编译器自己加上的对于 <code>int</code> 类型大小的缩放因子。</p>
<p>再来一段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zincr</span><span class="params">(zig_dig z)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ZLEN; i++)</span><br><span class="line">        z[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zincr:</span><br><span class="line">    movl	$0, %eax</span><br><span class="line">    jmp		.L3</span><br><span class="line">.L4</span><br><span class="line">    addl	$1, (%rdi, %rax, 4)</span><br><span class="line">    addq	$1, %rax</span><br><span class="line">.L3</span><br><span class="line">    cmpq	$4, %rax</span><br><span class="line">    jbe		.L4</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure>
<p>这里汇编代码对 for 循环的处理是转化为 while 循环并采用 “jump to middle” translation；</p>
<p>首先初始化部分将 <code>%rax</code> 置零作为存放 i 的寄存器，接着跳至 <code>.L3</code> 判断部分；</p>
<p><code>.L3</code> 判断部分将 <code>%rax</code>（i）和 4 比较，只有 unsigned <code>i ≤ 4</code>（<code>CF | ZF</code>）时才进入 <code>.L4</code> 循环；</p>
<p>在 <code>.L4</code> 循环中，先将地址为 <code>%rdi + 4 * %rax</code> 的 memory 引用处的数据加 1，并且将 <code>%rax</code> 中的数据加 1（<code>i++</code>）；</p>
<hr>
<blockquote>
<p><strong>补充 C/C++ 基础-2</strong>：为了掌握 C/C++ 数组的核心思想，你必须能够理解以下的声明的含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">int</span> A1[<span class="number">3</span>];        <span class="comment">// 一个长度为 3 的整型数组</span></span><br><span class="line"><span class="type">int</span> *A2[<span class="number">3</span>];        <span class="comment">// 一个长度为 3 的整型指针 构成的数组</span></span><br><span class="line"><span class="type">int</span> (*A3)[<span class="number">3</span>];    <span class="comment">// 一个指向 长度为 3 的整型数组 的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：C/C++ 阅读类型声明的关键是从内向外读，这条道理不仅适用于上面的 <code>int (*A3)[3]</code>，还适用于函数指针等复杂类型的阅读</strong>。例如 <code>int**(*)(int*, int)</code> 是指向参数表为 <code>(int*, int)</code>、返回值类型为 <code>int**</code> 的函数的指针。</p>
<p><strong>补充 C/C++ 基础-3</strong>：数组变量和指针的区别之一是，在声明数组时程序不仅会为数组标识符这个指针来分配空间，而且会为数组中的所有元素分配空间；但指针只会为自身分配空间。这就导致<strong>二者调用 <code>sizeof</code> 的大小是不同的</strong>；例如 <code>sizeof(A3) == 8</code>，<code>sizeof(*A3) == 12</code>，<code>sizeof(A3) == 4</code>;</p>
<p>⚠ 另外，如果想判断什么类型的指针取 <code>*</code> 后会导致野指针 / 空指针引用错误，应该想想<strong>在一开始声明的时候，程序有没有为其自动分配空间</strong>。例如上面的例子，如果使用 <code>*A3</code> 则可能出现空指针引用错误，但 <code>*A2</code> 就不会。</p>
</blockquote>
<p>为什么要 “补充 C/C++ 基础 1~3” ？<strong>因为只有清楚了解程序的源码表示的含义，才能去关注、正确认识编译后的代码</strong>。</p>
<h4 id="6-1-2-Array-Access-Two-Dimension-Array"><a href="#6-1-2-Array-Access-Two-Dimension-Array" class="headerlink" title="6.1.2 Array Access: Two Dimension Array"></a>6.1.2 Array Access: Two Dimension Array</h4><blockquote>
<p>⚠ 本节讨论的 array 规模全部是 <code>constexpr</code>（编译前确定）；</p>
</blockquote>
<p>这个时候我们再看二维数组的真实含义。</p>
<p>⚠ <strong>注意：由上面的讨论可知，一共有 2 类二维数组，尽管源码的使用上是一样的，但汇编层面完全不同！！！</strong></p>
<ul>
<li><p>Nested Array</p>
<ul>
<li><p>在 C/C++ 中，一种二维数组的声明语法为 <code>T A[R][C];</code>，其实是 <code>T[C] A[R];</code> 的另一种写法，表示 <strong><code>A</code> 是一个包含 <code>R</code> 个元素的数组，其元素是包含 <code>C</code> 个元素的数组</strong>。</p>
</li>
<li><p>这种数组被称为 <strong>Nested array</strong>，特点是二维数组中<strong>所有元素的空间在声明时都被自动分配了，更重要的是，它们是连续的</strong>。</p>
</li>
<li><p>另一个需要关注的点是，<strong>Nested array 是 “Row-Major” 的，即行优先，第一个索引应该指定行，并且分配空间、存储时，连续的部分也是行，又称 Row Vectors</strong>。</p>
</li>
<li><p>Nested Array 的每个行向量 <code>A[i]</code> 开始的地址是 <strong><code>A + i * C * sizeof(T)</code></strong>，每个元素 <code>A[i][j]</code> 的地址是 <strong><code>A + (i * C + j) * sizeof(T)</code></strong>（由 <code>A + i * C * sizeof(T) + j * sizeof(T)</code> 化简得来）;</p>
</li>
</ul>
</li>
</ul>
<p><img src="imgs/nested_array.png" height="200px"></p>
<ul>
<li>Multi-Level Array<ul>
<li>另一种二维数组的声明方式是 <code>T* A[R];</code>，随后在初始化中（在栈中）/ new 上（在堆中）数组的各个元素。</li>
<li>这种数组称为 <strong>Multi-level array</strong>，在声明时，<strong>仅为每个一级元素（<code>int*</code>）进行了空间分配</strong>。</li>
<li><strong>事实上，这种声明的数组每一行的存储位置可以不是连在一起的，甚至每一行的元素可以不同</strong>！因此每个元素的地址计算应该<strong>取决于 <code>A</code> 中每个元素的值</strong>！没法通过标识符 <code>A</code> 直接取得。</li>
</ul>
</li>
</ul>
<p><img src="imgs/multi_level_array.png" height="200px"></p>
<hr>
<p>我们继续利用之前 <code>zip_dig</code> 的例子，我们分别声明两种类型的二维数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PCOUNT 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UCOUNT 3</span></span><br><span class="line"></span><br><span class="line">zip_dig pgh[PCOUNT] = &#123;                    <span class="comment">// Nested array</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> *univ[UCOUNT] = &#123; mit, cmu, ucb &#125;;    <span class="comment">// Multi-level array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里分别是使用它们的两个函数</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">get_pgh_zip</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="keyword">return</span> pgh[index]; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_univ_digit</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> digit)</span> &#123; <span class="keyword">return</span> univ[index][digit]; &#125;</span><br></pre></td></tr></table></figure>
<p>这时对应函数的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">get_pgh_zip:</span><br><span class="line">    leaq	(%rdi,%rdi,4), %rax</span><br><span class="line">    leaq	pgh(,%rax,4), %rax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">get_univ_digit:</span><br><span class="line">    salq	$2, %rsi</span><br><span class="line">    addq	univ(,%rdi,8), %rsi</span><br><span class="line">    movl	(%rsi), %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>注意到，这里使用的 <code>pgh</code>、 <code>univ</code> 是全局变量，不存储在栈中，意味着在汇编代码中<strong>可以直接使用变量名称来表示全局变量</strong>。</p>
<p>注意！这时候两个数组的索引方式就有差别了。</p>
<p>对于使用 Nested array 的函数 <code>get_pgh_zip</code> 而言，第一步是相当于进行算术计算 <code>%rax = 5 * %rdi</code>，第二步还是相当于算术计算 <code>%rax = pgh + 4 * %rax</code>。这两步的真实含义是：<code>%rax = pgh + sizeof(int) * 5 * index</code>，这里的 5 就是之前提到的<strong>每列列宽</strong>；</p>
<p>它可以表示：<code>&amp;Memory[pgh + 5 * sizeof(int) * index]</code>，取得其中的指针；</p>
<p>对于使用 Multi-level array 的函数 <code>get_univ_digit</code> 而言，<strong>事情完全不一样！</strong></p>
<p>第一步将 <code>%rsi</code> 的值（<code>digit</code>）乘以 4，没什么好说的；</p>
<p>第二步注意，这里不是 <code>leaq</code> 而是 <code>addq</code>，说明这里先取得 <code>univ + 8 * %rdi</code> 中的值，并把它看作地址，找到 memory 中该地址对应的引用值。最后把 <code>%rsi</code> 加上引用值;</p>
<p>这两步<strong>没法写出真实含义的表达式，因为涉及 memory 取值。但可以表示为</strong>：</p>
<p><code>Memory[Memory[univ + sizeof(int*) * index] + sizeof(int) * digit]</code>;</p>
<p>最后 <code>get_univ_digit</code> 才把计算好的地址使用 Simple Memory Addressing Mode 取出值，并赋给 <code>%rax</code>（<code>%eax</code>）;</p>
<hr>
<p>对比上面两种二维数组的汇编操作，这说明了不同的结构决定了不同的计算方法。前者只需要对<strong>数组标识符</strong>和<strong>索引</strong>进行算术计算，就能得到地址；而后者必须先由<strong>数组标识符</strong>和<strong>行参数</strong>找到一级元素内容，然后用<strong>一级元素内容</strong>和<strong>列索引</strong>才能定位具体的元素位置。</p>
<h4 id="6-1-3-Array-Access-M-×-N-Matrix"><a href="#6-1-3-Array-Access-M-×-N-Matrix" class="headerlink" title="6.1.3 Array Access: M × N Matrix"></a>6.1.3 Array Access: M × N Matrix</h4><ul>
<li>对于恒定（constexpr）规模、声明时已分配内存的矩阵而言，就是上一节说的 Nested array；</li>
<li>对于作为参数传入的 Nested array（未知规模，但空间连续），则必须进行乘法计算（开销较大）结合其他算术计算得出位置；</li>
</ul>
<p>总而言之，访问数组的思路就是之前说的 Multi-level array 和 Nested array 两类。其他情况可以同理思考。</p>
<h3 id="6-2-Structures-in-Assembly"><a href="#6-2-Structures-in-Assembly" class="headerlink" title="6.2 Structures in Assembly"></a>6.2 Structures in Assembly</h3><h4 id="6-2-1-Structure-Representation"><a href="#6-2-1-Structure-Representation" class="headerlink" title="6.2.1 Structure Representation"></a>6.2.1 Structure Representation</h4><p>关于结构体的存储和表示，有下面的 3 条简单规则：</p>
<ul>
<li><p>结构体本身在内存中的表示是<strong>连续的</strong>，并且 “big enough to hold all of the fields”；</p>
</li>
<li><p>结构体中各个字段在内存中的排布顺序<strong>严格</strong>按照源码中的<strong>声明顺序</strong>；</p>
</li>
<li><p><strong>编译器来决定所有字段存储的空间和字节偏移、对齐情况</strong>（相对结构体地址的位置）；</p>
<blockquote>
<p>整个过程对汇编层面透明，汇编代码是看不出来这里定义了一个结构体的，只能看到一系列变量排列在内存上；</p>
</blockquote>
</li>
</ul>
<h4 id="6-2-2-Structure-Access-Generate-Pointer-to-Structure-Member"><a href="#6-2-2-Structure-Access-Generate-Pointer-to-Structure-Member" class="headerlink" title="6.2.2 Structure Access: Generate Pointer to Structure Member"></a>6.2.2 Structure Access: Generate Pointer to Structure Member</h4><p>其实通过 structure representation 就能略知如何用指针找各个字段了。这里以一个例子说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rec</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">get_ap</span><span class="params">(<span class="keyword">struct</span> rec *r, <span class="type">size_t</span> idx)</span> &#123; <span class="keyword">return</span> &amp;r-&gt;a[idx]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_val</span><span class="params">(<span class="keyword">struct</span> rec *r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (r) &#123;</span><br><span class="line">        <span class="type">int</span> i = r-&gt;i;</span><br><span class="line">        r-&gt;a[i] = val;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get_ap</code> 函数对应的汇编代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_ap:</span><br><span class="line">    leaq	(%rdi,%rsi,4), %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>这里的操作表明了 <code>%rax = %rdi + 4 * %rsi</code>，即 <code>%rax = r + sizeof(int) * idx</code>。这说明了<code>struct rec</code> 中的第一个成员就位于 <code>rec</code> 空间的开头，并按正常的整型数组进行排列。</p>
<p>但是对于另外一个函数 <code>set_val</code> 而言：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set_val:</span><br><span class="line">.L11:</span><br><span class="line">    movslq	16(%rdi), %rax</span><br><span class="line">    movl	%esi, (%rdi,%rax,4)</span><br><span class="line">    movq	24(%rdi), %rdi</span><br><span class="line">    testq	%rdi, %rdi</span><br><span class="line">    jne		.L11</span><br></pre></td></tr></table></figure>
<p>第一步可以认为 <code>movslq</code> 就是 <strong>取 <code>Src</code> 的 32-bit 数据，0 扩展为 64-bit 数据后放入 <code>Dst</code></strong>，作用是将地址为 <code>%rdi + 16</code>（即 <code>r + 4 * sizeof(int)</code>）的 memory 引用的值覆盖到 <code>%rax</code> 上去。完成了源码的 <code>int i = r-&gt;i;</code> 这一步；</p>
<p>从这里可以看出，编译器将 <code>int a[4]</code>、<code>int i</code> 和 <code>struct rec* next</code> 这三个成员排在一起，<strong>是没有间隔的，如下图。但某些场合下编译器指定可能会出现间隔</strong>，这是是为了<strong>内存对齐的原因，下面马上会讨论结构体的内存对齐</strong>。</p>
<p><img src="imgs/struct_example.png" height="150px"></p>
<p>第二步 <code>movl</code> 将 <code>%esi</code>（<code>%rsi</code> 的 low-order 32-bit）的值赋给地址为 <code>%rdi + 4 * %rax</code>（即 <code>r + sizeof(int) * i</code>）的 memory 引用，完成了 <code>r-&gt;a[i] = val;</code> 这步；</p>
<p>第三部让 <code>%rdi</code> 的值变为 “地址为 <code>%rdi + 24</code> 的 memory 引用的值”，相当于 <code>r = r-&gt;next;</code></p>
<p>剩下的部分就是完成 while 循环的判断任务。</p>
<p><strong>上面的例子中，还有一个重要的问题没有阐释——结构体的内存对齐问题</strong>。</p>
<p>那么为什么要对结构体进行内存对齐？又是如何进行内存对齐的？再来看另外一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<p>对于这个结构体而言，如果每个成员紧紧挨在一起，那么在内存中的排布是这样的：</p>
<p><img src="imgs/struct_example2_unaligned.png" height="60px"></p>
<p>但实际上编译器会在其中插入一些空数据块，让内存排布变成这样：</p>
<p><img src="imgs/struct_example2_aligned.png" height="125px"></p>
<p>这就是因为，x86-64（和其他很多架构的机器）规定了结构体内存对齐的规则。为什么要有这样的规则？这其实是 <strong>硬件效率问题</strong>。</p>
<p>对于当今大多数机器的内存系统而言，实际从硬件内存中一次读取的数据量大约 64 bytes，本身称为一个读取的<strong>数据块</strong>，大小取决于机器硬件中的各种宽度。所以，如果因为没有对齐的地址，而导致读取时特定的数据跨越了两个数据块的边界，那么很可能会导致操作系统需要采取一些额外的步骤来处理这种情况，从而大大降低处理效率。</p>
<p>除了上面的这种原因，还有种原因是，如果这些未对齐的结构体组成了数组，那么想要<strong>索引</strong>这些数组的计算将会非常复杂，<strong>使用起来也非常不方便</strong>。</p>
<p>鉴于以上原因，很多架构都采用了这种内存对齐的思路。其实内存对齐除了在结构体这里，我们之前在 “跳表” 的汇编代码（4.4）中也看到了内存对齐的指令（<code>.align</code>）；</p>
<blockquote>
<p>如果某种编译器编译程序时，没有安排内存对齐，那么在 x86-64 的架构上运行是没有问题的，因为微架构中有解决这个问题的方法（重新读入），速度可能会慢一点；但有些架构完全不能运行，会抛出内存错误的异常。</p>
</blockquote>
<p>那么如何对齐能够解决上面的问题？x86-64 架构提出了以下<strong>内存对齐的原则</strong>：</p>
<ol>
<li><p><strong>Primitive data type requires K bytes, so its address must be multiple of K</strong>;</p>
<p>如果原始数据类型的大小是 K bytes，那么它（所对应成员）的起始地址必须能被 K 整除。</p>
</li>
<li><p><strong>Overall structure length must be multiple of $\max\limits_{i}{K_i}$, where $\max\limits_{i}{K_i}$ is the largest alignment requirement in this structure</strong> (otherwise “external padding”).</p>
<p>结构体总体的大小必须是该结构体中最大的数据类型大小的整数倍。（完成上一条后，编译器可以通过在结构体尾部追加空数据块来实现）</p>
</li>
</ol>
<p>例如：</p>
<ul>
<li>对于 1 byte 的数据类型（如 <code>char</code>），这种类型成员在内存上的排布没有限制，哪里有空往哪搬；</li>
<li>对于 2 bytes 的数据类型（如 <code>short</code>），这种类型成员要求起始地址必须能被 2 整除（即 LSB of address must be $0_2$）；</li>
<li>对于 4 bytes 的数据类型（如 <code>int, float</code>），要求起始地址必须能被 4 整除（即 lowest 2 bits of address must be $00_2$）；</li>
<li>对于 8 bytes 的数据类型（如 <code>double, long, x86-64下各种 pointer</code>），要求起始地址必须能够被 8 整除（即 lowest 3 bits of address must be $000_2$）；</li>
<li>对于 16 bytes 的数据类型（如 <code>x86-64 gcc/Linux下的 long double</code>），要求起始地址必须能被 16 整除（即 lowest 4 bits of address must be $0000_2$）；</li>
</ul>
<p>再例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<p>这个结构体的内存对齐方式如下：</p>
<p><img src="imgs/struct_example2_aligned_tail.png" height="125px"></p>
<p>因为其中含有 <code>double</code> 数据类型，所以总体大小必须是 8 的整数倍；又因为整体长度不是 8 的整数倍（<code>p + 17</code>），所以尾部补充空数据块到 <code>p + 24</code>;</p>
<h4 id="6-2-3-Accessing-Arrays-of-Structure"><a href="#6-2-3-Accessing-Arrays-of-Structure" class="headerlink" title="6.2.3 Accessing Arrays of Structure"></a>6.2.3 Accessing Arrays of Structure</h4><p>更进一步地，如果有一个结构体数组，并且结构体是被正确定义的，那么编译器就能很容易地确定各个结构体的大小、成员位置和数组的大小，从而在其他使用到的场合为其正确地分配空间、索引成员；</p>
<p>来看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> i;</span><br><span class="line">    <span class="type">float</span> v;</span><br><span class="line">    <span class="type">short</span> j;</span><br><span class="line">&#125; a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>如果你使用 <code>sizeof(S3)</code> 的话，你会发现值是 12，说明编译器生成的空数据块的大小也计算在内。具体的结构如下图所示，在 <code>i</code> 和 <code>v</code> 成员间、结构体尾部都有分配空数据块：</p>
<p><img src="imgs/struct_example3.png" height="125px"></p>
<p>还有使用它的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="title function_">get_j</span><span class="params">(<span class="type">int</span> idx)</span> &#123; <span class="keyword">return</span> a[idx].j; &#125;</span><br></pre></td></tr></table></figure>
<p>对照 <code>S3</code> 结构体的内存分布图，你就会发现这个函数的汇编代码也没有那么难以理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get_j:</span><br><span class="line">    leaq	(%rdi,%rdi,2), %rax</span><br><span class="line">    movzwl	a+8(,%rax,4), %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>我们来解释上面例子的汇编行为：</p>
<p>第一步是相当于算术运算 <code>%rax = 3 * %rdi</code>;</p>
<p>第二步是 <code>%rax = a + 8 + 4 * %rax</code>，实质上是 <code>%rax = a + 8 + 4 * 3 * idx</code>，对照上面的内存分布情况可以理解，<code>a + 8</code> 就指向 <code>a[0].j</code>，而后面加 <code>4 * 3 * idx</code> 则是因为每个结构体占位 <code>4 * 3 bytes = 12 bytes</code> 的空间，这样就对应着 <code>a[idx].j</code> 的位置了。</p>
<blockquote>
<p><strong>这里的总结一下遇到的乱七八糟的 <code>movXXX</code> 指令</strong>。</p>
<p><code>movzbl</code> 和 <code>movsbl</code> 的作用相近，都是<strong>将 8-bit 扩展到 32-bit</strong>。但前者是 <strong>zero extension</strong> 零扩展（根据 <strong>extension conclusion</strong>，针对 unsigned 的扩展），而后者是 <strong>sign extension</strong> 符号扩展（针对 signed 的扩展）；</p>
<p> <code>movzwl</code> 和 <code>movswl</code> 很像，前者是 16-bit（1 word）<strong>零扩展移动</strong>至 32-bit，后者是 16-bit <strong>符号扩展移动</strong>至 32-bit（long）；</p>
<p><code>movzlq</code> 和 <code>movslq</code> 同理。</p>
<p><strong>如果你会看指令名称的含义的话，上面的内容就无需记忆了</strong>：在 <code>mov&lt;A&gt;&lt;B&gt;&lt;C&gt; &lt;Src&gt;, &lt;Dst&gt;</code> 中，</p>
<p>A 表示扩展种类，可以是 <code>z</code>（zero extension）、<code>s</code>（sign extension）；</p>
<p>B 表示扩展源（<code>Src</code>）的大小，可以是 <code>b</code>（1 byte，8 bits），<code>w</code>（word，1 字，16 bits）、<code>l</code>（2 字，32 bits）、<code>q</code>（quadword，4 字，64 bits）；</p>
<p>C 表示扩展目标（<code>Dst</code>）的大小，可以取的值和 B 相同，但两者不能同时取一个值。</p>
<p>除此以外就是普通的 <code>mov&lt;X&gt;</code>（没有扩展功能）和条件移动 <code>mov&lt;cond&gt;</code> 指令了。 </p>
</blockquote>
<h4 id="6-2-4-Saving-Space"><a href="#6-2-4-Saving-Space" class="headerlink" title="6.2.4 Saving Space"></a>6.2.4 Saving Space</h4><p>现在，我们了解了结构体的基本排布和表示，也知道了结构体内存对齐的规则。有些同学可能会发现，诶，因为结构体各成员在内存中的排布顺序严格按照源码声明的顺序，那么<strong>结构体中各个成员排布的不同，是不是会导致结构体最终所占的大小不同？</strong></p>
<p>答案是肯定的，所以，有必要讨论一下 “按什么方式声明结构体，能够让指定结构体的空间占用最小” 这个问题。下面是结论：</p>
<ul>
<li><p><strong>将占用空间较大的数据类型声明在前面</strong>。</p>
<blockquote>
<p>这种贪心算法是有效的。因为所有数据类型的大小只有 1、2、4、8、16 bytes，全是 2 的整数次幂，在数学上来说能够严格证明。</p>
</blockquote>
</li>
</ul>
<p>下面的例子中，<code>S4</code> 和 <code>S5</code> 相比，<code>S5</code> 更节省空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125; *p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S5</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-Floating-Point-in-Assembly"><a href="#6-3-Floating-Point-in-Assembly" class="headerlink" title="6.3 Floating Point in Assembly"></a>6.3 Floating Point in Assembly</h3><h4 id="6-3-1-History-amp-Background-for-Representing-FP"><a href="#6-3-1-History-amp-Background-for-Representing-FP" class="headerlink" title="6.3.1 History &amp; Background for Representing FP"></a>6.3.1 History &amp; Background for Representing FP</h4><p>在 x86 架构中，floating point 的表示有着比较深的历史。</p>
<p><strong>x87 FP</strong></p>
<p>很早之前，Intel 的 8087 芯片和 IEEE 浮点数标准一起诞生，安装在 8086 处理器上，是第一个能够完全处理 IEEE 浮点数运算的集成单元。但是编程模型从现在看来比较糟糕，所以 CSAPP 第三版就把这方面的内容完全移除了（expunged）；</p>
<p><strong>MMX FP</strong></p>
<p>1997 年 Intel 公司推出了多媒体扩展指令集 MMX，它包括57条多媒体指令。MMX 指令主要用于增强 CPU 对多媒体信息的处理能力，提高 CPU 处理 3D 图形、视频和音频信息的能力。</p>
<p><strong>SSE FP</strong></p>
<p>随着人们日益增长的精神文化的需要，例如核显渲染的浮点数运算需求增长，人们迫切需要并行计算的手段，于是一个全新的思路就出现了——<strong>SIMD（Single Instruction Multiple Data），单指令多数据</strong>，和整型寄存器不一样，我们在浮点数寄存器上多放几个数同时计算，那么运算速度不就上去了？</p>
<p>紧接着，一套新的指令拓展集 SSE（Streaming SIMD Extension）被设计出来，兼容 MMX 指令，配合一套浮点寄存器，来完成标量浮点数，或者单指令多数据的浮点数的计算。</p>
<p><strong>AVX FP</strong></p>
<p>在2010 年 AVX 将之前浮点运算数据的宽度从 128 bits 的扩展到 256-bits。同时新的 CPU 架构下数据传输速度也获得了提升。AVX 指令集在 SIMD 计算性能增强的同时也沿用了的 MMX/SSE 指令集。不过和 MMX/SSE 的不同点在于，增强的 AVX 指令在指令的格式上也发生了很大的变化。x86 (IA-32/Intel 64) 架构的基础上增加了prefix，所以实现了新的命令，也使更加复杂的指令得以实现，从而提升了 x86 CPU的性能。</p>
<blockquote>
<p>AVX 并不是 x86 CPU 的扩展指令集，可以实现更高的效率，同时和 CPU 硬件兼容性也更好，在 SSE 指令的基础上 AVX 也使 SSE 指令接口更加易用；</p>
</blockquote>
<h4 id="6-3-2-Programming-with-SSE3"><a href="#6-3-2-Programming-with-SSE3" class="headerlink" title="6.3.2 Programming with SSE3"></a>6.3.2 Programming with SSE3</h4><p>在 SSE 第 3 版中，指明了 x86 架构有 <strong>16 个 floating point registers</strong>（和之前的 16 个 integer registers 完全不同），每个 floating point register 空间大小 <strong>16 bytes</strong>（大概是 integer register 的两倍大）；</p>
<p>它们又叫 <code>XMM</code> Register（名称的历史渊源比较多，此处省略，感兴趣看 CSAPP 原书 P294），所以这些寄存器的名称：<code>%xmm0 ~ %xmm15</code>;</p>
<p>其中，按照<strong>指令使用的不同</strong>，每个 <code>XMM</code> Register 都可以存储：</p>
<ul>
<li>16 个 1 byte 整型（<code>char</code>）；</li>
<li>或 8 个 2 bytes 整型（<code>short</code>）；</li>
<li>或 4 个 4 bytes 整型（<code>int</code>）；</li>
<li>或 4 个 单精度浮点数（<code>float</code>）；</li>
<li>或 2 个双精度浮点数（<code>double</code>）；</li>
<li>或 1 个 单精度浮点数（<code>float</code>，没存满，有剩余空间）；</li>
<li>或 1 个 双精度浮点数（<code>double</code>，没存满，有剩余空间）；</li>
</ul>
<p><img src="imgs/xmm_registers.png" height="400px"></p>
<p>这意味着浮点数寄存器<strong>既可以处理整型，又可以处理浮点数类型</strong>；<strong>既可以处理一个数的运算，又可以多个数并行运算</strong>。</p>
<p>这种一次计算单个数的指令被称为 <strong>Scalar Operations（标量运算）</strong>，一次并行计算多个数的指令被称为 <strong>SIMD Operations（单指令多数据运算）</strong>。</p>
<p>具体的命令长什么样子的呢？还是经典的 <strong>名称+后缀</strong> 命名方法，所以如果你能读懂命名方法，那就不用记忆太多的指令了。</p>
<p>对于浮点数运算而言，主要有 4 种指令：<code>addss</code>、<code>addps</code>、<code>addsd</code>、<code>addpd</code>；</p>
<p>会读的同学已经懂了，就是 <code>&lt;OP_NAME&gt;&lt;OP_TYPE&gt;&lt;DATA_TYPE&gt;</code> 的组合嘛！</p>
<ul>
<li><p><code>OP_NAME</code> 就是运算的名称，这里是 <code>add</code> 加法运算（显然还有 <code>mov</code> 移动、<code>sub</code> 减法等等）；</p>
</li>
<li><p><code>OP_TYPE</code> 是运算类型，上面提到的 <code>s</code> 代表 Scalar 标量运算（一次算一个数），<code>p</code> 代表 Packed 多数据运算（一次算一组数）；</p>
<blockquote>
<p>特别地，如果强调是对齐的数据，那么 <code>OP_TYPE</code> 还有前缀 <code>a</code> 代表 aligned，例如：<code>movapd</code>;</p>
</blockquote>
</li>
<li><p><code>DATA_TYPE</code> 是运算的数据类型，<code>s</code> 代表 Single precision floating point，<code>d</code> 代码 Double precision floating point；</p>
</li>
</ul>
<p>所以举个例子，<code>addpd</code> 就是双精度浮点数的 SIMD 加法运算指令嘛！</p>
<p>运算的参数和之前的整型寄存器运算一样，<code>&lt;Src&gt;, &lt;Dst&gt;</code>;</p>
<p>运算的内存表示就是如图：</p>
<p><img src="imgs/sse_fp_addition.png" height="400px"></p>
<p>除此以外，FP 还有 <strong>2 点</strong>需要注意：</p>
<ol>
<li><p>FP Registers 的 Saving Conventions：</p>
<ul>
<li><p><code>%xmm0 ~ %xmm15</code> 就是依次传递参数的 register，参数多于 15 个浮点数类型，则和多出 6 个的整型参数一样，会放到栈帧中去；</p>
</li>
<li><p><code>%xmm0</code> 也是约定<strong>返回浮点数值</strong>的存放位置；</p>
</li>
<li><p><strong>所有的 <code>XMM</code> Register 都是 Caller-Saved Register</strong>，没有 Callee-Saved Register；</p>
</li>
</ul>
</li>
<li><p>FP 的还有众多的命令等待认识，不过最重要的还是之前提到的<strong>记忆指令的命名方法</strong>，理解了命名方法就能更少地记忆指令；</p>
<ul>
<li><p>FP 数据比较指令：<code>ucomiss</code>（Unordered Compare Scalar Single Precision Floating Point）、<code>ucomisd</code>（Unordered Compare Scalar Double Precision Floating Point）；</p>
<blockquote>
<p>和 <code>cmpq</code> 大致相似，会设置 condition codes，包括 <code>CF/ZF/PF</code>；</p>
</blockquote>
</li>
<li><p>FP 常数使用：这里 <code>$</code> 符号<strong>只能</strong>接整型常量，所以如果要使用浮点数常量，需要 <code>xorpd %xmm0 %xmm0</code> 等类似指令运算出 / 从内存中读入才能使用。</p>
</li>
</ul>
</li>
</ol>
<p>事实上，之前我们一直担心的 “<strong>浮点数如何通过寄存器传递参数</strong>” 等问题，只要有了命令就非常简单，操作方法几乎和 integer registers 一样。下面是一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">fadd</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">dadd</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">dincr</span><span class="params">(<span class="type">double</span>* p, <span class="type">double</span> v)</span> &#123;</span><br><span class="line">    <span class="type">double</span> x = *p;</span><br><span class="line">    *p = x + v;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fadd:</span><br><span class="line">    addss	%xmm1, %xmm0</span><br><span class="line">    ret</span><br><span class="line">dadd:</span><br><span class="line">    addsd	%xmm1, %xmm0</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">dincr:</span><br><span class="line">    movapd	%xmm0, %xmm1</span><br><span class="line">    movsd	(%rdi), %xmm0</span><br><span class="line">    addsd	%xmm0, %xmm1</span><br><span class="line">    movsd	%xmm1, (%rdi)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>函数 <code>fadd</code> 和 <code>dadd</code> 没有什么好说的，主要看 <code>dincr</code>：</p>
<p>第一步 <code>movapd</code> 见名知意，Move Aligned Packed Double Precision Floating Point，成组移动双精度浮点数，参数类型和其他的 <code>mov</code> 指令相同；</p>
<p>这里的 <code>%xmm0</code> 里装的是<strong>函数第二参数 <code>double v</code></strong>（第一参数是指针整型，所以放在 <code>%rdi</code>），移动到了未使用到的 <code>%xmm1</code> 寄存器中；</p>
<p>第二步 <code>movsd</code>，Move Scalar Double Precision Floating Point，移动标量双精度浮点数，将地址为 <code>%rdi</code> 的 memory 引用值（也就是 <code>p</code> 指向的内存 double 数据）赋给 <code>%xmm0</code>（x），并且最终将作为返回值返回；</p>
<p>第三步就是标量将 <code>%xmm0</code> 的数据（x）加到 <code>%xmm1</code> 的值（v）上，完成了 <code>*p = x + v;</code></p>
<p>第四步就将计算结果 <code>%xmm1</code> 的值（t）标量移动到地址为 <code>%rdi</code> 的 memory 引用区域中（p 所指向的区域），完成 <code>*p = t;</code></p>
<h4 id="6-3-3-AVX-Instructions"><a href="#6-3-3-AVX-Instructions" class="headerlink" title="6.3.3 AVX Instructions"></a>6.3.3 AVX Instructions</h4><p>AVX 新增的指令可以说是非常地多，使用方法、命名规范和之前所有的命令不同的是，加了前缀 “v”，其他都相近。</p>
<ul>
<li><p><code>mov</code> 类命令：<code>vmovss/vmovsd/vmovps/vmovpd/vmovass/...</code>;</p>
<blockquote>
<p>命名规范见前面的叙述；</p>
</blockquote>
</li>
<li><p><code>cvt</code> （convert）类命令，一般实现浮点和整型之间的转换：</p>
<ul>
<li><p><code>vcvttss2si/vcvttsd2si/vcvttss2si/vcvttss2siq/vcvttsd2siq</code>;</p>
</li>
<li><p><code>vcvtsi2ss/vcvtsi2sd/vcvtsi2ssq/vcvtsi2sdq</code>;</p>
<blockquote>
<p>有点长，但是命名规范清楚：</p>
<p><code>vcvt</code> 是 <code>cvt</code> 类命令的前缀；</p>
<p>中间有 <code>t</code> 表示 truncation，进行截断（<strong>出现在浮点向整型的转换中</strong>）；</p>
<p>后缀 <code>XX2YY</code> 是 从 <code>XX</code> 类型转换到 <code>YY</code> 类型的意思，<code>XX/YY</code> 可取的值有：<code>ss/sd/ssq/sdq/si(integer, 32-bit)/siq(integer, 64-bit)</code>;</p>
</blockquote>
</li>
</ul>
</li>
<li><p>arithmetic 类命令：<code>vaddss/vsubss/vmulss/vdivss/vmaxss/vminss/vxorps/xandps/sqrtss/...</code></p>
<blockquote>
<p>新的指令名：<code>sqrt</code>，之前 integer registers 的指令所没有的；</p>
</blockquote>
</li>
<li><p>比较类命令（和 SSE3 相同）：<code>ucomiss/ucomisd</code>;</p>
</li>
</ul>
<h3 id="6-4-Summary-for-Chapter-6"><a href="#6-4-Summary-for-Chapter-6" class="headerlink" title="6.4 Summary for Chapter 6"></a>6.4 Summary for Chapter 6</h3><p>本章的内容密度也相当之大，有必要总结回顾一下本章所学的全部内容。</p>
<p>本章的一开始我们复习了 C/C++ 中指针和数组的准确定义，从分析<strong>二者的使用方式</strong>和 <strong>2 种区别（常量性、空间分配的自主性）</strong>方面入手，从较深的角度考虑了 <strong>数组标识符的含义和多种声明方式</strong>，以及这些声明方式如何阅读、如何理解。这样我们就能准确地回答：不同标识符的 <code>sizeof</code> 判断问题、空指针/野指针的出现问题，也有助于我们理解在汇编中数组的呈现方式。</p>
<p>在了解数组在 C/C++ 中的地位后，我们先讨论了普通一维数组的<strong>内存分布</strong>和<strong>访问方式</strong>。</p>
<p>无论是存在于程序栈帧中的一维数组（<code>T[]</code> 声明法），还是存在于堆中的一维数组（<code>T*</code> 声明法），它们的排布都是位于<strong>连续的</strong>、 <strong><code>L * sizeof(T)</code> 大小的</strong>内存空间中，数组标识符可以看作指向开头位置的指针常量。因此，对于一维数组的汇编访问就是看作<strong>一串连续的同类型数据排布</strong>，按照 Simple Memory Address Mode 进行索引即可。</p>
<p>而后我们从恒定的（<code>constexpr</code>，编译前确定）数组规模出发，进一步学习二维数组的情况。</p>
<p>由于 C/C++ 的语言特性，二维数组的两种声明方式（Nested array <code>T[][]</code> 和 Multi-level array <code>T*[]</code>），<strong>尽管二者的使用方法几乎一致</strong>，但所对应的<strong>内存排布方式 和 汇编操作性质完全不同</strong>。</p>
<p>前者在声明时，所有元素的空间都会被自动分配至栈中，并且以 “Row major” 的方式<strong>连续排布</strong>；而后者则仅有一级元素（<code>T*</code>）被自动分配空间，并且指向的每一行数组之间的存储位置<strong>可以不连续</strong>。</p>
<p>内存结构上的差异就决定了这两种数组在汇编代码访问方式的不一致。访问 Nested Array 的某个元素时，只需要对<strong>数组标识符</strong>和<strong>索引</strong>进行算术计算（<code>&amp;A[i][j] == A + i * C * sizeof(T) + j * sizeof(T)</code>）就能得到相应地址；而访问 Multi-Level Array 时却必须先由<strong>数组标识符</strong>和<strong>行参数</strong>找到一级元素内容，然后用<strong>一级元素内容</strong>和<strong>列索引</strong>才能定位具体的元素位置。</p>
<p>讨论完固定规模二维数组的内存排布和访问方式后，我们将眼光拓展到可变规模的 Nested Array（即 M × N Matrix）上。按照所掌握的知识，我们也可以从普通固定规模的两种二维数组出发，类比出访问这种可变规模二维数组的汇编实现。</p>
<p>聚合结构除了数组，还有一个重要的部分——结构体，也是 C++ 中类的前身。</p>
<p>结构体在内存中的表示遵循简单的 3 条原则：<strong>连续排布</strong>、<strong>严格按声明顺序</strong>、<strong>编译器决定字段内存对齐</strong>。</p>
<p>在观察几个例子后，我们发现在有些情况下，结构体的每个程序紧密排布，访问方式与数组相近；但有些情况编译器会在成员间插入空白数据段（也计入数据结构的总大小）。于是我们分析了<strong>结构体内存对齐</strong>的两点<strong>现实原因</strong>和两点<strong>对齐的原则</strong>（“起始地址整除原则”、“最大倍数原则”）；我们根据这些原则能够正确认识结构体在内存中的组织情况，并以此对程序进行存储方面（<strong>如何声明结构体成员，以获得最小的占用空间</strong>）和性能方面的改进。</p>
<p>对于结构体所组成的数组，则可以看成完整的结构体所为一个基本元素所组成的数组，一级索引方式与普通数组相同，二级索引方式和单一结构体相同，在汇编层面<strong>共同构成结构体数组针对单个元素、单个成员的索引表达式</strong>。</p>
<p>虽然聚合结构对于汇编层面来说完全透明，但以上建立的规则和约定让底层的一个个指令共同实现了聚合结构的高级功能。</p>
<p>除了阐明聚合结构在汇编层面的实现之外，我们还整理了非常多的 <code>mov</code> 指令。从中我们归纳出了<strong>指令命名的规则</strong>，这个规则适用于其他几乎所有指令，可以帮助我们<strong>少记忆指令</strong>、<strong>在遇到没有见过的指令时能够推测出其大致作用</strong>。</p>
<p>最后，我们提及了浮点数指令的历史，及其在内存中的整体存储、汇编层面的使用。</p>
<p>在 SSE3 指令拓展集中，16 个 <code>XMM</code> Register 既可以存储标量数据，又可以存储成组的数据；既可以存放各种数据类型的整型数据，又可以存放各种数据类型的浮点型数据。在此基础上，我们接触到了两类运算方法（Scalar Op 和 SIMD Op）及其对应的指令，使用方法和整型的情况相近。</p>
<p>此外，关于 FP Register 的 Saving Conventions、比较指令和常数的使用，进一步加深了我们对浮点数的汇编操作的理解。</p>
<p>另外介绍的 AVX Instructions 有助于帮助我们理解某些浮点数操作的汇编代码的含义。</p>
<h2 id="Chapter-7-Machine-Level-Programming-Ⅴ-Advanced"><a href="#Chapter-7-Machine-Level-Programming-Ⅴ-Advanced" class="headerlink" title="Chapter 7. Machine Level Programming Ⅴ - Advanced"></a>Chapter 7. Machine Level Programming Ⅴ - Advanced</h2><h3 id="7-1-Memory-Layout-in-x86-64"><a href="#7-1-Memory-Layout-in-x86-64" class="headerlink" title="7.1 Memory Layout in x86-64"></a>7.1 Memory Layout in x86-64</h3><p>内存（虚拟内存）本质上就是一个很大的字节数组。而之前观察 memory 的角度要么是从汇编 Simple Memory Address Mode 的访问角度，要么是从 x86-64 的程序栈的角度来看内存的。本节将从<strong>更为宏观、更为完整</strong>的角度介绍 <strong>x86-64 Linux 的完整内存布局</strong>。</p>
<p>首先，从 64 位系统的特征上来说，x86-64 系统上的程序所能访问的内存空间应该是 $2^{64}$ bits（大约 $16\times10^{18}$ bits），但由于当前存储技术的种种限制，当前的硬件限制我们只能使用最高 47 位的地址（大约 $128\times10^{12}$ bits，128 TB）。</p>
<p>在这个限制下，我们看一看系统提供给程序的运行内存的结构：</p>
<p><img src="imgs/memory.png" height="400px"></p>
<ul>
<li><p>最底层的 128 MB 是栈区（<code>0x0000 7FFF FFFF 0000</code>，即 $2^{47}-4096$ 至 <code>0x0000 7FFF F800 0000</code>），实际 x86-64 栈的<strong>实际最大大小</strong>在 8 MB 左右，向低地址增长。栈的结构参考 5.2 和 5.3。</p>
<blockquote>
<ol>
<li>一般操作系统为了保护栈数据不被攻击，一般在栈的前后放置随机数据区域；如果没有这些保护数据，那么栈就放在内存最底层（<code>0x0000 7FFF FFFF 0000</code> 的位置）.</li>
<li>如果运行中的程序<strong>试图访问超过这里 8 MB 限制范围的地址</strong>，或者<strong>访问的地址还没有通过 virtual memory allocator 的分配</strong>时，系统会抛出 segmentation fault，并强制结束程序；</li>
</ol>
</blockquote>
</li>
<li><p>在从最下面看起，位置 <code>0x40 0000</code> 开始向高地址位置，有一段 text 区（找不到这个名字的来源），是程序存放运行机器代码的位置（信息从可执行文件读入）。<strong>我们将在 “链接” 一章详细讨论这个部分的具体内容</strong>。数据只读（Read Only）；</p>
</li>
<li><p>再下面一段是 Data 区，<strong>是用来存放程序开始时就分配的数据</strong>。存放的内容包括：</p>
<ul>
<li>静态分配的数据；</li>
<li>程序中的全局变量、静态值、字符串常量；</li>
<li>……</li>
</ul>
</li>
<li><p>再下面一段是堆。堆和栈的分配方式<strong>完全不同</strong>，堆空间在运行时按代码<strong>动态分配</strong>（dynamically allocated，一般由 malloc()、calloc()、new 等方法创建，free()、delete 等方法销毁），最有趣的是，堆的分配位置和生长方向不固定；下面将由例子来说明；</p>
</li>
<li><p>堆下面有一段空间的位置是外部库（Shared Libraries），存储的是类似 malloc()、printf() 的库函数。它们一开始是<strong>作为动态链接库存储于磁盘上</strong>，在程序加载时，它们也载入内存的这个位置，供程序使用，称为<strong>动态加载</strong>。<strong>我们将在 “动态链接” 这一部分详细讨论具体内容</strong>。</p>
</li>
</ul>
<p>我们运行下面的程序进行测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> big_array[<span class="number">8388608L</span>];        <span class="comment">/* 1&lt;&lt;24, 16 MB */</span></span><br><span class="line"><span class="type">char</span> huge_array[<span class="number">1073741824L</span>];    <span class="comment">/* 1&lt;&lt;31, 2 GB */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">useless</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *phuge1, *psmall2, *phuge3, *psmall4;</span><br><span class="line">    <span class="type">int</span> local = <span class="number">0</span>;</span><br><span class="line">    phuge1 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">28</span>);    <span class="comment">/* 256 MB */</span></span><br><span class="line">    psmall2 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">8</span>);    <span class="comment">/* 256 B */</span></span><br><span class="line">    phuge3 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">32</span>);    <span class="comment">/* 4 GB */</span></span><br><span class="line">    psmall4 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">8</span>);    <span class="comment">/* 256 B */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 GDB 调试可以发现，在 Linux 内存中，<code>big_array</code>、<code>huge_array</code> 和 <code>global</code> 这三个全局变量分布在大致 <code>0x600000</code> 的低地址的位置，位于 <strong>Data 区</strong>；局部变量 <code>local</code> 在地址 <code>0x7FFE 0000 0000</code> 的大致位置，位于<strong>内存栈区</strong>；对于函数 <code>main()</code> 和 <code>useless()</code> 而言，它们的地址在 <code>0x400000</code> 附近，位于 <strong>Text 区</strong>；</p>
<p>而对于 <code>phuge1</code>、<code>psmall2</code>、<code>phuge3</code>、<code>psmall4</code> 来说略有特殊。它们是使用 <code>malloc</code> 分配在堆里的，但是它们的位置差别较大：<strong>占用空间很大的 <code>phuge1</code> 和 <code>phuge3</code> 位于更靠近栈区的堆中，而占用空间较小的 <code>psmall2</code> 和 <code>psmall4</code> 则位于更靠近 Data 区的堆中</strong>。大致情况如下图：</p>
<p><img src="imgs/memory_pos.png" height="350px"></p>
<p>奇怪的是，<code>malloc</code> 大数据量的堆在上方和 shared libraries 紧贴，向低地址增长；而普通数据的堆在 Data 区的下方向高地址增长。可以预见，当两块 heap 碰头的时候，<code>malloc</code> 会返回空指针。</p>
<p>这个规律目前还没有解释，等到以后的章节慢慢了解。</p>
<h3 id="7-2-Buffer-Overflow"><a href="#7-2-Buffer-Overflow" class="headerlink" title="7.2 Buffer Overflow"></a>7.2 Buffer Overflow</h3><p>在 Chapter 0-0.3 的越界实验中，我们就讨论过内存缓冲区溢出的问题。当时造成的后果是结构体中的其他成员的数据被修改。本节会详细解释内存缓冲区溢出的各个方面的影响和应当措施。</p>
<h4 id="7-2-1-The-Vulnerability"><a href="#7-2-1-The-Vulnerability" class="headerlink" title="7.2.1 The Vulnerability"></a>7.2.1 The Vulnerability</h4><p>继续以 0.3 中的实验代码为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125; <span class="type">struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">struct_t</span> s;    <span class="comment">/* volatile 关键字表示易变量，警告编译器不进行任何优化 */</span></span><br><span class="line">    s.d = <span class="number">3.14</span>;</span><br><span class="line">    s.a[i] = <span class="number">1073741824</span>;    <span class="comment">/* Possibly out of bounds */</span></span><br><span class="line">    <span class="keyword">return</span> s.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>i</code> 参数取值大于 1 时会污染 <code>s.d</code> 的值，当 <code>i</code> 参数大于 6 时，可能会出现 segmentation fault；</p>
<p>但内存缓冲区溢出的问题不仅仅是内部开发者编写错误这一个小问题。相反，这是一个<strong>大问题</strong>。</p>
<ul>
<li>Buffer overflow 的出现：when <strong>exceeding</strong> the memory <strong>size</strong> allocated for <strong>an array</strong>;</li>
<li>Buffer overflow 为什么是大问题：它是<strong>头号的技术层面上的安全漏洞</strong>（#1 technical cause of security vulnerabilities）；</li>
<li>Buffer overflow 产生的原因列举：<ul>
<li>Unchecked lengths on string inputs（外部因素：<strong>不对输入字符串的长度和内容进行合法性检查</strong>）；</li>
<li>Illegal indexing / referring / modifying memory（内部因素：<strong>不对访问 memory 的参数进行检查</strong>）；</li>
</ul>
</li>
</ul>
<p>下面举一个实际点的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get string from stdin */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = getchar();        <span class="comment">/* get a single char from stdin */</span></span><br><span class="line">    <span class="type">char</span> *p = dest;            <span class="comment">/* the pointer p points to the same addr as dest */</span></span><br><span class="line">    <span class="keyword">while</span> (c != EOF &amp;&amp; c != <span class="string">&#x27;\n&#x27;</span>) &#123;    <span class="comment">/* reading stdin until new line or EOF */</span></span><br><span class="line">        *p++ = c;            <span class="comment">/* add the value of p directly. (A problem ?) */</span></span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;                <span class="comment">/* the dest char must ends with &#x27;\0&#x27; */</span></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Echo Line */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>];            <span class="comment">/* Way too small */</span></span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">call_echo</span><span class="params">()</span> &#123; echo(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a string: &quot;</span>);</span><br><span class="line">    call_echo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>gets</code> 函数不管 <code>dest</code> 的实际被分配的大小，直接进行输入，很可能在内存中出现 Buffer Overflow。于是总结出导致 Buffer Overflow 的罪魁祸首之一：<strong>存储字符串，却不检查边界情况的库函数</strong>；C 库里有很多这样不检查边界的库函数：<code>scanf</code>、<code>fscanf</code>、<code>sscanf</code>（等 <code>scanf</code> 家族，尤其是使用 <code>%s</code> 格式化参量）、<code>strcpy</code>、<code>strcat</code>（等字符串移动家族）……</p>
<p>现在看看运行这个程序会出现什么问题（如果自己想试试的话，记得<strong>关闭 gcc 栈保护 <code>-fno-stack-protector</code></strong>）：</p>
<ul>
<li>如果输入短一点的字符串（长度小于 24 个），那么程序很可能会正常运行；</li>
<li>如果输入很长的字符串，那么程序会报告 segmentation fault；</li>
</ul>
<p>那么，都是缓冲区溢出，为什么短一点的看起来不会出问题呢？这时候就需要从汇编代码解释了。我们生成上面的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">    sub		$0x18, %rsp</span><br><span class="line">    mov		%rsp, %rdi</span><br><span class="line">    callq	400680 &lt;gets&gt;</span><br><span class="line">    mov		%rsp, %rdi</span><br><span class="line">    callq	400520 &lt;puts@plt&gt;</span><br><span class="line">    add		$0x18, %rsp</span><br><span class="line">    retq</span><br><span class="line">call_echo:</span><br><span class="line">    sub		$0x8, %rsp</span><br><span class="line">    mov		$0x0, %eax</span><br><span class="line">    callq	4006cf &lt;echo&gt;</span><br><span class="line">    add		$0x8, %rsp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>
<p>首先观察，一开始系统为 <code>echo</code> 函数的栈帧分配了 24 bytes（<code>0x18</code>）的空间，<strong>因此，如果输入的输出加入超过了所有的栈空间，进入没有被分配的 memory 时，就会报告 segmentation fault</strong>。</p>
<p>所以，（<strong>当没有使用 <code>gcc</code> 栈保护机制时</strong>）安全问题通常就出现在 “溢出内容超过了原来分配的位置，但是没有超过栈的总体空间” 这种情况下。这时系统不会抛出 segmentation fault，<strong>栈中数据只能任由输入者篡改</strong>。</p>
<p>再来看看内存对应的情况：</p>
<p><img src="imgs/buffer_overflow_example1.png" height="260px"><img src="imgs/buffer_overflow_example1_2.png" height="260px"><img src="imgs/buffer_overflow_example1_3.png" height="260px"></p>
<p>如上左图，当 <code>char buf[4]</code> 声明后，在程序初始化时，编译器为<code>echo</code> 预留了 24 bytes 的空间；<code>echo</code> 栈帧的最顶层存放的是局部变量 <code>buf</code> 数组对应的空间大小是 4 bytes，一切都很正常。</p>
<p>如上中图，我们不妨假设 <code>call_echo</code> 在 return address 里存放的地址是 <code>0x4006C3</code>（<code>echo</code> 运行结束后应该返回的地址）；如果输入字符串内容超过了 <code>buf</code> 能承受的 3 bytes，则会出现 buffer overflow，如图，数据覆盖了 <code>buf</code> 下方的 20 bytes 其他区域的数据，但因为这个例子中，恰好那个区域没有存放其他数据，所以表面上程序没问题；</p>
<blockquote>
<p>如果那 20 bytes 空间放了其他数据，那么会被篡改；</p>
</blockquote>
<p>但，如果输入长度更长，那么字符串序列会溢出的更长，如上右图所示，污染了 Return address 的话，问题就出现了。当 echo 想要结束时，会因为 Return address 被修改而转移到一个不知道什么的地方，很可能导致 segmentation fault；<strong>更严重的，如果恰好跳转到一个奇怪的函数中，并且还能运行、没报错，那么坏了，程序不会按预期的方式继续运行，这样的 bug 非常隐晦</strong>；</p>
<h4 id="7-2-2-Stack-Smashing-Attacks"><a href="#7-2-2-Stack-Smashing-Attacks" class="headerlink" title="7.2.2 Stack Smashing Attacks"></a>7.2.2 Stack Smashing Attacks</h4><p>在上面说到的情况下，如果攻击者想要函数在输入后，跳转到不应该执行的、但是程序里面有的函数中，会让程序出现一些意料之外的行为。</p>
<blockquote>
<p>例如登录场景：攻击者想要输入一串内容，让软件跳转到登陆成功的函数中;</p>
</blockquote>
<p>这种攻击被称为<strong>缓冲区溢出攻击（stack smashing attack）</strong>，这种攻击就是利用了技术人员不注意输入检查，而导致的缓冲区溢出的问题。</p>
<p>实现这种攻击的原理比较简单，就是<strong>输入无意义的填充字符（padding）让输入的内容 buffer overflow，并且在末尾设置一个想要跳转到的函数的地址，并且只需让末尾的地址恰好覆盖 return address</strong> 就行。</p>
<p>如下图所示，正常的流程是 <code>P()</code> 调用 <code>Q()</code>，<code>P</code> 函数在 return address 中写的是 <code>A</code>，也就是 <code>P</code> 函数中调用 <code>Q</code> 的下一行；但由于 <code>Q()</code> 中的 <code>gets(buf)</code> 有溢出风险，在攻击者输入 <code>padding</code> 字符 + <code>S</code> 地址组合的字符串后，<code>gets</code> 函数将缓冲区数据覆盖了，如下图右，return address 被改成了 <code>S</code> 的地址。这样在 <code>Q()</code> 执行结束后，会跳转到 <code>S()</code> 函数中，而不是原来的 <code>P()</code> 中：</p>
<p><img src="imgs/stack_smashing_attack.png" height="300px"></p>
<p>做法很简单，但是编译时要关闭 <code>gcc</code> 的栈保护机制（<code>-fno-stack-protector</code>）。现在大多数 C/C++ 编译器都有这项功能，利用栈随机化、“金丝雀” 检查等技术，打乱栈空间的实际排布、利用栈两端的 “金丝雀” 侦测栈溢出，发现就立即终止程序，让攻击难以进行。<strong>（后面会详细讨论）</strong></p>
<ol>
<li>找到有导致缓冲区溢出风险的函数（像之前提到的 <code>scanf</code> 家族、<code>str</code> 家族），并且技术人员没有为这些函数的输入进行检查；</li>
<li>反汇编找到想要跳转的函数（也就是上面的 <code>S</code>）的地址；</li>
<li>反汇编找到汇编代码中编译器为 <code>Q</code> 函数分配的栈帧大小，计算出 <code>pad</code> 填充字符的大小，使得 <code>S</code> 地址恰好覆盖 return address；</li>
<li>将 padding 数据 + <code>S</code> 的地址（<strong>注意大小端序的问题</strong>）转换为字符串，运行程序并输入即可。</li>
</ol>
<h4 id="7-2-3-Code-Injection-Attacks"><a href="#7-2-3-Code-Injection-Attacks" class="headerlink" title="7.2.3 Code Injection Attacks"></a>7.2.3 Code Injection Attacks</h4><p>也是在上面说到的情况下，如果有攻击者刻意如此设置，让缓冲区溢出到 return address，并且恰好让 return address 指向攻击者事先设计好的 exploit code 中，那么程序就会执行攻击者设计的函数，从而给计算机造成威胁。</p>
<p>这种攻击被称为 <strong>代码注入攻击</strong>，思路和上面的 stack smashing attack 如出一辙，只不过攻击者不满足于执行软件内的其他函数了，他要执行的是自己嵌入的函数，危害可能更大。</p>
<p>实现攻击的原理就是，<strong>攻击者输入编码有 exploit code + padding string + pointer to exploit code 的内容</strong>，让读入程序执行结束后跳转到攻击者刚刚输入的 exploit code 中执行，如下图所示：</p>
<p><img src="imgs/code_injection_attack.png" height="300"></p>
<blockquote>
<p>更聪明的攻击者会在运行完 exploit code 后修复溢出的缓冲区，并且跳转到原来的函数，伪装成没有被攻击的假象。</p>
<p>知识拓展：计算机病毒和计算机蠕虫的区别</p>
<ul>
<li>蠕虫：可以通过某种隐蔽的方式，进行自我复制、独立地在机器上运行预期代码；</li>
<li>病毒：可以通过某种隐蔽的方式，进行自我复制，攻击一个程序，并改变这个程序的行为，但自己不能独立存在。</li>
</ul>
</blockquote>
<h4 id="7-2-4-The-Protection-in-personal-respective"><a href="#7-2-4-The-Protection-in-personal-respective" class="headerlink" title="7.2.4 The Protection: in personal respective"></a>7.2.4 The Protection: in personal respective</h4><p><strong>Avoid overflow vulnerabilities when writing a program</strong></p>
<blockquote>
<p>例如之前的 <code>gets</code> 函数有风险，可以换成 <code>fget</code> 指定读入缓冲区的大小；</p>
<p><code>strcpy</code> 换成 <code>strncpy</code>、<code>scanf</code> 使用时不轻易用 <code>%s</code> 格式，而使用 <code>%ns</code>，或者直接用 <code>fgets</code>;</p>
</blockquote>
<p><strong>Avoid overflow vulnerabilities in system-level</strong></p>
<ul>
<li><p>栈随机化（stack randomization），是更宏观策略 ASLR (Address Space Layout Randomization, 地址空间布局随机化) 的一部分；</p>
<blockquote>
<p>这样的话，每次运行程序，栈和堆上变量的位置偏移 offset 会随机产生，攻击者就没法找到准确的攻击代码的插入位置了；</p>
</blockquote>
</li>
<li><p>Non-executable code segments：在栈中规定禁止执行代码，只有在 Text 区 / Shared Libraries 区才能执行；</p>
<blockquote>
<p>以前人们在内存中每一个 chunk 前放置 3 个 flags，类似 Unix 上的 可读、可写、可执行三个权限，对于栈区的空间中 flags 应该是可读、可写、不可执行；</p>
</blockquote>
</li>
<li><p>Stack Canaries（栈 “金丝雀”），在栈中的 buffer 两端设置特殊的随机值（称为 “金丝雀”，早期人们下矿就用金丝雀的生死来判断矿井中瓦斯是否超标），在写入 buffer 的函数退出前检查这些值。如果这些值被改变了，那么说明 buffer overflow，可能会出问题，就立即终止接下来程序的执行；<strong>现在这个技术已经在 <code>gcc</code> 中成为默认的编译选项：<code>-fstack-protector</code></strong>;</p>
</li>
</ul>
<blockquote>
<p>这里简单从汇编层面分析一下 “金丝雀” 是如何实现的。</p>
<p>还是以上面的 <code>echo</code> 函数为例，这时我们编译就删除 <code>-fno-stack-protector</code> 这个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">    sub		$0x18, %rsp</span><br><span class="line">    mov		%fs:0x28, %rax</span><br><span class="line">    mov		%rax, 0x8(%rsp)</span><br><span class="line">    xor		%eax, %eax</span><br><span class="line">    mov		%rsp, %rdi</span><br><span class="line">    callq	4006e0 &lt;gets&gt;</span><br><span class="line">    mov		%rsp, rdi</span><br><span class="line">    callq	400570 &lt;puts@plt&gt;</span><br><span class="line">    mov		0x8(%rsp), %rax</span><br><span class="line">    xor		%fs:0x28, %rax</span><br><span class="line">    je		400768 &lt;echo+0x39&gt;</span><br><span class="line">    callq	400580 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">    add		$0x18, %rsp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>
<p>我们一步步分析：</p>
<p>第一步给 <code>echo</code> 栈帧分配了 24 bytes 的空间，非常简单；</p>
<p>第二步用到了一个没见过的东西 <code>%fs:0x28</code>，实际上 <code>%fs</code> 是一个<strong>为原始 8086 芯片设计的一个寄存器</strong>，由于向下兼容，所以它现在还能<strong>以某种方式</strong>使用，但是基本很少用，甚至已经找不到它的文档了……只需要知道 <code>%fs:0x28</code> 是内存的某个隐匿部位，相当于随机数 “金丝雀”，我们将这个数放到 <code>%rax</code>，第三步再将这个值放到 <code>%rsp</code> 所指向的下面 8 bytes 的位置——这就意味着 <code>buf</code> 只要溢出 8 bytes 就会被察觉；</p>
<blockquote>
<p>⚠ <code>%fs</code> <strong>不是</strong>真正可用的寄存器，它是 segment register（段寄存器）in protected mode，其中的值是指向某个有效位置的指针。所以只能用如此方式（<code>%fs:0x28</code>）取出值，它（<code>%fs:0x28</code>）实际上是内存中某个位置的引用，<strong>并且每次运行，这个值都会改变</strong>。</p>
<p>这也回答了为什么不能直接将 <code>%fs:0x28</code> 的值 <code>mov</code> 到内存中。</p>
<p>——以上摘自 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://stackoverflow.com/questions/10325713/why-does-this-memory-address-fs0x28-fs0x28-have-a-random-value">StackOverflow</a>;</p>
</blockquote>
<p>第四步将 <code>%rax</code> 清空为 0，然后执行普通的 <code>echo</code> 操作，省略；</p>
<p>直到倒数第 5 步（第 10 行），系统将 “金丝雀” 取出到 <code>%rax</code> 并和原值 <code>%fs:0x28</code> 比较，如果不等就是缓冲区溢出，立即调用 <code>__stack_chk_fail</code> 报错终止执行；</p>
</blockquote>
<h4 id="7-2-5-【New】Return-Oriented-Programming-Attacks"><a href="#7-2-5-【New】Return-Oriented-Programming-Attacks" class="headerlink" title="7.2.5 【New】Return-Oriented Programming Attacks"></a>7.2.5 【New】Return-Oriented Programming Attacks</h4><p>在上面的许多防护措施出来后，给攻击者带来很多难题：</p>
<ul>
<li>栈随机化使得他们很难预测缓冲区的位置；</li>
<li>栈区无法执行代码，使得他们插入代码也没用；</li>
</ul>
<p>于是攻击者有了一些替代性的措施，<strong>能够突破上面的两个障碍（栈随机化 + 禁止栈中执行代码）</strong>：</p>
<ul>
<li>利用已存在的代码，例如标准库中的代码。因为它们不在栈区和堆区，位置不会轻易变动；</li>
<li>利用 x86 架构中 <code>ret</code> 指令的特殊行为，来执行代码；</li>
</ul>
<p>下面介绍这种攻击的原理。</p>
<p>这种攻击利用的部件称之为 <strong>gadget</strong>，通常是各个函数的<strong>包含 <code>ret</code> 指令的最后几行或者一段</strong>，如下：</p>
<p><img src="imgs/gadget_1.png" height="225px"><img src="imgs/gadget_2.png" height="225px"></p>
<p>这些毫无关系的函数的汇编代码最后几行甚至几个片段总会包含一些指令，例如将某个寄存器的值加多少、将某个寄存器的值移动到哪。它们紧接着 <code>ret</code> 指令（对应汇编码 <code>0xC3</code>）。这就意味这我们可以<strong>收集这些 gadget 的地址，按照我们的需求依此排列这些 gadget，通过输入将这些地址溢出到栈里，让栈充当程序计数器的角色，反复执行 <code>gadget1</code> -&gt; <code>ret</code> -&gt; 执行 <code>gadget2</code> -&gt; <code>ret</code> -&gt; …，越过了上面两个限制，将所有 gadget 连在一起，最终让程序段达到我们的目的</strong>，如下图：</p>
<p><img src="imgs/ROP_execution.png" height="300px"></p>
<p><strong>可以说是顶级的 “断章取义”！</strong></p>
<p>不过有两个缺点：</p>
<ul>
<li>这种攻击仍然不能突破 “金丝雀” 的防护，因为这毕竟是栈溢出；</li>
<li>各个 gadget 需要大量地查找，比较费精力。有些人会在标准库中积累一些 gadget；</li>
</ul>
<h3 id="7-3-Union-in-Memory"><a href="#7-3-Union-in-Memory" class="headerlink" title="7.3 Union in Memory"></a>7.3 Union in Memory</h3><p>C 中有一个特殊的数据结构：<code>Union</code>，声明方式与 <code>struct</code> 几乎一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125; *up;</span><br></pre></td></tr></table></figure>
<p>但用法完全不一样。<strong><code>Union</code> 的所有域共用一块最大的域大小的内存</strong>，这就导致在改动一个域的数据时，其他域的值也会改变；所以 <strong><code>Union</code> 一次只能使用一个域，或者用在通过别名引用不同的内存的场合</strong>。<code>Union</code> 用的地方少，但在单片机、掩码的领域用的比较多。</p>
<p>还有就是之前的 Data Lab 中用于 <strong>bit-level representation 的 float 和真实的 float 之间相互转换</strong>，不会改变 bit pattern，也能用到 <code>Union</code>（当然不是解题答案，因为不允许）；</p>
<p><strong>使用 <code>Union</code> 也要特别注意端序的问题</strong>！！！</p>
<h4 id="7-3-1-Union-Allocation"><a href="#7-3-1-Union-Allocation" class="headerlink" title="7.3.1 Union Allocation"></a>7.3.1 Union Allocation</h4><p>对联合体（<code>Union</code>）而言，内存分配比较简单，只需要判断所有域中占用空间最大的那一个来分配就行。例如上面的例子就是 8 bytes；</p>
<h4 id="7-3-2-Summary-of-Compound-Types-in-C"><a href="#7-3-2-Summary-of-Compound-Types-in-C" class="headerlink" title="7.3.2 Summary of Compound Types in C"></a>7.3.2 Summary of Compound Types in C</h4><ul>
<li>Arrays<ul>
<li>Contiguous allocation of memory（1-D &amp; Nested Array）；</li>
<li>Aligned to satisfy every element’s alignment requirement；</li>
<li>Pointer to first element；</li>
<li>No bounds checking；</li>
</ul>
</li>
<li>Structures<ul>
<li>Allocate bytes in order declared；</li>
<li>Pad in middle and at end to satisfy alignment；</li>
</ul>
</li>
<li>Unions<ul>
<li>Overlay declarations；</li>
<li>Way to circumvent type system；</li>
</ul>
</li>
</ul>
<h3 id="7-4-Summary-of-Chapter-7"><a href="#7-4-Summary-of-Chapter-7" class="headerlink" title="7.4 Summary of Chapter 7"></a>7.4 Summary of Chapter 7</h3><p>本章的内容相较于之前两章较少，但是也很重要。</p>
<p>本章开始我们就从<strong>更全面的</strong>角度来观察 <strong>x86-64 Linux 的完整内存布局</strong>，我们落脚于实际，考虑到实际能够使用的内存不过 128 T 左右，建立了一个 <code>0x0000 7FFF FFFF F000 ~ 0x40 0000</code> 的内存图谱。</p>
<p>在这个图谱中，自高地址至低地址分布栈区（stack）、外部库区（shared libraries）、堆区（heap）、数据区（data）、机读代码区（text）；</p>
<p>这些位置都由 virtual memory allocator 进行管理，如果访问了超出整个内存的范围，或是不在已分配的空间内，系统都会抛出 segmentation fault；</p>
<p>我们了解到，栈区<strong>位于内存的最高地址处</strong>，内部存放见 5.2 和 5.3，实际大小约 8 MB（x86-64），地址在 $2^{47}-4096$ 至 <code>0x0000 7FFF F800 0000</code> 中，前后可能含有因为 ASLR 或 “金丝雀” 产生的<strong>随机数据</strong>，总共约 128 MB；</p>
<p>在栈区的上方（这里把较低地址的称为 “上方”）是 Shared Libaries 区，<strong>它存放重要的外部库函数</strong>，是动态加载至内存上的部分。如果堆中有较大的数据，可能部分的堆区会与外部库区毗邻，并且向低地址生长。</p>
<p>跨过中间大片的未分配的区域向低地址看，就是堆区，<strong>由代码函数手段分配和释放的区域，存放大部分由手动分配的普通变量</strong>，向高地址生长；</p>
<p>在堆区的上方，是数据区，<strong>存放程序开始就分配的数据</strong>，包括静态数据、全局变量、字符串常量等；</p>
<p>再向上就是内存的地址最低处，机读代码区，开始于 <code>0x40 0000</code>，具体内容会在 “链接” 一章中讨论。</p>
<p>以上区域，text / data / shared libraries 区域运行时可读可执行，heap / stack 区域可读可写不可执行。</p>
<p>介绍完 x86-64 Linux 整体的内存分布，我们进一步讨论了 Buffer overflow 的原理和危害性。</p>
<p>Buffer overflow 出现的<strong>内部原因</strong>是对数组或其他 memory 不恰当的读写访问，<strong>外部原因</strong>是不对输入字符串进行长度和内容的合法性检验。</p>
<p>最后 Buffer Overflow 或者触发 segmentation fault 导致程序崩溃，或者恰好进行了不恰当的跳转，让程序行为不可预测、难以调试，或者被不法分子利用后，危害计算机系统的正常使用。</p>
<p>从一个使用容易内存缓冲区溢出的 <code>gets</code> 的函数 <code>echo</code> 出发，我们讨论了输入不同长度的字符串对缓冲区溢出的影响，进而推出了 <strong>3 种</strong>利用缓冲区溢出特点的攻击行为（Stack Smashing Attacks、Code Injection Attacks、Return-Oriented Programming Attacks）。它们共同点是，都利用了溢出影响 return address 的特性，使得程序跳转到攻击者指定的位置执行；但从具体操作上各有差异。</p>
<p>之后我们介绍了<strong>两类、四种</strong>针对内存缓冲区溢出攻击的防护办法。两类中的一类是<strong>从开发者自己做起</strong>，尽量避免使用有缓冲区溢出风险的函数；另一类是<strong>从系统层面做起</strong>，主要分为 3 种，分别是<strong>栈随机化</strong>、<strong>栈区禁止执行代码</strong> 和 <strong>栈 “金丝雀”</strong>。这 3 种防护思路能够轻松应对 Stack Smashing Attacks 和 Code Injection Attacks，但只有 栈 “金丝雀” 能够防护 Return-Oriented Attacks。</p>
<p>我们仔细分析了 栈 “金丝雀” 的汇编层面的实现，更加确信这个至今没有被破解的防护方法的强大。</p>
<p>本章最后，我们接触到了 <code>Union</code> 联合体在内存中的分配和表示，反复强调使用 <code>Union</code> 时<strong>一定要注意端序的问题</strong>，以免出现字节序方面的编程错误。</p>
<blockquote>
<p>第 3 ~ 7 章已结束，请完成 Bomb Lab &amp; Attack Lab！</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://sjtuxhw.asia">SJTU-XHW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sjtuxhw.asia/2023/09/17/CSAPP-Notes-Chapter1-3/">https://sjtuxhw.asia/2023/09/17/CSAPP-Notes-Chapter1-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sjtuxhw.asia" target="_blank">SJTU-XHW's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/myBlog/tags/GNU/">GNU</a><a class="post-meta__tags" href="/myBlog/tags/CSAPP/">CSAPP</a><a class="post-meta__tags" href="/myBlog/tags/ICS/">ICS</a><a class="post-meta__tags" href="/myBlog/tags/Programming/">Programming</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/myBlog/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/myBlog/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/myBlog/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/myBlog/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/myBlog/2023/10/01/%E3%80%8A%E5%8F%AA%E6%9C%89%E6%88%91%E4%B8%8D%E5%9C%A8%E7%9A%84%E5%9F%8E%E5%B8%82%E3%80%8B%E7%95%AA%E8%AF%84/" title="《只有我不在的城市》番评"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/anime_bokumachi.jpg" onerror="onerror=null;src='/myBlog/img/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《只有我不在的城市》番评</div></div></a></div><div class="next-post pull-right"><a href="/myBlog/2023/09/05/MC-Forge%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" title="MC-Forge开发笔记（一）"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/minecraft1.png" onerror="onerror=null;src='/myBlog/img/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MC-Forge开发笔记（一）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/myBlog/2023/04/28/GNU-Tutor/" title="GNU-Tutor"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/GNU-Tutor.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="title">GNU-Tutor</div></div></a></div><div><a href="/myBlog/2023/07/21/CMake-%E8%BF%9B%E9%98%B6/" title="CMake 进阶"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/cmake.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">CMake 进阶</div></div></a></div><div><a href="/myBlog/2023/04/28/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Git学习笔记"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/git.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="title">Git学习笔记</div></div></a></div><div><a href="/myBlog/2023/04/28/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java 学习笔记（1）"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/java1.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="title">Java 学习笔记（1）</div></div></a></div><div><a href="/myBlog/2023/06/18/Matlab-%E5%A4%8D%E4%B9%A0/" title="Matlab 复习"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/matlab.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-18</div><div class="title">Matlab 复习</div></div></a></div><div><a href="/myBlog/2023/06/28/SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/" title="SQL学习笔记-第一部分"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/sql-1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-28</div><div class="title">SQL学习笔记-第一部分</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/myBlog/img/favicon.ico" onerror="this.onerror=null;this.src='/myBlog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SJTU-XHW</div><div class="author-info__description">A blog to document learning and life</div></div><div class="card-info-data site-data is-center"><a href="/myBlog/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/myBlog/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/myBlog/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://sjtuxhw.asia/myBlog/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! ‎|•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-0-Intro"><span class="toc-text">Chapter 0. Intro</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-Ints-are-not-Integers-Floats-are-not-Reals"><span class="toc-text">0.1 Ints are not Integers, Floats are not Reals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-2-Learn-Assembly-but-never-write-it"><span class="toc-text">0.2 Learn Assembly but never write it</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-3-Memory-Matters-Unbounded"><span class="toc-text">0.3 Memory Matters: Unbounded</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-4-There%E2%80%99s-more-to-performance-than-asymtotic-complexity"><span class="toc-text">0.4 There’s more to performance than asymtotic complexity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-5-Computers-do-more-than-execute-programs"><span class="toc-text">0.5 Computers do more than execute programs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-1-Bits-Bytes-and-Integers"><span class="toc-text">Chapter 1. Bits, Bytes and Integers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Everythings-is-bits"><span class="toc-text">1.1 Everythings is bits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Boolean-Algebra"><span class="toc-text">1.2 Boolean Algebra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%8E%9F%E7%A0%81-true-form-%E3%80%81%E5%8F%8D%E7%A0%81-1%E2%80%99s-complement-%E3%80%81%E8%A1%A5%E7%A0%81-2%E2%80%99s-complement"><span class="toc-text">1.3 原码(true form)、反码(1’s complement)、补码(2’s complement)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Operations"><span class="toc-text">1.4 Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-Miscellaneous"><span class="toc-text">1.5 Miscellaneous</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-Puzzles"><span class="toc-text">1.6 Puzzles</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-2-Floating-Point"><span class="toc-text">Chapter 2. Floating Point</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Fractional-Binary-Numbers"><span class="toc-text">2.1 Fractional Binary Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-The-Operations-for-Floating-Point"><span class="toc-text">2.2 The Operations for Floating Point</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Floating-Point-in-C"><span class="toc-text">2.3 Floating Point in C</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Puzzles"><span class="toc-text">2.4 Puzzles</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-Machine-Level-Programming-%E2%85%A0-Basics"><span class="toc-text">Chapter 3. Machine-Level Programming Ⅰ- Basics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-History-of-Intel-processors-and-architectures"><span class="toc-text">3.1 History of Intel processors and architectures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-C-Assembly-Machine-code"><span class="toc-text">3.2 C, Assembly, Machine code</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-Definitions"><span class="toc-text">3.2.1 Definitions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-Assembly-Machine-Code-View"><span class="toc-text">3.2.2 Assembly&#x2F;Machine Code View</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-Assembly-Characteristics-Data-Types"><span class="toc-text">3.2.3 Assembly Characteristics: Data Types</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-Assembly-Characteristics-Operations"><span class="toc-text">3.2.4 Assembly Characteristics: Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-Assembling-amp-Disassembling-Object-Code-At-first-glance"><span class="toc-text">3.2.5 Assembling &amp; Disassembling Object Code: At first glance</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Assembly-Basics"><span class="toc-text">3.3 Assembly Basics</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-The-names-for-integer-registers"><span class="toc-text">3.3.1 The names for integer registers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-Move-Operands-and-usage"><span class="toc-text">3.3.2 Move, Operands, and usage</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Moving-Data-Command-movq-lt-SrcR-gt-lt-DstR-gt"><span class="toc-text">Moving Data Command: movq &lt;SrcR&gt;, &lt;DstR&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Operands"><span class="toc-text">Operands</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-Arithmetic-amp-logical-operations"><span class="toc-text">3.3.3 Arithmetic &amp; logical operations</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Address-Computation-Instruction-leaq-lt-Src-gt-lt-Dst-gt"><span class="toc-text">Address Computation Instruction: leaq &lt;Src&gt;, &lt;Dst&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Some-Arithmetic-Operations"><span class="toc-text">Some Arithmetic Operations</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-4-Machine-Level-Programming-%E2%85%A1-Control"><span class="toc-text">Chapter 4. Machine Level Programming Ⅱ - Control</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Introduction-to-Condition-Codes"><span class="toc-text">4.1 Introduction to Condition Codes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-Processor-State-of-x86-64-partial"><span class="toc-text">4.1.1 Processor State of x86-64, partial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-The-meanings-for-Condition-Codes"><span class="toc-text">4.1.2 The meanings for Condition Codes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-Condition-Codes-Explicit-Setting"><span class="toc-text">4.1.3 Condition Codes: Explicit Setting</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Compare-cmpq-lt-Src2-Src1-gt"><span class="toc-text">Compare: cmpq &lt;Src2, Src1&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Test-testq-lt-Src2-Src1-gt"><span class="toc-text">Test: testq &lt;Src2, Src1&gt;</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-Condition-Codes-Reading"><span class="toc-text">4.1.4 Condition Codes: Reading</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Conditional-Branches"><span class="toc-text">4.2 Conditional Branches</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-JX-Instructions-%E3%80%90Old%E3%80%91"><span class="toc-text">4.2.1 JX Instructions 【Old】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-General-Conditional-Expression-Translation-amp-Conditional-Moves"><span class="toc-text">4.2.2 General Conditional Expression Translation &amp; Conditional Moves</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Loops"><span class="toc-text">4.3 Loops</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-Do-While-Loop"><span class="toc-text">4.3.1 Do-While Loop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-General-While-Loop-Translation-1-%E2%80%9CJump-to-Middle%E2%80%9D-Translation"><span class="toc-text">4.3.2 General While Loop Translation #1 - “Jump to Middle” Translation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-General-While-Loop-Translation-2-%E2%80%9CDo-while%E2%80%9D-Conversion"><span class="toc-text">4.3.3 General While Loop Translation #2 - “Do-while” Conversion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-For-Loop"><span class="toc-text">4.3.4 For Loop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Switch-Statements"><span class="toc-text">4.4 Switch Statements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Summary-for-Chapter-4"><span class="toc-text">4.5 Summary for Chapter 4</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-5-Machine-Level-Programming-%E2%85%A2-Procedure"><span class="toc-text">Chapter 5. Machine Level Programming Ⅲ - Procedure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Mechanisms-in-Procedures"><span class="toc-text">5.1 Mechanisms in Procedures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-x86-64-Stack"><span class="toc-text">5.2 x86-64 Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Calling-Conventions"><span class="toc-text">5.3 Calling Conventions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-Passing-Control"><span class="toc-text">5.3.1 Passing Control</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-Passing-Data"><span class="toc-text">5.3.2 Passing Data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-Managing-Local-Data"><span class="toc-text">5.3.3 Managing Local Data</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Register-Saving-Conventions"><span class="toc-text">5.4 Register Saving Conventions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Illustration-of-Recursion"><span class="toc-text">5.5 Illustration of Recursion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Summary-for-Chapter-5"><span class="toc-text">5.5 Summary for Chapter 5</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-6-Machine-Level-Programming-%E2%85%A3-Data"><span class="toc-text">Chapter 6. Machine Level Programming Ⅳ - Data</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Arrays-in-Assembly"><span class="toc-text">6.1 Arrays in Assembly</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-Array-Access-Normal-Array"><span class="toc-text">6.1.1 Array Access: Normal Array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-Array-Access-Two-Dimension-Array"><span class="toc-text">6.1.2 Array Access: Two Dimension Array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-Array-Access-M-%C3%97-N-Matrix"><span class="toc-text">6.1.3 Array Access: M × N Matrix</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Structures-in-Assembly"><span class="toc-text">6.2 Structures in Assembly</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-Structure-Representation"><span class="toc-text">6.2.1 Structure Representation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-Structure-Access-Generate-Pointer-to-Structure-Member"><span class="toc-text">6.2.2 Structure Access: Generate Pointer to Structure Member</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-Accessing-Arrays-of-Structure"><span class="toc-text">6.2.3 Accessing Arrays of Structure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-Saving-Space"><span class="toc-text">6.2.4 Saving Space</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Floating-Point-in-Assembly"><span class="toc-text">6.3 Floating Point in Assembly</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-History-amp-Background-for-Representing-FP"><span class="toc-text">6.3.1 History &amp; Background for Representing FP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-Programming-with-SSE3"><span class="toc-text">6.3.2 Programming with SSE3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-AVX-Instructions"><span class="toc-text">6.3.3 AVX Instructions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Summary-for-Chapter-6"><span class="toc-text">6.4 Summary for Chapter 6</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-7-Machine-Level-Programming-%E2%85%A4-Advanced"><span class="toc-text">Chapter 7. Machine Level Programming Ⅴ - Advanced</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Memory-Layout-in-x86-64"><span class="toc-text">7.1 Memory Layout in x86-64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Buffer-Overflow"><span class="toc-text">7.2 Buffer Overflow</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-The-Vulnerability"><span class="toc-text">7.2.1 The Vulnerability</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-Stack-Smashing-Attacks"><span class="toc-text">7.2.2 Stack Smashing Attacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-Code-Injection-Attacks"><span class="toc-text">7.2.3 Code Injection Attacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-The-Protection-in-personal-respective"><span class="toc-text">7.2.4 The Protection: in personal respective</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-5-%E3%80%90New%E3%80%91Return-Oriented-Programming-Attacks"><span class="toc-text">7.2.5 【New】Return-Oriented Programming Attacks</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-Union-in-Memory"><span class="toc-text">7.3 Union in Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-Union-Allocation"><span class="toc-text">7.3.1 Union Allocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-Summary-of-Compound-Types-in-C"><span class="toc-text">7.3.2 Summary of Compound Types in C</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-Summary-of-Chapter-7"><span class="toc-text">7.4 Summary of Chapter 7</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2023/10/01/%E3%80%8A%E5%8F%AA%E6%9C%89%E6%88%91%E4%B8%8D%E5%9C%A8%E7%9A%84%E5%9F%8E%E5%B8%82%E3%80%8B%E7%95%AA%E8%AF%84/" title="《只有我不在的城市》番评"><img src="https://cdn.sjtuxhw.top/cover_imgs/anime_bokumachi.jpg" onerror="this.onerror=null;this.src='/myBlog/img/404.png'" alt="《只有我不在的城市》番评"/></a><div class="content"><a class="title" href="/myBlog/2023/10/01/%E3%80%8A%E5%8F%AA%E6%9C%89%E6%88%91%E4%B8%8D%E5%9C%A8%E7%9A%84%E5%9F%8E%E5%B8%82%E3%80%8B%E7%95%AA%E8%AF%84/" title="《只有我不在的城市》番评">《只有我不在的城市》番评</a><time datetime="2023-10-01T14:20:47.000Z" title="发表于 2023-10-01 10:20:47">2023-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2023/09/17/CSAPP-Notes-Chapter1-3/" title="CSAPP Notes Chapter1~3"><img src="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg" onerror="this.onerror=null;this.src='/myBlog/img/404.png'" alt="CSAPP Notes Chapter1~3"/></a><div class="content"><a class="title" href="/myBlog/2023/09/17/CSAPP-Notes-Chapter1-3/" title="CSAPP Notes Chapter1~3">CSAPP Notes Chapter1~3</a><time datetime="2023-09-17T23:47:15.000Z" title="发表于 2023-09-17 19:47:15">2023-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2023/09/05/MC-Forge%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" title="MC-Forge开发笔记（一）"><img src="https://cdn.sjtuxhw.top/cover_imgs/minecraft1.png" onerror="this.onerror=null;this.src='/myBlog/img/404.png'" alt="MC-Forge开发笔记（一）"/></a><div class="content"><a class="title" href="/myBlog/2023/09/05/MC-Forge%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" title="MC-Forge开发笔记（一）">MC-Forge开发笔记（一）</a><time datetime="2023-09-06T01:04:06.000Z" title="发表于 2023-09-05 21:04:06">2023-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2023/08/30/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%B8%89%EF%BC%89/" title="从C++入门Qt（三）"><img src="https://cdn.sjtuxhw.top/cover_imgs/qt3.jpg" onerror="this.onerror=null;this.src='/myBlog/img/404.png'" alt="从C++入门Qt（三）"/></a><div class="content"><a class="title" href="/myBlog/2023/08/30/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%B8%89%EF%BC%89/" title="从C++入门Qt（三）">从C++入门Qt（三）</a><time datetime="2023-08-30T23:05:14.000Z" title="发表于 2023-08-30 19:05:14">2023-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2023/08/16/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%BA%8C%EF%BC%89/" title="从C++入门Qt（二）"><img src="https://cdn.sjtuxhw.top/cover_imgs/qt2.jpg" onerror="this.onerror=null;this.src='/myBlog/img/404.png'" alt="从C++入门Qt（二）"/></a><div class="content"><a class="title" href="/myBlog/2023/08/16/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%BA%8C%EF%BC%89/" title="从C++入门Qt（二）">从C++入门Qt（二）</a><time datetime="2023-08-17T03:15:11.000Z" title="发表于 2023-08-16 23:15:11">2023-08-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By SJTU-XHW | tech SJTU saves the world</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> &nbsp;|&nbsp;&nbsp;本网站由 <img src="/img/upCloud_logo.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/myBlog/js/utils.js"></script><script src="/myBlog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-ax33bluz4-alex-andrews-projects.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(init)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-ax33bluz4-alex-andrews-projects.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo-ax33bluz4-alex-andrews-projects.vercel.app/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script src="/myBlog/js/jquery-3.7.0.min.js"></script><script src="/myBlog/js/rightmenu.js"></script><div class="aplayer no-destroy" data-id="6898044781" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"></div><script src="/myBlog/js/mourn.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="/myBlog/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/myBlog/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/myBlog/js/search/local-search.js"></script></div></div></body></html>