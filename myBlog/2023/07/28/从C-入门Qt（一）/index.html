<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>从C++入门Qt（一） | SJTU-XHW's blog</title><meta name="author" content="SJTU-XHW,sjtuxhw12345@sjtu.edu.cn"><meta name="copyright" content="SJTU-XHW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~">
<meta property="og:type" content="article">
<meta property="og:title" content="从C++入门Qt（一）">
<meta property="og:url" content="https://sjtuxhw.top/2023/07/28/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="SJTU-XHW&#39;s blog">
<meta property="og:description" content="written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/qt1.jpg">
<meta property="article:published_time" content="2023-07-28T06:44:12.000Z">
<meta property="article:modified_time" content="2023-09-19T05:26:18.000Z">
<meta property="article:author" content="SJTU-XHW">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Qt">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/qt1.jpg"><link rel="shortcut icon" href="/myBlog/img/favicon.ico"><link rel="canonical" href="https://sjtuxhw.top/2023/07/28/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%B8%80%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/myBlog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?64dd3b0c09c8af7b916f8249d32097e2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/myBlog/',
  algolia: undefined,
  localSearch: {"path":"/myBlog/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从C++入门Qt（一）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-19 13:26:18'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/myBlog/css/mouseConfig.css"><link rel="stylesheet" href="/myBlog/css/valineBg.css"><link rel="stylesheet" href="/myBlog/css/rightmenu.css"><link rel="stylesheet" href="/myBlog/css/custom_music.css"><link rel="stylesheet" href="/myBlog/css/addFonts.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/myBlog/atom.xml" title="SJTU-XHW's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="/myBlog/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/myBlog/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/myBlog/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/myBlog/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/myBlog/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/myBlog/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/myBlog/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/update-log/v0.3.0-Beta.html"><i class="fa-fw fa fa-arrow-circle-up"></i><span> Update</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.sjtuxhw.top/cover_imgs/qt1.jpg')"><nav id="nav"><span id="blog-info"><a href="/myBlog/" title="SJTU-XHW's blog"><img class="site-icon" src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="/myBlog/img/head_icon.png"/><span class="site-name">SJTU-XHW's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/myBlog/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/myBlog/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/myBlog/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/update-log/v0.3.0-Beta.html"><i class="fa-fw fa fa-arrow-circle-up"></i><span> Update</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">从C++入门Qt（一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-28T06:44:12.000Z" title="发表于 2023-07-28 14:44:12">2023-07-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-19T05:26:18.000Z" title="更新于 2023-09-19 13:26:18">2023-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/myBlog/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/myBlog/2023/07/28/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%B8%80%EF%BC%89/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><i>written by SJTU-XHW</i></p>
<p><i>Reference: C++ GUI Programming with Qt 4 (2nd Edition) </i></p>
<p><i>注意：本文章将讲解 <strong>Qt 5</strong> 入门知识，需要一定的 C++ 基础</i></p>
<p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p>
<p><strong>观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~</strong></p>
<hr>
<span id="more"></span>
<h1 id="Chapter-0-前置知识"><a href="#Chapter-0-前置知识" class="headerlink" title="Chapter 0 前置知识"></a>Chapter 0 前置知识</h1><h2 id="0-1-C-基础-和-面向对象编程"><a href="#0-1-C-基础-和-面向对象编程" class="headerlink" title="0.1 C++ 基础 和 面向对象编程"></a>0.1 C++ 基础 和 面向对象编程</h2><h2 id="0-2-C-的宏（macro）"><a href="#0-2-C-的宏（macro）" class="headerlink" title="0.2 C++ 的宏（macro）"></a>0.2 C++ 的宏（macro）</h2><ul>
<li>宏的定义非常自由甚至可以把一个符号定义为一个很长的字符串，甚至代码；主要是因为宏的工作原理是<strong>编译前将宏直接原封不动地替换</strong>；例如下面的极端例子：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 直接把 HELLO 定义为一串代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO \</span><br><span class="hljs-meta">    QLabel* label = new QLabel(<span class="hljs-string">&quot;&lt;h2&gt;&lt;i&gt;Hello,&lt;/i&gt;&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;&quot;</span>);\</span><br><span class="hljs-meta">    QPushButton* btn = new QPushButton(<span class="hljs-string">&quot;Quit&quot;</span>);\</span><br><span class="hljs-meta">    QObject::connect(btn, SIGNAL(clicked()), &amp;app, SLOT(quit()));\</span><br><span class="hljs-meta">    label-&gt;show();\</span><br><span class="hljs-meta">    btn-&gt;show();</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br>    <br>    <span class="hljs-comment">// 直接写 HELLO 就相当于替换了</span><br>    HELLO<br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="0-3-Qt-环境配置"><a href="#0-3-Qt-环境配置" class="headerlink" title="0.3 Qt 环境配置"></a>0.3 Qt 环境配置</h2><blockquote>
<p>Unix 系统：不是安装完就能在命令行里用了吗？</p>
</blockquote>
<p>Windows 系统：在下载安装的 Qt 目录中找到编译器文件夹（安装时应该提醒你设置过了），把编译器目录下 <code>bin</code> 文件夹目录添加到 <strong>用户/系统环境变量 <code>Path</code></strong> 中；</p>
<h1 id="Chapter-1-Qt-初认识"><a href="#Chapter-1-Qt-初认识" class="headerlink" title="Chapter 1 Qt 初认识"></a>Chapter 1 Qt 初认识</h1><h2 id="1-1-简单示例"><a href="#1-1-简单示例" class="headerlink" title="1.1 简单示例"></a>1.1 简单示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QApplication&gt;</span>    <span class="hljs-comment">// Qt 中一些类的定义</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QtWidgets/QLabel&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// QApplication 支持两个参数，说明 Qt 也有自己的命令行参数</span><br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;    <span class="hljs-comment">// 创建 QApplication 对象，用于管理程序资源</span><br>    <span class="hljs-comment">// 创建了显示 “……” 的 QLabel 窗口部件(widget)</span><br>    QLabel* label = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QLabel</span>(<span class="hljs-string">&quot;Hello, Qt!&quot;</span>);<br>    <span class="hljs-comment">// 显示该 widget，详见 tips2.</span><br>    label-&gt;<span class="hljs-built_in">show</span>();<br>    <span class="hljs-comment">// 将应用程序的控制权传递给 Qt，程序进入循环等待状态，监听用户动作并根据代码作出反应</span><br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>    <span class="hljs-comment">// 此处不考虑内存泄漏，因为整个程序结束后，空间能直接被操作系统回收</span><br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>widget：窗口部件，指用户界面中的一个可视化元素，相当于 Windows 中的控件、容器。按钮、菜单、滚动条、框架等都是窗口部件。</p>
<p>tips 1. <strong>绝大多数应用程序会使用 <code>QMainWindow</code> 或 <code>QDialog</code> 作为窗口</strong>；而且在 Qt 中很灵活，甚至可以使用 QLabel 窗口部件来作为窗口（如上例）；</p>
<p>tips 2. <strong>创建 widget 时，大多都是“隐藏”属性，这可以使得我们先更改一些性质，在手动显示它们</strong>；</p>
<p>tips 3. <code>QLabel</code> 类的初始化参数的字符串<strong>允许简单 HTML 文本</strong>！例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">QLabel* label = <span class="hljs-built_in">QLabel</span>(<span class="hljs-string">&quot;&lt;h2&gt;&lt;i&gt;Hello,&lt;/i&gt;&lt;/h2&gt;&quot;</span><br>                   <span class="hljs-string">&quot;&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;&quot;</span>);<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="1-2-要点：通过命令行（qmake）创建、编译-Qt-工程"><a href="#1-2-要点：通过命令行（qmake）创建、编译-Qt-工程" class="headerlink" title="1.2 要点：通过命令行（qmake）创建、编译 Qt 工程"></a>1.2 要点：通过命令行（qmake）创建、编译 Qt 工程</h2><p>本文单独提出为一个小节足以证明重要性，这里不会，连程序都跑不起来……</p>
<p>【⚠ 劝退警告】了解 Qt 前，本文默认大家已经对 C++ 从编码到编译运行的过程都基本了解；</p>
<blockquote>
<p>不了解就想学 Qt，只能说你是抱着没打算学透彻的心态，或者是只会用 IDE，一碰到报错就四处提问，，建议直奔 B 站 “1天速成”，或者某 CSDN 看“教程”；</p>
<p>但如果想要了解这方面内容可以参见博客 “GNU Tutor” 来入门，或者配合 GCC、CMake 相关课程学习（当然要先学会 C++ 基础）；</p>
</blockquote>
<p>从现在开始将使用 Qt 的用户分为 2 类（和操作系统环境无关）：</p>
<ol>
<li><p>使用 Qt Creator 的用户（即在官网安装 Qt Creator IDE 及 全套 Qt 运行环境的用户），<strong>以后称这类用户为 “IDE 用户”</strong>；</p>
<blockquote>
<p>这很像 C++ 使用 VS、VSCode、CLion 等 IDE（集成开发环境） 一键编译运行的用户；</p>
</blockquote>
</li>
<li><p>使用单独的 Qt Designer 的用户（即 Qt 库 + 命令行编译 + Qt Designer 的用户），<strong>以后称这类用户为 “非 IDE 用户”</strong>；</p>
<blockquote>
<p>这很像 C++ 使用<strong>编辑器</strong>写代码、手动使用 CMake/Make/GCC 编译、使用命令行运行的<strong>亲力亲为</strong>的用户；</p>
</blockquote>
</li>
</ol>
<h3 id="非-IDE-用户如何创建、编译运行-Qt-项目"><a href="#非-IDE-用户如何创建、编译运行-Qt-项目" class="headerlink" title="非 IDE 用户如何创建、编译运行 Qt 项目"></a>非 IDE 用户如何创建、编译运行 Qt 项目</h3><blockquote>
<p>由于手动编译更困难、更接近 Qt 运行的原理，所以优先介绍非 IDE 用户的做法；</p>
<p>劝退警告：Windows 环境配置复杂于 Linux，不过能让你更好了解 Qt 项目编译全过程，如果感兴趣可以使用这种方法；本人在开发 Windows 桌面应用时就采用这种方法</p>
</blockquote>
<ul>
<li><p><span id="script-env">【此步仅 Windows 用户】</span>确认编译器环境：Windows 中你可能在之前就有一个 C++ 编译器，并且已经配置在环境变量里，例如 MSVC 或者 minGW，所以为了防止手动编译用错了编译器，导致报错，<strong>这步是必须的</strong>；</p>
<p>在编译前，需要<strong>临时加入2个环境变量，来确保覆盖系统内其他C++编译器的环境变量</strong>：</p>
<ol>
<li><p>和 Qt 库配套的 C++ 编译器目录。如果你安装了 Qt Creator，那么在安装时应该顺带让你设置并安装了对应版本的 minGW 编译器，它的位置和 Qt 是放在一起的；</p>
<p><strong>通常位置是：<code>&lt;Qt安装根目录&gt;\Tools\mingw&lt;版本号&gt;\bin</code></strong>;</p>
<p>例如本人的位置：<code>D:\Qt5.14.2\Tools\mingw730_64\bin</code>；</p>
</li>
<li><p>Qt 库引入新的编译器，例如 <code>moc</code> 编译器、<code>uic</code> 编译器（后面会说），所在的目录；</p>
<p><strong>通常位置是：<code>&lt;Qt安装根目录&gt;\&lt;Qt版本号&gt;\mingw&lt;版本号&gt;\bin</code></strong>；</p>
<p>例如本人的位置：<code>D:\Qt5.14.2\5.14.2\mingw73_64\bin</code>；</p>
</li>
</ol>
<p>为了在手动编译完项目后，不影响其他C++编译器的正常使用，应该把这两个环境变量设置为临时环境变量，最方便的做法是<strong>写成 BAT 脚本</strong>，在命令行窗口中使用，只保留到本次会话结束；<strong>坏处是每次编译前都要运行这个脚本</strong>；例如本人的脚本应该这么写：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># File: addEnv.bat</span><br>@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">set</span> PATH=D:\Qt5.<span class="hljs-number">14.2</span>\<span class="hljs-number">5.14</span>.<span class="hljs-number">2</span>\mingw73_64\bin;D:\Qt5.<span class="hljs-number">14.2</span>\Tools\mingw730_64\bin;%PATH%<br></code></pre></td></tr></table></figure>
<p>你可以将这个脚本保存在你的项目目录，或者其他目录，编译前运行一下就行，<strong>注意必须用命令行运行，而且编译必须使用这个命令行，不能关闭，否则临时环境变量会丢失，需要重新运行</strong>；</p>
<blockquote>
<p><strong>当然，如果你十分肯定系统中唯一的 C++ 编译器就是 Qt 安装的这个编译器，并且还在环境变量里，那么这一整个步骤就不用做了</strong>；</p>
</blockquote>
</li>
<li><p>创建工程：在<strong>已安排源文件（你已经创建了一些 <code>*.h/cpp</code>）的目录</strong>下执行：<code>qmake -project</code>，生成 <code>*.pro</code> 文件，与平台无关的项目文件；</p>
<blockquote>
<p>或者你想让项目目录干净点可以新建一个 build 文件夹，将命令行切入 build 中，再执行 <code>qmake -project &lt;你的项目目录&gt;</code></p>
</blockquote>
</li>
<li><p>添加 Qt 库：如果这个项目除了 <code>QtCore</code>、<code>QtGui</code>（默认包含） 以外，还想添加额外的 Qt 库，例如常用的 <code>QtWidgets</code>，<code>QtNetwork</code>，那么在 <code>*.pro</code> 文件的合适位置添加：<code>QT += widgets</code>、<code>QT += network</code>；</p>
<blockquote>
<p>想要了解更详细的 <code>*.pro</code> 文件的编写规则，请查阅<a target="_blank" rel="noopener external nofollow noreferrer" href="https://doc.qt.io/qt-5/qmake-manual.html">官方文档</a>；</p>
<p><span id="important1"><strong>不过除了添加 Qt 库，其他应该很少会直接修改 <code>pro</code> 文件，例如引入项目文件就不用</strong>：</span></p>
<ul>
<li>IDE 用户可以在 Qt Creator 左侧文件栏右击添加文件，会自动更新 pro 文件；</li>
<li>非 IDE 用户只需在相同文件夹下重新运行 <code>qmake -project</code> 即可更新 pro 文件；</li>
</ul>
</blockquote>
</li>
<li><p>编译工程：使用 <code>qmake *.pro</code> 将一般项目文件编译为与平台相关的 <code>makefile</code> 文件；最后运行<code>make</code> 直接编译即可；</p>
<blockquote>
<p><code>qmake *.pro</code> 的过程有点像 CMake 对照 CMakeLists.txt 生成 Makefile 的过程；</p>
<p>注：Windows 下稍微麻烦一点，在项目目录下：</p>
<ol>
<li><p>运行 <code>qmake *.pro -spec win32-g++ &quot;CONFIG+=debug&quot; &quot;CONFIG += qml_debug&quot;</code></p>
</li>
<li><p>运行 <code>mingw32-make.exe</code>，这就相当于 Unix 系统下的 <code>make</code>；</p>
</li>
</ol>
</blockquote>
<ol>
<li><p>⚠ <strong>当你在生成 <code>makefile</code> 后，又向程序中加入一些新的包或函数，那么可能需要再次运行 <code>qmake</code> 来生成 新的 <code>makefile</code>，以防编译器无法找到新文件</strong>；</p>
</li>
<li><p><strong>有同学可能会问，能不能不用 <code>qmake</code>，就用 <code>cmake</code>？这个可以，下一节就说！</strong></p>
</li>
</ol>
</li>
</ul>
<h3 id="IDE-用户如何创建、编译运行-Qt-项目"><a href="#IDE-用户如何创建、编译运行-Qt-项目" class="headerlink" title="IDE 用户如何创建、编译运行 Qt 项目"></a>IDE 用户如何创建、编译运行 Qt 项目</h3><ul>
<li>法1（纯 IDE 法）：打开 Qt Creator -&gt; 新建项目 -&gt; 按指示配置环境（界面中 Qt Application 模板对新手不友好，可能需要思考一会项目结构） -&gt; 编写项目 -&gt; 编译运行就交给 IDE 吧~；</li>
<li>法2（命令行法，比较自由）：新建一个项目文件夹 -&gt; 按需创建 <code>*.cpp</code> <code>*.h</code> 等项目文件 -&gt; 命令行进入该目录运行 <code>qmake -project</code> -&gt; 进入生成的 <code>*.pro</code> 按需添加所需 Qt 库 -&gt; 双击 pro 文件/进入 Qt Creator 打开项目 -&gt; 编写项目 -&gt; 编译运行就交给 IDE 吧~；</li>
</ul>
<h2 id="1-2-EX-使用-CMake-代替-qmake-构建项目"><a href="#1-2-EX-使用-CMake-代替-qmake-构建项目" class="headerlink" title="1.2-EX 使用 CMake 代替 qmake 构建项目"></a>1.2-EX 使用 CMake 代替 qmake 构建项目</h2><p><strong>使用 IDE 的小伙伴就可以跳过了哦 ~ 因为你们只需要在创建项目时，选择 “项目构建系统” 为CMake，就完成了！</strong></p>
<p>下面，在原来的 CMake 语法的基础上（基础语法不作介绍，可以看本站以前的文章，或者网上学习），本人仅会介绍 <strong>和普通 C++ 项目构建的不同之处</strong>：</p>
<ol>
<li><p><strong>【必要】添加 Qt 专属编译器</strong>（这些编译器在后面会一一介绍，学完可以回来看看）：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 自动调用 uic 编译器处理 *.ui</span><br><span class="hljs-keyword">set</span>(CMAKE_AUTOUIC <span class="hljs-keyword">ON</span>)<br><span class="hljs-comment"># 自动调用 moc 编译器处理 Qt 宏和关键字</span><br><span class="hljs-keyword">set</span>(CMAKE_AUTOMOC <span class="hljs-keyword">ON</span>)<br><span class="hljs-comment"># 自动处理 *.qrc Qt 资源文件</span><br><span class="hljs-keyword">set</span>(CMAKE_AUTORCC <span class="hljs-keyword">ON</span>)<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>【必要】</strong>如果 你在 qmake 中需要添加诸如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">QT += widgets network    // *.pro 的写法<br></code></pre></td></tr></table></figure>
<p>的 Qt 库，在 CMake 中需要这么写：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># $ENV&#123;&#125; 调用系统环境变量，这个 Qt_HOME 需要自己设置在系统环境变量里</span><br><span class="hljs-keyword">find_package</span>(Qt5 COMPONENTS Widgets Network REQUIRED PATHS $ENV&#123;Qt_HOME&#125;)<br></code></pre></td></tr></table></figure>
<p><strong>很遗憾，CMake 没有 qmake 的默认设置，qmake 默认加入的 <code>Gui</code>、<code>Core</code> 库需要在 CMakeLists 中手动加入</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(Qt5 COMPONENTS Core Gui REQUIRED)<br></code></pre></td></tr></table></figure>
<p><strong>而且在最后还要手动链接库</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(exeName PRIVATE Qt5::Widgets Qt5::Core Qt5::Gui)<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>【注意】</strong>：在 CMake 中，由于之前添加了专属编译器，所以 <code>*.ui</code> 和 <code>*.h/cpp</code> 一样，都需要在 <code>add_executable</code> 或 <code>add_library</code> 构建目标时，<strong>作为源文件加入进去</strong>；</p>
</li>
</ol>
<p><strong>最后，以一个示例项目为例子（不同的项目没法照抄哦~）</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="hljs-number">3.12</span>)<br><span class="hljs-keyword">PROJECT</span>(HelloWorld)<br><br><span class="hljs-comment"># 【optional】设置工程包含当前目录</span><br><span class="hljs-keyword">SET</span>(CMAKE_INCLUDE_CURRENT_DIR <span class="hljs-keyword">ON</span>) <br><br><span class="hljs-keyword">SET</span>(CMAKE_AUTOMOC <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">SET</span>(CMAKE_AUTOUIC <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">SET</span>(CMAKE_AUTORCC <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-keyword">FIND_PACKAGE</span>(Qt5 COMPONENTS Widgets Gui Core REQUIRED PATHS $ENV&#123;Qt5_HOME&#125;)<br><br><span class="hljs-comment"># 查找当前文件夹中的所有相关文件</span><br><span class="hljs-keyword">FILE</span>(GLOB SOURCE_FILES <span class="hljs-string">&quot;./*.cpp&quot;</span>) <br><span class="hljs-keyword">FILE</span>(GLOB HEADER_FILES <span class="hljs-string">&quot;./*.h&quot;</span>) <br><span class="hljs-keyword">FILE</span>(GLOB UI_FILES <span class="hljs-string">&quot;./*.ui&quot;</span>) <br><br><span class="hljs-comment"># 通过Ui文件生成对应的头文件</span><br>QT5_WRAP_UI(WRAP_FILES <span class="hljs-variable">$&#123;UI_FILES&#125;</span>)<br><br><span class="hljs-comment"># 添加资源文件</span><br><span class="hljs-keyword">SET</span>(RCC_FILES rcc.qrc)<br><br><span class="hljs-comment"># 【optional】生成UI文件夹</span><br><span class="hljs-keyword">SOURCE_GROUP</span>(<span class="hljs-string">&quot;UI&quot;</span> FILES <span class="hljs-variable">$&#123;UI_FILES&#125;</span> <span class="hljs-variable">$&#123;WRAP_FILES&#125;</span> )<br><br><span class="hljs-comment"># 生成可执行文件，需添加RCC_FILES、WRAP_FILES</span><br><span class="hljs-keyword">ADD_EXECUTABLE</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> <span class="hljs-variable">$&#123;SOURCE_FILES&#125;</span> <span class="hljs-variable">$&#123;HEADER_FILES&#125;</span> <span class="hljs-variable">$&#123;RCC_FILES&#125;</span> <span class="hljs-variable">$&#123;WRAP_FILES&#125;</span>)<br><br><span class="hljs-comment"># 添加Qt5依赖项</span><br><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> Qt5::Widgets Qt5::Core Qt5::Gui)<br></code></pre></td></tr></table></figure>
<h2 id="1-3-建立连接"><a href="#1-3-建立连接" class="headerlink" title="1.3 建立连接"></a>1.3 建立连接</h2><blockquote>
<p>之前我们认识了简单 Qt 程序的基本运作，那么如何实现 <strong>Qt 响应用户的动作呢？</strong></p>
</blockquote>
<h3 id="1-3-1-信号与槽的原理"><a href="#1-3-1-信号与槽的原理" class="headerlink" title="1.3.1. 信号与槽的原理"></a>1.3.1. 信号与槽的原理</h3><ul>
<li><p>Qt 的 widget 通过<strong>发射信号</strong>（signal，实质是一个函数，和操作系统的信号无关）来表明用户的某个动作已发生，或者状态已改变；</p>
<blockquote>
<p>举例：用户点击按钮类 <code>QPushButton</code> 时，按钮会发射 <code>clicked()</code> 信号；</p>
</blockquote>
</li>
<li><p>Qt 的 <strong>槽（slot）能够接收信号</strong>，是一个实际上的函数，一旦触发该信号，slot 会自动执行；</p>
<p>⚠<strong>注意：槽就是函数！一个类如果具有一个方法，那么它就可以作为这个类的槽</strong>；</p>
</li>
<li><p>Qt 通过宏（macro）来将 click() 等对象转化为信号str、将函数 F() 转化为槽，并使用 <code>QObject::connect</code> 函数进行绑定；</p>
<blockquote>
<p><strong>宏转化的时候，如果信号 / 槽对应的函数有参数，务必填入参数类型，例如：</strong></p>
<p><code>SIGNAL(valueChanged(int))</code></p>
</blockquote>
</li>
</ul>
<p>ℹ 这里简单带过一下，给读者一个初印象，以后会详细深入介绍 信号-槽机制；</p>
<h3 id="1-3-2-示例代码"><a href="#1-3-2-示例代码" class="headerlink" title="1.3.2. 示例代码"></a>1.3.2. 示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QtWidgets/QPushButton&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br>    QPushButton* btn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;quit&quot;</span>);<br>    <span class="hljs-comment">// 使用 connect 静态成员函数，其参数原型为：</span><br>    <span class="hljs-comment">// QObject::connect(QObject* p1, SIGNAL, QObject* p2, SLOT)</span><br>    <span class="hljs-comment">// 其中 p1 是指向发送信号的widget指针，p2 是指向接受信号的函数槽**所在的widget**指针，这里是 含有quit()方法 的 QApplication 对象；</span><br>    QObject::<span class="hljs-built_in">connect</span>(btn, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), &amp;app, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">quit</span>()));<br>    button-&gt;<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-4-Qt-窗口的布局设计"><a href="#1-4-Qt-窗口的布局设计" class="headerlink" title="1.4 Qt 窗口的布局设计"></a>1.4 Qt 窗口的布局设计</h2><h3 id="1-4-1-widget-间的父子关系"><a href="#1-4-1-widget-间的父子关系" class="headerlink" title="1.4.1 widget 间的父子关系"></a>1.4.1 widget 间的父子关系</h3><blockquote>
<p>当需要在一个窗口中，<strong>合理地</strong>安排各种 widget 的摆放时，需要考虑这些 widget 间的层次关系；</p>
<p>Qt 中，和其他类的 GUI 设计库类似的做法是，<strong>引入 widget 间的父子关系</strong>；表示：<strong>A 是 B 的子控件 就可以理解为 A 是布局在 B 上的 控件</strong>；</p>
</blockquote>
<p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="layout.png" height="100px"></p>
<p>比如，想要制作如上图的应用界面，就需要遵循这样的步骤（仅供参考，其他方法也能实现）：</p>
<ol>
<li><p>在窗口最顶层设置一个 <code>QWidget</code> 类对象的抽象的 widget，用来盛放其他 widget，可以理解现实中的一个 “桌布”；</p>
</li>
<li><p>以 <code>QWidget</code> 类对象为父控件（QWidget 自己没有父控件，它就是顶层窗口），设置 <code>QSpinbox</code> 和 <code>QSlider</code> 对象（分别是 微调框 控件类、滑动条 控件类）;</p>
<blockquote>
<p><strong>一般情况下，QWidget 及其子类设置父控件的方法是通过布局管理器实现</strong>；理解为“用布局管理器打包在一起”；</p>
</blockquote>
</li>
<li><p>绑定内部信号-槽的关联；</p>
</li>
<li><p>最后<strong>使用布局管理器</strong>将子控件<strong>按指定“摆放方式”</strong>显式加入父控件，显示顶层 widget 即可；</p>
</li>
</ol>
<p>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QtWidgets/QHBoxLayout&gt;</span>    <span class="hljs-comment">// 引入 布局管理器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QtWidgets/QSlider&gt;</span>        <span class="hljs-comment">// 引入 滑动条控件类</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;Qtwidgets/QSpinBox&gt;</span>        <span class="hljs-comment">// 引入 微调框控件类</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br>    <br>    QWidget* mainWindow = <span class="hljs-keyword">new</span> QWidget;<br>    mainWindow-&gt;<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-string">&quot;Enter your age&quot;</span>);    <span class="hljs-comment">// QWidget 类具有成员函数 setWindowTitle</span><br>    <br>    QSpinBox* spinBox = <span class="hljs-keyword">new</span> QSpinBox;<br>    QSlider* slider = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QSlider</span>(Qt::Horizontal);    <span class="hljs-comment">// QSlider 的构造函数的第一个参数可以使用 Qt 枚举量 Horizontal 设置滑动方向</span><br>    spinBox-&gt;<span class="hljs-built_in">setRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">130</span>);<br>    slider-&gt;<span class="hljs-built_in">setRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">130</span>);    <span class="hljs-comment">// 两个类都具有成员函数 setRange</span><br>    <br>    <span class="hljs-comment">// 两个类都具有：valueChanged(int) 信号、setValue(int) 槽，因此将两者相互绑定</span><br>    QObject::<span class="hljs-built_in">connect</span>(spinBox, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">valueChanged</span>(<span class="hljs-type">int</span>)), slider, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">setValue</span>(<span class="hljs-type">int</span>)));<br>    QObject::<span class="hljs-built_in">connect</span>(slider, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">valueChanged</span>(<span class="hljs-type">int</span>)), spinBox, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">setValue</span>(<span class="hljs-type">int</span>)));<br>    <br>    spinBox-&gt;<span class="hljs-built_in">setValue</span>(<span class="hljs-number">35</span>);    <span class="hljs-comment">// 初始化值为35</span><br>    <br>    QHBoxLayout* layout = <span class="hljs-keyword">new</span> QHBoxLayout;    <span class="hljs-comment">// 初始化布局管理器</span><br>    layout-&gt;<span class="hljs-built_in">addWidget</span>(spinBox);<br>    layout-&gt;<span class="hljs-built_in">addWidget</span>(slider);    <span class="hljs-comment">// 布局管理器将子控件打包在一起</span><br>    <span class="hljs-comment">// QWidget 具有成员函数 setLayout，可以传入布局管理器实现布局设计</span><br>    window-&gt;<span class="hljs-built_in">setLayout</span>(layout);    <span class="hljs-comment">// 再将包传给父控件，底层会自动将管理器中的所有子控件定向其父控件</span><br>    <br>    window-&gt;<span class="hljs-built_in">show</span>();        <span class="hljs-comment">// 最后只需展示顶层 widget 即可</span><br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-4-2-布局设计的意义"><a href="#1-4-2-布局设计的意义" class="headerlink" title="1.4.2 布局设计的意义"></a>1.4.2 布局设计的意义</h3><p>有同学会问，为什么需要 layout？<strong>layout 可以让多个 widget 按想要的方式排列在一个窗口上</strong>；如果不这么做，就没法定义摆放方式了！你可以试一试，不用布局管理器，你会发现两个或多个 widget 是分布在不同的窗口下的；</p>
<h3 id="1-4-3-布局管理器的类型"><a href="#1-4-3-布局管理器的类型" class="headerlink" title="1.4.3 布局管理器的类型"></a>1.4.3 布局管理器的类型</h3><p>除了以上例子介绍的 <code>QHBoxLayout</code> 类，还有 <code>QVBoxLayout</code>、<code>QGridLayout</code>，其作用分别是：</p>
<ul>
<li><code>QHBoxLayout</code>：默认在水平方向，从左到右排列 widget；</li>
<li><code>QVBoxLayout</code>：默认在竖直方向，从上到下排列 widget；</li>
<li><code>QGridLayout</code>：将 widget 排列在预设的网格中；</li>
</ul>
<p>常见的使用方法：先声明、在设置属性，最后添加打包到布局管理器中，设置给父控件；</p>
<p><strong>它们都继承于 <code>QLayout</code>，所以它们不是 widget（<code>QWidget</code>），一般也不可见</strong>；</p>
<h2 id="1-5-章末贴士"><a href="#1-5-章末贴士" class="headerlink" title="1.5 章末贴士"></a>1.5 章末贴士</h2><ul>
<li><p>重要：一定要会使用官方文档；</p>
</li>
<li><p>有些同学会想，里面的命令行参数 <code>argc</code> 和 <code>argv</code> 究竟可以做什么？其实，举个例子就明白了，其中一个用途是<strong>设置应用界面的主题</strong>，即：<code>./应用名 -style &lt;style name&gt;</code>，常用的 <code>style name</code> 有：<code>plastique</code>、<code>Cleanlooks</code>、<code>CDE</code>、<code>Motif</code>、<code>Windows</code>、<code>Windows XP</code>、<code>Windows Vista</code>、<code>Mac</code>；</p>
</li>
<li><p>本章涉及到的类和一些方法的总结</p>
<p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="C1.png"></p>
</li>
<li><p><strong>和 Qt 4 比较</strong>：QLabel、QPushButton、QSlider、QSpinBox 都还是 QWidget 的子类，但 Qt 5 类的头文件移动到<strong>单独的 <code>QWidgets</code> 模块中</strong>，即 include 时，需要：<code>#include&lt;QtWidgets/QXXX&gt;</code></p>
<blockquote>
<p>例如 1.4.1 的例子在 Qt 4 环境下应该这么写<strong>【亲测能跑】</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QSpinBox&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QSlider&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QHBoxLayout&gt;</span></span><br><br><span class="hljs-comment">// …… （后面一毛一样）</span><br><span class="hljs-comment">// 记得在 *.pro 中移除：QT += widgets</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>最后强调一下， Qt 4 到 5、Qt 5 到 6 的很多操作都改变了，所以别轻易更换项目的 Qt 大版本！</strong></p>
</li>
</ul>
<h1 id="Chapter-2-面向对象的-Qt"><a href="#Chapter-2-面向对象的-Qt" class="headerlink" title="Chapter 2 面向对象的 Qt"></a>Chapter 2 面向对象的 Qt</h1><h2 id="2-1-纯代码设计"><a href="#2-1-纯代码设计" class="headerlink" title="2.1 纯代码设计"></a>2.1 纯代码设计</h2><h3 id="2-1-1-示例：以简单对话框为例"><a href="#2-1-1-示例：以简单对话框为例" class="headerlink" title="2.1.1 示例：以简单对话框为例"></a>2.1.1 示例：以简单对话框为例</h3><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="QDiag.png" height="150px"></p>
<blockquote>
<p>想象一下，这是一个庞大应用程序的一个小部分对话框，现在想要单独设计它。但是第一章的代码都写在一个 main 函数中，如果窗口一多，不仅不利于维护，而且容易编写错误；</p>
<p>所以我们从现在开始采用 C++ 中的不同类来编写不同窗口，可以形成很好的封装性，增强可读性；</p>
</blockquote>
<p>下面将这个窗口编写为一个类 <code>findDialog</code>；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// file: findDialog.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FINDDIALOG_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINDDIALOG_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QtWidgets/QDialog&gt;</span>    <span class="hljs-comment">// 包含 Qt 对话的基类，派生于 QWidget，和 1.5 中说的一样，在 Qt 4 中要写 #include&lt;QDialog&gt;，以下不再赘述；</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QtWidgets/QLineEdit&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QtWidgets/QPushButton&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QtWidgets/QCheckBox&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QtWidgets/QLabel&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">findDialog</span> : <span class="hljs-keyword">public</span> QDialog &#123;<br>    Q_OBJECT    <span class="hljs-comment">// 很重要的一个宏，里面写了 QObject 类的几乎所有信号和槽，还有其他属性和方法</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 这是一个典型的 Qt widget 类的定义方式，第一个参数指定父控件</span><br>    <span class="hljs-built_in">findDialog</span>(QWidget* parent = <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 这个 marco 说明以下定义的函数都是 信号函数</span><br>signals:<br>    <span class="hljs-comment">// Qt::CaseSensitivity 是 enum 类型，和 C++ 中的 true、false 如出一辙，本身的值也是 0 或 1，用于区分大小写是否敏感的具体情况，含有值 Qt:CaseSensitive 和 Qt::CaseInSensitive</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findNext</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findPrevious</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span></span>;<br>    <br><span class="hljs-comment">// 声明了私有的槽</span><br><span class="hljs-keyword">private</span> slots:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findClicked</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 思考一下，已知 QPushButton 自己有槽函数 setEnabled(bool)，为什么还要包装一层 私有的槽呢？（答案在实现这个槽的时候揭晓）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enabledFindButton</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; text)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    QLabel* label;<br>    QLineEdit* lineEdit;<br>    QCheckBox* caseCheckBox;<br>    QCheckBox* backwardCheckBox;<br>    QPushButton* findButton;<br>    QPushButton* closeButton;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>这是窗口的实现 cpp：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// file: findDialog.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QtGui&gt;</span>        <span class="hljs-comment">// 详见注解 tips 1.</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;findDialog.h&quot;</span></span><br><br><span class="hljs-comment">// findDialog 继承于 QDialog，所以也使用它的一些数据成员，自然需要委托构造</span><br>findDialog::<span class="hljs-built_in">findDialog</span>(QWidget* parent) : <span class="hljs-built_in">QDialog</span>(parent) &#123;<br>    <span class="hljs-comment">// 这里有 3 点需要解释，详见 tips 2. 、 tips 3. 和 tips 4.</span><br>    label = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QLabel</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;Find &amp;what&quot;</span>));    <span class="hljs-comment">// tips2. tips3.</span><br>    <span class="hljs-comment">// 新的类：QLineEdit 类，单行输入框类</span><br>    lineEdit = <span class="hljs-keyword">new</span> QLineEdit;<br>    label-&gt;<span class="hljs-built_in">setBuddy</span>(lineEdit);    <span class="hljs-comment">// tips4.</span><br>    <br>    <span class="hljs-comment">// 新的类：QCheckBox 类，勾选框类，初始化参数和 QLabel 一样，也是str内容</span><br>    caseCheckBox = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QCheckBox</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;Match &amp;case&quot;</span>));<br>    backwardCheckBox = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QCheckBox</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;Search &amp;backward&quot;</span>));<br>    <br>    findButton = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;&amp;Find&quot;</span>));<br>    findButton-&gt;<span class="hljs-built_in">setDefault</span>(<span class="hljs-literal">true</span>);        <span class="hljs-comment">// tips 5.</span><br>    findButton-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">false</span>);        <span class="hljs-comment">// tips 6.</span><br>    <br>    closeButton = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;Close&quot;</span>));<br>    <br>    <span class="hljs-comment">// 这里不用写作用域 “QObject::”，因为 QDialog 就是 QObject 的子类</span><br>    <span class="hljs-comment">// 详见 tips 7.</span><br>    <span class="hljs-comment">// 还记得之前声明的私有槽吗？（再等会实现定义）这里是将 lineEdit 的文字改变信号连接到 findDiag 窗体的 enabledFindButton(const QString&amp;) 私有槽上；</span><br>    <span class="hljs-built_in">connect</span>(lineEdit, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">textChanged</span>(<span class="hljs-type">const</span> QString&amp;)),<br>           <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">enableFindButton</span>(<span class="hljs-type">const</span> QString&amp;)));<br>    <span class="hljs-built_in">connect</span>(findButton, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()),<br>           <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">findClicked</span>()));<br>    <span class="hljs-comment">// tips 8.</span><br>    <span class="hljs-built_in">connect</span>(closeButton, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()),<br>           <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">close</span>()));<br>    <br>    <span class="hljs-comment">// 代码块未完待续----------------------------</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p><strong>tips 1.</strong> 头文件 <code>QtGui.h</code> 包含了 Qt GUI 类的 <code>QtCore</code> 和 <code>QtGui</code> 模块的所有类的定义；</p>
<blockquote>
<p><strong>回顾一下 Qt 的主要模块：<code>QtCore</code>、<code>QtGui</code>、<code>QtNetwork</code>、<code>QtOpenGL</code>、<code>QtSql</code>、<code>QtSvg</code>、<code>QtXml</code></strong>；</p>
</blockquote>
<ul>
<li>同学会问，为什么不在 <code>findDialog.h</code> 中直接 <code>#include&lt;QtGui&gt;</code>？<strong>因为这个包比较大，引入他可能造成引用的不清晰，不是一个好习惯；理论上用到什么引入什么</strong>；</li>
</ul>
</li>
<li><p><strong>tip 2.</strong>  在 Qt 中，所有字符串都认为是 <code>QString</code> ——有 <code>tr(QString)</code> 方法可以将它们翻译；这就意味着，<strong>在所有用户可见的字符串周围加上 <code>tr()</code> 函数</strong>是个好习惯；这样方便软件后期的翻译工作，对 <code>tr()</code> 的翻译会在后面介绍；</p>
</li>
<li><p><strong>tips 3.</strong> 如果想在用户可见的字符串中加入<strong>快捷键来控制焦点（选中的区域，意味着用户可以直接输入，或者按 ENTER=点击）</strong>，那么在字符串前中写 <strong>“&amp;”</strong> 符号，表示<strong>将 <code>Alt + 字符串第一个字符</code> 作为快捷键</strong>；</p>
</li>
<li><p><strong>tips 4.</strong> 几乎所有 <code>QWidget</code> 都有一个方法 <code>setBuddy(QWidget* ptr)</code> 用来绑定两个 widget 为兄弟控件，具体表现在<strong>共用同一个快捷键</strong>（这个快捷键会同时聚焦这两个控件）；</p>
</li>
<li><p><strong>tips 5.</strong> 大多数 <code>QWidget</code> 都有一个方法 <code>setDefault(bool flag)</code> 用来指定<strong>刚打开窗口时聚焦的控件</strong>；</p>
</li>
<li><p><strong>tips 6.</strong> <code>QPushButton</code> 有一个特有属性 <code>enabled</code>，如果是 <code>true</code>，则这个按钮是可以点击的，否则按钮呈现灰色不可点击的状态；</p>
</li>
<li><p><strong>tips 7.</strong> 由上面的 <code>connect</code> 函数可以看出，<code>QLineEdit</code> 类有一个 <code>textChanged(const QString&amp;)</code> 信号；</p>
</li>
<li><p><strong>tips 8.</strong> 这里 <code>QDialog</code> 的 <code>close()</code> 方法<strong>继承于 <code>QWidget</code> 类</strong>，默认行为是<strong>将 widget 隐藏起来（而非删除）</strong>，这和 <code>QApplication</code> 类的 <code>quit()</code> 方法不一样，<code>quit()</code> 方法是关闭并删除窗口及其上的所有布局、widget；</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++">    <span class="hljs-comment">// 上接上一个代码块 --------------------------	</span><br><br>    <span class="hljs-comment">// 记住在 1.4.1 中说的 4 个基本步骤，这里是倒数第二个：打包布局</span><br>    <span class="hljs-comment">// 这里的案例告诉我们，对于多个 widget 的布局，可以采用多个不同位置、不同类型的布局管理器来进行，这里的具体划分见 tips 9.</span><br>    QHBoxLayout* topLeftLayout = <span class="hljs-keyword">new</span> QHBoxLayout;<br>    topLeftLayout-&gt;<span class="hljs-built_in">addWidget</span>(label);<br>    topLeftLayout-&gt;<span class="hljs-built_in">addWidget</span>(lineEdit);<br>    <br>    QVBoxLayout* leftLayout = <span class="hljs-keyword">new</span> QVBoxLayout;<br>    <span class="hljs-comment">// tip 10.</span><br>    leftLayout-&gt;<span class="hljs-built_in">addLayout</span>(topLeftLayout);<br>    leftLayout-&gt;<span class="hljs-built_in">addWidget</span>(caseCheckBox);<br>    leftLayout-&gt;<span class="hljs-built_in">addWidget</span>(backwardCheckBox);<br>    <br>    QVBoxLayout* rightLayout = <span class="hljs-keyword">new</span> QVBoxLayout;<br>    rightLayout-&gt;<span class="hljs-built_in">addWidget</span>(findButton);<br>    rightLayout-&gt;<span class="hljs-built_in">addWidget</span>(closeButton);<br>    <span class="hljs-comment">// tip 11.</span><br>    rightLayout-&gt;<span class="hljs-built_in">addStretch</span>();<br>    <br>    QHBoxLayout* mainLayout = <span class="hljs-keyword">new</span> QHBoxLayout;<br>    mainLayout-&gt;<span class="hljs-built_in">addLayout</span>(leftLayout);<br>    mainLayout-&gt;<span class="hljs-built_in">addLayout</span>(rightLayout);<br>    <span class="hljs-comment">// 回想之前在 1.4.1 中对 QWidget 顶层窗口使用 setLayout</span><br>    <span class="hljs-built_in">setLayout</span>(mainLayout);<br>    <br>    <span class="hljs-comment">// 和 1.4.1 中一样，这里是 QWidget 派生来的方法</span><br>    <span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;Find&quot;</span>));<br>    <span class="hljs-comment">// tip 12.</span><br>    <span class="hljs-built_in">setFixedHeight</span>(<span class="hljs-built_in">sizeHint</span>().<span class="hljs-built_in">height</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><strong>tips 9.</strong> 此处的布局划分的方式如下图所示：</p>
<p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="QLayout.png" height="200px"></p>
<p>这样的划分思路很类似 HTML 的设计框架布局，<strong>先划分大的区域，再根据功能或对齐位置逐个 “切开” </strong>；</p>
</li>
<li><p><strong>tips 10.</strong> <code>QLayout</code> 类的对象都有 <code>addLayout(QLayout* ptr)</code>，与 <code>addWidget(QWidget* ptr)</code> 类似；前者可以将布局嵌套布局，形成更复杂的结构；</p>
</li>
<li><p><strong>tips 11.</strong> <code>QLayout</code> 类中的 <code>addStretch()</code> 方法，如 tip9 中的图片中的 “分隔符” 的作用，用来撑开当前的 <code>Layout</code>，与同级的 <code>Layout</code> 高度或宽度对齐适应，同时使之前加入布局管理器的 widget 更加紧凑；</p>
</li>
<li><p><strong>tips 12.</strong> <code>setFixedHeight(int h)</code> 是 <code>QWidget</code> 类的方法，可以设定一个固定的 widget 高度，<code>QWidget::sizeHint()</code> 可以计算当前 widget 中各个布局管理器中各子 widget 默认 size，从而得出比较适宜的高度；</p>
</li>
</ul>
<p><strong>写完构造函数，无需写析构函数。因为：Qt 在删除父对象时，会自动删除所有子 widget 和 子布局；</strong></p>
<p>下面<strong>定义之前声明的私有槽</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findDialog::findClicked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 读取当前 lineEdit 中的字符串到 text 中</span><br>    QString text = lineEdit-&gt;<span class="hljs-built_in">text</span>();<br>    <span class="hljs-comment">// tips 13.</span><br>    Qt::CaseSensitivity cs = <br>        caseCheckBox-&gt;<span class="hljs-built_in">isChecked</span>() ? Qt:CaseSensitive : Qt:CaseInSensitive;<br>    <span class="hljs-keyword">if</span> (backwardCheckBox-&gt;<span class="hljs-built_in">isChecked</span>())<br>        <span class="hljs-comment">// tips 14.</span><br>        <span class="hljs-function">emit <span class="hljs-title">findPrevious</span><span class="hljs-params">(text, cs)</span></span>;<br>    <span class="hljs-keyword">else</span> emit <span class="hljs-built_in">findNext</span>(text, cs);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findDialog::enableFindButton</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; text)</span> </span>&#123;<br>    <span class="hljs-comment">// 代码块 1 中的疑问，答案揭晓：tips 15.</span><br>    findButton-&gt;<span class="hljs-built_in">setEnabled</span>(!text.<span class="hljs-built_in">isEmpty</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><strong>tips 13.</strong> <code>QCheckBox</code> 具有方法 <code>isChecked()</code>，指示这个选择框有没有被选中；</p>
</li>
<li><p><strong>tips 14.</strong> <code>emit &lt;function&gt;</code> 是 Qt 的关键字之一，<strong>表示向函数 <code>function</code> 发射信号</strong>；</p>
</li>
<li><p><strong>tips 15.</strong> 之所以要单独设计一个私有槽，是因为考虑到不仅仅是在输入变换的时候，使这个按钮处于 enable 状态，还要考虑<strong>在文本框为空的时候，使按钮再次 disable</strong>，而这需要额外的逻辑设计；这里就是 <code>!text.isEmpty()</code> 这个方法；</p>
<blockquote>
<p>整体逻辑：如果改变了文本，就调用 <code>enableFindButton</code> 槽；如果文本为空，就 disable “Find” 按钮；</p>
</blockquote>
</li>
</ul>
<p>这下将所有的部件放在一起：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;findDialog.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br>    findDialog* dialog = <span class="hljs-keyword">new</span> findDialog;<br>    dialog-&gt;<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>⚠注意：因为这里没有实际应用场景，所以以上代码的信号 <code>findPrevious(str, cs)</code> 和 <code>findNext(str, cs)</code> 暂时没有应用，以后继续补充</strong>；</p>
<h3 id="2-1-2-进一步了解信号-槽机制"><a href="#2-1-2-进一步了解信号-槽机制" class="headerlink" title="2.1.2 进一步了解信号-槽机制"></a>2.1.2 进一步了解信号-槽机制</h3><ul>
<li><p>槽（<code>slot</code>）：和普通 C++ 成员函数<strong>几乎一模一样</strong>：可以是虚函数、可以被重载、可以是 <code>public/protected/private</code>、可以被其他 C++ 成员函数之间调用、参数可以是任意类型；唯一不同的就是<strong>槽可以和信号连接在一起</strong>，只要 <code>emit</code> 了对应的信号，就会自动调用这个槽；</p>
<blockquote>
<p><strong>当普通 C++ 函数变成槽调用时，一般会忽略原本的返回值</strong>；</p>
</blockquote>
</li>
<li><p>信号 - 槽的连接的函数：<code>QObject::connect(QObject* sender, SIGNAL(signal), QObject* receiver, SLOT(slot))</code></p>
<blockquote>
<p>其中宏 <code>SIGNAL()</code> 和 <code>SLOT()</code> <strong>会将它们的参数转换成相应的字符串</strong>（暂时不必了解这些字符串的结构）；</p>
</blockquote>
</li>
<li><p>信号-槽连接的<strong>要求</strong>：要想信号和槽成功连接，<strong>它们的参数必须有相同的顺序和相同的类型</strong>；</p>
<blockquote>
<p>有一种情况例外：<strong>信号的参数多于槽的参数，但对应的参数类型相同</strong>（这样多余的参数会被简单地忽略掉）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">connect</span>(ftp, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">rawCommnadReply</span>(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> QString&amp;)),<br>    <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">checkErrorCode</span>(<span class="hljs-type">int</span>)));<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>信号-槽连接的<strong>特性</strong></p>
<ol>
<li><p><strong>一个信号可以连接多个槽</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在这个例子中，如果信号 slider 被 emit，那么会以不确定的顺序一个接着一个调用这些槽（setValue(int) 和 updateStatusBarIndicator(int)，可以不止两个）</span><br><span class="hljs-built_in">connect</span>(slider, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">valueChanged</span>(<span class="hljs-type">int</span>)),<br>        spinBox, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">setValue</span>(<span class="hljs-type">int</span>)));<br><span class="hljs-built_in">connect</span>(slider, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">valueChanged</span>(<span class="hljs-type">int</span>)),<br>       <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">updateStatusBarIndicator</span>(<span class="hljs-type">int</span>)));<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>多个信号可以连接一个槽</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 无论发射其中的哪一个信号，都会调用这个槽</span><br><span class="hljs-built_in">connect</span>(lcd, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">overflow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">handleMathError</span>()));<br><span class="hljs-built_in">connect</span>(calc, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">divisionByZero</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">handleMathError</span>()));<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>一个信号可以连接另一个信号</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// emit 第一个信号，就会触发 emit 第二个信号</span><br><span class="hljs-built_in">connect</span>(lineEdit, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">textChanged</span>(<span class="hljs-type">const</span> QString&amp;)),<br>       <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">updateRecord</span>(<span class="hljs-type">const</span> QString&amp;)));<br></code></pre></td></tr></table></figure>
</li>
<li><p>连接可以被移除：<strong>这种情况应用较少，因为 <code>Qt</code> 在移除对象时，会自动移除和对象相关的所有连接</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">disconnect</span>(lcd, <span class="hljs-built_in">SINGAL</span>(<span class="hljs-built_in">overflow</span>()),<br>          <span class="hljs-keyword">this</span>, <span class="hljs-built_in">handlerMathError</span>());<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>信号-槽不仅可以应用在图形化界面的编写中，在哪怕不是为了设计 GUI，在类中声明宏 <code>Q_OBJECT</code> 也可以实现信号-槽机制</strong>；</p>
</li>
</ol>
</li>
</ul>
<h3 id="2-1-3-Qt-的元对象编译器-moc-和-元对象系统"><a href="#2-1-3-Qt-的元对象编译器-moc-和-元对象系统" class="headerlink" title="2.1.3 Qt 的元对象编译器 moc 和 元对象系统"></a>2.1.3 Qt 的元对象编译器 moc 和 元对象系统</h3><p>在我一开始尝试写一些基本的程序的时候，一直很疑惑，Qt 的宏 <code>slots</code>、<code>signal</code>、<code>Q_OBJECT</code> 究竟是什么？因为我不理解这其中的原理，所以犯过一个低级的错误——将声明成信号（<code>signal</code>）的函数加以定义，像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// File: XXX.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XXX</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>signal:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signalA</span><span class="hljs-params">(Type1 p1, Type2 p2)</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// File: XXX.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">XXX::signalA</span><span class="hljs-params">(Type1 p1, Type2 p2)</span> </span>&#123;<br>    <span class="hljs-comment">// 某些代码逻辑</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样写实际上会在 <code>make</code> 编译是报 <code>multiple definition</code> 的错误，我正纳闷，为啥会 “重复定义” 呢？再一看报错的信息：<strong>重复定义的位置位于 <code>moc_XXX.cpp</code> </strong>，我再想，我也没有写过 <code>moc_XXX.cpp</code> 呀？于是就引出了 <strong><code>Qt</code> 中相当重要的概念：<code>moc</code> 元对象编译器</strong>；</p>
<p>Qt 的主要成就之一就是使用一种机制对 C++ 进行了扩展，并且使用这种机制创建了软件组件；</p>
<p>这种机制叫做 “元对象系统（meta-object system）”，它提供了关键的 2 项技术：<strong>信号-槽机制</strong> 和 <strong>内省（introspection）</strong>；</p>
<p>内省功能对于实现信号和槽是必需的，还允许开发人员获得有关 <code>QObject</code> 子类的 “元信息（meta-information，<strong>包含一些类名和它所支持的信号-槽列表</strong>）”，还支持 Qt 设计师属性（<strong>下一节将提到</strong>）和文本翻译（之前所说的 <code>tr()</code>），为 <code>QScript</code> 模块奠定基础（不过目前接触不到）；</p>
<p>但以上提到的这些，标准 C++ 没有，这意味着用普通的 C++ 编译器一定没法实现；所以 Qt 引入了新的编译器：<code>moc</code> 元对象编译器；</p>
<p>因此，Qt 整个编码到运行的工作流程是：</p>
<ol>
<li><code>qmake</code> 效仿 <code>cmake</code> ，以平台无关的方式指定了程序编译所需的库，这里包含了标准 C++ 所没有的 Qt 的库；最后生成了普通的 <code>Makefile</code>；</li>
<li><code>moc</code> 元对象编译器一边识别 Qt 特定的宏或关键字（例如 <code>QObject</code>、<code>slots</code>、<code>signal</code>），添加特定内容（例如自动实现信号函数），一边和普通 C++ 编译器一样，编译链接源文件；</li>
<li><code>moc</code> 元对象编译器在编译时还会补充 <code>QObject</code> 的 内省函数，完成特殊的触发工作；</li>
</ol>
<p>以上内容一般很少需要开发者去考虑，都封装在 <code>qmake</code>、<code>moc</code>、<code>QObject</code>内部；如果感兴趣，可以阅读有关 <code>QMetaObject</code> 文档，或者是前面提到的 <code>moc</code> 自动生成的 C++ 源码 <code>moc_XXX.cpp/h</code>；</p>
<h2 id="2-2-Qt-Designer：UI-快速设计"><a href="#2-2-Qt-Designer：UI-快速设计" class="headerlink" title="2.2 Qt Designer：UI 快速设计"></a>2.2 Qt Designer：UI 快速设计</h2><p>在上面一些纯代码设计的例子中，我们会发现 GUI 的设计遵循一些基本的规律定式：</p>
<ol>
<li>创建、初始化（例如设置文本内容）子窗口部件；</li>
<li>将 widget 放置到布局中；</li>
<li>设置 Tab 键顺序；</li>
<li>建立信号 — 槽连接；</li>
<li>实现自定义槽；</li>
</ol>
<p>现在，可以使用 Qt Designer 将图形化设计的一部分（指前三步）交给图形界面；</p>
<h3 id="2-2-1-Qt-Designer-的基本使用"><a href="#2-2-1-Qt-Designer-的基本使用" class="headerlink" title="2.2.1 Qt Designer 的基本使用"></a>2.2.1 Qt Designer 的基本使用</h3><blockquote>
<p>本部分将介绍 Qt Designer 如何设计基本 UI 界面，完成上面所提到的 <strong>前3步</strong>，同时<strong>回顾之前所学到的方法</strong>；</p>
</blockquote>
<p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="cellDialog.png"></p>
<p>以上面的窗体为目标设计一个窗口类；</p>
<ul>
<li><p>打开 Qt Designer：在进行此步前，建议按之前的方法先创建一个 Qt 项目；</p>
<ul>
<li>IDE 用户可以在 Qt Creator 中右击创建 <code>Qt 设计师文件</code> （<strong>文件名很重要，将要作为这个窗体的变量名，需要记住，下面提到</strong>），在左边栏的列表中直接双击打开 <code>*.ui</code>；</li>
<li>非 IDE 用户可以直接进入 Qt Designer 按所需模板新建一个 <code>ui</code> 文件（<strong>文件名很重要，需要记住，下面提到</strong>）；</li>
</ul>
</li>
<li><p>创建、初始化子窗口部件 和 部分常用属性</p>
<ol>
<li><code>text</code> 属性：大部分组件的显示内容（还记得之前 <code>QPushButton</code>、<code>QLabel</code> 的初始化参数吗？），拖动出来双击就可以编辑；</li>
<li><code>objectName</code> 属性：<strong>这个名字建议自己设置，需要记住，因为这是控件的变量名，之后设计信号-槽时需要用到</strong>；</li>
<li><code>default</code> 属性：记得之前的方法 <code>QWidget::setDefault</code> 吗？这就是它的图形化；</li>
<li><code>enabled</code> 属性（<code>QPushButton</code>）：相当于在创建 widget 的同时指定 <code>btn-&gt;setEnabled(bool)</code>；</li>
<li><code>windowTitle</code> 属性（<code>QMainWindow</code>，这里点击窗体在右边栏就能搜到）：相当于 <code>win-&gt;setWindowTitle(str)</code>；</li>
</ol>
</li>
<li><p>Qt Designer 设计模式</p>
<ul>
<li>Edit Widgets 模式：默认模式，可以直接编辑上述部件及其属性，在程序顶部“Edit”菜单可以点击进入；</li>
<li>Edit Buddies 模式：点击顶部菜单栏相应按钮进入。此模式下，点击控件并拖到另一个部件上可以完成<strong>部件伙伴的设置</strong>，就是之前设置的 <code>widget1-&gt;setBuddy(widget2)</code>；</li>
<li>Edit Tab Order 模式：点击顶部菜单栏相应按钮进入。此模式下可以<strong>设置 Tab 键顺序</strong>；</li>
</ul>
</li>
<li><p>Qt Designer 中的布局设置</p>
<ul>
<li>方法1：使用左边栏的 Layout 控件；</li>
<li>方法2：按住 CTRL 选中一些 widget，点击顶部菜单栏中的 <code>Lay out Vertically/Horizontally</code>；</li>
</ul>
<blockquote>
<p>注：在布局中加入左边栏中的 <code>Spacer</code> 就等价于之前设置的 <code>layout-&gt;addStretch()</code></p>
</blockquote>
</li>
<li><p>Qt Designer 中的窗口大小设计</p>
<p>可以点击顶部菜单栏中的 <code>Adjust size</code>（调整大小），可以自动将窗体大小定义为最佳形式（等价于之前的 <code>setFixedHeight(sizeHint().height())</code>）</p>
</li>
</ul>
<h3 id="2-2-2-Qt-Designer-的运行原理【重要】"><a href="#2-2-2-Qt-Designer-的运行原理【重要】" class="headerlink" title="2.2.2 Qt Designer 的运行原理【重要】"></a>2.2.2 Qt Designer 的运行原理【重要】</h3><p>说了这么多 Qt Designer 的基本使用，那么它是怎么将 图形界面中设计的 UI 转换为之前的纯代码，并交给 <code>moc</code> 编译器 和 C++ 编译器的呢？</p>
<p>细心的同学可能以文本形式打开过 <code>*.ui</code> ，会发现里面的格式是 <code>XML</code> 文件格式，那么它又是如何转化为 <code>*.h/cpp</code> 的呢？<strong>下面先从非 IDE 用户的视角讲述，IDE 用户也建议看一下，因为 Qt Creator IDE 的自动操作比较奇怪，可能不好理解</strong>；</p>
<p> 以下的案例以名为 <code>myDialog</code> 的主窗口 <code>MainWindow</code> 的设计为例；</p>
<h4 id="非-IDE-用户的视角"><a href="#非-IDE-用户的视角" class="headerlink" title="非 IDE 用户的视角"></a>非 IDE 用户的视角</h4><p>首先，我们向项目中导入这个 <code>myDialog.ui</code> 文件（创建文件并 <code>qmake -project</code>，即前面的<a href="#important1">要点🔗</a>）；</p>
<p>你会发现，<code>qmake</code> 自动更新了 pro 文件：<code>FORM += myDialog.ui</code>（不用自己写）；</p>
<p>紧接着运行 <code>qmake myDialog.pro</code> 生成 <code>Makefile</code> 的同时，<code>qmake</code> 智能识别 <code>myDialog.ui</code>，会在 Makefile 中加入配置规则 <strong>调用 Qt 的新的一种编译器，这不是 GCC，也不是 <code>moc</code>，而是 Qt 用户界面编译器（user interface compiler，uic）</strong>；它会将 <code>myDialog.ui</code> 转换为 C++ 代码存储于 <code>ui_myDialog.h</code> 中；</p>
<p>在 <code>ui_myDialog.h</code> 会生成一个类，类名是 <code>myDialog</code>，<strong>位于 <code>Ui</code> 命名空间</strong>（命名空间 <code>Ui</code> 是 Qt 中用于存放各种 UI 类 的命名空间，通常存放在里面是一种规范）</p>
<blockquote>
<p>⚠ <strong>注意：这里 <code>ui</code> 文件名 <code>XXX.ui</code>、生成的 <code>ui_XXX.h</code> 中的 <code>XXX</code>、生成的类名 <code>XXX</code> 应该是一个名字！！！</strong></p>
<p>不建议轻易修改，不然有可能在下次编译时，编译器找不到相应组件；</p>
<p>这也是为什么之前提醒 “创建 <code>*.ui</code> 文件的文件名很重要”；</p>
</blockquote>
<p><code>ui_myDialog.h</code> 中自动生成的类看起来像：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-comment">// #include something</span><br><br>QT_BEGIN_NAMESPACE    <span class="hljs-comment">// Qt 独有的宏，将其中的类加入特定的namespace中</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ui_myDialog</span> &#123;        <span class="hljs-comment">// 生成类，由于它谁都不继承，功能少，通常作为中间类使用</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Widgets</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupUi</span><span class="hljs-params">(QMainWindow* myDialog)</span> </span>&#123;<br>        <span class="hljs-comment">// realize ...</span><br>    &#125;<br>&#125;;<br><br>QT_END_NAMESPACE<br><br><span class="hljs-keyword">namespace</span> Ui &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">myDialog</span>: <span class="hljs-keyword">public</span> ui_myDialog &#123;&#125;;    <span class="hljs-comment">// Qt 自动在 Ui 命名空间中</span><br>&#125;                                <span class="hljs-comment">// 定义了继承于 ui_myDialog 的类 myDialog</span><br></code></pre></td></tr></table></figure>
<p>而真正想要应用这个窗口类，需要进行<strong>多继承</strong>，使用它和 <code>QMainWindow</code> 的子类——<strong>毕竟这个类不是 <code>QObject</code>，没有办法完成信号-槽的创建</strong>；</p>
<p>所以一般情况下将 <code>ui_myDialog</code> 类作为中间类，再<strong>手动</strong>为这个窗口创建 <code>myDialog.h</code> 和 <code>myDialog.cpp</code>，分别书写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// File: myDialog.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QMainWindow&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ui_myDialog.h&quot;</span></span><br><br><span class="hljs-comment">// 请注意！！！这里的 myDialog 和之前定义在 ui_myDialog.h 文件中 Ui 命名空间中的类 myDialog 不一样！</span><br><span class="hljs-comment">// 这里的 myDialog 和 Ui::myDialog 类进行了继承，使 myDialog 具有了 Ui::myDialog 类一样的控件作为属性</span><br><span class="hljs-comment">// 同时 myDialog 还和 QMainWindow 进行多继承，使 myDialog 还具有 QMainWindow的属性</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myDialog</span> : <span class="hljs-keyword">public</span> QMainWindow, <span class="hljs-keyword">public</span> Ui::myDialog &#123;<br>    Q_OBJECT        <span class="hljs-comment">// 为何需要继承 Ui::myDialog，组合不行吗？不行。</span><br><span class="hljs-keyword">public</span>:                <span class="hljs-comment">// 因为需要修改信号-槽连接，涉及其中的控件</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">myDialog</span><span class="hljs-params">(QWidget* parent = <span class="hljs-literal">nullptr</span>)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// File: myDialog.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myDialog.h&quot;</span></span><br><br><span class="hljs-comment">// 由于 myDialog 是 QMainWindow 的子类，因此想要重用它的属性，</span><br><span class="hljs-comment">// 需要委托调用父类的构造函数：QMainWindow(parent)；</span><br><span class="hljs-comment">// 此外，setupUi(this) 是以当前窗口为顶级控件，按 UI 设计部署控件</span><br>myDialog::<span class="hljs-built_in">myDialog</span>(QWidget* parent)<br>    : <span class="hljs-built_in">QMainWindow</span>(parent)<br>&#123;<br>    <span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>至此，一个只有图形界面、没有添加 槽-函数 连接的主窗口类 <code>myDialog</code> 就设计完成了；</p>
<blockquote>
<p>提示：除了上面的继承方法，还可以把 <code>Ui::myDialog</code> 作为 <code>myDialog</code> 的一个数据成员使用。</p>
</blockquote>
<h4 id="IDE-用户视角"><a href="#IDE-用户视角" class="headerlink" title="IDE 用户视角"></a>IDE 用户视角</h4><p>事实上，使用 Qt Creator 的用户在一开始，<strong>向项目中添加 <code>UI 设计师文件</code></strong>，IDE 会提示用户起名的时候，就会同时创建 <code>myDialog.ui</code>、<code>myDialog.h</code>、<code>myDialog.cpp</code> 三个文件，并更新 <code>&lt;项目名称&gt;.pro</code> 文件，直接省去非 IDE 方法中所有步骤；</p>
<p>值得一提的是，Qt Creator 在编译时生成的 <code>ui_myDialog.h</code> 不在项目目录中（也许是考虑到相关性），而藏在上层 build_XXX 目录里，不过使用的时候也无需注意，因为引入工作已经在自动生成的 <code>myDialog.h</code> 中写好了；</p>
<p>这下关于 Qt Designer 的运行机制、IDE 封装的机制是不是更清楚了呢？</p>
<h3 id="2-2-3-案例演示"><a href="#2-2-3-案例演示" class="headerlink" title="2.2.3 案例演示"></a>2.2.3 案例演示</h3><blockquote>
<p>本节将一步步地完成 2.2.1 中的窗体设计目标；将以非 IDE 的方式完成（IDE 的操作简单就不演示了）（<strong>注意，它的角色是子窗口</strong>）</p>
</blockquote>
<ol>
<li><p>创建一个项目目录：新建项目文件夹 <code>testUI</code>，创建文件 <code>main.cpp</code>、<code>GoToCellDialog.cpp</code>、<code>GoToCellDialog.h</code>；</p>
</li>
<li><p>打开 Qt Designer，选择 <code>Dialog without button</code> 模板，按照图中要求设计出 UI，窗体命名为 <code>GoToCellDialog</code>（<code>objectName</code>），保存文件为 <code>GoToCellDialog.ui</code>，记得保存在项目目录中；</p>
</li>
<li><p>命令行切换至项目目录，新建目录 build（为了让项目目录更干净，build 就设置在项目目录里面，你也可以设置在其他地方，比如上层目录——Qt Creator IDE 就是这么干的），命令行切入，运行 <code>qmake -project ../</code>，向 生成的 <code>testUI.pro</code> 中添加 <code>QT += widgets</code>；</p>
</li>
<li><p>编写 Go to Cell 窗体的主要逻辑代码（包括信号-槽的定义）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// File: GoToCellDialog.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QtWidgets/QDialog&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ui_GoToCellDialog.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoToCellDialog</span> : <span class="hljs-keyword">public</span> QDialog, <span class="hljs-keyword">public</span> Ui::GoToCellDialog &#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">GoToCellDialog</span>(QWidget* parent = <span class="hljs-literal">nullptr</span>);<br>    <br><span class="hljs-comment">// 自定义槽</span><br><span class="hljs-keyword">private</span> slots:<br>    <span class="hljs-comment">// 注意：这么命名是有讲究的！！！</span><br>    <span class="hljs-comment">// 在 uic 和 moc 编译时，会识别所有 on_&lt;objectName&gt;_&lt;signalName&gt;() 命名的函数，自动连接：</span><br>    <span class="hljs-comment">// connect(lineEdit, SIGNAL(textChanged(const QString&amp;)),</span><br>    <span class="hljs-comment">//             this, SLOT(on_lineEdit_textChanged()));</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_lineEdit_textChanged</span><span class="hljs-params">()</span></span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// File: GoToCellDialog.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QtGui&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GoToCellDialog.h&quot;</span></span><br><br><span class="hljs-comment">// 这个函数中的 widget 变量名就是之前你在 GoToCellDialog.ui 设计中的 objectName</span><br>GoToCellDialog::<span class="hljs-built_in">GoToCellDialog</span>(QWidget* parent)<br>    : <span class="hljs-built_in">QDialog</span>(parent)<br>&#123;<br>    <span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);    <span class="hljs-comment">// 以当前对象为父 widget 初始化窗体部件</span><br>    <br>    <span class="hljs-function">QRegExp <span class="hljs-title">reg</span><span class="hljs-params">(<span class="hljs-string">&quot;[a-zA-Z][1-9][0-9]&#123;0,2&#125;&quot;</span>)</span></span>;        <span class="hljs-comment">// 正则表达式类</span><br>    <span class="hljs-comment">// 新方法：为 QLineEdit 类设置正则可接受检验器</span><br>    <span class="hljs-comment">// QRegExpValidator 的构造函数 第一个参数是 QRegExp（正则Pattern）</span><br>    <span class="hljs-comment">// 第二个参数是 parent，使 QRegExpValidator 对象成为 parent 的</span><br>    <span class="hljs-comment">// 子控件，这样就不要手动 delete，在父控件析构时，子控件一起析构了（之前提过）</span><br>    lineEdit-&gt;<span class="hljs-built_in">setValidator</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">QRegExpValidator</span>(reg, <span class="hljs-keyword">this</span>));<br>    <br>    <span class="hljs-comment">// 设置信号-槽</span><br>    <span class="hljs-comment">// 这里的 accept() 和 reject() 槽是 QDialog 的固有槽，</span><br>    <span class="hljs-comment">// 触发这两槽之一都会关闭窗口，但是分别会修改：</span><br>    <span class="hljs-comment">// QDialog::Accepted 和 QDialog::Rejected 数据成员的值，</span><br>    <span class="hljs-comment">// 以便主窗口判断用户执行了什么操作</span><br>    <span class="hljs-built_in">connect</span>(okBtn, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">accept</span>()));<br>    <span class="hljs-built_in">connect</span>(cancelBtn, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">reject</span>()));<br>&#125;<br><br><span class="hljs-comment">// 这里是指，当文本框改变，就进入这个函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoToCellDialog::on_lineEdit_textChanged</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 如果经过 QRegExpValidator 检查符合，那么激活 okBtn，否则禁用</span><br>    okBtn-&gt;<span class="hljs-built_in">setEnabled</span>(lineEdit-&gt;<span class="hljs-built_in">hasAcceptableInput</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// File: main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GoToCellDialog.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br>    GoToCellDialog* dialog = <span class="hljs-keyword">new</span> GoToCellDialog;<br>    <br>    dialog-&gt;<span class="hljs-built_in">show</span>();<br>    <br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>执行 <code>qmake testUI.pro</code>；</p>
</li>
<li><p><strong>Windows 用户</strong>请按照之前所说的，在当前命令行运行 <a href="#script-env">配置临时环境变量的脚本🔗</a> ；</p>
</li>
<li><p>Unix 用户 执行 <code>make</code>，Windows 用户执行 <code>mingw32-make</code>，构建完成；</p>
</li>
</ol>
<p>如此一来，一个子窗口类的演示就做好了；</p>
<h1 id="Chapter-3-Qt：样式更丰富的子窗口"><a href="#Chapter-3-Qt：样式更丰富的子窗口" class="headerlink" title="Chapter 3 Qt：样式更丰富的子窗口"></a>Chapter 3 Qt：样式更丰富的子窗口</h1><blockquote>
<p>前面几章，只是零碎地介绍基本编写方法；</p>
<p>在 1.4 中，初步学习了 面向过程的简单<strong>主窗口纯代码</strong>设计；</p>
<p>在 2.1 中，初步学习了 面向对象的简单<strong>子窗口纯代码</strong>设计；</p>
<p>在 2.2 中，初步学习了 面向对象的简单<strong>子窗口快速 UI</strong> 设计；</p>
<p>本章将介绍更多其他样式的子窗口的设计；</p>
</blockquote>
<h2 id="3-1-扩展对话框"><a href="#3-1-扩展对话框" class="headerlink" title="3.1 扩展对话框"></a>3.1 扩展对话框</h2><p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="externDialog.png" height="300px"></p>
<p>本节技术栈并没有拓展，还是之前的 Qt Creator、Qt Designer 使用技术；</p>
<p>此处仅会提及新出现的控件属性或方法等信息；</p>
<ul>
<li><code>QPushButton</code> 的属性 <code>checkable</code> ：如果修改为 <code>true</code>，则在用户点击一下后持续有效（相当于 <code>checkBox</code>），再次点击才会还原；</li>
<li><code>QPushButton</code> 的槽 <code>toggled(bool)</code>：当按钮 <code>enabled</code> 属性被改变时，<code>toggle</code> 会发射信号，参数就不用说了吧，，这个槽在按钮为 <code>checkable</code> 时有用；</li>
<li><code>QPushButton</code> 的槽 <code>setText(QString)</code>：可以在中途改变按钮的文本；</li>
<li><code>QGridLayout</code> 布局管理器：在 1.4.3 中介绍过，如果发现按钮较多，而且摆不整齐的时候可以尝试这个布局，它可以使控件按照行、列的规则摆放；</li>
<li><strong>有些人会疑惑水平/竖直分隔符（spacer）有什么用</strong>，其实它就像 Qt Designer 上画的一样，用来在窗口伸缩时，调节控件之间的位置关系的；</li>
<li>在 2.2.1 中，其实还有一种 <strong>Qt Designer 设计模式没有介绍到：Edit Signals/Slots</strong>，在此模式下可以<strong>直接编辑信号-槽连接</strong>，无需手动写 <code>connect</code> 函数；使用方法 和 Edit Buddy 模式类似，感兴趣可以尝试一下；</li>
<li><strong>新的类 <code>QGroupBox</code> 组群盒</strong>：如上图，就是那一个个小方框；</li>
<li>大多数 Widget 都有一个槽：<code>QWidget::setVisible(bool)</code>，可以理解为<strong>含参数、可重用的 <code>QWidget::close()</code>槽</strong>；</li>
<li>快捷复制：按住 CTRL，单击要复制的控件，再拖动就能复制了 ~</li>
<li><strong>新的类 <code>QComboBox</code> 下拉栏选择器</strong><ul>
<li>具有方法 <code>clear()</code>，常用在初始化时，清空选项；</li>
<li>具有方法 <code>addItem(QString)</code>，添加下拉栏内容，一般在 Qt Designer 里添加，也可自己在代码里写；</li>
<li>具有方法 <code>setMinimumSize(int)</code>，设置下拉栏的最小大小值；</li>
</ul>
</li>
<li><p><strong>新的类 <code>QChar</code> 字符类</strong></p>
<ul>
<li>具有方法 <code>unicode()</code>：转化为 unicode 码，可以运算；</li>
<li>可以作为 <code>QString</code> 的初始化参数；</li>
</ul>
</li>
<li><p><strong>设置窗口固定尺寸的常用方法：<code>layoutName-&gt;setSizeConstraint(QLayout::SetFixedSize)</code></strong>；</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// File: SortDialog.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ui_SortDialog.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QtWidgets/QDialog&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortDialog</span> : <span class="hljs-keyword">public</span> QDialog, <span class="hljs-keyword">public</span> Ui::SortDialog &#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SortDialog</span>(QWidget* parent = <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-comment">// Initialize the content of each column comboBox</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setColumnRange</span><span class="hljs-params">(QChar first, QChar last)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// File: SortDialog.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SortDialog.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QtGui&gt;</span></span><br><br>SortDialog::<span class="hljs-built_in">SortDialog</span>(QWidget* parent)<br>    : <span class="hljs-built_in">QDialog</span>(parent) &#123;<br>    <span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// Hide the group box first,</span><br>    <span class="hljs-comment">// Because the setVisible(bool) function hasn&#x27;t been called.</span><br>    secondaryGroupBox-&gt;<span class="hljs-built_in">hide</span>();<br>    tertiaryGroupBox-&gt;<span class="hljs-built_in">hide</span>();<br>    <span class="hljs-comment">// Fix the size of the window</span><br>    <span class="hljs-built_in">layout</span>()-&gt;<span class="hljs-built_in">setSizeConstraint</span>(QLayout::SetFixedSize);<br><br>    <span class="hljs-built_in">setColumnRange</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;Z&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SortDialog::setColumnRange</span><span class="hljs-params">(QChar first, QChar last)</span> </span>&#123;<br>    <span class="hljs-comment">// Clear the content of each comboBox</span><br>    primaryColCombo-&gt;<span class="hljs-built_in">clear</span>();<br>    secondaryColCombo-&gt;<span class="hljs-built_in">clear</span>();<br>    tertiaryColCombo-&gt;<span class="hljs-built_in">clear</span>();<br><br>    <span class="hljs-comment">// Optional</span><br>    secondaryColCombo-&gt;<span class="hljs-built_in">addItem</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;None&quot;</span>));<br>    tertiaryColCombo-&gt;<span class="hljs-built_in">addItem</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;None&quot;</span>));<br><br>    <span class="hljs-comment">// 由于 primaryColCombo 中显示单字符时，展示的宽度小于</span><br>    <span class="hljs-comment">// secondary 和 tertiary ColCombo 显示的 “None”，所以设置</span><br>    <span class="hljs-comment">// primaryColCombo 的最小宽度，防止宽度不相同的现象</span><br>    primaryColCombo-&gt;<span class="hljs-built_in">setMinimumSize</span>(secondaryColCombo-&gt;<span class="hljs-built_in">sizeHint</span>());<br><br>    QChar ch = first;<br>    <span class="hljs-keyword">while</span> (ch &lt;= last) &#123;<br>        primaryColCombo-&gt;<span class="hljs-built_in">addItem</span>(<span class="hljs-built_in">QString</span>(ch));<br>        secondaryColCombo-&gt;<span class="hljs-built_in">addItem</span>(<span class="hljs-built_in">QString</span>(ch));<br>        tertiaryColCombo-&gt;<span class="hljs-built_in">addItem</span>(<span class="hljs-built_in">QString</span>(ch));<br>        ch = ch.<span class="hljs-built_in">unicode</span>() + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// File: main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SortDialog.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br>    SortDialog* dialog = <span class="hljs-keyword">new</span> SortDialog;<br>    <span class="hljs-comment">// 测试函数是否能用</span><br>    dialog-&gt;<span class="hljs-built_in">setColumnRange</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>);<br>    dialog-&gt;<span class="hljs-built_in">show</span>();<br>    <br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编译运行项目即可；</p>
<h2 id="3-2-Qt-内置的更多部件和对话框"><a href="#3-2-Qt-内置的更多部件和对话框" class="headerlink" title="3.2 Qt 内置的更多部件和对话框"></a>3.2 Qt 内置的更多部件和对话框</h2><blockquote>
<p>这里仅作初步介绍，在完整项目的应用中会进一步介绍使用方法，因为一次性看完很可能记不住……</p>
</blockquote>
<ul>
<li><p>Qt 中的按钮类</p>
<ul>
<li>QPushButton：之前演示的普通按钮；</li>
<li>QToolButton：具有图标的功能按钮；</li>
<li>QCheckBox：复选框类；</li>
<li>QRadioButton：单选框类，只能在一组中选一个激活；</li>
</ul>
<p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="btns.png" height="100px"></p>
</li>
<li><p>Qt 中的单页容器部件</p>
<ul>
<li>QGroupBox：之前演示的群组框；</li>
<li>QFrame：QLabel 的父类，可以用来展示图片、文字等信息（所以 QLabel 也行）；</li>
</ul>
</li>
<li><p>Qt 中的多页容器部件</p>
<ul>
<li>QTabWidget：切换多个 Tab 的窗口控件；</li>
<li>QToolBox：切换不同工具分类的窗口控件；</li>
</ul>
<p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="multiPWidgets.png" height="200"></p>
</li>
<li><p>Qt 中的显示窗口部件：<code>QLabel</code>、<code>QLCDNumber</code>、<code>QProgressBar</code>、<code>QTextBrowser</code></p>
<p>注：QTextBrowser 是只读的 QTextEdit 子类，也可以显示带格式的文本，<strong>建议处理大型格式化文本</strong>，因为它和 QLabel 不同，可以在必要时自动提供滚动条；</p>
<p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="showWidgets.png"></p>
</li>
<li><p>Qt 中的输入窗口部件：<code>QSpinBox</code>、<code>QDoubleSpinBox</code>、<code>QComboBox</code>、<code>QDateEdit</code>、<code>QTimeEdit</code>、<code>QDateTimeEdit</code>、<code>QScrollBar</code>、<code>QSlider</code>、<code>QTextEdit</code>、<code>QLineEdit</code>、<code>QDial</code></p>
<p>注：QTextEdit 支持输入掩码、检验器（2.2.3 已演示）等功能；</p>
<p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="inputWidgets.png"></p>
</li>
<li><p>Qt 的反馈对话框：<code>QInputDialog</code>、<code>QProgressDialog</code>、<code>QMessageBox</code>、<code>QErrorMessage</code>、<code>QColorDialog</code>、<code>QFontDialog</code>、<code>QFileDialog</code>、<code>QPrintDialog</code> 等；</p>
</li>
</ul>
<h2 id="3-3-Qt-类的第二次总结-amp-下文预告"><a href="#3-3-Qt-类的第二次总结-amp-下文预告" class="headerlink" title="3.3 Qt 类的第二次总结 &amp; 下文预告"></a>3.3 Qt 类的第二次总结 &amp; 下文预告</h2><blockquote>
<p>学完了以上的知识，目前使用到的 Qt 类的框架如下图所示：</p>
</blockquote>
<p><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="C3.png"></p>
<p><strong>同系列下一篇文章预告：将会是 第一个完整的 Qt 入门项目（会非常地长，比本篇还长），目的是通过实战来学习 Qt 的更多类的用法，源代码和程序 届时会放在仓库，以供读者参考。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://sjtuxhw.top">SJTU-XHW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sjtuxhw.top/2023/07/28/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%B8%80%EF%BC%89/">https://sjtuxhw.top/2023/07/28/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%B8%80%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sjtuxhw.top" target="_blank">SJTU-XHW's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/myBlog/tags/Programming/">Programming</a><a class="post-meta__tags" href="/myBlog/tags/Qt/">Qt</a><a class="post-meta__tags" href="/myBlog/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/qt1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/myBlog/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="/myBlog/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/myBlog/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="/myBlog/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/myBlog/2023/08/07/2023-HDC-%E5%8F%82%E4%BC%9A%E7%AC%94%E8%AE%B0%E4%B8%8E%E6%84%9F%E6%82%9F/" title="2023 HDC 参会笔记与感悟"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/2023-HDC.jpg" onerror="onerror=null;src='/myBlog/img/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2023 HDC 参会笔记与感悟</div></div></a></div><div class="next-post pull-right"><a href="/myBlog/2023/07/21/CMake-%E8%BF%9B%E9%98%B6/" title="CMake 进阶"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/cmake.png" onerror="onerror=null;src='/myBlog/img/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CMake 进阶</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/myBlog/2023/08/30/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%B8%89%EF%BC%89/" title="从C++入门Qt（三）"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/qt3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="title">从C++入门Qt（三）</div></div></a></div><div><a href="/myBlog/2023/08/16/%E4%BB%8EC-%E5%85%A5%E9%97%A8Qt%EF%BC%88%E4%BA%8C%EF%BC%89/" title="从C++入门Qt（二）"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/qt2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-16</div><div class="title">从C++入门Qt（二）</div></div></a></div><div><a href="/myBlog/2023/09/17/CSAPP-Notes-Part-1/" title="CSAPP Notes Part 1"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="title">CSAPP Notes Part 1</div></div></a></div><div><a href="/myBlog/2023/11/11/CSAPP-Notes-Part-2/" title="CSAPP Notes Part 2"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/csapp_p2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-11</div><div class="title">CSAPP Notes Part 2</div></div></a></div><div><a href="/myBlog/2023/04/28/GNU-Tutor/" title="GNU-Tutor"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/GNU-Tutor.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="title">GNU-Tutor</div></div></a></div><div><a href="/myBlog/2023/04/28/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Git学习笔记"><img class="cover" src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/git.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="title">Git学习笔记</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="/myBlog/img/favicon.ico" onerror="this.onerror=null;this.src='/myBlog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SJTU-XHW</div><div class="author-info__description">A blog to document learning and life</div></div><div class="card-info-data site-data is-center"><a href="/myBlog/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/myBlog/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/myBlog/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://sjtuxhw.top/myBlog/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! ‎|•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-0-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">Chapter 0 前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-C-%E5%9F%BA%E7%A1%80-%E5%92%8C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-text">0.1 C++ 基础 和 面向对象编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-2-C-%E7%9A%84%E5%AE%8F%EF%BC%88macro%EF%BC%89"><span class="toc-text">0.2 C++ 的宏（macro）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-3-Qt-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">0.3 Qt 环境配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-Qt-%E5%88%9D%E8%AE%A4%E8%AF%86"><span class="toc-text">Chapter 1 Qt 初认识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">1.1 简单示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%A6%81%E7%82%B9%EF%BC%9A%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88qmake%EF%BC%89%E5%88%9B%E5%BB%BA%E3%80%81%E7%BC%96%E8%AF%91-Qt-%E5%B7%A5%E7%A8%8B"><span class="toc-text">1.2 要点：通过命令行（qmake）创建、编译 Qt 工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E-IDE-%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E3%80%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-Qt-%E9%A1%B9%E7%9B%AE"><span class="toc-text">非 IDE 用户如何创建、编译运行 Qt 项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDE-%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E3%80%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-Qt-%E9%A1%B9%E7%9B%AE"><span class="toc-text">IDE 用户如何创建、编译运行 Qt 项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-EX-%E4%BD%BF%E7%94%A8-CMake-%E4%BB%A3%E6%9B%BF-qmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">1.2-EX 使用 CMake 代替 qmake 构建项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-text">1.3 建立连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">1.3.1. 信号与槽的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">1.3.2. 示例代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Qt-%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1"><span class="toc-text">1.4 Qt 窗口的布局设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-widget-%E9%97%B4%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB"><span class="toc-text">1.4.1 widget 间的父子关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">1.4.2 布局设计的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.4.3 布局管理器的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E7%AB%A0%E6%9C%AB%E8%B4%B4%E5%A3%AB"><span class="toc-text">1.5 章末贴士</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84-Qt"><span class="toc-text">Chapter 2 面向对象的 Qt</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%BA%AF%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.1 纯代码设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BB%A5%E7%AE%80%E5%8D%95%E5%AF%B9%E8%AF%9D%E6%A1%86%E4%B8%BA%E4%BE%8B"><span class="toc-text">2.1.1 示例：以简单对话框为例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3%E4%BF%A1%E5%8F%B7-%E6%A7%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">2.1.2 进一步了解信号-槽机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-Qt-%E7%9A%84%E5%85%83%E5%AF%B9%E8%B1%A1%E7%BC%96%E8%AF%91%E5%99%A8-moc-%E5%92%8C-%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F"><span class="toc-text">2.1.3 Qt 的元对象编译器 moc 和 元对象系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Qt-Designer%EF%BC%9AUI-%E5%BF%AB%E9%80%9F%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.2 Qt Designer：UI 快速设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-Qt-Designer-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">2.2.1 Qt Designer 的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-Qt-Designer-%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91"><span class="toc-text">2.2.2 Qt Designer 的运行原理【重要】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E-IDE-%E7%94%A8%E6%88%B7%E7%9A%84%E8%A7%86%E8%A7%92"><span class="toc-text">非 IDE 用户的视角</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IDE-%E7%94%A8%E6%88%B7%E8%A7%86%E8%A7%92"><span class="toc-text">IDE 用户视角</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-text">2.2.3 案例演示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-Qt%EF%BC%9A%E6%A0%B7%E5%BC%8F%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%AD%90%E7%AA%97%E5%8F%A3"><span class="toc-text">Chapter 3 Qt：样式更丰富的子窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%89%A9%E5%B1%95%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-text">3.1 扩展对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Qt-%E5%86%85%E7%BD%AE%E7%9A%84%E6%9B%B4%E5%A4%9A%E9%83%A8%E4%BB%B6%E5%92%8C%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-text">3.2 Qt 内置的更多部件和对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Qt-%E7%B1%BB%E7%9A%84%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%80%BB%E7%BB%93-amp-%E4%B8%8B%E6%96%87%E9%A2%84%E5%91%8A"><span class="toc-text">3.3 Qt 类的第二次总结 &amp; 下文预告</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2024/02/27/React%E6%A1%86%E6%9E%B6%E9%80%9F%E9%80%9A/" title="React框架速通"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/react.jpg" onerror="this.onerror=null;this.src='/myBlog/img/404.png'" alt="React框架速通"/></a><div class="content"><a class="title" href="/myBlog/2024/02/27/React%E6%A1%86%E6%9E%B6%E9%80%9F%E9%80%9A/" title="React框架速通">React框架速通</a><time datetime="2024-02-27T07:30:41.000Z" title="发表于 2024-02-27 15:30:41">2024-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2024/02/25/JavaScript%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/" title="JavaScript入门笔记-(2)"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/javascript2.jpeg" onerror="this.onerror=null;this.src='/myBlog/img/404.png'" alt="JavaScript入门笔记-(2)"/></a><div class="content"><a class="title" href="/myBlog/2024/02/25/JavaScript%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/" title="JavaScript入门笔记-(2)">JavaScript入门笔记-(2)</a><time datetime="2024-02-25T03:25:22.000Z" title="发表于 2024-02-25 11:25:22">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2024/02/20/JavaScript%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" title="JavaScript入门笔记"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/javascript.jpg" onerror="this.onerror=null;this.src='/myBlog/img/404.png'" alt="JavaScript入门笔记"/></a><div class="content"><a class="title" href="/myBlog/2024/02/20/JavaScript%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" title="JavaScript入门笔记">JavaScript入门笔记</a><time datetime="2024-02-20T13:17:09.000Z" title="发表于 2024-02-20 21:17:09">2024-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2024/01/15/%E6%B5%85%E6%9E%90-TTY-Subsystem/" title="浅析 TTY Subsystem"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/tty.jpg" onerror="this.onerror=null;this.src='/myBlog/img/404.png'" alt="浅析 TTY Subsystem"/></a><div class="content"><a class="title" href="/myBlog/2024/01/15/%E6%B5%85%E6%9E%90-TTY-Subsystem/" title="浅析 TTY Subsystem">浅析 TTY Subsystem</a><time datetime="2024-01-14T23:12:02.000Z" title="发表于 2024-01-15 07:12:02">2024-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2024/01/13/%E6%94%BE%E5%81%87%EF%BC%81%E5%90%90%E6%A7%BD%EF%BC%81/" title="放假！吐槽！"><img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="https://cdn.sjtuxhw.top/cover_imgs/tease.jpg" onerror="this.onerror=null;this.src='/myBlog/img/404.png'" alt="放假！吐槽！"/></a><div class="content"><a class="title" href="/myBlog/2024/01/13/%E6%94%BE%E5%81%87%EF%BC%81%E5%90%90%E6%A7%BD%EF%BC%81/" title="放假！吐槽！">放假！吐槽！</a><time datetime="2024-01-13T06:33:01.000Z" title="发表于 2024-01-13 14:33:01">2024-01-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By SJTU-XHW  |  tech SJTU saves the world</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> &nbsp;|&nbsp;&nbsp;本网站由 <img src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="/img/upCloud_logo.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/myBlog/js/utils.js"></script><script src="/myBlog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.sjtuxhw.top',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(init)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.sjtuxhw.top',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="https://cdn.sjtuxhw.top/cover_imgs/lazyload.gif" data-original="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.sjtuxhw.top',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script src="/myBlog/js/jquery-3.7.0.min.js"></script><script src="/myBlog/js/rightmenu.js"></script><div class="aplayer no-destroy" data-id="6898044781" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"></div><script src="/myBlog/js/mourn.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="/myBlog/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/myBlog/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/myBlog/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: true,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>