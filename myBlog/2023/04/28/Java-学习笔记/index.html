<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 学习笔记（1） | SJTU-XHW's blog</title><meta name="author" content="SJTU-XHW,sjtuxhw12345@sjtu.edu.cn"><meta name="copyright" content="SJTU-XHW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Attention: 本文建立在具有一定 C++基础知识的前提上 Reference: Introduction to Java Programming 10th Edition (Y. Daniel Liang) 郑重声明：本文原创，资料引用已在原文相应位置进行标注，感谢为我们无偿提供知识和技术指导的创作者们，转载请注明">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 学习笔记（1）">
<meta property="og:url" content="https://sjtuxhw.top/2023/04/28/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="SJTU-XHW&#39;s blog">
<meta property="og:description" content="Attention: 本文建立在具有一定 C++基础知识的前提上 Reference: Introduction to Java Programming 10th Edition (Y. Daniel Liang) 郑重声明：本文原创，资料引用已在原文相应位置进行标注，感谢为我们无偿提供知识和技术指导的创作者们，转载请注明">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/java1.jpeg">
<meta property="article:published_time" content="2023-04-27T16:58:09.000Z">
<meta property="article:modified_time" content="2023-09-19T05:18:46.000Z">
<meta property="article:author" content="SJTU-XHW">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/java1.jpeg"><link rel="shortcut icon" href="/myBlog/img/favicon.ico"><link rel="canonical" href="https://sjtuxhw.top/2023/04/28/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/myBlog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?64dd3b0c09c8af7b916f8249d32097e2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/myBlog/',
  algolia: undefined,
  localSearch: {"path":"/myBlog/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 学习笔记（1）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-19 13:18:46'
}</script><link rel="stylesheet" href="/myBlog/css/mouseConfig.css"><link rel="stylesheet" href="/myBlog/css/valineBg.css"><link rel="stylesheet" href="/myBlog/css/rightmenu.css"><link rel="stylesheet" href="/myBlog/css/custom_music.css"><link rel="stylesheet" href="/myBlog/css/addFonts.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/myBlog/atom.xml" title="SJTU-XHW's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myBlog/img/favicon.ico" onerror="onerror=null;src='img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/myBlog/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/myBlog/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/myBlog/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/myBlog/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/myBlog/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/myBlog/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/java1.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/myBlog/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myBlog/img/head_icon.png" alt="Logo"><span class="site-name">SJTU-XHW's blog</span></a><a class="nav-page-title" href="/myBlog/"><span class="site-name">Java 学习笔记（1）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/myBlog/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/myBlog/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/myBlog/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/myBlog/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/myBlog/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java 学习笔记（1）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-27T16:58:09.000Z" title="发表于 2023-04-28 00:58:09">2023-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-19T05:18:46.000Z" title="更新于 2023-09-19 13:18:46">2023-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/myBlog/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/myBlog/2023/04/28/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><i>Attention: 本文建立在具有一定 C++基础知识的前提上</i></p>
<p><i>Reference: Introduction to Java Programming 10th Edition (Y. Daniel Liang)</i></p>
<p><u>郑重声明：本文原创，资料引用已在原文相应位置进行标注，感谢为我们无偿提供知识和技术指导的创作者们，转载请注明</u></p>
<hr>
<span id="more"></span>
<h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><h3 id="解释型语言和编译型语言的区别"><a href="#解释型语言和编译型语言的区别" class="headerlink" title="解释型语言和编译型语言的区别"></a>解释型语言和编译型语言的区别</h3><h4 id="编译型语言（以C-为例）的编译运行过程"><a href="#编译型语言（以C-为例）的编译运行过程" class="headerlink" title="编译型语言（以C++为例）的编译运行过程"></a>编译型语言（以C++为例）的编译运行过程</h4><ol>
<li>预编译（*.c/cpp &amp; *.h —&gt; *.i ）：<strong>对应gcc/g++命令：<code>gcc -E [xxx] -o [output.i]</code></strong><ul>
<li>展开所有宏定义#define（字符替换）；</li>
<li>处理所有条件预编译命令（#ifdef、#ifndef、#endif等）；</li>
<li>处理#include，具体操作是将指向的文件直接插入到文件的这一行（严格遵循上一步的条件）；</li>
<li>删除所有注释；</li>
<li>添加行号、文件标识，以便调试/编译出错时及时指出；</li>
<li>保留#pragma指令，以供编译器使用；</li>
</ul>
</li>
<li>编译（*.i —&gt; *.s ，即高级语言转汇编语言）：<strong>对应gcc/g++命令：<code>gcc -S [xxx] -o [output.s]</code></strong><ul>
<li>词法分析、语法分析、语义分析（前端）；</li>
<li>生成中间代码、优化，生成目标代码（解释型语言无需做此步，生成中间代码后直接对语义执行）；</li>
<li>编译原理入门：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/fisherss/p/13905395.html">https://www.cnblogs.com/fisherss/p/13905395.html</a></li>
</ul>
</li>
<li>汇编（*.s —&gt; *.o/obj，即汇编语言转机器语言）：<strong>对应gcc/g++命令：<code>gcc -c [xxx] -o [output.o/obj]</code></strong><ul>
<li>类Unix系统下生成*.o，Windows系统下生成*.obj；</li>
</ul>
</li>
<li>链接（*.o —&gt; *.out/exe，链接各种需要的库和其他目标文件）：<strong>对应gcc/g++命令：<code>gcc [xxx] -o [output]</code></strong></li>
<li>生成调试文件（供gdb使用，<strong>对应gcc/g++命令：<code>gcc [xxx] -g -o [output]</code></strong>）<ul>
<li>也支持<code>-o</code>参数：<code>-O</code>（默认）、<code>-O1</code>（尝试减少代码体积和代码运行时间，但是并不执行会花费大量时间的优化操作）、<code>-O2</code>（包含 -O1的优化并增加了不需要在目标文件大小和执行速度上进行折衷的优化，会花费更多的编译时间当然也会生成性能更好的代码）、<code>-O3</code></li>
</ul>
</li>
</ol>
<h4 id="解释型语言的运行过程"><a href="#解释型语言的运行过程" class="headerlink" title="解释型语言的运行过程"></a>解释型语言的运行过程</h4><p>前端分析“三件套” + 生成中间代码 + 解释器解释执行</p>
<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./CompileAndExplain.png"></p>
<blockquote>
<p>注：字节码是低级语言</p>
</blockquote>
<h4 id="可惜Java是“半解释型语言”！"><a href="#可惜Java是“半解释型语言”！" class="headerlink" title="可惜Java是“半解释型语言”！"></a>可惜Java是“半解释型语言”！</h4><blockquote>
<p>Java程序既要<strong>编译</strong>为class文件，同时class文件也要经过JVM的<strong>解释运行</strong></p>
<p><strong>刚入门暂时略过此处有难度的部分，详细参考黑皮书《深入了解Java虚拟机》</strong></p>
<p>Java虚拟机是一种解释器，是解释Java字节码（*.class）的一种程序，</p>
<p>简单解释过程：运行<strong>类加载器</strong>将字节码加载到内存中 —-&gt; 运行<strong>字节码验证器</strong>强制检查Java程序合法性和安全性，不符合安全规范的不予运行 —-&gt; 读取内存中的字节码逐句解释为机器码执行；</p>
</blockquote>
<ol>
<li><p>Java源文件编译（*.java -&gt; *.class）：<code>javac [*.java]</code></p>
</li>
<li><p>Java字节码解释运行：<code>java [className]</code></p>
<blockquote>
<p>Attention: 如果填className=”myclass.class”，那么解释器会去找<code>myclass.class.class</code>！所以搞清类名；</p>
<p>字节码运行提醒：</p>
<ul>
<li>Java指令默认寻找class文件通过环境变量<code>CLASSPATH</code>指定目录进行，大部分情况下当前目录不在其中，通常需要在其中添加条目<code>.;</code></li>
<li>Java对class文件执行强依赖于package路径。运行时严格按照<code>pwd</code>+文件中的包名+类名搜索class文件；</li>
<li>一般大项目没有这么运行的，因为依赖的源文件较多，建议使用IDE、Maven（管理Java库*.jar（二进制）的存储、分发）等工具；别问为什么没有CMake一样管理编译的工具，也别问为什么C++没有库管理工具（C++是头文件+*.dll/so/a/lib，一般靠官网下载）；</li>
</ul>
<p>如果类在包中，举例：<code>priv.hello.myPackage</code>（源码的包导入声明也这么写的），包存在<code>/home/xxx/src/</code>下，那么需要：</p>
<ul>
<li><code>CLASSPATH</code>中存在当前目录（可以按照上面所说添加<code>.;</code>）；</li>
<li>当前命令行位于src（即包名+类名整体的上一级）；</li>
</ul>
<p>此时不能写<code>java myclass</code>（包路径缺失）、不能写<code>java myclass.class</code>（后缀重复）；</p>
<p>此时正确写法是：<code>java priv.hello.myPackage.myclass</code></p>
</blockquote>
</li>
<li><p>Java的变量存储机制：既然已经充分了解C++，那么敞开天窗说亮话——</p>
<ul>
<li><p><strong>Java 中绝大多数对象都包装的比C++好，不需要指针（也没有），创建对象（new）时，由 JVM 在堆中自动分配动态空间，GC也一般不需要编写者关心。所以绝大多数情况下，接触到的类型对象都是“引用”类型，和Python很像</strong></p>
<blockquote>
<p>这种“引用”是可以更改的引用，<strong>和C++的“引用类型”不同</strong>，此后不再赘述</p>
</blockquote>
</li>
<li><p>方法调用及存储、方法中的局部变量等都存放于栈中；</p>
</li>
</ul>
</li>
</ol>
<h3 id="操作系统认知"><a href="#操作系统认知" class="headerlink" title="操作系统认知"></a>操作系统认知</h3><ul>
<li>控制、监视系统活动：识别输入、发送输出、跟踪文件动态、控制外部设备</li>
<li>分配系统资源：确定某一程序需要哪些计算机资源</li>
<li>调度：多道程序设计（multiprogramming）、多线程、并行处理</li>
</ul>
<h3 id="Java-认知"><a href="#Java-认知" class="headerlink" title="Java 认知"></a>Java 认知</h3><ul>
<li><p>常用于开发：Web应用程序、服务端应用程序、安卓应用程序等</p>
</li>
<li><p>Java版本：JavaSE（标准版，其他所有版本基础，重点）、JavaEE（企业版）、JavaME（微型版）</p>
<blockquote>
<p>目前以 JavaSE 8为例，对应的开发工具包为JDK（全部可以基于命令行），也可使用主流IDE进行编写</p>
</blockquote>
</li>
</ul>
<h2 id="Java-基本语法"><a href="#Java-基本语法" class="headerlink" title="Java 基本语法"></a>Java 基本语法</h2><h3 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h3><ol>
<li><p>每个Java程序都至少应该有一个class，<strong>通常大写开头</strong>（区分大小写）、驼峰命名；</p>
<blockquote>
<p><strong>Java 的 public类名必须和当前的java类文件（*.java）同名！！！</strong></p>
<p>这意味着一个*.java类文件中只能定义一个同名、public的类</p>
</blockquote>
</li>
<li><p>Java程序必须有主方法<code>main</code>、语句以分号结尾（同C++）；</p>
</li>
<li><p>Java注释方法、程序块的大括号划分同C++；</p>
</li>
<li><p>在单一的项目内，哪怕源文件很少，也建议将源文件放入“package”（实质是目录）中来组织项目；</p>
<ul>
<li><p>目的：防止同名，限制作用域；增强可读性；提升封装性；</p>
</li>
<li><p>命名：所有字符必须是小写字母，不得有特殊字符；</p>
</li>
<li><p>可以有多层；包导入的时候，每层由“.”隔开；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com一般约定俗称是公司开发的，还可以是team，或者indi（个人项目）、onem（单人项目）、pers（个人发起的项目，有其他人合作）、priv（私有项目）；这里指示包位于：项目根目录/com/hello/myPackage 中。</span></span><br><span class="line"><span class="keyword">package</span> com.hello.myPackage;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>和C++一样，有次行风格和行尾风格两种规范，各有优点，不建议混用；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不良风格示范</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;<span class="comment">// 次行风格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">// 行尾风格</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="基本程序设计（与C-相同部分省略）：基础与数据类型"><a href="#基本程序设计（与C-相同部分省略）：基础与数据类型" class="headerlink" title="基本程序设计（与C++相同部分省略）：基础与数据类型"></a>基本程序设计（与C++相同部分省略）：基础与数据类型</h3><h4 id="包引入、包声明"><a href="#包引入、包声明" class="headerlink" title="包引入、包声明"></a>包引入、包声明</h4><ul>
<li><code>import java.util.Scanner(库名);</code></li>
<li><code>package priv.hello.myPackage(包);</code></li>
<li>所有Java程序中，自动隐式导入包<code>java.lang</code>，内含<code>System</code>类、<code>Math</code>类等，无需手动添加；</li>
</ul>
<h4 id="变量命名规范、声明、定义"><a href="#变量命名规范、声明、定义" class="headerlink" title="变量命名规范、声明、定义"></a>变量命名规范、声明、定义</h4><h4 id="命名常量的定义（C-中的常量const）"><a href="#命名常量的定义（C-中的常量const）" class="headerlink" title="命名常量的定义（C++中的常量const）"></a>命名常量的定义（C++中的常量const）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// final &lt;TYPE&gt; &lt;NAME&gt; = &lt;VAL&gt;;</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159265358979</span>;</span><br></pre></td></tr></table></figure>
<p>等价于C++中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159265358979</span>;</span><br></pre></td></tr></table></figure>
<p><strong>注意：Java的常量和C++的不同！Java常量允许仅定义，后来可以赋一次值，但C++要求常量的定义和初始化必须在一起，如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> PI;</span><br><span class="line">PI = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="comment">// 不允许第二次赋值：</span></span><br><span class="line"><span class="comment">// PI = 0;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// 不允许：</span></span><br><span class="line"><span class="comment">// const double PI;</span></span><br><span class="line"><span class="comment">// PI = 3.14;</span></span><br></pre></td></tr></table></figure>
<h4 id="赋值语句、赋值表达式"><a href="#赋值语句、赋值表达式" class="headerlink" title="赋值语句、赋值表达式"></a>赋值语句、赋值表达式</h4><blockquote>
<p>注：Java中字符串和Python一样，允许直接相加，并且存在整型—-&gt;字符串的自动类型转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span> + a + <span class="string">&quot;Java!&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="标准输入输出（初认识）"><a href="#标准输入输出（初认识）" class="headerlink" title="标准输入输出（初认识）"></a>标准输入输出（初认识）</h4><blockquote>
<p>Java 使用 System.in、System.out （类）作为标准输入输出；</p>
<p>可惜不支持控制台直接输入，需要引入包：<code>java.util.Scanner</code>，也可通配符导入：<code>import java.util.*;</code></p>
<p>其中含有<code>Scanner</code>类，初始化一个实例对象，以便使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> input.nextDouble();</span><br></pre></td></tr></table></figure>
<p>输入不是double，或者不能自动类型转换为double时，抛出异常；</p>
<p>除了double以外，还接受：byte、short、int、long、float等类型，有对应的方法；</p>
</blockquote>
<ul>
<li>输入输出命令行重定向（类似大部分Linux命令可重定向）<ul>
<li><code>java [className] &lt; input.txt</code>（输入卡）</li>
<li><code>java [className] &gt; output.txt</code></li>
<li><code>java [className] &lt; input.txt &gt; output.txt</code></li>
</ul>
</li>
</ul>
<h4 id="数据类型入门"><a href="#数据类型入门" class="headerlink" title="数据类型入门"></a>数据类型入门</h4><ol>
<li><strong>byte</strong>：8 bit（1Byte）含符号整型（$-2^72^7-1$）;</li>
<li>short：16 bit（2Bytes）含符号整型；</li>
<li>int：32bit（4Bytes）；</li>
<li>long：64bit（8Bytes）；</li>
<li>float：32bit（4Bytes）；</li>
<li>double：64bit（8Bytes）；</li>
<li><strong>boolean</strong>：官方文档表示大小没有严格规定，有时作为int，有时作为byte，可以将其看作“最窄类型”；</li>
<li>char：16bit（<strong>2Bytes</strong>）；</li>
<li>String（java.lang类），详细内容以后叙述</li>
</ol>
<p><strong>注意：还有一点和C++类似——数值型直接量</strong>（literal），书写方法与C++相似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xFFFF</span>;</span><br><span class="line"><span class="number">2147483648L</span>;</span><br><span class="line"><span class="number">0.3F</span>/<span class="number">1.0</span>;</span><br><span class="line"><span class="number">100.2d</span>;</span><br><span class="line"><span class="number">1.23E-2</span>;</span><br><span class="line"><span class="comment">// 为提高可读性，Java中允许在数字间加入下划线，但必须置于两个数间：</span></span><br><span class="line"><span class="number">2324_4545_4519_3415L</span>;</span><br></pre></td></tr></table></figure>
<h4 id="数值运算符、增强赋值操作符、自加自减运算符、逻辑运算符（绝大部分与C-相同）"><a href="#数值运算符、增强赋值操作符、自加自减运算符、逻辑运算符（绝大部分与C-相同）" class="headerlink" title="数值运算符、增强赋值操作符、自加自减运算符、逻辑运算符（绝大部分与C++相同）"></a>数值运算符、增强赋值操作符、自加自减运算符、逻辑运算符（绝大部分与C++相同）</h4><blockquote>
<p>注：Java中有API接口库 Math，，包含方法pow进行幂运算，更多方法自行探索：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">4</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><h4 id="强制（显式）类型转换、自动类型转换，及其原则（和C-有所不同）"><a href="#强制（显式）类型转换、自动类型转换，及其原则（和C-有所不同）" class="headerlink" title="强制（显式）类型转换、自动类型转换，及其原则（和C++有所不同）"></a>强制（显式）类型转换、自动类型转换，及其原则（和C++有所不同）</h4><ol>
<li>支持的自动类型转换：绝大多数是宽类型=&gt;缩窄类型/同等宽窄类型<ul>
<li>char &lt;=&gt; int &lt;=&gt; short &lt;=&gt; byte；</li>
<li>double =&gt; float（反过来不行，double也不能到其他整型类型）；</li>
<li>boolean最窄，不支持绝大多数自动类型转换，甚至强制类型转换也不行；</li>
<li><strong>int/double +(operator) String =&gt; String </strong>，只有使用“+”运算符才可将数值型自动类型转换为String，也可以用专用转换函数；</li>
</ul>
</li>
<li>支持的强制类型转换<ul>
<li>char、int、short、byte、double、float间均可；</li>
</ul>
</li>
</ol>
<blockquote>
<p>警告：Java中不允许缩窄类型不显式指明进行初始化/类型转换（<strong>这样导致很多与C++操作不同之处，例如没法直接<code>if（&lt;int&gt;）</code>来判断整型的真假</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 不允许：</span></span><br><span class="line"><span class="comment">// float x = 1.12;</span></span><br><span class="line"><span class="comment">// byte y = x;</span></span><br><span class="line"><span class="comment">// if (x) &#123; System.out.println(x); &#125;</span></span><br><span class="line"><span class="comment">// 正确写法：</span></span><br><span class="line"><span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1.12f</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">byte</span>)x;</span><br><span class="line"><span class="keyword">if</span> (x != <span class="number">0</span>) &#123; System.out.println(x); &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="常见错误：与C-相同"><a href="#常见错误：与C-相同" class="headerlink" title="常见错误：与C++相同"></a>常见错误：与C++相同</h4><blockquote>
<p>使用未声明/定义/初始化的变量、整型溢出、取整错误等；</p>
</blockquote>
<h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><ol>
<li><p>时间工具</p>
<blockquote>
<p>Java System类中提供<code>currentTimeMillis()</code>方法，返回从1970年1月1日 00:00:00（UNIX首次发布时间，又称UNIX时间戳-UNIX epoch）至今经历的毫秒数；</p>
</blockquote>
</li>
<li><p>Math类</p>
<p>Java Math类中提供相当多的数学支持：</p>
<ul>
<li><code>[0.0, 1.0)</code>间的均匀伪随机分布数：<code>Math.random()</code>；</li>
<li>sin、cos、tan、asin、acos、atan（均以弧度为单位）、toRadians、toDegrees；</li>
<li>exp、log、log10、pow、sqrt；</li>
<li>ceil（向上取整）、floor（向下取整）、rint（最接近的整数）、round（四舍五入，相当于<code>floor(x + 0.5)</code>）;</li>
<li>max、min、abs；</li>
</ul>
</li>
</ol>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ul>
<li>通过IDE界面调试（图形化）；</li>
<li>命令行调试：<code>jdb</code>程序（类似C++的<code>gdb</code>）;</li>
</ul>
<h3 id="基本程序设计：字符与字符串与格式化输出"><a href="#基本程序设计：字符与字符串与格式化输出" class="headerlink" title="基本程序设计：字符与字符串与格式化输出"></a>基本程序设计：字符与字符串与格式化输出</h3><ol>
<li>字符 char（2Bytes）</li>
</ol>
<blockquote>
<p>遵循和C++一样的内码规则（ASCII），允许比较、参与数值计算、合并打印等；</p>
</blockquote>
<ol>
<li>字符串类 String（java.lang包中的<strong>引用类型（和C++的引用是否相同？以后讨论）</strong>）</li>
</ol>
<blockquote>
<p>常用操作方法：</p>
<p><code>length()</code>、<code>charAt(index)</code>（和其他语言的at索引一样，越界会抛出异常）、<code>indexOf()/lastIndexOf()</code>、<code>toUpperCase()/toLowerCase()</code></p>
<p><code>concat(other_str)</code>：拼接字符串，返回新值（建议用“+”/“+=”，更方便）；</p>
<p><code>substring(begin, end)</code>：取子串；</p>
<p><code>trim()</code>：去掉两边空白字符，类似Python的<code>strip()</code>；</p>
<p>常用比较方法：</p>
<p><code>equals(other_str)</code>（仅看内容是否相等的话，<strong>和C++一样，不能用==操作符！</strong>因为String是引用类型，只能说明地址是否一致）、<code>equalsIgnoreCase(...)</code>、<code>compareTo(...)</code>（返回第一个不同的位置上的字符之差）、<code>startWith(prefix)</code>、<code>endWith(suffix)</code>、<code>contains(...)</code></p>
<p>常用转换方法：</p>
<p>除了之前介绍的“+”operator，还可以用内置包<code>java.lang</code>的类<code>Integer</code></p>
<p>、<code>Double</code>中的<code>Integer.parseInt(...)</code>、<code>Double.parseDouble(...)</code></p>
<p>字符串和输入输出：Scanner类中的实例方法<code>next()</code>专门捕获字符串，遇到空白字符停止（空白字符定义同C++，包括space、制表符、换行符等），<strong>不从缓冲区拿走空白字符</strong>；</p>
<p>还有<code>nextLine()</code>，不过遇到回车键停止，和C++一样，注意中间的联用问题；</p>
</blockquote>
<ol>
<li>格式化输出：<code>System.out.printf(&lt;pattern&gt; [args])</code></li>
</ol>
<blockquote>
<p>格式标记符与Python完全相同（例如%d、%4.2f、%s、%%等，唯一一种不同的是%c、%Nc，同时%后、数字前加负号表示<strong>左对齐</strong>），只不过不需要“%”外部标记；</p>
</blockquote>
<h3 id="基本程序设计：条件与分支"><a href="#基本程序设计：条件与分支" class="headerlink" title="基本程序设计：条件与分支"></a>基本程序设计：条件与分支</h3><h4 id="比较操作符、条件表达式和三目运算符"><a href="#比较操作符、条件表达式和三目运算符" class="headerlink" title="比较操作符、条件表达式和三目运算符"></a>比较操作符、条件表达式和三目运算符</h4><blockquote>
<p>由于Java中不允许缩窄类型不显式指明进行初始化/类型转换，只有boolean类型</p>
</blockquote>
<h4 id="if-else-if-else语句"><a href="#if-else-if-else语句" class="headerlink" title="if - [else if] - else语句"></a>if - [else if] - else语句</h4><h4 id="switch-case-default-语句"><a href="#switch-case-default-语句" class="headerlink" title="switch - case - [default]语句"></a>switch - case - [default]语句</h4><blockquote>
<p>和C++类似，只有特定数据类型才能作为switch的变量：byte、char、short、int、String等；</p>
</blockquote>
<h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><blockquote>
<p>忘记必要的大括号、测试浮点数的相等性等；</p>
</blockquote>
<h3 id="基本程序设计：循环（全部与C-相同😂）"><a href="#基本程序设计：循环（全部与C-相同😂）" class="headerlink" title="基本程序设计：循环（全部与C++相同😂）"></a>基本程序设计：循环（全部与C++相同😂）</h3><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><h4 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h4><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><h4 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h4><blockquote>
<p>同样，不应该使用浮点数作为条件</p>
</blockquote>
<h3 id="基本程序设计：方法"><a href="#基本程序设计：方法" class="headerlink" title="基本程序设计：方法"></a>基本程序设计：方法</h3><blockquote>
<p>由于Java的函数全都包裹在类中，所以将Java的函数都称作<strong>方法</strong>！</p>
</blockquote>
<p><strong>Java不允许分支控件有部分没有返回值，会抛出编译错误。但C++只会编译警告（如果经过没有返回值的分支，则返回一个没有初始化为0/空的对应类型的对象）</strong></p>
<ol>
<li><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数列表） &#123;</span><br><span class="line">    方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法签名：方法名+参数列表；</p>
</li>
<li><p>调用堆栈结构：同C++</p>
</li>
<li><p>方法重载：注意的点也同C++，注意歧义调用（可以自动类型转换的值）</p>
</li>
<li><p><strong>可惜的是，目前为止Java所有方法的参数传递都是值传递</strong></p>
</li>
<li><p><strong>更可惜的是，Java的方法参数不能指定默认值，只能使用重载实现类似效果</strong></p>
</li>
</ol>
<h3 id="基本程序设计：一维数组"><a href="#基本程序设计：一维数组" class="headerlink" title="基本程序设计：一维数组"></a>基本程序设计：一维数组</h3><blockquote>
<p>请记住，Java中没有指针，一切数组对象都是引用，其类型名为：<code>elemType[]</code></p>
</blockquote>
<ol>
<li><p>定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elemType[] arrayName;    <span class="comment">// 此处arrayName是引用类型变量</span></span><br><span class="line"><span class="comment">// 可以使用C++风格定义</span></span><br><span class="line">elemType arrayName[];    <span class="comment">// arrayName仍然是引用类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>new操作符创建（<strong>和C++不同，只有new操作符才会给数组对象引用分配空间，所以说，new是对象新建的关键字</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">elemType[] arrayName = <span class="keyword">new</span> <span class="title class_">elemType</span>[size];    <span class="comment">// 这里的new仅仅是新的意思，arrayName仍然是对新对象的引用；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点：数组引用变量在没有指向具体存储空间（仅定义）是，内容是null；</span></span><br><span class="line">elemType[] arrayName2;    <span class="comment">// 此时arrayName2是null</span></span><br><span class="line">elemType[] arrayName3 = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">0</span>];     <span class="comment">// 但arrayName3不是null，只是一个长度为0的空数组，也占用空间；</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和C++不一样，一维数组是包装好的<strong>引用类型</strong>，<strong>存在长度属性</strong>：<code>arrayName.length</code>，存在<strong>自动赋初值（0）</strong>；</p>
</li>
<li><p>元素的访问：<code>arrayName[index]</code>；</p>
</li>
<li><p>赋初值（初始化语法）</p>
<ul>
<li><p>使用new操作符；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>[] array = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) array[i] = i;</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通赋值（<strong>不得将定义和初始化过程分开！因为普通定义不会为数组分配空间</strong>）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,...&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>对比C++的数组/指针处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>* arr = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">10</span>];    <span class="comment">// 可以后边接上赋初值</span></span><br><span class="line"><span class="type">double</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;        <span class="comment">// 中括号中的元素个数可以省略</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>特殊的一维数组：char[]</p>
<blockquote>
<p>和C++不一样，char数组末尾<strong>不用加 ‘\\0’ 字符</strong>、<strong>支持直接标准输出打印</strong>；</p>
</blockquote>
<p><code>char[] city = &#123;&#39;D&#39;, &#39;a&#39;, &#39;l&#39;, &#39;l&#39;, &#39;a&#39;, &#39;s&#39;&#125;;</code></p>
</li>
<li><p>遍历：和C++11标准一样，允许foreach循环</p>
<p><code>for (double x: arrayName) &#123;...&#125;</code></p>
</li>
<li><p>复制：记住，Java中的数组对象也是引用类型，和Python一样，和C++不一样；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...(前面已定义并为list1、list2赋值)</span></span><br><span class="line"><span class="comment">// 这样的做法会让list1引用指向list2的空间，</span></span><br><span class="line"><span class="comment">// list1原来空间会被 JVM 自动回收（GC机制）</span></span><br><span class="line"><span class="comment">// list1 = list2;</span></span><br></pre></td></tr></table></figure>
<p>正确的方法有3种：</p>
<ul>
<li><p>循环语句复制；</p>
</li>
<li><p><code>System</code>类中的“静态方法”（是什么以后介绍）<code>arraycopy()</code>；</p>
<blockquote>
<p>该方法使用前请确保目标数组已经分配好空间！</p>
</blockquote>
</li>
<li><p>clone方法复制，以后介绍；</p>
</li>
</ul>
</li>
<li><p>数组作为参数传递 / 作为返回值</p>
<blockquote>
<p>Java中对数组的参数传递方式，和C++一样，都是引用传递；</p>
<p><strong>同时也允许数组类型作为返回值，也是引用传递（和C++只能返回指针又不一样）</strong></p>
<p>因为Java中的类申请空间在堆中，且有GC机制，故不存在不能返回引用类型的说法；</p>
</blockquote>
</li>
<li><p>和Python<code>*args</code>类似的可变参数列表</p>
<blockquote>
<ul>
<li><p>C++中没有此类功能；</p>
</li>
<li><p>和Python一样，可变参数需要放在普通形参后面</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">double</span>... argList)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数定义：elemType... paramName</span></span><br><span class="line"><span class="comment">// 其中的argList会作为double一维数组处理</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常用数组操作工具：位于<code>java.util.Arrays</code>类中</p>
<ul>
<li><code>sort() / parallelSort()</code>：排序与并行排序（多处理器有用）；</li>
<li><code>binarySearch()</code>：要求查找前<strong>升序排好</strong>、未查找到返回某一个负数：<code>-（该元素应该处于的位置下标+1）</code>；</li>
<li><code>equals(...)</code>、<code>fill(...)（以某种方式填充）</code>；</li>
<li><code>toString(...)</code>：转换的数组对应字符串含有comma、中括号；</li>
</ul>
<blockquote>
<p>小结：目前用到了哪些java的包？</p>
<p><code>java.util.Scanner</code>、<code>java.util.Arrays</code></p>
<p><code>java.lang.Double</code>、<code>java.lang.Integer</code>、<code>java.lang.Math</code>、<code>java.lang.String</code>、<code>java.lang.System</code></p>
</blockquote>
</li>
<li><p>main命令行参数</p>
<blockquote>
<p>由于传入String一维数组引用类型，和C++的指针数组不一样，所以不需要<code>int argc</code>；</p>
</blockquote>
<p>和C++不一样的是，<code>main</code>函数和普通函数一样，可以在其他类中随意调用；</p>
<p><strong>重要提示：Java程序的命令行和C++不同，输入*符号相当于目录通配符，想要表达乘法*的意思，使用双引号括起表示字符串</strong></p>
</li>
</ol>
<h3 id="基本程序设计：多维数组"><a href="#基本程序设计：多维数组" class="headerlink" title="基本程序设计：多维数组"></a>基本程序设计：多维数组</h3><blockquote>
<p>二维数组为例，</p>
<p>Java中的二维数组比C++中开放，<strong>允许每行的数组长度不一样</strong>，但需要单独创建；</p>
<p>可以将每行看作一个独立的数组引用，可能具有不同的length参数值，自身的length就是行数；</p>
<p>更高维数组同理；</p>
</blockquote>
<ol>
<li><p>定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elemType[][] arrayName;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 至少指定rowNum，如果没有指定colNum，那么只为每一行的“指针分配空间，总体数组还是null组成的数组”，需要每行去new</span></span><br><span class="line"><span class="type">double</span>[][] arrayName = <span class="keyword">new</span> <span class="title class_">double</span>[rowNum][[colNum]];</span><br><span class="line"><span class="comment">// arrayName[i] = new double[j]; ...</span></span><br><span class="line"><span class="comment">// 或者普通创建：</span></span><br><span class="line"><span class="type">double</span>[][] raggedArray = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="基本程序设计：面向对象初步"><a href="#基本程序设计：面向对象初步" class="headerlink" title="基本程序设计：面向对象初步"></a>基本程序设计：面向对象初步</h3><blockquote>
<p>Java 中所有的类都是引用类型、对象都是引用类型变量；</p>
<p>注意：Java的类结尾无需以分号结束类的声明；</p>
</blockquote>
<ol>
<li><p>统一建模语言（UML）和UML类图</p>
<ul>
<li>类和对象框图的画法；</li>
<li>“-”：私有修饰符；“+”：公共修饰符；“#”：保护修饰符；</li>
<li>下划线：静态成员（静态变量+静态方法）；</li>
<li>属性：<code>attrName: type</code>；</li>
<li>方法：<code>method(params: type): returnType</code>；</li>
</ul>
</li>
<li><p>主类：包含main方法的类是主类；一个*.java 文件中至多只能含有一个主类、公有类（public，含义见“Java的类可见性修饰符”）；</p>
<blockquote>
<p>每个类（哪怕不是主类）会在编译时生成对应的*.class文件；</p>
<p><strong>一个*.java文件中，可以没有主类：像C++的面向对象一样，只是为了描述一个类、供外部调用而创建</strong></p>
<p>类所书写的文件名必须和类的公有类<strong>同名</strong></p>
</blockquote>
</li>
<li><p>类的构造函数（在使用new操作符时被调用）和默认构造函数（同C++）</p>
<blockquote>
<p>别问为什么没有析构函数，问就是Java包装太好了，以致于编程人员几乎不涉及GC的处理；</p>
</blockquote>
</li>
<li><p>引用属性（引用数据域）和 Java 的 null 值 和 属性的默认值</p>
<blockquote>
<p>Java 的“引用”和C++不同，可以修改指向对象，因此可以作为类的属性；</p>
<p>Java 中引用类型中有直接量<code>null</code>，就像boolean数值类型有直接量<code>true</code>、<code>false</code>;</p>
<p><strong>和C++一样，建议一定义对象就进行初始化/赋值操作</strong></p>
</blockquote>
<ul>
<li>数值类型的默认值为0、false等；</li>
<li>引用类型的默认值为null（直接使用会抛出<code>NullPointerException</code>异常）；</li>
</ul>
</li>
<li><p>匿名对象：创建后不需要引用的对象，可以不用赋给引用类型变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Area is: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>).getArea());</span><br></pre></td></tr></table></figure>
</li>
<li><p>类的静态变量（C++中的静态数据成员、Python中的类属性）、静态常量、静态方法；</p>
<ul>
<li>声明方法与C++相同、实际的储存方法和C++也相同（与Python不同，因为整个类中共享静态数据域）；</li>
</ul>
<blockquote>
<p>提示1：静态常量应该在类内定义：<code>final static &lt;TYPE&gt; name = value;</code></p>
<p>提示2（其他编程语言一样）：调用静态属性/方法时，建议使用类名+方法名/属性，因为能够提高可读性，帮助其他维护者迅速找到静态成员；</p>
<p>提示3：由于Java的类的使用特殊性，类的静态变量也在类中直接初始化（C++不允许，需要类外声明赋值）；</p>
</blockquote>
</li>
<li><p>Java的类可见性修饰符</p>
<ul>
<li><code>private、protected、public</code>：含义与C++完全相同，但使用方法不同（Java只能声明在属性/方法一行前）；</li>
<li><strong>注意：Java若没有声明可见性修饰符，默认的可见范围是：<code>package-private</code>，即在所有同一个包中的所有位置都能被访问，哪怕类不同（C++默认private）</strong></li>
</ul>
<blockquote>
<p>Java中的包能对类本身的”可见性“进行约束（进一步实现对类的组织），可能类似C++的命名空间；</p>
<p>每个文件前可以声明类所处的包，表示将该类放入该包中；如果不指定，则会放入默认包中（不建议这样，因为可能会造成一些混乱）；</p>
</blockquote>
</li>
<li><p>类的访问器和修改器：Java中的类的封装</p>
<blockquote>
<p>这里与Python的属性装饰器中的@set、@get思路有些类似；</p>
</blockquote>
</li>
<li><p>对象作为方法参数传递：与前面的”数组作为方法参数传递“完全相同；</p>
</li>
<li><p>对象数组：储存引用的数组；</p>
</li>
<li><p>不可变类和不可变对象（和Python思路相似）</p>
<blockquote>
<p>不可变类的定义：一个类满足如下三个条件：</p>
<ul>
<li>所有数据域都是私有的；</li>
<li>没有修改器方法；</li>
<li>没有”返回值是指向可变数据域的引用”的访问器方法；</li>
</ul>
<p><strong>因此如果有一个类数据域都私有、没有修改器方法，但有一个方法：返回内部一个可变数据域的引用（例如数组），则这个类也是可变类</strong></p>
</blockquote>
</li>
<li><p>Java类中的“this”</p>
<ul>
<li><p>只可惜Java中没有指针，所以this是一个引用（使用场景和存在位置都和C++类似）；</p>
</li>
<li><p><strong>Java中和C++在这个部分中实现较大的差别是：“委托构造函数”</strong>，C++的委托构造函数有专门的语法；但Java的“委托构造函数”只能使用this实现：<code>this(...)</code>；</p>
<blockquote>
<p>其实C++中也可以使用这种方法；另外C++用这种方法可以实现“后部分的委托构造”；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>变量作用域：和C++一样的理解；</p>
<blockquote>
<p>别问为什么和C++介绍的位置不一样（C++一般在介绍函数之后就介绍，但Java在类的知识中介绍），因为Java几乎所有的操作都在类里面；</p>
</blockquote>
</li>
<li><p>使用 Java 内置类型（常见）</p>
<ul>
<li><p><code>java.util.Date</code> 类：提供与系统无关的对时间、日期的封装（不是<code>java.System.currentTimeMillis()</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                    java.util.Date</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">+Date()                     // 为当前时间创建一个Date对象</span><br><span class="line">+Date(elapseTime: long)        // 从GMT 1970.1.1至今以毫秒计算的时间创建Date对象</span><br><span class="line"></span><br><span class="line">+toString(): String</span><br><span class="line">+getTime(): long            // 返回GMT 1970.1.1至今的毫秒数</span><br><span class="line">+setTime(elapseTime: long): void</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.util.Random</code> 类：提供各种数据类型下的伪随机数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                    java.util.Random</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">+Random()                    // 以当前时间为时间种子创建一个Random对象</span><br><span class="line">+Random(seed: long)</span><br><span class="line"></span><br><span class="line">+nextInt(): int</span><br><span class="line">+nextInt(n: int): int        // 返回一个0~n间（不包含n）的随机int值</span><br><span class="line">// 类似还有nextDouble、nextLong、nextFloat、nextBoolean等</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示（其他编程语言一样）：可以指定相同种子、生成相同的伪随机序列，这种能力在软件测试中非常有用；</p>
</blockquote>
</li>
<li><p><code>javafx.geometry.Point2D</code>类：请自行探索；</p>
</li>
<li><p>Java的基本数据类型包装为对象（<code>java.lang.xxx</code>，可以是Double、Integer、Byte、Character、Boolean、Float、Short、Long）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, srcT&gt;</span><br><span class="line">                        java.lang.T</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">-value: srcT</span><br><span class="line">+MAX_VALUE: srcT (static)</span><br><span class="line">+MIN_VALUE: srcT (static)</span><br><span class="line">-----------------------------</span><br><span class="line">+T(value: srcT)</span><br><span class="line">+T(s: String)</span><br><span class="line">+otherSrcTValue(): otherT</span><br><span class="line">+toString(): String</span><br><span class="line">+valueOf(s: String): T (static)</span><br><span class="line">// radix: 基数</span><br><span class="line">+valueOf(s: String, radix: int): T (static)</span><br><span class="line">+parseSrcT(s: String): srcT (static)</span><br><span class="line">+parseSrcT(s: String, radix: int): srcT (static)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java内置高精度运算：<code>java.math.BigDecimal/BigInteger</code></p>
<blockquote>
<p>内部自定义运算名称（add、multiple等），可以与String转换（“”+~可以转为String）</p>
<p>注意<code>divide</code>：高精度数除不尽时可能触发<code>ArithmaticException</code>，需要明确给定保留小数位和舍入方式：<code>a.divide(b, 20, BigDecimal.ROUND_UP)</code></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="基本程序设计：面向对象思想和应用"><a href="#基本程序设计：面向对象思想和应用" class="headerlink" title="基本程序设计：面向对象思想和应用"></a>基本程序设计：面向对象思想和应用</h3><ol>
<li><p>重载：Java不支持运算符重载；</p>
</li>
<li><p>封装</p>
</li>
<li><p>关联、组合</p>
<ul>
<li><p>类的关联关系：两个类之间有特定的活动联系；</p>
<blockquote>
<p>最简单的例子是：教师类和同学类的关系（教师教授一些课程类、学生学习一些课程类，而且学生与课程、教师与课程间有数量关系限制）；</p>
<p>关联的实现方法：两个类使用同类数据域、相关方法；</p>
<p>这里的数量限制又称<strong>类的多重性</strong>；</p>
</blockquote>
<p>补充UML类图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// [near]m..n[far]: far类需要与m~n（包含）个near类建立关联</span><br><span class="line">// *: far类可以与任意个数个near类建立关联</span><br><span class="line">// x: far类必须与x个near类建立关联</span><br><span class="line">// relation ▶: 类的抽象关系</span><br><span class="line"></span><br><span class="line">             take ▶                  ◀ teach</span><br><span class="line">        3..50      *            0..3            1</span><br><span class="line">student --------------- course ------------------ teacher</span><br></pre></td></tr></table></figure>
</li>
<li><p>类的聚集和组合</p>
<blockquote>
<p>聚集：两个类之间具有归属关系（<code>has-a</code>），一个该类的对象可以被其他多个聚集类的对象所归属；</p>
<p>组合：如果一个类的对象仅被一个聚集类的对象所归属，则称这两个类的聚集关系为组合；</p>
<p>最典型的例子是：学生-ID-班级类的关系，ID对象唯一地被学生对象所归属，班级对象可以与多个学生进行聚集；</p>
</blockquote>
<p>补充UML类图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// [near]◆[far]: far和near组合，其中near是owner；（◇代表聚集）</span><br><span class="line"></span><br><span class="line">   1            1            5..60       1</span><br><span class="line">ID -------------◆ student ◇-------------- Class</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>继承</p>
<blockquote>
<p>UML类图中以指向父类的三角箭头来表示两个类间的继承关系；</p>
</blockquote>
<ul>
<li><p>继承的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[qualifiers] <span class="keyword">class</span> <span class="title class_">subClassName</span> <span class="keyword">extends</span> <span class="title class_">superClassName</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>能够继承的部分：父类所有数据域和方法；但能够访问的数据域和方法只有public（依可见性修饰符而定，同C++）——即子类包裹父类，比父类具有更多信息；</p>
</li>
<li><p>Java 中的单一继承和多重继承：<strong>和C++和Python不一样：Java不允许多重继承，仅允许单一继承，即一个Java类只能直接继承自一个父类，不能继承于多个父类；</strong></p>
</li>
<li><p>Java 的 super 关键字：<strong>和C++不同、和Python类似，Java使用<code>super</code>关键字调用父类构造方法</strong></p>
<blockquote>
<p>C++：子类构造函数自动调用父类构造函数；</p>
<p>Java：想要调用父类构造函数（一般情况下都需要，否则不需要继承了），必须使用super关键字，且要写在子类构造函数的最前面（不写的话编译器会添加默认的<code>super()</code>，如果父类恰好没有默认构造函数，则抛出异常）；</p>
<p>Python 和 Java 类似，只不过是魔法方法<code>__init__()</code>，是初始化方法而非构造函数（Python甚至比Java还要少一个考虑空间分配的问题）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>():</span><br><span class="line"><span class="built_in">super</span>().__init__(...)</span><br><span class="line">    <span class="comment"># Statement</span></span><br></pre></td></tr></table></figure>
<p><strong>这些语言构造父类属性时，依此调用父类构造函数的过程称为“构造方法链”</strong></p>
<p>Java 允许通过 super 关键字调用父类public/protected方法：<code>super.methodName(...)</code></p>
</blockquote>
</li>
<li><p>Java的公共基类：<code>java.lang.Object</code>（Java所有类继承于Object类）</p>
<blockquote>
<p>与C++不同，C++没有公共基类的说法；</p>
<p>和Python2类似，Python2的旧式类的定义就是说明具有公共基类Object；</p>
<p><code>java.lang.Object</code>的重要公有方法：</p>
<ul>
<li><p><code>toString()</code>返回类名+@+内存地址构成的十六进制数字符串，可以在Object的所有子类中重写这个方法，类似Python的魔法方法：<code>__str__()</code>；</p>
</li>
<li><p><code>equals(object x)</code>：返回两对象引用是否指向同一内存地址，可以在子类中重载来完成仅对内容相同的判断；</p>
<p><strong>易错：重写equals的时候，不能改变参数类型！！！</strong></p>
</li>
</ul>
</blockquote>
</li>
<li><p>方法重写（override）：和C++一样，仅覆盖子类可见的方法；</p>
<blockquote>
<p>a. 静态方法不能被覆盖，只会被隐藏；</p>
<p>b. 可以通过<code>super</code>关键字调用<strong>直接父类</strong>的被覆盖的方法！！！</p>
<p>c. 建议添加重写标注<code>@Override</code>，<strong>意义和作用与C++的<code>override</code>后置关键字完全相同</strong></p>
</blockquote>
</li>
<li><p>UML类图的书写</p>
<ul>
<li>子类指向父类的实线+空心三角箭头；</li>
<li>子类可省略父类中的同签名的方法；</li>
</ul>
</li>
</ul>
</li>
<li><p>多态</p>
<blockquote>
<p>请回想C++的多态实现：基类指针+虚函数（作用是让基类指针调用虚函数时检查子类有没有重写情况，有则调用重写的方法，从而实现多态）；</p>
<p>Java 中没有指针，那么说明Java中的父类引用可以指向子类来充当“基类指针”（<strong>声明类型和实际类型可以不一致的特性</strong>）、Java的重写直接代替“虚函数”的说法；</p>
<p><strong>总结：为什么Java中没有C++的虚函数说法、C++没有Java的super关键字，却都能实现对应功能（例如多态）？</strong></p>
<ul>
<li>C++默认基类指针访问非虚函数时，只能访问基类对应的方法，只有加<code>virtual</code>关键字才能实现真正检查、覆盖；</li>
<li>相较于Java，Java默认指向子类对象的父类引用<strong>直接可以访问子类的重写方法（即直接覆盖——这里体现Java的引用调用重写方法时完全由实际类型决定，这称为“动态绑定”，C++使用虚函数关键字实现基类指针对该方法的“动态绑定”）</strong>，但想要访问父类的被覆盖方法，需要加上super关键字指明调用父类；</li>
</ul>
<p>（tips. Python和Java的多态实现是一样的思路）</p>
</blockquote>
</li>
<li><p>父类-子类类型转换 和 自定义类型转换</p>
<ul>
<li><p>子类 —-&gt; 父类：直接转换，因为子类实例总是父类的实例；</p>
</li>
<li><p>父类 —-&gt; 子类：一般不支持！而且 Java不支持自定义类型转换函数！</p>
<blockquote>
<p>只有父类引用指向子类对象时才可以使用，且需要显式类型转换，而且转换前要检查是不是真的可以：<code>instanceof</code>关键字（<code>&lt;obj&gt; instanceof &lt;class&gt; -&gt; boolean</code>）</p>
</blockquote>
</li>
<li><p>Java 不支持自定义类型转换函数；</p>
</li>
</ul>
</li>
<li><p>阻止类扩展和重写</p>
<ul>
<li>Java 在类前的修饰符<code>final</code>表示：该类不能作为父类（禁止扩展）；</li>
<li>Java 在方法前的修饰符<code>final</code>表示：该方法不能被重写（与C++ 11的<code>final</code>后置关键字含义相同）；</li>
</ul>
</li>
<li><p>字符串类（<code>java.lang.String</code>）的进一步分析</p>
<ul>
<li><p>创建方法及其含义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串有两种创建方式：</span></span><br><span class="line"><span class="comment">// 常量赋值法：</span></span><br><span class="line"><span class="comment">// 原理（和C++一样）：在常量存储区创建常量字符串&quot;12345&quot;，并将引用对象str指向该字符串；</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="comment">// 创建对象法（普通变量使用）：</span></span><br><span class="line"><span class="comment">// 原理：在堆中创建一个字符串（也是常量，不过是动态分配的空间），并将str指向该量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;12345&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>String是一种不可变数据类型 &amp;&amp; String的限定字符串</p>
<blockquote>
<p>原理见上；</p>
<p>限定字符串的工作和Python一模一样。如果是使用常量赋值法定义的两个字符串值相同，那么这两个字符串引用对象共用一个字符串数据内容，称为“限定字符串”</p>
</blockquote>
</li>
<li><p>转换为char array：<code>String.toCharArray()</code></p>
</li>
<li><p>格式匹配：<code>replace、replaceAll、replaceFirst、split、matches、equals</code>（ 全部支持正则表达式）；</p>
</li>
<li><p>格式化生成字符串：<code>format()</code>，类似printf的作用，将不同参数的变量转化为字符串；</p>
</li>
<li><p>可修改的String区域（和C++的string、char array很像）：<code>java.lang.StringBuilder/StringBuffer</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                        java.lang.StringBuilder</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">+StringBuilder()</span><br><span class="line">+StringBuilder(capacity: int)</span><br><span class="line">+StringBuilder(s: String)</span><br><span class="line"></span><br><span class="line">// 以下操作会直接修改原数据</span><br><span class="line">+append(...): StringBuilder</span><br><span class="line">+delete(indexes...): StringBuilder</span><br><span class="line">+insert(...): StringBuilder</span><br><span class="line">+replace(...): StringBuilder</span><br><span class="line">+reverse(): StringBuilder</span><br><span class="line">+setCharAt(...): void</span><br><span class="line"></span><br><span class="line">+toString(): String</span><br><span class="line">+capacity(): int</span><br><span class="line">+charAt(index: int): char</span><br><span class="line">+length(): int</span><br><span class="line">+setLength(newLength: int): void</span><br><span class="line">+substring(...): String</span><br><span class="line">+trimToSize(): void // shrink</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>StringBuffer</code>和<code>StringBuilder</code>的使用方法相同，区别是前者支持并发操作，后者仅支持普通操作，但性能更好；</p>
</blockquote>
</li>
<li><p>字符串池：Java 的 String 类会维护一个独立的字符串常量池（JDK7以后，存在于堆内存中）</p>
<blockquote>
<p>Java 维护静态变量、常量的方法与C++不同，将常量池和静态变量存在于堆区，因为不用编写者考虑内存分配问题；</p>
<p>C++对于静态局部变量、静态数据成员、全局变量都存在于<strong>全局数据区</strong>，独立于栈区和堆区；</p>
</blockquote>
<ul>
<li><p>常量池存储的是引用！！！</p>
</li>
<li><p>代码中的字符串常量（“…”，类似于C++中说的常量表达式constexpr）在运行时直接加载到常量池中（用new创建就不会）；</p>
</li>
<li><p>控制局部变量（存于栈帧中）转到常量池：<code>str2 = str1.intern();</code></p>
<blockquote>
<p>如果<code>str1</code>是个局部变量（即：其指向的字符串存在于栈帧中）或者是手动new分配的String，等<strong>一切：指向数据不在字符串常量池中的<code>str1</code></strong>，那么在运行上面一句后，Java会在常量池中加入一个引用（赋给<code>str2</code>），指向<code>str1</code>所指向的数据；</p>
<p>否则，<code>str2</code>直接指向<code>str1</code>所指向的数据；</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="基本程序设计：泛型类"><a href="#基本程序设计：泛型类" class="headerlink" title="基本程序设计：泛型类"></a>基本程序设计：泛型类</h3><ol>
<li><p>定义方法：直接在类名后加类型参数即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">stack</span>&lt;E&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Java的泛型类运行效率极差，且仅支持引用类型E，比C++的模板类慢很多，不建议应用此方法；</strong></p>
</li>
<li><p>实例：<code>ArrayList</code>类</p>
<blockquote>
<p><code>ArrayList</code>类可以动态分配列表大小，无需关系容量问题，类似 C++ STL <strong>线性表容器</strong>；</p>
<p><strong>很遗憾！Java 的泛型类仅支持引用对象，而非基本数据类型作为类型参数！</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">java.util.ArrayList&lt;E&gt;</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">+ArrayList()        // 线性数据结构（线性表，甚至杂糅一些集合结构的内容在其中）</span><br><span class="line"></span><br><span class="line">+clear(): void                    // 清</span><br><span class="line">+add(obj: E): void                // 增</span><br><span class="line">+add(index: int, obj: E): void</span><br><span class="line">+remove(obj: Object): boolean    // 删</span><br><span class="line">+remove(index: int): E</span><br><span class="line">+contains(obj: Object): boolean    // 查</span><br><span class="line">+get(index: int): E</span><br><span class="line">+indexOf(obj: Object): int</span><br><span class="line">+lastIndexOf(obj: Object): int</span><br><span class="line">+set(index: int, obj: E): E        // 改</span><br><span class="line">+isEmpty(): boolean                // 判空</span><br><span class="line">+size(): int</span><br><span class="line"></span><br><span class="line">+toString(): String</span><br></pre></td></tr></table></figure>
<ul>
<li><p>从对象数组创建ArrayList：<code>java.util.Array.asList(object[] arr(是引用)) -&gt; 数组数据</code></p>
</li>
<li><p>从ArrayList复制普通数组：<code>ArrayListObj.toArray(object[] arr)</code>，要求arr已分配空间；</p>
</li>
<li><p>支持<code>ArrayList</code>的Java库：<code>java.util.Collections</code></p>
<blockquote>
<p>max / min、shuffle、sort方法等；</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="基本程序设计：异常处理"><a href="#基本程序设计：异常处理" class="headerlink" title="基本程序设计：异常处理"></a>基本程序设计：异常处理</h3><ol>
<li><p>抛出异常：例如：<code>throw new</code>）</p>
</li>
<li><p>try-catch 块：与C++相同；</p>
</li>
<li><p>Java 中的异常类</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./JavaError_and_Exception.png"></p>
</li>
</ol>
<blockquote>
<p>图中的几个重要概念：</p>
<ul>
<li><p>异常基类<code>Throwable</code>和常用异常类<code>Exception</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                        java.lang.Throwable</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">+getMessage(): String</span><br><span class="line">+toString(): String</span><br><span class="line"></span><br><span class="line">+printStackTrace(): void</span><br><span class="line"></span><br><span class="line">+getStackTrace(): StackTraceElement[]</span><br></pre></td></tr></table></figure>
<p><strong><code>Exception</code>类继承自<code>Throwable</code>，以上方法都具有，故省略：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                        java.lang.Exception</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">+Exception()</span><br><span class="line">+Exception(message: String)</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统错误<code>system error</code>：Java虚拟机抛出的异常，内部系统有错误，遇到后必须立即终止程序不能有补救，只能有善后；</p>
<p>LinkageError：依赖库已修改，不兼容当前代码；</p>
<p>VirtualMachineError：Java虚拟机崩溃，或者运行时所需资源耗尽；</p>
</li>
<li><p>异常<code>exception</code>：可以被捕获和处理的异常</p>
<p>ClassNotFoundException：<code>java</code>命令运行的类无法找到；</p>
<p>IOException：包括子类<code>InterruptedIOException</code>、<code>EOFException</code>、<code>FileNotFoundException</code>等；</p>
</li>
<li><p>运行时异常（异常的子集）<code>runtime exception</code>；</p>
</li>
</ul>
</blockquote>
<ol>
<li><p>Java 异常处理机制</p>
<ul>
<li><p>声明异常（关键字<code>throws</code>）：任何方法必须尾置声明可能抛出的异常（<code>RuntimeException</code>、<code>Error</code>及其子类除外，如<code>IOException</code>、自定义类就就必须声明，除非当场使用try-catch捕获）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> IOException [, ...] &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抛出异常（关键字<code>throw</code>）<code>throw ExceptionObj;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&#x27;...&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>捕获异常（try-catch-finally）：语法几乎与C++相同、<code>finally</code>关键字用法同Python（即使前面有return也会进行）；</p>
<blockquote>
<p>JDK 7 多捕获特性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">catch</span> (exception1 | exception2 | ...) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>使用须知</p>
<ul>
<li>没有被捕获的异常会导致程序中断；</li>
<li>由于异常调用栈回溯繁琐，会耗费更多资源，故不应过度使用异常；</li>
<li>必要时重新抛出异常、设计链式异常；</li>
</ul>
</li>
<li><p>自定义异常类：建议基于<code>Exception</code>类做扩展（其UML类图见上）；</p>
</li>
</ol>
<h3 id="基本程序设计：Java的抽象类和接口"><a href="#基本程序设计：Java的抽象类和接口" class="headerlink" title="基本程序设计：Java的抽象类和接口"></a>基本程序设计：Java的抽象类和接口</h3><blockquote>
<p>提示：看源码的时候，关键字<code>native</code>表示这个方法不是用Java写的，但是基于JVM平台实现的；</p>
</blockquote>
<ol>
<li><p>抽象类的定义方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[qualifiers] <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">className</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象方法</p>
<ul>
<li>定义：<code>[qualifiers] abstract &lt;returnType&gt; funcName(params);</code></li>
<li>类似C++的纯虚函数；</li>
</ul>
</li>
<li><p>抽象类的构造函数</p>
<ul>
<li><p>和C++一样，逻辑上抽象类不需要定义构造函数，但如果执意要定义，那么需要声明为protected类型（C++也一样，思考为什么）；</p>
<blockquote>
<p>注意：Java 在子类中不能像C++一样自动调用父类的构造函数，所以抽象类的子类和普通类的子类一样，都需要显式super调用父类的构造函数；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>抽象类/方法的UML类图表示：文字以 <strong><i>斜体</i></strong> 表示；</p>
</li>
<li><p>注意事项</p>
<ul>
<li><p>和C++一样，Java不允许实例化抽象类；</p>
</li>
<li><p>包含抽象方法的类一定要是抽象类；</p>
</li>
<li>与C++不同，Java因为会抽象声明的原因，其抽象类可以没有抽象方法，但建议有；</li>
<li>Java 的一个具体类的子类可以是抽象类（例如Object是具体类，而我们能够定义抽象子类）；</li>
<li>抽象方法一定不是静态的；</li>
</ul>
</li>
<li><p>抽象类的一些实例</p>
<ul>
<li><code>java.lang.Number</code>：Double、Float、Long、Integer、Short、Byte、BigInteger、BigDecimal都是其子类；</li>
<li><code>java.util.Calendar</code>：其他类型的历法方式是其子类；</li>
</ul>
</li>
<li><p>接口的定义和使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">[qualifiers] <span class="keyword">interface</span> <span class="title class_">InterfaceName</span> &#123;&#125;    <span class="comment">// 允许泛型接口！</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">[qualifiers] <span class="keyword">class</span> <span class="title class_">className</span> [extend ...] <span class="keyword">implements</span> <span class="title class_">InterfaceName</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口 的 注意事项</p>
<ul>
<li><p>和抽象类一样抽象：描述一群类的共同行为 / 常量数据，类似Python的“协议”（如上下文管理协议、序列协议等）；</p>
</li>
<li><p>仅包含常量、抽象方法：数据域全是<code>public static final</code>，方法全是<code>public abstract</code>，故<strong>接口定义中允许省略所有修饰符</strong>；</p>
<blockquote>
<p>C++ 的“接口”一般用抽象类实现就行，因为C++允许多继承；</p>
</blockquote>
</li>
<li><p><strong>接口允许继承：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">interfaceName</span> extend I1 [, ...] &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类允许接口的多重扩展：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">className</span> <span class="keyword">implements</span> <span class="title class_">i1</span> [, ...] &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>UML类图：虚线+空心三角形+<code>&lt;&lt;interface&gt;&gt;</code></p>
</li>
</ul>
</li>
<li><p>接口的一些实例</p>
<ul>
<li><code>java.lang.Comparable</code>：只有一个方法<code>compareTo(E obj);</code></li>
<li><code>java.lang.Cloneable</code>：空接口（标记接口），标记有此接口的对象可以重写<code>Object.clone</code>以完成功能的实现；</li>
</ul>
</li>
</ol>
<h3 id="基本程序设计：文本-I-O-和网络-I-O"><a href="#基本程序设计：文本-I-O-和网络-I-O" class="headerlink" title="基本程序设计：文本 I/O 和网络 I/O"></a>基本程序设计：文本 I/O 和网络 I/O</h3><ol>
<li><p><code>File</code>类：<strong>此类初始化后并没有真正打开对象（占用资源）！不需要释放</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">                        java.io.File</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">+File(pathName: String)</span><br><span class="line">+File(parentDir: String, childPath: String)</span><br><span class="line">+File(parentDir: File, childPath: String)</span><br><span class="line"></span><br><span class="line">// 谓词函数，默认返回值为boolean，省略</span><br><span class="line">+exists()</span><br><span class="line">+canRead()</span><br><span class="line">+canWrite()</span><br><span class="line">+isDirectory()</span><br><span class="line">+isFile()</span><br><span class="line">+isAbsolute()    // File 对象的path数据是否是绝对路径</span><br><span class="line">+isHidden()        // Windows中的隐藏属性，Unix中文件前的“.”</span><br><span class="line"></span><br><span class="line">+getAbsolutePath(): String</span><br><span class="line">+getCanonicalPath(): String        // 将path数据转换为标准的绝对路径（没有简写）</span><br><span class="line">+getName(): String                // 相当于Python的os.path.basename(...)+后缀</span><br><span class="line">+getParent(): String            // 相当于Python的os.path.dirname(...)</span><br><span class="line">+lastModified(): long            // 文件最后修改时间（从Unix时间开始的毫秒数）</span><br><span class="line">+length(): long                    // 文件大小（如果File对象指向目录或不存在，为0）</span><br><span class="line">+listFile(): File[]                // 相当于Python的os.listdir()</span><br><span class="line"></span><br><span class="line">+delete(): boolean                // 删除File对象指向的文件/目录</span><br><span class="line">+renameTo(dst: File): boolean</span><br><span class="line">+mkdir(): boolean</span><br><span class="line">+mkdirs(): boolean</span><br></pre></td></tr></table></figure>
</li>
<li><p>文本输入：<code>java.io.PrintWriter</code>：<strong>此类对象初始化后会占用文件资源，记得及时释放</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                        java.io.PrintWriter</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">+PrintWriter(file: File)</span><br><span class="line">+PrintWriter(filename: String)</span><br><span class="line"></span><br><span class="line">+print(s: String): void</span><br><span class="line">+print(c: char): void</span><br><span class="line">+print(cArray: char[]): void</span><br><span class="line">// 注：此外还支持其他各种基本数据类型、包含println（自动换行）、printf（格式化输出）重载方法！！！</span><br><span class="line"></span><br><span class="line">+close(): void</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Java 中类似 Python 上下文管理器 处理I/O的工具：JDK 7 的<code>try-with-resources</code>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (声明、创建资源) &#123;</span><br><span class="line">使用资源;</span><br><span class="line">&#125;    <span class="comment">// 下面（Scanner）也能用，就是try-catch的功能之一！</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>文本输入 &amp;&amp; 控制台输入：<code>java.util.Scanner</code>（第三次介绍）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                        java.util.Scanner</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">+Scanner()    // 默认标准输入，即控制台</span><br><span class="line">+Scanner(source: File)        // 注意：可能抛出 IOException ！！！</span><br><span class="line">+Scanner(source: String)</span><br><span class="line"></span><br><span class="line">+close()    // 提示：如果是用来访问文件的，及时释放；控制台输出则不必要；</span><br><span class="line">+hasNext(): boolean</span><br><span class="line">+next(): String        // 分隔符为空格时，如果遇到换行符，则立即停止（读指针停在\n前）</span><br><span class="line">+nextXXX(): XXXX    // XXX表示各种基本数据类型</span><br><span class="line">+nextLine(): String</span><br><span class="line">+useDelimiter(pattern: String): Scanner    // 指定分隔符，默认空格</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 的网络I/O：以简单爬虫为例</p>
<blockquote>
<p>Java 的目标之一是互联网应用，所以对于网络相关部件封装的会比其他一些语言更好</p>
</blockquote>
<ul>
<li><p><code>java.net.URL</code>类：管理对URL的访问的类，仅介绍一个方法：<code>URL.openStream() -&gt; inputStream（和System.in一个类型，都是输入流类型，类似C++的istream）</code>，因为都是输入流，可以采用Scanner读取数据；</p>
</li>
<li><p>爬虫示例：详见我的另一篇博客《开发一个极简的 Java 网络爬虫》</p>
</li>
</ul>
</li>
</ol>
<h3 id="基本程序设计：二进制-I-O"><a href="#基本程序设计：二进制-I-O" class="headerlink" title="基本程序设计：二进制 I/O"></a>基本程序设计：二进制 I/O</h3><blockquote>
<ul>
<li><p>二进制I/O比文本I/O更高效：无需进行字符的编解码；</p>
</li>
<li><p>Java 的*.class文件就以二进制形式存储；</p>
</li>
<li>Java 中几乎所有 I/O 方法都可能 <code>throws IOException</code>；</li>
<li>个人主观感觉，Java的二进制 I/O 比Python、C++的好用…</li>
<li>注意<code>EOFException</code>的处理；</li>
</ul>
</blockquote>
<ol>
<li><p>Binary I/O 类：和<code>PrintWriter</code>、<code>Scanner</code>一样，会占用资源，请及时释放</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./bin_io.png"></p>
<blockquote>
<p><i>摘自 Introduction to Java Programming 10th Edition (Y. Daniel Liang)</i></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                    java.io.InputStream (abstract)</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">+read(): int (abstract)        // 从输入流读取下一个字节（0~255的int表示），EOF则返回-1</span><br><span class="line"></span><br><span class="line">+read(b: byte[]): int        // 从输入流读b.length()个字节，返回实际读到的字节数</span><br><span class="line">+read(b: byte[], off: int, len: int): int    // 保存在b[off], b[off+1], ..., b[off+len-1]中</span><br><span class="line"></span><br><span class="line">+available(): int            // 目前可读的字节数</span><br><span class="line">+close(): void                // 释放资源</span><br><span class="line">+skip(n: long): long        // 跳过、丢弃n个字节，返回实际跳过的字节</span><br><span class="line"></span><br><span class="line">+markSupported(): boolean    // 是否支持以下两个方法</span><br><span class="line">+mark(readlimit: int): void // 标记当前位置（默认开头）</span><br><span class="line">+reset(): void                // 将当前读指针定位到之前标记的位置</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                    java.io.OutputStream (abstract)</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">+write(b: int):  void (abstract)    // 将(byte)b写入输出流</span><br><span class="line"></span><br><span class="line">+write(b: byte[]): void</span><br><span class="line">+write(b: byte[], off: int, len: int): void</span><br><span class="line"></span><br><span class="line">+close(): void</span><br><span class="line">+flush(): void                // 注：缓冲区何时自动更新和C++一样</span><br></pre></td></tr></table></figure>
<p><strong>向文件中读写二进制数据：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                        java.io.FileInputStream</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">// 省略同签名函数就没什么东西了，唯一不同的是构造函数（可名可File），读没有花样，简单（不存在会报错）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                        java.io.FileOutputStream</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">// 构造函数类似文件输入流（上面），只是有一个额外的参数：append，决定是否追加还是覆盖（不存在会创建）</span><br></pre></td></tr></table></figure>
<p><strong>过滤二进制数据（从二进制数据中翻译为基本数据类型）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                            &lt;&lt;interface&gt;&gt;</span><br><span class="line">                    java.io.DataInput (abstract)</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">+readXXX(): XXX            // 读取XXX的基本数据类型</span><br><span class="line">+readLine(): String</span><br><span class="line">+readUTF(): String        // 以UTF格式读为字符串	（注：UTF-8格式中,每个字符1Byte）</span><br><span class="line">// 这个接口对标准输入也通用！</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                            &lt;&lt;interface&gt;&gt;</span><br><span class="line">                    java.io.DataOutput (abstract)</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">// 把上面接口中的read改为write</span><br><span class="line">+writeChars(s: String): void    // 每个字符2Byte</span><br></pre></td></tr></table></figure>
<p><code>DataInputStream</code>、<code>DataOutputStream</code>就是配备以上两个接口、以InputStream、OutputStream为间接父类的应用类；</p>
<p><strong>缓冲区操作二进制数据：</strong></p>
<p><code>BufferInputStream</code>、<code>BufferOutputStream</code>，使用见InputStream、OutputStream，唯一不同的是初始化时建议给定缓冲区大小；</p>
<blockquote>
<p>应该总是采用缓冲区来提升 I/O 速度，尤其大文件更能感受到；</p>
</blockquote>
<p><strong>随机访问文件（与之前的顺序流不同）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                        java.io.RandomAccessFile</span><br><span class="line">                    // 以DataInput、DataOutput为接口</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">+RandomAccessFile(file: File, mode: String)    // mode 与 Python规则一样</span><br><span class="line">+RandomAccessFile(name: String, mode: String)</span><br><span class="line">+close(): void</span><br><span class="line">+getFilePointer(): long                // 没有指针，只有字节数偏移量</span><br><span class="line"></span><br><span class="line">+length(): long</span><br><span class="line">+read(): int</span><br><span class="line">+read(b: byte[] [,...]): int</span><br><span class="line">+write(b: byte[] [,...]): void</span><br><span class="line"></span><br><span class="line">+seek(pos: long): void                // 设置指针为从流开始位置起的偏移量</span><br><span class="line">+skipBytes(int n): int</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象 I/O 和序列化接口</p>
<blockquote>
<p><code>ObjectInputStream</code>基于接口<code>ObjectInput</code>（其基于<code>DataInput</code>）和<code>ObjectStreamConstants</code>；<code>ObjectOutputStream</code>同理；</p>
</blockquote>
<p><strong>现阶段只需会用即可：<code>readObject() -&gt; Object</code>、<code>writeObject(Object x)</code></strong></p>
<blockquote>
<p>能够序列化的对象必须配备<code>serializable</code>接口（一种标记接口）</p>
<p>不支持则抛出<code>NoSerializableException</code></p>
<p>Java 中大多数基本数据类型、数组、字符串、大数类、日期类等都可序列化；</p>
</blockquote>
<p>简单的自定义可序列化类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">example</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 必须全由可序列化的数据域组成！</span></span><br><span class="line">    <span class="comment">// 如果有不可序列化的数据域，需要使用transient关键字丢弃它</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> unSerializableClass u;</span><br><span class="line">    <span class="comment">// 不会序列化静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="基本程序设计：总结"><a href="#基本程序设计：总结" class="headerlink" title="基本程序设计：总结"></a>基本程序设计：总结</h3><ol>
<li><p>前面使用到的所有类、包：复习回顾有哪些知识？（主要）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./packages.png"></p>
</li>
<li><p>类的设计原则</p>
<blockquote>
<p>内聚性、一致性（名字一致等）、封装性、清晰性、完整性、实例静态区分、继承聚会结合、灵活使用接口和抽象类；</p>
</blockquote>
</li>
</ol>
<p>全文完——————————————————————-</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://sjtuxhw.top">SJTU-XHW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sjtuxhw.top/2023/04/28/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://sjtuxhw.top/2023/04/28/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://sjtuxhw.top" target="_blank">SJTU-XHW's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/myBlog/tags/Programming/">Programming</a><a class="post-meta__tags" href="/myBlog/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/java1.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/myBlog/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myBlog/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/myBlog/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myBlog/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/myBlog/2023/05/03/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%9E%81%E7%AE%80%E7%9A%84Java%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/" title="开发一个极简的Java网络爬虫"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/java-crawler.jpeg" onerror="onerror=null;src='/myBlog/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">开发一个极简的Java网络爬虫</div></div><div class="info-2"><div class="info-item-1">说明本人最近在学习 Java 的基础用法时，开发了一个简易的爬取网站资源的 Java 程序； 预计的实现功能和特性：  选择爬取没有设置反爬措施的网站，自定义爬取资源数量； 支持保存主流资源格式，详见Source code； test 测试用例 分别是： https://www.baidu.com 和 https://www.vcg.com/creative-image/fengjing/；   Source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// written by SJTU_XHW// file:...</div></div></div></a><a class="pagination-related" href="/myBlog/2023/04/28/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Git学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/git.jpg" onerror="onerror=null;src='/myBlog/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Git学习笔记</div></div><div class="info-2"><div class="info-item-1">Chapter 0. The history of version control systems Local Version Control Systems  downsides: It is easy to forget which directory you’re in and accidentally write to the wrong file or copy over files you don’t mean to.   Centralized Version Control Systems  downsides:   the single point of failure that the centralized server represents  if the hard disk the central database is on becomes corrupted, and  proper backups haven’t been kept, you lose absolutely everything (Local VCSs suffer from...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/myBlog/2024/05/06/Java-Spring-Boot-%E5%85%A5%E9%97%A8/" title="Java Spring Boot 入门"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/spring-boot.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="info-item-2">Java Spring Boot 入门</div></div><div class="info-2"><div class="info-item-1"> 前置条件：WEB 基础（Socket，HTTP 整套规范），SQL 和数据库基础，Java 语言基础、前端基础（至少了解一种前端框架，本文以 React 为例）；  Chapter 0. Basic Concepts0.1 Servlet, war &amp; jar在接触 Web 框架时，你肯定能碰到一个绕不开的词：Servlet。它是什么？ Servlet 本质上就是一种规范，在 Java 的实现中就是一个 Web 规范接口。 所以，为什么要有这个规范？让我们回到最初的起点。  假设你什么框架都不用，想要徒手写一个能提供服务的服务器，那需要做哪些工作？ 其实原理比较简单，遵循当今互联网的 HTTP 协议发报文就行：  先编写基于多线程的 TCP 服务（Web 3.0 准备改用 UDP 了）； 然后在一个 TCP 连接中读取 HTTP 请求，发送 HTTP 响应即可；  但是其中还要考虑一些与网络协议相关、与业务逻辑无关的其他情况：  识别正确和错误的 HTTP 请求； 识别正确和错误的 HTTP 头； 复用 TCP 连接； 复用线程； IO...</div></div></div></a><a class="pagination-related" href="/myBlog/2024/05/02/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Java 学习笔记（二）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/java2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-02</div><div class="info-item-2">Java 学习笔记（二）</div></div><div class="info-2"><div class="info-item-1">Reference: Oracle Documentation Chapter 3. Java Record &amp; Java Bean3.1 Java Record在 Java 14 以后，官方引入了新的 Java 关键字：record； 那么这个 record 关键字究竟有什么用处呢？它和我们熟知的 class / interface / abstract class 又有什么区别呢？其实在 Java 14 以前，有一种需求写起来非常的麻烦，正因为这种需求才产生出了 record 关键字。这个需求是什么呢？ 举个例子，假如现在有个应用场景，想要定义一个数据类型，它只是用来存放一些数据（例如数据库查询的结果，或者是某个服务的返回信息）。 在很多实际情况下，我们希望使用这些数据就像 Java 内置基本类型一样，是不可变数据类型。这样做有几点好处：  复制构造时，不是引用传递，因此是深拷贝。这样使用起来和基本类型一样方便，但是又不用担心改错源数据（非引用链接）；  确保数据在多线程情况下无需同步，线程安全！   回忆下基础篇中的知识，要让 Java 类型（对象）behaves...</div></div></div></a><a class="pagination-related" href="/myBlog/2023/09/17/CSAPP-Notes-Basic/" title="CSAPP Notes Basic"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="info-item-2">CSAPP Notes Basic</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference:  CMU - 213, Computer Systems A Programmer’s Perspective 3rd Edition by Randal Bryant, David O’Hallaron 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 内容很长，写起来很慢 😳   Chapter 0. Intro0.1 Ints are not Integers, Floats are not Reals $x^2\ge 0$：int（32-bit）may overflow； $a+(b+c)=(a+b)+c$：floats may discard some “unsignificant” digits；  0.2 Learn Assembly but never write it0.3 Memory Matters: Unbounded1234567891011121314typedef struct &#123;    int a[2];    double d;&#125;...</div></div></div></a><a class="pagination-related" href="/myBlog/2024/04/16/CSAPP-Notes-ECF-I-O/" title="CSAPP Notes: ECF &amp; I&#x2F;O"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-ecf.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-16</div><div class="info-item-2">CSAPP Notes: ECF &amp; I&#x2F;O</div></div><div class="info-2"><div class="info-item-1">Chapter 13. Exceptional Control Flow 对应书中第 8 章。  异常控制流是现代计算机系统的一个相当重要的部分。 13.1 Control Flow 控制流：从机器打开到关闭的过程中，处理器只做一件事：读指令、执行指令，一个周期做一个指令。多核的机器则每个核心依次交替执行指令。这些指令序列被称为控制流。硬件正在执行的实际指令序列就被称为物理控制流。  改变内存中控制流的方法：分支 &amp; 跳转，过程调用 &amp; 返回（Branches &amp; Jumps &amp; Procedure call and return）；  都是对于程序状态变化的处理。    但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）； 什么是 “系统级别的状态变化”？  数据从磁盘 / 网卡到达内存中； I/O 设备输入...</div></div></div></a><a class="pagination-related" href="/myBlog/2024/04/10/CSAPP-Notes-Memory-Hierarchy-Cache-Opt/" title="CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-mh.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-10</div><div class="info-item-2">CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt</div></div><div class="info-2"><div class="info-item-1">Chapter 10. The Memory Hierarchy 本章将介绍系统的内存分层架构。  之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。 正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。 10.1 Storage Technologies &amp; Trends在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。 10.1.1 Random-Access Memory (RAM)当前大多数人所熟知的 “内存” 的一部分就是随机访问存储器（RAM），它具有以下的特征：  RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；  RAM 常常被打包放在 CPU 芯片中；  RAM 中每一个基本的存储单元被称为 单元胞（Cell），一个单元胞中存放 1 bit 数据；  很多个 RAM 芯片共同工作，组成了计算机的...</div></div></div></a><a class="pagination-related" href="/myBlog/2023/11/11/CSAPP-Notes-Scheduler-Arch/" title="CSAPP Notes: Scheduler &amp; Arch"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_p2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-11</div><div class="info-item-2">CSAPP Notes: Scheduler &amp; Arch</div></div><div class="info-2"><div class="info-item-1">Chapter 8. Scheduler in OS为操作系统的调度环境作出假设：  Each job runs for the same amount of time All jobs arrive at the same time Once started, each job runs to completion All jobs only use the CPU  i.e., they perform no I/O   The run-time of each job is known  引入调度优劣衡量指标：周转时间，$T_{turnaround}=T_{completion}-T_{arrival}$； Strategy 1: FIFO（FCFS，First Come First Served） Implementation: queue； 消除假设 1：若短时任务排在长时任务之后，则平均周转时间效果很差；  Strategy 2 : SJF（Shortest Job First） 内容：对于同时到达的任务，优先选择总时长小的任务。 作用：（应对假设 1...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myBlog/img/favicon.ico" onerror="this.onerror=null;this.src='/myBlog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SJTU-XHW</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/myBlog/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/myBlog/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/myBlog/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://sjtuxhw.top/myBlog/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Concepts"><span class="toc-text">Basic Concepts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">解释型语言和编译型语言的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BB%A5C-%E4%B8%BA%E4%BE%8B%EF%BC%89%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">编译型语言（以C++为例）的编译运行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">解释型语言的运行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3"><span class="toc-text">图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%83%9CJava%E6%98%AF%E2%80%9C%E5%8D%8A%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E2%80%9D%EF%BC%81"><span class="toc-text">可惜Java是“半解释型语言”！</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%A4%E7%9F%A5"><span class="toc-text">操作系统认知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E8%AE%A4%E7%9F%A5"><span class="toc-text">Java 认知</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">Java 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83"><span class="toc-text">基本规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8EC-%E7%9B%B8%E5%90%8C%E9%83%A8%E5%88%86%E7%9C%81%E7%95%A5%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本程序设计（与C++相同部分省略）：基础与数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E5%BC%95%E5%85%A5%E3%80%81%E5%8C%85%E5%A3%B0%E6%98%8E"><span class="toc-text">包引入、包声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E3%80%81%E5%A3%B0%E6%98%8E%E3%80%81%E5%AE%9A%E4%B9%89"><span class="toc-text">变量命名规范、声明、定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%88C-%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8Fconst%EF%BC%89"><span class="toc-text">命名常量的定义（C++中的常量const）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E3%80%81%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">赋值语句、赋值表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88%E5%88%9D%E8%AE%A4%E8%AF%86%EF%BC%89"><span class="toc-text">标准输入输出（初认识）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%85%A5%E9%97%A8"><span class="toc-text">数据类型入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%A2%9E%E5%BC%BA%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%E3%80%81%E8%87%AA%E5%8A%A0%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%BB%9D%E5%A4%A7%E9%83%A8%E5%88%86%E4%B8%8EC-%E7%9B%B8%E5%90%8C%EF%BC%89"><span class="toc-text">数值运算符、增强赋值操作符、自加自减运算符、逻辑运算符（绝大部分与C++相同）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">运算符优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%EF%BC%88%E6%98%BE%E5%BC%8F%EF%BC%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%8F%8A%E5%85%B6%E5%8E%9F%E5%88%99%EF%BC%88%E5%92%8CC-%E6%9C%89%E6%89%80%E4%B8%8D%E5%90%8C%EF%BC%89"><span class="toc-text">强制（显式）类型转换、自动类型转换，及其原则（和C++有所不同）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%EF%BC%9A%E4%B8%8EC-%E7%9B%B8%E5%90%8C"><span class="toc-text">常见错误：与C++相同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">常用工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-text">调试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">基本程序设计：字符与字符串与格式化输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%88%86%E6%94%AF"><span class="toc-text">基本程序设计：条件与分支</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6%E3%80%81%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">比较操作符、条件表达式和三目运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if-else-if-else%E8%AF%AD%E5%8F%A5"><span class="toc-text">if - [else if] - else语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-case-default-%E8%AF%AD%E5%8F%A5"><span class="toc-text">switch - case - [default]语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="toc-text">常见错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%BE%AA%E7%8E%AF%EF%BC%88%E5%85%A8%E9%83%A8%E4%B8%8EC-%E7%9B%B8%E5%90%8C%F0%9F%98%82%EF%BC%89"><span class="toc-text">基本程序设计：循环（全部与C++相同😂）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#do-while-%E5%BE%AA%E7%8E%AF"><span class="toc-text">do-while 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-text">for 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#break-amp-continue"><span class="toc-text">break &amp; continue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%96%B9%E6%B3%95"><span class="toc-text">基本程序设计：方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">基本程序设计：一维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">基本程序设计：多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5"><span class="toc-text">基本程序设计：面向对象初步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E5%92%8C%E5%BA%94%E7%94%A8"><span class="toc-text">基本程序设计：面向对象思想和应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">基本程序设计：泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">基本程序设计：异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9AJava%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-text">基本程序设计：Java的抽象类和接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%96%87%E6%9C%AC-I-O-%E5%92%8C%E7%BD%91%E7%BB%9C-I-O"><span class="toc-text">基本程序设计：文本 I&#x2F;O 和网络 I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6-I-O"><span class="toc-text">基本程序设计：二进制 I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%80%BB%E7%BB%93"><span class="toc-text">基本程序设计：总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2024/07/20/Algorithms-in-AI/" title="Algorithms in AI"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/algo-in-ai.jpg" onerror="this.onerror=null;this.src='/myBlog/img/404.jpg'" alt="Algorithms in AI"/></a><div class="content"><a class="title" href="/myBlog/2024/07/20/Algorithms-in-AI/" title="Algorithms in AI">Algorithms in AI</a><time datetime="2024-07-20T07:23:40.000Z" title="发表于 2024-07-20 15:23:40">2024-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2024/06/15/Convex-Optimizations/" title="Convex &amp; Optimizations"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/convex.jpg" onerror="this.onerror=null;this.src='/myBlog/img/404.jpg'" alt="Convex &amp; Optimizations"/></a><div class="content"><a class="title" href="/myBlog/2024/06/15/Convex-Optimizations/" title="Convex &amp; Optimizations">Convex &amp; Optimizations</a><time datetime="2024-06-15T07:18:39.000Z" title="发表于 2024-06-15 15:18:39">2024-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2024/06/12/Numeric-Analysis-for-Beginners/" title="Numeric Analysis for Beginners"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/numeric-analysis.jpg" onerror="this.onerror=null;this.src='/myBlog/img/404.jpg'" alt="Numeric Analysis for Beginners"/></a><div class="content"><a class="title" href="/myBlog/2024/06/12/Numeric-Analysis-for-Beginners/" title="Numeric Analysis for Beginners">Numeric Analysis for Beginners</a><time datetime="2024-06-12T05:11:56.000Z" title="发表于 2024-06-12 13:11:56">2024-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2024/06/01/Introduction-to-Rabbit-MQ/" title="Introduction to Rabbit MQ"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/rabbit.jpeg" onerror="this.onerror=null;this.src='/myBlog/img/404.jpg'" alt="Introduction to Rabbit MQ"/></a><div class="content"><a class="title" href="/myBlog/2024/06/01/Introduction-to-Rabbit-MQ/" title="Introduction to Rabbit MQ">Introduction to Rabbit MQ</a><time datetime="2024-06-01T08:31:33.000Z" title="发表于 2024-06-01 16:31:33">2024-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/myBlog/2024/05/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%8E%A2/" title="微服务初探"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/micro.jpg" onerror="this.onerror=null;this.src='/myBlog/img/404.jpg'" alt="微服务初探"/></a><div class="content"><a class="title" href="/myBlog/2024/05/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%8E%A2/" title="微服务初探">微服务初探</a><time datetime="2024-05-21T03:27:40.000Z" title="发表于 2024-05-21 11:27:40">2024-05-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By SJTU-XHW  |  tech SJTU saves the world</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> &nbsp;|&nbsp;&nbsp;本网站由 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="img/upCloud_logo.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/myBlog/js/utils.js"></script><script src="/myBlog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.sjtuxhw.top',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.sjtuxhw.top',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code      
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'data-lazy-src'
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}"></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'twikoo-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const getComment = ele => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.sjtuxhw.top',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(res => {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray, ele)
      }).catch(err => {
        console.error(err)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  run(keyName, getComment)
})</script><script src="/myBlog/js/jquery-3.7.0.min.js"></script><script src="/myBlog/js/rightmenu.js"></script><div class="aplayer no-destroy" data-id="6898044781" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"></div><script src="/myBlog/js/mourn.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="/myBlog/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/myBlog/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/myBlog/js/search/local-search.js"></script></div></div></body></html>