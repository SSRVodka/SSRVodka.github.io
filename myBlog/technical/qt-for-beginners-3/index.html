<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>从C++入门Qt（三） | SJTU-XHW's blog</title><meta name="author" content="SJTU-XHW,sjtuxhw12345@sjtu.edu.cn"><meta name="copyright" content="SJTU-XHW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~">
<meta property="og:type" content="article">
<meta property="og:title" content="从C++入门Qt（三）">
<meta property="og:url" content="https://blog.sjtuxhw.top/technical/qt-for-beginners-3/index.html">
<meta property="og:site_name" content="SJTU-XHW&#39;s blog">
<meta property="og:description" content="written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/qt3.jpg">
<meta property="article:published_time" content="2023-08-30T11:05:14.000Z">
<meta property="article:modified_time" content="2024-10-25T14:02:04.689Z">
<meta property="article:author" content="SJTU-XHW">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Qt">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/qt3.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/technical/qt-for-beginners-3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从C++入门Qt（三）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SJTU-XHW's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/qt3.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SJTU-XHW's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">从C++入门Qt（三）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">从C++入门Qt（三）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-30T11:05:14.000Z" title="发表于 2023-08-30 19:05:14">2023-08-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T14:02:04.689Z" title="更新于 2024-10-25 22:02:04">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/technical/qt-for-beginners-3/#post-comment"><span class="waline-comment-count" data-path="/technical/qt-for-beginners-3/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><i>written by SJTU-XHW</i></p>
<p><i>Reference: C++ GUI Programming with Qt 4 (2nd Edition) </i></p>
<p><i>注意：本文章将讲解 <strong>Qt 5</strong> 入门知识，需要一定的 C++ 基础</i></p>
<p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p>
<p><strong>观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~</strong></p>
<hr>
<span id="more"></span>
<p>前面 4 章节的内容都是从具体项目来学习 Qt 的方法，也已经让我们初步认识了 Qt 的使用方法，下面的内容将按类分块来介绍，文章的篇幅也会短一些。</p>
<h1 id="Chapter-5-Qt-常用事件"><a href="#Chapter-5-Qt-常用事件" class="headerlink" title="Chapter 5. Qt 常用事件"></a>Chapter 5. Qt 常用事件</h1><p>Qt 中常用的 <code>Event</code> 主要有：<strong>鼠标事件</strong>、<strong>键盘事件</strong>、<strong>内部事件</strong>。其中内部事件绝大多数都交给 <strong>信号-槽</strong> 来处理，少部分的内部事件在特定情况需要重写，例如 <code>QPaintEvent</code>（下一章说）、 <code>QCloseEvent</code> 关闭事件（实现关闭前确认）。前两个事件是输入事件，都继承于 <code>QInputEvent</code>。</p>
<h2 id="5-1-内部事件"><a href="#5-1-内部事件" class="headerlink" title="5.1 内部事件"></a>5.1 内部事件</h2><p>前面介绍过，对于内部事件（特指关闭事件），<code>QCloseEvent</code> 的使用方法也很简单，重写 <code>void QWidget::closeEvent(QCloseEvent* event)</code> 即可，如果调用了 <strong><code>event-&gt;accept()</code></strong>，表示控件接受关闭事件，正式关闭；而如果调用了 <strong><code>event-&gt;ignore()</code></strong>，则控件忽略关闭事件。</p>
<h2 id="5-2-鼠标事件"><a href="#5-2-鼠标事件" class="headerlink" title="5.2 鼠标事件"></a>5.2 鼠标事件</h2><blockquote>
<p>注意：鼠标滚轮另外归于 <code>QWheelEvent</code> 类。在最后会一笔带过。</p>
</blockquote>
<h3 id="5-2-1-简单介绍"><a href="#5-2-1-简单介绍" class="headerlink" title="5.2.1 简单介绍"></a>5.2.1 简单介绍</h3><p>Qt 的鼠标事件交由 <code>QMouseEvent</code> 处理，分为鼠标移动、左键 / 右键的单击、双击、释放。具体为何能够实现，归因于 <code>QWidget</code> 的信号-槽，它们会在鼠标在该控件区域发生特点行为时发出信号，进而传递 <code>QMouseEvent</code> 对象。</p>
<p>有一个重要的点需要阐释：鼠标<strong>移动事件</strong>只会在<strong>按下鼠标按键</strong>的情况下才会发生！除非通过<strong>显式调用 <code>QWidget::setMouseTracking()</code></strong>函数来开启鼠标轨迹，这种情况下只要鼠标指针在移动，就会产生一系列的鼠标移动事件。</p>
<h3 id="5-2-2-QMouseEvent-的传递方式"><a href="#5-2-2-QMouseEvent-的传递方式" class="headerlink" title="5.2.2 QMouseEvent 的传递方式"></a>5.2.2 <code>QMouseEvent</code> 的传递方式</h3><p>一个鼠标事件包含一些指定的接受标志 <code>flag</code> 用于指出该事件是否会被接收和处理 ，如果鼠标指针所在的父控件不接收该事件则可以调用函数 <code>QMouseEvent::ignore()</code> 予以忽略；</p>
<p>多个重叠的控件好比一个倒立的树，鼠标事件会沿着鼠标指针所在的父控件向上传递，直到某个控件调用 <code>QMouseEvent::accept()</code> 函数进行事件处理，否则该事件将被过滤销毁掉；</p>
<p>此外，<code>QWidget</code> 中的属性 <code>Qt::WA_NoMousePropagation</code> 能够改变这种传递行为。如果设置为 <code>true</code>，那么鼠标信号不会再向父控件传递。</p>
<h3 id="5-2-3-QMouseEvent-的使用"><a href="#5-2-3-QMouseEvent-的使用" class="headerlink" title="5.2.3 QMouseEvent 的使用"></a>5.2.3 <code>QMouseEvent</code> 的使用</h3><p>需要引入 <code>QMouseEvent</code> 类的头文件。通常通过重写下面的函数来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::mouseDoubleClickEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br></pre></td></tr></table></figure>
<p>具体 <code>QMouseEvent</code> 有如下获取位置实例方法（成员函数）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">QMouseEvent::pos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QMouseEvent::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QMouseEvent::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QPoint <span class="title">QMouseEvent::globalPos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QMouseEvent::globalX</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QMouseEvent::globalY</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>注：<code>QPoint</code> 类的方法也有 <code>QPoint::x()</code> 和 <code>QPoint::y()</code>，代表点对象在当前画布的位置。</p>
<p>如果鼠标事件还涉及处理移动窗口的坐标计算（pos 在窗口外），那么为了防止抖动可以使用 <code>QMouseEvent::globalPos()</code> 获取屏幕全局坐标。</p>
<p>还需要注意的问题，就是鼠标指针位置类 <code>QCursor</code> 的方法 <code>pos()</code> 和 这里鼠标事件 <code>globalPos()</code> 不一样，需要使用 <code>QWidget::mapToGlobal(pos())</code> 在窗口坐标和全局坐标间转换；</p>
<hr>
<p>鼠标事件除了记录位置，还记录了鼠标击键的方法，可以调用下面这些函数判断：</p>
<p>注意，<code>Qt::MouseButton</code> 是枚举类型，其取值都以十六进制存储，<strong>可以进行按位或的方法来多选</strong>。常见的值有：<code>Qt::NoButton</code>、<code>Qt::AllButtons</code>、<code>Qt::LeftButton</code>、<code>Qt::RightButton</code>、<code>Qt::MiddleButton</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是鼠标移动事件，那么此函数始终返回 Qt::NoButton</span></span><br><span class="line"><span class="function">Qt::MouseButton <span class="title">QMouseEvent::button</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和上面一个可以相互替代，不过这个函数更准，返回同时将触发的按键值**按位或**起来</span></span><br><span class="line"><span class="function">Qt::MouseButton <span class="title">QMouseEvent::buttons</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>正因为 <code>buttons()</code> 的结果是按位或起来，所以判断自然不是 <code>==</code>，而是<strong>按位与</strong>判断有没有特定的按键。</p>
<p>注：在 <code>QWidget::mouseDoubleClick()</code> 中，因为双击是同一按键，所以也能用 <code>QMouseEvent::button()</code> 来判断按键的。</p>
<h3 id="5-2-4-鼠标滚轮"><a href="#5-2-4-鼠标滚轮" class="headerlink" title="5.2.4 鼠标滚轮"></a>5.2.4 鼠标滚轮</h3><p>简单介绍 <code>QWheelEvent</code> 类，用的比较多的是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QWheelEvent::delta</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果返回值大于 0，说明滚轮向下（远离使用者）；反之向上（接近使用者）。</p>
<h2 id="5-3-键盘事件"><a href="#5-3-键盘事件" class="headerlink" title="5.3 键盘事件"></a>5.3 键盘事件</h2><p>键盘事件交由 <code>QKeyEvent</code> 来处理。传递方式和鼠标事件几乎相同。在使用方面，键盘事件比鼠标简单，不存在移动、右击、双击的事件，就处理按下和释放两个事件，可以重写的函数有两个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::keyPressEvent</span><span class="params">(QKeyEvent* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::keyReleaseEvent</span><span class="params">(QKeyEvent* event)</span></span>;</span><br></pre></td></tr></table></figure>
<p>具体 <code>QKeyEvent</code> 有如下的实例方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Qt::Key <span class="title">QKeyEvent::key</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">Qt::KeyboardModifiers <span class="title">QKeyEvent::modifiers</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QKeyEvent::isAutoRepeat</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QKeyEvent::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里解释一下 <code>isAutoRepeat()</code>。众所周知，<strong>长按键盘的某个键，就相当于快速重复触发这个键（平时在编辑文本中应该感受到了）</strong>。而在 Qt 的键盘事件中，在控件中按一次键就<strong>各触发一次 <code>QKeyEvent</code> 按下和释放事件</strong>，长按也会快速触发 <code>QKeyEvent</code>，但有种方法能够辨别长按的行为——<code>isAutoRepeat()</code>，只有长按键盘的事件第一次会返回 <code>false</code>，快速触发的接下来所有事件都返回 <code>true</code>，直至物理上松开按键。利用这个函数，可以设计出 “不处理长按事件” 的逻辑（需要在按下和释放的处理函数中都写一下）。</p>
<p>其次，<code>Qt::Key</code> 也是枚举类型，其取值都以十六进制存储，值的格式为 <code>Qt::Key_&lt;keyName&gt;</code>：</p>
<p><code>Qt::Key_Escape</code>（Esc）、<code>Qt::Key_Tab</code>、<code>Qt::Key_Backspace</code>、<code>Qt::Key_Enter</code>、<code>Qt::Key_Insert</code>、<code>Qt::Key_Delete</code>、<code>Qt::Key_Pause</code>（对于键盘的 <code>Pause/Break</code>，和多媒体的 “暂停” 丝毫没有关系）、<code>Qt::Key_Print</code>、<code>Qt::Key_Home</code>、<code>Qt::Key_End</code>、<code>Qt::Key_[Left/Right/Up/Down]</code>、<code>Qt::Key_PageUp</code>、<code>Qt::Key_PageDown</code>、<code>Qt::Key_Shift</code>、<code>Qt::Key_Control</code>（MacOS 中的 <code>command</code> 键）、<code>Qt::Key_Alt</code>、<code>Qt::Key_Meta</code>（MacOS 中的 <code>Ctrl</code>，Windows 中的徽标键）、<code>Qt::Key_CapsLock</code>、<code>Qt::Key_NumLock</code>、<code>Qt::Key_ScrollLock</code>、<code>Qt::Key_[F1~35]</code>、<code>Qt::Key_Space</code>、<code>Qt::Key_[0-9]</code>、<code>Qt::Key_[A-Z]</code>……</p>
<p>多个键同时按下时，还可以使用 <code>count()</code> 返回本次 <code>QKeyEvent</code> 事件按键数量。</p>
<p>如果多个键按下时，伴随的是<strong>修饰键</strong>（例如 <code>shift</code>、<code>ctrl</code>、<code>alt</code> 等），可以用 <code>modifiers()</code> 查到。</p>
<p>修饰键有单独的枚举类型 <code>Qt::KeyboradModifiers</code>，值有：</p>
<p><code>Qt::NoModifier</code>、<code>Qt::ShiftModifier</code>、<code>Qt::ControlModifier</code>、<code>Qt::AltModifier</code>、<code>Qt::MetaModifier</code>……</p>
<p>举个例子，<strong>想要查到 <code>ctrl+M</code> 事件</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestWidget::keyPressEvent</span><span class="params">(QKeyEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">modifiers</span>() == Qt::ControlModifiers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">key</span>() == Qt::Key_M) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> QWidget::<span class="built_in">keyPressEvent</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最后强调一个事，Qt 的键盘事件一次仅能捕捉一个按键 ！！！例如看似我“同时”按下 A 和 S 这两个键，实际上会先触发 <code>Qt::Key_A</code>/<code>Qt::Key_S</code> 中的一个，再触发另一个</strong>。</p>
<p>这对于想要判断<strong>非修饰键的组合键</strong>的同学来说可能有些麻烦——因为这需要设置一个容器，或者十六进制码进行存储，按下键存进去，松开键删除掉，然后统一判断这个存储的信息。</p>
<h1 id="Chapter-6-Qt-图形绘制"><a href="#Chapter-6-Qt-图形绘制" class="headerlink" title="Chapter 6. Qt 图形绘制"></a>Chapter 6. Qt 图形绘制</h1><p>Qt 所制作的几乎所有 GUI 上的按钮、编辑框等组件都是通过绘图得到的。Qt 的二维绘图基本功能是使用 <code>QPainter</code> 在绘图设备（包括 <code>QWidget</code>、<code>QPixmap</code> 等）上绘图，通过绘制一些基本的点、线、圆等基本形状组成需要的图形，得到的图形不可交互。</p>
<p>除了 <code>QPainter</code>，Qt 还提供 Graphics View 架构，使用 <code>QGraphicsView</code>、<code>QGraphicsScene</code>、<code>QGraphicsItem</code> 类来制作更多样复杂的、可交互的图形。</p>
<h2 id="6-1-QPainter-基本绘图"><a href="#6-1-QPainter-基本绘图" class="headerlink" title="6.1 QPainter 基本绘图"></a>6.1 <code>QPainter</code> 基本绘图</h2><h3 id="6-1-1-绘图区"><a href="#6-1-1-绘图区" class="headerlink" title="6.1.1 绘图区"></a>6.1.1 绘图区</h3><p>Qt 基本绘图系统基于 <code>QPainter</code>（绘图操作使用）、<code>QPaintDevice</code>（可以使用 <code>QPainter</code> 的抽象二维界面）、<code>QPaintEngine</code>（为 <code>QPainter</code> 提供各种设备上绘制的接口）类。</p>
<p>一般情况下不需要关注底层 <code>QPaintEngine</code>，除非想自定义一个可以绘制的设备类型。</p>
<p>常见的绘图设备有 <code>QWidget</code>、<code>QPixmap</code>、<code>QImage</code>，为 <code>QPainter</code> 提供了 “canvas”。</p>
<p>下面先以 <code>QWdiget</code> 这个绘图设备为例。</p>
<p>想在 <code>QWidget</code> 这一绘图设备上绘图很简单，重写以下函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::paintEvent</span><span class="params">(QPaintEvent* event)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这也是上一章提到的 “内部事件” 之一。利用 <code>QPaintEvent</code> 事件，在函数中创建 <code>QPaint</code> 对象，就可以在控件画布上绘图了。</p>
<p>当然，重写也是有讲究的，需要使用<strong>专用的宏 <code>Q_DECL_OVERRIDE</code></strong> 来声明这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestWidget::paintEvent</span><span class="params">(QPaintEvent* event)</span> Q_DECL_OVERRIDE</span>;</span><br></pre></td></tr></table></figure>
<p>再介绍一下绘图坐标系中的<strong>视口（viewport）坐标</strong>：<code>QWidget</code> 的左上角就是（0，0），向右是 x 轴正方向，向下是 y 轴正方向；绘图区宽度和高度分别由控件宽度、高度决定：<code>QWidget::width()</code>、<code>QWidget::height()</code>。</p>
<p>除了视口坐标，还有逻辑坐标和窗口坐标，以后介绍。</p>
<h3 id="6-1-2-绘图属性"><a href="#6-1-2-绘图属性" class="headerlink" title="6.1.2 绘图属性"></a>6.1.2 绘图属性</h3><p><code>QPainter</code> 具有 3 各重要属性：</p>
<ul>
<li><code>QPainter::pen</code>，是一个 <code>QPen</code> 对象，用于控制<strong>线条颜色、宽度、线型</strong>；</li>
<li><code>QPainter::brush</code>，是一个 <code>QBrush</code> 对象，用于设置一个区域的填充特性，可以设置<strong>填充颜色、填充方式、渐变特性</strong>，也可以指定图片做材质填充；</li>
<li><code>QPainter::font</code>，是一个 <code>QFont</code> 对象，用于绘制文字时设置<strong>文字样式、大小</strong>；</li>
</ul>
<p>下面以一个实例来介绍。假设 <code>TestWidget</code> 类是一个继承于 <code>QWidget</code>、已设计的一个类，只需要在其上绘制图案就完成任务，那么函数这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestWidget::paintEvent</span><span class="params">(QPaintEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个 QPainter 对象，与 TesWidget 对象关联、</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::TextAntialiasing);</span><br><span class="line">    <span class="type">int</span> W = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>();    <span class="comment">// 记录绘图区宽度和高度</span></span><br><span class="line">    <span class="type">int</span> H = <span class="keyword">this</span>-&gt;<span class="built_in">height</span>();</span><br><span class="line">    <span class="comment">// QRect 类是个二维图形类，初始化一个长方形，后文会详细介绍</span></span><br><span class="line">    <span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个指定的画笔</span></span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.<span class="built_in">setWidth</span>(<span class="number">3</span>);    <span class="comment">// 笔的线宽</span></span><br><span class="line">    pen.<span class="built_in">setColor</span>(Qt::red);    <span class="comment">// 笔的颜色</span></span><br><span class="line">    pen.<span class="built_in">setStyle</span>(Qt::SolidLine);    <span class="comment">// 笔画的线的样式（这里是实线）</span></span><br><span class="line">    pen.<span class="built_in">setCapStyle</span>(Qt::FlatCap);    <span class="comment">// 笔画的线的端点样式</span></span><br><span class="line">    pen.<span class="built_in">setJoinStyle</span>(Qt::BevelJoin);    <span class="comment">// 笔画的线的连接点样式</span></span><br><span class="line">    <span class="comment">// 笔设置完后，给  QPainter 装上指定的笔：</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个画刷</span></span><br><span class="line">    QBrush brush;</span><br><span class="line">    brush.<span class="built_in">setColor</span>(Qt::Yellow);    <span class="comment">// 画刷填充的颜色</span></span><br><span class="line">    brush.<span class="built_in">setStyle</span>(Qt::SolidPattern);    <span class="comment">// 画刷填充的样式（这里是实心）</span></span><br><span class="line">    <span class="comment">// 画刷设置完后，给 QPainter 装上指定画刷：</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘图</span></span><br><span class="line">    painter.<span class="built_in">drawRect</span>(rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序先从 <code>QPainter</code> 说起，<code>QPainter::setRenderHint(QPainter::Antialiasing)</code> 表示绘制图形抗锯齿（默认关闭），<code>QPainter::setRenderingHint(QPainter::Textantialiasing)</code></p>
<p>然后是 <code>QPen</code>，以上已经展示了大多数情况下会用到的方法：<strong>如何设置线宽、颜色、线的样式、端点样式和连接点样式</strong>。</p>
<p>其中，线的样式有枚举量 <code>Qt::PenStyle</code>，常用的值有 <code>Qt::SolidLine</code>（实线）、<code>Qt::DashLine</code>（虚线）、<code>Qt::DotLine</code>（点状线）、<code>Qt::DashDotLine</code>（点划线）、还有自定义样式 <code>Qt::CustomDashLine</code>，要结合 <code>setDashOffset()</code> 和 <code>setDashPattern()</code> 使用。</p>
<p>线端点的样式有枚举量 <code>Qt::PenCapStyle</code>，常用的值有 <code>Qt::Square</code>（方形端点）、<code>Qt::FlatCap</code>（平端点）、<code>Qt::RoundCap</code>（圆润端点）。</p>
<p>线条连接样式有枚举量 <code>Qt::PenJoinStyle</code>，常用的值有 <code>Qt::BevelJoin</code>、<code>Qt::MiterJoin</code>、<code>Qt::RoundJoin</code>；</p>
<p>然后是 <code>QBrush</code>，主要常用的方法就 4 个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QBrush::setColor</span><span class="params">(<span class="type">const</span> QColor&amp; color)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QBrush::setStyle</span><span class="params">(Qt::BrushStyle style)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QBrush::setTexture</span><span class="params">(<span class="type">const</span> QPixmap&amp; pixmap)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QBrush::setTextureImage</span><span class="params">(<span class="type">const</span> QImage&amp; image)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>QColor</code> 和之前见到过的一样，可以用枚举类型，也可以手动创建对象。</p>
<p>先介绍 <code>Qt::BrushStyle</code> 枚举类型，它定义的是填充样式，常用的值有：<code>Qt::NoBrush</code>（不填充）、<code>Qt::SolidBrush</code>（单一颜色填充）、<code>Qt::HorPattern</code>（水平线填充）、<code>Qt::VerPattern</code>（垂直线填充）、<code>Qt::TexturePattern</code>（材质填充，<strong>需要指定 texture 或 texture image</strong>）、<code>Qt::LinearGradientPattern</code>（线性渐变，需要使用 <code>QLinearGradient</code> 类作为 brush）、<code>Qt::RadialGradientPattern</code>（辐射渐变，需要使用 <code>QRadialGradient</code> 类作为 brush）、<code>Qt::ConicalGradientPattern</code>（圆锥渐变，需要使用 <code>QConicalGradient</code> 类作为 brush）；</p>
<p>渐变的使用暂时不介绍了，用到再上网查。</p>
<h4 id="补充：QPixmap-和-QImage"><a href="#补充：QPixmap-和-QImage" class="headerlink" title="补充：QPixmap 和 QImage"></a>补充：QPixmap 和 QImage</h4><p>下面分析一下 <code>QPixmap</code> 和 <code>QImage</code> 类<strong>本身的</strong>使用方法。</p>
<p>它们的构造函数比较简单，可以是含有图片的 uri 字符串，也可以是 <code>QUrl</code>，构造后即可将图片像素信息读入对象中。</p>
<p>两者有一些差别，<code>QPixmap</code> 主要是用于绘图，<strong>针对屏幕显示而最佳化设计</strong>（适合小图片的呈现），<code>QImage</code> 主要是为图像I/O、图片访问和<strong>像素修改</strong>而设计的类（适合大图片的编辑）。</p>
<p>这些差别可以从常用的方法上看出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QImage 类允许从空构造, QImage::QImageFormat 枚举类型含有多种图片格式</span></span><br><span class="line">QImage::<span class="built_in">QImage</span>(<span class="type">int</span> x, <span class="type">int</span> y, QImage::QImageFormat f);</span><br><span class="line">QImage::<span class="built_in">QImage</span>(<span class="type">const</span> QString&amp; picture);</span><br><span class="line"><span class="comment">// 方法允许直接修改像素点</span></span><br><span class="line"><span class="comment">// 注：QRgb 构造函数参数就是 R、G、B 值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QImage::setPixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> QRgb&amp; rgb)</span></span>;</span><br><span class="line"><span class="comment">// 其他非常多方法，等到用到再介绍</span></span><br></pre></td></tr></table></figure>
<p>二者相互转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">QPixmap::fromImage</span><span class="params">(<span class="type">const</span> QImage&amp; image)</span></span>;</span><br><span class="line"><span class="function">QImage <span class="title">QPixmap::toImage</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="补充：基本图形元件"><a href="#补充：基本图形元件" class="headerlink" title="补充：基本图形元件"></a>补充：基本图形元件</h4><p>最后，介绍上面的示例中的最后一行 <code>painter.drawRect(rect);</code>，这说明 <code>QPainter</code> 底层能够直接绘制出基本的几何图形，这称为 <strong><code>QPainter</code> 绘制的基本图形元件</strong>。下面介绍一些 <code>QPainter</code> 类中常用的图形元件：</p>
<ul>
<li><p>绘制一个点 和 一组点：<code>QPainter::drawPoint(const QPoint&amp; p);</code> 和 <code>QPainter::drawPoints(const QPoint[] points, int size);</code> 示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">drawPoint</span>(<span class="built_in">QPoint</span>(W/<span class="number">2</span>, H/<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 一组点 --------------------------</span></span><br><span class="line">QPoint points[] = &#123;</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">5</span>*W/<span class="number">12</span>, H/<span class="number">4</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">3</span>*W/<span class="number">4</span>, <span class="number">5</span>*H/<span class="number">12</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">2</span>*W/<span class="number">4</span>, <span class="number">5</span>*H/<span class="number">12</span>)</span><br><span class="line">&#125;;</span><br><span class="line">painter.<span class="built_in">drawPoints</span>(points, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>QPoint</code> 类之前在鼠标事件中就遇到过，构造函数就是坐标系中的 x 和 y；</p>
</li>
<li><p>绘制弧线：<code>QPainter::drawArc(const QRect&amp; rect, int startAngle, int spanAngle);</code>（这里的 angle 是角度制）；示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">90</span> * <span class="number">16</span>;    <span class="comment">// 起始为坐标系中 90° 角，其中 0° 指向 x 轴正向</span></span><br><span class="line"><span class="type">int</span> span = <span class="number">90</span> * <span class="number">16</span>;        <span class="comment">// 旋转 90°</span></span><br><span class="line">painter.<span class="built_in">drawArc</span>(rect, start, span);</span><br></pre></td></tr></table></figure>
<p>聪明的小伙伴可能会问，为什么要乘以 16 呢？因为，出于绘图精细粒度和数据的保存考量，Qt 中大多数绘图角度使用整型（int），并且一个单位是 <strong>1 / 16</strong> 个角度（degree）。</p>
</li>
<li><p>绘制弦：<code>QPainter::drawChord(const QRect&amp; rect, int startAngle, int spanAngle);</code> 示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">90</span> * <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> span = <span class="number">90</span> * <span class="number">16</span>;</span><br><span class="line">painter.<span class="built_in">drawChord</span>(rect, start, span);</span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制矩形：<code>QPainter::drawRect(const QRect&amp; rect);</code> 上面的例子就是示例；</p>
</li>
<li><p><strong>擦除矩形</strong>：<code>QPainter::eraseRect(const QRect&amp; rect);</code> 示例显然。<strong>本质上是等效于用当前背景色填充该区域</strong>；</p>
</li>
<li><p>绘制圆角矩形：<code>QPainter::drawRoundedRect(const QRect&amp; rect);</code> 使用方法同矩形；</p>
</li>
<li><p>绘制扇形：<code>QPainter::drawPie(const QRect&amp; rect, int startAngle, int spanAngle);</code> 示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">40</span> * <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> span = <span class="number">120</span> * <span class="number">16</span>;</span><br><span class="line">painter.<span class="built_in">drawPie</span>(rect, start, span);</span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制凸多边形：<code>QPainter::drawConvexPolygon(const QPoint[] pArr, int size);</code> 示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QPoint points[<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">5</span>*W/<span class="number">12</span>, H/<span class="number">4</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">3</span>*W/<span class="number">4</span>, <span class="number">5</span>*H/<span class="number">12</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(<span class="number">5</span>*W/<span class="number">12</span>, <span class="number">3</span>*H/<span class="number">4</span>),</span><br><span class="line">    <span class="built_in">QPoint</span>(W/<span class="number">4</span>, <span class="number">5</span>*H/<span class="number">12</span>)</span><br><span class="line">&#125;;</span><br><span class="line">painter.<span class="built_in">drawConvexPolygon</span>(points, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制闭合多边形（闭合折线）：<code>QPainter::drawPolygon(const QPoint[] points, int size);</code> 使用方法同 “绘制凸多边形”；</p>
</li>
<li><p>绘制不闭合折线：<code>QPainter::drawPolyline(const QPoint[] points, int size);</code> 使用方法同 “绘制凸多边形”；</p>
</li>
<li><p>绘制椭圆：<code>QPainter::drawEllipse(const QRect&amp; rect);</code> 示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(rect);</span><br></pre></td></tr></table></figure>
<p>这里实际上是利用了椭圆的外接矩形唯一的特性，长轴长是矩形的长，宽也同理。</p>
</li>
<li><p>绘制<strong>图片</strong>：<code>QPainter::drawImage(const QRect&amp; rect, const QImage&amp; image);</code>  和 <code>QPainter::drawPixmap(const QRect&amp; rect, const QPixmap&amp; pixmap);</code>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">QImage <span class="title">image</span><span class="params">(<span class="string">&quot;:/imgs/qt.jpg&quot;</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawImage</span>(rect, image);</span><br><span class="line"><span class="comment">// 或者 Pixmap 图形 ----------------</span></span><br><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/imgs/qt.jpg&quot;</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawPixmap</span>(rect, pixmap);</span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制线段：<code>QPainter::drawLine(const QLine&amp; line);</code> 示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QLine <span class="title">line</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawLine</span>(line);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>QLine</code> 类，和之前的 <code>QPoint</code>、<code>QRect</code> 一样，都是表示二维图形的类。它的构造函数可以是两个点的坐标，也可以是两个 <code>QPoint</code> 对象。</p>
</li>
<li><p>绘制线段组：<code>QPainter::drawLines(const QVector&lt;QLine&gt;&amp; lines);</code> 示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">QVector&lt;QLine&gt; lines;</span><br><span class="line">lines.<span class="built_in">append</span>(<span class="built_in">QLine</span>(rect.<span class="built_in">topLeft</span>(), rect.<span class="built_in">bottomRight</span>()));</span><br><span class="line">lines.<span class="built_in">append</span>(<span class="built_in">QLine</span>(rect.<span class="built_in">topRight</span>(), rect.<span class="built_in">bottomLeft</span>()));</span><br><span class="line">lines.<span class="built_in">append</span>(<span class="built_in">QLine</span>(rect.<span class="built_in">topLeft</span>(), rect.<span class="built_in">bottomLeft</span>()));</span><br><span class="line">lines.<span class="built_in">append</span>(<span class="built_in">QLine</span>(rect.<span class="built_in">topRight</span>(), rect.<span class="built_in">bottomRight</span>()));</span><br><span class="line">painter.<span class="built_in">drawLines</span>(lines);</span><br></pre></td></tr></table></figure>
<p>这里用到了 <code>QRect</code> 类的调用顶点方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">QRect::topLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制定制的路径：<code>QPainter::drawPath(const QPainterPath&amp; path);</code> 示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">QPainterPath path;</span><br><span class="line">path.<span class="built_in">addEllipse</span>(rect);</span><br><span class="line">path.<span class="built_in">addRect</span>(rect);</span><br><span class="line">painter.<span class="built_in">drawPath</span>(path);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>QPainterPath</code> <strong>不是</strong>基本图形元件，而是复合图形对象。它是由一系列绘图操作的<strong>顺序集合</strong>，很多方法和 <code>QPainter</code> 很接近，也有专用函数，例如 <code>lineTo(const QPoint&amp;)</code>（在当前起点到指定点间连一条线段） <code>closeSubPath()</code>、<code>connectPath()</code> 等，感兴趣查阅文档。</p>
</li>
<li><p>绘制文字：<code>QPainter::drawText(const QRect&amp; rect, const QString&amp; text);</code> 示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(W/<span class="number">4</span>, H/<span class="number">4</span>, W/<span class="number">2</span>, H/<span class="number">2</span>)</span></span>;</span><br><span class="line">QFont font;</span><br><span class="line">font.<span class="built_in">setPointSize</span>(<span class="number">30</span>);</span><br><span class="line">font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">painter.<span class="built_in">setFont</span>(font);    <span class="comment">// 这里用 painter 设置字体</span></span><br><span class="line">painter.<span class="built_in">drawText</span>(rect, <span class="string">&quot;Hello, Qt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="QRect-和-QRectF"><a href="#QRect-和-QRectF" class="headerlink" title="QRect 和 QRectF"></a>QRect 和 QRectF</h4><p>我们在上面的例子中可以看到，几乎所有的绘画过程竟然都用到了 <code>QRect</code> 类。</p>
<p>看文档的同学可能会问，诶，这个经常看到 <code>QRect</code> 和 <code>QRectF</code> 类同时出现，它们有什么关系吗？实际上两者的目标是一样的，只不过是 “历史遗留问题”。</p>
<p>先出现的 <code>QRect</code> 的构造方法之一是<strong>左上、右下</strong>的点的坐标。这个构造是准确的，但是调用 <code>bottomRight()</code>、<code>bottonLeft()</code>、<code>topRight()</code> 返回的位置和实际位置<strong>相差 1 个单位</strong>。这是由于对于像素中心的划分方法导致的，只有 <code>topLeft()</code> 返回数据与实际数据相同，官方文档描述如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="QRect.png" height="750"></p>
<p>而后出现的 <code>QRectF</code>，修复了这个问题，所有方法都是准确的。所以，你既可以使用 <code>QRect</code>，但要记住这个 ± 1 的“陷阱”，也可以用 <code>QRectF</code>，这取决于自己，又或是项目的兼容性。</p>
<p>因为在 Qt 几乎所有的官方函数中，使用到 <code>QRect</code> 类的地方都用了 <code>QRectF</code> 重载了一下。留着 <code>QRect</code> 是为了向前兼容。</p>
<p>还有 <code>QPoint</code> 和 <code>QPointF</code> 等，想要中文版了解原因，强烈推荐这篇文章：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/lvdongjie/p/4816024.html">传送门🚪</a></p>
<h3 id="6-1-3-绘图坐标系-和-坐标变换"><a href="#6-1-3-绘图坐标系-和-坐标变换" class="headerlink" title="6.1.3 绘图坐标系 和 坐标变换"></a>6.1.3 绘图坐标系 和 坐标变换</h3><h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><p>在 6.1.1 中提到过，目前为止我们使用的都是<strong>视口坐标</strong>，这是 Qt 绘图的默认坐标系统，也被称为绘图设备的物理坐标。为了绘图方便，<code>QPainter</code> 还提供了变换绘图坐标的功能，例如<strong>平移、旋转</strong>等。这个时候，由于旋转涉及大量数学计算，所以使用<strong>逻辑坐标系统</strong>是最方便的。逻辑坐标会在接下来的讨论中逐步解释。</p>
<p>下面是 <code>QPainter</code> 关于坐标变换的相关方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::translate</span><span class="params">(qreal dx, qreal dy)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::rotate</span><span class="params">(qreal angle)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::scale</span><span class="params">(qreal sx, qreal sy)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::shear</span><span class="params">(qreal sh, qreal sv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::save</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::restore</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::resetTransform</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>先解释 <code>qreal</code>，它就是 Qt 用来存储实数的基础数据类型，和 <code>double</code> 类似的使用。</p>
<p><code>QPainter::translate()</code> 会<strong>将坐标系统的原点平移给定的偏移量</strong>；</p>
<p>⚠ 注意，这里平移的是坐标系统，<strong>不会改变已有图形的绝对位置，只会改变当前绘图的坐标、改变原有图形在当前坐标系统下的坐标</strong>。下面所有的功能也都是这样！！！</p>
<p><code>QPainter::rotate()</code> 会<strong>将坐标系统顺时针（+）旋转给定角度</strong>；</p>
<p>注：这个角度由于是 <code>qreal</code>，所以是 1° 的角度制。</p>
<p><code>QPainter::scale()</code> 会<strong>将坐标系统的 x、y 轴分别缩放指定倍数</strong>；</p>
<p>注：倍数大于 1 放大，小于 1 缩小。</p>
<p><code>QPainter::shear()</code> 会<strong>将坐标系统在水平、垂直方向做指定倍数的扭转变换</strong>；</p>
<p><code>QPainter::save()</code> <strong>保存 <code>painter</code> 当前的状态，并将其压入堆栈</strong>；</p>
<p><code>QPainter::restore()</code> <strong>从堆栈中弹出并恢复到上一个 <code>painter</code> 状态</strong>；</p>
<p><code>QPainter::resetTransform()</code> <strong>复位所有的坐标变换</strong>；</p>
<h4 id="绘图坐标系"><a href="#绘图坐标系" class="headerlink" title="绘图坐标系"></a>绘图坐标系</h4><p>现在解释之前的 “<strong>视口坐标系</strong>”、“<strong>窗口坐标系</strong>” 和 “<strong>逻辑坐标系</strong>”。</p>
<p>视口（viewport）表示绘图设备的<strong>任意</strong>一个矩形区域的物理坐标，默认情况下等于绘图设备的整个矩形区域（意味着可以更改）；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::setViewport</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure>
<p>窗口（window）和 视口 是同一个矩形，只不过<strong>窗口是用逻辑坐标定义的坐标系</strong>。</p>
<p>逻辑坐标可以理解为一种相对的坐标，不代表物理坐标，只是数学上的参照。</p>
<p>上面的解释非常抽象，以一个例子说明：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="viewport_and_window.png" height="150"></p>
<p>如上图，（a）的外围矩形框代表绘图设备的物理大小、坐标范围，假设宽 300px，高 200px。现在取中间的正方形阴影区域作为视口。因此视口的左上角在设备的物理坐标（50，0），右下角（250，200）；可以这么设置：<code>painter.setViewport(50, 0, 200, 200);</code>；<strong>而在设置指定视口后，逻辑坐标还没有确定，因为没有确定窗口</strong>。</p>
<p>对于给定的视口，<strong>可以在其上定义窗口</strong>，这里<strong>定义窗口就是在定义逻辑坐标系</strong>。为什么这么说？因为别忘了<strong>窗口和视口是同一个矩形</strong>，这时设置窗口坐标相当于指定窗口在逻辑坐标系中的位置，进而可以由 <code>QPainter</code> 底层计算出逻辑坐标的情况。</p>
<p>例如，这里我设置 <code>painter.setWindow(-50, -50, 100, 100);</code> 代表当前的窗口左上角在逻辑坐标的位置是（-50，-50），当前窗口的逻辑宽度、逻辑高度都是 100；<strong>注意：逻辑宽度、逻辑高度设置后，可能比例与物理宽高不一致，这取决于您给定的数字。这个例子中逻辑长度和物理长度是 1：1</strong>。由此建立的逻辑坐标系如图（b）所示。<strong>以后的坐标都按逻辑坐标系来给定</strong>。</p>
<p>为什么要大费周章引入这一系列坐标系？直接用视口坐标（物理坐标）不行吗？其实窗口坐标（逻辑坐标）有优点，就是只需按窗口坐标的定义来绘图，不用管实际物理坐标范围。<strong>例如在固定边长 100px（物理长度）的正方形窗口中绘图，当实际设备的大小变化（可能是用户拖动），绘制图形会自动变化实际大小来适应相对大小</strong>。</p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>现在综合之前的知识做个练习：在画布上绘制一个正五角星，并在一旁绘制至少 2 个旋转了不同角度的正五角星。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请自行实现 Canvas 类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Canvas::paintEvent</span><span class="params">(QPaintEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.<span class="built_in">setWidth</span>(<span class="number">3</span>);</span><br><span class="line">    pen.<span class="built_in">setColor</span>(Qt::blue);</span><br><span class="line">    pen.<span class="built_in">setStyle</span>(Qt::SolidLine);</span><br><span class="line">    pen.<span class="built_in">setCapStyle</span>(Qt::RoundCap);</span><br><span class="line">    pen.<span class="built_in">setJoinStyle</span>(Qt::RoundJoin);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">    QBrush brush;</span><br><span class="line">    brush.<span class="built_in">setStyle</span>(Qt::NoBrush);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> H = <span class="keyword">this</span>-&gt;<span class="built_in">height</span>();</span><br><span class="line">    <span class="type">int</span> W = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>();</span><br><span class="line">    <span class="type">const</span> qreal PI = <span class="number">3.141592653</span>;</span><br><span class="line">    <span class="function">QRectF <span class="title">rect</span><span class="params">(-W/<span class="number">2</span>, -H/<span class="number">8</span>, W/<span class="number">2</span>, H/<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setViewport</span>(W/<span class="number">8</span>, H/<span class="number">8</span>, <span class="number">3</span>*W/<span class="number">4</span>, <span class="number">3</span>*H/<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 数学好的同学这里一眼就看出来，逻辑长度:物理长度 = 3:4</span></span><br><span class="line">    painter.<span class="built_in">setWindow</span>(<span class="number">0</span>, -H/<span class="number">2</span>, W, H);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> qreal m = <span class="built_in">qMin</span>(H, W);</span><br><span class="line">    </span><br><span class="line">    <span class="function">QPoint <span class="title">center_1</span><span class="params">(-m/<span class="number">2</span>+m/<span class="number">6</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">center_2</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">center_3</span><span class="params">(m/<span class="number">2</span>-m/<span class="number">6</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_1</span><span class="params">(<span class="number">0</span>, -m/<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_2</span><span class="params">(m/<span class="number">6</span>*std::cos(<span class="number">2</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>), m/<span class="number">6</span>*std::sin(<span class="number">2</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_3</span><span class="params">(m/<span class="number">6</span>*std::cos(<span class="number">4</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>), m/<span class="number">6</span>*std::sin(<span class="number">4</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_4</span><span class="params">(m/<span class="number">6</span>*std::cos(<span class="number">6</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>), m/<span class="number">6</span>*std::sin(<span class="number">6</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p_1_5</span><span class="params">(m/<span class="number">6</span>*std::cos(<span class="number">8</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>), m/<span class="number">6</span>*std::sin(<span class="number">8</span>*PI/<span class="number">5</span>-PI/<span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    QPainterPath* path = <span class="keyword">new</span> <span class="built_in">QPainterPath</span>(p_1_1);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_3);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_5);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_2);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_4);</span><br><span class="line">    path-&gt;<span class="built_in">lineTo</span>(p_1_1);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawPath</span>(*path);</span><br><span class="line">    painter.<span class="built_in">translate</span>(m/<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    painter.<span class="built_in">rotate</span>(<span class="number">30</span>);</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(*path);</span><br><span class="line">    painter.<span class="built_in">translate</span>(m/<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    painter.<span class="built_in">rotate</span>(<span class="number">30</span>);</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(*path);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-2-QGraphicsView-进阶绘图"><a href="#6-2-QGraphicsView-进阶绘图" class="headerlink" title="6.2 QGraphicsView 进阶绘图"></a>6.2 <code>QGraphicsView</code> 进阶绘图</h2><p>在介绍 <code>QGraphicsView</code> 前，请大家回想在第 4 章使用的 <code>QTableWidget</code>（父类 <code>QTableView</code>），它是 <strong>model/view（模型/视图）结构</strong>。在 Qt 中，model/view 结构是 Qt 界面组件显示与编辑数据的一种结构，视图时显示和编辑数据的界面组件，而模型是视图与原始数据之间的接口。最典型的应用是在数据库软件中的表单渲染。</p>
<p>主要用到的视图组件有 <code>QListView</code>、<code>QTreeView</code>、<code>QTableView</code>  等，它们对应的 <code>XXXWidget</code> 则是一层包装，直接用项存储，而在更高级的用法中就需要 model/view 的结构了。看下面的关系图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="model_view.png" height="275"></p>
<ul>
<li><p>数据（Data）：就是实际的数据，例如数据库的一个表、SQL 查询结果、内存里的一个数组、磁盘文件结构等等；</p>
</li>
<li><p>视图或视图组件（View）：是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引（model index），然后依此获得数据并显示。Qt 中的例子如下，大家根据需要，用到再查询文档使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QListView: 用于显示单列的列表数据，适用于一维数据的展示和操作</span><br><span class="line">QTreeView: 用于显示树状结构数据</span><br><span class="line">QTableView: 用于显示表格状数据，适用于二维表格型数据的展示和操作</span><br><span class="line">QColumnView: 用于多个 QListView 显示树状层次，每层用一个 QListView 表示</span><br><span class="line">QHeaderView: 提供表头或列表头的视图组件，例如 QTableView 的行表头和列表头</span><br></pre></td></tr></table></figure>
<p><strong>这些视图组件一般调用 <code>setModel()</code>  来设置模型或数据模型的种类</strong>。</p>
</li>
<li><p>模型或数据模型（Model）：与实际数据通信，并且为视图组件提供数据接口。主要是从原始数据提取内容，并提示视图组件进行显示、编辑。Qt 中的例子如下，大家根据需要，用到再查询文档使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QStringListModel: 用于处理字符串列表的数据模型类</span><br><span class="line">QStandardItemModel: 标准的基于项数据的数据模型类，每个项数据可以是任何数据类型</span><br><span class="line">QFileSytemModel: 计算机上文件系统的数据模型类</span><br><span class="line">QSortFilterProxyModel: 与其他数据类型结合，提供排序、过滤等功能的数据模型类</span><br><span class="line"></span><br><span class="line">QSqlQueryModel: 用于数据库 SQL 查询结果的数据模型类</span><br><span class="line">QSqlTableModel: 用于数据库的一个数据表的数据模型类</span><br><span class="line">QSqlRelationalTableModel: 用于关系型数据库的数据模型类</span><br><span class="line"></span><br><span class="line">// 如果上面的类不能满足要求，还可以自己从 QAbstractItemModel、QAbstractListModel、QAbstractTableModel 等类自行定制</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理（Delegate）：这可以让用户定制数据的显示和编辑方式。默认情况下代理显示一个数据，当数据被编辑时，代理通过 model index 和数据模型通信（一般会提供编辑器，默认 <code>QLineEdit</code>）；</p>
<p>通俗地解释一下，第 4 章中，我们使用 <code>QTableWidget</code> 来创建表格区域时，双击修改表格会弹出一个 <code>QLineEdit</code>，输入回车后消失，它就是代理。当然，除了 <code>QLineEdit</code>，对于特定场景，例如只允许输入整型，那么 <code>QSpinBox</code> 合适，如果要从列表中选择数据填入，那么 <code>QComboBox</code> 合适。<strong>这时，可以从 <code>QStyledItemDelegate</code> 来继承创建一个自定义代理类</strong>。</p>
</li>
<li><p>View、Model、Delegate 三者间通过信号-槽通信：源数据改变时，model 向 view 发射信号；用户在 view 中操作数据时，view 向 model 发射信号；用户借助代理编辑数据时，delegate 向 model 和 view 发射信号。</p>
</li>
<li><p>Model/View 结构有一些约定的实现需要了解。</p>
<ul>
<li>数据<strong>形式上</strong>还是以项的形式存在；这意味着第 4 章中对于 “<code>QTableWidgetItem</code> 设计” 的探讨，这里对于所有的 <code>QStandardItem</code> 都是一样的，都有 “role” 的说法；</li>
<li>为了保证数据表示 和 数据存取方式的隔离，数据模型中引入了<strong>模型索引（model index）</strong>的概念。通过数据模型存取的每一个数据都有一个模型索引，视图组件 view 和代理 delegate 都通过调用 model 的模型索引来定位、获取数据；</li>
<li>模型索引有个专门的类来表示：<code>QModelIndex</code>，它提供数据存取的<strong>临时指针</strong>（数据模型内部组织数据的结构随时可能改变）。如果想要持久性的索引，可能需要 <code>QPersistentModelIndex</code> 类，但会牺牲部分的性能和空间；</li>
<li>由模型索引确定数据，<strong>需要向 <code>QModelIndex</code> 传递 3 个参数：行号、列号、父项的模型索引</strong>。但请注意，这不代表底层的数据以二维数组存储，只是这么表示更方便，所以 <code>QModelIndex</code> 的接口就这么设计。行和列的编号好说，在 <code>List Model</code> 和 <code>Table Model</code> 中就是原本的意思，在 <code>Tree Model</code> 中行指深度优先的编号；父项索引也好说，在 <code>Tree Model</code> 中就是原本的意思，在 <code>List Model</code> 和 <code>Table Model</code> 中就是空对象（<code>QModelIndex()</code>）；</li>
</ul>
</li>
</ul>
<p>铺垫了这么多 model/view 结构的知识，接下来终于可以开始讨论 <code>QGraphicsView</code> 的使用了。</p>
<h3 id="6-2-1-场景、视图、图形项"><a href="#6-2-1-场景、视图、图形项" class="headerlink" title="6.2.1 场景、视图、图形项"></a>6.2.1 场景、视图、图形项</h3><p>前一节叙述的 <code>QPainter</code> 绘图只能实现一些简单的绘制事件。对于复杂度高、交互性强、图形间的逻辑关系复杂的情况，很可能就需要 Graphics View 绘图架构来完成。</p>
<p>这种架构是基于 Graphics/Item 的模型/视图模式，和 Model/View 模式类似。Graphics/Item 模式由 3 个部分组成：<strong>场景、视图、图形项</strong>。</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p> <code>QGraphicsScene</code> 类提供绘图场景（Scene）。场景本身不可见，是一个抽象的<strong>管理图形项的容器</strong>，可以向场景加入图形项，获取场景中某个图形项等功能，具体如下：</p>
<ul>
<li>提供管理大量图形项的快速接口；</li>
<li>将事件传播给每个图形项；</li>
<li>管理每个图形项的状态，例如选择、焦点状态；</li>
<li>管理未经变换的渲染功能（主要用于打印）；</li>
</ul>
<p>场景中除了图形项，还有<strong>背景层</strong>和<strong>前景层</strong>，通常用 <code>QBrush</code> 指定，也可以重写 <code>drawBackground()</code>、<code>drawForeground()</code> 来自定义效果；</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p><code>QGraphicsView</code> 提供绘图的视图（view）组件，用于显示场景中的内容。可以为一个场景设置多个视图，也可以对同一个数据集提供不同视口。下图展示了场景、视图、图形项三者间的关系：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="graphics_view.png"></p>
<p>虚线框是场景，视图 1 范围比场景大，因此可以显示全部内容（默认居中显示在视图中，可调整视图的 <code>Alignment</code> 属性）；视图 2 小于场景，仅能显示一部分内容，但会<strong>自动</strong>提供滚动条在整个场景中滚动。</p>
<p><strong>视图负责接收键鼠输入事件，并转换为场景事件，经过坐标变换后传送给可视场景</strong>。</p>
<h4 id="图形项"><a href="#图形项" class="headerlink" title="图形项"></a>图形项</h4><p>图形项（Graphics Item）就是一些基本图形元件，基类是 <code>QGraphicsItem</code>。Qt 提供了一些基本的图形项，例如椭圆 <code>QGraphicsEllipseItem</code>、矩形 <code>QGraphicsRectItem</code>、文字 <code>QGraphicsTextItem</code> 等。</p>
<p><code>QGraphicsItem</code> 支持如下操作：</p>
<ul>
<li>一切鼠标、键盘、按键输入事件；</li>
<li>支持拖放操作；</li>
<li>支持组合，可以是父子项关系组合，也可以通过 <code>QGraphicsItemGroup</code> 类进行组合；</li>
</ul>
<h3 id="6-2-2-Graphics-View-的坐标系统"><a href="#6-2-2-Graphics-View-的坐标系统" class="headerlink" title="6.2.2 Graphics View 的坐标系统"></a>6.2.2 Graphics View 的坐标系统</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Graphics View 系统有 3 个有效坐标系：<strong>图形项坐标</strong>、<strong>场景坐标</strong>、<strong>视图坐标</strong>。</p>
<p>其中，<strong>绘图时，场景坐标等价于 <code>QPainter</code> 的逻辑坐标</strong>，一般以场景中心为原点；</p>
<p><strong>视图坐标与设备坐标（物理坐标）相同，是绝对的，默认以左上角为原点</strong>；</p>
<p><strong>图形项坐标是 <u>局部逻辑坐标</u></strong>，一般以某个图形项的几何中心为原点。</p>
<p>这里很多教程和书籍写的很麻烦，下面用一段话来总结一下：</p>
<p>首先对于一个图形项而言，就只讨论图形项坐标。图形项坐标就是<strong>以当前图形项为参考系的坐标</strong>；而这个图形项本身整体坐标以几何中心为位置，按其父级 <code>QGraphicsItem</code> 的图形项坐标来表示位置。如果上层没有 <code>QGraphicsItem</code>，那么事件的位置就是<strong>场景坐标位置</strong>。这就意味着图形项坐标层层嵌套，最外层是场景坐标系。因此，场景坐标描述了每个顶层图形项的坐标位置。</p>
<p>而视图坐标就是<strong>窗口界面（widget）的物理坐标（单位像素）</strong>，只与 widget 有关，与场景无关。<strong>更重要的是，所有鼠标事件、拖动事件的坐标首先由视图坐标定义，然后由转换矩阵转换为场景坐标，以便与图形项交互</strong>。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>那么如何使用？首先创建场景的时候就可以定义场景坐标范围：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsScene::<span class="built_in">QGraphicsScene</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height);</span><br></pre></td></tr></table></figure>
<p>在使用时，虽然 <code>QGraphicsScene</code> 描述的是顶层 <code>QGraphicsItem</code>，但有一层封装可以取得所有图形项的场景坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">QGraphicsItem::scenePos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>还有 <code>QGraphicsItem</code> 在其父级中的坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">QGraphicsItem::pos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：除了上面两个方法，<code>QGraphicsItem</code> 的方法返回的位置几乎都是自己的<strong>局部坐标</strong>；</p>
<p>例如获得 <code>QGraphicsItem</code> 的边界矩形框的方法，返回的就是边界矩形在自己的局部坐标系下的坐标值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">QGraphicsItem::boundingRect</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>既然 <code>pos()</code> 有对应在场景中的 <code>scenePos()</code>，那么 <code>boundingRect()</code> 也有在场景中的 <code>sceneBoundingRect()</code>，<strong>可以指出当前图形项在场景中的边界矩形、图形项的边界有什么变化等</strong>。</p>
<p><strong>场景本身也会在变化时发射 <code>QGraphicsScene::changed()</code> 信号，参数是一个场景坐标中的 <code>QRect[]</code>，表示发生变化的矩形区</strong>；</p>
<h4 id="坐标映射"><a href="#坐标映射" class="headerlink" title="坐标映射"></a>坐标映射</h4><p>在场景中操作图形项的时候，在场景、图形项、视图间的坐标变换是非常有用的，这被称为 “坐标映射”。我们可以通过 <strong><code>QGraphicsView::mapToScene()</code></strong> 从视图坐标映射为场景坐标，然后用 <strong><code>QGraphicsScene::itemAt()</code></strong> 获取场景中<strong>鼠标光标处的图形项</strong>；</p>
<h3 id="6-2-3-主要类的接口"><a href="#6-2-3-主要类的接口" class="headerlink" title="6.2.3 主要类的接口"></a>6.2.3 主要类的接口</h3><p>在接口列表中，<strong>我们省去了设置函数对应的读取函数，例如 <code>setScene()</code> 有对应的 <code>scene()</code> 读，后者是有的，但不会赘述</strong>，同时省去作用域符 <code>::</code> 和显然的参数、<code>const</code> 修饰。</p>
<h4 id="QGraphicsView"><a href="#QGraphicsView" class="headerlink" title="QGraphicsView"></a><code>QGraphicsView</code></h4><p>对于这个类，主要讨论的是它的视口坐标（视图坐标，也就是物理坐标）。下面列出类中常用的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景类型的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScene</span><span class="params">()</span></span>;        <span class="comment">// 设置与 view 关联的场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSceneRect</span><span class="params">()</span></span>;    <span class="comment">// 用 QRect 设置</span></span><br><span class="line"><span class="comment">// 外观类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlignment</span><span class="params">()</span></span>;    <span class="comment">// 设置场景在视图中的对齐方式，默认上下都居中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setBackgroundBrush</span><span class="params">()</span></span>;    <span class="comment">// 设置场景的背景画刷，用来管理背景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setForegroundBrush</span><span class="params">()</span></span>;    <span class="comment">// 前景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setRenderHints</span><span class="params">()</span></span>;    <span class="comment">// 设置绘图选项，回想一下 QPainter::setRenderHints()</span></span><br><span class="line"><span class="comment">// 交互类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setInteractive</span><span class="params">()</span></span>;    <span class="comment">// 设置场景是否允许交互。如果禁止，那么键鼠事件也会被忽略</span></span><br><span class="line"><span class="function">QRect <span class="title">rubberBandRect</span><span class="params">()</span></span>;    <span class="comment">// 返回当前选中的矩形框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setRubberBandSelectionMode</span><span class="params">()</span></span>;    <span class="comment">// 就是设置选择模式：能否选择、能否多选等，请回想 QTableWidget::setSelectionMode()</span></span><br><span class="line"><span class="function">QGraphicsItem* <span class="title">itemAt</span><span class="params">()</span></span>;    <span class="comment">// 获取视图（物理）坐标系中某位置处的图形项</span></span><br><span class="line"><span class="function">QList&lt;QGraphicsItem*&gt; <span class="title">items</span><span class="params">()</span></span>;    <span class="comment">// 返回场景中所有 / 某个选中区域的图形项列表</span></span><br><span class="line"><span class="comment">// 坐标映射型</span></span><br><span class="line"><span class="function">QPoint <span class="title">mapFromScene</span><span class="params">()</span></span>;    <span class="comment">// 场景坐标 转 视图坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapToScene</span><span class="params">()</span></span>;    <span class="comment">// 视图坐标 转场景坐标</span></span><br></pre></td></tr></table></figure>
<h4 id="QGraphicsScene"><a href="#QGraphicsScene" class="headerlink" title="QGraphicsScene"></a><code>QGraphicsScene</code></h4><p>这个类就是用于管理图形项的场景，是图形项的容器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSceneRect</span><span class="params">()</span></span>;    <span class="comment">// 设置场景的矩形边界，和 QGraphicsView 一样能改</span></span><br><span class="line"><span class="comment">// 分组类型</span></span><br><span class="line"><span class="function">QGraphicsItemGroup* <span class="title">createItemGroup</span><span class="params">()</span></span>;    <span class="comment">// 创建图形项组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroyItemGroup</span><span class="params">()</span></span>;    <span class="comment">// 解除一个图形项组</span></span><br><span class="line"><span class="comment">// 输入焦点类型</span></span><br><span class="line"><span class="function">QGraphicsItem* <span class="title">focusItem</span><span class="params">()</span></span>;    <span class="comment">// 返回当前获得焦点的图形项</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearFocus</span><span class="params">()</span></span>;            <span class="comment">// 去除选择焦点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasFocus</span><span class="params">()</span></span>;            <span class="comment">// 当前视图是否有焦点</span></span><br><span class="line"><span class="comment">// 图形项操作类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addItem</span><span class="params">()</span></span>;                <span class="comment">// 添加一个**已创建**的图形项</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeItem</span><span class="params">()</span></span>;            <span class="comment">// 删除图形项</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;                <span class="comment">// 清除场景中所有图形项</span></span><br><span class="line"><span class="function">QGraphicsItem* <span class="title">mouseGrabberItem</span><span class="params">()</span></span>;    <span class="comment">// 返回鼠标抓取的图形项</span></span><br><span class="line"><span class="function">QList&lt;QGraphicsItem*&gt; <span class="title">selectedItems</span><span class="params">()</span></span>;    <span class="comment">// 与QGraphicsView::items()差距很小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearSelection</span><span class="params">()</span></span>;        <span class="comment">// 清除当前所有选中</span></span><br><span class="line"><span class="function">QGraphicsItem* <span class="title">itemAt</span><span class="params">()</span></span>;    <span class="comment">// 获取场景坐标系下某位置的顶层图形项，和 QGraphicsView::itemAt(); 就是输入坐标有差异</span></span><br><span class="line"><span class="function">QList&lt;QGraphicsItem*&gt; <span class="title">items</span><span class="params">()</span></span>;    <span class="comment">// 参考 QGraphicsView::items();</span></span><br><span class="line"><span class="comment">// 添加图形项类型</span></span><br><span class="line"><span class="function">QGraphicsEllipseItem* <span class="title">addEllipse</span><span class="params">()</span></span>;    <span class="comment">// 加一点椭圆</span></span><br><span class="line"><span class="function">QGraphicsLineItem* <span class="title">addLine</span><span class="params">()</span></span>;        <span class="comment">// 加一点线段</span></span><br><span class="line"><span class="function">QGraphicsPathItem* <span class="title">addPath</span><span class="params">()</span></span>;        <span class="comment">// 加一点 QPainterPath</span></span><br><span class="line"><span class="function">QGraphicsPixmapItem* <span class="title">addPixmap</span><span class="params">()</span></span>;    <span class="comment">// 加一点 pixmap</span></span><br><span class="line"><span class="function">QGraphicsPolygonItem* <span class="title">addPolygon</span><span class="params">()</span></span>;    <span class="comment">// 加一点多边形</span></span><br><span class="line"><span class="function">QGraphicsRectItem* <span class="title">addRect</span><span class="params">()</span></span>;        <span class="comment">// 加一点矩形</span></span><br><span class="line"><span class="function">QGraphicsSimpleTextItem* <span class="title">addSimpleText</span><span class="params">()</span></span>;    <span class="comment">// 加一点简单文字</span></span><br><span class="line"><span class="function">QGraphicsTextItem* <span class="title">addText</span><span class="params">()</span></span>;        <span class="comment">// 加一点字符串</span></span><br><span class="line"><span class="function">QGraphicsProxyWidget* <span class="title">addWidget</span><span class="params">()</span></span>;    <span class="comment">// 加一点界面组件</span></span><br><span class="line">                                    <span class="comment">// 味道好极了</span></span><br></pre></td></tr></table></figure>
<h4 id="QGraphicsItem"><a href="#QGraphicsItem" class="headerlink" title="QGraphicsItem"></a><code>QGraphicsItem</code></h4><p>它是所有图形项的基类，用户可以从它继承定义自己的图形项类。Qt 中常见的图形项类的继承关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsItem</span><br><span class="line">    |</span><br><span class="line">    ├─ QAbstractGraphicsShapeItem</span><br><span class="line">    |			|</span><br><span class="line">    |			├─ QGraphicsEllipseItem</span><br><span class="line">    |			├─ QGraphicsPathItem</span><br><span class="line">    |			├─ QGraphicsPolygonItem</span><br><span class="line">    |			├─ QGraphicsRectItem</span><br><span class="line">    |			└─ QGraphicsSimpleTextItem</span><br><span class="line">    |</span><br><span class="line">    ├─ QGraphicsLineItem</span><br><span class="line">    ├─ QGraphicsPixmapItem</span><br><span class="line">    ├─ QGraphicsObject</span><br><span class="line">    |		|</span><br><span class="line">    |		└─ QGraphicsTextItem</span><br><span class="line">    |</span><br><span class="line">    └─ QGraphicsItemGroup</span><br></pre></td></tr></table></figure>
<p>这个 <code>QGraphicsItem</code> 类提供了对图形项的基本操作方法，常见方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性设置类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setFlags</span><span class="params">()</span></span>;        <span class="comment">// 设置图形项的操作属性，例如可选择、可移动等</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setOpacity</span><span class="params">()</span></span>;        <span class="comment">// 如其名，设置透明度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGraphicsEffect</span><span class="params">()</span></span>;    <span class="comment">// 设置图形效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSelected</span><span class="params">()</span></span>;        <span class="comment">// 设置图形项是否被选中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">()</span></span>;            <span class="comment">// 用户自定义数据</span></span><br><span class="line"><span class="comment">// 坐标类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">()</span></span>;            <span class="comment">// 图形项在父级中的 X 坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">()</span></span>;            <span class="comment">// Y 坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setZValue</span><span class="params">()</span></span>;        <span class="comment">// Z 值控制叠放次序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPos</span><span class="params">()</span></span>;            <span class="comment">// 图形项在父级中的位置</span></span><br><span class="line"><span class="function">QPointF <span class="title">scenePos</span><span class="params">()</span></span>;        <span class="comment">// 返回图形项在场景中的坐标，相当于在 mapToScene 上包装</span></span><br><span class="line"><span class="comment">// 坐标变换类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetTransform</span><span class="params">()</span></span>;    <span class="comment">// 复位坐标系，取消所有变换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setRotation</span><span class="params">()</span></span>;        <span class="comment">// 顺时针(+)旋转指定角度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScale</span><span class="params">()</span></span>;        <span class="comment">// 等比例缩放</span></span><br><span class="line"><span class="comment">// 坐标映射类型</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapFromItem</span><span class="params">()</span></span>;    <span class="comment">// 将另一个图形项的一个**点**映射到本图形项的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapFromParent</span><span class="params">()</span></span>;<span class="comment">// 将父级的一个点映射到本图形项的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapFromScene</span><span class="params">()</span></span>;    <span class="comment">// 将场景的一个点映射到本图形项的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapToItem</span><span class="params">()</span></span>;    <span class="comment">// 将本图形项的一个点映射到另一个图形项的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapToParent</span><span class="params">()</span></span>;    <span class="comment">// 将本图形项的一个点映射到父级的局部坐标</span></span><br><span class="line"><span class="function">QPointF <span class="title">mapToScene</span><span class="params">()</span></span>;    <span class="comment">// 将本图形项的一个点映射到场景坐标</span></span><br><span class="line"><span class="comment">// 绘制类型</span></span><br><span class="line"><span class="comment">// 注意！QGraphicsItem 也可以像 QPainter 一样指定绘制的工具</span></span><br><span class="line"><span class="comment">// ...(略)</span></span><br><span class="line"><span class="comment">// 再补充一个改变鼠标悬停样式的方法：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setCursor</span><span class="params">()</span></span>;        <span class="comment">// 参数请参考 QApplication::setOverrideCursor()</span></span><br></pre></td></tr></table></figure>
<p>这里说一下 <code>QGraphicsItem::setFlags()</code>  的使用，参数就是 <code>QGraphicsItem::QGraphicsItemFlag</code> 枚举类型，其值也是十六进制数码，<strong>也允许按位或组合</strong>，常见值有：<code>QGraphcisItem::ItemIsMovable</code>、<code>QGraphicsItem::ItemIsSelectable</code>、<code>QGraphicsItem::ItemIsFocusable</code> 等；</p>
<h2 id="6-3-章末总结"><a href="#6-3-章末总结" class="headerlink" title="6.3 章末总结"></a>6.3 章末总结</h2><h3 id="6-3-1-知识补充"><a href="#6-3-1-知识补充" class="headerlink" title="6.3.1 知识补充"></a>6.3.1 知识补充</h3><p>Qt 中有格式化字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static function</span></span><br><span class="line"><span class="function">QString <span class="title">QString::asprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, __VAR_ARGS__)</span></span>;</span><br></pre></td></tr></table></figure>
<p>格式化占位符和 C++ 的 <code>printf</code> 函数相同；</p>
<p>Qt 中还有一个类，比较常用，但是内容很少，就不再另起一节——它就是 <code>QTimer</code>；</p>
<p><code>QTimer</code> 用于创建和管理定时器。它提供了一种机制，可以在给定的时间间隔内发出信号。比较常用的方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QTimer::<span class="built_in">QTimer</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTimer::interval</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 查询时间间隔</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setInterval</span><span class="params">(<span class="type">int</span> milliSeconds)</span></span>;    <span class="comment">// 设置触发间隔</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isActive</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 当前是否正在计时</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isSingleShot</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// 是否是只触发一次的计时器</span></span><br><span class="line"><span class="comment">// slots:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::start</span><span class="params">()</span></span>;                        <span class="comment">// 计时开始</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::stop</span><span class="params">()</span></span>;                        <span class="comment">// 计时停止</span></span><br><span class="line"><span class="comment">// signals:</span></span><br><span class="line"><span class="comment">// 除非是仅触发一次的计时器，否则每当开始后 interval 的整数倍时间就 emit 一次这个信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::timeout</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-2-类图总结"><a href="#6-3-2-类图总结" class="headerlink" title="6.3.2 类图总结"></a>6.3.2 类图总结</h3><p>前面几章遇到的类图的总结如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C6.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SJTU-XHW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/technical/qt-for-beginners-3/">https://blog.sjtuxhw.top/technical/qt-for-beginners-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SJTU-XHW's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Programming/">Programming</a><a class="post-meta__tags" href="/tags/Qt/">Qt</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/qt3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/technical/mc-forge-1/" title="MC-Forge开发笔记（一）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/minecraft1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MC-Forge开发笔记（一）</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference: Minecraft Forge Doc 1.16.x、Boson 1.16（导论部分） 注意：以 MC 版本 1.16.5 为例（同一大版本 1.16.x 的操作方式变化不大） 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！   Chapter 0. Forge 导论0.1 Forge 历史与定义 Minecraft 其中发行版的一个大类是由 Java写的商业软件，这意味着：  Minecraft 容易反编译和修改：由于 Java 半解释型语言的特性（但凡换成 C++ 就很可能不会有今天 Mod 丰富的生态了，毕竟 Mojang 当年一直不给官方 API）； 代码本身是闭源的、被混淆的：这毕竟是一款商业软件。   为了给 Minecraft 增添更多的游戏特性，大家千方百计地寻找添加代码的办法。最终 MCP（Mod Coder Pack）项目诞生了，它规避了没有官方 API 的问题，通过反编译、反混淆直接修改 Minecraft jar 包中的内容。其发展过程中，人们研究各类的名称的产生如下：  notch...</div></div></div></a><a class="pagination-related" href="/technical/qt-for-beginners-2/" title="从C++入门Qt（二）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/qt2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">从C++入门Qt（二）</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~   Chapter 4 第一个完整的 Qt 入门项目 在完成以上的学习过程后，在座诸位都具有独立写出一个极简的、较为完整 Qt 项目的能力； 以下，本人将用 纯代码方式 方式完成这个项目； 本章末，会总结到目前为止学到的所有 Qt 类的继承/思维图。  观前提示：本项目的设计思路很长，完整源代码放在 仓库 里，有需要可以取出查看 ~ 本章的目的是为了学习 Qt 一些组件的用法而已 ~ 项目目标：模仿 Microsoft Excel 设计一个表格应用程序。 4.1 创建主窗口 UI4.1.1 子类化 QMainWindow创建一个主窗口最方便的方法是利用 Qt 库中已有的设计类：QMainWindow。 QMainWindow 和...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/technical/qt-for-beginners-1/" title="从C++入门Qt（一）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/qt1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-28</div><div class="info-item-2">从C++入门Qt（一）</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~   Chapter 0 前置知识0.1 C++ 基础 和 面向对象编程0.2 C++ 的宏（macro） 宏的定义非常自由甚至可以把一个符号定义为一个很长的字符串，甚至代码；主要是因为宏的工作原理是编译前将宏直接原封不动地替换；例如下面的极端例子：  123456789101112131415// 直接把 HELLO 定义为一串代码#define HELLO \    QLabel* label = new QLabel(&quot;&lt;h2&gt;&lt;i&gt;Hello,&lt;/i&gt;&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;&quot;);\   ...</div></div></div></a><a class="pagination-related" href="/technical/qt-for-beginners-2/" title="从C++入门Qt（二）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/qt2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-16</div><div class="info-item-2">从C++入门Qt（二）</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~   Chapter 4 第一个完整的 Qt 入门项目 在完成以上的学习过程后，在座诸位都具有独立写出一个极简的、较为完整 Qt 项目的能力； 以下，本人将用 纯代码方式 方式完成这个项目； 本章末，会总结到目前为止学到的所有 Qt 类的继承/思维图。  观前提示：本项目的设计思路很长，完整源代码放在 仓库 里，有需要可以取出查看 ~ 本章的目的是为了学习 Qt 一些组件的用法而已 ~ 项目目标：模仿 Microsoft Excel 设计一个表格应用程序。 4.1 创建主窗口 UI4.1.1 子类化 QMainWindow创建一个主窗口最方便的方法是利用 Qt 库中已有的设计类：QMainWindow。 QMainWindow 和...</div></div></div></a><a class="pagination-related" href="/technical/rust-owner/" title="另一个角度看 Rust 所有权和借用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/rust-owner.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-06</div><div class="info-item-2">另一个角度看 Rust 所有权和借用</div></div><div class="info-2"><div class="info-item-1">笔者在一开始了解 Rust 的内存管理机制的时候，阅读了官方文档，以及网络上的教科书，它们首先都引入了所谓 “所有权” 和 “借用” 的概念。 笔者认为这样的叙述方法非常合适，特别是如果读者对操作系统原理与实现、C/C++ 语言不了解，那么这么讲授的方法是大概是最好的。因为这能够很快教给读者 rust 语言的规则，而不需要很多的知识储备或者语境。 但这也带来了弊端：很多读者会把它当作只有 rust 才有的特性、规定，但实际上这种系统设计思想可以用在很多地方。对于为什么 rust 要这么设计，则需要读者学了很长时间之后，结合计算机相关基础知识才能慢慢领会。 因此，个人认为应该从 C/C++ 如何变得安全的角度来讨论 rust 的这个语言特性会比较方便，因为 rust 本身就是在对标 C/C++ 内存不安全的问题，然后在此基础上进行改进。 笔者想提供一种思路，从 C/C++ 开发者的视角来解释 rust 为什么这么设计，然后再定义这两个性质，希望能对读者有所启发。本人学识短浅，望读者勘误/斧正。 如何设计一种全新的内存管理机制？假设你想创造一个新的编译型语言（就叫 rust），想和...</div></div></div></a><a class="pagination-related" href="/review/csapp-basic/" title="CSAPP Notes Basic"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="info-item-2">CSAPP Notes Basic</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference:  CMU - 213, Computer Systems A Programmer’s Perspective 3rd Edition by Randal Bryant, David O’Hallaron 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 内容很长，写起来很慢 😳   Chapter 0. Intro0.1 Ints are not Integers, Floats are not Reals $x^2\ge 0$：int（32-bit）may overflow； $a+(b+c)=(a+b)+c$：floats may discard some “unsignificant” digits；  0.2 Learn Assembly but never write it0.3 Memory Matters: Unbounded1234567891011121314typedef struct &#123;    int a[2];    double d;&#125;...</div></div></div></a><a class="pagination-related" href="/review/csapp-ecf-io/" title="CSAPP Notes: ECF &amp; I&#x2F;O"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-ecf.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-16</div><div class="info-item-2">CSAPP Notes: ECF &amp; I&#x2F;O</div></div><div class="info-2"><div class="info-item-1">Chapter 13. Exceptional Control Flow 对应书中第 8 章。  异常控制流是现代计算机系统的一个相当重要的部分。 13.1 Control Flow 控制流：从机器打开到关闭的过程中，处理器只做一件事：读指令、执行指令，一个周期做一个指令。多核的机器则每个核心依次交替执行指令。这些指令序列被称为控制流。硬件正在执行的实际指令序列就被称为物理控制流。  改变内存中控制流的方法：分支 &amp; 跳转，过程调用 &amp; 返回（Branches &amp; Jumps &amp; Procedure call and return）；  都是对于程序状态变化的处理。    但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）； 什么是 “系统级别的状态变化”？  数据从磁盘 / 网卡到达内存中； I/O 设备输入...</div></div></div></a><a class="pagination-related" href="/review/csapp-mm-cache/" title="CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-mh.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-10</div><div class="info-item-2">CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt</div></div><div class="info-2"><div class="info-item-1">Chapter 10. The Memory Hierarchy 本章将介绍系统的内存分层架构。  之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。 正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。 10.1 Storage Technologies &amp; Trends在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。 10.1.1 Random-Access Memory (RAM)当前大多数人所熟知的 “内存” 的一部分就是随机访问存储器（RAM），它具有以下的特征：  RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；  RAM 常常被打包放在 CPU 芯片中；  RAM 中每一个基本的存储单元被称为 单元胞（Cell），一个单元胞中存放 1 bit 数据；  很多个 RAM 芯片共同工作，组成了计算机的...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SJTU-XHW</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5-Qt-%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6"><span class="toc-text">Chapter 5. Qt 常用事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%86%85%E9%83%A8%E4%BA%8B%E4%BB%B6"><span class="toc-text">5.1 内部事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-text">5.2 鼠标事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">5.2.1 简单介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-QMouseEvent-%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-text">5.2.2 QMouseEvent 的传递方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-QMouseEvent-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">5.2.3 QMouseEvent 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE"><span class="toc-text">5.2.4 鼠标滚轮</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-text">5.3 键盘事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-6-Qt-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6"><span class="toc-text">Chapter 6. Qt 图形绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-QPainter-%E5%9F%BA%E6%9C%AC%E7%BB%98%E5%9B%BE"><span class="toc-text">6.1 QPainter 基本绘图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E7%BB%98%E5%9B%BE%E5%8C%BA"><span class="toc-text">6.1.1 绘图区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E7%BB%98%E5%9B%BE%E5%B1%9E%E6%80%A7"><span class="toc-text">6.1.2 绘图属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9AQPixmap-%E5%92%8C-QImage"><span class="toc-text">补充：QPixmap 和 QImage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E5%85%83%E4%BB%B6"><span class="toc-text">补充：基本图形元件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QRect-%E5%92%8C-QRectF"><span class="toc-text">QRect 和 QRectF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E7%BB%98%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB-%E5%92%8C-%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2"><span class="toc-text">6.1.3 绘图坐标系 和 坐标变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2"><span class="toc-text">坐标变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-text">绘图坐标系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-text">练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-QGraphicsView-%E8%BF%9B%E9%98%B6%E7%BB%98%E5%9B%BE"><span class="toc-text">6.2 QGraphicsView 进阶绘图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%9C%BA%E6%99%AF%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E5%9B%BE%E5%BD%A2%E9%A1%B9"><span class="toc-text">6.2.1 场景、视图、图形项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-text">场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-text">视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E9%A1%B9"><span class="toc-text">图形项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-Graphics-View-%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F"><span class="toc-text">6.2.2 Graphics View 的坐标系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E6%98%A0%E5%B0%84"><span class="toc-text">坐标映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-%E4%B8%BB%E8%A6%81%E7%B1%BB%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">6.2.3 主要类的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QGraphicsView"><span class="toc-text">QGraphicsView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QGraphicsScene"><span class="toc-text">QGraphicsScene</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QGraphicsItem"><span class="toc-text">QGraphicsItem</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E7%AB%A0%E6%9C%AB%E6%80%BB%E7%BB%93"><span class="toc-text">6.3 章末总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-text">6.3.1 知识补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E7%B1%BB%E5%9B%BE%E6%80%BB%E7%BB%93"><span class="toc-text">6.3.2 类图总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ml-roadmap.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识图谱：Machine Learning Roadmap"/></a><div class="content"><a class="title" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap">知识图谱：Machine Learning Roadmap</a><time datetime="2025-06-08T06:59:31.000Z" title="发表于 2025-06-08 14:59:31">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"/></a><div class="content"><a class="title" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</a><time datetime="2025-05-30T08:49:12.000Z" title="发表于 2025-05-30 16:49:12">2025-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/tee-lab.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机密计算与TEE：知识整理和试验笔记"/></a><div class="content"><a class="title" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记">机密计算与TEE：知识整理和试验笔记</a><time datetime="2025-04-17T15:31:36.000Z" title="发表于 2025-04-17 23:31:36">2025-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/rust-owner/" title="另一个角度看 Rust 所有权和借用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/rust-owner.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="另一个角度看 Rust 所有权和借用"/></a><div class="content"><a class="title" href="/technical/rust-owner/" title="另一个角度看 Rust 所有权和借用">另一个角度看 Rust 所有权和借用</a><time datetime="2025-04-06T12:20:14.000Z" title="发表于 2025-04-06 20:20:14">2025-04-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/io-mul-more/" title="更多的 I/O 多路复用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/io-mult-more.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="更多的 I/O 多路复用"/></a><div class="content"><a class="title" href="/review/io-mul-more/" title="更多的 I/O 多路复用">更多的 I/O 多路复用</a><time datetime="2025-04-01T04:13:25.000Z" title="发表于 2025-04-01 12:13:25">2025-04-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SJTU-XHW  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Powered By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>