<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>从C++入门Qt（二） | SJTU-XHW's blog</title><meta name="author" content="SJTU-XHW,sjtuxhw12345@sjtu.edu.cn"><meta name="copyright" content="SJTU-XHW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~">
<meta property="og:type" content="article">
<meta property="og:title" content="从C++入门Qt（二）">
<meta property="og:url" content="https://blog.sjtuxhw.top/technical/qt-for-beginners-2/index.html">
<meta property="og:site_name" content="SJTU-XHW&#39;s blog">
<meta property="og:description" content="written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/qt2.jpg">
<meta property="article:published_time" content="2023-08-16T15:15:11.000Z">
<meta property="article:modified_time" content="2024-10-25T14:02:14.534Z">
<meta property="article:author" content="SJTU-XHW">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Qt">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/qt2.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/technical/qt-for-beginners-2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从C++入门Qt（二）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><link rel="stylesheet" href="/css/talk.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SJTU-XHW's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/qt2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SJTU-XHW's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">从C++入门Qt（二）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">从C++入门Qt（二）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-16T15:15:11.000Z" title="发表于 2023-08-16 23:15:11">2023-08-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T14:02:14.534Z" title="更新于 2024-10-25 22:02:14">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>54分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/technical/qt-for-beginners-2/#post-comment"><span class="waline-comment-count" data-path="/technical/qt-for-beginners-2/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><i>written by SJTU-XHW</i></p>
<p><i>Reference: C++ GUI Programming with Qt 4 (2nd Edition) </i></p>
<p><i>注意：本文章将讲解 <strong>Qt 5</strong> 入门知识，需要一定的 C++ 基础</i></p>
<p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p>
<p><strong>观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~</strong></p>
<hr>
<span id="more"></span>
<h1 id="Chapter-4-第一个完整的-Qt-入门项目"><a href="#Chapter-4-第一个完整的-Qt-入门项目" class="headerlink" title="Chapter 4 第一个完整的 Qt 入门项目"></a>Chapter 4 第一个完整的 Qt 入门项目</h1><blockquote>
<p>在完成以上的学习过程后，在座诸位都具有独立写出一个<strong>极简的、</strong>较为完整 Qt 项目的能力；</p>
<p>以下，本人将用 <strong>纯代码方式</strong> 方式完成这个项目；</p>
<p><strong>本章末，会总结到目前为止学到的所有 Qt 类的继承/思维图</strong>。</p>
</blockquote>
<p><strong>观前提示：本项目的设计思路很长，完整源代码放在 仓库 里，有需要可以取出查看 ~ 本章的目的是为了学习 Qt 一些组件的用法而已 ~</strong></p>
<p><strong>项目目标：模仿 <code>Microsoft Excel</code> 设计一个表格应用程序</strong>。</p>
<h2 id="4-1-创建主窗口-UI"><a href="#4-1-创建主窗口-UI" class="headerlink" title="4.1 创建主窗口 UI"></a>4.1 创建主窗口 UI</h2><h3 id="4-1-1-子类化-QMainWindow"><a href="#4-1-1-子类化-QMainWindow" class="headerlink" title="4.1.1 子类化 QMainWindow"></a>4.1.1 子类化 QMainWindow</h3><p>创建一个主窗口最方便的方法是利用 Qt 库中已有的设计类：<code>QMainWindow</code>。</p>
<p><code>QMainWindow</code> 和 <code>QDialog</code> 都是 <code>QWidget</code> 的子类，所以之前的很多方法在创建主窗口时同样有效。</p>
<p>编写前先认识 <code>QMainWindow</code> 类的对应结构：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="QMainWindow.png"></p>
<p>其中中央窗口部件可以放置 Widget，使用 <code>QMainWindow::setCentralWidget(QWidget*)</code> 在此区域添加 Widget；</p>
<p>首先根据目标，声明一个主窗口类（自己起个名字，这里用  <code>MainWindow</code>）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: MainWindow.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面才添加上的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FindDialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HolySheet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义的常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxRecentFiles 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    <span class="comment">// Q_OBJECT</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>();    <span class="comment">// 主窗口构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// closeEvent 时 QWidget 类的虚函数，在 widget 关闭时可以自动调用。所以这里打算覆写此函数，达到“退出时弹出询问窗口”的功能，并保存一些设置到磁盘里</span></span><br><span class="line">    <span class="comment">// 流程：用户点击绑定了原生槽 QWidget::close() 的控件发出的信号(内部emit)，</span></span><br><span class="line">    <span class="comment">// 然后通过内置信号-槽自动调用原生槽 void closeEvent(QCloseEvent* event).</span></span><br><span class="line">    <span class="comment">// 注意，QCloseEvent* event 只有调用了 event-&gt;accept() 才会真正退出窗口，</span></span><br><span class="line">    <span class="comment">// 如果调用了 event-&gt;ignore()，将忽略关闭动作。详细见下文本函数实现的代码。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:    <span class="comment">// 之所以声明为私有槽，是因为它们是需要用户点击后作出相应的函数，而且不需要从类外被调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newFile</span><span class="params">()</span></span>;        <span class="comment">// 私有槽实现新建文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span></span>;        <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">save</span><span class="params">()</span></span>;        <span class="comment">// 保存文件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">saveAs</span><span class="params">()</span></span>;        <span class="comment">// 另存为文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">()</span></span>;        <span class="comment">// 表格查找功能，可以复用之前的 findDialog 窗口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">goToCell</span><span class="params">()</span></span>;    <span class="comment">// 表格定位功能，可以复用之前的 GoToCellDialog 窗口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>;        <span class="comment">// 表格排序功能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">about</span><span class="params">()</span></span>;        <span class="comment">// 关于软件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以上部分是一开始设计出来的 -----------------------------</span></span><br><span class="line">    <span class="comment">// 以下功能是后来加上的，所以实现到再解释 -------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openRecentFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateStatusBar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">holySheetModified</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:    <span class="comment">// 工具函数，大多是代码创建 UI 组件、被上面函数调用的底层功能等</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createActions</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createMenus</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createContextMenu</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createToolBars</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createStatusBar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">readSettings</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">writeSettings</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">okToContinue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">loadFile</span><span class="params">(<span class="type">const</span> QString&amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">saveFile</span><span class="params">(<span class="type">const</span> QString&amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCurrentFile</span><span class="params">(<span class="type">const</span> QString&amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateRecentFileAction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">strippedName</span><span class="params">(<span class="type">const</span> QString&amp; fullFileName)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一些私有数据成员，不用管它，真正编程时，先空着用到再添加</span></span><br><span class="line">    HolySheet* holySheet;    <span class="comment">// 注：HolySheet 类是表格的数据管理类，以后实现</span></span><br><span class="line">    FindDialog* findDialog;</span><br><span class="line">    QLabel* locationLabel;</span><br><span class="line">    QLabel* formulaLabel;</span><br><span class="line">    QStringList recentFiles;    <span class="comment">// 新类 QStringList，QString 类型的列表</span></span><br><span class="line">    QString curFile;</span><br><span class="line">    </span><br><span class="line">    QAction* recentFileActions[MaxRecentFiles];</span><br><span class="line">    QAction* separatorAction;</span><br><span class="line">    </span><br><span class="line">    QMenu* fileMenu;</span><br><span class="line">    QMenu* editMenu;</span><br><span class="line">    QToolBar* fileToolBar;</span><br><span class="line">    QToolBar* newAction;</span><br><span class="line">    QAction* newAction;</span><br><span class="line">    QAction* openAction;</span><br><span class="line">    QAction*aboutAction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在实现以上的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: MainWindow.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MainWindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化中央窗口部件</span></span><br><span class="line">    holySheet = <span class="keyword">new</span> HolySheet;</span><br><span class="line">    <span class="comment">// QMainWindow 的方法，用于将 widget 设置在中央窗口区</span></span><br><span class="line">    <span class="built_in">setCentralWidget</span>(holySheet);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建顶部栏、侧边栏等其他部件</span></span><br><span class="line">    <span class="built_in">createActions</span>();</span><br><span class="line">    <span class="built_in">createMenus</span>();</span><br><span class="line">    <span class="built_in">createContextMenu</span>();</span><br><span class="line">    <span class="built_in">createToolBars</span>();</span><br><span class="line">    <span class="built_in">createStatusBar</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取磁盘中的软件偏好设置</span></span><br><span class="line">    <span class="built_in">readSettings</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等调用 MainWindow::find() 后再创建</span></span><br><span class="line">    findDialog = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置窗口图标，至于为何前面是“：”，请看解析</span></span><br><span class="line">    <span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/images/icon.png&quot;</span>));</span><br><span class="line">    <span class="built_in">setCurrentFile</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要说明的是 <code>QMainWindow::setWindowIcon(QIcon)</code> 和 <code>QIcon</code> 类；</p>
<p>在应用程序需要读取一些资源的时候，通常开发者会把资源放在一个文件夹中，需要的时候通过<strong>和系统相关的路径</strong>载入，这种方法可移植性较低，并且容易因为移动而丢失资源，<strong>最讨厌的是资源路径比较麻烦</strong>；</p>
<p>因此，比较推荐的是 <strong>Qt 的资源机制（resource mechanism）</strong>，优点是比运行时载入更方便、适用于任意文件格式；推荐的使用方法是：</p>
<ol>
<li><p>将资源分类放在各目录下，比如图片放在项目创建的 <code>images</code> 子目录下；</p>
</li>
<li><p>新建 <strong>Qt 资源系统文件</strong> <code>*.qrc</code> ，名字自己起，格式是 <code>XML</code> ，举个例子（用相对路径）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RCC</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qresource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/icon.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/gotocell.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RCC</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>记得在项目 <code>*.pro</code> 文件中添加：<code>RESOURCE = yourFileName.qrc</code>（如果您用 Qt Creator  IDE 自动添加，就当我没说）</p>
</li>
</ol>
<p><strong>这样在 Qt 程序的绝大多数地方路径字符串 <code>:/</code> 代表 <code>*.qrc</code> 存在的路径，不会出错</strong>；例如调用上面的 <code>icon.png</code> 时可以这么用：<code>QIcon(&quot;:/images/icon.png&quot;)</code>；</p>
<h3 id="4-1-2-实现菜单栏、上下文菜单和工具栏"><a href="#4-1-2-实现菜单栏、上下文菜单和工具栏" class="headerlink" title="4.1.2 实现菜单栏、上下文菜单和工具栏"></a>4.1.2 实现菜单栏、上下文菜单和工具栏</h3><p>现在介绍前面没提到的 <code>QAction</code> 类，<strong>Qt 通过 “动作” 的概念简化了有关于菜单和工具栏的编程</strong>，一个动作就是一个可以添加到任意数量的菜单和工具栏上的项；</p>
<p>所以在 Qt 中创建菜单和工具栏包括以下几个步骤：</p>
<ol>
<li>创建并设置动作属性，例如文本、提示、信号-槽、图标、快捷键等；</li>
<li>创建菜单并将动作添加到菜单上；</li>
<li>创建工具栏并将动作添加到工具栏上；</li>
</ol>
<p>以本章的项目来举个栗子🌰：</p>
<p><strong>Firstly</strong>，要创建菜单栏的项并设置属性：实现上面的 <code>MainWindow::createActions()</code> 函数；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建文本为“New”、父控件为 MainWindow 的动作（这样就不用手动释放了）</span></span><br><span class="line">    newAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;New&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    newAction-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/image/new.png&quot;</span>));    <span class="comment">// 设置动作的图标</span></span><br><span class="line">    newAction-&gt;<span class="built_in">setShortcut</span>(QKeySequence::New);        <span class="comment">// 设置动作的快捷键</span></span><br><span class="line">    <span class="comment">// 设置提示性文本</span></span><br><span class="line">    newAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Create a new holySheet file&quot;</span>));</span><br><span class="line">    <span class="comment">// 将动作项与底层函数连接</span></span><br><span class="line">    <span class="built_in">connect</span>(newAction, <span class="built_in">SINGAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">newFile</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下省略 Open、Save、Save As 的动作编写，因为几乎一模一样</span></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Recent Open Files 动作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxRecentFiles; ++i) &#123;</span><br><span class="line">        recentFileActions[i] = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 这里设置隐藏，因为第一次打开没有最近文件</span></span><br><span class="line">        recentFileActions[i]-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 将动作和底层的 openRecentFile() 连接</span></span><br><span class="line">        <span class="built_in">connect</span>(recentFileActions[i], <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()),</span><br><span class="line">               <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">openRecentFile</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Exit 动作</span></span><br><span class="line">    exitAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Exit&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    exitAction-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">tr</span>(<span class="string">&quot;Ctrl+Q&quot;</span>));</span><br><span class="line">    exitAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Exit the Application&quot;</span>));</span><br><span class="line">    <span class="comment">// 这里的 close() 是 QWidget::close() 自带槽</span></span><br><span class="line">    <span class="built_in">connect</span>(exitAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Select All 动作</span></span><br><span class="line">    selectAllAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;All&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    selectAllAction-&gt;<span class="built_in">setShortcut</span>(QKeySequence::SelectAll);</span><br><span class="line">    selectAllAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Select all the cells in the sheet&quot;</span>));</span><br><span class="line">    <span class="comment">// 注意，这里 holySheet 是设计成 QTableWidget 的子类，因为需要看表；</span></span><br><span class="line">    <span class="comment">// 而 QTableWidget 具有内置槽 selectAll()，因此无需自行实现</span></span><br><span class="line">    <span class="built_in">connect</span>(selectAllAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()),</span><br><span class="line">           holySheet, <span class="built_in">SLOT</span>(<span class="built_in">selectAlll</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置中的 Show Grid 动作，是否展示表格边框</span></span><br><span class="line">    showGridAction = <span class="keyword">new</span> <span class="built_in">Action</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Show Grid&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 可勾选模式</span></span><br><span class="line">    showGridAction-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 今后需要在 holySheet 中实现的方法，同步勾选状态 和 显示状态</span></span><br><span class="line">    showGridAction-&gt;<span class="built_in">setChecked</span>(holySheet-&gt;<span class="built_in">showGrid</span>());</span><br><span class="line">    showGridAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Show or hide the holySheet&#x27;s grid&quot;</span>));</span><br><span class="line">    <span class="comment">// 又一个今后需要在 holySheet 中实现的槽，同步勾选动作 和 设置显示槽</span></span><br><span class="line">    <span class="built_in">connect</span>(showGridAction, <span class="built_in">SIGNAL</span>(<span class="built_in">toggled</span>(<span class="type">bool</span>)),</span><br><span class="line">           holySheet, <span class="built_in">SLOT</span>(<span class="built_in">setShowGrid</span>(<span class="type">bool</span>)));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处省略 Auto Recalculate 动作</span></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// About 动作</span></span><br><span class="line">    aboutAction = <span class="keyword">new</span> <span class="built_in">Action</span>(<span class="built_in">tr</span>(<span class="string">&quot;About&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    aboutAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Show the information about the app&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(aboutAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">about</span>());</span><br><span class="line">    <span class="comment">// About Qt 动作</span></span><br><span class="line">    aboutQtAction = <span class="keyword">new</span> <span class="built_in">Action</span>(<span class="built_in">tr</span>(<span class="string">&quot;About &amp;Qt&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    aboutQtAction-&gt;<span class="built_in">setStatusTip</span>(<span class="string">&quot;Show the Qt library&#x27;s About Box&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里的 qApp 将设置为全局变量，QApplication 类，包含 aboutQt() 方法</span></span><br><span class="line">    <span class="built_in">connect</span>(aboutQtAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), qApp, <span class="built_in">SLOT</span>(<span class="built_in">aboutQt</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>其中 <code>QKeySequence</code> 类提供了一套标准化的键盘快捷键的对应 enum 值，可以通过查看文档中 <code>enum QKeySequence::StandardKey</code> 的枚举值来找到运行平台上正确的快捷键表示；</p>
<blockquote>
<p>标准键如：全选<code>QKeySequence::SelectAll =&gt; &quot;Ctrl+A&quot;</code>，复制 <code>Ctrl+C</code> 等；</p>
<p>可惜的是，上面的 <strong>退出</strong> 就没有标准化快捷键，只能自定义：<code>&quot;Ctrl+Q&quot;</code>；</p>
</blockquote>
</li>
<li><p>还可以通过 <code>QActionGroup</code> 类来实现<strong>相互排斥</strong>的勾选 <code>Action</code>，这里不需要就不演示了；</p>
</li>
</ol>
<p><strong>Secondly</strong>，需要创建菜单，并且把创建好的菜单项放进菜单中：实现 <code>MainWindow::createMenus()</code>；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createMenus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意：QMainWindow 和 QMenu 类进行了组合，本身有 QMainWindow::menuBar()，</span></span><br><span class="line">    <span class="comment">// 调用即返回内嵌于 QMainWindow 中的菜单栏，位置见上面 QMainWindow 结构展示</span></span><br><span class="line">    fileMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(saveAsAction);</span><br><span class="line">    separatorAction = fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxRecentFile; ++i)</span><br><span class="line">        fileMenu-&gt;<span class="built_in">addAction</span>(recentFileActions[i]);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>(exitAction);</span><br><span class="line">    </span><br><span class="line">    editMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Edit&quot;</span>));</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(cutAction);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(copyAction);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(pasteAction);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(deleteAction);</span><br><span class="line">    </span><br><span class="line">    selectSubMenu = editMenu-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Select&quot;</span>));</span><br><span class="line">    selectSubMenu-&gt;<span class="built_in">addAction</span>(selectRowAction);</span><br><span class="line">    selectSubMenu-&gt;<span class="built_in">addAction</span>(selectColAction);</span><br><span class="line">    selectSubMenu-&gt;<span class="built_in">addAction</span>(selectAllAction);</span><br><span class="line">    </span><br><span class="line">    editMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(findAction);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(goToCellAction);</span><br><span class="line">    </span><br><span class="line">    toolsMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Tools&quot;</span>));</span><br><span class="line">    toolsMenu-&gt;<span class="built_in">addAction</span>(recalculationAction);</span><br><span class="line">    toolsMenu-&gt;<span class="built_in">addAction</span>(sortAction);</span><br><span class="line">    </span><br><span class="line">    optionsMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Options&quot;</span>));</span><br><span class="line">    optionsMenu-&gt;<span class="built_in">addAction</span>(showGridAction);</span><br><span class="line">    optionsMenu-&gt;<span class="built_in">addAction</span>(autoRecalculation);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是菜单间间隔的写法，menuBar() 没有 addMenu，有些系统呈现的是</span></span><br><span class="line">    <span class="comment">// 将之后的菜单放在最右侧，有些系统会直接忽略，有些系统仅仅显示一个分割线</span></span><br><span class="line">    <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    </span><br><span class="line">    helpMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Help&quot;</span>));</span><br><span class="line">    helpMenu-&gt;<span class="built_in">addAction</span>(aboutAction);</span><br><span class="line">    helpMenu-&gt;<span class="built_in">addAction</span>(aboutQtAction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Thirdly</strong>，实现完菜单栏，再关注 <strong>上下文菜单栏（context menu 直译，或译作 “右键菜单”）</strong>：实现 <code>MainWindow::createContextMenu()</code>；</p>
<p><strong>实现上下文菜单的重要机制是：Qt 的上下文菜单策略（context menu policy）</strong></p>
<p>任何 QWidget 都有一个与之相关联的 <code>QAction</code> 列表，也有上下文菜单策略枚举变量：<code>enum Qt::ContextMenuPolicy</code>；当设置上下文菜单策略为枚举量 <code>Qt::ActionsContextMenu(=2)</code> 时，会以该 QAction 列表为 widget 的上下文菜单，当右击这个 widget 时，会展开上下文菜单；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createContextMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    holySheet-&gt;<span class="built_in">addAction</span>(cutAction);</span><br><span class="line">    holySheet-&gt;<span class="built_in">addAction</span>(copyAction);</span><br><span class="line">    holySheet-&gt;<span class="built_in">addAction</span>(pasteAction);</span><br><span class="line">    holySheet-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::ActionsContextMenu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种设计的方法比较繁琐，不重用之前的 <code>QAction</code>，即上下文菜单策略是<code>Qt::DefaultContextMenu(=1)</code> 时，重新实现：<code>QWidget::contextMenuEvent()</code> 函数，在其中创建一个 <code>QMenu</code>，添加，再对该部件调用 <code>exec()</code>，感兴趣可以尝试，这里不做演示；</p>
<p><strong>Last but not the least</strong>，关注<strong>工具栏</strong>：实现 <code>MainWindow::createToolBars()</code>；注意，如果你之前设置的 Action 有设置图标的话，可以直接复用，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createToolBars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fileToolBar = <span class="built_in">addToolBar</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">    fileToolBar-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line">    fileToolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">    fileToolBar-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line">    </span><br><span class="line">    editToolBar = <span class="built_in">addToolBar</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Edit&quot;</span>));</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(cutAction);</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(copyAction);</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(pasteAction);</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(findAction);</span><br><span class="line">    editToolBar-&gt;<span class="built_in">addAction</span>(goToCellAction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-3-设置状态栏"><a href="#4-1-3-设置状态栏" class="headerlink" title="4.1.3 设置状态栏"></a>4.1.3 设置状态栏</h3><blockquote>
<p>什么是状态栏？大家看 Microsoft Word 中左下角每当进行一些操作时，会显示不同文字，如下，这就是状态栏：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="statusBar-example.png"></p>
</blockquote>
<p>下面实现 <code>MainWindow::createStatusBar()</code>；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createStatusBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    locationLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot; w999 &quot;</span>);</span><br><span class="line">    locationLabel-&gt;<span class="built_in">setAlignment</span>(Qt::AlignHCenter);</span><br><span class="line">    locationLabel-&gt;<span class="built_in">setMinimumSize</span>(locationLabel-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">    </span><br><span class="line">    formulaLabel = <span class="keyword">new</span> QLabel;</span><br><span class="line">    formulaLabel-&gt;<span class="built_in">setIndent</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">statusBar</span>()-&gt;<span class="built_in">addWidget</span>(locationLabel);</span><br><span class="line">    <span class="built_in">statusBar</span>()-&gt;<span class="built_in">addWidget</span>(formulaLabel, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">connect</span>(holySheet, <span class="built_in">SIGANL</span>(<span class="built_in">currentCellChanged</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">updateStatusBar</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(holySheet, <span class="built_in">SIGNAL</span>(<span class="built_in">modified</span>()),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">holySheetModified</span>()));</span><br><span class="line">    <span class="built_in">updateStatusBar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分状态栏的实现大致可以分为两个部分：</p>
<ol>
<li><p>创建控件（大多是 QLabel），设置控件的布局；</p>
<ul>
<li>初始的 <code>locationLabel</code> 设置内容 “ w999 ” 表示最大单元格位置，配合 <code>locationLabel-&gt;setMinmumSize(locationLabel-&gt;sizeHint())</code> 可以确定位置状态标签大小满足要求；</li>
<li><code>locationLabel-&gt;setAlignment(Qt::AlignHCenter)</code> 确保文本居中对齐；</li>
<li><code>formulaLabel-&gt;setIndent(3)</code> 表示标签内添加文本缩进，这是实现之后进行的微调，确保美观；</li>
<li><code>statusBar()-&gt;addWidget(QWidget*, int)</code> 中第二个参数是<strong>伸展因子</strong>，参数为 0 表示<strong>紧贴模式（默认）</strong>，参数为 1 表示<strong>最大占用模式（还剩多少就占多少，类似 CSS 中的 auto 参数）</strong>；</li>
</ul>
</li>
<li><p>为状态栏的变化建立连接；</p>
<ul>
<li><p>先利用将要实现的 <code>holySheet</code> 信号 <code>currentCellChanged(int, int, int, int)</code>，和更新状态栏的槽 <code>updateStatusBar()</code> 绑定；<code>MainWindow::updateStatusBar()</code> 实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::updateStatusBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    locationLabel-&gt;<span class="built_in">setText</span>(holySheet-&gt;<span class="built_in">currentLocation</span>());</span><br><span class="line">    formulaLabel-&gt;<span class="built_in">setText</span>(holySheet-&gt;<span class="built_in">currentFormula</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此外，为了实现 <strong>“已修改后会改变窗口标题”</strong>（很多软件在文件修改后，会在窗口标题加一个记号，如 <code>*</code>） ，还要实现 <code>MainWindow::holySheetModified()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::holySheetModified</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QMainWindow 的固有槽</span></span><br><span class="line">    <span class="built_in">setWindowModified</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">updateStatusBar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<strong>每个 <code>QWidget</code> 都有一个 <code>windowModified</code> 属性</strong> ~</p>
</li>
</ul>
</li>
</ol>
<h2 id="4-2-主窗口的底层函数实现"><a href="#4-2-主窗口的底层函数实现" class="headerlink" title="4.2 主窗口的底层函数实现"></a>4.2 主窗口的底层函数实现</h2><blockquote>
<p>函数比较多，还是从窗口的菜单功能下手；</p>
</blockquote>
<h3 id="4-2-1-File-菜单"><a href="#4-2-1-File-菜单" class="headerlink" title="4.2.1 File 菜单"></a>4.2.1 File 菜单</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新文件创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::newFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前窗口有没保存的改动，提醒是否保存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">okToContinue</span>()) &#123;</span><br><span class="line">        holySheet-&gt;<span class="built_in">clear</span>();    <span class="comment">// holySheet 等待实现的函数，清屏</span></span><br><span class="line">        <span class="built_in">setCurrentFile</span>(<span class="string">&quot;&quot;</span>);    <span class="comment">// 当前文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::okToContinue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断当前窗口是否有没有保存的修改，也是 QMainWindow 的方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isWindowModified</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> res = QMessageBox::<span class="built_in">warning</span>(</span><br><span class="line">            <span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">            <span class="built_in">tr</span>(<span class="string">&quot;The document has been modified.\n&quot;</span></span><br><span class="line">               <span class="string">&quot;Do you want to save your changes?&quot;</span>),</span><br><span class="line">            QMessageBox::Yes | QMessageBox::No | QMessageBox::Cancel</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (res == QMessageBox::Yes) <span class="keyword">return</span> <span class="built_in">save</span>();    <span class="comment">// 保存更改</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res == QMessageBox::Cancel) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 确认立即继续</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上值得一提的是，<code>QMessageBox</code> 提供了很多标准的信息对话框模板，例如：提示信息、提问、警告、严重错误，语法：<code>QMessageBox::warning(QWidget* parent, QString title, QString message, (enum)QMessageBox::StandardButtons buttons)</code>；</p>
<p>其中枚举类型 <code>QMessageBox::StandardButtons</code> 含有枚举值 <code>QMessageBox::Yes</code>、<code>QMessageBox::No</code>、<code>QMessageBox::Cancel</code>、<code>QMessageBox::Apply</code>等等，有特殊需要可以参考官方文档，<strong>这里设计非常巧妙，枚举值设置为 16 进制数码，使用多个 buttons 时，利用按位或 <code>|</code> （参考上面代码），达到类似 Linux 权限掩码的多选效果</strong>；</p>
<p>除了 <code>warning</code> 警告对话框，还有 <code>information</code> 提示对话框、<code>question</code> 提问对话框、<code>critical</code> 严重错误对话框；<strong>语法是相同的</strong>；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开已有文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">okToContinue</span>()) &#123;</span><br><span class="line">        QString fileName = QFileDialog::<span class="built_in">getOpenFileName</span>(</span><br><span class="line">                                <span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Open sheet&quot;</span>), <span class="string">&quot;.&quot;</span>,</span><br><span class="line">                                <span class="built_in">tr</span>(<span class="string">&quot;HolySheet file (*.hs)&quot;</span>)</span><br><span class="line">                            );</span><br><span class="line">        <span class="keyword">if</span> (!fileName.<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="built_in">loadFile</span>(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层实现：载入指定文件，之所以不和 MainWindow::open() 合在一起，就是为了在“打开最近文件”的功能中重用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::loadFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holySheet-&gt;<span class="built_in">readFile</span>(fileName)) &#123;    <span class="comment">// holySheet 等待实现的函数</span></span><br><span class="line">        <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;Loading canceled&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setCurrentFile</span>(fileName);</span><br><span class="line">    <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;File loaded&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>借助上面的代码，再补充一些重要的点，<code>QFileDialog</code> 类提供各种<strong>打开文件名（“浏览”）</strong>的对话窗口，和前面介绍的 <code>QMessageBox</code> 都继承于 <code>QDialog</code>；比较常用的是 <code>QFileDialog::getOpenFileName(QWdiget* parent, QString title, QString startPath, QString filter)</code>；</p>
<p>还有 <code>QFileDialog::getSaveFileName(...)</code>，语法相同，之和代码会介绍；</p>
<blockquote>
<p>注意：① 这里的QFileDialog 一般窗口优先级都比父窗口的高，显示在其上层；② 文件过滤器参数 <code>filter</code> 参数的格式是 “<code>&lt;description&gt; (*.suffix)</code>”，如果允许多个文件类型，则用换行符分割：“<code>&lt;desc1&gt; (*.suffix1)\n&lt;desc2&gt; (*.suffix2)</code>”；</p>
</blockquote>
</li>
<li><p><code>QStatusBar::showMessage(QString text, int milisec)</code> 的调用不会影响到 <code>QStatusBar</code> 中添加的 widget，会单独再显示消息；第二个参数 <code>milisec</code> 表示消息停留的<strong>毫秒数</strong>；</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curFile.<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="built_in">saveAs</span>();    <span class="comment">// 当前不存在文件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">saveFile</span>(curFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::saveFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holySheet-&gt;<span class="built_in">writeFile</span>(fileName)) &#123;    <span class="comment">// holySheet 等待实现的函数</span></span><br><span class="line">        <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;Saving canceled&quot;</span>, <span class="number">2000</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setCurrentFile</span>(fileName);    <span class="comment">// 保存成功，则设置当前文件为指定文件</span></span><br><span class="line">    <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;File saved&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::saveAs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QString fileName = QFileDialog::<span class="built_in">getSaveFileName</span>(</span><br><span class="line">                            <span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Save sheet&quot;</span>), <span class="string">&quot;.&quot;</span>,</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;HolySheet file (*.hs)&quot;</span>)</span><br><span class="line">                        );</span><br><span class="line">    <span class="keyword">if</span> (fileName.<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">saveFile</span>(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>QFileDialog::getSaveFileName</code> 和 <code>QFileDialog::getOpenFileName</code> 不同的是，<strong>如果给定的文件已经存在，会自动弹出对话框提醒是否需要覆盖</strong>；也可以传递附加参数： <code>QFileDialog::DontConfirmOverwrite</code>来改变这个行为；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::closeEvent</span><span class="params">(QCloseEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">okToContinue</span>()) &#123;</span><br><span class="line">        <span class="built_in">writeSettings</span>();    <span class="comment">// 写入配置</span></span><br><span class="line">        event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> event-&gt;<span class="built_in">ignore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得之前<strong>在声明这个函数的时候的注释内容</strong>吗？</p>
<p>此外，<code>QApplication</code> 默认 <code>quitOnLastWindowClosed = true</code>，如果想要**关闭最后一个窗口后，<code>QApplication</code> 仍然运行（例如托盘运行），那么可以将它设置为 <code>false</code>；</p>
<p>顺便实现内部函数 <code>setCurrentFile</code> 和 <code>strippedName</code>。前者用于<strong>指定当前文件（<code>curFile</code> 私有变量）、修改窗口标题、修改 “最近文件” 列表、修改窗口是否改动的状态</strong>，后者用于得到文件除去后缀的名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::setCurrentFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    curFile = fileName;</span><br><span class="line">    <span class="built_in">setWindowModified</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    QString shownName = <span class="built_in">tr</span>(<span class="string">&quot;Untitled&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!curFile.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        shownName = <span class="built_in">strippedName</span>(curFile);</span><br><span class="line">        recentFiles.<span class="built_in">removeAll</span>(curFile);</span><br><span class="line">        recentFiles.<span class="built_in">prepend</span>(curFile);</span><br><span class="line">        <span class="built_in">updateRecentFileActions</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Qt 的格式化字符串！</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;%1 [*] - %2&quot;</span>).<span class="built_in">arg</span>(shownName).<span class="built_in">arg</span>(<span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">MainWindow::strippedName</span><span class="params">(<span class="type">const</span> QString&amp; fullFileName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QFileInfo</span>(fullFileName).<span class="built_in">fileName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到了更新 “最近文件” 列表，还有之前说到的 “最近文件” 列表的动作绑定，现在来实现 <code>updateRecentFileActions</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::updateRecentFileActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QMutableStringListIterator <span class="title">iter</span><span class="params">(recentFiles)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (iter.<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!QFile::<span class="built_in">exists</span>(iter.<span class="built_in">next</span>()))</span><br><span class="line">            iter.<span class="built_in">remove</span>();    <span class="comment">// 移除还在列表中，但已不存在的文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxRecentFiles; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; recentFiles.<span class="built_in">count</span>()) &#123;</span><br><span class="line">            QString text = <span class="built_in">tr</span>(<span class="string">&quot;&amp;%1 %2&quot;</span></span><br><span class="line">                              .<span class="built_in">arg</span>(i + <span class="number">1</span>)</span><br><span class="line">                              .<span class="built_in">arg</span>(<span class="built_in">strippedName</span>(recentFiles[i]))</span><br><span class="line">                             );</span><br><span class="line">            recentFileActions[i]-&gt;<span class="built_in">setText</span>(text);</span><br><span class="line">            recentFileActions[i]-&gt;<span class="built_in">setData</span>(recentFiles[i]);</span><br><span class="line">            recentFileActions[i]-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> recentFileActions[i]-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    seperatorAction-&gt;<span class="built_in">setVisible</span>(!recentFiles.<span class="built_in">isEmpty</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先 <code>QMutableStringIterator</code> 可以看作是 <code>QStringList</code>（<code>recentFiles</code> 的类型）的可变的迭代器；</p>
<p>其次，对于 <code>recentFileActions[i]-&gt;setData(recentFiles[i])</code> 这一步，其实 <code>QAction</code> 类的函数 <code>setData(QVariant qvar)</code> 对应设置了 <code>QVariant QAction::data</code>  数据成员，它可以保存很多种 C++ / Qt 的数据类型，<strong>包括 <code>QString</code>、一切 <code>numerical</code>、<code>bool</code>、<code>QStringList</code> 等</strong>（以后会进一步讨论）；</p>
<p>下面实现 <code>openRecentFile</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::openRecentFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">okToContinue</span>()) &#123;</span><br><span class="line">        QAction* action = <span class="built_in">qobject_cast</span>&lt;QAction*&gt;(<span class="built_in">sender</span>());</span><br><span class="line">        <span class="keyword">if</span> (action) <span class="built_in">loadFile</span>(<span class="built_in">action</span>()-&gt;<span class="built_in">data</span>().<span class="built_in">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>QObject::sender()</code> 返回 <code>QObject*</code>，用于<strong>查出是哪个信号 / 动作调用了当前的槽（所以在槽函数内使用）</strong>；这里知道调用 <code>openRecentFile()</code> 函数的一定是 <code>QAction</code> 的动作，所以强制转换到它的指针类型，并且读出 <code>data</code> 数据，进而找到点击的 “最近文件” 并调用 <code>loadFile()</code>；</p>
<h3 id="4-2-2-主窗口调用-Dialog：模态和非模态"><a href="#4-2-2-主窗口调用-Dialog：模态和非模态" class="headerlink" title="4.2.2 主窗口调用 Dialog：模态和非模态"></a>4.2.2 主窗口调用 Dialog：模态和非模态</h3><p>这里会用到之前所写的 <code>findDialog</code>、<code>goToCellDialog</code>、<code>sortDialog</code> 等对话框，进行功能的<strong>拼接</strong>，同时会制作简单的 <code>about</code> 对话框。</p>
<p>首先是之前的 <code>findDialog</code> 对话框。由于希望用户可以在主窗口、子窗口间<strong>自由切换</strong>（毕竟只是查找功能），所以 <code>findDialog</code> 必须是 <strong>非模态的（modeless）</strong>——在运行的程序中，这种窗口独立于其他窗口，不会覆盖或阻挡，实现方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!findDialog) &#123;    <span class="comment">// 从未创建过 findDialog，懒加载模式</span></span><br><span class="line">        findDialog = <span class="keyword">new</span> <span class="built_in">FindDialog</span>(<span class="keyword">this</span>);    <span class="comment">// 设置父对象可以不用另外析构</span></span><br><span class="line">        <span class="comment">// 将 findDialog 的两个信号绑定到 holySheet 的两个槽上进行查找处理</span></span><br><span class="line">        <span class="built_in">connect</span>(findDialog, <span class="built_in">SIGNAL</span>(<span class="built_in">findNext</span>(<span class="type">const</span> QString&amp;, Qt::CaseSensitivity)), holySheet, <span class="built_in">SLOT</span>(<span class="built_in">findNext</span>(<span class="type">const</span> QString&amp;, Qt::CaseSensitivity)));</span><br><span class="line">        <span class="built_in">connect</span>(findDialog, <span class="built_in">SIGNAL</span>(<span class="built_in">findPrev</span>(<span class="type">const</span> QString&amp;, Qt::CaseSensitivity)), holySheet, <span class="built_in">SLOT</span>(<span class="type">const</span> QString&amp;, Qt::CaseSensitivity));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    findDialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    findDialog-&gt;<span class="built_in">raise</span>();</span><br><span class="line">    findDialog-&gt;<span class="built_in">activateWindow</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过点击 <code>Edit-&gt;Find</code> 菜单来调出 <code>find()</code> 函数有 3 种情况：</p>
<ol>
<li>用户第一次调用这个对话框：由于懒加载，会先创建它，再打开；</li>
<li>用户曾经打开过，现在是关闭（<code>visible=false</code>）状态：直接 <code>show()</code> 就足以完成<strong>显示、置顶、激活</strong>这 3 个状态；</li>
<li>用户曾经打开，仍没有关闭：这时 <code>show()</code> 不能完成置顶、激活这两个状态，分别需要 <code>raise()</code> 和 <code>activateWindow()</code> 来完成；</li>
</ol>
<p>按照这个逻辑，后面 3 行还可以写成：（<strong>不过没必要</strong>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (findDialog-&gt;<span class="built_in">isHidden</span>()) findDialog-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    findDialog-&gt;<span class="built_in">raise</span>();</span><br><span class="line">    findDialog-&gt;<span class="built_in">activateWindow</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看 <code>goToCellDialog</code>，我们希望用户弹出、使用、关闭它，不希望在使用它的期间去碰主窗口，这种子窗口就是 <strong>模态的（modal）</strong>——可弹出并阻塞应用程序的对话框：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::goToCell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里为什么不 new，而只是在栈中建立一个 dialog，是由对话框目的决定；</span></span><br><span class="line">    <span class="comment">// 这里用完就可以销毁，没必要 new + delete.</span></span><br><span class="line">    <span class="function">GoToCellDialog <span class="title">dialog</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (dialog.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        QString str = dialog.lineEdit-&gt;<span class="built_in">text</span>().<span class="built_in">toUpper</span>();</span><br><span class="line">        holySheet-&gt;<span class="built_in">setCurrentCell</span>(str.<span class="built_in">mid</span>(<span class="number">1</span>).<span class="built_in">toInt</span>() - <span class="number">1</span>, str[<span class="number">0</span>].<span class="built_in">unicode</span>() - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：模态对话框不能使用 <code>show()</code>，否则变成非模态对话框！应该使用 <code>QDialog::exec()</code> 阻塞获取对话框返回结果</strong>（由 <code>accept()</code> 和 <code>reject()</code> 决定，<code>QDialog::Accepted=true</code>、<code>QDialog::Rejected=false</code>）；</p>
<p>另外，<code>HolySheet::setCurrentCell(int x, int y)</code> 等待实现；</p>
<p><code>QString::mid(int)</code> 指提取从第 int 个字符串以后的子串、<code>toInt()</code> 不解释，其正确性由之前 <code>GoToCellDialog::lineEdit</code> 中设置的 <code>QRegExpValidator</code> 来保证；</p>
<p>再来看 <code>sortDialog</code>，它也是一个模态对话框，允许用户<strong>在当前选定区域</strong>使用<strong>给定的列</strong>进行排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SortDialog <span class="title">dialog</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 注意：这个函数没写错，就是之后需要在 HolySheet 类中实现的一个函数</span></span><br><span class="line">    <span class="comment">// 它不是 QTableWidget 的原生函数 selectRanges()</span></span><br><span class="line">    QTableWidgetSelectionRange range = holySheet-&gt;<span class="built_in">selectedRange</span>();</span><br><span class="line">    dialog.<span class="built_in">setColumnRange</span>(<span class="string">&#x27;A&#x27;</span> + range.<span class="built_in">leftColumn</span>(),</span><br><span class="line">                          <span class="string">&#x27;A&#x27;</span> + range.<span class="built_in">rightColumn</span>());</span><br><span class="line">    <span class="keyword">if</span> (dialog.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        </span><br><span class="line">        HolySheetCompare compare;</span><br><span class="line">        compare.keys[<span class="number">0</span>] = dialog.primaryColumnCombo-&gt;<span class="built_in">currentIndex</span>();</span><br><span class="line">        compare.keys[<span class="number">1</span>] = dialog.secondaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() - <span class="number">1</span>;</span><br><span class="line">        compare.keys[<span class="number">2</span>] = dialog.tertiaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() - <span class="number">1</span>;</span><br><span class="line">        compare.ascending[<span class="number">0</span>] = </span><br><span class="line">            (dialog.primaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() == <span class="number">0</span>);</span><br><span class="line">        compare.ascending[<span class="number">1</span>] = </span><br><span class="line">            (dialog.secondaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() == <span class="number">0</span>);</span><br><span class="line">        compare.ascending[<span class="number">2</span>] = </span><br><span class="line">            (dialog.tertiaryColumnCombo-&gt;<span class="built_in">currentIndex</span>() == <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        holySheet-&gt;<span class="built_in">sort</span>(compare);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们看到了 2 个新类。一个是 Qt 原生的 <code>QTableWidgetSelectionRange</code>，用来记录 <code>QTableWidget</code> 选中的区域信息，可以由 <code>QTableWidget::selectRange()</code> 得到当前选中的范围。含有 <code>leftColumn()</code>、<code>rightColumn()</code> 方法查到区域的列；</p>
<blockquote>
<p>注意：<code>SortDialog::setColumnRange</code> 是之前我们自己定义为了 <code>column ComboBox</code> 的取值范围而设置的函数。</p>
</blockquote>
<p>另一个类是 <code>HolySheetCompare</code>，和 <code>HolySheet</code> 一样，是之后我们自己会实现的类。这个类存储<strong>主键、第二键、第三键以及它们的排序顺序（<code>keys</code> 数组存储键的列号，<code>ascending</code> 数组按 <code>bool</code> 格式存储每个键相关顺序）</strong>，这个对象可以被 <code>HolySheet::sort()</code> 使用，用于两行间的比较；</p>
<blockquote>
<p>注意：<code>QComboBox::currentIndex()</code> 返回当前选定项的索引值，第一个为 0；</p>
<p>上面的 “-1” 指去除前面的 “None” 设置值。</p>
</blockquote>
<p>本节最后，我们制作一个简单的 <code>About</code> 对话框，只需要静态函数 <code>QMessageBox::about</code> 就行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::about</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">about</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;About HolySheet&quot;</span>),</span><br><span class="line">                      <span class="built_in">tr</span>(<span class="string">&quot;&lt;h2&gt;HolySheet 0.1&lt;/h2&gt;&quot;</span></span><br><span class="line">                         <span class="string">&quot;&lt;p&gt;Copyright &amp;copy; 2023 SJTU-XHW Inc.&lt;/p&gt;&quot;</span></span><br><span class="line">                         <span class="string">&quot;&lt;p&gt;HolySheet is a small application that &quot;</span></span><br><span class="line">                         <span class="string">&quot;demonstrate QAction, QMainWindow, QMenuBar, &quot;</span></span><br><span class="line">                         <span class="string">&quot;QStatusBar, QTableWidget, QToolBar and many &quot;</span></span><br><span class="line">                         <span class="string">&quot;other Qt classes.&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>QMessageBox::about(QWidget* parent, const QString&amp; title, const QString&amp; contents)</code> 和 <code>warning/information/critical</code> 不同的是，<strong>它的图标取决于父控件的图标</strong>。</p>
<h3 id="4-2-3-设置的持久化"><a href="#4-2-3-设置的持久化" class="headerlink" title="4.2.3 设置的持久化"></a>4.2.3 设置的持久化</h3><p>现在关注 <code>readSettings()</code>、<code>writeSettings()</code> 函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::writeSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QSettings <span class="title">settings</span><span class="params">(<span class="string">&quot;SJTU-XHW Inc.&quot;</span>, <span class="string">&quot;HolySheet&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 这里的 saveGeometry() 是 QWidget 类的原生方法，</span></span><br><span class="line">    <span class="comment">// 返回 QByteArray，可以被 QVariant 存储</span></span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;geometry&quot;</span>, <span class="built_in">saveGeometry</span>());</span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;recentFiles&quot;</span>, recentFiles);</span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;showGrid&quot;</span>, showGridAction-&gt;<span class="built_in">isChecked</span>());</span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;autoRecalc&quot;</span>, autoRecalcAction-&gt;<span class="built_in">isChecked</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>QSettings</code> 类的值设置非常类似 <code>Python</code> 的字典键值对，值也是用 <code>QVariant</code> 存储的；默认情况下，<code>QSettings</code> 在系统上存储方法和系统种类有关（<code>Windows</code> 上就存在注册表，<code>UNIX</code> 存在文本文件中，<code>MacOS</code> 存在 <code>Core Foundation Preferences</code> 编程接口中），详细内容如下表：</p>
<table>
    <tr style="text-align: center;">
        <th>Platform</th>
        <th>Format</th>
        <th>Scope</th>
        <th>Path</th>
    </tr>
    <tr>
        <td rowspan=4>Windows</td>
        <td rowspan=2>Native</td>
        <td>User</td>
        <td>HKEY_CURRENT_USER\Software\*</td>
    </tr>
    <tr>
        <td>System</td>
        <td>HKEY_LOCAL_MACHINE\Software\*</td>
    </tr>
    <tr>
        <td rowspan=2>INI</td>
        <td>User</td>
        <td>%APPDATA%\*.ini</td>
    </tr>
    <tr>
        <td>System</td>
        <td>%COMMON_APPDATA%\*.ini</td>
    </tr>
    <tr>
        <td rowspan=4>Unix</td>
        <td rowspan=2>Native</td>
        <td>User</td>
        <td>$HOME/.config/*.conf</td>
    </tr>
    <tr>
        <td>System</td>
        <td>/etc/xdg/*.conf</td>
    </tr>
    <tr>
        <td rowspan=2>INI</td>
        <td>User</td>
        <td>$HOME/.config/*.ini</td>
    </tr>
    <tr>
        <td>System</td>
        <td> /etc/xdg/*.ini</td>
    </tr>
    <tr>
        <td rowspan=4>Mac OS X</td>
        <td rowspan=2>Native</td>
        <td>User</td>
        <td>$HOME/Library/Preferences/com.*.plist</td>
    </tr>
    <tr>
        <td>System</td>
        <td> /Library/Preferences/com.*.plist</td>
    </tr>
    <tr>
        <td rowspan=2>INI</td>
        <td>User</td>
        <td> $HOME/.config/*.ini</td>
    </tr>
    <tr>
        <td>System</td>
        <td> /etc/xdg/*.ini</td>
    </tr>
</table>


<p><code>QSettings</code> 类的构造函数的参数分别是组织名、程序名，为的是方便设置的<strong>读取、查找</strong>。</p>
<p>此外，<code>QSettings</code> 的设置还能以路径形式指定子键的值（如 <code>findDialog/matchCase</code>）或者用 <code>beginGroup(QString)</code> 和 <code>endGroup()</code> 的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">settings.<span class="built_in">beginGroup</span>(<span class="string">&quot;findDialog&quot;</span>);</span><br><span class="line">settings.<span class="built_in">setValue</span>(<span class="string">&quot;matchCase&quot;</span>, caseCheckBox-&gt;<span class="built_in">isChecked</span>());</span><br><span class="line">settings.<span class="built_in">setValue</span>(<span class="string">&quot;searchBackward&quot;</span>, backwardCheckBox-&gt;<span class="built_in">isChecked</span>());</span><br><span class="line">settings.<span class="built_in">endGroup</span>();</span><br></pre></td></tr></table></figure>
<p>还有 <code>readSettings</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::readSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按组织名 + 程序名读取设置</span></span><br><span class="line">    <span class="function">QSettings <span class="title">settings</span><span class="params">(<span class="string">&quot;SJTU-XHW Inc.&quot;</span>, <span class="string">&quot;HolySheet&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">restoreGeometry</span>(settings.<span class="built_in">value</span>(<span class="string">&quot;geometry&quot;</span>).<span class="built_in">toByteArray</span>());</span><br><span class="line">    recentFiles = settings.<span class="built_in">value</span>(<span class="string">&quot;recentFiles&quot;</span>).<span class="built_in">toStringList</span>();</span><br><span class="line">    <span class="built_in">updateRecentActions</span>();    <span class="comment">// 更新 “最近文件” 菜单栏</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二参数是默认值，类似 Python dict 类的 setdefault()</span></span><br><span class="line">    <span class="type">bool</span> showGrid = settings.<span class="built_in">value</span>(<span class="string">&quot;showGrid&quot;</span>, <span class="literal">true</span>).<span class="built_in">toBool</span>();</span><br><span class="line">    showGridAction-&gt;<span class="built_in">setChecked</span>(showGrid);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> autoRecalc = settings.<span class="built_in">value</span>(<span class="string">&quot;autoRecalc&quot;</span>, <span class="literal">true</span>).<span class="built_in">toBool</span>();</span><br><span class="line">    autoRecalcAction-&gt;<span class="built_in">setChecked</span>(autoRecalc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以在应用程序的其他任何地方使用 <code>QSettings</code> 方便地查询、修改设置。</p>
<p>到目前为止，<code>MainWindow</code> 及其 UI 界面已经几乎完全实现，主要的任务就是实现 <code>HolySheet</code> 类和 <code>HolySheetCompare</code> 类了。</p>
<h3 id="4-2-4-锦上添花：多文档模式"><a href="#4-2-4-锦上添花：多文档模式" class="headerlink" title="4.2.4 锦上添花：多文档模式"></a>4.2.4 锦上添花：多文档模式</h3><p>现在我们可以准备编写程序的 <code>main</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainWindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow win;        <span class="comment">// 这里不用 new 创建</span></span><br><span class="line">    win.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑这个问题：我们想要<strong>同一时间打开、处理多个表格</strong>，怎么办？</p>
<p>肯定不能让用户重复打开程序——这是不方便的。应该像浏览器打开页面一样，提供多个窗口。这就是程序的<strong>多窗口（文档）模式</strong>。</p>
<p>这时，我们就需要对 <code>File</code> 菜单进行一些改动，<strong>使得一个应用程序实例，能够处理多个文档</strong>：</p>
<ul>
<li><p><code>File-&gt;New</code> 操作不再是使用原先存在的窗口，而是<strong>创建一个空文档窗口</strong>，已存在的窗口需要手动关闭；</p>
</li>
<li><p><code>File-&gt;Close</code> 关闭当前的主窗口，而不是清除内容；</p>
<blockquote>
<p><strong>注：原来的 <code>MainWindow</code> 没有这个 <code>Close</code> 选项，因为是单窗口，它的作用和 <code>Exit</code> 相同</strong>；</p>
</blockquote>
</li>
<li><p><code>File-&gt;Exit</code> 关闭所有窗口，而不是关闭当前仅有的窗口。</p>
</li>
</ul>
<p>想要具有多窗口功能，需要使用 <code>new</code> 来统一创建、销毁窗口。所以 <code>main.cpp</code> 改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainWindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow* win = <span class="keyword">new</span> MainWindow;</span><br><span class="line">    win-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着修改 <code>newFile()</code> 槽和 <code>Actions</code> 的组成和提示信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: mainWindow.cpp</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWondow::newFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MainWindow* otherWin = <span class="keyword">new</span> MainWindow;</span><br><span class="line">    otherWin-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    closeAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Close&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    closeAction-&gt;<span class="built_in">setShortCut</span>(QKeySequence::Close);</span><br><span class="line">    closeAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Close this window&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(closeAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line">    </span><br><span class="line">    exitAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;E&amp;xit&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    exitAction-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">tr</span>(<span class="string">&quot;Ctrl+Q&quot;</span>));</span><br><span class="line">    exitAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Exit the application&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(exitAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), qApp, <span class="built_in">SLOT</span>(<span class="built_in">closeAllWindows</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>QApplication</code> 的槽 <code>closeAllWindows()</code> 会关闭所有在 <code>app</code> 循环中创建的窗口，并且不用担心释放问题，每个窗口都会调用 <code>closeEvent()</code> 处理。</p>
<p>同时需要注意另一个问题，是创建窗口过多的问题。<strong>这时就需要考虑 <code>MainWindow</code> 的析构问题了</strong>。解决方法很简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个设置会使得所有 <code>close()</code> 的控件立即被析构。可是有个更需要解决的问题：<strong>“最近文件” 列表的问题</strong>——多个窗口需要共享一个 “最近文件” 的列表。</p>
<p>这个问题可以通过将 <code>recentFiles</code> 改成静态变量的方法解决，读者可以自行思考。</p>
<p>实现本节 “多文档” 的目标不止这一种，还可以采用 <code>Qt</code> 的 <code>MDI</code>（multiple document interface）管理方法，以后介绍。</p>
<h3 id="4-2-5-锦上添花：程序启动画面"><a href="#4-2-5-锦上添花：程序启动画面" class="headerlink" title="4.2.5 锦上添花：程序启动画面"></a>4.2.5 锦上添花：程序启动画面</h3><p>这个需求可能是因为甲方的要求，又或是要掩饰程序启动慢的事实（手动狗头）；很简单，只需要在 <code>main</code> 函数中使用 <code>QSplashScreen</code> 类就能解决：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    QSplashScreen* splash = <span class="keyword">new</span> QSplashScreen;</span><br><span class="line">    splash-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/splash.png&quot;</span>));    <span class="comment">// 设置启动界面背景图</span></span><br><span class="line">    splash-&gt;<span class="built_in">show</span>();        <span class="comment">// 不管主程序有没有启动，先启动“启动画面”再说</span></span><br><span class="line">    </span><br><span class="line">    Qt::Alignment topRight = Qt::AlignRight | Qt::AlignTop;</span><br><span class="line">    </span><br><span class="line">    splash-&gt;<span class="built_in">showMessage</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;Setting up the main window...&quot;</span>),</span><br><span class="line">                        topRight, Qt::black);</span><br><span class="line">    MainWindow win;</span><br><span class="line"></span><br><span class="line">    splash-&gt;<span class="built_in">showMessage</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;Testing windows (5s)...&quot;</span>),</span><br><span class="line">                        topRight, Qt::black);</span><br><span class="line">    QTime timer;</span><br><span class="line">    timer.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">while</span> (timer.<span class="built_in">elapsed</span>() &lt; <span class="number">5000</span>)</span><br><span class="line">        app.<span class="built_in">processEvents</span>();</span><br><span class="line">    </span><br><span class="line">    win.<span class="built_in">show</span>();</span><br><span class="line">    splash-&gt;<span class="built_in">finish</span>(&amp;win);    <span class="comment">// 完成，把位置让给 MainWindow</span></span><br><span class="line">    <span class="keyword">delete</span> splash;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-程序中央窗口实现：QTableWidget"><a href="#4-3-程序中央窗口实现：QTableWidget" class="headerlink" title="4.3 程序中央窗口实现：QTableWidget"></a>4.3 程序中央窗口实现：<code>QTableWidget</code></h2><p>中央窗口部件常见的设计方法有下面几种：</p>
<ol>
<li>使用一个<strong>标准的 Qt 窗口部件</strong>（或继承于其的控件）作为 <code>centralWidget</code>，例如 <code>QTableWidget</code>、<code>QTextEdit</code> 等，本工程就是用这种方法；</li>
<li>使用一个<strong>自定义窗口部件</strong> 作为 <code>centralWidget</code>，以后会介绍怎么自定义窗口部件（继承得到的不叫自定义部件）；</li>
<li>使用一个<strong>带布局管理器的普通 <code>QWidget</code></strong> 作为 <code>centralWidget</code>，这也是初学者最喜欢用的方法；</li>
<li>使用<strong>切分窗口（<code>QSplitter</code>）</strong>，利用切分条（<code>splitter handle</code>）控制它们的尺寸；</li>
<li>使用<strong><code>MDI</code></strong>。上一节说了，以后再讨论。</li>
</ol>
<p>本项目使用的是标准 Qt 窗口部件 <code>QTableWidget</code>，并采用继承的方法来给 <code>HolySheet</code> 类添加一些必要的功能。先搞清 <code>QTableWidget</code> 的继承关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QObject -&gt; QWidget -&gt; QTableView -&gt; QTableWidget -&gt; HolySheet(自定义)</span><br><span class="line"></span><br><span class="line">// 这是个纯粹的数据类，就是存放数据、为 QTableWidget 类服务</span><br><span class="line">QTableWidgetItem -&gt; Cell(自定义)</span><br></pre></td></tr></table></figure>
<p>再了解一下 <code>QTableWidget</code> 类对象的组成：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="QTableWidget.png"></p>
<h3 id="4-3-1-表格的定义"><a href="#4-3-1-表格的定义" class="headerlink" title="4.3.1 表格的定义"></a>4.3.1 表格的定义</h3><p>最后开始设计 <code>HolySheet</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QTableWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后会说 Cell 类的定义和实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Cell.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一些常量</span></span><br><span class="line"><span class="keyword">namespace</span> holysheet &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> MagicNumber = <span class="number">0x7F51C883</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> RowCount = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ColumnCount = <span class="number">26</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> holysheet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类是自己写的，先声明以供 HolySheet 类使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HolySheetCompare</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HolySheet</span> : <span class="keyword">public</span> QTableWidget &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HolySheet</span>(QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 这些函数几乎全是之前在 MainWindow 类里面要用的，可以回忆一下它们被用在哪里</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAutoRecalc</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> autoRecalc; &#125;</span><br><span class="line">    <span class="function">QString <span class="title">currentLocation</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">currentFormula</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QTableWidgetSelectionRange <span class="title">selectedRange</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 之所以写 clear 的原因是，不想“全部清除”</span></span><br><span class="line">    <span class="comment">// 想要留下表头提示信息等，所以需要自定义</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">readFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">writeFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span></span>;</span><br><span class="line">    <span class="comment">// 后面实现的时候再说 HolySheetCompare 的定义和实现</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">const</span> HolySheetCompare&amp; compare)</span></span>;</span><br><span class="line"><span class="keyword">public</span> slot:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paste</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectCurrentRow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectCurrentColumn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recalculate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAutoRecalculate</span><span class="params">(<span class="type">bool</span> recalc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findNext</span><span class="params">(<span class="type">const</span> QString&amp; text, Qt::CaseSensitivity cs)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findPrev</span><span class="params">(<span class="type">const</span> QString&amp; text, Qt::CaseSensitivity cs)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modified</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">somethingChanged</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> autoRecalc;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Cell* <span class="title">cell</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">text</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">formula</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFormula</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">const</span> QString&amp; formula)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-2-表格的-“文本”-和-“公式”"><a href="#4-3-2-表格的-“文本”-和-“公式”" class="headerlink" title="4.3.2 表格的 “文本” 和 “公式”"></a>4.3.2 表格的 “文本” 和 “公式”</h3><p>下面正式开始实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HolySheet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">HolySheet::<span class="built_in">HolySheet</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QTableWidget</span>(parent) &#123;</span><br><span class="line">    </span><br><span class="line">    autoRecalc = <span class="literal">true</span>;    <span class="comment">// 默认选中</span></span><br><span class="line">    <span class="comment">// 自定义表格每个格子的内容模式，参数类型需要 QTableWidgetItem</span></span><br><span class="line">    <span class="comment">// 这里用的是继承的 Cell 实例</span></span><br><span class="line">    <span class="built_in">setItemPrototype</span>(<span class="keyword">new</span> Cell);</span><br><span class="line">    <span class="comment">// 设置 QTableWidget 的选择方法，这里仅限连续格子的选择</span></span><br><span class="line">    <span class="built_in">setSelectionMode</span>(ContiguousSelection);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原生信号 QTableWidget::itemChanged(QTableWidgetItem*)</span></span><br><span class="line">    <span class="comment">// 为何不直接连接 modified 信号，而非要经过 somethingChanged 槽？</span></span><br><span class="line">    <span class="comment">// 因为 somethingChanged 槽中需要检查 autoRecalc 并且自动更新！(实现会说)</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">itemChanged</span>(QTableWidgetItem*)),</span><br><span class="line">            <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">somethingChanged</span>()));</span><br><span class="line">    <span class="comment">// 第一次启动需要清空格子内容</span></span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清除行列数（为了删除内容）并重设行列总数</span></span><br><span class="line">    <span class="built_in">setRowCount</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">setColumnCount</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">setRowCount</span>(RowCount);</span><br><span class="line">    <span class="built_in">setColumnCount</span>(ColumnCount);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是给每列第一行加上表头</span></span><br><span class="line">    <span class="comment">// 无需为每行第一列考虑，它们默认数字编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ColumnCount; ++i) &#123;</span><br><span class="line">        QTableWidgetItem* item = <span class="keyword">new</span> QTableWidgetItem;</span><br><span class="line">        item-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="built_in">QChar</span>(<span class="string">&#x27;A&#x27;</span> + i)));</span><br><span class="line">        <span class="comment">// 原生函数，设置指定内容的 QTableWidgetItem 实例为每一列的表头</span></span><br><span class="line">        <span class="built_in">setHorizontalHeaderItem</span>(i, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将选中的位置回归到原点</span></span><br><span class="line">    <span class="built_in">setCurrentCell</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明中的 <code>cell()</code> 函数是为了给定行列，返回一个 <code>Cell</code> 指针，目的和 <code>QTableWidget::item()</code> 取 <code>QTableWidgetItem</code> 一样。只不过之前设置了每个格子类型为 <code>Cell</code>，所以这里自定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cell* <span class="title">HolySheet::cell</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Cell*&gt;(<span class="built_in">item</span>(row, col));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更方便的是，可以直接取单元格的数据为字符串、公式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">HolySheet::text</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Cell* c = <span class="built_in">cell</span>(row, col);</span><br><span class="line">    <span class="keyword">if</span> (c) <span class="keyword">return</span> c-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">HolySheet::formula</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Cell* c = <span class="built_in">cell</span>(row, col);</span><br><span class="line">    <span class="keyword">if</span> (c) <span class="keyword">return</span> c-&gt;formula();    <span class="comment">// Cell 类等待实现：Cell::formula()</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠ 注意：<strong>“公式” 和 “文本” 数据在每个 <code>Cell</code> 中存储在不同地方（机理和 <code>QTableWidgetItem</code> 类有关，由 <code>role</code> 参数控制，等实现 <code>Cell</code> 类再说。目前只需要知道看文本用 <code>text()</code>、看公式 <code>formula()</code>）</strong>，而公式数据可以按照计算结果来修改本格的文本数据。</p>
<p>这里需要搞清楚，很多情况下，公式和文本是相同的，它的<strong>处理规则</strong>如下：</p>
<ul>
<li><p>公式是普通文本时，和文本数据一样，不会计算。例如公式 “Hello” 等价于文本 “Hello”；</p>
</li>
<li><p>公式是数字的时候，公式的数字会被认为双精度浮点数（double），而非文本；</p>
</li>
<li>公式以单引号开始（Excel 中把这个叫做转义内容），那么剩余部分会被认为是文本，例如：公式 “ ‘12345 ” 就是文本，等价于字符串 “12345”；</li>
<li>公式以等号开始，那么公式会被认为是算数公式，例如公式 “ =A1+A2 ” 会计算 A1 和 A2 单元格的文本（转化为数字）之和的值，并填入 <code>Cell</code> 的文本数据中；</li>
</ul>
<p>这里 <strong>由公式计算出值</strong> 的过程会由 <code>Cell</code> 类完成，<code>HolySheet</code> 类不会涉及。</p>
<p>上面实现的是取数据的函数，下面实现设定数据的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::setFormula</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">const</span> QString&amp; formula)</span> </span>&#123;</span><br><span class="line">    Cell* c = <span class="built_in">cell</span>(row, col);</span><br><span class="line">    <span class="keyword">if</span> (!c) &#123;                    <span class="comment">// 当前格子还没有创建对应的 Cell 对象</span></span><br><span class="line">        <span class="comment">// 不用担心释放问题，这里 QTableWidget 会自动</span></span><br><span class="line">        <span class="comment">// 取得新的 QTableWidgetItem 的所有权，并且在合适的时机自动析构</span></span><br><span class="line">        c = <span class="keyword">new</span> Cell;</span><br><span class="line">        <span class="built_in">setItem</span>(row, col, c);</span><br><span class="line">    &#125;</span><br><span class="line">    c-&gt;<span class="built_in">setFormula</span>(formula);        <span class="comment">// Cell 类来设定、计算公式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细心的读者会发现，这里只有 <code>setFormula</code>，没有 <code>setText</code>，刚刚不是说两个分开存储吗？对，这里还是和 <code>QTableWidgetItem</code> 类有关。<strong>我们会在 “<code>QTableWidgetItem</code> 机理简介” 一节进行解释</strong>。</p>
<p>另外能看出来的是，我们存储表并不是使用二维数组或字符串列表，而是<strong>存储为项（item）</strong>，有助于节省空间、加快运行速度等。这种方法在 <code>QListWidget</code> 和 <code>QTreeWidget</code> 类中也能看到（对应 <code>QListWidgetItem</code> 和 <code>QTreeWidgetItem</code> 类）；</p>
<p>此外，对于更大数据量的应用场景，Qt 还支持模型/视图类（model/view），以后介绍。</p>
<p>再来实现其他用到的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">HolySheet::currentLocation</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// currentRow() 和 currentColumn() 还是 QTableWidget 的原生函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QString</span>(<span class="string">&#x27;A&#x27;</span> + <span class="built_in">currentColumn</span>()</span><br><span class="line">                + QString::<span class="built_in">number</span>(<span class="built_in">currentRow</span>() + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原本在 MainWindow 中的用途是展示在 formulaLabel 中的</span></span><br><span class="line"><span class="function">QString <span class="title">HolySheet::currentFormula</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> formula(<span class="built_in">currentRow</span>(), <span class="built_in">currentColumn</span>());    <span class="comment">// 上面的取公式函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::somethingChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为什么不直接 emit modified() 的原因在这</span></span><br><span class="line">    <span class="keyword">if</span> (autoRecalc) <span class="built_in">recalculate</span>();</span><br><span class="line">    <span class="function">emit <span class="title">modified</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-3-表格数据的存取"><a href="#4-3-3-表格数据的存取" class="headerlink" title="4.3.3 表格数据的存取"></a>4.3.3 表格数据的存取</h3><p>再来看<strong>表数据的存储和读取</strong>的问题。我们要用一种<strong>自定义的二进制格式</strong>来实现 <code>HolySheet</code> 文件的读取和存储。这时就用到了 <strong><code>QFile</code> 类和 <code>QDataStream</code> 类</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HolySheet::writeFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="comment">// 如果只写的打开方式失败，说明文件不存在或有权限问题等</span></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::WriteOnly)) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;Cannot write file %1:\n%2.&quot;</span>)</span><br><span class="line">                            .<span class="built_in">arg</span>(file.<span class="built_in">fileName</span>())</span><br><span class="line">                            .<span class="built_in">arg</span>(file.<span class="built_in">errorString</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">QDataStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">    <span class="comment">// 这个版本看你的 Qt 版本。例如 5.12 版本就用 QDataStream::Qt_5_12</span></span><br><span class="line">    out.<span class="built_in">setVersion</span>(QDataStream::Qt_5_14);</span><br><span class="line">    out &lt;&lt; <span class="built_in">quint32</span>(MagicNumber);        <span class="comment">// 混淆作用，你可以随便改 MagicNumber</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更改鼠标指针样式为 “等待”</span></span><br><span class="line">    QApplication::<span class="built_in">setOverrideCursor</span>(Qt::WaitCursor);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; RowCount; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; ColumnCount; ++col) &#123;</span><br><span class="line">            QString str = formula(row, col);</span><br><span class="line">            <span class="keyword">if</span> (!str.<span class="built_in">isEmpty</span>())</span><br><span class="line">                out &lt;&lt; <span class="built_in">quint16</span>(row) &lt;&lt; <span class="built_in">quint16</span>(col) &lt;&lt; str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还原鼠标指针样式</span></span><br><span class="line">    QApplication::<span class="built_in">restoreOverrideCursor</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>QDataStream</code> 模仿了标准 C++ 的流（<code>stream</code>）类，都使用 <code>&gt;&gt;/&lt;&lt;</code> 运算符来输入输出流，例如：<code>in &gt;&gt; x &gt;&gt; y;</code> 和 <code>out &lt;&lt; x &lt;&lt; y;</code>。</p>
<p>这里还考虑到 C++ 的基本类型<strong>在不同平台下的空间大小不同</strong>，所以将它们强制转换为 <code>qint8/quint8/...(16、32)/qint64/quint64</code>，其中 <code>quint64</code> 最安全，但占用空间也比较多，所以结合实际数据范围，上面的代码以 <code>quint16</code> 为例。</p>
<p>在上面的例子中，<code>HolySheet</code> 程序的文件（<code>*.hs</code>）存储格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MagicNumber(混淆码，32 bits, 4 Bytes) | row(16 bits) | column(16 bits) | string (32 bits) | row | column | string | ...</span><br></pre></td></tr></table></figure>
<p>而具体存储方式由 <code>QDataStream</code> 内部决定。例如，<code>quint16</code> 会被 <code>QDataStream</code> 按<strong>小端序</strong>存成 2 Bytes，<code>QString</code> 会被存成 <code>字符串长度 + Unicode字符</code> 形式；</p>
<p><strong>而且不同版本的 Qt ，存储方式不同</strong>，这也是为什么上面要指定 <code>QDataStream</code> 的版本（<code>setVersion</code>）；</p>
<p><code>QDataStream</code> 除了使用在 <code>QFile</code> 上，还能用在 <code>QBuffer</code>、<code>QProcess</code>、<code>QTcpSocket</code>、<code>QUdpSocket</code>、<code>QSslSocket</code> 等类中。</p>
<p>如果仅仅是读取文本，还可以用 <code>QTextStream</code> 来代替 <code>QDataStream</code>。以后会深入介绍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HolySheet::readFile</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly)) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;Cannot read file %1:\n%2.&quot;</span>)</span><br><span class="line">                            .<span class="built_in">arg</span>(file.<span class="built_in">fileName</span>())</span><br><span class="line">                            .<span class="built_in">arg</span>(file.<span class="built_in">errorString</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">QDataStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">    in.<span class="built_in">setVersion</span>(QDataStream::Qt_5_14);</span><br><span class="line">    </span><br><span class="line">    quint32 magic;</span><br><span class="line">    in &gt;&gt; magic;</span><br><span class="line">    <span class="keyword">if</span> (magic != MagicNumber) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;The file is broken / not a HolySheet file.&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">clear</span>();    <span class="comment">// 读取文件之前已经确认过，所以这里直接清空表格</span></span><br><span class="line">    </span><br><span class="line">    quint16 row, column;</span><br><span class="line">    QString str;</span><br><span class="line">    </span><br><span class="line">    QApplication::<span class="built_in">setOverrideCursor</span>(Qt::WaitCursor);</span><br><span class="line">    <span class="keyword">while</span> (!in.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">        in &gt;&gt; row &gt;&gt; column &gt;&gt; str;</span><br><span class="line">        <span class="built_in">setFormula</span>(row, column, str);</span><br><span class="line">    &#125;</span><br><span class="line">    QApplication::<span class="built_in">restoreOverrideCursor</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-4-表格编辑功能"><a href="#4-3-4-表格编辑功能" class="headerlink" title="4.3.4 表格编辑功能"></a>4.3.4 表格编辑功能</h3><p>到现在为止，<code>HolySheet</code> 除 “公式处理功能” 以外的其他功能已经基本具备（准确地说是接口做好了，可以当作 <code>Cell</code> 类已经实现），现在把 <code>Edit</code> 菜单中对应的诸如 <strong>复制、粘贴、剪切、删除</strong> 等功能补充完全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.cpp ------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::cut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">copy</span>();</span><br><span class="line">    <span class="built_in">del</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QTableWidgetSelectionRange range = <span class="built_in">selectedRange</span>();</span><br><span class="line">    QString str;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// QTableWidgetSelectionRange::rowCount 和 columnCount 是原生方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range.<span class="built_in">rowCount</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) str += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; range.<span class="built_in">columnCount</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) str += <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">            <span class="comment">// QTableWidgetSelectionRange::topRow 和 bottomRow 也是原生方法</span></span><br><span class="line">            str += formula(range.<span class="built_in">topRow</span>() + i, range.<span class="built_in">leftColumn</span>() + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置系统剪切板的静态方法</span></span><br><span class="line">    QApplication::<span class="built_in">clipboard</span>()-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的复制方法的结果认为，<strong>每列每格间隔一个制表符（<code>\t</code>），每行间格一个换行符（<code>\n</code>）——这是几乎全球通用的格式</strong>，<code>Microsoft Excel</code> 也这么用，所以可以直接粘贴到其他多数软件上。</p>
<p>对于<strong>粘贴、删除</strong>（剪切包含在其中）的操作，会导致<strong>modified</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里考验信息提取的简单方法的设计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::paste</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QTableWidgetSelectionRange range = <span class="built_in">selectedRange</span>();</span><br><span class="line">    QString str = QApplication::<span class="built_in">clipboard</span>()-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="comment">// 下面解析剪切板中的内容</span></span><br><span class="line">    QStringList rows = str.<span class="built_in">split</span>(<span class="string">&#x27;\n&#x27;</span>);        <span class="comment">// 和 Python 很像</span></span><br><span class="line">    <span class="type">int</span> numRows = rows.<span class="built_in">count</span>();</span><br><span class="line">    <span class="type">int</span> numColumns = rows.<span class="built_in">first</span>().<span class="built_in">count</span>(<span class="string">&#x27;\t&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 区域合法性检验</span></span><br><span class="line">    <span class="keyword">if</span> (range.<span class="built_in">rowCount</span>() * range.<span class="built_in">columnCount</span>() != <span class="number">1</span></span><br><span class="line">       &amp;&amp; (range.<span class="built_in">rowCount</span>() != numRows || range.<span class="built_in">columnCount</span>() != numColumn)) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                            <span class="built_in">tr</span>(<span class="string">&quot;The contents in the clipboard cannot be&quot;</span></span><br><span class="line">                              <span class="string">&quot; pasted because the contents and the &quot;</span></span><br><span class="line">                              <span class="string">&quot;selected area aren&#x27;t the same size.&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">        QStringList columns = rows[i].<span class="built_in">split</span>(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numColumns; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> row = range.<span class="built_in">topRow</span>() + i;</span><br><span class="line">            <span class="type">int</span> column = range.<span class="built_in">leftColumn</span>() + j;</span><br><span class="line">            <span class="keyword">if</span> (row &lt; RowCount &amp;&amp; column &lt; ColumnCount)</span><br><span class="line">                <span class="built_in">setFormula</span>(row, column, columns[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">somethingChanged</span>();        <span class="comment">// 手动触发槽，其中 emit modified() 信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::del</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QTableWidget::selectedItems 原生函数</span></span><br><span class="line">    QList&lt;QTableWidgetItem*&gt; items = <span class="built_in">selectedItems</span>();</span><br><span class="line">    <span class="keyword">if</span> (!items.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="comment">// Qt 自带的 foreach，模仿 Java</span></span><br><span class="line">        foreach (QTableWidgetItem* item, items)</span><br><span class="line">            <span class="keyword">delete</span> item;</span><br><span class="line">        <span class="built_in">somethingChanged</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面用了那么多次自定义的 <code>selectedRange()</code> 函数，现在看看如何实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTableWidgetSelectRange <span class="title">HolySheet::selectedRange</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QTableWidget::selectedRanges() 原生函数</span></span><br><span class="line">    <span class="comment">// 返回放置所有选中的、连续区域对应的 QTableWidgetSelectionRange</span></span><br><span class="line">    QList&lt;QTableWidgetSelectionRange&gt; ranges = <span class="built_in">selectedRanges</span>();</span><br><span class="line">    <span class="keyword">if</span> (ranges.<span class="built_in">isEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QTableWidgetSelectRange</span>();</span><br><span class="line">    <span class="comment">// 还记得吗？之前设置 setSelectionMode(ContiguousSelection)</span></span><br><span class="line">    <span class="comment">// 只会选择连续区域的单元格，所以 ranges 的 size 只会是 0 或 1</span></span><br><span class="line">    <span class="keyword">return</span> range.<span class="built_in">first</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看 <code>MainWindow</code> 的菜单栏中 <code>select</code> 子菜单中，有两个功能（另外一个 <code>selectAll</code> 函数就是 <code>QTableWidget</code> 的原生函数，不用写，直接 <code>connect</code> 就行），一个是 <code>select column</code>，另一个是 <code>select row</code>，它们就是选定当前选中单元格所在的列 / 行，只需要交给原生的 <code>QTableWidget::selectColumn/selectRow(int)</code> 就行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::selectCurrentRow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">selectRow</span>(<span class="built_in">currentRow</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::selectCurrentColumn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">selectColumn</span>(<span class="built_in">currentColumn</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再实现心心念念的 <code>findNext</code>、<code>findPrev</code>（早在 <code>findDialog</code> 的编写上就看到了）：</p>
<blockquote>
<p>注意：无论是向前找，还是向后找，都是从当前选中位置开始的，这是共识</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::findNext</span><span class="params">(<span class="type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为要找下一个，所以从同一行、下一列开始</span></span><br><span class="line">    <span class="comment">// 思考：为什么这里不用考虑出界？——有 while 循环条件保证</span></span><br><span class="line">    <span class="type">int</span> row = <span class="built_in">currentRow</span>(), column = <span class="built_in">currentColumn</span>() + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (row &lt; RowCount) &#123;</span><br><span class="line">        <span class="keyword">while</span> (column &lt; ColumnCount) &#123;</span><br><span class="line">            <span class="comment">// QString::contains(QString, Qt::CaseSensitivity) 原生函数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">text</span>(row, column).<span class="built_in">contains</span>(str, cs)) &#123;</span><br><span class="line">                <span class="built_in">clearSelection</span>();    <span class="comment">// 清除当前选择</span></span><br><span class="line">                <span class="built_in">setCurrentCell</span>(row, column);    <span class="comment">// 选择到下一个符合要求的格子</span></span><br><span class="line">                <span class="built_in">activateWindow</span>();    <span class="comment">// 焦点落回表格</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++column;</span><br><span class="line">        &#125;</span><br><span class="line">        column = <span class="number">0</span>; ++row;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使系统鸣叫一下，表示没找到</span></span><br><span class="line">    QApplication::<span class="built_in">beep</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::findPrev</span><span class="params">(<span class="type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为要查找上一个，所以从同一行、上一列开始</span></span><br><span class="line">    <span class="type">int</span> row = <span class="built_in">currentRow</span>(), column = <span class="built_in">currentColumn</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (row &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (column &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">text</span>(row, column).<span class="built_in">contains</span>(str, cs)) &#123;</span><br><span class="line">                <span class="built_in">clearSelection</span>();</span><br><span class="line">                <span class="built_in">setCurrentCell</span>(row, column);</span><br><span class="line">                <span class="built_in">activateWindow</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --column;</span><br><span class="line">        &#125;</span><br><span class="line">        column = ColumnCount - <span class="number">1</span>;</span><br><span class="line">        --row;</span><br><span class="line">    &#125;</span><br><span class="line">    QApplication::<span class="built_in">beep</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来实现支持 <code>MainWindow</code> 的 <code>Tools</code> 和 <code>Options</code> 菜单的功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此函数是将所有单元格全部遍历一遍，并标记存在数据的 cell 实例，</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::recalculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; RowCount; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> column = <span class="number">0</span>; column &lt; ColumnCount; ++column) &#123;</span><br><span class="line">            <span class="comment">// Cell::setDirty() 等待实现</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cell</span>(row, column)) <span class="built_in">cell</span>(row, column)-&gt;<span class="built_in">setDirty</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面对于所有有数据的格子都调用了 setDirty()，</span></span><br><span class="line">    <span class="comment">// 接下来调用原生函数 QTableWidget::viewpoint() 获得全局视口</span></span><br><span class="line">    <span class="comment">// 对视口（类型）更新重新绘制 update()，调用每一个 “dirty” 的格子重新计算 text</span></span><br><span class="line">    <span class="built_in">viewport</span>()-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置自动重计算</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheet::setAutoRecalculate</span><span class="params">(<span class="type">bool</span> recalc)</span> </span>&#123;</span><br><span class="line">    autoRecalc = recalc;</span><br><span class="line">    <span class="keyword">if</span> (autoRecalc) <span class="built_in">recalculate</span>();    <span class="comment">// 设置后立即先生效一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-5-表格的排序功能"><a href="#4-3-5-表格的排序功能" class="headerlink" title="4.3.5 表格的排序功能"></a>4.3.5 表格的排序功能</h3><p>接下来解释 <code>HolySheetCompare</code> 类 和 <code>HolySheet::sort()</code> 排序的实现原理。</p>
<p>首先，我们要想起 <code>sort</code> 操作的用户使用方法就是：<strong>先选中一个区域，然后在弹出的 <code>sortDialog</code> 对话框中选择第一、二、三键（比较的列数）和升降序的要求，最终程序按数据和要求排序</strong>；</p>
<p><strong>我们简单设计给表格排序的算法</strong>：</p>
<ol>
<li><p>将选中的区域分割成 <strong>行列表</strong>（每一行在一个列表中，不同列的作为列表的不同元素），对这些行列表进行编号；</p>
</li>
<li><p>使用 Qt 自带的 <code>qStableSort</code> 算法（看到名字就知道是稳定的排序算法），它的参数为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemT</span>&gt;</span><br><span class="line"><span class="built_in">qStableSort</span>(</span><br><span class="line">    QList&lt;elemT&gt;::iterator iter_start,</span><br><span class="line">    QList&lt;elemT&gt;::iterator iter_end,</span><br><span class="line">    <span class="built_in">bool</span> (comp)(elemT obj1, elemT obj2)    <span class="comment">// 这不是正规写法，源代码是typename</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>其中 <code>comp</code> 函数指针<strong>一定要对传入的所有可能的 <code>elemT</code> 类数据都能比较</strong>，要求：<strong>如果第一参数小于第二参数，则返回 <code>true</code>，反之无论如何返回 <code>false</code>，那么最后是升序排序</strong>；</p>
<blockquote>
<p>如果想降序，只要让 <code>comp</code> 指向的函数在大于关系时返回 <code>true</code> 就行；</p>
</blockquote>
<p>这里利用传入的将行列表作为排序的最小单元，所以传给 <code>qStableSort</code> 的第一、二参数都会是 <code>QList&lt;QStringList&gt;</code> 类型；第三个参数的函数指针<strong>是设计的核心</strong>，类型要求：<code>bool (comp)(QStringList, QStringList)</code>，<strong>并且能够按 <code>QStringList</code> 中指定的键进行依此排序</strong>；</p>
</li>
<li><p>最后只需把排序好的 <code>QList&lt;QStringList&gt;</code> 重新写入当前列表，并且标记为 “modified” 就完成了。</p>
</li>
</ol>
<p>为了完成上面的第二步的要求，我们设计出了 <code>HolySheetCompare</code> 类，使其<strong>不仅能够保存用户排序的需求信息，还能并且能够按用户指定的键进行元素先后判别</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.h</span></span><br><span class="line"><span class="keyword">namespace</span> hsCompare &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> KeyCount = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> hsCompare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HolySheetCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里重载括号运算符，使得这个类能有函数一样的行为：compare(A, B) -&gt; bool</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> QStringList&amp; row1, <span class="type">const</span> QStringList&amp; row2)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 保存第 n 键在 QStringList 中的索引</span></span><br><span class="line">    <span class="type">int</span> keys[KeyCount];</span><br><span class="line">    <span class="comment">// 保存第 n 键是否为升序</span></span><br><span class="line">    <span class="type">bool</span> ascending[KeyCount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里是实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: HolySheet.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HolySheetCompare::operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> QStringList&amp; row1, <span class="type">const</span> QStringList&amp; row2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第一键到第三键，如果当前键比较的数据不同，那么可以得出结果，结束单次比较；</span></span><br><span class="line">    <span class="comment">// 否则，进入下一键的比较；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KeyCount; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> column = keys[i];    <span class="comment">// 当前比较的键的列索引</span></span><br><span class="line">        <span class="comment">// -1 的含义是用户没有要求这个键（对应 comboBox 界面中的 None）</span></span><br><span class="line">        <span class="comment">// column != -1 说明用户选择了这个键（要比较，否则就不比了）</span></span><br><span class="line">        <span class="keyword">if</span> (column != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(row1[column] != row2[column]) &#123;    <span class="comment">// 说明这个键就能得出结果</span></span><br><span class="line">                <span class="comment">// qStableSort 的要求。详细见上面的参数分析</span></span><br><span class="line">                <span class="keyword">if</span> (ascending[i]) <span class="keyword">return</span> row1[column] &lt; row2[column];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> row1[column] &gt; row2[column];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果本键相同，说明无法比较，需要进行下一个键的比较</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// 所有能比较的键都比完了，还是相同（不是小于），所以返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就能完整实现 <code>HolySheet::sort</code> 函数了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HolySheeet::sort</span><span class="params">(<span class="type">const</span> HolySheetCompare&amp; compare)</span> </span>&#123;</span><br><span class="line">    QList&lt;QStringList&gt; rows;    <span class="comment">// 行列表</span></span><br><span class="line">    QTableWidgetSelectionRange range = <span class="built_in">selectedRange</span>();</span><br><span class="line">    <span class="type">int</span> i;    <span class="comment">// 提出来，因为频繁用到计数变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历每一行</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; range.<span class="built_in">rowCount</span>(); ++i) &#123;</span><br><span class="line">        QStringList curRow;    <span class="comment">// 当前读到的行</span></span><br><span class="line">        <span class="comment">// 对当前行的每一列遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; range.<span class="built_in">columnCount</span>(); ++i)</span><br><span class="line">            curRow.<span class="built_in">append</span>(formula(range.<span class="built_in">topRow</span>() + i,</span><br><span class="line">                                  range.<span class="built_in">leftColumn</span>() + j));</span><br><span class="line">        rows.<span class="built_in">append</span>(curRow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qStableSort</span>(rows.<span class="built_in">begin</span>(), rows.<span class="built_in">end</span>(), compare);</span><br><span class="line">    <span class="comment">// 把行列表放回原位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; range.<span class="built_in">rowCount</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; range.<span class="built_in">columnCount</span>(); ++j)</span><br><span class="line">            <span class="built_in">setFormula</span>(range.<span class="built_in">topRow</span>() + i,</span><br><span class="line">                       range.<span class="built_in">leftColumn</span>() + j,</span><br><span class="line">                       rows[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">clearSelection</span>();    <span class="comment">// 排序完清除选中</span></span><br><span class="line">    <span class="built_in">somethingChanged</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-6-表格的公式计算实现"><a href="#4-3-6-表格的公式计算实现" class="headerlink" title="4.3.6 表格的公式计算实现"></a>4.3.6 表格的公式计算实现</h3><p>到此为止，<code>HolySheet</code> 的全部要求都实现完毕，现在进行 <code>Cell</code> 的定义和实现，一举解决公式计算问题。</p>
<p>根据上面 <code>HolySheet</code> 类对于 <code>Cell</code> 的请求，<code>Cell</code> 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: Cell.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QTableWidgetItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 Cell 类不需要信号-槽机制，所以就不需要 Q_OBJECT 宏</span></span><br><span class="line"><span class="comment">// 更何况 QTableWidgetItem 并不是由 QObject 派生而来</span></span><br><span class="line"><span class="comment">// 这也是为了让项（item）的开销尽可能地低、访问效率尽可能地高</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span> : <span class="keyword">public</span> QTableWidgetItem &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cell</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFormula</span><span class="params">(<span class="type">const</span> QString&amp; formula)</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">formula</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDirty</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下没见过的函数 / 数据成员，会在后面讲它们的含义</span></span><br><span class="line">    <span class="function">QTableWidgetItem* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> role, <span class="type">const</span> QVariant&amp; value)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QVariant <span class="title">data</span><span class="params">(<span class="type">int</span> role)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">QVariant <span class="title">value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前缓存的单元格的值</span></span><br><span class="line">    <span class="keyword">mutable</span> QVariant cachedValue;</span><br><span class="line">    <span class="comment">// 这个值是否不是最新的，即：是否需要更新</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> cacheIsDirty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先解释基础 C++ 知识（和 Qt 没关系）——什么是 <code>mutable</code> 关键字。在 C++ 面向对象中，<code>const(constant)</code> 和 <code>mutable</code> 是一对含义恰好相反的关键字。</p>
<p>考虑这个场景：<strong>如果我有个函数（<code>func_1</code>），只想改变一个数据成员（<code>A</code>），其他（<code>B/C/D/...</code>）变量都不允许它改变，想要保护起来。</strong>为了<strong>强调</strong> “保护数据成员” 这一要求，我们可能会想把 <code>func_1</code> 声明为 <code>const</code> 常量函数，但是怎么能改到 <code>A</code> 呢？</p>
<p>没错！把 <code>A</code> 声明为 <code>mutable</code> 变量就行了！<strong>所谓 <code>mutable</code> 关键字的作用就是：类中的、凡被此关键字修饰的数据成员，都可以被常量函数修改！</strong>这样做可以起到一个作用：强调 “这个静态函数不会修改其他任何数据” 的特点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: Cell.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Cell.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Cell::<span class="built_in">Cell</span>() &#123; <span class="built_in">setDirty</span>(); &#125;    <span class="comment">// 构造函数意思是单元格刚创建时，就需要更新</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cell::setDirty</span><span class="params">()</span> </span>&#123; cacheIsDirty = <span class="literal">true</span>; &#125;    <span class="comment">// 当前 cell 设置需要更新</span></span><br></pre></td></tr></table></figure>
<p>这里没必要传递父对象，因为当你 <code>new</code> 一个 <code>Cell</code> 对象，并且用 <code>setItem()</code> 插入到 <code>QTableWidget</code> 当中时，<code>QTableWidget</code> 会<strong>自动获得对该 <code>Cell</code> 对象的控制权，也会自动帮您析构</strong>。</p>
<h3 id="4-3-7-补充：QTableWidgetItem-类的机理简介"><a href="#4-3-7-补充：QTableWidgetItem-类的机理简介" class="headerlink" title="4.3.7 补充：QTableWidgetItem 类的机理简介"></a>4.3.7 补充：<code>QTableWidgetItem</code> 类的机理简介</h3><p>现在也不得不回答，之前提出的问题：<strong>“为什么在 <code>HolySheet</code>、<code>Cell</code> 里面都只有 <code>setFormula</code>，没有 <code>setText</code>，但却说 ‘公式和文本分开存储’ 呢？”</strong></p>
<p>实际上，在上面 <code>Cell.h</code> 的声明中也能看到，<code>Cell</code> 和它的父类都采用 <strong><code>role</code> 参数来控制 <code>Data</code> 的方法，而这就是 <code>QTableWidgetItem</code> 的设计。</strong></p>
<p>在 Qt 中有几个枚举值：<code>Qt::DisplayRole</code>、<code>Qt::EditRole</code>、<code>Qt::TextAlignmentRole</code>，用来指定 <code>QTableWidgetItem</code> 存储数据的 “不同模式”：</p>
<ul>
<li><code>Qt::EditRole</code> 表示编辑模式，指的是单元格的原始内容（raw）；</li>
<li><code>Qt::DisplayRole</code> 表示显示模式，指的是单元格的显示内容；</li>
<li><code>Qt::TextAlignmentRole</code> 表示对齐样式模式，指的是单元格的对齐方式；</li>
</ul>
<p>无论是原式内容，还是显示内容，都由 <code>QTableWidgetItem::data(Qt::role)</code> 这个原生原生函数统一返回。在默认情况下，<code>QTableWidgetItem</code> 的显示内容和原始内容是一模一样的。</p>
<p><strong>但是我们的程序是模仿 Excel 表格，要处理公式——于是乎，我们自定义了 <code>data(Qt::role)</code> 函数，使得公式所在单元格的显示内容和原始内容可能不一样</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QVariant <span class="title">Cell::data</span><span class="params">(<span class="type">int</span> role)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用方想要获得显示模式（已计算）的信息</span></span><br><span class="line">    <span class="keyword">if</span> (role == Qt::DisplayRole) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">value</span>().<span class="built_in">isValid</span>()) <span class="keyword">return</span> <span class="built_in">value</span>().<span class="built_in">toString</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;####&quot;</span>;    <span class="comment">// 计算失败，不符语法的公式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用方想要获得显示模式中，内容（已计算）显示的格式</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (role == Qt::TextAlignmentRole) &#123;</span><br><span class="line">        <span class="comment">// 如果里面存的是字符串（已计算）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">value</span>().<span class="built_in">type</span>() == QVariant::String) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(Qt::AlignLeft | Qt::AlignVCenter); <span class="comment">//垂直居中，左对齐</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果里面存的是数据（已计算）</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(Qt::AlignRight | Qt::AlignVCenter);<span class="comment">//垂直居中，右对齐</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用方想要获得表格的原始内容</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的方法，将格子中的所有数据原封不动地给调用方</span></span><br><span class="line">        <span class="keyword">return</span> QTableWidgetItem::<span class="built_in">data</span>(role);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先解释一下上面的 <code>if (value().isValid())</code>：这个 <code>Cell::value()</code> 是等会会实现的自定义函数，<strong>用来从 EditRole 的原始内容计算出 DisplayRole 的展示内容，换言之，这个函数用来计算公式的！！！</strong></p>
<p>只有当 “文本是公式，并且不符合语法“的，<code>value()</code> 函数才会返回 <code>QVariant()</code>，其他的无论是<strong>纯文本（原封不动）</strong>，还是<strong>符合语法的公式（解析得到答案）</strong>都会返回有数据的 <code>QVariant</code> 实例。</p>
<p>大家可能会奇怪，<code>QVariant::isValid()</code> 是用来判断什么有效的？事实上，<strong>只有使用 <code>QVariant</code> 的默认构造函数构造（无参数）出来的实例，其 <code>isValid()</code> 返回值才是 <code>false</code>，其他含有数据的实例都是 <code>true</code></strong>。</p>
<p>现在就能解释 “为什么只有 <code>setFormula</code> 没有 <code>setText</code>” 的问题。</p>
<p>因为 <code>QTableWidgetItem::text()</code> 是原生函数（这里 <code>Cell</code> 类没有覆写，因为满足要求），在内部会调用 <code>QTableWidgetItem::data(Qt::DisplayRole)</code>。也就是说：<strong><code>text()</code> 获取的是 “展示模式” 的数据，<code>formula()</code> 获取的是 原始数据</strong>。</p>
<p>所以，我们只需要设置原始数据（<code>Cell::setFormula</code>，更底层调用 <code>Cell::setData</code>）、设置原始数据的计算方式（<code>Cell::value</code> 及相关函数），就能让展示模式、原始内容各自呈现出我们想要的内容！</p>
<p>既然我们现在知道了 <code>setFormula</code>、<code>formula</code>、<code>value</code>、 <code>setData</code> 的作用，现在我们分别实现它们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cell::setFormula</span><span class="params">(<span class="type">const</span> QString&amp; formula)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用底层自定义的 data 设置原始内容</span></span><br><span class="line">    <span class="built_in">setData</span>(Qt::EditRole, formula);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">Cell::formula</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用自定义的 data 以 QString 形式返回原始数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>(Qt::EditRole).<span class="built_in">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写底层的 QTableWidgetItem::setData，添加一个 “标记 dirty” 的功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cell::setData</span><span class="params">(<span class="type">int</span> role, <span class="type">const</span> QVariant&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置数据的功能和父类一样</span></span><br><span class="line">    QTableWidgetItem::<span class="built_in">setData</span>(role, value);</span><br><span class="line">    <span class="comment">// 增添的是标记功能</span></span><br><span class="line">    <span class="keyword">if</span> (role == Qt::EditRole)</span><br><span class="line">        <span class="built_in">setDirty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Cell::setData</code> 的 <code>if (role == Qt::EditRole)</code>，有同学可能会问，为啥要判断一下？既然修改了，直接 <code>setDirty</code> 不就行？其实不是这样。</p>
<p>前面说了，用户只能改原始数据 （<code>Qt::EditRole</code>）；而展示数据（<code>Qt::DisplayRole</code>）是程序内部计算公式 / 纯文本的时候才会更改。<code>setDirty</code> <strong>只需要，也只能</strong> 标记用户的修改行为。一旦标记了机器的修改行为，轻则浪费系统资源，重则会陷入 “机器更新展示数据 -&gt; <code>setDirty</code> -&gt; 机器更新展示数据 -&gt; …” 的<strong>死循环</strong>中。</p>
<p>继续：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里偷个懒，用我很早以前写的简易计算器程序，支持+-*/^()运算</span></span><br><span class="line"><span class="comment">// 简易计算器不在这里展示，详情请看项目源码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value() 底层函数，用于计算原始数据</span></span><br><span class="line"><span class="comment">// 是纯文本 / 符合语法的公式 -&gt; return QVariant(计算结果)</span></span><br><span class="line"><span class="comment">// 是不符合语法的公式 -&gt; return QVariant()，可以被 isValid() 发现</span></span><br><span class="line"><span class="function">QVariant <span class="title">Cell::value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cacheIsDirty) &#123;</span><br><span class="line">        cacheIsDirty = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        QString formulaStr = formula();</span><br><span class="line">        <span class="keyword">if</span> (formulaStr.<span class="built_in">startsWith</span>(<span class="string">&#x27;\&#x27;&#x27;</span>))    <span class="comment">// 单引号引起的内容代表纯文本</span></span><br><span class="line">            cachedValue = formulaStr.<span class="built_in">mid</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (formulaStr.<span class="built_in">startsWith</span>(<span class="string">&#x27;=&#x27;</span>)) &#123;    <span class="comment">// 以等号开头的是公式</span></span><br><span class="line">            cachedValue = <span class="built_in">QVariant</span>();</span><br><span class="line">            <span class="comment">// 将中缀表达式中所有变量（正则式如下）全部递归替换为已计算内容</span></span><br><span class="line">            <span class="function">QRegularExpression <span class="title">exp</span><span class="params">(<span class="string">&quot;([a-zA-Z][1-9][0-9]&#123;0,2&#125;)&quot;</span>)</span></span>;</span><br><span class="line">            QRegularExpressionMatch curMatch;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                curMatch = exp.<span class="built_in">match</span>(formulaStr);</span><br><span class="line">                <span class="keyword">if</span> (!curMatch.<span class="built_in">hasMatch</span>()) <span class="keyword">break</span>;</span><br><span class="line">                QString var = curMatch.<span class="built_in">captured</span>(<span class="number">1</span>);</span><br><span class="line">                QChar tmp = var[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> column = tmp.<span class="built_in">toInt</span>(), row = var.<span class="built_in">mid</span>(<span class="number">1</span>).<span class="built_in">toInt</span>() - <span class="number">1</span>;</span><br><span class="line">                Cell* varCell = <span class="built_in">static_cast</span>&lt;Cell*&gt;(</span><br><span class="line">                    <span class="built_in">tableWidget</span>()-&gt;<span class="built_in">item</span>(row, column)</span><br><span class="line">                );</span><br><span class="line">                QString cur;</span><br><span class="line">                <span class="keyword">if</span> (varCell) cur = varCell-&gt;<span class="built_in">text</span>();    <span class="comment">// 递归替换内容</span></span><br><span class="line">                <span class="keyword">else</span> cur = <span class="string">&quot;0.0&quot;</span>;</span><br><span class="line">                formulaStr.<span class="built_in">replace</span>(</span><br><span class="line">                    formulaStr.<span class="built_in">indexOf</span>(var),    <span class="comment">// offset</span></span><br><span class="line">                    var.<span class="built_in">size</span>(),                    <span class="comment">// length</span></span><br><span class="line">                    cur                            <span class="comment">// new string</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="function">calc <span class="title">calculator</span><span class="params">(formulaStr.toStdString().c_str())</span></span>;</span><br><span class="line">                cachedValue = calculator.<span class="built_in">getResult</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (exprErr err) &#123;    <span class="comment">// 公式计算错误</span></span><br><span class="line">                QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;HolySheet&quot;</span>),</span><br><span class="line">                                    <span class="built_in">tr</span>(err.<span class="built_in">what</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;    <span class="comment">// 是纯文本，但不清楚是不是纯数字</span></span><br><span class="line">            <span class="type">bool</span> ok;    <span class="comment">//能否转换为数字</span></span><br><span class="line">            <span class="type">double</span> d = formulaStr.<span class="built_in">toDouble</span>(&amp;ok);</span><br><span class="line">            <span class="keyword">if</span> (ok) cachedValue = d;        <span class="comment">// 赋值为双精度浮点数</span></span><br><span class="line">            <span class="keyword">else</span> cachedValue = formulaStr;    <span class="comment">// 只能作为字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后可能需要覆写一个父类里的函数 <code>QTableWidget::clone()</code>，它的作用是，当用户在表格中从未创建过的单元格中写入数据时，自动调用 <code>clone()</code> 传递给之前的 <code>QTableWidget::setItemPrototype()</code>，这里需要用 <code>Cell</code> 类 <code>new</code>，不能用父类来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTableWidgetItem* <span class="title">Cell::clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Cell</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样返回的虽然是父类指针，但是指向子类的对象，在 <code>setItemPrototype</code> 函数里会转换回去，所以满足要求。</p>
<hr>
<p>至此，<code>Cell</code>、<code>HolySheet</code> 类已经全部完成，现在只需要回到 <code>MainWindow</code> 中，把剩下还没加入的一些 <code>Action</code> 添加进去，<strong>整个程序就完成了</strong>！</p>
<p>如果你不是 IDE 用户，别忘了写一写 <code>CMakeLists.txt/Makefile</code> 或者运行运行 <code>qmake</code>，把项目跑起来吧 ~</p>
<h2 id="4-4-章末总结-amp-下文预告"><a href="#4-4-章末总结-amp-下文预告" class="headerlink" title="4.4 章末总结 &amp; 下文预告"></a>4.4 章末总结 &amp; 下文预告</h2><p>下面是本人总结的 Qt 5 类图，和上次总结相比，非常非常地长。需要 <code>*.xmind/*.pdf/*.png</code> 格式的同学可以联系本人 ~</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C4.png"></p>
<p><strong>同系列下一篇文章预告：将会是关于 Qt 的 <code>event</code>（事件）、图形绘制 和 游戏的内容。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SJTU-XHW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/technical/qt-for-beginners-2/">https://blog.sjtuxhw.top/technical/qt-for-beginners-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SJTU-XHW's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Programming/">Programming</a><a class="post-meta__tags" href="/tags/Qt/">Qt</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/qt2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/technical/qt-for-beginners-3/" title="从C++入门Qt（三）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/qt3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">从C++入门Qt（三）</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~   前面 4 章节的内容都是从具体项目来学习 Qt 的方法，也已经让我们初步认识了 Qt 的使用方法，下面的内容将按类分块来介绍，文章的篇幅也会短一些。 Chapter 5. Qt 常用事件Qt 中常用的 Event 主要有：鼠标事件、键盘事件、内部事件。其中内部事件绝大多数都交给 信号-槽 来处理，少部分的内部事件在特定情况需要重写，例如 QPaintEvent（下一章说）、 QCloseEvent 关闭事件（实现关闭前确认）。前两个事件是输入事件，都继承于 QInputEvent。 5.1 内部事件前面介绍过，对于内部事件（特指关闭事件），QCloseEvent 的使用方法也很简单，重写 void...</div></div></div></a><a class="pagination-related" href="/literary/2023-hdc/" title="2023 HDC 参会笔记与感悟"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/2023-HDC.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">2023 HDC 参会笔记与感悟</div></div><div class="info-2"><div class="info-item-1">Author: SJTU-XHW Language: Simple Chinese License: CC BY 4.0 本人学识有限，内容难免有错，恳请读者能够批评指正，本人将不胜感激！ 注：在笔记的 这里 你可以体验有趣的 WebXR 的项目 Demo ~  8 月 4 日主会场：HarmonyOS 4 与 SDK 主题演讲一、 Harmony 4 UX 设计 系统输入法表情更新：上千个专属定制的 unicode 表情符号，精细化表情符号所代表的语义；  举例：一碗面条所对应的表情就有 4 种之多，提供 “宽面”、“窄面”，“拌面”、“汤面” 之选择；   结合 HarmonyOS 4 图像识别处理的技术，用户可以 定制 “以自己主角” 的壁纸、主题，体现个性化界面设计之美； 系统界面 UI 焕然一新，同时给用户和开发者提供更多不同的窗口组件；  二、 Security 细化权限控制粒度，最小化权限给予。将应用权限交由用户决定；  举例：用户不允许透露的信息（如通讯录），可以采取提交 “虚假信息”...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/technical/qt-for-beginners-1/" title="从C++入门Qt（一）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/qt1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-28</div><div class="info-item-2">从C++入门Qt（一）</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~   Chapter 0 前置知识0.1 C++ 基础 和 面向对象编程0.2 C++ 的宏（macro） 宏的定义非常自由甚至可以把一个符号定义为一个很长的字符串，甚至代码；主要是因为宏的工作原理是编译前将宏直接原封不动地替换；例如下面的极端例子：  123456789101112131415// 直接把 HELLO 定义为一串代码#define HELLO \    QLabel* label = new QLabel(&quot;&lt;h2&gt;&lt;i&gt;Hello,&lt;/i&gt;&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;&quot;);\   ...</div></div></div></a><a class="pagination-related" href="/technical/qt-for-beginners-3/" title="从C++入门Qt（三）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/qt3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="info-item-2">从C++入门Qt（三）</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~   前面 4 章节的内容都是从具体项目来学习 Qt 的方法，也已经让我们初步认识了 Qt 的使用方法，下面的内容将按类分块来介绍，文章的篇幅也会短一些。 Chapter 5. Qt 常用事件Qt 中常用的 Event 主要有：鼠标事件、键盘事件、内部事件。其中内部事件绝大多数都交给 信号-槽 来处理，少部分的内部事件在特定情况需要重写，例如 QPaintEvent（下一章说）、 QCloseEvent 关闭事件（实现关闭前确认）。前两个事件是输入事件，都继承于 QInputEvent。 5.1 内部事件前面介绍过，对于内部事件（特指关闭事件），QCloseEvent 的使用方法也很简单，重写 void...</div></div></div></a><a class="pagination-related" href="/review/csapp-basic/" title="CSAPP Notes Basic"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="info-item-2">CSAPP Notes Basic</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference:  CMU - 213, Computer Systems A Programmer’s Perspective 3rd Edition by Randal Bryant, David O’Hallaron 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 内容很长，写起来很慢 😳   Chapter 0. Intro0.1 Ints are not Integers, Floats are not Reals $x^2\ge 0$：int（32-bit）may overflow； $a+(b+c)=(a+b)+c$：floats may discard some “unsignificant” digits；  0.2 Learn Assembly but never write it0.3 Memory Matters: Unbounded1234567891011121314typedef struct &#123;    int a[2];    double d;&#125;...</div></div></div></a><a class="pagination-related" href="/review/csapp-ecf-io/" title="CSAPP Notes: ECF &amp; I&#x2F;O"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-ecf.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-16</div><div class="info-item-2">CSAPP Notes: ECF &amp; I&#x2F;O</div></div><div class="info-2"><div class="info-item-1">Chapter 13. Exceptional Control Flow 对应书中第 8 章。  异常控制流是现代计算机系统的一个相当重要的部分。 13.1 Control Flow 控制流：从机器打开到关闭的过程中，处理器只做一件事：读指令、执行指令，一个周期做一个指令。多核的机器则每个核心依次交替执行指令。这些指令序列被称为控制流。硬件正在执行的实际指令序列就被称为物理控制流。  改变内存中控制流的方法：分支 &amp; 跳转，过程调用 &amp; 返回（Branches &amp; Jumps &amp; Procedure call and return）；  都是对于程序状态变化的处理。    但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）； 什么是 “系统级别的状态变化”？  数据从磁盘 / 网卡到达内存中； I/O 设备输入...</div></div></div></a><a class="pagination-related" href="/review/csapp-mm-cache/" title="CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-mh.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-10</div><div class="info-item-2">CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt</div></div><div class="info-2"><div class="info-item-1">Chapter 10. The Memory Hierarchy 本章将介绍系统的内存分层架构。  之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。 正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。 10.1 Storage Technologies &amp; Trends在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。 10.1.1 Random-Access Memory (RAM)当前大多数人所熟知的 “内存” 的一部分就是随机访问存储器（RAM），它具有以下的特征：  RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；  RAM 常常被打包放在 CPU 芯片中；  RAM 中每一个基本的存储单元被称为 单元胞（Cell），一个单元胞中存放 1 bit 数据；  很多个 RAM 芯片共同工作，组成了计算机的...</div></div></div></a><a class="pagination-related" href="/review/csapp-sched-arch/" title="CSAPP Notes: Scheduler &amp; Arch"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_p2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-11</div><div class="info-item-2">CSAPP Notes: Scheduler &amp; Arch</div></div><div class="info-2"><div class="info-item-1">Chapter 8. Scheduler in OS为操作系统的调度环境作出假设：  Each job runs for the same amount of time All jobs arrive at the same time Once started, each job runs to completion All jobs only use the CPU  i.e., they perform no I/O   The run-time of each job is known  引入调度优劣衡量指标：周转时间，$T_{turnaround}=T_{completion}-T_{arrival}$； Strategy 1: FIFO（FCFS，First Come First Served） Implementation: queue； 消除假设 1：若短时任务排在长时任务之后，则平均周转时间效果很差；  Strategy 2 : SJF（Shortest Job First） 内容：对于同时到达的任务，优先选择总时长小的任务。 作用：（应对假设 1...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SJTU-XHW</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84-Qt-%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE"><span class="toc-text">Chapter 4 第一个完整的 Qt 入门项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%88%9B%E5%BB%BA%E4%B8%BB%E7%AA%97%E5%8F%A3-UI"><span class="toc-text">4.1 创建主窗口 UI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%AD%90%E7%B1%BB%E5%8C%96-QMainWindow"><span class="toc-text">4.1.1 子类化 QMainWindow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E5%AE%9E%E7%8E%B0%E8%8F%9C%E5%8D%95%E6%A0%8F%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E8%8F%9C%E5%8D%95%E5%92%8C%E5%B7%A5%E5%85%B7%E6%A0%8F"><span class="toc-text">4.1.2 实现菜单栏、上下文菜单和工具栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81%E6%A0%8F"><span class="toc-text">4.1.3 设置状态栏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%B8%BB%E7%AA%97%E5%8F%A3%E7%9A%84%E5%BA%95%E5%B1%82%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.2 主窗口的底层函数实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-File-%E8%8F%9C%E5%8D%95"><span class="toc-text">4.2.1 File 菜单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E4%B8%BB%E7%AA%97%E5%8F%A3%E8%B0%83%E7%94%A8-Dialog%EF%BC%9A%E6%A8%A1%E6%80%81%E5%92%8C%E9%9D%9E%E6%A8%A1%E6%80%81"><span class="toc-text">4.2.2 主窗口调用 Dialog：模态和非模态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">4.2.3 设置的持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E9%94%A6%E4%B8%8A%E6%B7%BB%E8%8A%B1%EF%BC%9A%E5%A4%9A%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.2.4 锦上添花：多文档模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E9%94%A6%E4%B8%8A%E6%B7%BB%E8%8A%B1%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E7%94%BB%E9%9D%A2"><span class="toc-text">4.2.5 锦上添花：程序启动画面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A4%AE%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0%EF%BC%9AQTableWidget"><span class="toc-text">4.3 程序中央窗口实现：QTableWidget</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">4.3.1 表格的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E8%A1%A8%E6%A0%BC%E7%9A%84-%E2%80%9C%E6%96%87%E6%9C%AC%E2%80%9D-%E5%92%8C-%E2%80%9C%E5%85%AC%E5%BC%8F%E2%80%9D"><span class="toc-text">4.3.2 表格的 “文本” 和 “公式”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96"><span class="toc-text">4.3.3 表格数据的存取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-%E8%A1%A8%E6%A0%BC%E7%BC%96%E8%BE%91%E5%8A%9F%E8%83%BD"><span class="toc-text">4.3.4 表格编辑功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-%E8%A1%A8%E6%A0%BC%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8A%9F%E8%83%BD"><span class="toc-text">4.3.5 表格的排序功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-6-%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%85%AC%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.3.6 表格的公式计算实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-7-%E8%A1%A5%E5%85%85%EF%BC%9AQTableWidgetItem-%E7%B1%BB%E7%9A%84%E6%9C%BA%E7%90%86%E7%AE%80%E4%BB%8B"><span class="toc-text">4.3.7 补充：QTableWidgetItem 类的机理简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%AB%A0%E6%9C%AB%E6%80%BB%E7%BB%93-amp-%E4%B8%8B%E6%96%87%E9%A2%84%E5%91%8A"><span class="toc-text">4.4 章末总结 &amp; 下文预告</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/pytorch-dim/" title="如何理解 PyTorch 函数的 dim 参数"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/pth_dim.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何理解 PyTorch 函数的 dim 参数"/></a><div class="content"><a class="title" href="/technical/pytorch-dim/" title="如何理解 PyTorch 函数的 dim 参数">如何理解 PyTorch 函数的 dim 参数</a><time datetime="2025-02-18T12:17:05.000Z" title="发表于 2025-02-18 20:17:05">2025-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/java-adv-3/" title="Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/java-adv-3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI"/></a><div class="content"><a class="title" href="/technical/java-adv-3/" title="Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI">Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI</a><time datetime="2025-01-06T05:44:06.000Z" title="发表于 2025-01-06 13:44:06">2025-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/algo-desgin-table/" title="算法设计知识点自查表"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/algo-design-table.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法设计知识点自查表"/></a><div class="content"><a class="title" href="/review/algo-desgin-table/" title="算法设计知识点自查表">算法设计知识点自查表</a><time datetime="2024-12-31T14:47:03.000Z" title="发表于 2024-12-31 22:47:03">2024-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/redis-starter/" title="Redis 入门：从实践到理论"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/redis.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 入门：从实践到理论"/></a><div class="content"><a class="title" href="/technical/redis-starter/" title="Redis 入门：从实践到理论">Redis 入门：从实践到理论</a><time datetime="2024-11-12T13:05:37.000Z" title="发表于 2024-11-12 21:05:37">2024-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/python-sci-starter/" title="Python 科学计算入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/python_sci.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 科学计算入门"/></a><div class="content"><a class="title" href="/technical/python-sci-starter/" title="Python 科学计算入门">Python 科学计算入门</a><time datetime="2024-11-03T11:08:13.000Z" title="发表于 2024-11-03 19:08:13">2024-11-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SJTU-XHW  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Powered By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>