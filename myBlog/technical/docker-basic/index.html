<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker 基础 | SSRVodka's blog</title><meta name="author" content="SSRVodka,xhwpro@gmail.com"><meta name="copyright" content="SSRVodka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="written by SJTU-XHW Reference：Docker 官方文档 本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker 基础">
<meta property="og:url" content="https://blog.sjtuxhw.top/technical/docker-basic/index.html">
<meta property="og:site_name" content="SSRVodka&#39;s blog">
<meta property="og:description" content="written by SJTU-XHW Reference：Docker 官方文档 本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/docker.jpeg">
<meta property="article:published_time" content="2023-07-09T14:23:41.000Z">
<meta property="article:modified_time" content="2024-10-25T13:54:49.209Z">
<meta property="article:author" content="SSRVodka">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="Container">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/docker.jpeg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/technical/docker-basic/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/css/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker 基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SSRVodka's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/docker.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SSRVodka's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Docker 基础</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Docker 基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-09T14:23:41.000Z" title="发表于 2023-07-09 22:23:41">2023-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T13:54:49.209Z" title="更新于 2024-10-25 21:54:49">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/technical/docker-basic/#post-comment"><span class="waline-comment-count" data-path="/technical/docker-basic/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><i>written by SJTU-XHW</i></p>
<p><i>Reference：</i><a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.docker.com/engine/reference/builder/">Docker 官方文档</a></p>
<p><i>本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p>
<hr>
<span id="more"></span>
<blockquote>
<p><strong>前置知识：Linux、Git、虚拟机、略懂操作系统</strong>；</p>
</blockquote>
<h2 id="Chapter-0-Docker-安装"><a href="#Chapter-0-Docker-安装" class="headerlink" title="Chapter 0. Docker 安装"></a>Chapter 0. Docker 安装</h2><h3 id="Mac-安装"><a href="#Mac-安装" class="headerlink" title="Mac 安装"></a>Mac 安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask docker</span><br></pre></td></tr></table></figure>
<h3 id="Linux-任何-distribution-自动安装"><a href="#Linux-任何-distribution-自动安装" class="headerlink" title="Linux 任何 distribution 自动安装"></a>Linux 任何 distribution 自动安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh    <span class="comment"># 自动安装脚本</span></span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun <span class="comment"># 国内阿里云，如果你在国外，删除 --mirror参数</span></span><br></pre></td></tr></table></figure>
<h3 id="Ubuntu-手动安装"><a href="#Ubuntu-手动安装" class="headerlink" title="Ubuntu 手动安装"></a>Ubuntu 手动安装</h3><ol>
<li><p>卸载旧版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker \</span><br><span class="line">               docker-engine \</span><br><span class="line">               docker.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 HTTPS 必要软件包 和 CA 证书防止安装包篡改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加软件源的 <code>GPG</code> 密钥，以确认所下载软件包的合法性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你在国外，或者正在科学上网，请使用国外密钥：</span></span><br><span class="line"><span class="comment"># curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>向 APT 源添加国内软件源（stable 版本）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 如果你在国外……</span></span><br><span class="line"><span class="comment"># echo \</span></span><br><span class="line"><span class="comment">#   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="comment">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新 APT 缓存并安装 <code>docker-ce</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 Docker 服务并建立对应用户组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Chapter-1-基本概念"><a href="#Chapter-1-基本概念" class="headerlink" title="Chapter 1. 基本概念"></a>Chapter 1. 基本概念</h2><h3 id="1-1-具体原理、地位和性质"><a href="#1-1-具体原理、地位和性质" class="headerlink" title="1.1 具体原理、地位和性质"></a>1.1 具体原理、地位和性质</h3><blockquote>
<p>本部分内容涉及内容比较深，学完 <code>Go</code> 和 操作系统再回来填坑……</p>
</blockquote>
<h3 id="1-2-Docker-和-传统虚拟化技术的比较"><a href="#1-2-Docker-和-传统虚拟化技术的比较" class="headerlink" title="1.2 Docker 和 传统虚拟化技术的比较"></a>1.2 Docker 和 传统虚拟化技术的比较</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="virtualization.png" height="200px"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="docker.png" height="150px"></p>
<p>如上图所示，传统虚拟化技术构建出的 <code>Hypervisor</code> 需要<strong>虚拟出一套硬件</strong>，并在其上运行一个完整的操作系统（<code>Guest OS</code>），再在该系统上运行所需进程；</p>
<p>而 Docker 容器中的应用进程借助 <code>Docker Engine</code> 直接运行于宿主内核，无需硬件虚拟；</p>
<table>
    <tr style="text-align: center;">
        <th>特性</th>
        <th>容器</th>
        <th>虚拟机</th>
    </tr>
    <tr>
        <td>启动</td>
        <td>秒级</td>
        <td>分钟级</td>
    </tr>
    <tr>
        <td>硬盘使用</td>
        <td>一般为 MB</td>
        <td>一般为 GB</td>
    </tr>
    <tr>
        <td>性能</td>
        <td>接近原生</td>
        <td>弱于</td>
    </tr>
    <tr>
        <td>系统支持量</td>
        <td>单机支持上千个容器</td>
        <td>一般几十个</td>
    </tr>
    <tr>
        <td>迁移和部署</td>
        <td>容易</td>
        <td>困难</td>
    </tr>
    <tr>
        <td>维护和扩展</td>
        <td>高质量官方镜像</td>
        <td>极其困难</td>
    </tr>
</table>


<h3 id="1-3-镜像"><a href="#1-3-镜像" class="headerlink" title="1.3 镜像"></a>1.3 镜像</h3><ul>
<li><p>操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持；</p>
</li>
<li><p>而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统（实际上就是一个特殊的文件系统）；除了<strong>提供</strong>容器运行时所需的<strong>程序、库、资源、配置</strong>等文件外，还包含了一些为运行时准备的一些配置参数（如<strong>匿名卷、环境变量、用户</strong>等）；</p>
</li>
<li><p>Docker 镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变；</p>
</li>
<li><p>Docker 镜像采用 <strong><a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a></strong> 技术（操作系统术语），设计为 <strong>分层存储</strong> 的架构——并非像 <code>*.iso</code> 一样打包成一个文件，<strong>而是一组、多层文件系统联合而成</strong>；</p>
<ol>
<li><p>镜像的<strong>构建</strong>时，会一层层构建；前一层是后一层的基础；</p>
</li>
<li><p>每一层构建完就不再改变，<strong>后一层的任何更改只发生在自己这层</strong>；</p>
<blockquote>
<p>比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除（最终容器运行时，也不会看到）；</p>
</blockquote>
</li>
<li><p>优点：<strong>分层存储的特征还使得镜像的复用、定制变的更为容易</strong>；</p>
</li>
</ol>
</li>
<li><p>镜像的构建方法以后再说；</p>
</li>
</ul>
<h3 id="1-4-容器"><a href="#1-4-容器" class="headerlink" title="1.4 容器"></a>1.4 容器</h3><ul>
<li><p>Docker 镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，可以看成面向对象程序设计中的 <strong>类</strong> 和 <strong>实例</strong>；</p>
<blockquote>
<p>镜像是<strong>静态</strong>的定义，容器是镜像<strong>运行时的</strong>实体；</p>
</blockquote>
</li>
<li><p>容器的实质是<strong>进程</strong>（process），但和运行在 <code>Host OS</code> 上的普通进程不一样，有着<strong>独立的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>（<code>Linux namespace</code>），包含独立的 <code>root</code> 文件系统、网络配置、进程空间、用户 ID 空间</strong>；</p>
<blockquote>
<p>体现<strong>隔离</strong>特性，有利于保证宿主系统的安全性；</p>
</blockquote>
</li>
<li><p>容器 和 镜像一样，使用<strong>分层存储</strong>——以镜像为<strong>基础层</strong>，在其上创建一个当前容器的存储层，称这个为容器<strong>运行时访问</strong>而准备的存储层为 <strong>容器存储层</strong>；</p>
<blockquote>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失；</p>
</blockquote>
<p><strong>tips 1.</strong> <span id="needVolume">按 Docker 规范，容器不应该向其存储层内写入任何数据，容器存储层要保持<strong>无状态化</strong>；</span></p>
<blockquote>
<p>注：Instead，应该使用 <strong>数据卷（Volume，类似 <code>Linux</code> 中的 <code>mount</code> 挂载目录）</strong>、或者 <strong>绑定宿主目录</strong>（这两种方法将在 Chapter 5 介绍），在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高；</p>
<p>相反，当我们运行一个容器的时候（<strong>如果不使用卷的话</strong>），我们做的任何文件修改都会被记录于容器存储层里，<strong>导致多个无关文件被修改，不利于迁移、维护</strong>；</p>
</blockquote>
<p><strong>tips 2.</strong> 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡，因此在容器被删除或重启后，在数据卷中的数据不会丢失；</p>
</li>
</ul>
<h3 id="1-5-仓库"><a href="#1-5-仓库" class="headerlink" title="1.5 仓库"></a>1.5 仓库</h3><ul>
<li><p>Docker 社区提供集中的<strong>存储、分发镜像</strong>的服务，称为<strong><code>Docker Registry</code> 公开服务</strong>，最常用的是 <code>Docker Hub</code>（可以理解成类似 <code>Github</code>、<code>Gitee</code> 一样）：提供 <strong>公共仓库（public repository）</strong> 服务，允许用户免费上传、下载公开的镜像；</p>
<blockquote>
<p>因此，<strong>Registry 和 Repository 是两个完全不同的概念</strong>；前者指注册的、提供这些服务的服务器，后者指可以被认为是一个具体的项目或目录；</p>
<p>例如，对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名；</p>
</blockquote>
</li>
<li><p>用户也还可以借助 ① Docker 开发团队的开源 Docker Registry 镜像；或 ② 第三方软件（如 Harbor 和 Sonatype Nexus），来实现<strong>本地搭建私有 Docker Registry</strong>；</p>
</li>
</ul>
<h2 id="Chapter-2-使用镜像"><a href="#Chapter-2-使用镜像" class="headerlink" title="Chapter 2. 使用镜像"></a>Chapter 2. 使用镜像</h2><h3 id="2-1-镜像获取"><a href="#2-1-镜像获取" class="headerlink" title="2.1 镜像获取"></a>2.1 镜像获取</h3><ul>
<li><p>从 <code>Docker Hub</code> 上获取：<code>docker pull [options] [addr:port/]&lt;RepositoryName&gt;[:tag]</code></p>
<ul>
<li><code>[options]</code>：请运行 <code>docker pull --help</code> 查看；</li>
<li><code>[addr:port/]</code>：默认 <code>docker.io:443</code>（<code>Docker Hub</code> 服务器）；</li>
<li><code>&lt;RepositoryName&gt;</code>：格式为 <code>&lt;userName&gt;/&lt;softwareName&gt;</code>，<strong>如果仅有 <code>softwareName</code>，则默认官方镜像（<code>userName = library</code>）</strong>;</li>
<li><code>[:tag]</code>：<strong>镜像标签</strong>，可以理解成 <code>Git</code> 中的 <code>tag</code>，起到<strong>标识镜像版本或分类</strong>的作用；<strong>同一个镜像必须有相同的 ID，可以有不同的 <code>tag</code></strong>；</li>
</ul>
<blockquote>
<p>下载会一层层下载（分层存储），完成后会显示<strong>每层 ID 前 12 位</strong>和镜像整体的 <code>sha256</code> 摘要；</p>
</blockquote>
</li>
</ul>
<h3 id="2-2-列出镜像"><a href="#2-2-列出镜像" class="headerlink" title="2.2 列出镜像"></a>2.2 列出镜像</h3><ul>
<li><p>列出顶层镜像：<code>docker image ls</code>，显示 <strong>仓库名、标签、镜像 ID、创建时间和占用空间大小</strong>；</p>
</li>
<li><p>关于 <strong>“占用空间大小”</strong>：由于 Docker 使用 Union FS 和多层存储结构，<strong>不同层间可以继承、复用</strong>，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比上面命令显示的小很多；</p>
<blockquote>
<p>想要查看<strong>镜像、容器、数据卷</strong>所占用的<strong>真实空间</strong>，请运行：<code>docker system df</code>；</p>
</blockquote>
</li>
<li><p><strong>虚悬镜像（dangling image）</strong>：一种特殊的<strong>顶层镜像</strong>，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>；</p>
<ul>
<li>产生原因：① 同一标签的镜像因为官方的维护，ID 发生变更，这样在 <code>docker pull</code> 同个镜像 <code>tag</code> 时，此镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消；② 自己本地构建镜像（<code>docker build</code>，以后介绍）时，由于新旧镜像同名，旧镜像名称被取消；</li>
<li><strong>查找虚悬镜像</strong>：<code>docker image ls -f dangling=true</code>（加 <code>-f</code> 参数，<code>--filter</code> 过滤）；</li>
<li><strong>删除虚悬镜像</strong>：虚悬镜像已经失去了存在的价值，可以随意删除：<code>docker image prune</code>；</li>
</ul>
</li>
<li><p><strong>中间层镜像</strong>：想要看中间层镜像，需要使用 <code>docker image ls -a</code>（加 <code>-a</code> 参数）；</p>
<blockquote>
<p>此时可能会出现没有标签的镜像，<strong>但它们不是虚悬镜像，而是中间层镜像</strong>，由于多层存储结构，它们相互依赖，<strong>千万不能盲目删除</strong>；</p>
</blockquote>
</li>
<li><p><strong>按条件筛选列出镜像</strong>：<code>docker image ls -f &lt;dangling=bool/since=repositoryName/label=labelName&gt;</code></p>
</li>
<li><p><strong>输出格式化</strong>：<code>docker image ls --format &quot;&lt;GoTemplate&gt;&quot;</code></p>
<blockquote>
<p>这里的 <code>GoTemplate</code> 是 Go 语言的<strong>模板语法</strong>，可以简单使用常见变量：<code>&#123;&#123;.ID&#125;&#125;</code>、<code>&#123;&#123;.Repository&#125;&#125;</code>、<code>&#123;&#123;.Tag&#125;&#125;</code>；</p>
</blockquote>
</li>
</ul>
<h3 id="2-3-删除镜像"><a href="#2-3-删除镜像" class="headerlink" title="2.3 删除镜像"></a>2.3 删除镜像</h3><ul>
<li><p>镜像 ID 删除：<code>docker image rm &lt;IMAGE_ID&gt;</code></p>
<blockquote>
<p>一般只有脚本使用完整 ID，人工一般都使用短 ID，对长度没有要求，只要能区分就行（一般 长度大于 3 就能区分）</p>
</blockquote>
</li>
<li><p><code>repositoryName</code> 删除：<code>docker image rm &lt;RepositoryName&gt;</code>；</p>
</li>
<li><p>镜像 <code>sha256</code> 摘要删除：<code>docker image &lt;name@sha256:VALUE&gt;</code>；</p>
<blockquote>
<p>查询镜像 <code>sha256</code> 摘要：<code>docker image ls --digests</code>；</p>
</blockquote>
</li>
<li><p>补充：<code>Untagged</code> 和 <code>Deleted</code> 的区别：请结合 <code>Git</code> 自行品味；<code>Git</code> 和这个很相似；</p>
</li>
<li><p><strong>查询删除法</strong>：<code>docker image rm $(docker image ls -q &lt;之前的查询条件&gt;)</code></p>
</li>
</ul>
<h3 id="2-4-镜像定制和构建"><a href="#2-4-镜像定制和构建" class="headerlink" title="2.4 镜像定制和构建"></a>2.4 镜像定制和构建</h3><blockquote>
<p>注：第一次学习感觉有难度的可以先跳过本节，直接进入下一章 Chapter 3！</p>
</blockquote>
<p><strong>镜像的定制实际上就是定制每一层所添加的配置、文件</strong>。</p>
<blockquote>
<p>正如官方文档所说：如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决；</p>
<p><strong>这个脚本</strong>（文本文档）就是 <code>Dockerfile</code>。和 <code>Makefile</code>、<code>CMakeLists</code> 有异曲同工之妙，名字必须是 <code>Dockerfile</code>；</p>
</blockquote>
<h4 id="2-4-1-Dockerfile-定制"><a href="#2-4-1-Dockerfile-定制" class="headerlink" title="2.4.1 Dockerfile 定制"></a>2.4.1 Dockerfile 定制</h4><blockquote>
<p><code>Dockerfile</code> 包含了一条条的 <strong>指令(Instruction)</strong>，每条指令构建一层，每行一条指令，末尾没有分号；</p>
</blockquote>
<h5 id="FROM-指令：指定基础镜像"><a href="#FROM-指令：指定基础镜像" class="headerlink" title="FROM 指令：指定基础镜像"></a><code>FROM</code> 指令：指定基础镜像</h5><ul>
<li><p>语法：<code>FROM &lt;REPO_NAME&gt;</code>，<code>&lt;REPO_NAME&gt;</code> 为之前提到的存储库名；</p>
</li>
<li><p>所谓定制镜像，那一定是<strong>以一个镜像为基础，在其上进行定制</strong>；</p>
</li>
<li><p>因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是<strong>必备的指令</strong>，并且<strong>必须是第一条指令</strong>；</p>
</li>
<li><p><code>Docker Hub</code> 上有很多高质量基础镜像：</p>
<ol>
<li>服务类镜像：<code>nginx</code>、<code>redis</code>、<code>mongo</code>、<code>mysql</code>、<code>httpd</code>、<code>php</code>、<code>tomcat</code> 等；</li>
<li>语言应用类镜像：<code>node</code>、<code>openjdk</code>、<code>python</code>、<code>ruby</code>、<code>golang</code> 等；</li>
<li>操作系统类镜像（具有对应软件库可更自由地配置）：<code>ubuntu</code>、<code>debian</code>、<code>centos</code> 等；</li>
</ol>
</li>
<li><p><strong>空白基础镜像</strong>：<code>scratch</code>（意味着<strong>不以任何镜像为基础</strong>，接下来所写的指令将作为镜像第一层开始存在）；</p>
<blockquote>
<p>不以任何系统为基础，<strong>直接将可执行文件复制进镜像</strong>的做法并不罕见：</p>
<ol>
<li>Linux 下静态编译的程序（所需的一切库都已经在可执行文件中，无需操作系统的运行时支持）；</li>
<li>大部分使用 Go 语言开发的应用（Go 特别适合容器微服务架构的原因之一）；</li>
</ol>
</blockquote>
</li>
</ul>
<h5 id="RUN-指令：执行命令"><a href="#RUN-指令：执行命令" class="headerlink" title="RUN 指令：执行命令"></a><code>RUN</code> 指令：执行命令</h5><ul>
<li><p>语法：<code>RUN &lt;SH_COMMAND&gt;</code> 或 <code>RUN [&quot;executableName&quot;, &quot;param1&quot;, ...]</code>；</p>
<ul>
<li><code>RUN &lt;SH_COMMAND&gt;</code> 参数会自动翻译为 <code>RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;&lt;SH_COMMAND&gt;&quot;]</code>；</li>
</ul>
</li>
<li><p>⚠ <strong>注意：每一个 <code>RUN</code> 指令都会新建一层镜像层</strong>，因此从重用性角度出发，<strong>同一个目的的操作尽量写在一个 <code>RUN</code> 语句中</strong>，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样的 Dockerfile 编写方式是不恰当的！！！结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等</span></span><br><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y gcc libc6-dev make wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这段代码只有一个目的，就是编译、安装 redis 可执行文件，所以没有必要建立很多层，这只是一层的事情。</span></span><br><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x; buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># 以下清理文件是非常重要的步骤，确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</span></span></span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \ <span class="comment"># 清理了 apt 缓存文件</span></span><br><span class="line">    &amp;&amp; rm redis.tar.gz \             <span class="comment"># 清理了所有下载、展开的文件</span></span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps <span class="comment"># 删除了为了编译构建所需要的软件和库</span></span><br></pre></td></tr></table></figure>
<p>⚠ <strong>更重要的是</strong>，每个 <code>RUN</code> 指令由于所处的层数不一样，所以执行这个命令的命令行也不一样，这样就相当于开了新的命令行窗口，有的时候第一种写法甚至是错误的、无法运行的，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure>
<p>你会发现 <code>world.txt</code> 根本不在 <code>/app/</code> 下面，因为下一个 <code>RUN</code> 的 console 已经不在 <code>/app/</code> 下面了；<strong>这就是对 Docker 分层存储理解不透的结果</strong>。也正是这个原因，请不要把 <code>Dockerfile</code> 作为 shell 脚本使用！</p>
<p>想要实现上面的操作，可以改成：<code>RUN cd /app &amp;&amp; echo &quot;hello&quot; &gt; world.txt</code>；</p>
<p>⚠ 如果你实在需要分成多个 <code>RUN</code> 步骤（例如为了容器层的可重用性——中间多一层可以有其他用处），但<strong>又希望命令行固定在某个目录下进行</strong>，请参考下文 <strong><code>WORKDIR</code> 指令的使用</strong>；</p>
</li>
</ul>
<h5 id="COPY-指令：复制文件"><a href="#COPY-指令：复制文件" class="headerlink" title="COPY 指令：复制文件"></a><code>COPY</code> 指令：复制文件</h5><ul>
<li><p>语法：<code>COPY [--chown=&lt;user:group&gt;] &lt;src1&gt;[, src2, ...], &lt;dist1&gt;[, dist2, ...]</code> ；</p>
</li>
<li><p>支持 <code>--chown</code> 参数更改文件所属用户和组；</p>
</li>
<li><p>使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等；</p>
</li>
<li><p><code>src</code> 源路径必须在上下文路径中，关于什么是上下文路径，建议立即查看 <a href="#contextPath"><strong>下文</strong>🔗</a>；</p>
</li>
<li><p>不仅可以指定多个文件，<code>src</code> 还支持 <code>Go</code> 语言的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://golang.org/pkg/path/filepath/#Match"><code>filepath.Match</code></a> 通配符规则，可以简单认为：</p>
<table>
    <tr style="text-align: center;">
        <th>Regex 正则</th>
        <th>Go::filepath.Match</th>
    </tr>
    <tr>
        <td>.*</td>
        <td>*</td>
    </tr>
    <tr>
        <td>.?</td>
        <td>?</td>
    </tr>
    <tr>
        <td>[a-zA-Z]</td>
        <td>[{a-zA-Z}]</td>
    </tr>
</table>
</li>
<li><p><strong>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径</strong>；举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|</span><br><span class="line">|--- Dockerfile</span><br><span class="line">|--- ABC.txt</span><br><span class="line">|--- testDir/</span><br><span class="line">        |</span><br><span class="line">        |--- DEF.txt</span><br><span class="line">        |--- testDir2/</span><br><span class="line">                |</span><br><span class="line">                |--- FGH.txt</span><br><span class="line">                |--- IJK.txt</span><br></pre></td></tr></table></figure>
<p>上面的项目目录，如果在 Dockerfile 中有这么一段：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>并且构建镜像以 <code>testDir</code> 为上下文根目录：<code>docker build -f Dockerfile -t XXX ./testDir/</code>，那么在容器中，<strong><code>testDir</code> 本身不会在里面</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app/</span><br><span class="line">|--- DEF.txt</span><br><span class="line">|--- testDir2/</span><br><span class="line">        |</span><br><span class="line">        |--- FGH.txt</span><br><span class="line">        |--- IJK.txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="ADD-指令：自动解压并复制文件"><a href="#ADD-指令：自动解压并复制文件" class="headerlink" title="ADD 指令：自动解压并复制文件"></a><code>ADD</code> 指令：自动解压并复制文件</h5><ul>
<li>和 <code>COPY</code> 语法几乎相同，<strong>真正需要 <code>ADD</code> 的场景是自动解压缩</strong>，即 <code>&lt;src&gt;</code> 路径是一个 <code>*.zip/*.bz/*.xz/*.gz/*.tar</code> 时会自动解压缩；<strong>其他时候应该使用语义明确的 <code>COPY</code></strong>；</li>
</ul>
<h5 id="CMD-指令：设置容器启动命令"><a href="#CMD-指令：设置容器启动命令" class="headerlink" title="CMD 指令：设置容器启动命令"></a><code>CMD</code> 指令：设置容器启动命令</h5><ul>
<li><p>用于指定默认的容器主进程的启动命令（容器启动指令 <code>docker run</code> 将在 3.1 介绍），语法和 <code>RUN</code> 相同；</p>
</li>
<li><p>如果指定了该命令，那么当运行 <code>docker run</code> 后，<strong>默认运行容器中的 <code>/bin/bash</code></strong> 的行为将被更改为 <code>CMD</code> 后的指令；</p>
</li>
<li><p><strong>易错点：前台执行 &amp;&amp; 后台执行</strong>；先问大家伙一个问题，下面的指令有意义吗？</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;&lt;h1&gt;Hello, nginx!&lt;/h1&gt;&quot;</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> systemctl start nginx</span></span><br></pre></td></tr></table></figure>
<p>如果你认为没有任何问题的话，恭喜你，<strong>你成功地将 传统虚拟机 和 docker 容器搞混了！</strong> 请你好好复习 <strong>1.2 和 1.4</strong> 的内容：容器本身就是一种进程，<strong>它不是虚拟机、内部不存在守护进程，因此不允许在“后台”启动应用，必须在前台，否则会直接退出</strong>；</p>
<blockquote>
<p>引用官方文档的一句话：对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出；</p>
</blockquote>
<p>上面的 <code>CMD systemctl start nginx</code> 会被解释成：<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，这样运行完这条指令后主进程直接结束！</p>
<p><strong>想要在容器生存周期内持续运行 <code>nginx</code>，必须以指定前台的方式运行，如下：</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;&lt;h1&gt;Hello, nginx!&lt;/h1&gt;&quot;</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="ENTRYPOINT-指令：设置容器入口点"><a href="#ENTRYPOINT-指令：设置容器入口点" class="headerlink" title="ENTRYPOINT 指令：设置容器入口点"></a><code>ENTRYPOINT</code> 指令：设置容器入口点</h5><ul>
<li><p>语法和 <code>RUN</code>、<code>CMD</code> 都相同，<strong>它存在的主要作用有两个：① 更方便地从外部添加运行参数；② 更方便地进行容器运行前准备工作</strong>；</p>
</li>
<li><p>想理解主要作用，需要知道 <code>ENTRYPOINT</code> 如何工作：<strong>当指定 <code>ENTRYPOINT</code> 后，<code>CMD</code> 指令的意义发生变化：<code>CMD</code> 默认值变为空，并且<code>CMD</code> 将作为 <code>ENTRYPOINT</code> 的参数进行传递</strong>；这使得 <code>ENTRYPOINT</code> 实现了上述两个优点；分别举一个栗子🌰说明：</p>
<p><strong>①</strong> 假设有一个镜像是这么设计的：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>如果<strong>想向里面的 <code>curl</code> 命令添加参数</strong>，例如 <code>-i</code>，是做不到的；</p>
<p>（之后会介绍 <code>docker run [options] &lt;containerName&gt; [CMD]</code> 启动容器的命令，在”容器名“后面的参数是 <code>CMD</code>，会覆盖 <code>Dockerfile</code> 中的 <code>CMD</code> 指令）</p>
<p>但是如果这么写就不一样了：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>这样在 <code>docker run</code> 最后指定 <code>CMD</code> 时，这个参数会传递给 <code>ENTRYPOINT</code> 作为参数，完美解决这个传参问题；</p>
<p><strong>②</strong> 再假设我们在使用一个数据库镜像，可能需要以 <code>root</code> 身份完成一些数据库配置、初始化的工作，再根据需要<strong>切换用户以保证安全性</strong>；<strong>比如官方 <code>Redis</code> 镜像是这么做的</strong>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File: Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.4</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># root 身份建立用户组相关设置</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]        <span class="comment"># 容器启动后执行该脚本</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;redis-server&quot;</span> ]    <span class="comment"># 因为上文有 ENTRYPOINT，所以这里不是指容器的启动命令，</span></span></span><br><span class="line">                        <span class="comment"># 而是指传给 ENTRYPOINT 的默认参数是 &quot;redis-server&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    find . \! -user redis -<span class="built_in">exec</span> <span class="built_in">chown</span> redis <span class="string">&#x27;&#123;&#125;&#x27;</span> +</span><br><span class="line">    <span class="built_in">exec</span> gosu redis <span class="string">&quot;<span class="variable">$0</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个脚本指的就是根据 CMD 参数的内容来判断，如果是 redis-server 的话，</span></span><br><span class="line"><span class="comment"># 则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="ENV-指令：设置环境变量"><a href="#ENV-指令：设置环境变量" class="headerlink" title="ENV 指令：设置环境变量"></a><code>ENV</code> 指令：设置环境变量</h5><ul>
<li><p>语法：<code>ENV &lt;key&gt; &lt;value&gt;</code> 或 <code>ENV &lt;key1&gt;=&lt;value1&gt; [&lt;key2&gt;=&lt;value2&gt; ...]</code>（语法特殊，只有多个环境变量参数间不用加逗号），<strong>环境变量将停留在容器的全生命周期中</strong>；</p>
</li>
<li><p>它的作用：设置合适的环境变量可以让维护工作变得轻松，例如 <code>node</code> 官方镜像的 Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; grep <span class="string">&quot; node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt | <span class="built_in">sha256sum</span> -c - \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; tar -xJf <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> -C /usr/local --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">ln</span> -s /usr/local/bin/node /usr/local/bin/nodejs</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="ARG-指令：设置构建参数"><a href="#ARG-指令：设置构建参数" class="headerlink" title="ARG 指令：设置构建参数"></a><code>ARG</code> 指令：设置构建参数</h5><ul>
<li><p>语法与 <code>ENV</code> 相同，不过 <code>ARG</code> 只是<strong>构建镜像时临时存在的环境变量</strong>，并且<strong>只在 <code>FROM</code> 中生效</strong>，想要在其他语句中使用，必须重新指定，举几个栗子🌰：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 情况 1 ----------------------------</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span> <span class="comment"># 这步是无效输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 2 -----------------------------</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想在 FROM 之后使用，必须再次指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span> <span class="comment"># 这样才是有效输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 3（多阶段构建，后面说） -----------</span></span><br><span class="line"><span class="comment"># 这个变量在每个 FROM 中都生效（使用的场合必须要都是 FROM）</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 4（多阶段构建）-------------------</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span> <span class="comment"># 有效输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span> <span class="comment"># 有效输出</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="VOLUME-指令：定义匿名卷"><a href="#VOLUME-指令：定义匿名卷" class="headerlink" title="VOLUME 指令：定义匿名卷"></a><code>VOLUME</code> 指令：定义匿名卷</h5><ul>
<li><p>语法：<code>VOLUME &lt;inContainerPath&gt;</code> 或 <code>VOLUME &quot;&lt;inPath1&gt;&quot;, &quot;&lt;inPath2&gt;, ...&quot;</code>；</p>
</li>
<li><p>它的作用：在 <a href="#needVolume">之前</a> 提到过，容器运行时应该尽量保持容器存储层不发生写操作，所以数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中（后面 <strong>5.1</strong> 会介绍数据卷），而<strong>为了防止用户运行容器 <code>docker run</code> 忘记加 <code>-v</code> 参数（后面说）来指定目录挂载卷，可以在 <code>Dockerfile</code> 中写 <code>VOLUME</code> 匿名卷，相当于“没有指定目录名的默认卷”</strong>；</p>
<p>这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据；</p>
<blockquote>
<p>注意：匿名卷正因为匿名、没有指定在 <code>Host OS</code> 上的挂载目录，docker engine 会自动选择诸如： <code>/var/lib/docker/</code> 这样的一些位置存起来，在容器删除后也不会自动删除，得自己找，比较麻烦；</p>
<p><strong>所以尽量自己记得挂载数据卷，不要依赖匿名卷</strong>；</p>
</blockquote>
</li>
</ul>
<h5 id="EXPOSE-指令：声明端口"><a href="#EXPOSE-指令：声明端口" class="headerlink" title="EXPOSE 指令：声明端口"></a><code>EXPOSE</code> 指令：声明端口</h5><ul>
<li>语法：<code>EXPOSE &lt;port1&gt; [port2 ...]</code> （和 <code>ENV</code> 一样，多个参数没逗号）；</li>
<li>⚠ <strong>注意：是声明，而不是直接暴露</strong>，意味着在容器运行时<strong>并不会因为这个声明应用就会开启这个端口的服务</strong>；那它有什么用呢？</li>
<li>它的作用：① <strong>帮助镜像使用者理解</strong>这个镜像服务的守护端口，以方便自行配置映射；② 当使用 <code>docker run</code> 的 <code>-P(大写)</code> 参数（后面介绍，是将容器端口开放到 <code>Host OS</code> 的随机端口）时，默认使用 <code>EXPOSE</code> 声明的端口；</li>
<li><strong>辨析：<code>EXPOSE</code> 不能和 <code>docker run</code> 的 <code>-p(小写)</code> 参数</strong>（也是后面介绍）<strong>作用搞混，后者是真的会进行从宿主到容器的端口映射，而前者只是声明</strong>；</li>
</ul>
<h5 id="WORKDIR-指令：指定工作目录"><a href="#WORKDIR-指令：指定工作目录" class="headerlink" title="WORKDIR 指令：指定工作目录"></a><code>WORKDIR</code> 指令：指定工作目录</h5><ul>
<li><p>语法：<code>WORKDIR &lt;inContainerDir&gt;</code>（如果容器内该目录不存在，则<strong>会自动创建</strong>）；</p>
</li>
<li><p>它的作用：<strong>改变以后各层的工作目录位置</strong>，确保每一层的命令行默认位置都在该目录下；如果参数是<strong>相对路径</strong>，那么和<strong>之前的</strong>工作目录有关，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span>    <span class="comment"># 此时在容器内命令行中打印的应该是 /a/b/c/</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="USER-指令：指定当前用户"><a href="#USER-指令：指定当前用户" class="headerlink" title="USER 指令：指定当前用户"></a><code>USER</code> 指令：指定当前用户</h5><ul>
<li><p>语法：<code>USER &lt;userName&gt;[:userGroup]</code>；</p>
</li>
<li><p>它的作用：<strong>改变</strong>之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的<strong>身份</strong>（之前说过，docker 容器有一套完整独立的命名空间）；</p>
</li>
<li><p>和 <code>WORKDIR</code> 的异同比较：</p>
<ul>
<li>和 <code>WORKDIR</code> 的作用效果类似，都是<strong>改变环境状态并影响以后的层</strong>；</li>
<li>和 <code>WORKDIR</code> 不同的是，如果指定用户不存在，则无法切换——<strong>此指令不会自动创建用户</strong>；</li>
</ul>
</li>
<li><p>⚠ 如果要建立一个用户、用户组（大多数时候用 <code>RUN</code>），并且在 <code>RUN</code> 的中途想要切换用户（不添加中间层的情况，就没法使用 <code>USER</code>），请 <strong>一定不要</strong> 使用 <code>su</code> 和 <code>sudo</code>，因为通常在刚下载的原始镜像中都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错；</p>
<blockquote>
<p>尤其是这种情况：<strong>如果容器内的应用需要 “优雅停机”（接收信号量 <code>SIGABRT</code>）</strong>，那么一定需要这个应用的进程<strong>在容器内的 <code>PID</code> = 1</strong>；而运行 <code>su/sudo</code> 会先建立 <code>sudo</code> 进程，再建立后面的进程，不能保证容器应用的 <code>PID</code> = 1！</p>
</blockquote>
<p><strong>正确做法之一是下载并使用 <code>gosu</code></strong>，以 <code>redis</code> 镜像中用户设置和切换为例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户和用户组</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/gosu \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; gosu nobody <span class="literal">true</span></span></span><br><span class="line"><span class="comment"># 设置 CMD，并使用 gosu 换另外的用户传参（gosu 使用方法：gosu + user + cmd）</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>至于使用 <code>gosu</code> 而不是 <code>su/sudo</code> 的深层原因，我看有篇博客写的不错，如果感兴趣这方面的原理可以戳 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/gaoyuechen/p/14336078.html">这里🔗</a>；不过看懂英文的话，最好看 <code>gosu</code> 官方解释：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/tianon/gosu">github 传送门</a>；</p>
<p><strong>另一种正确方法比较方便，是使用 <code>chroot</code> 的 <code>--userspec</code> 参数</strong>：<code>chroot --userspec=&lt;userName&gt;</code>，可以完成相似效果；</p>
</li>
</ul>
<h5 id="HEALTHCHECK-指令：健壮性检查"><a href="#HEALTHCHECK-指令：健壮性检查" class="headerlink" title="HEALTHCHECK 指令：健壮性检查"></a><code>HEALTHCHECK</code> 指令：健壮性检查</h5><ul>
<li><p>语法：<code>HEALTHCHECK [OPTIONS] CMD &lt;HOST_COMMAND&gt;</code> 或 <code>HEALTHCHECK NONE</code>；</p>
<ul>
<li><strong><code>HEALTHCHECK</code> 和 <code>CMD</code>、<code>ENTRYPOINT</code> 一样，只可以出现一次，如果写了多个，只有最后一个生效</strong>；</li>
<li><code>[options]</code>：<code>--interval=&lt;带单位的数值&gt;</code>、<code>--timeout=&lt;...&gt;</code> 前面两个都默认 <code>30s</code>；<code>--retries=&lt;N&gt;</code> 默认 3 次，超过则认为不健康；</li>
<li><code>CMD &lt;...&gt;</code>：检查时由宿主机向容器内执行的指令，指令返回值代表本次检查是否成功：<code>0:成功, 1:失败, 2:放弃结果</code>；</li>
<li><code>NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令；</li>
</ul>
</li>
<li><p>它的作用：引用官方文档的话：</p>
<blockquote>
<p>在没有 <code>HEALTHCHECK</code> 指令前，Docker engine 只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入<strong>死锁</strong>状态，或者<strong>死循环</strong>状态，应用进程并不退出，但是该容器已经无法提供服务了。</p>
<p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而<strong>比较真实地反应</strong>容器实际状态。</p>
</blockquote>
</li>
<li><p>举个例子🌰：对于一个网络服务而言，如果需要检查 WEB 服务是否还有响应，那么可以这么写：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5s --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1        <span class="comment"># 使用 curl 来判断</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>健康检查的日志可以使用 <code>docker inspect --format &#39;&#123;&#123;json .State.Health&#125;&#125;&#39; &lt;containerName&gt;</code> 来查看（json 格式）；</p>
</li>
</ul>
<h5 id="ONBUILD-指令：多级构建准备"><a href="#ONBUILD-指令：多级构建准备" class="headerlink" title="ONBUILD 指令：多级构建准备"></a><code>ONBUILD</code> 指令：多级构建准备</h5><ul>
<li><p>语法：<code>ONBUILD &lt;所有其他指令&gt;</code>；</p>
</li>
<li><p>它的效果：它后面跟的是其它指令，而<strong>在当前镜像构建时并不会被执行</strong>。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行；</p>
</li>
<li><p>它的作用：<strong>提升镜像多级构建的重用性和扩展性</strong>；这句非常抽象，需要举例说明；首先说明<strong>什么是多级构建</strong>——利用已构建好的镜像为基础，构建下一级镜像（<strong>事实上所有镜像都是这么构建的，但多级构建更强调这几个镜像都是自己写出来的</strong>）</p>
<blockquote>
<p>以下的例子涉及 <code>node.js</code> 相关知识，只需了解 <code>node.js</code> 使用 <code>npm</code> 作为包管理器之一，相关包依赖和启动信息存在 <code>package.json</code> 中，可以类比成 <code>Python</code> 中的 <code>pip</code> 和 <code>requirements.txt</code>；部署项目时需要在根目录下执行 <code>npm install</code> 安装依赖，才能运行项目；</p>
</blockquote>
<p>🌰 假设我们在一个 <code>node.js</code> 项目中，目录情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|</span><br><span class="line">|--- Dockerfile</span><br><span class="line">|--- package.json</span><br><span class="line">|--- ...             # 其他项目文件</span><br></pre></td></tr></table></figure>
<p>因此 Dockerfile 应该这么写：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app                <span class="comment"># 创建并以 /app 为工作目录</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./package.json /app    <span class="comment"># 将当前上下文目录下的 package.json 文件复制到镜像中的 /app/ 下</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]    <span class="comment"># 执行 sh -c npm install 安装项目依赖</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app/                <span class="comment"># 将当前上下文目录中(即客户端中的项目根目录)所有文件复制到 /app/ 下</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]        <span class="comment"># 设置容器默认启动命令为 npm start</span></span></span><br></pre></td></tr></table></figure>
<p>很好。那如果还有一个项目，<strong>项目文件不一样，但依赖的包和它一模一样</strong>，如果想要定制为镜像，应该怎么办？你可能会说，简单！把 Dockerfile 直接复制过去不就行了？好，那如果还有 5 个、10个呢？<strong>直接复制 Dockerfile 一定不现实，会给版本控制造成极大阻碍</strong>（例如，如果你想把这些所有项目的镜像基础 <code>node:slim</code> 换成 <code>node:alpine</code>，那你得一个个改）；</p>
<p>聪明的人会想，这也好办，直接把<strong>和项目无关的部分提出来</strong>——这样公共部分只要修改一次就行（<strong>这就是多级构建的思想</strong>，注意和后面的 <strong>多阶段构建区分</strong>）：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公共镜像的 Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>假设这个生成的镜像名叫 <code>my-node</code>，那么某一个用到这个镜像的项目的 Dockerfile 可以这么写：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用到公共镜像的某个项目镜像的 Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> my-node</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br></pre></td></tr></table></figure>
<p>这么进行 “多级构建” 是没有问题的；但是，如果项目创建容器时，我想给<strong>每个项目的启动命令 <code>npm install</code> 都加个相同的参数呢</strong>？哦吼，完了，问题又回去了，是不是要一个个改呢……有些同学会说：那把 <code>RUN</code> 挪到公共镜像的 Dockerfile 中？不行。因为下面的 <code>COPY</code> 和 <code>RUN</code> 和项目有关，<strong>如果这样构建，某个项目的文件就进入公共镜像中，显然不符合重用的要求</strong>；</p>
<p>这个时候，应该用 <code>ONBUILD</code> 完成：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公共镜像的 Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>这样 <code>ONBUILD</code> 这几步在构建公共镜像时不会运行，而各个项目只需要写：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br></pre></td></tr></table></figure>
<p><strong>这一句话就行！</strong>是不是非常方便！</p>
</li>
</ul>
<h5 id="LABEL-指令：添加镜像元数据-metadata"><a href="#LABEL-指令：添加镜像元数据-metadata" class="headerlink" title="LABEL 指令：添加镜像元数据 metadata"></a><code>LABEL</code> 指令：添加镜像元数据 metadata</h5><ul>
<li><p>一般是用来申明镜像的作者、文档地址等：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.authors=<span class="string">&quot;XXX&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.documentation=<span class="string">&quot;https://XXX&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="SHELL-指令：指定命令行运行参数"><a href="#SHELL-指令：指定命令行运行参数" class="headerlink" title="SHELL 指令：指定命令行运行参数"></a><code>SHELL</code> 指令：指定命令行运行参数</h5><ul>
<li><p>语法：<code>SHELL [&quot;executable&quot;, &quot;params&quot;]</code></p>
</li>
<li><p>作用：用来指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell，Linux 中默认为 <code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-cex&quot;</span>]</span></span><br><span class="line"><span class="comment"># 命令转为 /bin/sh -cex &quot;nginx&quot;</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> nginx</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="很重要的网站"><a href="#很重要的网站" class="headerlink" title="很重要的网站"></a>很重要的网站</h5><ul>
<li><p><code>Docker</code> 官方镜像 <code>Dockerfile</code>：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/docker-library/docs">Dockerfile contents - github</a>；</p>
<p>在你不知道官方镜像的设计，或者想学习官方 Dockerfile 的用法时，这是极好的了解途径；</p>
</li>
</ul>
<h4 id="2-4-2-从容器快照定制"><a href="#2-4-2-从容器快照定制" class="headerlink" title="2.4.2 从容器快照定制"></a>2.4.2 从容器快照定制</h4><p><strong>见 3.4 容器的导入和导出</strong></p>
<h4 id="2-4-3-构建镜像"><a href="#2-4-3-构建镜像" class="headerlink" title="2.4.3 构建镜像"></a>2.4.3 构建镜像</h4><ul>
<li><p>语法：<code>docker build [options] &lt;contextPath&gt;</code></p>
</li>
<li><p><code>[options]</code> 中 <strong>最常用的是 <code>-t &lt;tagName&gt;</code>，给生成的镜像固定一个标签</strong>、<code>-f &lt;DockerfilePath&gt;</code> 指定 <code>Dockerfile</code>；</p>
</li>
<li><p><span id="contextPath"><code>&lt;contextPath&gt;</code> 指<strong>上下文路径</strong>，想要理解它，就需要理解部分 <code>docker build</code> 的工作原理</span>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="docker-on-linux.png" height="300"></p>
<ul>
<li><p>Docker <strong>采用 C/S 架构设计</strong>，在运行时分为 Docker Engine（也就是服务端守护进程 <code>containerd</code>）和客户端工具（图片最上面的 4 个）；</p>
</li>
<li><p>Docker 的引擎提供了一组 REST API，被称为 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.docker.com/develop/sdk/">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能；<strong>这种 C/S 分离式的设计，使得操作远程服务器的 docker engine 和本地一样轻松</strong>；</p>
</li>
<li><p>所以什么是上下文路径（contextPath）？</p>
<ol>
<li><p>构建镜像时，构建操作一定是在服务器端进行（C/S 架构），因此服务端会请求将 <strong><code>Dockerfile</code> 所在目录（这不是 contextPath，因为默认不用 <code>-f DockerfileName</code> 指定的，引擎默认是上下文目录下的 <code>Dockerfile</code>）下的</strong>所有文件打包，并从客户端传递给 <code>Docker Engine</code>；</p>
<blockquote>
<p>正因如此，① 应该将 <code>Dockerfile</code> 置于一个<strong>空目录</strong>下，或者<strong>项目根目录</strong>下；</p>
<p>② 如果该目录下没有所需文件，那么应该把所需文件<strong>复制一份过来</strong>；</p>
<p>③ 如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <strong><code>.dockerignore</code></strong>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的；</p>
</blockquote>
</li>
<li><p><strong>真正的 contextPath 是</strong>：<code>docker build</code> 指定<strong>要压缩给服务器的目录</strong>，<strong>并且从此以后，<code>Dockerfile</code> 中的所有的相对路径（如 <code>COPY</code> 等命令，也强烈建议是相对路径）的 “<code>.</code>” 都代表 <code>docker build</code> 中指定的上下文目录</strong>；</p>
</li>
</ol>
</li>
<li><p>举个两个栗子🌰🌰帮助理解上面内容：</p>
<ol>
<li><p>假设有一个项目结构是这样的，想要添加到 <code>nginx</code> 镜像中合成新的镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|</span><br><span class="line">|--- Dockerfile</span><br><span class="line">|--- .dockerignore</span><br><span class="line">|</span><br><span class="line">|--- index.html</span><br><span class="line">|--- webConfig        # nginx 配置文件</span><br></pre></td></tr></table></figure>
<p>由于 <code>Dockerfile</code> 恰在项目根目录下，因此可以这么写（这里只是演示什么是上下文目录，不建议这么做，建议使用<strong>数据卷或挂载主机目录</strong>）：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./index.html /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./webConfig /etc/nginx/site-avaliable/webConfig</span></span><br></pre></td></tr></table></figure>
<p>那么指令应该这么写：<code>docker build -t my_nginx:v1 .</code></p>
<p>这里：</p>
<p>① 无需指定 <code>Dockerfile</code>，是因为上下文目录恰好指定的是当前目录，该目录下又恰好有 <code>Dockerfile</code>，因此不用指定；</p>
<p>② <code>Dockerfile</code> 中 <code>COPY</code> 语句中的 “源目录(第一参数)” 中的 “<code>.</code>” 指的是 <strong>contextPath</strong>，也是在服务器端解压后的 “<code>.</code>”，<strong>而非客户端的“当前目录”</strong>；</p>
</li>
<li><p>再假设有一个项目结构是这样的，想以 <code>src/</code> 为整个项目打包进容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|</span><br><span class="line">|--- Dockerfile</span><br><span class="line">|--- .dockerignore</span><br><span class="line">|</span><br><span class="line">|--- src/</span><br><span class="line">        |--- index.html</span><br><span class="line">        |--- webConfig		# nginx 配置文件</span><br></pre></td></tr></table></figure>
<p>那么如果 <code>Dockerfile</code> 这么写：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./index.html /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./webConfig /etc/nginx/site-avaliable/webConfig</span></span><br></pre></td></tr></table></figure>
<p>则指令应该这么写：<code>docker build -f ./Dockerfile -t my_nginx:v1 ./src/</code></p>
<p>这里：</p>
<p>① <strong>指定了上下文路径是 <code>src/</code>，意味着只会给 docker engine 压缩打包这个目录，仅此而已</strong>；</p>
<p>② 在这个上下文目录（<code>src/</code>）中，没有 <code>Dockerfile</code>，因此需要指定 <code>Dockerfile</code> 在客户端的位置； <code>-f</code> 参数指定 <code>Dockerfile</code>，<strong>这个路径和 contextPath 无关，真的是客户端的路径</strong>；</p>
<p>③ 在 <code>Dockerfile</code> 中，<code>COPY</code> 的源路径（第一参数）中的 “<code>.</code>” 可以理解为的是在服务器端<strong>刚解压后的当前路径</strong>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. &lt;--- 它就是上下文路径在 Dockerfile 中表示的含义</span><br><span class="line">|</span><br><span class="line">|--- index.html</span><br><span class="line">|--- webConfig</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-4-多阶段构建"><a href="#2-4-4-多阶段构建" class="headerlink" title="2.4.4 多阶段构建"></a>2.4.4 多阶段构建</h4><ul>
<li><p><strong>多阶段构建和多级构建的对比：后者的目的是为了提升重用性，多写了几个镜像并依赖构建；前者是因为原本的镜像过于庞大，要拆解镜像层次，人为降低镜像的体积</strong>；前者一次只会一次构建出一个镜像，后者强调分步构建好几个镜像；</p>
</li>
<li><p>使用方法：<strong>就是一个 Dockerfile 文件中写好几个 <code>FROM</code></strong>，引入 <code>as</code> 关键字，使得外部可以通过 <code>docker build</code> 的 <code>--target</code> 参数<strong>指定构建的阶段</strong>；并且多阶段之间的镜像<strong>可以相互复制文件</strong>！</p>
<p>举个例子🌰：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest as prod</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是使用上一阶段(--from=0) “builder” 镜像的文件</span></span><br><span class="line"><span class="comment"># 0 是“上一个”的简写，还可以 --from=builder</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /go/src/github.com/go/helloworld/app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>也可以只构建 <code>builder</code>：<code>docker build --target builder -t XXX:XX .</code></p>
</li>
<li><p>⚠ <strong>当需要的容器服务过于多的时候，写 <code>Dockerfile</code> 变得很繁琐（例如一个镜像中同时需要 python、nginx、redis 服务等），建议使用 <code>docker compose</code>（见 Chapter 7）</strong>；</p>
</li>
</ul>
<h2 id="Chapter-3-操作容器"><a href="#Chapter-3-操作容器" class="headerlink" title="Chapter 3. 操作容器"></a>Chapter 3. 操作容器</h2><h3 id="3-1-创建和启动容器"><a href="#3-1-创建和启动容器" class="headerlink" title="3.1 创建和启动容器"></a>3.1 创建和启动容器</h3><h4 id="3-1-1-新建容器并启动"><a href="#3-1-1-新建容器并启动" class="headerlink" title="3.1.1 新建容器并启动"></a>3.1.1 新建容器并启动</h4><ul>
<li><p>语法：<code>docker run [options] &lt;IMAGE_NAME or ID&gt; [CMD]</code>；</p>
<ul>
<li><p><code>[options]</code>：① <code>-i</code> 启动容器内 bash 并绑定于 stdin 允许交互；</p>
<p>② <code>-t</code> 分配伪终端（显示命令提示符，<strong>常和 <code>-i</code> 联用将容器 I/O 绑定在当前 TTY 上：<code>-it</code></strong>）；</p>
<blockquote>
<p>如果使用 <code>-i</code> 参数，<code>[CMD]</code> 为必须项，且一般填写 <code>/bin/bash</code> 或 sh；</p>
</blockquote>
<p>③ <code>-d</code> 拒绝和当前终端连接（detach，在启动容器后不与当前 TTY 关联，与 <code>-it</code> 互斥，此时 <strong>stdout 的内容可以使用 <code>docker container logs</code> 查看</strong>）；</p>
<p>④ <code>-p &lt;host_port:container_port&gt;</code> 将容器指定端口映射到主机指定端口；</p>
<p>⑤ <code>-P</code> 将容器端口开放到 <code>Host OS</code> 的随机端口；</p>
<p>⑥ <code>-v &lt;host_dir:container_dir&gt;</code> 将主机指定目录作为<strong>数据卷</strong>挂载到容器指定目录上，<strong>不会覆盖</strong> Dockerfile 中的 <code>VOLUME</code> 指令。因为如果有 <code>VOLUME</code> 指令，那么在构建镜像时匿名卷已被创建；（<strong>详细见 Chapter 5</strong>）</p>
<p>⑦ <code>--name &lt;containerName&gt;</code> 为容器命名，<strong>在容器互联、集群时非常重要</strong>；</p>
<p>⑧ <code>--network</code> 参数见 <strong>6.2 容器互联</strong>；</p>
</li>
<li><p><code>[CMD]</code>：<strong>会覆盖 Dockerfile 中的 <code>CMD</code> 指令</strong>；</p>
</li>
</ul>
</li>
<li><p>运行该命令后 docker engine 在干什么：</p>
<ol>
<li>检查本地是否存在指定的镜像，不存在就从 Docker Registory 下载；</li>
<li>利用镜像创建并启动一个容器；</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层；</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去；</li>
<li>从地址池配置一个 ip 地址给容器；</li>
<li>执行用户指定的应用程序；</li>
<li>执行完毕后容器被终止；</li>
</ol>
</li>
</ul>
<h4 id="3-1-2-启动已终止的容器"><a href="#3-1-2-启动已终止的容器" class="headerlink" title="3.1.2 启动已终止的容器"></a>3.1.2 启动已终止的容器</h4><p>就一句：<code>docker container start &lt;ID&gt;</code>（如果容器没有exit，应该用 <code>restart</code>）；</p>
<h3 id="3-2-终止容器"><a href="#3-2-终止容器" class="headerlink" title="3.2 终止容器"></a>3.2 终止容器</h3><p>也就一句：<code>docker container stop &lt;ID&gt;</code>；</p>
<p>此外，查看所有<strong>正在运行的</strong>容器：<code>docker container ls</code>；</p>
<p>⚠ <strong>处于终止状态的容器需要在后面加 <code>-a</code> 参数：<code>docker container ls -a</code></strong>；</p>
<h3 id="3-3-进入容器"><a href="#3-3-进入容器" class="headerlink" title="3.3 进入容器"></a>3.3 进入容器</h3><p>本质上就是在容器中创建一个 bash 程序，并把 I/O 绑定到当前 TTY 上。总共两种方法：</p>
<ul>
<li><code>docker attach &lt;ID&gt;</code>，不建议使用，因为执行 <code>exit</code> 退出这个 bash 后，会给整个容器发送 SIGABRT 信号，导致终止；</li>
<li><code>docker exec -it &lt;ID&gt; bash</code>：使用 <code>exit</code> 退出 bash 不影响原来容器；显然 <code>docker exec</code> 不止可以进入容器，还能干其他事（把 <code>-it</code> 去掉，最后一个参数换成要运行的命令等等，详细内容请参阅官方文档，或者运行 <code>docker exec --help</code>）；</li>
</ul>
<h3 id="3-4-导入和导出"><a href="#3-4-导入和导出" class="headerlink" title="3.4 导入和导出"></a>3.4 导入和导出</h3><ul>
<li><p>将容器保存为快照（<strong>这会丢弃容器的元数据</strong>）：<code>docker export &lt;ID&gt; &gt; compressFile.tar</code>；</p>
</li>
<li><p>将<strong>容器快照展开为镜像</strong>（这是镜像的另一种创建方式：<strong>从容器创建</strong>）：<code>cat compressFile.tar | docker import - &lt;REPO_NAME&gt;</code></p>
<blockquote>
<p>复习一下，<code>REPO_NAME</code> = <code>userName/IMAGE_NAME:tag</code>；</p>
</blockquote>
<p>除了管道流方法以外，还可以从指定地址展开镜像：<code>docker import http://example.com/exampleimage.tgz example/imagerepo</code>；</p>
</li>
</ul>
<h3 id="3-5-删除容器"><a href="#3-5-删除容器" class="headerlink" title="3.5 删除容器"></a>3.5 删除容器</h3><ul>
<li><p>删除<strong>处于终止状态的</strong>容器：<code>docker container rm &lt;ID&gt;</code>；</p>
<ul>
<li>如果需要删除任何状态的容器（包括正在运行的），则需添加 <code>-f</code> 参数，这会给正在运行的容器先发送 <code>SIGKILL</code> 信号；</li>
<li>如果实在需要在停止容器的同时删除挂载的数据卷：添加 <code>-v</code> 参数；</li>
</ul>
</li>
<li><p>清除<strong>所有</strong>处于终止状态的容器：<code>docker container prune</code> </p>
<blockquote>
<p>复习一下：清除所有虚悬镜像：<code>docker image prune</code></p>
</blockquote>
</li>
</ul>
<h2 id="Chapter-4-访问仓库"><a href="#Chapter-4-访问仓库" class="headerlink" title="Chapter 4. 访问仓库"></a>Chapter 4. 访问仓库</h2><h3 id="4-1-Docker-Hub"><a href="#4-1-Docker-Hub" class="headerlink" title="4.1 Docker Hub"></a>4.1 Docker Hub</h3><ul>
<li><p>登录/登出 docker 账户：<code>docker login/logout</code>；</p>
</li>
<li><p>查找相关镜像：<code>docker search [--filter=starts=N] &lt;...&gt;</code>（里面示例筛选器是筛选 N 星以上的镜像）；</p>
</li>
<li><p>推送镜像到自己账户的公共仓库中（需登录）：<code>docker push &lt;userName/IMGAE_NAME:tag&gt;</code>；</p>
<blockquote>
<p>提示：<strong>目前自动构建（Automated build）仅支持付费用户</strong>，没钱没用过，不讨论；</p>
</blockquote>
</li>
</ul>
<h3 id="4-2-私有仓库管理"><a href="#4-2-私有仓库管理" class="headerlink" title="4.2 私有仓库管理"></a>4.2 私有仓库管理</h3><p><code>docker-registry</code> 相关命令，平时没啥人用，不作介绍；</p>
<h2 id="Chapter-5-数据管理"><a href="#Chapter-5-数据管理" class="headerlink" title="Chapter 5. 数据管理"></a>Chapter 5. 数据管理</h2><h3 id="5-1-数据卷"><a href="#5-1-数据卷" class="headerlink" title="5.1 数据卷"></a>5.1 数据卷</h3><p>在之前已经无数次接触到数据卷的概念，现在详细说明数据卷的概念和使用；</p>
<ul>
<li><p>概念和特征：是一个可供一个或多个容器使用的特殊目录，<strong>可以理解为 Linux 下对目录或文件进行 <code>mount</code></strong>；</p>
<ul>
<li><p>数据卷可以<strong>在容器之间共享和重用</strong>；</p>
</li>
<li><p>对数据卷的修改会立马生效；但对数据卷的更新，不会影响镜像（挂载的特征）；</p>
</li>
<li><p>数据卷默认会一直存在，即使容器被删除（<strong>没有自动回收机制，独立于容器，需要手动删除</strong>）</p>
<blockquote>
<p>数据无价，谨慎删除；</p>
</blockquote>
</li>
<li><p><strong>匿名卷也是一个数据卷</strong>；</p>
</li>
</ul>
</li>
<li><p>管理数据卷：docker 支持在没有启动容器时，手动对数据卷进行管理；</p>
<ul>
<li><p>查看所有数据卷：<code>docker volume ls</code>；</p>
</li>
<li><p>查看特定数据卷详细信息：<code>docker volume inspect &lt;volumeName&gt;</code>；</p>
</li>
<li><p>创建数据卷：<code>docker volume create &lt;volumeName&gt;</code>；</p>
<blockquote>
<p>和匿名卷一样，默认挂载于 <code>/var/lib/docker/containers/</code> 中；</p>
</blockquote>
</li>
<li><p>启动一个挂载指定数据卷的容器：3.1.1 介绍过，<code>-v</code> 参数，<strong>等价于：<code>--mount source=&lt;volumeName&gt;,target=&lt;containerPath&gt;</code></strong>；</p>
</li>
<li><p>手动删除数据卷：<code>docker volume rm &lt;volumeName&gt;</code>；</p>
</li>
<li><p>清理<strong>没有被当前容器使用的</strong>数据卷：<code>docker volume prune</code>；</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-2-挂载主机目录"><a href="#5-2-挂载主机目录" class="headerlink" title="5.2 挂载主机目录"></a>5.2 挂载主机目录</h3><ul>
<li><p>和数据卷比较：挂载主机目录和挂载数据卷极其类似，不过前者是自定义位置，后者默认和匿名卷都放在一起；</p>
</li>
<li><p>使用：<code>docker run</code> 的 <code>-v</code> 参数，<strong>如果 Host OS 中没有指定目录，会自动创建</strong>；</p>
<p>或者：<code>docker run</code> 的 <code>--mount type=bind,source=&lt;dir&gt;,target=&lt;cDir&gt;</code> ，如果本地目录不存在，则报错；</p>
<p><strong>也可以仅赋予只读权限：<code>--mount type=bind,source=&lt;dir&gt;,target=&lt;cDir&gt;,readonly</code></strong>；</p>
</li>
<li><p><strong>甚至可以只挂载一个主机文件</strong>；</p>
</li>
</ul>
<h2 id="Chapter-6-网络配置"><a href="#Chapter-6-网络配置" class="headerlink" title="Chapter 6. 网络配置"></a>Chapter 6. 网络配置</h2><h3 id="6-1-外部访问"><a href="#6-1-外部访问" class="headerlink" title="6.1 外部访问"></a>6.1 外部访问</h3><p>绝大部分内容已在 3.1.1 启动容器时介绍，这里仅介绍一些高级用法；</p>
<ul>
<li><p><code>-p</code> 参数可以多次使用来绑定多个端口：<code>docker run -d -p 80:80 -p 443:443 nginx:alpine</code></p>
</li>
<li><p><code>-P</code> 参数的 “随机” 是针对 Host OS 的端口随机分配，一般会按照 Dockerfile 中的 <code>EXPOSE</code> 分配指定的容器内部端口；</p>
<blockquote>
<p>等价于在 <code>docker run</code> 中加入参数：<code>-p 127.0.0.1::&lt;EXPOSE_port&gt;</code></p>
</blockquote>
</li>
</ul>
<h3 id="6-2-容器互联"><a href="#6-2-容器互联" class="headerlink" title="6.2 容器互联"></a>6.2 容器互联</h3><p>以前会使用<code>docker run</code> 的 <code>--link</code> 参数，进行点对点的连接；但随着结点数的增大，这么做不容于配置；正确做法是<strong>自行配置容器间的网络</strong>；</p>
<ul>
<li><p>新建容器网络：<code>docker network create -d bridge &lt;netName&gt;</code></p>
<blockquote>
<p><code>-d</code> 参数指定网络类型，参数值有 <code>bridge</code>（网桥） 和 <code>overlay</code>，前者用的多，后者需要配合 <code>swarm mode</code> 配置集群，暂时不介绍；</p>
</blockquote>
</li>
<li><p>运行容器同时将容器连接到网络：<code>docker run</code> 的 <code>--network &lt;netName&gt;</code> </p>
<blockquote>
<p>注意：如果要容器连接网络，强烈建议自己为<strong>容器命名</strong>：<code>--name</code> 参数，因为容器间交互识别就靠容器名——<strong>在一个容器中可以访问同网络的另一个容器：<code>ping &lt;containerName&gt;</code></strong>；</p>
</blockquote>
</li>
</ul>
<p><strong>其实更方便的做法是：使用 <code>Docker compose</code>（Chapter 7）</strong>；</p>
<h3 id="6-3-DNS-配置"><a href="#6-3-DNS-配置" class="headerlink" title="6.3 DNS 配置"></a>6.3 DNS 配置</h3><p>这个操作在特殊场合有用（因为一般默认容器中的 DNS 设置就够用了），比如某些同学想用 <code>Grasscutter</code> 建立 Ys 私服的时候，包装成 Docker 镜像时就需要将一系列网络代理到本机上——如果使用 DNS 劫持的方法就需要在容器内配置 DNS；</p>
<p>最方便的方法是构建镜像时自己写一个 <code>HOST</code> 文件在放到<code>/etc/hosts</code>；</p>
<p>当然，也可以通过 <code>docker run</code> 的 <code>-h HOSTNAME</code> 写入 <code>/etc/hosts</code> 和 <code>/etc/hostname</code> ，还可以通过 <code>docker run</code> 的 <code>--dns=IP_ADDR</code> 写入 DNS 服务器地址（在 <code>/etc/resolv.conf</code>）；</p>
<p>还可以通过修改主机 <code>/etc/docker/daemon.json</code> 来<strong>同时修改所有容器的 DNS 服务器</strong>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Chapter-7-Docker-Compose"><a href="#Chapter-7-Docker-Compose" class="headerlink" title="Chapter 7. Docker Compose"></a>Chapter 7. Docker Compose</h2><h3 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h3><ul>
<li><p>地位：由 <code>Python</code> 编写的 Docker 官方的开源项目；</p>
</li>
<li><p>定位：定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）；</p>
</li>
<li><p>作用：允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project），<strong>很方便地实现容器运行设置、互联</strong>；</p>
</li>
<li><p><strong>两个重要概念</strong>：服务和项目</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例；</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义；</li>
</ul>
<blockquote>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理；</p>
</blockquote>
</li>
<li><p>和 docker 普通用法的比较【重要】：docker compose <strong>不在于构建镜像</strong>，而在于<strong>直接一条龙拉取已有镜像/按 <code>Dockerfile</code> 构建自定义镜像（前面章节的内容），并按配置运行<u>一组</u>容器</strong>；</p>
</li>
<li><p><strong>举例认识</strong>🌰：假设有一个项目，使用 <code>Python</code> 建立一个记录页面访问次数的 Web 服务，使用 <code>Flask</code> 框架、<code>redis</code> 服务器；</p>
<blockquote>
<p>（本部分无需看懂，只需要感受 <code>docker compose</code> 使用便捷就行）</p>
<p><strong>如果使用 docker 原来的方法，编写 <code>Dockerfile</code> 来构建容器，那么需要作很多事</strong>：从一个 Python 镜像中开始构建、安装 flask、安装 redis、复制项目文件、删除安装的 apt 缓存和安装包等文件，运行 <code>docker run</code> 还要加各种参数，例如挂载、端口、网络互联……</p>
<p>但如果使用 <code>docker compose</code> 就不一样了：</p>
</blockquote>
<p>编写模板文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File: docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span>        <span class="comment"># 容器内的所有服务</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span>            <span class="comment"># web 服务</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span>    <span class="comment"># 镜像构建方法是当前页面的自定义镜像：./Dockerfile</span></span><br><span class="line">    <span class="attr">ports:</span>        <span class="comment"># 运行该 web 服务的容器时，进行端口映射，相当于 docker run 的 -p</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span>        <span class="comment"># redis 服务</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span>    <span class="comment"># 镜像构建方法是直接从 redis:alpine 拉取</span></span><br></pre></td></tr></table></figure>
<p>编写 web 服务的镜像构建 Dockerfile（python + flask + 项目文件）：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install redis flask</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>最后直接运行：<code>docker compose up -d</code> ，结束！</p>
</li>
</ul>
<h3 id="7-2-安装"><a href="#7-2-安装" class="headerlink" title="7.2 安装"></a>7.2 安装</h3><blockquote>
<p>需要已经安装 Docker 及其服务；</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_CONFIG=/usr/local/lib/docker/cli-plugins</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p <span class="variable">$DOCKER_CONFIG</span>/cli-plugins</span><br><span class="line"><span class="comment"># 国内加速：</span></span><br><span class="line"><span class="comment"># sudo curl -SL https://download.fastgit.org/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose</span></span><br><span class="line">sudo curl -SL https://github.com/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 -o <span class="variable">$DOCKER_CONFIG</span>/cli-plugins/docker-compose</span><br><span class="line">sudo <span class="built_in">chmod</span> +x <span class="variable">$DOCKER_CONFIG</span>/cli-plugins</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure>
<h3 id="7-3-compose-命令"><a href="#7-3-compose-命令" class="headerlink" title="7.3 compose 命令"></a>7.3 compose 命令</h3><blockquote>
<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响；</p>
</blockquote>
<p>语法：<code>docker compose [options] [compose-command]</code>；</p>
<h4 id="options-参数"><a href="#options-参数" class="headerlink" title="[options] 参数"></a>[options] 参数</h4><ul>
<li><code>-f template</code> 指定 docker compose 模板，默认 <code>docker-compose.yml</code>；</li>
<li><code>-p Name</code> 指定项目名称；</li>
<li><code>--verbose</code> 运行时调试信息更详细；</li>
</ul>
<h4 id="compose-command-命令"><a href="#compose-command-命令" class="headerlink" title="[compose-command] 命令"></a>[compose-command] 命令</h4><h5 id="构建-amp-运行命令"><a href="#构建-amp-运行命令" class="headerlink" title="构建&amp;运行命令"></a>构建&amp;运行命令</h5><ul>
<li><p><code>pull</code>：拉取模板中的基础镜像；</p>
</li>
<li><p><code>build [options]</code>：按模板构建项目中的所有镜像并组合为容器；</p>
<ul>
<li><code>--force-rm</code>：删除构建过程中产生的临时镜像；</li>
<li><code>--no-cache</code>： 不使用缓存构建；</li>
</ul>
</li>
<li><code>start [serviceName]</code>：启动<strong>已存在的指定服务容器</strong>；</li>
<li><code>restart [-t TIMEOUT]</code>：重启项目中的服务；<ul>
<li><code>-t TIMEOUT</code>：重启前停止容器；</li>
</ul>
</li>
<li><code>run [options] &lt;serviceName&gt; [CMD]</code>：手动<strong>按 <code>docker run</code> 一样的参数</strong>启动指定容器，用的少，因为不如在 <code>docker-compose</code> 里设置并且 <code>up</code>  启动；</li>
<li><strong><code>up [options]</code>：强大的命令，可以一次性实现上述所有命令（构建镜像、（重新）创建服务、启动服务，并关联服务相关容器）</strong>；<ul>
<li><code>-d</code>（detach）：后台运行；</li>
<li>其他选项和上面的前 4 条命令一样；</li>
</ul>
</li>
</ul>
<h5 id="停止-amp-管理命令"><a href="#停止-amp-管理命令" class="headerlink" title="停止&amp;管理命令"></a>停止&amp;管理命令</h5><ul>
<li><code>down</code>：停止 <code>up</code> 所启动的容器，同时移除网络；</li>
<li><code>stop [serviceName]</code>：仅停止指定服务容器，不删除任何东西，可以通过 <code>start</code> 再启动；</li>
<li><code>kill [-s SIGNAL] [serviceName]</code>：通过 <code>-s</code> 传递终止信号结束服务容器 ；</li>
<li><code>pause/unpause [serviceName]</code>：暂停指定服务容器 / 恢复被暂停的服务容器；</li>
<li><code>rm [options] [serviceName]</code>：删除所有处于停止状态的服务容器，options 参数和 docker 一样；</li>
<li><code>exec [options]</code>：进入指定容器，参数和 docker 一样；</li>
</ul>
<h5 id="维护命令"><a href="#维护命令" class="headerlink" title="维护命令"></a>维护命令</h5><ul>
<li><code>images</code>：列出模板中所含的所有镜像；</li>
<li><code>ps</code>：列出项目中<strong>当前所有容器</strong>；</li>
<li><code>top</code>：查看<strong>各服务容器里运行的进程</strong>（这样就不用在容器里装 <code>procps</code> 包了）；</li>
<li><code>logs [serviceName]</code>：查看某个服务容器的 stdout 输出，对调试有用；</li>
<li><code>version</code>：版本信息；</li>
<li><code>help</code>：帮助；</li>
</ul>
<h3 id="7-4-docker-compose-模板"><a href="#7-4-docker-compose-模板" class="headerlink" title="7.4 docker-compose 模板"></a>7.4 docker-compose 模板</h3><p>和 7.1 里说的一样，<code>docker-compose.yml</code> 同时完成指定构建什么镜像（自己不会设计镜像）和 <code>docker run</code> 的工作，所有<strong>可以将下面的选项和前几章的指令一一对照</strong>； </p>
<p>下面直接在文件中说明：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span>    <span class="comment"># 指定一个版本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span>        <span class="comment"># 必不可缺的部分，是容器运行的核心——服务</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">webApp:</span>		<span class="comment"># 服务名，可以自己取，代表容器的其中一个服务。</span></span><br><span class="line">                <span class="comment"># 注意，每个服务都可以指定一个构建镜像</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&lt;XX/XX&gt;</span>	<span class="comment"># image 和 build 选项二选一（必选，因为容器必须要从镜像开始）</span></span><br><span class="line">        <span class="attr">build:</span> <span class="string">&lt;dir&gt;</span>	<span class="comment"># image 指这个容器从已存在的镜像构建，值是 REPO_NAME</span></span><br><span class="line">                        <span class="comment"># build 指这个容器将自行构建镜像，值是上下文目录（必须包含 Dockerfile）</span></span><br><span class="line">        <span class="attr">build:</span>			<span class="comment"># 但如果上下文目录和 Dockerfile 不在一起，请详细指定，如左</span></span><br><span class="line">            <span class="attr">context:</span> <span class="string">&lt;dir&gt;</span></span><br><span class="line">            <span class="attr">dockerfile:</span> <span class="string">&lt;path&gt;</span></span><br><span class="line">            <span class="attr">args:</span></span><br><span class="line">                <span class="comment"># 这里相当于 docker build 的参数，不过不能缩写，没有“--”</span></span><br><span class="line">                </span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">&lt;name&gt;</span>	<span class="comment"># 谨慎使用，会降低模板文件的扩展性，因为容器名唯一</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">command:</span> <span class="string">&lt;CMD&gt;</span>	<span class="comment"># 这里覆盖 Dockerfile 里的 CMD 指令 或者是默认的 CMD 指令</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">devices:</span>		<span class="comment"># 这里在 Dockerfile 中没讲过，可以映射硬件设备</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;/dev/&lt;host_device&gt;:/dev/&lt;container_device&gt;&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">depends_on:</span>		<span class="comment"># 这里可以解决依赖问题，会先启动依赖服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;serviceName&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">dns:</span>			<span class="comment"># DNS 服务器，对应 docker run 的 --dns 参数</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;IP_ADDR&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">tmpfs:</span>			<span class="comment"># 对应 Dockerfile 中的 VOLUME 指令</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;dir&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">env_file:</span>		<span class="comment"># 对应 Dockerfile 的 ENV 指令</span></span><br><span class="line">                        <span class="comment"># 通过文件载入环境变量，环境变量文件规范如下：</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;ENV_file&gt;</span>	<span class="comment"># 以 “#” 作行注释、后缀名 *.env</span></span><br><span class="line">                            <span class="comment"># 内容 “key=value” 顶格、中间不能有空格</span></span><br><span class="line">                            <span class="comment"># 有表达特殊含义的 value 必须用引号引起，特殊词包括：</span></span><br><span class="line">                            <span class="comment">#  y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</span></span><br><span class="line">        <span class="attr">environment:</span>	<span class="comment"># 环境变量少可以这么用，多的话建议用上面的 env_file</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">key=value</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">expose:</span>			<span class="comment"># 对应 Dockerfile 的 EXPOSE 指令</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;&lt;port&gt;&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">ports:</span>			<span class="comment"># 对应 docker run 的 -p 参数</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;&lt;host_port&gt;:&lt;container_port&gt;&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">extra_hosts:</span>	<span class="comment"># 对应 docker run 的 -h 参数，可以进行 DNS 劫持</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;domain:IP&quot;</span>	<span class="comment"># 会在 /etc/hosts 文件中添加：&quot;IP domain&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">healthcheck:</span>	<span class="comment"># 对应 Dockerfile 的 HEALTHCHECK 指令</span></span><br><span class="line">            <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;&lt;COMMAND&gt;&quot;</span>]</span><br><span class="line">            <span class="attr">interval:</span> <span class="string">&lt;time&gt;</span></span><br><span class="line">            <span class="attr">timeout:</span> <span class="string">&lt;time&gt;</span></span><br><span class="line">            <span class="attr">retries:</span> <span class="string">N</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">labels:</span>			<span class="comment"># 对应 Dockerfile 的 LABEL 指令</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">value</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">user:</span> <span class="string">&lt;name&gt;</span>	<span class="comment"># 对应 Dockerfile 的 USER 指令</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">working_dir:</span> <span class="string">&lt;dir&gt;</span>	<span class="comment"># 对应 Dockerfile 的 WORKDIR 指令</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">entrypoint:</span> <span class="string">&lt;COMMAND&gt;</span> <span class="comment"># 对应 Dockerfile 的 ENTRYPOINT 指令</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">restart:</span> <span class="string">&lt;options&gt;</span>	<span class="comment"># 指定容器退出后的重启策略</span></span><br><span class="line">                            <span class="comment"># 相当有用的选项，对保持服务始终运行十分有效</span></span><br><span class="line">                            <span class="comment"># 在生产环境中推荐配置为 always 或者 unless-stopped</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">logging:</span>    <span class="comment"># 设置容器输出日志</span></span><br><span class="line">            <span class="attr">driver:</span> <span class="string">&lt;&quot;json-file&quot;/&quot;syslog&quot;/&quot;none&quot;&gt;</span>	<span class="comment"># 写成 json 还是和系统一致</span></span><br><span class="line">            <span class="attr">options:</span>	<span class="comment"># 日志轮替选项</span></span><br><span class="line">                <span class="attr">max-size:</span> <span class="string">&quot;Nk&quot;</span> <span class="comment"># 或 &quot;Nm&quot;</span></span><br><span class="line">                <span class="attr">max-file:</span> <span class="string">N</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 如此还可以写下一个服务……</span></span><br></pre></td></tr></table></figure>
<p>还有<strong>两个重要选项 和 一个重要的行为</strong>需要单独拎出来说：</p>
<p><strong>① <code>volumes</code> 挂载选项</strong>：对应 Dockerfile 的 <code>VOLUME</code> 指令，用法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="string">&lt;serviceName&gt;:</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;host_dir&gt;:&lt;container_dir&gt;</span>	<span class="comment"># 对应 docker run 本机目录挂载（可选）</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;volumName&gt;:&lt;container_dir&gt;</span>	<span class="comment"># 对应 docker run 数据卷挂载（可选）</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 如果上面使用了数据卷名（volumnName），那么需要声明创建一个数据卷：</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">    <span class="string">&lt;volumeName&gt;:</span>	<span class="comment"># 和匿名卷放在一个位置，不用给它值</span></span><br></pre></td></tr></table></figure>
<p><strong>② <code>networks</code> 网络选项</strong>：对应 docker run 的 <code>--network</code> 参数，用法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="string">&lt;serviceName&gt;:</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">networks:</span>	<span class="comment"># 容器加入某个指定网络，可以同时加入多个网络</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;netName&gt;</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 上面使用了 networks 就必须指定网络名称</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="string">&lt;netName1&gt;:</span>						<span class="comment"># 如果名字是 default，设置默认网络，一般不用设置</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">&lt;bridge/overlays&gt;</span>	<span class="comment"># 对应 docker network create 的 -d 参数</span></span><br><span class="line">        </span><br><span class="line">    <span class="string">&lt;netName2&gt;:</span></span><br><span class="line">        <span class="attr">external:</span>	<span class="comment"># 如果不希望 docker compose 创建网络，想自己 docker network create，那么引入外部设置网络需要 external 选项</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">&lt;external_netName&gt;</span></span><br></pre></td></tr></table></figure>
<p>⚠ <strong>重要行为：<code>docker-compose.yml</code> 读取环境变量</strong></p>
<p>如果在模板文件中使用 <code>$&#123;XXX&#125;</code> 的变量，模板会先搜索<strong>系统环境变量</strong>，再搜索<strong>之前设置的 <code>env_files/environment</code> 选项</strong>；</p>
<hr>
<p>docker 入门基础篇完【EOF】</p>
<p>预计将会跟进 docker 底层实现分析、<code>Kubernetes</code> 集群 等内容；</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SSRVodka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/technical/docker-basic/">https://blog.sjtuxhw.top/technical/docker-basic/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SSRVodka's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/Container/">Container</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/docker.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/technical/fiddler-everywhere/" title="Fiddler Everywhere的crack实践"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/fiddler-crack.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Fiddler Everywhere的crack实践</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW 本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！ 本文如有侵权，请联系作者删除   众所周知，Fiddler 是一个无比好用的、免费的网络调试代理工具，可以方便地进行抓包、代理服务等基本操作。最近在看到一些文章介绍 Fiddler 的使用时无意间发现 Fiddler everywhere 的软件，UI 制作更加用心，而且功能更加强大，可惜的是会订阅收费。在受到 Github@msojocs（好像停更了）的指引下，我开始了对 Fiddler-Everywhere 软件的 “学习”。  声明：本文不含有实际的观点导向 或者 建议，如有侵权，请联系删除； 在尽情使用的同时，欢迎大家订阅官网正版的 Fiddler everywhere；  工作环境准备要进行 crack 实践，必然得从反编译入手； 首先了解到 Fiddler Everywhere 是使用 C# 编写的程序，所以事先必须准备关于 C# 的运行环境 和 反编译程序； Windows 自带 .net 运行库不够用，需要下载...</div></div></div></a><a class="pagination-related" href="/technical/sql-basic-1/" title="SQL学习笔记-第一部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/sql-1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SQL学习笔记-第一部分</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW 本部分文章是 SQL 的基础部分，纪念我丢掉的 SQL 笔记 😭 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ Reference: 《 SQL 必知必会 (第 5 版 ) 》  使用前须知本系列文章的 “章末习题” 使用的数据库和表的关系如下图所示；  这里提供创建表和数据的 SQL 文本（以 MySQL 为例）：generate.sql，可以在搭建好 MySQL 环境后直接导入它，以备后面章末习题使用； Chapter 0 数据库的基本概念 数据库（从 SQL 角度看）：以某种有组织的方式存储的数据集合；  关系型数据库 &amp; 非关系型数据库  关系型数据库：采用关系模型、遵循关系代数模式来组织数据的数据库（例如 MySQL、PostgreSQL等）；关系模型类似二维表，允许表间数据相互关联，支持多表查询； 非关系型数据库（No SQL）：不依赖关系模型的、分布式的数据库（例如 MongoDB、Redis 等）；以键值来存储，结构不稳定，每个元组的字段可以不相同，可以面向高并发key-value读写 /...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/sc.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</div></div><div class="info-2"><div class="info-item-1">这是一篇 2025 年的关于软硬协同的安全容器设计的文章。 0. Overview虚拟机级别的容器中，每个容器运行在虚拟机虚拟出的独立内核上，因此隔离性很强。但其依赖于通用虚拟机虚拟出的虚拟化硬件，与 OS 级别的容器相比，会导致不可忽略的性能开销。而在嵌套虚拟化场景下，secure container 运行在虚拟机中，这个性能的 gap 会显著地扩大。 本篇文章基于两个角度提出容器内核隔离（CKI），一个软硬协调的高效机密容器设计。  首先，Protection Keys for Supervisor（PKS）可以帮助我们构建一个新的权限级别，用于在 Host Kernel 中安全地配置多个容器内核，而不涉及 non-root ring 0（Intel 中的 Guest Kernel 所处级别）； 其次，secure container 使用的通用虚拟化技术提供很多容器实际隔离并不需要的特性，例如二阶段页表翻译，这引入了可以避免的性能开销；  因此容器内核隔离技术在跑容器内核时：  避免使用虚拟化硬件，并移除不必要的虚拟化技术（像二阶段地址翻译）。它使用 PKS...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="xhw-card-content"><div class="xhw-avatar-group"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="xhw-sticker"><img class="sticker-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/smile.avif" alt="emoji-sticker"/></div></div></div><div class="author-info-name">SSRVodka</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span><a class="service-status-badge" id="serviceStatusBadge" href="https://status.sjtuxhw.top" rel="external nofollow noreferrer" target="_blank"><span class="status-loading"></span><span class="status-text">loading...</span></a></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-0-Docker-%E5%AE%89%E8%A3%85"><span class="toc-text">Chapter 0. Docker 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mac-%E5%AE%89%E8%A3%85"><span class="toc-text">Mac 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E4%BB%BB%E4%BD%95-distribution-%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85"><span class="toc-text">Linux 任何 distribution 自动安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ubuntu-%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85"><span class="toc-text">Ubuntu 手动安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">Chapter 1. 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%85%B7%E4%BD%93%E5%8E%9F%E7%90%86%E3%80%81%E5%9C%B0%E4%BD%8D%E5%92%8C%E6%80%A7%E8%B4%A8"><span class="toc-text">1.1 具体原理、地位和性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Docker-%E5%92%8C-%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">1.2 Docker 和 传统虚拟化技术的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%95%9C%E5%83%8F"><span class="toc-text">1.3 镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%AE%B9%E5%99%A8"><span class="toc-text">1.4 容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E4%BB%93%E5%BA%93"><span class="toc-text">1.5 仓库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-2-%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F"><span class="toc-text">Chapter 2. 使用镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%95%9C%E5%83%8F%E8%8E%B7%E5%8F%96"><span class="toc-text">2.1 镜像获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%88%97%E5%87%BA%E9%95%9C%E5%83%8F"><span class="toc-text">2.2 列出镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-text">2.3 删除镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%95%9C%E5%83%8F%E5%AE%9A%E5%88%B6%E5%92%8C%E6%9E%84%E5%BB%BA"><span class="toc-text">2.4 镜像定制和构建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-Dockerfile-%E5%AE%9A%E5%88%B6"><span class="toc-text">2.4.1 Dockerfile 定制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FROM-%E6%8C%87%E4%BB%A4%EF%BC%9A%E6%8C%87%E5%AE%9A%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F"><span class="toc-text">FROM 指令：指定基础镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RUN-%E6%8C%87%E4%BB%A4%EF%BC%9A%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-text">RUN 指令：执行命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#COPY-%E6%8C%87%E4%BB%A4%EF%BC%9A%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">COPY 指令：复制文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ADD-%E6%8C%87%E4%BB%A4%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%8E%8B%E5%B9%B6%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">ADD 指令：自动解压并复制文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CMD-%E6%8C%87%E4%BB%A4%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">CMD 指令：设置容器启动命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ENTRYPOINT-%E6%8C%87%E4%BB%A4%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="toc-text">ENTRYPOINT 指令：设置容器入口点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ENV-%E6%8C%87%E4%BB%A4%EF%BC%9A%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">ENV 指令：设置环境变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ARG-%E6%8C%87%E4%BB%A4%EF%BC%9A%E8%AE%BE%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%8F%82%E6%95%B0"><span class="toc-text">ARG 指令：设置构建参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VOLUME-%E6%8C%87%E4%BB%A4%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%8C%BF%E5%90%8D%E5%8D%B7"><span class="toc-text">VOLUME 指令：定义匿名卷</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EXPOSE-%E6%8C%87%E4%BB%A4%EF%BC%9A%E5%A3%B0%E6%98%8E%E7%AB%AF%E5%8F%A3"><span class="toc-text">EXPOSE 指令：声明端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WORKDIR-%E6%8C%87%E4%BB%A4%EF%BC%9A%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-text">WORKDIR 指令：指定工作目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#USER-%E6%8C%87%E4%BB%A4%EF%BC%9A%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7"><span class="toc-text">USER 指令：指定当前用户</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HEALTHCHECK-%E6%8C%87%E4%BB%A4%EF%BC%9A%E5%81%A5%E5%A3%AE%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-text">HEALTHCHECK 指令：健壮性检查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ONBUILD-%E6%8C%87%E4%BB%A4%EF%BC%9A%E5%A4%9A%E7%BA%A7%E6%9E%84%E5%BB%BA%E5%87%86%E5%A4%87"><span class="toc-text">ONBUILD 指令：多级构建准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LABEL-%E6%8C%87%E4%BB%A4%EF%BC%9A%E6%B7%BB%E5%8A%A0%E9%95%9C%E5%83%8F%E5%85%83%E6%95%B0%E6%8D%AE-metadata"><span class="toc-text">LABEL 指令：添加镜像元数据 metadata</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SHELL-%E6%8C%87%E4%BB%A4%EF%BC%9A%E6%8C%87%E5%AE%9A%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-text">SHELL 指令：指定命令行运行参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%88%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%AB%99"><span class="toc-text">很重要的网站</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E4%BB%8E%E5%AE%B9%E5%99%A8%E5%BF%AB%E7%85%A7%E5%AE%9A%E5%88%B6"><span class="toc-text">2.4.2 从容器快照定制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-text">2.4.3 构建镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA"><span class="toc-text">2.4.4 多阶段构建</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8"><span class="toc-text">Chapter 3. 操作容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-text">3.1 创建和启动容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E6%96%B0%E5%BB%BA%E5%AE%B9%E5%99%A8%E5%B9%B6%E5%90%AF%E5%8A%A8"><span class="toc-text">3.1.1 新建容器并启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E5%90%AF%E5%8A%A8%E5%B7%B2%E7%BB%88%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">3.1.2 启动已终止的容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-text">3.2 终止容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-text">3.3 进入容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA"><span class="toc-text">3.4 导入和导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-text">3.5 删除容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-4-%E8%AE%BF%E9%97%AE%E4%BB%93%E5%BA%93"><span class="toc-text">Chapter 4. 访问仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Docker-Hub"><span class="toc-text">4.1 Docker Hub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86"><span class="toc-text">4.2 私有仓库管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-5-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-text">Chapter 5. 数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">5.1 数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95"><span class="toc-text">5.2 挂载主机目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-6-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-text">Chapter 6. 网络配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE"><span class="toc-text">6.1 外部访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94"><span class="toc-text">6.2 容器互联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-DNS-%E9%85%8D%E7%BD%AE"><span class="toc-text">6.3 DNS 配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-7-Docker-Compose"><span class="toc-text">Chapter 7. Docker Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">7.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%AE%89%E8%A3%85"><span class="toc-text">7.2 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-compose-%E5%91%BD%E4%BB%A4"><span class="toc-text">7.3 compose 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#options-%E5%8F%82%E6%95%B0"><span class="toc-text">[options] 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compose-command-%E5%91%BD%E4%BB%A4"><span class="toc-text">[compose-command] 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-amp-%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-text">构建&amp;运行命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2-amp-%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-text">停止&amp;管理命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%91%BD%E4%BB%A4"><span class="toc-text">维护命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-docker-compose-%E6%A8%A1%E6%9D%BF"><span class="toc-text">7.4 docker-compose 模板</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/2025-ccf/" title="CCF 2025 会议笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ccf-2025.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CCF 2025 会议笔记"/></a><div class="content"><a class="title" href="/technical/2025-ccf/" title="CCF 2025 会议笔记">CCF 2025 会议笔记</a><time datetime="2025-08-03T03:36:45.000Z" title="发表于 2025-08-03 11:36:45">2025-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/transformer.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Transformer 论文精读 + 代码实现"/></a><div class="content"><a class="title" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现">Transformer 论文精读 + 代码实现</a><time datetime="2025-07-20T15:15:10.000Z" title="发表于 2025-07-20 23:15:10">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/sc.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"/></a><div class="content"><a class="title" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</a><time datetime="2025-07-01T10:14:11.000Z" title="发表于 2025-07-01 18:14:11">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ml-roadmap.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识图谱：Machine Learning Roadmap"/></a><div class="content"><a class="title" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap">知识图谱：Machine Learning Roadmap</a><time datetime="2025-06-08T06:59:31.000Z" title="发表于 2025-06-08 14:59:31">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"/></a><div class="content"><a class="title" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</a><time datetime="2025-05-30T08:49:12.000Z" title="发表于 2025-05-30 16:49:12">2025-05-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SSRVodka  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-image"><a class="rightMenu-item" href="javascript:rmf.copyImageUrl();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制图片地址</span></a><a class="rightMenu-item" href="javascript:rmf.downloadImage();" rel="external nofollow noreferrer"><i class="fa-solid fa-download"></i><span>保存图片</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-link"><a class="rightMenu-item" href="javascript:rmf.copyLink();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制链接地址</span></a><a class="rightMenu-item" href="javascript:rmf.openLinkNewTab();" rel="external nofollow noreferrer"><i class="fa-solid fa-external-link-alt"></i><span>在新标签页打开</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script src="/js/status_badge.js"></script><script defer src="/js/console_welcome.js"></script><script async data-pjax src="/js/bsz.build-20250729.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>