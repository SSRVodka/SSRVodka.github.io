<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>阅读: A Hardware-Software Co-Design for Efficient Secure Containers | SSRVodka's blog</title><meta name="author" content="SSRVodka,xhwpro@gmail.com"><meta name="copyright" content="SSRVodka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这是一篇 2025 年的关于软硬协同的安全容器设计的文章。 0. Overview虚拟机级别的容器中，每个容器运行在虚拟机虚拟出的独立内核上，因此隔离性很强。但其依赖于通用虚拟机虚拟出的虚拟化硬件，与 OS 级别的容器相比，会导致不可忽略的性能开销。而在嵌套虚拟化场景下，secure container 运行在虚拟机中，这个性能的 gap 会显著地扩大。 本篇文章基于两个角度提出容器内核隔离（CK">
<meta property="og:type" content="article">
<meta property="og:title" content="阅读: A Hardware-Software Co-Design for Efficient Secure Containers">
<meta property="og:url" content="https://blog.sjtuxhw.top/technical/sc-paper/index.html">
<meta property="og:site_name" content="SSRVodka&#39;s blog">
<meta property="og:description" content="这是一篇 2025 年的关于软硬协同的安全容器设计的文章。 0. Overview虚拟机级别的容器中，每个容器运行在虚拟机虚拟出的独立内核上，因此隔离性很强。但其依赖于通用虚拟机虚拟出的虚拟化硬件，与 OS 级别的容器相比，会导致不可忽略的性能开销。而在嵌套虚拟化场景下，secure container 运行在虚拟机中，这个性能的 gap 会显著地扩大。 本篇文章基于两个角度提出容器内核隔离（CK">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/sc.webp">
<meta property="article:published_time" content="2025-07-01T10:14:11.000Z">
<meta property="article:modified_time" content="2025-07-27T11:01:09.454Z">
<meta property="article:author" content="SSRVodka">
<meta property="article:tag" content="Container">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="Paper">
<meta property="article:tag" content="VM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/sc.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/technical/sc-paper/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/css/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '阅读: A Hardware-Software Co-Design for Efficient Secure Containers',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SSRVodka's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">78</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/sc.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SSRVodka's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-01T10:14:11.000Z" title="发表于 2025-07-01 18:14:11">2025-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-27T11:01:09.454Z" title="更新于 2025-07-27 19:01:09">2025-07-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/technical/sc-paper/#post-comment"><span class="waline-comment-count" data-path="/technical/sc-paper/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>这是一篇 2025 年的关于软硬协同的安全容器设计的文章。</p>
<h2 id="0-Overview"><a href="#0-Overview" class="headerlink" title="0. Overview"></a>0. Overview</h2><p>虚拟机级别的容器中，每个容器运行在虚拟机虚拟出的独立内核上，因此隔离性很强。但其依赖于通用虚拟机虚拟出的虚拟化硬件，与 OS 级别的容器相比，会导致不可忽略的性能开销。而在嵌套虚拟化场景下，secure container 运行在虚拟机中，这个性能的 gap 会显著地扩大。</p>
<p>本篇文章基于两个角度提出容器内核隔离（CKI），一个软硬协调的高效机密容器设计。</p>
<ul>
<li>首先，Protection Keys for Supervisor（PKS）可以帮助我们构建一个新的权限级别，用于在 Host Kernel 中安全地配置多个容器内核，而不涉及 non-root ring 0（Intel 中的 Guest Kernel 所处级别）；</li>
<li>其次，secure container 使用的通用虚拟化技术提供很多容器实际隔离并不需要的特性，例如二阶段页表翻译，这引入了可以避免的性能开销；</li>
</ul>
<p>因此容器内核隔离技术在跑容器内核时：</p>
<ol>
<li>避免使用虚拟化硬件，并移除不必要的虚拟化技术（像二阶段地址翻译）。它使用 PKS 来构建一个新特权级，用来隔离不同的容器内核，并且提供了跨特权级更高效的交互方式；</li>
<li>给每个容器内核使用了 single-stage address translation，并且用轻量级的方式监听这些页表，来确保跨容器虚拟内存隔离；</li>
</ol>
<p>实机实验证明了 CKI 技术的高效性，结果显示对于内存密集型应用相对于硬件辅助虚拟化 hardware-assisted virtualization (HVM) 和基于软件虚拟化 software-based virtualization (PVM) 技术分别提升了 72% 和 47%；</p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>由于容器具有可移植性和可扩展性等优势，因此被广泛应用于云中构建和部署应用程序。有两种典型的容器架构：</p>
<ul>
<li><p>OS 级别容器。由于互不信任的容器之间共享操作系统内核中的漏洞，操作系统级容器因<strong><u>安全性差</u></strong>而饱受诟病。恶意的操作系统级容器可能会利用系统调用接口暴露的巨大攻击面来<strong><u>逃避隔离</u></strong>；</p>
</li>
<li><p>VM 级别容器。相比之下，虚拟机级容器在自己的客户操作系统内核上运行每个容器，具有<strong><u>更强的安全隔离性</u></strong>，在云计算中越来越受欢迎。<strong><u>破坏客户内核对主机内核或其他容器无害</u></strong>。</p>
<p>尽管进行了许多优化，但与操作系统级容器相比，虚拟机级容器仍显示出<strong><u>性能上的劣势</u></strong>，这是因为涉及到为通用虚拟机设计的虚拟化硬件。例如，遍历 walk 过 two-stage page table 可将内存密集型应用的延迟平均增加 46%；</p>
</li>
</ul>
<p>此外，性能差距随着嵌套虚拟化的增加而增大。据谷歌和阿里巴巴等知名云提供商称，基于公共基础设施即服务（IaaS）的云构建服务 (building cloud services) 的需求日益增长。在这种<strong><u>嵌套云</u></strong>中，虚拟机级容器必须在虚拟机内运行，由于 L2 VM（容器）、guest hypervisor（L1 内核）和 host hypervisor（L0 内核）之间的<strong><u>上下文切换过多</u></strong>，导致运行时开销很大。根据我们的评估，这种开销使内存密集型和 I/O 密集型应用的性能分别降低了 28%∼226% 和 1.8×∼4.3× 。</p>
<p>我们认为，性能开销源于 <strong><u>secure container 架构所需的权限级别与 CPU 硬件所提供的权限级别之间的不匹配</u></strong>。具体来说，主机内核需要隔离多个容器访客内核，而每个访客内核又需要隔离多个容器应用进程。因此，需要三个权限级别。然而，CPU 硬件通常为运行操作系统内核和应用程序提供两种权限级别，例如 x86 ring-0/ring-3 和 Arm EL1/EL0。因此，现有的安全容器（如 Kata Containers 和 Firecracker）利用硬件虚拟化扩展来获得额外的权限级别，从而导致性能开销。</p>
<p>一些 secure container 架构，如 PVM 和 gVisor，不需要虚拟化硬件。它们将容器 guest kernel 授权为用户模式，并将 guest kernel 和 container app 隔离在不同的地址空间中。不过，<strong><u>这些架构会产生更多上下文切换开销，因为容器内的系统调用和异常一定会 redirect 给 host kernel</u></strong>。例如，空系统调用在操作系统级容器中需要 90 ns 的时间，而在 PVM 容器中则需要 336 ns。</p>
<p>在本文中，我们基于两个观点提出了一种新的安全容器设计，称为 CKI（容器内核隔离）：</p>
<ol>
<li>首先，最近的 CPU 功能（Protection Keys for Supervisor，PKS 或 MPK）可以改造为在 kernel mode 中创建另一个特权级别，以容纳 guest（容器）kernel。这一新的权限级别允许客户内核有效地为其容器应用服务，从而带来性能上的优势，例如将裸机云和嵌套云中的上下文切换最小化；</li>
<li>其次，为每个容器分离内核是为了安全隔离，而不是通用虚拟化。具体来说，内存虚拟化中使用的两阶段地址转换机制为任何客户内核提供了透明的物理地址空间，确保了兼容性，但这与容器隔离要求无关。因此，支持任意虚拟机的虚拟化机制是不必要的（例如二阶段地址翻译可以被移除，以此提升性能）。</li>
</ol>
<p>但在创建新的权限级别时，CKI 面临着三个挑战。我们逐个应对：</p>
<ol>
<li><p>首先，PKS 仅用于内存隔离，而恶意 guest kernel 在 kernel mode 下执行时，可能会执行任意特权指令。为了解决这个问题，我们提出了针对 PKS 的<strong><u>轻量级硬件扩展，以实现指令隔离</u></strong>；</p>
</li>
<li><p>其次，CKI 中 PKS switch gates 的<strong><u>安全目标</u></strong>，即防止容器逃逸或主机拒绝服务（host DoS），<strong><u>需要在基本 MPK 门之外进行额外设计</u></strong>。例如，switch gates 需要新的机制来定位每 vCPU 区域，防止中断垄断或伪造；</p>
</li>
<li><p>PKS 在一个内核地址空间内只支持 16 个内存域，而一台机器可能承载数十到数百个安全容器。为了支持任意数量的容器，CKI <strong><u>结合了 PKS 和地址空间隔离技术，以隔离不同的客户内核</u></strong>。</p>
<p>具体来说，它为每个 guest kernel 创建了一个单独的地址空间，并在每个地址空间中映射一个内核安全监控器（KSM, kernel security monitor），然后使用 PKS 将 KSM 与 guest kernel 隔离。PKS 隔离会剥夺 guest kernel 的权限，使其只能通过 KSM 或 host kernel 提供的接口执行特权操作。KSM 实现的特权操作只能访问一个安全容器的私有数据（如页表更新），这些操作可通过快速 PKS 开关门调用。</p>
<p>我们只会在 KSM 中映射这些私有数据，这样 PKS gate 在切换时就不需要进行侧信道保护（PTI, IBRS, …），这能节省上百个时钟周期；</p>
</li>
</ol>
<p>最后，我们实现了 CKI 的原型，并利用真实世界的容器应用对其进行了评估。我们在裸机云（bare-metal）和嵌套云中对 CKI 进行了评估，并将其与硬件辅助虚拟化（HVM）和基于软件的虚拟化（PVM）进行了比较。在裸机云中，与 HVM/PVM 相比，CKI 可将内存密集型应用的延迟时间最多减少 18%/47%。在嵌套云中，与 HVM/PVM 相比，CKI 最多可将内存密集型应用的延迟降低 72%/47%，并且与 HVM/PVM 相比，I/O 密集型应用最多可获得 6.8 倍/1.2 倍的吞吐量。</p>
<p>总之，本文做出了以下贡献：</p>
<ul>
<li><p>全面探索了安全容器的设计空间，揭示了 CPU 权限级别与容器内核分离需求之间的不匹配；</p>
</li>
<li><p>一种名为 CKI 的新型安全容器设计，通过引入软硬件共同设计的权限级别实现了高效的内核分离；</p>
</li>
<li><p>一个系统原型，其在实际应用中的实验结果证明了它的有效性。</p>
</li>
</ul>
<h2 id="2-背景和动机"><a href="#2-背景和动机" class="headerlink" title="2. 背景和动机"></a>2. 背景和动机</h2><h3 id="2-1-Secure-Container-Models"><a href="#2-1-Secure-Container-Models" class="headerlink" title="2.1 Secure Container Models"></a>2.1 Secure Container Models</h3><p><strong><u>操作系统级容器</u></strong>通过在多个容器之间共享单个操作系统内核来实现轻量级隔离。然而，操作系统级隔离机制很薄弱，因为在 Linux 等商品级操作系统内核中发现了许多漏洞。复杂的 syscall interface 向 userspace 暴露了巨大的攻击面，容器可利用这些攻击面进行权限升级、信息泄漏或拒绝服务（DoS）。</p>
<p>而 secure container 通过限制 OS kernel 被 compromised 的影响来加强容器隔离。这可以通过两种容器架构来实现： <strong><u>虚拟机级容器和基于 enclave 的容器</u></strong>，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="esc/scm.png" width="550px" /></p>
<ul>
<li>虚拟机级容器。虚拟机级容器在单独的 guest kernel 上运行每个容器。它们要求用户应用程序、guest kernel 和 host kernel 具有三级权限。容器内的恶意应用程序可利用内核漏洞入侵其 guest kernel ，但这对 host kernel 或其他容器无害。guest kernel 与 host kernel 之间的接口可能比系统调用接口简单得多，因此恶意 guest kernel 很难入侵 host kernel。</li>
<li>基于 enclave 的容器。和 OS 级容器一样，基于 enclave 的容器在共享的 kernel 上运行所有容器。但是 Secure Monitor（BlackBox，有一个运行在 Root Kernel 中的监控器，类似虚拟机监控器）或基于硬件的可信执行环境（TEE），都会剥夺共享内核任意访问<u>受保护容器的内存数据或执行上下文</u>的权限。</li>
</ul>
<p>不过，如果考虑了 CVE 之后，虚拟机级容器就是首选方案了。在收集近两年（2022-2023 年）可在容器中利用的 Linux 内核 CVE，并按安全影响对其进行分类（共 209 个）后发现，这些 CVE，97.3% 可导致 DoS 攻击，包括破坏系统状态（如越界写入、use-after-free）、导致不可恢复的错误（如空指针延迟、kernel panic）或独占硬件资源（如内存泄漏、死锁）。虽然 enclave-based 的容器可以保护容器数据的机密性和完整性，但由于内核共享设计，它们<strong><u>无法抵御 DoS 攻击</u></strong>。相反，虚拟机级容器由于采用了内核分离设计，可以防止 DoS。</p>
<h3 id="2-2-Secure-Containers-in-Nested-Clouds"><a href="#2-2-Secure-Containers-in-Nested-Clouds" class="headerlink" title="2.2 Secure Containers in Nested Clouds"></a>2.2 Secure Containers in Nested Clouds</h3><p>根据先前的研究，在基础设施即服务（IaaS）云租用的虚拟机中构建容器平台的需求日益增长。在这些嵌套云中，VM 级容器部署在另一个虚拟机内。例如，阿里巴巴云正在将 secure containers 从 bare-metal 实例转移到通用（虚拟化）实例，以实现更高的隔离度、节约成本以及更灵活、更有弹性的 Kubernetes 集群管理。谷歌的 gVisor 通常会考虑虚拟机内部署，并设计相应的优化措施。</p>
<p>在 IaaS 虚拟机内运行安全容器需要嵌套虚拟化，其中一个 L0 内核（host hypervisor）运行一个带有 L1 内核（guest hypervisor）的虚拟机，然后隔离多个安全容器（L2 虚拟机，guest hypervisor 上的 VM），每个容器都有自己的 L2 内核。内存密集型和 I/O 密集型容器应用都可以在嵌套虚拟化下部署。<strong><u>我们的目标是减轻这些应用的嵌套虚拟化开销</u></strong>。</p>
<h3 id="2-3-Memory-Protection-Keys"><a href="#2-3-Memory-Protection-Keys" class="headerlink" title="2.3 Memory Protection Keys"></a>2.3 Memory Protection Keys</h3><p>Memory Protection Keys，内存保护密钥（MPK）是 x86 CPU 上用于内存隔离的新硬件功能。MPK 将虚拟地址空间中的页面最多分为 16 个域，并利用页表项 (PTE) 中以前未使用的四个位来表示每个页面的 domain ID。它还引入了一个 32 位 per-core protection key register，用于配置每个域的访问权限。权限可设置为只读、读写或不可访问。</p>
<p>MPK 有两种变体： Protection Keys for Userspace（PKU）控制用户页面的权限，而 Protection Key for Supervisor（PKS）控制内核页面的权限。PKU 和 PKS 的 protection key register 分别称为 PKRU 和 PKRS。PKRU 可以使用名为 <code>wrpkru</code>（write PKRU）的高效指令进行配置，而 PKRS 则可以使用 <code>wrmsr</code>（write MSR）指令进行配置。</p>
<h3 id="2-4-Issues-of-VM-Level-Containers"><a href="#2-4-Issues-of-VM-Level-Containers" class="headerlink" title="2.4 Issues of VM-Level Containers"></a>2.4 Issues of VM-Level Containers</h3><p>虚拟机级容器需要三个权限级别，而 CPU 硬件只为内核和应用程序提供两个权限级别。虚拟机级容器的一个问题是缺少第三个 CPU 权限级别来有效地适应客户（容器）内核。具体来说，下图展示了现有的虚拟机级容器设计，表格则显示了这些设计的比较。现有设计存在的问题归纳如下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="esc/vmc-issue-design.png" /></p>
<ul>
<li>硬件辅助虚拟化（HVM）通过专用的虚拟机控制结构（VMCS）和 EPT 隔离了 guest kernel，导致 EPT 转换和管理造成内存性能不理想，以及虚拟机退出缓慢造成嵌套云中 I/O 性能不佳；</li>
<li>基于软件的虚拟化（PVM）将 guest kernel 剥夺为用户模式，并使用影子分页隔离容器内存，导致在处理系统调用时出现额外的上下文切换，以及页表更新效率低下；</li>
<li>基于 LibOS 的容器打破了应用程序与客户内核之间的隔离，降低了安全保证并导致兼容性问题。</li>
</ul>
<h4 id="2-4-1-HVM-的问题"><a href="#2-4-1-HVM-的问题" class="headerlink" title="2.4.1. HVM 的问题"></a>2.4.1. HVM 的问题</h4><p>The container design with HVM faces <strong><u>both performance and compatibility issues</u></strong>.</p>
<ul>
<li><p><strong><u>EPT 的开销</u></strong>。</p>
<ul>
<li><p>在裸机云中，HVM 处理一次 EPT fault 需要 3µs 的时间，与操作系统级容器相比，这可能会使内存密集型应用的延迟增加 2%∼21%。HVM 还会因 two-staged page table walk 导致昂贵的 TLB miss 处理，内存密集型应用的平均超限率为 46%。</p>
</li>
<li><p>在嵌套云中，由于没有硬件支持三级地址转换，L1 内核依赖 L0 内核为每个 L2 虚拟机维护一个影子 EPT（SPTE），从而导致 EPT 管理的高开销。</p>
<blockquote>
<p>这不就丢失了一部分半虚拟化的优势了吗？</p>
</blockquote>
</li>
<li><p>在嵌套云中，HVM 容器中的页面故障需要 32µs 以上的时间。与操作系统级容器（图 4 中的 HVM-NST / RunC-BM）相比，这使内存密集型应用的延迟增加了 28%∼226%。</p>
</li>
</ul>
</li>
<li><p><strong><u>虚拟机退出重定向的开销</u></strong>。</p>
<ul>
<li><p>在嵌套云中运行 HVM 容器时，L1 内核和 L2 VM 使用不同的 VMCS 执行，导致 L0 对 VM 退出进行干预。具体来说，当 L2 虚拟机发生 VM Exit 时，会触发一个 trap 到 L0 内核，然后 L0 内核恢复 L1 内核来处理 L2 虚拟机退出。L1 内核处理完虚拟机退出后，再次向 L0 内核发出陷阱，然后 L0 内核恢复 L2 虚拟机。</p>
<p>在裸机云中，HVM 容器中的空的 hyper-call 只需 1.1us，而在嵌套云中则需要 6.7us。与消除了 L0 干涉的 PVM 相比，这种虚拟机退出开销将 I/O 密集型应用的吞吐量降低了 1.8×∼4.3× 倍；</p>
</li>
</ul>
</li>
<li><p>兼容性问题。HVM 在嵌套云中也面临兼容性问题。首先，一些 IaaS 云禁用硬件辅助嵌套虚拟化，以减少 L0 内核的攻击面。其次，新兴的 Confidential VM（CVM）不支持硬件辅助嵌套虚拟化，因为 L0 内核不受信任；</p>
</li>
</ul>
<h4 id="2-4-2-PVM-的问题"><a href="#2-4-2-PVM-的问题" class="headerlink" title="2.4.2. PVM 的问题"></a>2.4.2. PVM 的问题</h4><p>PVM 利用半虚拟化技术实现 VM 级容器。它以用户和内核模式分别运行容器应用程序和 host kernel。它还在单独的地址空间内以 user mode 运行 guest（容器）kernel。PVM 通过避免虚拟机退出到 L0 内核，<u>在嵌套云中获得了比硬件辅助虚拟化（HVM）更好的性能</u>。</p>
<ul>
<li><p><strong><u>系统调用重定向的开销</u></strong>。当应用程序调用系统调用时，它 trap 给 host kernel。然后，host kernel 会切换到 guest kernel 的 page table、返回用户态、调用 guest kernel 的 syscall handler。当处理结束后，会以一个相反的路径返回用户态应用程序。</p>
<p>与本地系统调用相比，该系统调用过程增加了两个 CPU 模式开关和两个页表开关。这将系统调用延迟从 90ns 增加到 336ns；</p>
<p>与裸机云中的 HVM 相比，I/O 密集型应用的平均开销为 6.6%。</p>
</li>
<li><p><strong><u>shadow paging 的开销</u></strong>。PVM 通过使用影子分页机制，保留了两阶段地址转换的灵活性：GVA -&gt; GPA -&gt; HPA。Host 为每个容器应用维护一个 SPT（将 GVA 转换为 HPA）。一个容器 page fault 涉及 host kernel 和 guest 之间至少 6 次上下文切换。两次切换用于将 page fault 重定向到 guest kernel，两次用于更新 shadow page table（SPT 由 host 维护 read-only），另外两次用于返回用户应用。</p>
<p>此外，页面故障处理过程中的仿真逻辑也会产生很高的开销，例如 page table walking（<strong><u>需要确认在哪个翻译阶段</u></strong>）、指令仿真、影子页表管理和异常注入。PVM 容器中的页面故障需要 7µs 的时间，而本地页面故障只需要 1µs 的时间。与操作系统级容器（PVM-BM / RunC-BM）相比，影子分页的开销使内存密集型应用的延迟增加了 6%∼73%。</p>
</li>
</ul>
<h4 id="2-4-3-LibOS-和-gVisor-的问题"><a href="#2-4-3-LibOS-和-gVisor-的问题" class="headerlink" title="2.4.3. LibOS  和 gVisor 的问题"></a>2.4.3. LibOS  和 gVisor 的问题</h4><p>基于 LibOS 的 secure container <strong><u>将 LibOS attach 到进程或虚拟机中的每个容器上</u></strong>。它们在 secure container 内不执行用户-内核隔离（user/kernel isolation），而是<strong><u>在同一地址空间运行应用程序和 libOS</u></strong>。这种设计避免了系统调用处理过程中的页表切换，但削弱了容器的隔离保证。同时，它们通常兼容性较差，例如无法完全支持容器中的多进程。</p>
<blockquote>
<p>优点：避免页表切换；缺点：削弱隔离性、安全性，不保证兼容性（如多进程）；</p>
</blockquote>
<p>gVisor 实现了一个名为 Sentry 的新用户空间内核，每个容器都运行在一个私有的 Sentry 实例上。gVisor 让 host kernel 处理应用程序的 page fault，避免了影子分页的开销。不过，由于涉及 IPC，Systrap 比本地系统调用慢得多。同时，作为一个重新实现的内核，gVisor 可能缺乏 Linux 内核的完全兼容性和优化功能。</p>
<blockquote>
<p>优点：避免 shadow page 开销，但是 IPC 导致性能下降，并且 Sentry 缺乏 Linux 一样的兼容性和优化能力；</p>
</blockquote>
<h2 id="3-解决方案总览"><a href="#3-解决方案总览" class="headerlink" title="3. 解决方案总览"></a>3. 解决方案总览</h2><h3 id="3-1-设计内涵和选择"><a href="#3-1-设计内涵和选择" class="headerlink" title="3.1 设计内涵和选择"></a>3.1 设计内涵和选择</h3><p><strong><u>设计内涵</u></strong>：根据第 2.4 节中的分析，为容器 guest kernel 高效构建新权限级别有两个设计含义（为什么要为容器 guest kernel 构建一个新特权级？）：</p>
<ol>
<li><strong><u>权限级别之间的高效切换</u></strong>。由于 guest kernel 经常与应用程序通信（即系统调用/异常）并执行特权操作（如页表更新和 I/O 请求），我们应尽量减少这些过程中的上下文切换开销。应避免 PVM 中的系统调用重定向或嵌套 HVM 中的虚拟机退出重定向等过度开销；</li>
<li><strong><u>无两阶段地址转换的内存隔离</u></strong>。两阶段地址转换是为通用虚拟化设计的，超出了容器隔离的需求，因为容器不依赖特定的物理内存布局。使用单级转换可以避免影子分页或 EPT 转换/管理的开销。</li>
</ol>
<p><strong><u>设计选择</u></strong>：MPK 可在单个 CPU 权限级别内执行高效的域隔离，这可用于构建新的权限级别。有两种可能的设计：</p>
<ol>
<li>在用户模式下运行 guest kernel，并使用 PKU（Design-PKU）将其与应用程序隔离；</li>
<li>在内核模式下运行 guest kernel，并使用 PKS（Design-PKS）将其与 host kernel 隔离。</li>
</ol>
<p>这两种设计都支持无需重定向的高效系统调用。它们还能避免嵌套云中的虚拟机退出重定向，因为 guest kernel 和 host kernel 使用相同的 VMCS 执行。</p>
<p>我们选择 Design-PKS 而不是 Design-PKU，原因如下。</p>
<ul>
<li>首先，由于 PKU 已被广泛用于各种应用（进程内隔离），Design-PKU 本身会干扰这些现有用例。这种冲突破坏了 PKU 在用户空间应用中的初衷；</li>
<li>其次，Design-PKU 需要替换容器应用中的 <code>wrpkru</code> 指令和系统调用指令。然而，正如 Hodor 所强调的，在没有源代码的情况下对任意（容器）镜像进行二进制重写可能是不可判定的，这可能会破坏容器二进制的兼容性或妨碍应用功能（如及时编译）；</li>
<li>第三，Design-PKU 在异常处理中会产生额外的性能开销。例如，从 host 向 guest kernel 注入 page fault 需要额外的跨特权级切换，在我们的测试平台上，page fault latency（原本约为 1,000ns）增加了约 750ns；</li>
</ul>
<h3 id="3-2-基于-PKS-隔离的挑战"><a href="#3-2-基于-PKS-隔离的挑战" class="headerlink" title="3.2 基于 PKS 隔离的挑战"></a>3.2 基于 PKS 隔离的挑战</h3><p>PKS 最初并不是为隔离容器 guest kernel 而设计的，这导致我们的设计面临以下挑战：</p>
<ol>
<li><p><strong><u>隔离域数量不足</u></strong>。PKS 在一个地址空间中最多只能支持 16 个域，远远低于安全容器的潜在数量。因此，在专用的 PKS 域中隔离每个客户内核是不可行的；</p>
</li>
<li><p><strong><u>缺乏特权指令隔离</u></strong>。PKS 只提供内存隔离，而在内核模式下运行的恶意 guest kernel 可以使用特权指令破坏隔离。二进制重写是从隔离软件中删除特定指令的常用技术。然而，要消除操作系统内核中未对齐位置的所有特权指令是不可行的。</p>
<p>对于嵌套云，一种潜在的解决方案是使用虚拟化硬件拦截和监控 L1 虚拟机中的所有特权指令，但这需要对 L0 内核进行侵入式修改，可能并不可行。</p>
</li>
<li><p><strong><u>switch gate 功能不完整</u></strong>。在基于 PKS 的隔离下，guest kernel 使用 PKS switch gate 与 host kernel 通信。但是，这种 switch gate 需要 PKS 原本不支持的功能。例如，host kernel 需要在 guest 执行期间使用 switch gate 拦截硬件中断，但原本实现的 switch gate 设计可能会让 guest kernel 向 host kernel 注入假中断。</p>
<blockquote>
<p>通俗来说，硬件中断（比如键盘输入、网络数据到达等）需要由主机内核统一处理，这个过程要通过 switch gate 机制来完成。但如果这个机制设计得太简单，恶意的客户内核就可能模仿硬件中断的信号格式，伪造出假的中断请求发送给主机内核。</p>
<p>可能导致的问题，一是主机内核被大量虚假请求干扰，无法处理真实的硬件中断（DoS）；二是假中断可能携带恶意指令，导致主机内核的安全机制被绕过；</p>
</blockquote>
</li>
</ol>
<h3 id="3-3-设计架构总览"><a href="#3-3-设计架构总览" class="headerlink" title="3.3 设计架构总览"></a>3.3 设计架构总览</h3><p>CKI 是一种虚拟机级容器架构，每个容器都运行在独立的内核上。它在不使用硬件虚拟化扩展的情况下实现了三种权限级别。PVM 是最先进（SOTA）的安全容器设计，不使用虚拟化硬件。下图显示了 CKI 的架构及其与 PVM 的不同之处。简而言之，CKI 避免了基于软件的虚拟化的系统调用重定向和影子分页的开销，因此无论在裸机还是嵌套云中都能获得更好的性能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="esc/cki-arch.png" /></p>
<h4 id="3-3-1-抽象"><a href="#3-3-1-抽象" class="headerlink" title="3.3.1 抽象"></a>3.3.1 抽象</h4><p>每个 CKI 安全容器就像一个虚拟机，有一个 guest kernel 和多个用户进程，运行在 host kernel 上。guest kernel 提供操作系统功能，如内存管理、调度、文件系统和网络堆栈。host kernel 调度 guest 的 vCPU，为其分配内存，并使用 VirtIO 协议为 guest kernel 模拟虚拟设备（磁盘和网卡）。<strong><u>所有硬件中断都由 host kernel 处理</u></strong>。当 guest kernel 需要调用 host 功能或发生硬件中断时，guest vCPU 会通过一段名为 switcher 的上下文切换代码退出到 host kernel（第 4.2 节）。<strong><u>对于嵌套虚拟化，CKI 虚拟机退出过程不涉及 L0 干预</u></strong>（guest kernel 和 host kernel 均位于内核态）。host kernel 在恢复 guest vCPU 时可能会注入虚拟中断。</p>
<h4 id="3-3-2-与-PVM-的区别"><a href="#3-3-2-与-PVM-的区别" class="headerlink" title="3.3.2 与 PVM 的区别"></a>3.3.2 与 PVM 的区别</h4><p>CKI 与基于软件的虚拟化（PVM）有两个主要区别。</p>
<ul>
<li><p>首先，CKI 在内核模式下以新的权限级别运行 guest kernel，使客户用户无需 host kernel 干预即可调用系统调用。<strong><u>guest kernel 的内存映射在 guest 用户地址空间中，并通过 PTE U/K 位隔离</u></strong>，从而消除了系统调用时的页表切换；</p>
<blockquote>
<p>不加 KPTI 的时候，Linux 不也是把 kernel 的内存映射到用户地址空间的吗？</p>
</blockquote>
</li>
<li><p>其次，<strong><u>CKI 不实现两阶段地址转换。host kernel 为每个 guest VM 提供一些连续的 HPA 段</u></strong>，由 guest kernel 中的内存管理器直接管理。因此，guest user page fault 可由 guest kernel 直接处理，而不是在 host kernel 中触发 shadow page fault。通过消除虚拟机退出、GPA 到 HPA 转换和影子 PTE 生成，PTE 更新操作也得到了简化。</p>
</li>
</ul>
<h4 id="3-3-3-定义新的权限级别（Guest-Kernel-Mode）"><a href="#3-3-3-定义新的权限级别（Guest-Kernel-Mode）" class="headerlink" title="3.3.3 定义新的权限级别（Guest Kernel Mode）"></a>3.3.3 定义新的权限级别（Guest Kernel Mode）</h4><p>CKI 利用基于 PKS 的内核内部隔离来构建新的权限级别，以消除 guest kernel 的权限。一方面，它将 PKS 隔离与地址空间隔离相结合，限制 guest kernel 的内存访问权限（PKS 原本就进行内存隔离，但不提供特权指令隔离）。另一方面，它还能监控来自 guest kernel 的特权操作的执行情况（需要扩展，参见下文）。</p>
<p>具体来说，不同的 secure container 和 host kernel 被隔离在不同的地址空间。每个 guest kernel 都是非特权内核，与特权内核安全监控程序（KSM）一起运行，两者运行在同一地址空间，但在 PKRS（内核页保护密钥权限寄存器）中指定的 PKS 权限不同。KSM （PKRS 为零）可以访问所有虚拟内存，而 guest kernel（PKRS 为 <code>PKRS_GUEST</code>）不能访问其 KSM 的内存。</p>
<blockquote>
<p>因此，在每个 secure container 的地址空间内，guest kernel 和 KSM 只需要两个 PKS 域。因此，CKI 可以支持任意数量的安全容器，而不受 PKS 域限制的影响（<strong><u>克服挑战-1</u></strong>）。</p>
</blockquote>
<p>此外，CKI 还为 PKS 增加了一个轻量级硬件扩展，使特权指令在 guest kernel 中不可执行（参见 4.1）（<strong><u>克服了挑战-2</u></strong>）。</p>
<p>guest kernel 只能通过其 KSM 或 host kernel 提供的预定义接口执行特权操作。KSM 实现的特权操作只能访问安全容器的私有数据，例如页表更新（参见 4.3，这不需要下陷到 L0）和 <code>iret</code> 指令。<strong><u>这些特权操作可通过高效的 PKS gate（guest kernel 与 KSM 之间的切换）调用</u></strong>（参见 4.2）。由于只有私有数据才会映射到 KSM 中，CKI 从 PKS gate 中消除了代价高昂的侧信道缓解方案（如 PTI 和 IBRS）。</p>
<p>其他特权操作（如 VirtIO MMIO、定时器设置、<code>hlt</code> 指令）依赖于全局数据（如驱动程序/调度程序元数据），由 host kernel 提供。guest kernel 可通过专门设计的 switcher（guest kernel 与 host kernel 之间的切换器）调用此类操作。switcher 还包含中断门，可在 guest VM 执行期间拦截硬件中断，并将其重定向到 host kernel。CKI 依靠多种技术防止中断垄断和中断伪造（参见 4.4）（<strong><u>克服挑战-3</u></strong>）。</p>
<h3 id="3-4-威胁模型"><a href="#3-4-威胁模型" class="headerlink" title="3.4 威胁模型"></a>3.4 威胁模型</h3><p>CKI 继承了 VM 级容器的威胁模型。host kernel 和 KSM 隔离多个容器，而容器中的 guest kernel 则隔离多个用户进程。一个容器可能会被入侵，然后试图打破容器间隔离，例如执行破坏性特权指令或破坏关键内存结构（如页表、IDT）。由于 KSM 和 host kernel 的攻击面较小（hypervisor 接口），因此假定它们是可信的。</p>
<p>单个安全容器内的瞬时执行攻击不在攻击范围内。容器间的瞬时执行攻击可通过在每个容器自己的地址空间中运行并在 host kernel 中启用 Spectre 缓解功能来缓解。</p>
<h2 id="4-设计细节"><a href="#4-设计细节" class="headerlink" title="4. 设计细节"></a>4. 设计细节</h2><h3 id="4-1-基于-PKS-的特权指令隔离"><a href="#4-1-基于-PKS-的特权指令隔离" class="headerlink" title="4.1 基于 PKS 的特权指令隔离"></a>4.1 基于 PKS 的特权指令隔离</h3><p>出于性能考虑，CKI 选择在内核模式下构建新的权限级别，也就是说，容器用户进程可以以原有的高效方式与（容器）guest kernel 进行交互。例如，进程仍可通过 syscall 指令直接调用系统调用，而无需额外的上下文切换。</p>
<p>由于 guest kernel 不受信任，CKI 需要防止它执行特权指令，从而破坏安全隔离。目前的 PKS 硬件功能只能在内核模式下提供内存隔离，无法限制特权指令的执行。此外，现有的基于软件的指令隔离技术（如二进制重写）也不适用于 CKI（第 3.2 节、第 3.1 节）。</p>
<h4 id="4-1-1-硬件扩展"><a href="#4-1-1-硬件扩展" class="headerlink" title="4.1.1 硬件扩展"></a>4.1.1 硬件扩展</h4><p>因此，CKI 引入了一种轻量级硬件扩展，以防止 guest kernel 执行可能导致破坏性序列的特权指令。由于 PKRS 在 guest kernel 执行期间为非零（有限内存视图），而在 KSM 执行期间为零（无限内存视图），因此该扩展可以依靠 PKRS 寄存器的值来确定当前执行的是哪一个。当 PKRS 非零时，扩展会阻止所有破坏性特权指令。在客户内核中执行这些指令会触发异常，并向 host kernel 发出 trap。非破坏性特权指令仍可在客户内核中执行，以尽量减少开销。下表列出了特权指令及其在客户内核中是否被阻止（通过控制这个规则可以控制哪种指令会下陷到 host kernel）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="esc/pks-blk.png" /></p>
<blockquote>
<p>注：block 表示如果 PKRS 非零时触发是否会阻塞并 trap 给 host kernel。</p>
</blockquote>
<h4 id="4-1-2-阻塞指令"><a href="#4-1-2-阻塞指令" class="headerlink" title="4.1.2 阻塞指令"></a>4.1.2 阻塞指令</h4><blockquote>
<p>任何写入系统寄存器、控制寄存器、<code>iret</code>、控制中断等指令（中断控制通过 host kernel 可见内存位）；</p>
</blockquote>
<p>除了上表中列出的无害指令外，大多数特权指令都被阻止。<strong><u>被屏蔽的指令可以使用基于软件的虚拟化中的类似技术进行虚拟化，即用调用宿主内核或 KSM 来代替它们</u></strong>。</p>
<p>我们屏蔽了任何写入系统寄存器（如 <code>GDTR</code> 和 <code>IDTR</code>）、控制寄存器或特定模型寄存器（MSR）的指令。中断返回指令 (<code>iret</code>)可能会修改段寄存器，因此会被阻止。我们还屏蔽了对容器 guest kernel 来说不必要的指令，如与 Port I/O 和系统管理模式相关的指令。</p>
<p>操作系统内核使用 <code>cli</code>/<code>sti</code> 和 <code>popf</code> 指令启用或禁用 CPU 上的中断处理。这些指令在 guest kernel 中被阻止，以防止 DoS。<strong><u>CKI 采用了半虚拟化的中断处理机制</u></strong>。所有硬件中断都由 host kernel 处理，host kernel 再向 guest kernel  注入虚拟中断。guest kernel 不使用特权指令管理中断启用/禁用状态（guest-aware 所以是半虚拟化），而是通过 host kernel 可见的内存位来管理。</p>
<h4 id="4-1-3-无阻塞指令"><a href="#4-1-3-无阻塞指令" class="headerlink" title="4.1.3 无阻塞指令"></a>4.1.3 无阻塞指令</h4><blockquote>
<p>修改 PKRS 的指令。x86 上使用 MSR 寄存器（特定模型寄存器），但不直接用 <code>wrmsr</code>（block），用包装后的新指令 <code>wrpkrs</code>；</p>
<p>并且限制 <code>wrpkrs</code> 的使用范围，二进制重写消除内核代码中的该指令，并 kernel 只读 + KSM 禁止新的可执行映射来避免安全问题（CKI 值用来提供容器环境，不需要支持那么多东西）。</p>
<p><code>sysret / swapgs</code> 系统调用相关也可以不阻塞。但是需要指令扩展来确保 PKRS 非零时中断不得被禁用（防止 DoS）；</p>
<p>关于 TLB flush 相关指令 <code>invlpg</code>（仅刷新当前 PCID 的 TLB 条目）是允许的，因为 secure container 和 host 隔离在不同的 PCID 上下文中，这能防止 performance attack；</p>
</blockquote>
<p>对 PKRS 寄存器的修改指令应能在 guest kernel 中执行，否则 guest kernel 将无法调用 KSM。现有的 x86 硬件将 PKRS 作为特定模型寄存器 (MSR) 来实现。但是，<code>wrmsr</code> 指令应在 guest kernel 中被阻止，以防止对其他 MSR 的任意操作。我们为修改 PKRS 引入了新的硬件指令 <code>wrpkrs</code>，其语义类似于现有的 <code>wrpkru</code> 指令（修改 PKRU，相当于 PKRS 的用户空间）。</p>
<p><code>wrpkrs</code> 指令只应出现在预先定义的 switch gates 上，因此我们使用先前工作中引入的类似<strong><u>二进制重写技术，消除了访客内核代码中的所有 <code>wrpkrs</code> 指令</u></strong>，包括未对齐指令。为防止客户内核动态创建 <code>wrpkrs</code> 指令，<strong><u>所有内核代码在 guest kernel 初始化期间都被映射为只读，KSM 禁止在容器执行期间进行新的内核可执行映射</u></strong>。</p>
<blockquote>
<p>[!NOTE] </p>
<p>CKI 不需要支持动态修补或加载 guest kernel 代码，因为这对容器来说是不必要的。请注意，CKI 的目的是提供一个容器环境，而不是支持任意的 guest kernel。</p>
</blockquote>
<p><code>sysret</code> 和 <code>swapgs</code> 指令用于处理系统调用。为这些指令调用 KSM 会将空系统调用延迟从 90ns 增加到 153ns。为了提高性能，我们允许这些指令在 guest kernel 中执行。sysret 指令可能会被用来修改 RFLAGS 寄存器并禁用内核中断（DoS）。因此，我们为该指令添加了一个轻量级扩展，以确保当 PKRS 非零时，IF（中断启用）标志保持开启。</p>
<p>guest kernel 可以使用 <code>invlpg</code> 清除 TLB。我们将每个 secure container 和 host 隔离在不同的 PCID 上下文中，以防止 performance attack，因为 <code>invlpg</code> 只刷新当前 PCID 的 TLB 条目。</p>
<h3 id="4-2-KSM-中用于-Context-Switch-的-Switch-Gates"><a href="#4-2-KSM-中用于-Context-Switch-的-Switch-Gates" class="headerlink" title="4.2 KSM 中用于 Context-Switch 的 Switch Gates"></a>4.2 KSM 中用于 Context-Switch 的 Switch Gates</h3><p>下图显示了 CKI 中的上下文切换流程。CKI 为最频繁的切换（即系统调用、异常和 KSM 调用）提供了快速路径。它为其他切换（即 host kernel 调用（hypercall）和硬件中断）提供慢速路径。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="esc/cki-paths.png" width="450px" /></p>
<p>在为这些上下文切换设计 PKS switch gates 时，KSM 中每 vCPU 区域的定位是一个难题。由于 guest kernel 可以任意修改 <code>kernel_gs</code>（Intel 中存放 per-CPU 信息地址的寄存器，有点像 AArch64 的 <code>TPIDR_EL1</code>），因此 KSM 无法依靠该寄存器来识别当前的 vCPU。</p>
<h4 id="4-2-1-系统调用和异常"><a href="#4-2-1-系统调用和异常" class="headerlink" title="4.2.1 系统调用和异常"></a>4.2.1 系统调用和异常</h4><p>当容器中的用户应用程序调用系统调用时，它会捕获到 <code>IA32_STAR</code> 寄存器中定义的 guest kernel 入口点。同样，当应用程序触发 page fault 等异常时，它也会跳转到中断描述符表（IDT）中的 guest kernel 入口点。在用户模式下，PKRS 被设置为 <code>PKRS_GUEST</code>，允许入口点调用不受信任的处理程序函数，而无需切换 PKS。系统调用和异常的进入和退出代码使用三条特权指令：<code>swapgs</code>、<code>sysret</code> 和 <code>iret</code>。<code>swapgs</code> 和 <code>sysret</code> 指令可在 guest kernel 中执行，而 <code>iret</code> 指令必须通过调用 KSM 才能执行（参见 4.1）。</p>
<h4 id="4-2-2-KSM-调用"><a href="#4-2-2-KSM-调用" class="headerlink" title="4.2.2 KSM 调用"></a>4.2.2 KSM 调用</h4><p>guest kernel 使用 <strong><u>KSM call gate</u></strong> 调用 KSM 提供的特权操作（下图）。该门将 PKRS 设为 0，切换到 guest kernel 无法访问的安全堆栈，调用处理函数，最后恢复 PKRS 和堆栈指针。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="esc/ksm-call-gate.png" width="450px" /></p>
<p>攻击者可能会利用类似 ROP 的攻击跳转到门结束时的 <code>wrpkrs</code> 指令，任意修改 PKRS 并执行恶意代码。为防止这种攻击，如上图中的 <code>switch_pks</code> 宏所示，修改后会检查新的 PKRS 值。</p>
<blockquote>
<p>[!IMPORTANT]</p>
<p>既然 <code>kernel_gs</code> 不可信，如何识别 per-vCPU 区域？</p>
<p>由于 KSM 可在多个 vCPU 上同时调用，因此每个 vCPU 都有自己的安全堆栈，位于 KSM 内存的每个 vCPU 区域。操作系统内核通常使用 <code>kernel_gs</code> 寄存器来定位每个 CPU 的变量，即每个 CPU 上的 <code>kernel_gs</code> 寄存器为本地 CPU 变量存储不同的基数。然而，CKI 允许 guest 执行 <code>swapgs</code> 指令（参见 4.1），因此恶意客户内核可以任意修改 <code>kernel_gs</code>。为了解决这个问题，<strong><u>CKI 将每 vCPU 区域放在一个恒定的虚拟地址上</u></strong>，这样就可以在没有 <code>kernel_gs</code> 的情况下找到它。</p>
<p>如下图所示，CKI 为 guest kernel 中的每个页表维护多个 per-vCPU 页表。当 guest thread 在不同的 vCPU 上执行时，会使用不同的 per-vCPU 页表。每个 per-vCPU 页表在相同的恒定的虚拟地址 (GVA) 上映射不同的 per-vCPU 区域 (HPA)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="esc/cki-percpu-pt.png" width="250px" /></p>
</blockquote>
<h4 id="4-2-3-Hypercall"><a href="#4-2-3-Hypercall" class="headerlink" title="4.2.3 Hypercall"></a>4.2.3 Hypercall</h4><p>Guest kernel 使用 hypercall gate 调用 host kernel 提供的特权操作。该门首先将 PKRS 切换为零，因为它需要执行特权指令并访问 KSM 内存（每虚拟 CPU 区域）。然后，它执行一次完整的上下文切换，以保存 guest kernel 上下文并恢复 host kernel 上下文，其中包括页表切换、通用/系统寄存器切换和<u><strong>侧信道缓解</strong></u>（如 IBRS）。host 和 guest 上下文存储在每 vCPU 区域。然后，host kernel 从 guest 上下文读取请求并进行处理。请求完成后，host kernel 恢复 guest 上下文，guest kernel 从 hypercall 门恢复。</p>
<h4 id="4-2-4-Hardware-Interrupt"><a href="#4-2-4-Hardware-Interrupt" class="headerlink" title="4.2.4 Hardware Interrupt"></a>4.2.4 Hardware Interrupt</h4><p>硬件中断会触发从 guest 到 host kernel 的 trap。硬件中断的 IDT 条目指向一个 interrupt gate；</p>
<p>中断门将中断信息保存到每 vCPU 区域，然后切换到 host kernel。host kernel 读取信息，构建中断上下文，并调用中断处理程序。处理完中断后，host kernel 会恢复被中断的 guest 上下文。</p>
<p>我们添加了一个<strong><u>硬件扩展，用于在中断进入时保存 PKRS 寄存器，并将 PKRS 切换为零</u></strong>（参见 4.4）。处理中断后，<code>iret</code> 指令应在 PKRS 设置为零时执行（参见 4.1），但在恢复 guest kernel 上下文时，它需要将 PKRS 重新设置成 <code>PKRS_GUEST</code>。因此，我们<strong><u>扩展了 <code>iret</code> 指令，允许它修改 PKRS 寄存器</u></strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="esc/cki-hvc-irq.png" width="450px" /></p>
<h3 id="4-3-内存保护机制"><a href="#4-3-内存保护机制" class="headerlink" title="4.3 内存保护机制"></a>4.3 内存保护机制</h3><p>恶意 guest kernel 可能会试图通过操纵页表来破坏内存隔离。为了隔离客户机的内存视图，KSM 会拦截并验证 guest kernel 中的所有页表更新（回忆页表更新是不涉及 L0 kernel 并且仅与 KSM private data 有关）。</p>
<h4 id="4-3-1-页表监控"><a href="#4-3-1-页表监控" class="headerlink" title="4.3.1 页表监控"></a>4.3.1 页表监控</h4><p>为了拦截页表更新，CKI 采用了与嵌套内核类似的机制，该机制基于以下不变式（invariant）：</p>
<ol>
<li>只有已声明的页才能用作页表页（PTP）；</li>
<li>已声明的 PTP 在 guest kernel 中是只读的（<strong><u>KSM / host kernel 才能修改</u></strong>）；</li>
<li>只有已声明的顶级 PTP 才能加载到 CR3 寄存器中。</li>
</ol>
<p>与嵌套内核不同，CKI 使用 PKS 而不是 PTE writable bit 来控制 PTP 的写入权限。CKI 将客户虚拟地址空间（GVA）中的所有 PTP 都划分到一个特定的 PKS 域中。它将 PKS 域 ID（<code>pkey_PTP</code>）添加到映射 PTP 的每个客户 PTE 中。执行 guest kernel 时，该 PKS 域在 PKRS 寄存器中被配置为只读。</p>
<blockquote>
<p>简言之：<strong><u>guest 页表所在页使用专用 PKS domain，在 guest kernel 执行时只读</u></strong>；</p>
</blockquote>
<p><strong><u>KSM 会为属于 guest 的每个物理页面维护一个描述符</u></strong>。guest kernel 可调用 KSM 声明 PTP 或更新 PTE。</p>
<ul>
<li>声明 PTP 时，会指定 PTP 级别并记录在描述符中。然后，KSM 会在页表中查找映射该 PTP 的 PTE，并将 <code>pkey_PTP</code>（PKS domain ID）添加到该 PTE 中。</li>
<li><strong><u>KSM 还会检查描述符中的引用计数器，以确保 PTP 只被映射一次</u></strong>。</li>
<li>更新 PTE 时，KSM 会验证新 PTE 是否指向有效的下一级 PTP 或属于客户的数据页，而不会映射已声明的 PTP。</li>
<li>此外，为防止恶意 <code>wrpkrs</code> 指令（参见 4.1），如果新映射是内核可执行的，KSM 将禁止更新。</li>
</ul>
<h4 id="4-3-2-Per-vCPU-的页表"><a href="#4-3-2-Per-vCPU-的页表" class="headerlink" title="4.3.2 Per-vCPU 的页表"></a>4.3.2 Per-vCPU 的页表</h4><p>如第 4.2 节所述，CKI 为每个 guest 页表维护多个每 vCPU 页表。每个 per-vCPU 页表映射 KSM 内存中不同的 per-vCPU 区域。具体来说，<strong><u>KSM 会为客户机中的每个顶级 PTP 维护多个 per-vCPU 副本</u></strong>。</p>
<ul>
<li>声明顶级 PTP 时，KSM 会将自己的代码和数据映射（包括 per-vCPU 区域）添加到每个副本中（有点像 kernel 给用户态程序配置页表的情形）。</li>
<li>当 guest kernel 调用 KSM 更新 CR3 时，KSM 会验证新的 CR3 值是否指向已声明的顶级 PTP，然后将相应的 PTP 副本加载到 CR3 中。</li>
<li>此外，KSM 还为读取顶层 PTP 中的 PTE 提供了一个接口，访问/脏位会从副本传播到原始 PTP。</li>
</ul>
<h4 id="4-3-3-与-Shadow-Paging-的比较"><a href="#4-3-3-与-Shadow-Paging-的比较" class="headerlink" title="4.3.3 与 Shadow Paging 的比较"></a>4.3.3 与 Shadow Paging 的比较</h4><p>与影子分页相比，CKI 的性能优势来自于更轻量级的 page fault 和 PTE 更新流程：</p>
<p>1) 轻量级页面故障。由于没有两阶段地址转换，CKI 中的用户页面故障可由客户内核直接处理。相比之下，在影子分页下，用户页面故障会被主机内核拦截，主机内核会执行页表走行以确定页面故障的类型（第一阶段或第二阶段），然后将页面故障注入客户内核。<br>2) 轻量级 PTE 更新。</p>
<ul>
<li>首先，在影子分页下，guest 中的 PTE 更新会触发虚拟机退出到 host kernel。相比之下，CKI 中的 guest kernel 可通过轻量级 PKS gate 执行 KSM call 从而进行 PTE 更新；</li>
<li>其次，影子分页将 GPA 与 QEMU 进程的虚拟内存区（VMA）关联起来。向 PTE 写入 GPA 时，必须从 VMA 的映射中找到与 GPA 相关的 HPA，这非常耗时。相反，CKI 将 HPA 委托给 guest kernel，允许 guest kernel 直接填充 PTE 中的 HPA，而不是 GPA。</li>
</ul>
<p>CKI 的一个局限是，<strong><u>它为每个 secure container 分配连续的物理内存段，这可能会由于内存碎片化而导致内存利用率较低</u></strong>。之所以做出这样的设计选择，是因为细粒度的离散内存分配会带来两个问题：</p>
<ol>
<li>它要求 KSM 在验证 PTE 更新时搜索大量元数据（页面粒度而不是段粒度），从而导致性能下降；</li>
<li>其次，容器内核（Linux）采用 buddy system 来管理物理内存，该系统可通过连续的内存段高效运行；</li>
</ol>
<p>因此，我们优先考虑运行时间性能，而不是内存利用效率。</p>
<h3 id="4-4-防止中断滥用"><a href="#4-4-防止中断滥用" class="headerlink" title="4.4 防止中断滥用"></a>4.4 防止中断滥用</h3><p>被入侵的 guest kernel 有三种通过滥用中断发起 DoS 攻击的潜在方法。</p>
<ol>
<li>中断垄断。它可能会修改中断门的代码，以独占所有中断。这样，主机和其他容器就无法再接收中断；</li>
<li>中断栈破坏。它可能会操纵中断堆栈，引发无法恢复的故障。具体来说，当中断发生时，CPU 会将上下文数据推入中断栈。如果中断发生在内核模式下，CPU 默认使用中断发生时的堆栈作为中断堆栈。恶意访客内核可能会将堆栈指针设置为无效地址，导致 CPU 尝试推送数据时出现三重故障；</li>
<li>中断伪造。它可以伪造中断，用不必要的中断请求压垮系统，从而降低系统性能或导致 host kernel 出现未定义的行为。</li>
</ol>
<p>CKI 可以防御所有这些攻击。</p>
<h4 id="4-4-1-防止中断垄断"><a href="#4-4-1-防止中断垄断" class="headerlink" title="4.4.1 防止中断垄断"></a>4.4.1 防止中断垄断</h4><p>CKI 有以下策略防止中断垄断：</p>
<ol>
<li><strong><u>门不可修改</u></strong>（位于 KSM）。CKI 在 KSM 内存中分配 IDT 和 interrupt gate 代码，使 guest kernel 无法修改它们；</li>
<li><strong><u>Guest Kernel 权限剥夺</u></strong>。它使用 PKS gate 权限剥夺机制（参见 4.1 节）确保 guest kernel 无法禁用中断处理或修改 IDTR（IDT 基地址寄存器）；</li>
<li><strong><u>门代码映射不可修改</u></strong>（位于 KSM）。guest kernel 不能更改或删除 IDT 或 interrupt gate 代码的映射，因为 KSM 在每个激活的页表中映射了自己的内存（参见 4.3）；</li>
</ol>
<p>有了这些机制，当中断发生时，CPU 控制流总能切换到正确的中断门。</p>
<h4 id="4-4-2-防止中断堆栈破坏"><a href="#4-4-2-防止中断堆栈破坏" class="headerlink" title="4.4.2 防止中断堆栈破坏"></a>4.4.2 防止中断堆栈破坏</h4><p>CKI 利用 x86 中断堆栈表 (IST) 功能，确保 CPU 始终使用正确的中断堆栈。具体来说，IST 允许设置特定的中断堆栈，并强制 CPU 在推送中断上下文之前切换到该堆栈。IST 初始化由 KSM 完成（guest kernel 无法执行相关特权指令），相应内存也位于 KSM 中（guest kernel 无法修改相应内存数据）。</p>
<p>简而言之，<strong><u>x86 IST + KSM 来初始化和内存存放</u></strong>。</p>
<h4 id="4-4-3-防止中断伪造"><a href="#4-4-3-防止中断伪造" class="headerlink" title="4.4.3 防止中断伪造"></a>4.4.3 防止中断伪造</h4><p>由于 interrupt gate 需要访问 KSM 内存并执行特权指令，因此当 guest kernel 发生中断时，它需要首先将 PKRS 切换为零。如果在门内通过 <code>wrpkrs</code> 指令进行切换，那么恶意 guest kernel 就会直接跳转到其中一个中断门，并向 host kernel 发送伪造的中断。</p>
<p>因此为了防止伪造中断，CKI 扩展了 IDT 配置，除了切换中断堆栈等原有功能外，还进一步支持切换 PKRS 寄存器。如下图中蓝色下划线文本所述，当发生硬件中断时，这一微小的硬件扩展会自动将 PKRS 寄存器置零。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="esc/cki-hvc-irq.png" width="450px" /></p>
<p>所以，interrupt gate 中没有 <code>wrpkrs</code> 指令。如果 guest kernel 跳转到门入口，PKRS 将保持 <code>PKRS_GUEST</code>，导致后续上下文切换失败。请注意，应用程序或 guest kernel 可能会使用 int 指令生成软件中断。<strong><u>硬件扩展只在硬件中断时切换 PKRS，而在软件中断时保持 PKRS 不变</u></strong>。</p>
<p>此外，guest kernel 也无法滥用 hypercall gate 进行中断伪造，因为 host kernel 可以根据 KSM（每 vCPU 内存区）中保存的信息识别不同的退出原因。</p>
<h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><h3 id="5-1-Guest-Kernel"><a href="#5-1-Guest-Kernel" class="headerlink" title="5.1 Guest Kernel"></a>5.1 Guest Kernel</h3><p>我们在 CKI 容器中将 Linux 内核作为访客内核运行。我们利用 Linux 内核中的半虚拟化实用程序（即 <code>pv_ops</code>）来 hook 特权操作。我们还在 Linux 内核中添加了一个新的启动程序，以移除传统的初始化操作。我们增加了 2000 行代码，修改了不到 80 行代码。</p>
<p>移除两阶段地址转换不需要大量的移植工作。</p>
<ul>
<li>传统内核可能依赖固定的低物理地址来启动真实模式。相反，CKI 通过半虚拟化直接从 long mode 启动虚拟 CPU（vCPU）；</li>
<li>传统的虚拟化堆栈使用两阶段地址转换来创建 MMIO 区域，这些区域在第一阶段映射，但在第二阶段不映射。我们用 hypercall 取代了客户内核（VirtIO 前端）中的 MMIO；</li>
</ul>
<p>在兼容性方面，CKI 有可能支持与基于软件的虚拟化相同的客户内核功能。</p>
<h3 id="5-2-Hardware-Extensions"><a href="#5-2-Hardware-Extensions" class="headerlink" title="5.2 Hardware Extensions"></a>5.2 Hardware Extensions</h3><p>第 7 节中的性能评估是在真实硬件而非模拟器上进行的。在评估中，我们使用 <code>wrpkru</code> 指令来模拟 <code>wrpkrs</code> 指令。根据我们基于 Gem5 模拟器的评估，在特权指令中添加 PKS 权限检查逻辑产生的开销可以忽略不计，因此我们在评估中直接使用未修改的指令。我们通过添加 wrpkru 指令来模拟中断进入和 <code>iret</code> 期间的 PKRS switching 开销。</p>
<h2 id="6-安全性分析"><a href="#6-安全性分析" class="headerlink" title="6. 安全性分析"></a>6. 安全性分析</h2><p>CKI 可以实现与基于软件的虚拟化（PVM）相同的安全目标，因为它实现了相同的隔离基元（见下图）。</p>
<ol>
<li><strong><u>页表和内存隔离</u></strong>（PKS）：PVM 通过 PTE U/K 位和单独的页表将 switcher 和 host kernel 内存与 guest kernel 隔离，而 CKI 通过 PKS 和独立页表将 KSM 和 host kernel 内存与 guest kernel 隔离（参见 4.3 节）；</li>
<li><strong><u>特权指令隔离</u></strong>（PKS EXT 权限剥夺）：PVM 通过在用户模式下运行，防止虚拟机 guest kernel 执行特权指令，而 CKI 通过 PKS 限制 guest kernel 执行特权指令（参见 4.1）；</li>
<li><strong><u>特权转换防护</u></strong>（Call Gates，包括 KSM call，Hypercall 等）：PVM 为虚拟机提供了一个预定义的系统调用入口点来调用主机内核。CKI 采用二进制重写技术，消除了客户内核中的 <code>wrpkrs</code> 指令，只留下有效的入口点来调用 KSM 或主机内核（参见 4.2）；</li>
<li><strong><u>中断防护</u></strong>（Interrupt Gates）：在 PVM 中，当虚拟机被硬件中断中断时，CPU 会调用 IDT 中定义的相应主内核处理函数。CKI 设计了中断门，将硬件中断重定向到主机内核，确保中断门不会被破坏或滥用（参见 4.4）。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="esc/cki-sec.png" /></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SSRVodka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/technical/sc-paper/">https://blog.sjtuxhw.top/technical/sc-paper/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SSRVodka's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Container/">Container</a><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/Paper/">Paper</a><a class="post-meta__tags" href="/tags/VM/">VM</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/sc.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/transformer.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Transformer 论文精读 + 代码实现</div></div><div class="info-2"><div class="info-item-1">笔记温习一下经典的 Transformer 架构的论文，结合代码实现和解读。  前置知识 循环神经网络、卷积神经网络的演化过程、结构、代表性的模型；  传统的注意力机制（attention）已经在很多场合下成为序列/转录模型的不可分割的一部分，因为无论两个词语语义的依赖在输入/输出序列中距离多远，都能建模依赖关系。但是这种传统的注意力机制仍然没有用在 recurrent 网络中。  自注意力机制（self-attention）是通过关联单个序列中的的不同位置，来计算这个序列的 hidden representation。自注意力机制在此前被成功应用与阅读理解、抽象总结等任务中；  另外有工作表明，基于循环注意力机制（recurrent attention）的端到端记忆网络（end-to-end memory networks），它并没有采用传统 RNN 的序列对齐循环（sequence-aligned recurrence）的计算方法，仍然能在简单语言问答、语言建模等任务上取得比较好的效果；  循环注意力机制：一种将注意力机制与循环神经网络（RNN）相结合的技术，常见的有...</div></div></div></a><a class="pagination-related" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ml-roadmap.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">知识图谱：Machine Learning Roadmap</div></div><div class="info-2"><div class="info-item-1">笔者感觉 ML 这块知识点太多，互联网上多数信息都难以结构化，尤其是一个方向的知识火起来后，每个人都写一篇博客，看的眼花缭乱。。因此笔者简单总结了一下机器学习领域的知识图谱，方便知识体系构建和回顾。 如有错误，欢迎读者勘误斧正。  </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/technical/hilog-paper/" title="OpenHarmony Hilog 架构趣读"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/hilog-paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-29</div><div class="info-item-2">OpenHarmony Hilog 架构趣读</div></div><div class="info-2"><div class="info-item-1">最近看到一篇讨论 OpenHarmony Hilog 日志子系统的设计的论文，遂进行了一番阅读。该论文发表在软件学报上。 摘要 分析当今主流日志系统的技术架构和优缺点； 基于 OpenHarmony 操作系统的异构设备互联特性，设计 HiLog 日志系统模型规范； 设计并实现第 1 个面向 OpenHarmony 的日志系统 HiLog, 并贡献到 OpenHarmony 主线； 对 HiLog 日志系统的关键指标进行测试和对比试验；  实现的 HiLog 具有以下特征：  基础性能：日志写入阶段吞吐量分别为 1 500 KB/s 和 700 KB/s，吞吐量相对 Android Log 提升 114%； 日志持久化：压缩率 3.5%，丢包率...</div></div></div></a><a class="pagination-related" href="/technical/xpc-paper/" title="论文阅读 - XPC: Architectural Support for Secure and Efficient Cross Process Call"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/xpc-paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-28</div><div class="info-item-2">论文阅读 - XPC: Architectural Support for Secure and Efficient Cross Process Call</div></div><div class="info-2"><div class="info-item-1">这是一篇 2019 年的关于微内核 IPC 性能优化的文章。 摘要微内核有很多引人注目的 features，例如 安全性、容错性、模块化，以及可定制性，这些特性近期在学术界和工业界又再次掀起了一股研究热潮（including seL4, QNX and Google’s Fuchsia OS）。  Google’s Fuchsia’s kernel (called Zircon)  但是 IPC（进程间通信）作为微内核的 阿喀琉斯之踵，仍然是导致微内核 OS 总体性能较低的主要因素之一。同时 IPC 在宏内核中也扮演者很重要的角色，例如 Android Linux，其中的移动端程序会经常和用户态服务通过 IPC 通信。所以优化 IPC 自然是一个很重要的课题。 之前学界对 IPC 在软件层面的优化都绕不开 Kernel，因为 IPC 在这方面的主要开销就是 域切换（domain switch）和消息复制/重映射（message copying/remapping）；在硬件层面的优化方法主要是 给内存和能力打...</div></div></div></a><a class="pagination-related" href="/technical/docker-basic/" title="Docker 基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/docker.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="info-item-2">Docker 基础</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference：Docker 官方文档 本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！    前置知识：Linux、Git、虚拟机、略懂操作系统；  Chapter 0. Docker 安装Mac 安装1brew install --cask docker Linux 任何 distribution 自动安装12curl -fsSL get.docker.com -o get-docker.sh    # 自动安装脚本sudo sh get-docker.sh --mirror Aliyun # 国内阿里云，如果你在国外，删除 --mirror参数 Ubuntu 手动安装 卸载旧版本 123sudo apt-get remove docker \               docker-engine \               docker.io  安装 HTTPS 必要软件包 和 CA 证书防止安装包篡改 12345678sudo apt-get updatesudo apt-get install \  ...</div></div></div></a><a class="pagination-related" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</div></div><div class="info-2"><div class="info-item-1">特权级切换与内存管理这两块知识一直是 OS 的极其极其重要的组成部分：特权级切换是 OS 上下文切换和调度的基石，而内存管理则是一切隔离性（进程抽象）、资源可用性的基石。可惜对于初学者而言太过庞大，并且它们通常相互涉及，以至于总是掌握不了全貌。 笔者想从尽可能全面的视角记录总结一下它们究竟在做什么，方便日后查阅笔记、快速理解，因此不会过于深入细节（例如不会介绍 Buddy System 和 SLUB 机制的具体内容）。 最后我们将总结并运用已经了解的知识，讨论一下全局视角下的 OS 内核栈。 如有错误，欢迎读者勘误斧正。  下面内容将以 AArch64 为例。 建议复习：通用寄存器 x0-x30、PC 程序计数器、4 个栈寄存器 SP_ELx、3 个异常链接器 ELR_ELx（从 1 开始）、3 个程序状态寄存器 SPSR_ELx、2 个页表基地址寄存器 TTBRx_EL1（注意只有 EL1 级别）、TCR/SCTLR/SCR/TPIDR/MPIDR 这些常见寄存器的用途。  A....</div></div></div></a><a class="pagination-related" href="/review/io-mul-more/" title="更多的 I&#x2F;O 多路复用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/io-mult-more.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-01</div><div class="info-item-2">更多的 I&#x2F;O 多路复用</div></div><div class="info-2"><div class="info-item-1">最近总结了一些 OS I/O 多路复用的知识。之前对 I/O Multiplexer 的认知还停留在 select 系统调用，现在是时候扩展一下视野了。 1. 从 Socket 模型开始Socket 作为一个应用层和传输层间的的抽象，支持网络层 IPv4 / IPv6，以及传输层 TCP / UDP。 双方要进行网络通信前，各自需要创建一个 Socket。 如果是基于 UDP 的套接字：  如果是基于 TCP 的套接字：  以基于 TCP 的套接字为例，首先使用 socket() 创建一个网络协议为 IPv4，以及传输协议为 TCP 的 Socket 结构体，然后使用 bind() 绑定 Server IP 和进程服务端口 port，并监听 listen() 在该端口上（listen 仅改变状态）；  之所以需要指定 Server IP，是因为一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址。Socket 允许指定监听的网卡。0.0.0.0 表示监听所有的 network interfaces； port 即为传输层信息，对应指定线程的服务。  Server 端...</div></div></div></a><a class="pagination-related" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/transformer.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-20</div><div class="info-item-2">Transformer 论文精读 + 代码实现</div></div><div class="info-2"><div class="info-item-1">笔记温习一下经典的 Transformer 架构的论文，结合代码实现和解读。  前置知识 循环神经网络、卷积神经网络的演化过程、结构、代表性的模型；  传统的注意力机制（attention）已经在很多场合下成为序列/转录模型的不可分割的一部分，因为无论两个词语语义的依赖在输入/输出序列中距离多远，都能建模依赖关系。但是这种传统的注意力机制仍然没有用在 recurrent 网络中。  自注意力机制（self-attention）是通过关联单个序列中的的不同位置，来计算这个序列的 hidden representation。自注意力机制在此前被成功应用与阅读理解、抽象总结等任务中；  另外有工作表明，基于循环注意力机制（recurrent attention）的端到端记忆网络（end-to-end memory networks），它并没有采用传统 RNN 的序列对齐循环（sequence-aligned recurrence）的计算方法，仍然能在简单语言问答、语言建模等任务上取得比较好的效果；  循环注意力机制：一种将注意力机制与循环神经网络（RNN）相结合的技术，常见的有...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="xhw-card-content"><div class="xhw-avatar-group"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="xhw-sticker"><img class="sticker-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/smile.avif" alt="emoji-sticker"/></div></div></div><div class="author-info-name">SSRVodka</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">78</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span><a class="service-status-badge" id="serviceStatusBadge" href="https://status.sjtuxhw.top" rel="external nofollow noreferrer" target="_blank"><span class="status-loading"></span><span class="status-text">loading...</span></a></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-Overview"><span class="toc-text">0. Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1. 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%83%8C%E6%99%AF%E5%92%8C%E5%8A%A8%E6%9C%BA"><span class="toc-text">2. 背景和动机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Secure-Container-Models"><span class="toc-text">2.1 Secure Container Models</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Secure-Containers-in-Nested-Clouds"><span class="toc-text">2.2 Secure Containers in Nested Clouds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Memory-Protection-Keys"><span class="toc-text">2.3 Memory Protection Keys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Issues-of-VM-Level-Containers"><span class="toc-text">2.4 Issues of VM-Level Containers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-HVM-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">2.4.1. HVM 的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-PVM-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">2.4.2. PVM 的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-LibOS-%E5%92%8C-gVisor-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">2.4.3. LibOS  和 gVisor 的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%BB%E8%A7%88"><span class="toc-text">3. 解决方案总览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%AE%BE%E8%AE%A1%E5%86%85%E6%B6%B5%E5%92%8C%E9%80%89%E6%8B%A9"><span class="toc-text">3.1 设计内涵和选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%9F%BA%E4%BA%8E-PKS-%E9%9A%94%E7%A6%BB%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-text">3.2 基于 PKS 隔离的挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88"><span class="toc-text">3.3 设计架构总览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E6%8A%BD%E8%B1%A1"><span class="toc-text">3.3.1 抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E4%B8%8E-PVM-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.3.2 与 PVM 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB%EF%BC%88Guest-Kernel-Mode%EF%BC%89"><span class="toc-text">3.3.3 定义新的权限级别（Guest Kernel Mode）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.4 威胁模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82"><span class="toc-text">4. 设计细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E4%BA%8E-PKS-%E7%9A%84%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%E9%9A%94%E7%A6%BB"><span class="toc-text">4.1 基于 PKS 的特权指令隔离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E7%A1%AC%E4%BB%B6%E6%89%A9%E5%B1%95"><span class="toc-text">4.1.1 硬件扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E9%98%BB%E5%A1%9E%E6%8C%87%E4%BB%A4"><span class="toc-text">4.1.2 阻塞指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E6%97%A0%E9%98%BB%E5%A1%9E%E6%8C%87%E4%BB%A4"><span class="toc-text">4.1.3 无阻塞指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-KSM-%E4%B8%AD%E7%94%A8%E4%BA%8E-Context-Switch-%E7%9A%84-Switch-Gates"><span class="toc-text">4.2 KSM 中用于 Context-Switch 的 Switch Gates</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-text">4.2.1 系统调用和异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-KSM-%E8%B0%83%E7%94%A8"><span class="toc-text">4.2.2 KSM 调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-Hypercall"><span class="toc-text">4.2.3 Hypercall</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-Hardware-Interrupt"><span class="toc-text">4.2.4 Hardware Interrupt</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">4.3 内存保护机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E9%A1%B5%E8%A1%A8%E7%9B%91%E6%8E%A7"><span class="toc-text">4.3.1 页表监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-Per-vCPU-%E7%9A%84%E9%A1%B5%E8%A1%A8"><span class="toc-text">4.3.2 Per-vCPU 的页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E4%B8%8E-Shadow-Paging-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">4.3.3 与 Shadow Paging 的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E9%98%B2%E6%AD%A2%E4%B8%AD%E6%96%AD%E6%BB%A5%E7%94%A8"><span class="toc-text">4.4 防止中断滥用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E9%98%B2%E6%AD%A2%E4%B8%AD%E6%96%AD%E5%9E%84%E6%96%AD"><span class="toc-text">4.4.1 防止中断垄断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E9%98%B2%E6%AD%A2%E4%B8%AD%E6%96%AD%E5%A0%86%E6%A0%88%E7%A0%B4%E5%9D%8F"><span class="toc-text">4.4.2 防止中断堆栈破坏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-%E9%98%B2%E6%AD%A2%E4%B8%AD%E6%96%AD%E4%BC%AA%E9%80%A0"><span class="toc-text">4.4.3 防止中断伪造</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Guest-Kernel"><span class="toc-text">5.1 Guest Kernel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Hardware-Extensions"><span class="toc-text">5.2 Hardware Extensions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-text">6. 安全性分析</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/transformer.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Transformer 论文精读 + 代码实现"/></a><div class="content"><a class="title" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现">Transformer 论文精读 + 代码实现</a><time datetime="2025-07-20T15:15:10.000Z" title="发表于 2025-07-20 23:15:10">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/sc.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"/></a><div class="content"><a class="title" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</a><time datetime="2025-07-01T10:14:11.000Z" title="发表于 2025-07-01 18:14:11">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ml-roadmap.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识图谱：Machine Learning Roadmap"/></a><div class="content"><a class="title" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap">知识图谱：Machine Learning Roadmap</a><time datetime="2025-06-08T06:59:31.000Z" title="发表于 2025-06-08 14:59:31">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"/></a><div class="content"><a class="title" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</a><time datetime="2025-05-30T08:49:12.000Z" title="发表于 2025-05-30 16:49:12">2025-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/tee-lab.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机密计算与TEE：知识整理和试验笔记"/></a><div class="content"><a class="title" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记">机密计算与TEE：知识整理和试验笔记</a><time datetime="2025-04-17T15:31:36.000Z" title="发表于 2025-04-17 23:31:36">2025-04-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SSRVodka  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-image"><a class="rightMenu-item" href="javascript:rmf.copyImageUrl();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制图片地址</span></a><a class="rightMenu-item" href="javascript:rmf.downloadImage();" rel="external nofollow noreferrer"><i class="fa-solid fa-download"></i><span>保存图片</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-link"><a class="rightMenu-item" href="javascript:rmf.copyLink();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制链接地址</span></a><a class="rightMenu-item" href="javascript:rmf.openLinkNewTab();" rel="external nofollow noreferrer"><i class="fa-solid fa-external-link-alt"></i><span>在新标签页打开</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script src="/js/status_badge.js"></script><script defer src="/js/console_welcome.js"></script><script async data-pjax src="/js/bsz.build-20250729.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>