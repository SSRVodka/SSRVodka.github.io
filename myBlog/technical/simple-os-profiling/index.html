<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>简单的 OS 性能分析速查（运维场景） | SSRVodka's blog</title><meta name="author" content="SSRVodka,xhwpro@gmail.com"><meta name="copyright" content="SSRVodka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="预备知识库：计算机组成原理（如内存 Hierarchy、CPU 基本组成），操作系统原理（kernel&#x2F;user space、资源抽象、进程状态抽象等）。 以下是很零碎、经验化的思路，总结下来方便回顾。 1. CPU 分析业界主流的对于 CPU 忙碌情况的指标是 “Load Average”，定义为 处于可运行状态（running）和不可中断睡眠（uninterruptible sleep，通常在">
<meta property="og:type" content="article">
<meta property="og:title" content="简单的 OS 性能分析速查（运维场景）">
<meta property="og:url" content="https://blog.sjtuxhw.top/technical/simple-os-profiling/index.html">
<meta property="og:site_name" content="SSRVodka&#39;s blog">
<meta property="og:description" content="预备知识库：计算机组成原理（如内存 Hierarchy、CPU 基本组成），操作系统原理（kernel&#x2F;user space、资源抽象、进程状态抽象等）。 以下是很零碎、经验化的思路，总结下来方便回顾。 1. CPU 分析业界主流的对于 CPU 忙碌情况的指标是 “Load Average”，定义为 处于可运行状态（running）和不可中断睡眠（uninterruptible sleep，通常在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/simple-os-prof.jpg">
<meta property="article:published_time" content="2026-01-08T03:16:24.000Z">
<meta property="article:modified_time" content="2026-01-17T10:54:07.768Z">
<meta property="article:author" content="SSRVodka">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="IO">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/simple-os-prof.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/technical/simple-os-profiling/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/css/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '简单的 OS 性能分析速查（运维场景）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SSRVodka's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">84</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/simple-os-prof.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SSRVodka's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">简单的 OS 性能分析速查（运维场景）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">简单的 OS 性能分析速查（运维场景）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-08T03:16:24.000Z" title="发表于 2026-01-08 11:16:24">2026-01-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-17T10:54:07.768Z" title="更新于 2026-01-17 18:54:07">2026-01-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/technical/simple-os-profiling/#post-comment"><span class="waline-comment-count" data-path="/technical/simple-os-profiling/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>预备知识库：计算机组成原理（如内存 Hierarchy、CPU 基本组成），操作系统原理（kernel/user space、资源抽象、进程状态抽象等）。</p>
<p>以下是很零碎、经验化的思路，总结下来方便回顾。</p>
<h2 id="1-CPU-分析"><a href="#1-CPU-分析" class="headerlink" title="1. CPU 分析"></a>1. CPU 分析</h2><p>业界主流的对于 CPU 忙碌情况的指标是 “<strong>Load Average</strong>”，定义为 <strong><u>处于可运行状态（running）和不可中断睡眠（uninterruptible sleep，通常在等待 I/O）的进程数平均值</u></strong>。相关知识参见 <a href="#Appendix II. Review: About Process States">附录 II</a>。</p>
<p>Linux 上使用 <code>top</code> 类指令查看到的 load average 通常有 3 个数字，分别代表在过去 1 分钟、5 分钟、15 分钟内的 load average。</p>
<p>例：<code>load average: 2.35, 1.87, 1.25</code> 表示 1 分钟平均有 2.35 个进程在等待 CPU 或 I/O 资源（粗略认为）。</p>
<p>一般情况正常工作的理想状况 load average 约等于 CPU 核心数。load average 两倍于 CPU 核心数超过 5 分钟认为过载预警，4 倍于 CPU 核心数认为严重过载。</p>
<p>另一个指标是 CPU 利用率（CPU 时间分配比例）。也可通过 <code>top</code> 类指令观察到：</p>
<ul>
<li><code>%usr</code>（<code>us</code>）：用户进程占用 CPU 时间百分比（应用程序）</li>
<li><code>%nice</code>（<code>ni</code>）：手动调整过优先级的用户进程占 CPU 时间百分比</li>
<li><code>%sys</code>（<code>sy</code>）：内核进程占用 CPU 时间百分比（系统调用、中断处理）</li>
<li><code>%idle</code>（<code>id</code>）：CPU 空闲时间百分比</li>
<li><code>%iowait</code>（<code>wa</code>）：CPU 等待 I/O 完成的时间百分比（<strong>不是 CPU 被占用，而是空闲但有未完成的 I/O 请求</strong>）</li>
<li><code>%softit / %hardit</code>（<code>si / hi</code>）：处理软中断/硬中断的 CPU 时间占比</li>
<li><code>%steal</code>（<code>st</code>）：虚拟机等待物理 CPU 的时间百分比（仅虚拟化环境）</li>
</ul>
<p>此外 <code>vmstat</code> 指令能提供更多全局数据，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vmstat 1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 8  0      0 123456  78901 234567    0    0     0     0  123 4567 85 10  5  0  0</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>r (running)</strong>：等待 CPU 的进程数，<strong>持续 &gt;&gt; CPU 核心数</strong>表示 CPU 瓶颈</li>
<li><strong>b (blocked)</strong>：等待 I/O 的进程数，<strong>持续 &gt; 0</strong> 可能存在 I/O 瓶颈</li>
<li><strong>us + sy</strong>：<strong>持续 &gt; 90%</strong> 表示 CPU 资源紧张</li>
<li><strong>cs (context switch)</strong>：context switch 次数，<strong>&gt; 10 万/秒</strong> 可能存在资源竞争问题</li>
</ul>
<hr>
<p>排除 CPU 瓶颈的手段：</p>
<ol>
<li><p>确认 CPU 大致状况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top -H  # -H 线程级别统计</span><br><span class="line">htop</span><br><span class="line">vmstat 1  # interval 1s, procs/memory/swap/io/cpu 统计</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认哪个进程、哪些 CPU：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 1  # 按 CPU 核心统计</span><br><span class="line">pidstat -u 1     # -u 按进程 CPU 使用</span><br></pre></td></tr></table></figure>
</li>
<li><p>追踪进程内的瓶颈，需使用 <code>perf</code> 生成 flame graph；</p>
</li>
<li><p>想知道某些进程的 CPU 亲和性，或者处于性能测试的原因想将进程绑定到特定 CPU 上，可以使用 <code>taskset -c 0-3 ./app</code> 这样的方法；</p>
</li>
<li><p>想手动调整特定进程的优先级，可以使用这样的指令来告诉调度器：<code>nice -n -20 ./critical_app</code>（nice 值越小意味着越倾向于让出 CPU 资源，因此优先级越高，范围 -20 到 19，默认 0）；</p>
</li>
</ol>
<h2 id="2-内存分析"><a href="#2-内存分析" class="headerlink" title="2. 内存分析"></a>2. 内存分析</h2><p>内存是否到达“极限”的核心指标：<strong>可用内存</strong>（available）和 <strong>swap 使用率</strong>。</p>
<p>一般可以通过 <code>free</code> 指令查看全局的粗略信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">free -h</span></span><br><span class="line">              total    used    free  shared  buff/cache   available</span><br><span class="line">Mem:           62Gi    15Gi   1.2Gi   1.2Gi        45Gi        45Gi</span><br><span class="line">Swap:          16Gi   166Mi    16Gi</span><br></pre></td></tr></table></figure>
<p>注：<code>shared</code> 表示 tmpfs 等共享内存使用量</p>
<blockquote>
<p>[!IMPORTANT]</p>
<p>注意可用内存：<strong><u><code>avail = free + buff/cache - reclaimable</code></u></strong>。</p>
<p>因此在判断内存瓶颈时，<strong>不能只看 <code>free</code> 命令的 free 列</strong>，因为 Linux 会充分利用空闲内存作为缓存。</p>
</blockquote>
<p>除了 <code>free</code>，<code>vmstat</code> 也能查看内存相关稍详细一点的全局信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vmstat 1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0 166400 123456  78901 234567    0    0    12    34   56   78 10  5 85  0  0</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>swpd</strong>：已使用的交换分区大小（KB）</li>
<li><strong>si</strong>（swap in）：每秒从交换分区读入内存的数据量（KB/s）</li>
<li><strong>so</strong>（swap out）：每秒从内存写入交换分区的数据量（KB/s）</li>
<li><strong>in</strong>（interrupt）：每秒发生的中断总数（page fault 中断包含其中）</li>
<li><strong>关键阈值</strong>：<strong>si + so &gt; 10MB/s 持续 5 秒以上</strong>，表示存在严重的 thrashing，working set 大于现有内存资源。</li>
</ul>
<p>如果想了解更详细关于 page fault 的情况来掌握内存使用情况，不止需要了解 swap，还需要了解 page fault 频率等等。</p>
<p>通过 <code>sar</code> 指令查看 page 的交换和缺页异常的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sar -W 1</span></span><br><span class="line">Linux 5.4.0-91-generic (server)     01/17/2026     _x86_64_    (8 CPU)</span><br><span class="line"></span><br><span class="line">02:30:01 PM  pswpin/s pswpout/s</span><br><span class="line">02:30:02 PM      0.00      0.00</span><br><span class="line"></span><br><span class="line">02:30:01 PM pgpgin/s pgpgout/s   fault/s  majflt/s</span><br><span class="line">02:30:02 PM    123.00    456.00   789.00      0.00</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>pswpin/s, pswpout/s</strong>：每秒交换入/出的页数</li>
<li><strong>fault/s</strong>：每秒 Page Fault 总数</li>
<li><strong>majflt/s</strong>：每秒 Major Page Fault 数量</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/pf.png" width="450px" /></p>
<hr>
<p>排除内存瓶颈的手段：</p>
<ol>
<li><p>使用 <code>top</code> / <code>free</code> / <code>vmstat</code> / <code>sar</code> 类型的指令查看全局的内存主存、swap 使用情况，包括占用/增速；</p>
</li>
<li><p>定位哪个进程正在造成这个问题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按 RSS(Resident Set Size) 排序</span></span><br><span class="line">ps -eo pid,user,rss,cmd --sort=-rss | head -10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-r 显示内存统计信息</span></span><br><span class="line">pidstat -r 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>针对这个进程了解内存使用情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监控特定进程的内存增长</span></span><br><span class="line">watch -n 1 &quot;ps -p &lt;pid&gt; -o rss,vsz,cmd&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看进程的详细内存映射</span></span><br><span class="line">cat /proc/&lt;pid&gt;/smaps | less</span><br></pre></td></tr></table></figure>
</li>
<li><p>更细粒度（进程甚至线程内部）的判断则需应用相关的调优手段。例如对 Java 应用可以通过 JVM 提供的 perf 工具（如 <code>jstat/jstack/jmap</code> 等）。</p>
</li>
</ol>
<blockquote>
<p>[!NOTE]</p>
<p>值得关注的是，在粒度细化到针对特定进程时，我们还有一些指标来衡量内存使用情况（下面表格为 LLM 生成内容）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>内存指标</strong></th>
<th><strong>定义</strong></th>
<th><strong>是否包含共享内存</strong></th>
<th><strong>是否包含 Swap</strong></th>
<th><strong>使用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RSS</strong> (Resident Set Size)</td>
<td>驻留在物理内存中的进程内存大小</td>
<td>✅ 完整计入</td>
<td>❌ 仅物理内存</td>
<td>快速查看进程内存占用</td>
</tr>
<tr>
<td><strong>VSZ</strong> (Virtual Memory Size)</td>
<td>进程虚拟地址空间总大小</td>
<td>✅ 完整计入</td>
<td>✅ 包含</td>
<td>了解进程地址空间需求</td>
</tr>
<tr>
<td><strong>PSS</strong> (Proportional Set Size)</td>
<td>RSS + 按比例分摊的共享内存</td>
<td>✅ 按进程数均摊</td>
<td>❌ 仅物理内存</td>
<td><strong>精确计算进程真实内存开销</strong></td>
</tr>
<tr>
<td><strong>USS</strong> (Unique Set Size)</td>
<td>进程独占的物理内存大小</td>
<td>❌ 仅独占部分</td>
<td>❌ 仅物理内存</td>
<td>分析内存泄漏、优化独占内存</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<h2 id="3-磁盘-I-O"><a href="#3-磁盘-I-O" class="headerlink" title="3. 磁盘 I/O"></a>3. 磁盘 I/O</h2><p>硬盘是否到达“极限”的指标：<strong><u>IOPS</u></strong> 和 <strong><u>吞吐量</u></strong>；</p>
<ul>
<li><strong>IOPS 极限</strong>：每秒能处理的请求数（一般小文件随机读写瓶颈）；</li>
<li><strong>Throughput 极限</strong>：每秒能传输的数据量（一般大文件顺序读写瓶颈）；</li>
</ul>
<blockquote>
<p>[!IMPORTANT]</p>
<p>在判断一个硬盘到达极限时应该遵循指标分析，方便后续优化工作。</p>
<p>另外 IOPS 还受制于 CPU 性能、Throughput 还受制于内存性能（看具体场景）。</p>
<p>这套指标不仅适用于存储 I/O，还适用于网络 I/O。</p>
</blockquote>
<p>使用 <code>iostat -x [interval]</code> 观察硬盘的指标（<code>-x</code> 打印 extended 信息，<code>-z</code> 不打印为 0 的数据）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Device      r/s     w/s   rkB/s    wkB/s  %util</span><br><span class="line">nvme0n1   48000   12000  192000   48000   85.00</span><br></pre></td></tr></table></figure>
<p><code>r/s</code>（读 IOPS）、<code>w/s</code>（写 IOPS）之和是 IOPS 数据；</p>
<p><code>rkB/s</code>（读吞吐量）、<code>wkB/s</code>（写吞吐量）之和是 Throughput 数据；</p>
<hr>
<ul>
<li><p><code>iostat</code> 的 <code>%util</code> 指标无法直接判断硬盘 I/O 极限。因为 <code>%util</code> 的定义是 “磁盘忙碌时间占比”。</p>
<ul>
<li><p>例：该磁盘 1 秒内 0.98 秒在处理请求，则当前 <code>%util</code> 值为 98%；</p>
</li>
<li><p>对机械硬盘（HDD）：每次只能处理一个请求（磁头只有一个），<code>%util</code> 为 100% 意味着满负荷（即到达 I/O 极限）；</p>
</li>
<li><p>对现代 SSD / NVMe：多 channels 设计，可并行处理上百请求，<code>%util</code> 为 100% 代表每时每刻都不是完全空闲的；</p>
<blockquote>
<p>一个 NVMe 盘能同时处理 128 个请求，现在有 10 个请求一直在队列中处理，<code>%util</code> 为 100%，但是 90% I/O 能力 not fully utilized；</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>iostat</code> 的 <code>await</code> 指标能间接判断硬盘的 I/O 极限。因为 <code>await</code> 的定义是请求从发出到完成的平均时间（即平均周转时间 ATT），单位毫秒；</p>
<p><strong><u><code>await</code> 异常升高（相对于同型号正常值）证明当前 workload 接近 I/O 极限</u></strong>。注意不同磁盘的 baseline（正常值基准）不一样。</p>
<p>可以使用 <code>fio</code> 工具测试磁盘的 IOPS /  吞吐量极限：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测随机读 IOPS</span></span><br><span class="line">fio --name=randread --ioengine=libaio --direct=1 --bs=4k \</span><br><span class="line">    --iodepth=64 --rw=randread --size=1G --runtime=30</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测顺序写吞吐量</span></span><br><span class="line">fio --name=seqwrite --ioengine=libaio --direct=1 --bs=1m \</span><br><span class="line">    --iodepth=32 --rw=write --size=1G --runtime=30</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>排除硬盘压力/瓶颈的手段：</p>
<ol>
<li><p>确认是否是 I/O 问题：<code>top</code> 选项的 <code>wa%</code>（<strong><u>iowait percentage</u></strong>）指标：15%-20% 记为高占用。</p>
</li>
<li><p>定位硬盘的具体问题，哪块设备、什么瓶颈：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>哪个进程正在造成这个问题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过检查 kernel 提供的 /proc 中的 I/O 统计信息</span></span><br><span class="line">sudo iotop -oP    # -o 仅正在执行 I/O 操作的进程；-P 仅进程（不包括默认显示的线程）</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sysstat 工具包一部分</span></span><br><span class="line">pidstat -d 1    # -d I/O 统计信息，interval 1s 采样间隔</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个进程正在读写什么文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -p &lt;pid&gt;</span><br><span class="line">strace -p &lt;pid&gt; -e trace=read,write,open -f</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Appendix-I-场景实战"><a href="#Appendix-I-场景实战" class="headerlink" title="Appendix I. 场景实战"></a>Appendix I. 场景实战</h2><h3 id="Scene-A-不可中断睡眠"><a href="#Scene-A-不可中断睡眠" class="headerlink" title="Scene A. 不可中断睡眠"></a>Scene A. 不可中断睡眠</h3><p>关于是否可中断睡眠的辨析：</p>
<ul>
<li>块设备操作，如磁盘读写操作涉及复杂的硬件交互，必须保证操作的完整性，所以进程操作时一定位于不可中断睡眠状态；<ul>
<li>错误。D/S 区分与“是不是磁盘 I/O” 无关。有些 I/O 操作需要 D 状态是因为 Kernel 打断后没法恢复状态/ roll back，与硬件性质也无关。</li>
</ul>
</li>
<li>观察到与 NFS 相关的大量进程长期进入 D 状态 是没关系的，因为 NFS 锁需要不可中断睡眠来保证操作完整性。<ul>
<li>半对，应该检查具体原因。NFS 历史上会导致很多 D 状态是设计缺陷，现在的 kernel 可以尽量避免出现 D 状态；</li>
</ul>
</li>
<li>使用不可中断睡眠的其中一个原因就是，kernel 在执行 nested signal handlers 时会出问题。<ul>
<li>错误。不可中断睡眠与内核处理嵌套信号句柄无关。本质上就是 Signals 默认会强制退出进程睡眠状态，如果 kernel 不能在此时 abort 操作（回到用户态为时尚早），那么使用 S 就是不安全的，这个进程需要 D 状态。</li>
</ul>
</li>
</ul>
<h3 id="Scene-B-CPU-瓶颈"><a href="#Scene-B-CPU-瓶颈" class="headerlink" title="Scene B. CPU 瓶颈"></a>Scene B. CPU 瓶颈</h3><p>下面的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uptime</span></span></span><br><span class="line"> 14:30:01 up 10 days,  3:22,  2 users,  load average: 12.45, 8.76, 4.32</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mpstat -P ALL 1</span></span><br><span class="line">Linux 5.4.0-91-generic (server)   01/17/2026  _x86_64_  (8 CPU)</span><br><span class="line">02:30:02 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">02:30:03 PM  all   85.21    0.00    9.87    0.00    0.00    4.92    0.00    0.00    0.00    0.00</span><br><span class="line">02:30:03 PM    0   99.00    0.00    1.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">02:30:03 PM    1   98.00    0.00    2.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意到：</p>
<ul>
<li>这是一个 8 核机器，一分钟内 load average 说明存在 CPU 资源压力；</li>
<li><code>%usr = 85.21%</code> 表明是<strong>用户进程</strong>导致的 CPU 压力；</li>
<li>接下来需要使用 <code>pidstat -u 1</code> 或其他指令查看具体进程使用情况；</li>
</ul>
<h3 id="Scene-C-I-O-等待会影响-Load-Average"><a href="#Scene-C-I-O-等待会影响-Load-Average" class="headerlink" title="Scene C. I/O 等待会影响 Load Average"></a>Scene C. I/O 等待会影响 Load Average</h3><p>下面的场景：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vmstat 1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  5      0  45678  12345 678901    0    0  2345  6789  100  200  5 10  0 85  0</span><br></pre></td></tr></table></figure>
<p>看起来 <code>id=0%</code> 是 CPU 资源受限吗？并非，<strong><code>wa=85%</code></strong> 说明 CPU 有 85% 时间在等待 I/O 完成，很可能是 I/O 瓶颈。</p>
<p>注意 <strong><code>bi=2345</code>、<code>bo=6789</code></strong>：块设备每秒读写次数高，需要结合 <code>iostat</code> 进一步分析 I/O 瓶颈问题。</p>
<h3 id="Scene-D-内存是否存在压力"><a href="#Scene-D-内存是否存在压力" class="headerlink" title="Scene D. 内存是否存在压力"></a>Scene D. 内存是否存在压力</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">free -h</span></span><br><span class="line">              total    used    free  shared  buff/cache   available</span><br><span class="line">Mem:           62Gi    58Gi   1.2Gi   1.5Gi        3.2Gi        2.1Gi</span><br><span class="line">Swap:          16Gi    12Gi    4.0Gi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vmstat 1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 4  2 12582912 123456  78901 234567  8192 12288   123   456  789 1011 25 15 40 20  0</span><br></pre></td></tr></table></figure>
<p><strong>available 仅 2.1Gi（总内存 62Gi 的 3.4%）</strong>，远低于 10% 的健康阈值，存在内存问题。</p>
<p><code>wa=20%</code> 说明 CPU 有 20% 时间在等待 I/O 完成，但另外的数据证明了并非用户态程序的 I/O：<strong><code>si=8192KB/s</code>, <code>so=12288KB/s</code></strong>，持续的高 swap I/O 活动证明可能存在大规模的 Thrashing 现象，说明系统存在严重物理内存短缺问题，需要立即定位进程并查找原因：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pidstat -r 1</span></span><br><span class="line">Linux 5.4.0-91-generic (server)     01/17/2026     _x86_64_    (8 CPU)</span><br><span class="line"></span><br><span class="line">02:35:01 PM   UID       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command</span><br><span class="line">02:35:02 PM  1000      1234    150.00      5.00 4500000 3200000   5.00  java</span><br><span class="line">02:35:02 PM  1000      5678    200.00     15.00 2000000 1800000   2.80  python</span><br><span class="line">02:35:02 PM     0       999     50.00     20.00 1500000 1200000   1.90  mysqld</span><br></pre></td></tr></table></figure>
<p>发现 PID 为 1234 的 Java 应用存在持续的 major page fault，应使用 JVM 相关工具对业务逻辑进行进一步排查。</p>
<h3 id="Scene-E-磁盘-I-O-检查"><a href="#Scene-E-磁盘-I-O-检查" class="headerlink" title="Scene E. 磁盘 I/O 检查"></a>Scene E. 磁盘 I/O 检查</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iostat -x 1</span></span><br><span class="line">Device      r/s     w/s  r_await w_await  aqu-sz  %util</span><br><span class="line">nvme0n1   15000    8000     0.08    0.12    1.84  99.80</span><br><span class="line">sda         200     150    45.32   62.18   16.43  98.50</span><br></pre></td></tr></table></figure>
<p>如上所示，可以发现：</p>
<ul>
<li><code>nvme0n1</code> 设备并不存在接近极限的问题：await 约 0.1 ms，队列长度 1.84；</li>
<li><code>sda</code> 设备达到极限：await 高达 45-62 ms，队列积压 16 个请求；</li>
</ul>
<h3 id="Scene-F-磁盘-I-O-瓶颈估算"><a href="#Scene-F-磁盘-I-O-瓶颈估算" class="headerlink" title="Scene F. 磁盘 I/O 瓶颈估算"></a>Scene F. 磁盘 I/O 瓶颈估算</h3><p>某 NVMe 硬盘标称 50 万 IOPS、3 GB/s 吞吐。估计：</p>
<ul>
<li><p>“数据库大量随机读写，4KB 小块” 时的场景：先达到 IOPS 极限（50w × 4KB = 2GB/s），此时吞吐量未达上限；</p>
</li>
<li><p>“视频转码，顺序读写超大视频文件” 时的场景：大概率先达到吞吐量上限（3 GB/s 时 IOPS 仅数千）；</p>
</li>
</ul>
<h2 id="Appendix-II-Review-About-Process-States"><a href="#Appendix-II-Review-About-Process-States" class="headerlink" title="Appendix II. Review: About Process States"></a>Appendix II. Review: About Process States</h2><p><strong>经典操作系统理论中的进程状态</strong>（Created/Ready/Running/Blocked/Terminated）是一个<strong>抽象模型</strong>，描述了进程生命周期的基本阶段。而 <strong>Linux 进程状态</strong>（如下）是<strong>具体工程实现</strong>，提供了更细致和实际的状态描述。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S Interruptible sleep (waiting for an event to complete)</span><br><span class="line">D Uninterruptible sleep (usually IO)</span><br><span class="line">R Running or runnable (on run queue)</span><br><span class="line">T Stopped, either by a job control signal or because it is being traced.</span><br><span class="line">W paging (not valid since the 2.6.xx kernel)</span><br><span class="line">X dead (should never be seen)</span><br><span class="line">Z Defunct (&quot;zombie&quot;) process, terminated but not reaped by its parent.</span><br></pre></td></tr></table></figure>
<p>二者映射关系如下：</p>
<ul>
<li><p><strong>Ready + Running -&gt; R</strong></p>
<ul>
<li>理论中的 Ready（就绪）和 Running（运行）状态在 Linux 中合并为 R 状态，这是因为在 Linux 调度器实现中，这两个状态在内核数据结构层面难以严格区分；</li>
<li>R 表示 “Running or runnable (on run queue)”，即要么正在 CPU 上执行，要么在 run queue 中等待 CPU；</li>
</ul>
</li>
<li><p><strong>Blocked -&gt; S + D</strong></p>
<ul>
<li><p>理论中的 Blocked（阻塞）状态在 Linux 中细化为两种：</p>
<ul>
<li><strong>S (Interruptible sleep)</strong>: 可中断睡眠，等待事件完成，可以被信号唤醒；</li>
<li><strong>D (Uninterruptible sleep)</strong>: 不可中断睡眠，通常是等待 I/O 操作完成，不能被 OS 的信号中断；</li>
</ul>
</li>
<li><p>这种细分反映了实际系统中阻塞的不同性质和处理需求。</p>
<p>区分的根本意义辨析：<strong>D state is not primarily about protecting “critical kernel processes.”</strong></p>
<p>It is about <strong>protecting specific *wait contexts*</strong> where interruption would cause:</p>
<ul>
<li>resource leaks;</li>
<li>inconsistent kernel state;</li>
<li>or impossible rollback;</li>
</ul>
<p>A task enters <strong>D</strong> when it sleeps <strong>while holding resources that cannot be safely released or unwound if a signal arrives</strong>.</p>
<p><strong><u>即：确保某些关键上下文不能被打断 (D)</u></strong>，同时顺便保证系统性能 (S)，与 I/O 或锁无关，只与 Kernel 有没有能力在 signal 打断后 context switch 原样恢复回去有关。举例场景：</p>
<ol>
<li><p>I/O Subsystem 的特殊性：</p>
<ul>
<li><p>虽然：Disk I/O is <strong>not inherently uninterruptible</strong>.</p>
</li>
<li><p>但是：Many I/O paths <em>used to</em> require D because they <strong>could not be safely rolled back</strong>, <strong><u>NOT</u></strong> because of “hardware complexity”.</p>
</li>
</ul>
</li>
<li><p>Kernel Signal 的正确性（需要 D）：防止在 kernel 关键路径上处理信号导致内核数据结构不一致、避免在持有重要锁时被中断导致死锁（持锁顺序问题）、确保资源清理工作能够完整执行等。这里需要 <strong>avoids partial execution states</strong>.</p>
</li>
<li><p>存在很多可以安全中断的等待（需要 S），如等待用户输入、等待定时器、等待非关键资源；</p>
</li>
<li><p>并不是所有持并发资源锁等待 / 等 IO 资源的进程都需要是 D 状态。甚至这么说：绝大多数持锁/或者等 IO 的进程（如 <code>mutex_lock</code>, <code>rwsemaphore</code>, <code>futex waits</code>, <code>pipe reads</code>, <code>socker rw</code>, <code>poll/select/epoll</code>, 绝大多数文件系统操作等）都不需要进入 D 状态。进入 D 状态的评判标准：</p>
<ul>
<li><p>The task must sleep (cannot spin).</p>
</li>
<li><p><strong>If a signal arrived at that sleep point, the kernel could not safely abort the operation and unwind all held state.</strong></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>Terminated -&gt; Z + X</strong></p>
<ul>
<li><strong>Z (Zombie)</strong>: 进程已终止但父进程尚未调用 <code>wait()</code> 回收其资源；</li>
<li><strong>X (Dead)</strong>: 完全终止状态，通常不会在 ps 这样的命令中看到；</li>
<li>理论模型中的 Terminated 在 Linux 实现中被细化为资源回收的不同阶段；</li>
</ul>
</li>
<li><p><strong>Linux 特有状态</strong></p>
<ul>
<li><strong>T (Stopped)</strong>: “Stopped, either by a job control signal or because it is being traced”，这个状态在经典理论模型中没有直接对应，可以看作是 Blocked 的一种特殊情况，被 shell / 调试工具等控制的进程；</li>
<li><strong>W (Paging)</strong>: 在 Linux 2.6.xx 内核后已不再有效；</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SSRVodka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/technical/simple-os-profiling/">https://blog.sjtuxhw.top/technical/simple-os-profiling/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SSRVodka's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/IO/">IO</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/simple-os-prof.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/technical/ros2ohos-plugins-fail/" title="ROS2 迁移到 OpenHarmony 平台后无法加载 Plugins 动态链接库的解决方案"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ohos-ros2nav2-fix.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ROS2 迁移到 OpenHarmony 平台后无法加载 Plugins 动态链接库的解决方案</div></div><div class="info-2"><div class="info-item-1">越过交叉编译的重重阻碍，我在将 ROS2 及其生态迁移到原生 OpenHarmony 平台上的过程中遇到了一个比较大的问题：ROS2 似乎无法加载插件形态的动态链接库！就是说，launch 一个 ROS2 应用（需要动态链接库）本身是可以的，但是这个 ROS2 应用如果使用到了动态链接库插件（一般通过 ROS2 的 class_loader 组件间接加载）就出问题了。 TL; DR:（太长不看版）最终解决方案请参见 “Final Solution” 一节；如果想看问题根源请参见 “问题根源” 一节。 下文将详细叙述调试经过，供读者思考、相互学习。举个实际迁移调试过程中的例子。下面是我编写的问题描述：  我在 OpenHarmony 上运行迁移的 Navigation2 框架时遇到一些问题，加载的 navigation2 相关的动态链接库出现加载失败的问题。 运行的应用环境是任意一个使用 navigation2 的 ROS 应用，例如 B 站鱼香肉丝 UP 开发的 fishbot 机器人的 navigation2.launch.py（删除 rviz2...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/review/io-mul-more/" title="更多的 I&#x2F;O 多路复用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/io-mult-more.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-01</div><div class="info-item-2">更多的 I&#x2F;O 多路复用</div></div><div class="info-2"><div class="info-item-1">最近总结了一些 OS I/O 多路复用的知识。之前对 I/O Multiplexer 的认知还停留在 select 系统调用，现在是时候扩展一下视野了。 1. 从 Socket 模型开始Socket 作为一个应用层和传输层间的的抽象，支持网络层 IPv4 / IPv6，以及传输层 TCP / UDP。 双方要进行网络通信前，各自需要创建一个 Socket。 如果是基于 UDP 的套接字：  如果是基于 TCP 的套接字：  以基于 TCP 的套接字为例，首先使用 socket() 创建一个网络协议为 IPv4，以及传输协议为 TCP 的 Socket 结构体，然后使用 bind() 绑定 Server IP 和进程服务端口 port，并监听 listen() 在该端口上（listen 仅改变状态）；  之所以需要指定 Server IP，是因为一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址。Socket 允许指定监听的网卡。0.0.0.0 表示监听所有的 network interfaces； port 即为传输层信息，对应指定线程的服务。  Server 端...</div></div></div></a><a class="pagination-related" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</div></div><div class="info-2"><div class="info-item-1">特权级切换与内存管理这两块知识一直是 OS 的极其极其重要的组成部分：特权级切换是 OS 上下文切换和调度的基石，而内存管理则是一切隔离性（进程抽象）、资源可用性的基石。可惜对于初学者而言太过庞大，并且它们通常相互涉及，以至于总是掌握不了全貌。 笔者想从尽可能全面的视角记录总结一下它们究竟在做什么，方便日后查阅笔记、快速理解，因此不会过于深入细节（例如不会介绍 Buddy System 和 SLUB 机制的具体内容）。 最后我们将总结并运用已经了解的知识，讨论一下全局视角下的 OS 内核栈。 如有错误，欢迎读者勘误斧正。  下面内容将以 AArch64 为例。 建议复习：通用寄存器 x0-x30、PC 程序计数器、4 个栈寄存器 SP_ELx、3 个异常链接器 ELR_ELx（从 1 开始）、3 个程序状态寄存器 SPSR_ELx、2 个页表基地址寄存器 TTBRx_EL1（注意只有 EL1 级别）、TCR/SCTLR/SCR/TPIDR/MPIDR 这些常见寄存器的用途。  A....</div></div></div></a><a class="pagination-related" href="/technical/hilog-paper/" title="OpenHarmony Hilog 架构趣读"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/hilog-paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-29</div><div class="info-item-2">OpenHarmony Hilog 架构趣读</div></div><div class="info-2"><div class="info-item-1">最近看到一篇讨论 OpenHarmony Hilog 日志子系统的设计的论文，遂进行了一番阅读。该论文发表在软件学报上。 摘要 分析当今主流日志系统的技术架构和优缺点； 基于 OpenHarmony 操作系统的异构设备互联特性，设计 HiLog 日志系统模型规范； 设计并实现第 1 个面向 OpenHarmony 的日志系统 HiLog, 并贡献到 OpenHarmony 主线； 对 HiLog 日志系统的关键指标进行测试和对比试验；  实现的 HiLog 具有以下特征：  基础性能：日志写入阶段吞吐量分别为 1 500 KB/s 和 700 KB/s，吞吐量相对 Android Log 提升 114%； 日志持久化：压缩率 3.5%，丢包率...</div></div></div></a><a class="pagination-related" href="/technical/xpc-paper/" title="论文阅读 - XPC: Architectural Support for Secure and Efficient Cross Process Call"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/xpc-paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-28</div><div class="info-item-2">论文阅读 - XPC: Architectural Support for Secure and Efficient Cross Process Call</div></div><div class="info-2"><div class="info-item-1">这是一篇 2019 年的关于微内核 IPC 性能优化的文章。 摘要微内核有很多引人注目的 features，例如 安全性、容错性、模块化，以及可定制性，这些特性近期在学术界和工业界又再次掀起了一股研究热潮（including seL4, QNX and Google’s Fuchsia OS）。  Google’s Fuchsia’s kernel (called Zircon)  但是 IPC（进程间通信）作为微内核的 阿喀琉斯之踵，仍然是导致微内核 OS 总体性能较低的主要因素之一。同时 IPC 在宏内核中也扮演者很重要的角色，例如 Android Linux，其中的移动端程序会经常和用户态服务通过 IPC 通信。所以优化 IPC 自然是一个很重要的课题。 之前学界对 IPC 在软件层面的优化都绕不开 Kernel，因为 IPC 在这方面的主要开销就是 域切换（domain switch）和消息复制/重映射（message copying/remapping）；在硬件层面的优化方法主要是 给内存和能力打...</div></div></div></a><a class="pagination-related" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/sc.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</div></div><div class="info-2"><div class="info-item-1">这是一篇 2025 年的关于软硬协同的安全容器设计的文章。 0. Overview虚拟机级别的容器中，每个容器运行在虚拟机虚拟出的独立内核上，因此隔离性很强。但其依赖于通用虚拟机虚拟出的虚拟化硬件，与 OS 级别的容器相比，会导致不可忽略的性能开销。而在嵌套虚拟化场景下，secure container 运行在虚拟机中，这个性能的 gap 会显著地扩大。 本篇文章基于两个角度提出容器内核隔离（CKI），一个软硬协调的高效机密容器设计。  首先，Protection Keys for Supervisor（PKS）可以帮助我们构建一个新的权限级别，用于在 Host Kernel 中安全地配置多个容器内核，而不涉及 non-root ring 0（Intel 中的 Guest Kernel 所处级别）； 其次，secure container 使用的通用虚拟化技术提供很多容器实际隔离并不需要的特性，例如二阶段页表翻译，这引入了可以避免的性能开销；  因此容器内核隔离技术在跑容器内核时：  避免使用虚拟化硬件，并移除不必要的虚拟化技术（像二阶段地址翻译）。它使用 PKS...</div></div></div></a><a class="pagination-related" href="/technical/tty-subsystem/" title="浅析 TTY Subsystem"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/tty.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-15</div><div class="info-item-2">浅析 TTY Subsystem</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW References: 参考文献见文章末尾。 本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！   为什么讨论 TTY在 Linux 系统中，TTY 是一个相当有名的子系统。当你输入 ls -l /dev 的时候，你能看到许许多多以 tty 为前缀的字符设备，这就是对 TTY 子系统在文件上的抽象。 虽然我们无论是命令行还是 GUI 使用 Linux 的时候，TTY 似乎对我们无感，但是，当我因为一个小问题在互联网上查了很多关于 TTY 资料，却仍然很难找到一个完整的知识资料的时候，我发现这个 TTY 子系统的重要性被很多人忽视了。在整理了相关资料后，我愿意相信，搞清楚 Linux 的 TTY 子系统，属实是入门 Linux 系统的必由之路。 尤其是，如果你想要写一些更接近 Linux 底层的、I/O interactive 方面的应用程序，那么 TTY 的知识就显得更加重要。 前段时间，我在写 CSAPP 的 shell lab，工作量不大所以很快就完成了。但是文档里有句话让我不解，“这个 tiny shell...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="xhw-card-content"><div class="xhw-avatar-group"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="xhw-sticker"><img class="sticker-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/sad.avif" alt="emoji-sticker"/></div></div></div><div class="author-info-name">SSRVodka</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">84</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span><a class="service-status-badge" id="serviceStatusBadge" href="https://status.sjtuxhw.top" rel="external nofollow noreferrer" target="_blank"><span class="status-loading"></span><span class="status-text">loading...</span></a></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-CPU-%E5%88%86%E6%9E%90"><span class="toc-text">1. CPU 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-text">2. 内存分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%A3%81%E7%9B%98-I-O"><span class="toc-text">3. 磁盘 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Appendix-I-%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%88%98"><span class="toc-text">Appendix I. 场景实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scene-A-%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E7%9D%A1%E7%9C%A0"><span class="toc-text">Scene A. 不可中断睡眠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scene-B-CPU-%E7%93%B6%E9%A2%88"><span class="toc-text">Scene B. CPU 瓶颈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scene-C-I-O-%E7%AD%89%E5%BE%85%E4%BC%9A%E5%BD%B1%E5%93%8D-Load-Average"><span class="toc-text">Scene C. I&#x2F;O 等待会影响 Load Average</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scene-D-%E5%86%85%E5%AD%98%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%8E%8B%E5%8A%9B"><span class="toc-text">Scene D. 内存是否存在压力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scene-E-%E7%A3%81%E7%9B%98-I-O-%E6%A3%80%E6%9F%A5"><span class="toc-text">Scene E. 磁盘 I&#x2F;O 检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scene-F-%E7%A3%81%E7%9B%98-I-O-%E7%93%B6%E9%A2%88%E4%BC%B0%E7%AE%97"><span class="toc-text">Scene F. 磁盘 I&#x2F;O 瓶颈估算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Appendix-II-Review-About-Process-States"><span class="toc-text">Appendix II. Review: About Process States</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/simple-os-profiling/" title="简单的 OS 性能分析速查（运维场景）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/simple-os-prof.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单的 OS 性能分析速查（运维场景）"/></a><div class="content"><a class="title" href="/technical/simple-os-profiling/" title="简单的 OS 性能分析速查（运维场景）">简单的 OS 性能分析速查（运维场景）</a><time datetime="2026-01-08T03:16:24.000Z" title="发表于 2026-01-08 11:16:24">2026-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/ros2ohos-plugins-fail/" title="ROS2 迁移到 OpenHarmony 平台后无法加载 Plugins 动态链接库的解决方案"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ohos-ros2nav2-fix.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ROS2 迁移到 OpenHarmony 平台后无法加载 Plugins 动态链接库的解决方案"/></a><div class="content"><a class="title" href="/technical/ros2ohos-plugins-fail/" title="ROS2 迁移到 OpenHarmony 平台后无法加载 Plugins 动态链接库的解决方案">ROS2 迁移到 OpenHarmony 平台后无法加载 Plugins 动态链接库的解决方案</a><time datetime="2025-12-18T12:49:17.000Z" title="发表于 2025-12-18 20:49:17">2025-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/embodied-paper-202511/" title="具身智能论文速读 2025年11月"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/embodied-paper-vla.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="具身智能论文速读 2025年11月"/></a><div class="content"><a class="title" href="/technical/embodied-paper-202511/" title="具身智能论文速读 2025年11月">具身智能论文速读 2025年11月</a><time datetime="2025-11-15T02:25:05.000Z" title="发表于 2025-11-15 10:25:05">2025-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/chat/web-search-mcps/" title="Survey: 有哪些好用的用于网络搜索的 MCP Servers?"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ws-mcp.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Survey: 有哪些好用的用于网络搜索的 MCP Servers?"/></a><div class="content"><a class="title" href="/chat/web-search-mcps/" title="Survey: 有哪些好用的用于网络搜索的 MCP Servers?">Survey: 有哪些好用的用于网络搜索的 MCP Servers?</a><time datetime="2025-08-28T15:56:12.000Z" title="发表于 2025-08-28 23:56:12">2025-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/2025-ccf/" title="CCF 2025 会议笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ccf-2025.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CCF 2025 会议笔记"/></a><div class="content"><a class="title" href="/technical/2025-ccf/" title="CCF 2025 会议笔记">CCF 2025 会议笔记</a><time datetime="2025-08-03T03:36:45.000Z" title="发表于 2025-08-03 11:36:45">2025-08-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2026 By SSRVodka  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-image"><a class="rightMenu-item" href="javascript:rmf.copyImageUrl();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制图片地址</span></a><a class="rightMenu-item" href="javascript:rmf.downloadImage();" rel="external nofollow noreferrer"><i class="fa-solid fa-download"></i><span>保存图片</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-link"><a class="rightMenu-item" href="javascript:rmf.copyLink();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制链接地址</span></a><a class="rightMenu-item" href="javascript:rmf.openLinkNewTab();" rel="external nofollow noreferrer"><i class="fa-solid fa-external-link-alt"></i><span>在新标签页打开</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script src="/js/status_badge.js"></script><script defer src="/js/console_welcome.js"></script><script async data-pjax src="/js/bsz.build-20250729.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>