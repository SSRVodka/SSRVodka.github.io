<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Introduction to Rabbit MQ | SJTU-XHW's blog</title><meta name="author" content="SJTU-XHW,sjtuxhw12345@sjtu.edu.cn"><meta name="copyright" content="SJTU-XHW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chapter 0. 背景0.1 同步消息和异步消息微服务架构下存在很多服务间相互调用的情况。 我们知道可以通过 OpenFeign 的方式来获取远程服务的响应，但是 OpenFeign 的远程调用是同步的，其优点是同步调用时效强，等待结果返回。但同时会导致：  代码可扩展性差。 性能堪忧。相较于相同项目实现的单体架构，同步的微服务调用方式会多出网络等待时间。  于是我们需要异步调用的方式，这里使">
<meta property="og:type" content="article">
<meta property="og:title" content="Introduction to Rabbit MQ">
<meta property="og:url" content="https://blog.sjtuxhw.top/technical/rabbit-mq/index.html">
<meta property="og:site_name" content="SJTU-XHW&#39;s blog">
<meta property="og:description" content="Chapter 0. 背景0.1 同步消息和异步消息微服务架构下存在很多服务间相互调用的情况。 我们知道可以通过 OpenFeign 的方式来获取远程服务的响应，但是 OpenFeign 的远程调用是同步的，其优点是同步调用时效强，等待结果返回。但同时会导致：  代码可扩展性差。 性能堪忧。相较于相同项目实现的单体架构，同步的微服务调用方式会多出网络等待时间。  于是我们需要异步调用的方式，这里使">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/rabbit.jpeg">
<meta property="article:published_time" content="2024-06-01T08:31:33.000Z">
<meta property="article:modified_time" content="2024-10-25T13:59:32.035Z">
<meta property="article:author" content="SJTU-XHW">
<meta property="article:tag" content="MQ">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="Microservice">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/rabbit.jpeg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/technical/rabbit-mq/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Introduction to Rabbit MQ',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-25 21:59:32'
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SJTU-XHW's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">63</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/rabbit.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SJTU-XHW's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Introduction to Rabbit MQ</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Introduction to Rabbit MQ</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-01T08:31:33.000Z" title="发表于 2024-06-01 16:31:33">2024-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T13:59:32.035Z" title="更新于 2024-10-25 21:59:32">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/technical/rabbit-mq/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chapter-0-背景"><a href="#Chapter-0-背景" class="headerlink" title="Chapter 0. 背景"></a>Chapter 0. 背景</h1><h2 id="0-1-同步消息和异步消息"><a href="#0-1-同步消息和异步消息" class="headerlink" title="0.1 同步消息和异步消息"></a>0.1 同步消息和异步消息</h2><p>微服务架构下存在很多服务间相互调用的情况。</p>
<p>我们知道可以通过 <code>OpenFeign</code> 的方式来获取远程服务的响应，但是 <code>OpenFeign</code> 的远程调用是同步的，其优点是同步调用时效强，等待结果返回。但同时会导致：</p>
<ul>
<li>代码可扩展性差。</li>
<li>性能堪忧。相较于相同项目实现的单体架构，同步的微服务调用方式会多出网络等待时间。</li>
</ul>
<p>于是我们需要异步调用的方式，这里使用到了<strong>发布-订阅者模式</strong>。</p>
<p>异步调用的优势是，</p>
<ul>
<li>模块间进一步解耦（发布者和订阅者间无需知道相互之间的信息）；</li>
<li>可拓展性强（scalable），添加实例无需更改代码；</li>
<li>异步性能有明显提升；</li>
<li>故障隔离（<strong><u>最终一致性保证</u></strong>）；</li>
<li>缓存消息，实现流量削峰填谷；</li>
</ul>
<p>但是缺点也很明显：</p>
<ul>
<li>异步实现无法立即得到结果，时效性差，可能导致数据不一致性；</li>
<li>不作额外措施，则不能保证最终一致性（下游业务是否成功）。所以业务安全依赖于 broker 的可靠性；</li>
</ul>
<h2 id="0-2-Message-Queue-选型"><a href="#0-2-Message-Queue-选型" class="headerlink" title="0.2 Message Queue 选型"></a>0.2 Message Queue 选型</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Opt</th>
<th>RabbitMQ</th>
<th>ActiveMQ</th>
<th>RocketMQ</th>
<th>Kafuka</th>
</tr>
</thead>
<tbody>
<tr>
<td>Company</td>
<td>Rabbit（专一，社区极活跃）</td>
<td>Apache（大厂支持）</td>
<td>Alibaba（开源冲业绩）</td>
<td>Apache</td>
</tr>
<tr>
<td>Language</td>
<td>Erlang（面向并发的语言）</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>Protocol Support</td>
<td>AMQP,XMPP,SMTP,STOMP</td>
<td>OpenWire,STOMP,REST,XMPP,AMQP</td>
<td>私有协议，只能被 Java 调用（微服务语言限制）</td>
<td>私有协议</td>
</tr>
<tr>
<td>Availability</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>Monolith Throughput（ops）</td>
<td>一般（数十万上下）</td>
<td>差</td>
<td>高（数十万）</td>
<td>极高（近数百万）</td>
</tr>
<tr>
<td>Latency</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>Reliability</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>一般</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出：</p>
<ul>
<li><p><code>Kafuka</code> 牺牲了部分可靠性（只确保最终一致性）、消息延迟，换取了极高的消息吞吐量。在对消息准确性要求不高（如日志传输）的情况下推荐；</p>
</li>
<li><p><code>RocketMQ</code> 虽然功能丰富，但是 <code>Alibaba</code> 的开源项目大多属于冲业绩，文档和社区支持不佳。</p>
<p>此外 <code>RocketMQ</code> 依赖于很多 <code>Alibaba</code> 技术栈，如果项目中不打算或者没有 <code>Alibaba</code> 的依赖，那么引入困难；</p>
<p>另外 <code>RocketMQ</code> 不支持主流协议，只支持他们自己的一套接口，微服务语言局限于 Java；</p>
</li>
<li><p><code>ActiveMQ</code> 是早期的项目，指标不如后辈；</p>
</li>
</ul>
<p>因此我们选择 <code>RabbitMQ</code>。</p>
<h1 id="Chapter-1-Introduction-to-RabbitMQ"><a href="#Chapter-1-Introduction-to-RabbitMQ" class="headerlink" title="Chapter 1. Introduction to RabbitMQ"></a>Chapter 1. Introduction to <code>RabbitMQ</code></h1><h2 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 架构</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/arch2.png"></p>
<ul>
<li><p><code>queue</code>：暂时存储消息的消息队列；队列有两类：</p>
<ul>
<li><p>durable queue：持久化队列，信息会被定期持久化到磁盘。这种队列可以提升可靠性，但是会降低性能；</p>
</li>
<li><p>non-durable queue：非持久化队列，信息总是保存在内存中。这种队列的速度会快于 durable queue，但是可靠性无法保证（例如不保证掉电不丢失数据）；</p>
</li>
</ul>
</li>
<li><p><code>virtual host</code>：虚拟主机，起到不同项目数据隔离作用；</p>
</li>
<li><p><code>exchange</code>：路由消息的交换机。其作用是接受发布者发送的消息，并将接收到的消息<strong><u>按照交换机的配置</u></strong>路由到所有与其绑定的队列中。本身不具备消息暂存能力；</p>
<p>交换机的配置（种类，或者说<strong>路由策略</strong>）大致有几种：</p>
<ul>
<li><p><code>Fanout</code>（广播）：<code>Fanout</code> 交换机。会将自身接受到的消息批量路由到<strong>所有与之关联的</strong>消息队列中；</p>
</li>
<li><p><code>Direct</code>（定向）：<code>Direct</code> 交换机。这种交换机 与 消息队列的关联时需要额外指定一个 <code>bindingKey</code>，并且发布者在向该种交换机发送消息时，必须指定 <code>routingKey</code>。</p>
<p>于是这种交换机只会将接受到的消息发送给 <code>bindingKey</code> 与这条消息的 <code>routingKey</code> 相同的消息队列中；</p>
<blockquote>
<p><code>bindingKey</code> 不要求对于交换机唯一。所以理论上 <code>Direct</code> 交换机的功能覆盖了 <code>Fanout</code> 交换机。</p>
</blockquote>
</li>
<li><p><code>Topic</code>（话题，类似 <code>Kafuka</code> 的按 Topic 订阅）：与 <code>Direct</code> 交换机类似，也以 <code>bindingKey</code> 和 <code>routingKey</code> 为路由依据，但：</p>
<ul>
<li><code>bindingKey</code> 这里是 topic，可以使用通配符：<code>#</code> 代表 0 到多个 topic，<code>*</code> 代表 1 个 topic；</li>
<li><code>routingKey</code> 可以是 topic 的组合，使用 <code>.</code>（period）隔开；</li>
</ul>
</li>
<li><p><code>Headers</code>（请求头）：<code>Headers</code> 交换机，</p>
</li>
</ul>
</li>
</ul>
<p>注意，交换机 和 消息队列间的关联需要显式声明 / 配置。</p>
<h2 id="1-2-Spring-AMQP"><a href="#1-2-Spring-AMQP" class="headerlink" title="1.2 Spring AMQP"></a>1.2 Spring <code>AMQP</code></h2><p><code>RabbitMQ</code> 支持多种协议，其中就包括 <code>AMQP</code>（Advanced Message Queuing Protocol），其他各种语言都有各自的 <code>AMQP</code> 的实现库。</p>
<p>为了方便起见，在 Spring 项目中常常使用 Spring 框架中实现好的 <code>AMQP</code> 协议接口来完成任务。</p>
<blockquote>
<p><code>spring-boot-starter-amqp</code> 依赖内部提供了针对 <code>AMQP</code> 协议的实现，只需引入该依赖即可操作 <code>RabbitMQ</code>；</p>
<p>引入后需要进行一些配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">virtual-host:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">...</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>最简单使用：<code>RabbitTemplate.convertAndSend</code> &amp; <code>@RabbitListener</code>；</li>
</ul>
<h3 id="1-2-1-Working-Queues-模型"><a href="#1-2-1-Working-Queues-模型" class="headerlink" title="1.2.1 Working Queues 模型"></a>1.2.1 Working Queues 模型</h3><p>Working Queues 模型：多个消费者绑定到一个队列，共同消费队列中的消息；</p>
<ul>
<li>结论 1：队列中的消息<strong><u>最多只能被消费一次</u></strong>；所以多个 consumer 监听的情况下，一个消息被某个 consumer 消费后，不会存在于消费队列中被其他 consumer 消费（不存在消息重复）；</li>
<li>结论 2：队列传递给所有监听它的消费者的<strong><u>默认行为</u></strong>是绝对平均（<strong>轮询</strong>）的，没有考虑到各个机器消费消息的性能（可以用 <code>Thread.sleep</code> 测试）；</li>
</ul>
<p>为了改善这个模型下出现的问题，我们可以对这个默认的轮询机制调优：<u>规定每个消费者一次只能获取一条消息，处理完成后才能获取下一条消息</u>；</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在消费者（使用 `@RabbitListener` 注解）所在的模块中配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-Fanout-Exchange"><a href="#1-2-2-Fanout-Exchange" class="headerlink" title="1.2.2 Fanout Exchange"></a>1.2.2 <code>Fanout</code> Exchange</h3><p>为什么需要广播交换机？考虑一个问题，假设一个发布者发布消息后，我们的业务逻辑要求同时有多个其他服务需要接收这个消息并且执行相应逻辑。举个例子，<code>consumer1</code> 和 <code>consumer2</code> 需要在 <code>publisher</code> 发送消息后各自接收一次消息（也就是都执行一次业务逻辑）。</p>
<p>如果没有广播交换，那么发布者发布的消息在全局范围内只能被一个消费者消费，这就没法实现多个服务都接受到发布者消息的需求了。</p>
<p>在这种需求下，我们只需要为每个微服务建立一个消息队列，并且对应监听；将这些队列与一个公共的 <code>fanout</code> 交换机关联，就能完成上面的需求。如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/fanout.png"></p>
<blockquote>
<p>代码中，如果使用了 <code>fanout</code> 交换机，那么 <code>routingKey</code> 可以指定为空字符串 / <code>null</code>；</p>
</blockquote>
<h3 id="1-2-3-Direct-Exchange"><a href="#1-2-3-Direct-Exchange" class="headerlink" title="1.2.3 Direct Exchange"></a>1.2.3 <code>Direct</code> Exchange</h3><ul>
<li>路由交换机需要与消息队列以 <code>bindingKey</code> 绑定；一个交换机和一个消息队列可以绑定多个 <code>bindingKey</code>；</li>
<li><p><code>bindingKey</code> 和 <code>routingKey</code> 不存在通配符；</p>
</li>
<li><p>路由直接发送到 <code>bindingKey == routingKey</code> 的消息队列中；</p>
</li>
</ul>
<h3 id="1-2-4-Topic-Exchange"><a href="#1-2-4-Topic-Exchange" class="headerlink" title="1.2.4 Topic Exchange"></a>1.2.4 <code>Topic</code> Exchange</h3><ul>
<li>路由交换机需要与消息队列以 <code>bindingKey</code> 绑定；</li>
<li><code>bindingKey</code> 允许通配符，<code>#</code> 表示任意 0 至多个 topic，<code>*</code> 表示任意一个；</li>
<li>路由发送到所有匹配的消息队列中；</li>
</ul>
<h3 id="1-2-5-Spring-AMQP-声明交换机-amp-队列"><a href="#1-2-5-Spring-AMQP-声明交换机-amp-队列" class="headerlink" title="1.2.5 Spring AMQP 声明交换机 &amp; 队列"></a>1.2.5 Spring <code>AMQP</code> 声明交换机 &amp; 队列</h3><ul>
<li><code>Queue</code> 声明队列的类，也可以使用 <code>QueueBuilder</code> 工厂类创建；</li>
<li><code>Exchange</code> 声明交换机的类，也可以使用 <code>ExchangeBuilder</code> 工厂类创建；</li>
<li><code>Binding</code> 声明队列和交换机的绑定关系，<code>BindingBuilder</code>（常用）；</li>
</ul>
<h4 id="Method-1-Spring-Bean-Configuration-式声明"><a href="#Method-1-Spring-Bean-Configuration-式声明" class="headerlink" title="Method 1. Spring Bean Configuration 式声明"></a>Method 1. Spring Bean Configuration 式声明</h4><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通常在 consumer 段声明，因为 consumer 更需要关注交换机和队列的生成 */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* 构造函数为名称 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;test.fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/* 等价于： */</span></span><br><span class="line">        <span class="comment">/* return ExchangeBuilder.fanoutExchange(&quot;test.fanout&quot;).build(); */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;test.queue1&quot;</span>);</span><br><span class="line">        <span class="comment">/* 等价于（默认 durable queue）： */</span></span><br><span class="line">        <span class="comment">/* return QueueBuilder.durable(&quot;test.queue1&quot;).build(); */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;test.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 自动注入 queue 和 exchange，从上面的 bean 寻找，采用 autowired-by-name 策略 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue</span><span class="params">(Queue fQueue1, FanoutExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fQueue1).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue</span><span class="params">(Queue fQueue2, FanoutExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fQueue2).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Method-2-Listener-注解式声明"><a href="#Method-2-Listener-注解式声明" class="headerlink" title="Method 2. Listener 注解式声明"></a>Method 2. Listener 注解式声明</h4><p>显然这种方法非常麻烦，主要有以下的问题：</p>
<ul>
<li><p>每个方法大同小异，大部分是 boilerplate code；</p>
</li>
<li><p>定义步骤相当繁琐每定义一个队列、交换机或者绑定关系，就要新建一个方法；</p>
</li>
<li>很多队列或者交换机的 bean，只能通过 <code>autowired-by-name</code> 的方法注入，降低了代码可读性和可维护性；</li>
</ul>
<p>于是可以使用另一种定义方式，直接使用 <code>@RabbitListener</code> 提供的 <code>bindings</code> 参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(</span></span><br><span class="line"><span class="meta">    bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &lt;Queue Name&gt;, [durable = &quot;true&quot; | &quot;false&quot;]),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &lt;Exchange Name&gt;, type = ExchangeTypes.?),</span></span><br><span class="line"><span class="meta">        key = &#123; /* bindingKeys [String Array] */ &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>
<p>只需要声明一个注解即可定义队列、交换机、绑定关系；</p>
<p>但是上面的 Method 2 可能还是有问题：</p>
<ul>
<li><p>配置散落在业务代码中，没有与业务逻辑解耦；</p>
</li>
<li><p>这么写可能存在 queue / exchange 重复定义的问题，而且需要保证每次声明同样对象的配置一致。降低了可维护性和可扩展性；</p>
</li>
<li>在每个方法前面写这么大段注解，降低代码可读性；</li>
</ul>
<p>有什么办法解决吗？可以综合 Method 1 使用 ~</p>
<h3 id="1-2-6-Spring-AMQP-消息转换器"><a href="#1-2-6-Spring-AMQP-消息转换器" class="headerlink" title="1.2.6 Spring AMQP 消息转换器"></a>1.2.6 Spring <code>AMQP</code> 消息转换器</h3><p>注意，到目前为止，我们没有讨论过队列传输的对象是 <code>POJO</code> 或者是更复杂的 Java 对象的情况。</p>
<p>我们知道如果传输的是简单的 Java String，则 <code>RabbitMQ</code> 直接在队列上传输字符串；但是对于一般的 Java 对象，<code>RabbitMQ</code> 会使用 Java 内置的序列化实现将对象转为 Java Serializable Object；</p>
<p>我们跟踪 Spring <code>RabbitTemplate</code> 源码发现，内部对 <code>Object</code>（传递的信息）执行了 <code>convertMessageIfNecessary</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">protected</span> Message <span class="title function_">covertMessageIfNecessary</span><span class="params">(<span class="keyword">final</span> Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Message) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Message) object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getRequiredMessageConverter().toMessage(object, <span class="keyword">new</span> <span class="title class_">MessageProperties</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>
<p><code>Message</code> 类型是 <code>AMQP</code> 定义的接口，定义了帮助 <code>AMQP</code> 传输消息的方法。</p>
<p>我们进一步了解发现 <code>getRequiredMessageConverter()</code> 方法是获取 <code>RabbitTemplate</code> 的实例属性 <code>messageConverter</code>，<strong>其类型是 <code>MessageConverter</code>，默认实现是 <code>SimpleMessageConverter</code></strong>；</p>
<p>再查看 <code>MessageConverter</code> 的接口实现可以发现 Spring 中存在很多实现，例如 <code>Jackson2XmlMessageConverter / Jackson2JsonMessageConverter / ...</code>；</p>
<p>那么这些 converter 具体是如何将一般的 <code>Object</code> 转换为 <code>Message</code> 的呢？</p>
<p>我们找到 <code>MessageConverter</code> 接口的 <code>toMessage()</code> 方法，发现其在 <code>SimpleMessageConverter</code> 中的实现如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/smc-createMessage.png"></p>
<p>注意到，对于非空非 <code>byte[] / String</code> 类型的可序列化对象，<code>SimpleMessageConverter</code> 会直接将对象序列化（默认 Java 的对象流 <code>ObjectOutputStream</code>）。</p>
<p>这样做一般情况下没什么，但是在消息中间件中不建议使用，具体有以下几点原因：</p>
<ul>
<li><code>JDK</code> 的 <code>ObjectOutputStream</code> 本身存在安全风险（可以轻松反序列化并且进行代码注入）；</li>
<li><code>JDK</code> 的对象数据流大小往往很大，存放了一些并不需要传输的数据（几个 byte 的数据可能被序列化成几百个 byte 的数据，降低了传输性能，限制了消息吞吐量）；</li>
</ul>
<p>这里建议使用 <code>Jackson2JsonMessageConverter</code>。我们只需要在发送模块书写一个 <code>Bean</code> 配置类，然后让 Spring Boot 自动装配即可。</p>
<blockquote>
<p>确保引入依赖 <code>com.fasterxml.jackson.core:jackson-databind</code>；</p>
</blockquote>
<h2 id="1-3-Spring-AMQP-实战：消息中间件替换-OpenFeign-同步远程调用"><a href="#1-3-Spring-AMQP-实战：消息中间件替换-OpenFeign-同步远程调用" class="headerlink" title="1.3 Spring AMQP 实战：消息中间件替换 OpenFeign 同步远程调用"></a>1.3 Spring <code>AMQP</code> 实战：消息中间件替换 <code>OpenFeign</code> 同步远程调用</h2><blockquote>
<p>小贴士：如果设置了消费者确认机制并且使用 <code>auto</code> 模式，使用 <code>@RabbitListener</code> 注解的函数返回类型必须是 <code>void</code>。否则 RabbitMQ 会认为 consumer 执行错误。</p>
</blockquote>
<h1 id="Chapter-2-MQ-进阶：消息可靠性"><a href="#Chapter-2-MQ-进阶：消息可靠性" class="headerlink" title="Chapter 2. MQ 进阶：消息可靠性"></a>Chapter 2. MQ 进阶：消息可靠性</h1><p>使用 Spring <code>AMQP</code> 进行服务间异步通信可能存在一些问题：</p>
<ul>
<li>消息发布方网络丢包，导致消息丢失；</li>
<li>消息被 MQ 正确接受到后，MQ 宕机导致消息丢失；或者消费者速度较低，MQ 产生内存中的消息积压（内存占满的刷盘期间）可能造成消息丢失；</li>
<li>在 MQ 发送给消息消费方时，消费方宕机导致消息丢失；</li>
</ul>
<p>因为网络的不可靠性，即便我们针对上述问题进行保护措施，仍然可能出现一些问题。我们最终需要一些兜底的机制，至少需要确保消息的最终一致性。</p>
<p>接下来将会以 RabbitMQ 为例，从上面 4 个角度分析 MQ 如何保证消息的可靠性。</p>
<h2 id="2-1-消息发布方的可靠性：重连与确认机制"><a href="#2-1-消息发布方的可靠性：重连与确认机制" class="headerlink" title="2.1 消息发布方的可靠性：重连与确认机制"></a>2.1 消息发布方的可靠性：重连与确认机制</h2><h3 id="2-1-1-发送者重连-性能警告"><a href="#2-1-1-发送者重连-性能警告" class="headerlink" title="2.1.1 发送者重连 [性能警告]"></a>2.1.1 发送者重连 [性能警告]</h3><p>发送者重连，在 MQ 与消息发布方连接后，存在连接断开的情况，这可能导致发布方网络丢包；因此需要 MQ 和服务发布方在网络丢失后进行重连，特别地，在 RabbitMQ 中需要<strong><u>在消息发送方</u></strong>进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">connection-timeout:</span> <span class="string">1s</span>	<span class="comment"># MQ 连接超时时间（连接等待多长时间才算失败，失败后才进行重连）</span></span><br><span class="line">        <span class="attr">template:</span></span><br><span class="line">            <span class="attr">retry:</span></span><br><span class="line">                <span class="attr">enable:</span> <span class="literal">true</span>	<span class="comment"># 消息重连（默认 false）</span></span><br><span class="line">                <span class="attr">initial-interval:</span> <span class="string">1000ms</span>	<span class="comment"># 连接失败/断开后的初识等待时间（立即尝试的成功概率小）</span></span><br><span class="line">                <span class="attr">multiplier:</span> <span class="number">1</span>	<span class="comment"># 尝试等待时间倍数（下次等待时间为上次的倍数。第二次相对于 initial-interval）</span></span><br><span class="line">                <span class="attr">max-attempts:</span> <span class="number">3</span>	<span class="comment"># 最大尝试次数</span></span><br></pre></td></tr></table></figure>
<p>但是这种机制是<strong>阻塞式重连</strong>，对业务性能会造成影响，这也是为什么 <code>retry</code> 默认配置是禁用的。如果必须要使用，也需要合理设置超时、等待时长，以及尝试次数；</p>
<h3 id="2-1-2-发送者确认-性能警告"><a href="#2-1-2-发送者确认-性能警告" class="headerlink" title="2.1.2 发送者确认 [性能警告]"></a>2.1.2 发送者确认 [性能警告]</h3><p>发送者确认：Spring <code>AMQP</code> 提供了 Publish Confirm（消息确认反馈）和 Publisher Return（路由错误返回信息）两种机制。</p>
<p><strong>在发送者确认机制打开后，当消息发布方向 MQ 发送一条消息，MQ 会返回<u>确认结果</u>给发送方</strong>，确认结果分为以下几种情况：</p>
<ul>
<li><p>消息成功投递到 MQ 中，但是路由失败：MQ 通过 Publisher Return 返回路由错误原因，返回 <code>ACK</code> 告知投递成功；</p>
<blockquote>
<p>这种情况只可能是：exchange 没有绑定队列 / routing key 没有匹配队列，是开发者原因。与网络、发送方、MQ 都没有关系，所以认为投递成功。</p>
<p>这种情况重新发送消息是没有意义的，因为错误不会因为重试而修复。</p>
</blockquote>
</li>
<li><p><strong><u>临时消息</u></strong>投递到 MQ 中，且成功入队；MQ 反馈 <code>ACK</code> 告知投递成功；</p>
<blockquote>
<p>临时消息对于队列是否是 <code>durable</code> 的没有要求，只要投递到 MQ 中，并且进入队列内存，就算成功；</p>
</blockquote>
</li>
<li><p><strong><u>持久消息</u></strong>投递到 MQ 中，且成功入队，且成功持久化；MQ 反馈 <code>ACK</code> 告知投递成功；</p>
<blockquote>
<p>持久消息需要被 MQ 放入 durable 队列中，并且持久化才算投递成功，这样可以防止 MQ 宕机造成消息丢失。</p>
<p>同时这可能损失一部分性能，所以应该根据业务逻辑来选择持久消息或临时消息。</p>
</blockquote>
</li>
<li><p>其他任何情况都会反馈 <code>NACK</code>，表示投递失败。<strong><u>只有在这种情况下，进行消息重发是正确的、有意义的</u></strong>；</p>
</li>
</ul>
<p>以 RabbitMQ 为例，开启发送者确认机制需要<strong><u>在消息发送方</u></strong>进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span>	<span class="comment"># 开启 Publish Confirm 机制，指定模式类型</span></span><br><span class="line">        <span class="attr">publish-return:</span> <span class="literal">true</span>	<span class="comment"># 开启 Publish Return 机制</span></span><br></pre></td></tr></table></figure>
<p>所谓 Publish Confirm 只包含了 <code>ACK / NACK</code> 的消息，而 Publish Return 则<strong>回调上面第一种投递成功，但路由失败的失败信息</strong>。</p>
<p>Publish Confirm 的 3 种模式分别为：</p>
<ul>
<li><code>none</code>：关闭 Publish Confirm 机制；</li>
<li><code>simple</code>：同步阻塞等待 MQ 的确认；</li>
<li><code>correlated</code>：MQ 异步回调方式确认；</li>
</ul>
<p>那么如何配置 MQ 的异步回调（confirm callback 和 return callback）？</p>
<p>事实上，一个 <code>RabbitTemplate</code> 只能配置一个 Return Callback（<strong>需要启用 Publish Return 机制</strong>）。所以需要在 Spring 项目启动过程中配置一次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在构造函数完成后执行一次 */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">            <span class="comment">/* RabbitTemplate.ReturnsCallback 是一个函数接口 */</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnMessage</span><span class="params">(ReturnedMessage msg)</span> &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Return callback triggered.&quot;</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                    log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                    log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                    log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                    log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于单条消息而言还有 Confirm Callback（<strong>需要启用 Publish Confirm 机制</strong>），这在每条消息发送前都需要配置一次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 CorrelationData，包含消息的全局 ID（MQ 需要区别消息以发送 confirm 或 return）</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(</span><br><span class="line">        UUID.randomUUID().toString()	<span class="comment">/* 注：UUID 可能存在性能问题和 MAC 地址安全问题 */</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 2.给 Future 添加 ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(</span><br><span class="line">        <span class="comment">/* ListenableFutureCallback 是一个含有 onFailure 和 onSuccess 的接口 */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">                <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">                log.error(<span class="string">&quot;handle message ack fail&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 请类比 JavaScript 的 Promise，思考为什么即便是投递失败也在 onSuccess 中 */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">                <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">                <span class="keyword">if</span> (result.isAck()) &#123;</span><br><span class="line">                    <span class="comment">// result.isAck()，boolean类型</span></span><br><span class="line">                    <span class="comment">// true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                    log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                    log.error(</span><br><span class="line">                        <span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason()</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;test.direct&quot;</span>, <span class="string">&quot;red1&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还要提一点，发送确认也会对性能有较大影响。而且发送丢包的概率较低，所以只建议在亟需确保数据可靠性的极端情况下才需要如此配置。</p>
<h2 id="2-2-MQ-的可靠性"><a href="#2-2-MQ-的可靠性" class="headerlink" title="2.2 MQ 的可靠性"></a>2.2 MQ 的可靠性</h2><p>如上所述，MQ 可能丢失消息的场景有两类：</p>
<ul>
<li>消息被 MQ 正确接受到后，MQ 宕机导致消息丢失；</li>
<li>消费者速度很低，MQ 产生内存中的消息积压阻塞（内存占满的刷盘期间无法继续入队）可能造成消息丢失；</li>
</ul>
<p>具体有两种思路可以解决，一是数据持久化策略，二是 Lazy Queue；</p>
<h3 id="2-2-1-MQ-的数据持久化-默认"><a href="#2-2-1-MQ-的数据持久化-默认" class="headerlink" title="2.2.1 MQ 的数据持久化 [默认]"></a>2.2.1 MQ 的数据持久化 [默认]</h3><ul>
<li><p>交换机持久化、队列持久化（默认都是 durable）；</p>
<blockquote>
<p>交换机、队列的持久化，是指交换机 / 队列自身的信息也会持久化在磁盘中；</p>
</blockquote>
</li>
<li><p>消息持久化。我们在之前提到，临时消息不会被 MQ 保证持久化到磁盘中，意味着这类消息在掉电后可能丢失。所以如果对一类消息的正确性要求很高，需要将消息设置为持久消息：</p>
<p>由于 <code>RabbitTemplate</code> 默认的 <code>convertAndSend</code> 方法中的 message converter 都默认构建 Message 为持久的消息，因此我们需要手动构建才能得到临时消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">    .withBody(<span class="string">&quot;Hello, Spring AMQP&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">    .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>如果使用大量数据实验会发现，大量、快速发送临时消息（不会主动刷盘）会不断在内存中积压，其触发的 Page Out（泛指内存耗尽触发的被动刷盘操作）会像数据结构 LSM Tree 的 compaction 操作一样短时间内迅速降低 MQ 的吞吐量，形成一个个性能低谷，总体性能反而小于持久数据（一开始就进行刷盘操作）；</p>
</li>
</ul>
<h3 id="2-2-2-Lazy-Queue-默认"><a href="#2-2-2-Lazy-Queue-默认" class="headerlink" title="2.2.2 Lazy Queue [默认]"></a>2.2.2 Lazy Queue [默认]</h3><p>在 Rabbit MQ 3.12 以后，所有队列默认 Lazy Queue 且无法更改。</p>
<p>Lazy Queue 的特征是，</p>
<ul>
<li>接收到消息后直接存入磁盘，不再存储到内存；</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存（可以提前缓存部分消息到内存，最多2048条）；</li>
</ul>
<h2 id="2-3-消费者的可靠性"><a href="#2-3-消费者的可靠性" class="headerlink" title="2.3 消费者的可靠性"></a>2.3 消费者的可靠性</h2><h3 id="2-3-1-消费者确认机制"><a href="#2-3-1-消费者确认机制" class="headerlink" title="2.3.1 消费者确认机制"></a>2.3.1 消费者确认机制</h3><p>Spring <code>AMQP</code> 同样存在一种机制，即消费者确认机制（Consumer Acknowledgement）。</p>
<p>它是为了确认消费者是否成功处理消息。当消费者处理消息结束后，应该向 Rabbit MQ 发送一个回执，告知 Rabbit MQ 自己消息处理状态：</p>
<ul>
<li><code>ACK</code>：成功处理消息，Rabbit MQ 从队列（内存以及磁盘）中删除该消息；</li>
<li><code>NACK</code>：消息处理失败，Rabbit MQ 需要再次投递消息；</li>
<li><code>REJECT</code>：消息处理失败并拒绝该消息，Rabbit MQ 从队列（内存以及磁盘）中删除该消息；</li>
</ul>
<p>这个回执应该在消费者关于该消息所有业务逻辑处理完成后，才能返回，防止出错后无法重试。</p>
<p>这样的操作非常类似 事务机制。</p>
<p>Spring <code>AMQP</code> 已经实现了消息确认功能。并允许我们通过配置文件选择ACK处理方式：</p>
<ul>
<li><p><code>none</code>：不处理。即消息投递给消费者后立刻 <code>ACK</code>，消息会立刻从 MQ 删除。非常不安全，不建议使用；</p>
</li>
<li><p><code>manual</code>：手动模式。需要自己在业务代码中调用 API，发送 <code>ACK</code> 或 <code>REJECT</code>，存在业务入侵，但更灵活；</p>
</li>
<li><p><code>auto</code>：自动模式。Spring <code>AMQP</code> 利用 <code>AOP</code> 对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回 <code>ACK</code>.  当业务出现异常时，根据异常判断返回不同结果：</p>
<ul>
<li><p>如果是业务异常，会自动返回 <code>NACK</code>，消息会重新进入 <code>Ready</code> 状态投递给对应消费者（重新处于 <code>Ready</code> 状态）；</p>
<blockquote>
<p>消费者宕机、抛出 <code>RuntimeException</code> / 其他自定义异常，都认为是 <code>NACK</code>；</p>
</blockquote>
</li>
<li><p>如果是消息处理或校验异常（需要抛出例如 <code>MessageConversionException</code>），自动返回 <code>REJECT</code>；</p>
<blockquote>
<p>这就提醒我们，遇到业务逻辑中的格式异常，请不要 throw <code>RuntimeException</code>，不然会被 Spring 认为是业务异常而重新发送！</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>我们需要在消息消费方配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">acknowledge-mode:</span> <span class="string">none</span>	<span class="comment"># 默认不处理，</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-消费者失败重试机制"><a href="#2-3-2-消费者失败重试机制" class="headerlink" title="2.3.2 消费者失败重试机制"></a>2.3.2 消费者失败重试机制</h3><p>在引入消费者确认机制后，还会出现一个问题：如果 MQ 中积压的消息量过大，导致消费方宕机，在消费者恢复后，没有进行请求热身，MQ 又重发了大量的消息，很有可能会再次导致消费方再次宕机。</p>
<p>这会给消费方和 MQ 都造成极大的压力。</p>
<p>为了应对这种情况，MQ 引入了另一种机制来保障消费方的消息可靠性：消费者失败重试机制。在消费者出现异常时按照配置重试，而不是无限的重复入队。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">retry:</span>	<span class="comment"># 注：发送方重试位于 template 下</span></span><br><span class="line">                    <span class="attr">enabled:</span> <span class="literal">true</span>				<span class="comment"># 默认 false</span></span><br><span class="line">                    <span class="attr">initial-interval:</span> <span class="string">1000ms</span>	<span class="comment"># 失败初始等待时间</span></span><br><span class="line">                    <span class="attr">multiplier:</span> <span class="number">1</span></span><br><span class="line">                    <span class="attr">max-attempts:</span> <span class="number">3</span></span><br><span class="line">                    <span class="attr">stateless:</span> <span class="literal">true</span>	<span class="comment"># 如果业务中含有事务，说明这种消息重递是有状态的，应该 false</span></span><br></pre></td></tr></table></figure>
<p>在重试超过 <code>max-attempts</code> 后，消息状态转变为 requeue-exhausted，进而转入 <code>MessageRecoverer</code> 中处理。</p>
<p>Spring <code>AMQP</code> <strong>默认的 <code>MessageRecoverer</code> 的实现是 <code>RejectAndDontRequeueRecoverer</code></strong>，其策略是直接丢弃这条消息，这样做有失消费者安全性。</p>
<p>除了默认的 recoverer，还有两种：</p>
<ul>
<li><p><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，仍然认为返回 <code>NACK</code>，重新入队；</p>
<blockquote>
<p>这种策略和不采取失败者重试的策略相比，性能影响会小一点；</p>
</blockquote>
</li>
<li><p><code>RepublishMessageRecoverer</code>：重试耗尽后，将消息（<strong>包括报错信息</strong>）投递到指定交换机，以供其他处理用途；</p>
<blockquote>
<p>这种策略也比较合理，认为反复投递无效就应该换一种处理方式。</p>
<p>但这种方法需要专门配置一个指定的交换机：</p>
<ul>
<li>定义接受失败队列、与其绑定的交换机；</li>
<li>定义 <code>RepublishMessageRecoverer</code> 的 Bean（传入 <code>RabbitTemplate</code>、交换机、队列名称）；</li>
</ul>
</blockquote>
</li>
</ul>
<p>这种机制虽然相较于原先确认机制而言，降低了可靠性，但是一定程度上提升了服务的可用性，降低多次/长时间宕机造成的资源浪费风险。</p>
<h2 id="2-4-业务幂等性保证"><a href="#2-4-业务幂等性保证" class="headerlink" title="2.4 业务幂等性保证"></a>2.4 业务幂等性保证</h2><p>在上面的过程中，有一种情况我们没有考虑：如果消费者的接口不是幂等的，就需要保证消息发送的不重复性。</p>
<p>也就是说，<strong>假设消费者收到消息后并且处理结束，要给 MQ 发送 <code>ACK</code> 时连接断开了（或者两方有一方宕机了），就可能会导致 MQ 消息重新发送</strong>。这个问题没办法借助 MQ 来解决，因为不是 MQ 本身的问题。</p>
<p>那么应该如何处理这种情况？</p>
<h3 id="2-4-1-唯一消息-ID"><a href="#2-4-1-唯一消息-ID" class="headerlink" title="2.4.1 唯一消息 ID"></a>2.4.1 唯一消息 ID</h3><p>第一种思路是唯一消息 ID：给每个消息都设置一个唯一 ID，利用 ID 区分是否是重复消息。</p>
<ul>
<li>每一条消息都生成一个唯一的 ID，与消息一起投递给消费者；</li>
<li>消费者接收到消息后处理自己的业务，业务处理成功后将消息 ID 保存到数据库；</li>
<li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li>
</ul>
<blockquote>
<p>Tips. 这和之前提到的发送者确认机制中创建的 <code>CorrelationData</code> 中的 ID 不一样，前者是作回执用的 ID，它和消费 ID 可以保持消费不一致；</p>
</blockquote>
<p>我们可以在定义消息转换器时显式声明让 MQ 创建全局唯一的 Message ID：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageCoverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    jmc.setCreateMessageIds(<span class="literal">true</span>);    <span class="comment">/* 默认 false */</span></span><br><span class="line">    <span class="keyword">return</span> jmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 Message ID 会存放在 Message 的 Properties 中（不是我们常用的 Payload 中），所以需要我们单独去取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 都需要转换，所以直接使用 Message 类型接收，就能收到 properties 数据 */</span></span><br><span class="line"><span class="meta">@RabbitListener(/* ... */)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    message.getBody();     <span class="comment">/* 返回 byte[] */</span></span><br><span class="line">    message.getMessageProperties();    <span class="comment">/* MessageProperties */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>byte[]</code> 中如果原来是字符串，则可以直接用字符串构造函数构造；</p>
<p>如果是 自定义的对象，并且使用了 <code>Jackson2JsonMessageConverter</code>，直接用配套的 <code>ObjectMapper</code> 解析就行；</p>
</li>
<li><p><code>MessageProperties.getMessageId()</code> 就能获取其中的 <code>message-id</code> 属性（如果有）；</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>业务逻辑嵌入和耦合。给业务引入了原本不需要的逻辑，造成耦合；</p>
</li>
<li><p>数据库写影响原本业务性能；</p>
</li>
</ul>
<h3 id="2-4-2-业务逻辑本身判断"><a href="#2-4-2-业务逻辑本身判断" class="headerlink" title="2.4.2 业务逻辑本身判断"></a>2.4.2 业务逻辑本身判断</h3><p>上面的方法虽然通用，但是是侵入式的解决方案。如果业务逻辑允许，我们可以根据原有的业务逻辑判断这次消息是否被处理过。</p>
<blockquote>
<p>相当于做了非幂等业务的保护流程。</p>
<p>例如对于订单业务，如下图，如果在交易服务中的 “标记订单为已支付”，如果用户在支付成功后，“标记订单已支付” 以及完成，正在向 MQ 发送 <code>ACK</code> 时断开连接。此时 MQ 认为消费者未收到。</p>
<p>如果用户此时发起了退款，交易服务立即更改为退款中，此后 MQ 的连接又恢复了，如果不作处理，则 “已支付” 的状态会覆盖 “退款中” 的状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/pe-example.png" width="400px"></p>
<p>这种情况除了使用 Message ID 的方法，还可以直接检查 “标记订单已支付” 之前的订单状态，毕竟根据业务逻辑，只有未支付的订单才会需要标记成已支付：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/pe-example-sol.png" width="600px"></p>
</blockquote>
<p> 总结一下：</p>
<p>如何保证支付服务与交易服务之间的订单状态一致性？</p>
<ul>
<li><p>首先，支付服务会正在用户支付成功以后利用 MQ 消息通知交易服务，完成订单状态同步；</p>
</li>
<li><p>其次，为了保证 MQ 消息的可靠性，我们采用了发送者确认机制、消费者确认、消费者失败重试等策略，确保消息投递和处理的可靠性。同时也开启了 MQ 的持久化，避免因服务宕机导致消息丢失；</p>
<blockquote>
<p>保证消费者至少消费一次。</p>
</blockquote>
</li>
<li><p>最后，我们还在交易服务更新订单状态时做了业务幂等判断，避免因消息重复消费导致订单状态异常。</p>
</li>
</ul>
<p>上面的策略已经比较完善了，但是还是可能存在问题：我们的机制没有问题，但是网络原因，MQ 和消费者间真的一直都没办法建立连接，能否有个兜底机制，至少确保关键的业务（例如支付）数据一致性？</p>
<h2 id="2-5-延迟任务和延迟消息"><a href="#2-5-延迟任务和延迟消息" class="headerlink" title="2.5 延迟任务和延迟消息"></a>2.5 延迟任务和延迟消息</h2><p>延迟任务是消息一致性的一种兜底方案。</p>
<p>延迟消息：<strong><u>发送者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。</u></strong></p>
<p>以下单举例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/delay-example.png" width="600px"></p>
<p>假设交易服务和支付服务间暂时一直无法连接，是否有机制确保二者间的消息一致？</p>
<p>我们可以引入超时时间的概念，一段时间后，再次向支付服务查询如果成功就改变状态；如果失败则取消。</p>
<p>在 Rabbit MQ 中可以借助插件来完成延迟任务（默认不支持）。</p>
<h3 id="2-5-1-死信交换机（dead-letter）"><a href="#2-5-1-死信交换机（dead-letter）" class="headerlink" title="2.5.1 死信交换机（dead-letter）"></a>2.5.1 死信交换机（dead-letter）</h3><p>当一个队列中的消息满足下列情况之一时，就会成为死信（dead letter）：</p>
<ul>
<li>消费者使用 <code>REJECT</code> 或 <code>NACK</code> 声明消费失败并且消息的 <code>requeue</code> 参数设置为 <code>false</code> / 使用失败重试机制的 Message Recoverer 是 <code>RejectAndDontRequeueRecoverer</code>；</li>
<li>消息是一个过期消息（达到了队列或消息本身设置的过期时间），超时无人消费；</li>
<li>要投递的队列消息堆积满了，最早的消息可能成为死信；</li>
</ul>
<p>我们可以在声明交换机时，给定一个属性 <code>dead-letter-exchange</code>，并且与某个队列绑定，那么该队列中的死信就会自动投递到这个交换机中；</p>
<p>我们可以利用死信交换机的 “超时” 特性，实现延时任务：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/dead-letter-meme-delay.png"></p>
<p>我们可以对某个队列声明死信交换机，直接使用 <code>QueueBuilder</code> 的方式定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueueBuilder</span><br><span class="line">    .durable(&lt;queue name&gt;)</span><br><span class="line">    .deadLetterExchange(&lt;dlx exchange name&gt;)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>
<p>最后，我们还有在发送消息时还需要指定消息的过期时间，确保最终以规定时间进入死信交换机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(&lt;normal direct&gt;, &lt;key&gt;, &lt;object&gt;, &lt;post process&gt;)</span><br></pre></td></tr></table></figure>
<p>在最后一个参数中，传入一个 <code>MessagePostProcessor</code> 函数接口的实现，即可在 object 转换为 <code>Message</code> 对象后再进行处理，以设置超时时间。因为<strong><u>超时时间也位于 Message 的 Properties 中</u></strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">postProccessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">        message.getMessageProperties().setExpiration(<span class="string">&quot;10000&quot;</span> <span class="comment">/* 字符串表示的 ms */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 也可以换成 lambda 表达式 */</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-2-Rabbit-MQ-延时任务插件"><a href="#2-5-2-Rabbit-MQ-延时任务插件" class="headerlink" title="2.5.2 Rabbit MQ 延时任务插件"></a>2.5.2 Rabbit MQ 延时任务插件</h3><p>需要在 <code>mq-plugins/_data</code> 中加入插件，并且配置 <code>enabled_plugins</code> 文件，加入 <code>rabbitmq_delayed_message_exchange</code> 即可；</p>
<p>然后，我们需要设置某个交换机的属性为 <code>delayed</code>：</p>
<ul>
<li>如果使用 Bean 配置，那么就用 <code>ExchangeBuilder</code> 添加 <code>delayed()</code> 方法；</li>
<li>如果使用 <code>@RabbitListener(bindings)</code> 的配置，就在 <code>@Exchange</code> 中加入 <code>delayed = &quot;true&quot;</code>；</li>
</ul>
<p>最后给要发送的消息指定 properties <code>x-delay</code>，同样使用 post processor，此时对 Message Properties 调用 <code>setDelay(&lt;ms&gt;)</code> （不是 <code>setExpiration</code>）即可；</p>
<blockquote>
<p>注意：无论是延时消息，还是死信的生成，其计时依赖 CPU 时钟，所以是 CPU 密集型任务。</p>
<p>如果超时时间 / 过期时间设置过长，都会导致需要计时的消息大量积压，影响 MQ 性能。</p>
<p><strong><u>所以无论是死信交换机中的过期时间，还是延时任务的延时时间，都不宜设置过长。</u></strong></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SJTU-XHW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/technical/rabbit-mq/">https://blog.sjtuxhw.top/technical/rabbit-mq/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SJTU-XHW's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MQ/">MQ</a><a class="post-meta__tags" href="/tags/Web/">Web</a><a class="post-meta__tags" href="/tags/Microservice/">Microservice</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/rabbit.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/review/numeric-analysis/" title="Numeric Analysis for Beginners"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/numeric-analysis.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Numeric Analysis for Beginners</div></div><div class="info-2"><div class="info-item-1">Chapter 1. Basic Concepts 相对误差与绝对误差；  求根问题：$\text{For }f:\mathbf{R}\rightarrow\mathbf{R},\text{ find }x^*\text{ such that }f(x^*)=0$； 假设有估计解 $x_{est}$，但是 $0\lt |f(x_{est})|\ll1$，那么我们也许不知道 $|x_{est}-x_0|$，但是我们一定知道 $|f(x_{est})-f(x_0)|\equiv|f(x_{est})|$；  前向误差：估计解与实际解的差值（就是上面的 $|x_{est}-x_0|$，一般我们不知道）；  后向误差：使得估计值正确所要让 problem statement 改变的 delta（就是上面的 $|f(x_{est})-f(x_0)|\equiv|f(x_{est})|$，一般我们能算出来）；  Well-Conditioned（insensitive）：$\text{Small backward error}\Rightarrow\text{Small forward...</div></div></div></a><a class="pagination-related" href="/technical/micro-service-basic/" title="微服务初探"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/micro.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">微服务初探</div></div><div class="info-2"><div class="info-item-1">Chapter 0. 基本概念 微服务是一种软件架构风格。专注于单一职责的小型业务为基础，组成复杂大型应用。 需要解决的问题：服务拆分、远程调用（RPC）、服务治理（可用性与调度）、请求路由、身份认证、配置管 理、分布式事务（一致性问题）、异步通信…… 优点和特征：粒度小、单服务开发便捷，团队自治，服务自治，系统耦合性低； 缺点：跨模块开发难度大，运维成本高；   对比而言，单体架构：  优点：架构简单、部署成本低（适用于开发功能相对简单、规模较小的项目）； 缺点：团队协作成本高，系统发布效率低、系统可用性差（软件可靠性差）；    对应框架：Spring Cloud，全球范围广泛使用的微服务框架； 服务注册发现组件：Eureka、Nacos、Consul…… 服务远程调用（RPC）；OpenFeign、Dubbo…… 服务链路监控：Zipkin、Sleuth…… 统一配置管理：Spring Cloud Config、Nacos…… 统一网关路由：Spring Cloud Gateway、Zuul…… 流控、降级、保护：Hystix、Sentinel……    Chapter...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/technical/micro-service-basic/" title="微服务初探"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/micro.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="info-item-2">微服务初探</div></div><div class="info-2"><div class="info-item-1">Chapter 0. 基本概念 微服务是一种软件架构风格。专注于单一职责的小型业务为基础，组成复杂大型应用。 需要解决的问题：服务拆分、远程调用（RPC）、服务治理（可用性与调度）、请求路由、身份认证、配置管 理、分布式事务（一致性问题）、异步通信…… 优点和特征：粒度小、单服务开发便捷，团队自治，服务自治，系统耦合性低； 缺点：跨模块开发难度大，运维成本高；   对比而言，单体架构：  优点：架构简单、部署成本低（适用于开发功能相对简单、规模较小的项目）； 缺点：团队协作成本高，系统发布效率低、系统可用性差（软件可靠性差）；    对应框架：Spring Cloud，全球范围广泛使用的微服务框架； 服务注册发现组件：Eureka、Nacos、Consul…… 服务远程调用（RPC）；OpenFeign、Dubbo…… 服务链路监控：Zipkin、Sleuth…… 统一配置管理：Spring Cloud Config、Nacos…… 统一网关路由：Spring Cloud Gateway、Zuul…… 流控、降级、保护：Hystix、Sentinel……    Chapter...</div></div></div></a><a class="pagination-related" href="/technical/js-basic-2/" title="JavaScript入门笔记-(2)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/javascript2.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-25</div><div class="info-item-2">JavaScript入门笔记-(2)</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference: 《Professional JavaScript for Web Developers》 3rd Edition 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 7. 简单使用 DOM假设你学习了初级数据结构，那么把 HTML 页面想象成一个以元素为结点的一般树。JavaScript DOM 操作就是操作这个文档树，达到改变前端页面的目的。 在浏览器运行的 JavaScript 引擎中，全局运行环境中会自动设置一个变量 document（DOM 对象），操作它就是在动态操作 HTML 页面。 7.1 基本操作 假设你学习了 CSS 的基础用法。   document.querySelector(&lt;selectorStr&gt;)：JavaScript DOM 中的重要方法，document 对象的 按选择器查找 HTML 中的元素（CSS 中有效的所有选择器，除了伪类选择器都行）；  如果有多个符合选择器的对象，那么只会返回一个。想要返回全部，请使用...</div></div></div></a><a class="pagination-related" href="/technical/js-basic/" title="JavaScript入门笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/javascript.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-20</div><div class="info-item-2">JavaScript入门笔记</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference: 《Professional JavaScript for Web Developers》 3rd Edition 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 0. JavaScript 起源0.1 历史 Web 流行早期（上世纪末），Internet 用户上网速度 28.8 KB/s，但网页的大小和复杂性却不断增加。为完成简单的表单验证而频繁地与服务器交换数据只会加重用户的负担。于是，为了开发一种客户端语言，仅用来处理表单的简单验证工作，Netscape 公司在其发布的应用 Netscape Navigator 2 上加入一种脚本语言 LiveScript，认为是 JavaScript 的前身之一；  1995 年 2 月，Netscape 与 Sun 合作，为了搭上媒体热炒 Java 的顺风车，临时把 LiveScript 改名为 JavaScript，这就是 JavaScript 1.0；  其后不久，微软在自家作品 IE 3 中加入 JScript（是...</div></div></div></a><a class="pagination-related" href="/technical/react-quick-start/" title="React框架速通"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/react.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-27</div><div class="info-item-2">React框架速通</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference:  MDN Doc &amp;&amp; React Doc 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 0. 5 分钟速通 React 框架 如果你只有 5 分钟时间，则只需阅读这一章；否则请从 Chapter 1 开始。 建议有一定的原生 JavaScript 基础，至少包括：JS 基本类型、内置引用类型、函数表达式的各种操作，简单 DOM 操作，JavaScript 事件，JavaScript 异步（Promise）。  0.1 基本概念 React 应用程序是由 组件 组成的。  一个组件是 UI 的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。   React 组件是返回标签的 JavaScript 函数。 12345function MyButton() &#123;    return (        &lt;button&gt;I&#x27;m a button&lt;/button&gt;    );&#125;; React...</div></div></div></a><a class="pagination-related" href="/technical/redis-starter/" title="Redis 入门：从实践到理论"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/redis.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-12</div><div class="info-item-2">Redis 入门：从实践到理论</div></div><div class="info-2"><div class="info-item-1">Chapter 1. 基本概念和 CLI 使用1.1 NoSQL用于存储非结构化数据，不保证 ACID 事务特性（仅有最终一致性 Weak Consistency Model）。 Redis（Remote Dictionary Server）就是一类基于内存的键值型 NoSQL，不保证数据一致性，但可以保证性能。  一种 KVStore System，可以方便的存放非结构化数据，这对于缓存各异性数据非常有帮助；  Handle 网络请求多线程。处理指令单线程，单个指令具有原子性；  低延迟，利用 I/O Multiplexing 在单线程中处理多个请求； 支持数据持久化； 支持主从集群（从备份，读写分离）和分片集群（数据拆分，存储上限提高）；  1.2 Redis Data StructureRedis Key 一般使用 String，Value 支持：  基本类型：String、Hash、List、Set、SortedSet； 特殊类型：GEO（地理位置信息格式）、BitMap（位图）、HyperLog；  1.3 Basic Redis CLI Commands1.3.1...</div></div></div></a><a class="pagination-related" href="/technical/typescript-basic/" title="TypeScript笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/typescript.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-18</div><div class="info-item-2">TypeScript笔记</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference:  MDN Doc &amp;&amp; TypeScript Doc 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 1. 与 JS 比较：类型声明 与 作用域TypeScript 是个静态类型语言，变量类型/对象成员/函数签名 在定义后就不能更改！  定义变量时，请使用规范的类型声明定义方式： 1234567/* Variable */var foo: number;var bar: string = &quot;Hello, TypeScript!&quot;;/* Function */function toString(num: number): string &#123;    return String(num);&#125;  天大的福音：只声明变量、不赋值就使用会报错！这下不用担心讨厌的 undefined 了； 12let x: number;console.log(x); // TypeError 而且开启了编译选项 strictNullChecks...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SJTU-XHW</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">63</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-0-%E8%83%8C%E6%99%AF"><span class="toc-text">Chapter 0. 背景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF"><span class="toc-text">0.1 同步消息和异步消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-2-Message-Queue-%E9%80%89%E5%9E%8B"><span class="toc-text">0.2 Message Queue 选型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-Introduction-to-RabbitMQ"><span class="toc-text">Chapter 1. Introduction to RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%9E%B6%E6%9E%84"><span class="toc-text">1.1 架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Spring-AMQP"><span class="toc-text">1.2 Spring AMQP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-Working-Queues-%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.2.1 Working Queues 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-Fanout-Exchange"><span class="toc-text">1.2.2 Fanout Exchange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-Direct-Exchange"><span class="toc-text">1.2.3 Direct Exchange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-Topic-Exchange"><span class="toc-text">1.2.4 Topic Exchange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-Spring-AMQP-%E5%A3%B0%E6%98%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA-amp-%E9%98%9F%E5%88%97"><span class="toc-text">1.2.5 Spring AMQP 声明交换机 &amp; 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Method-1-Spring-Bean-Configuration-%E5%BC%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">Method 1. Spring Bean Configuration 式声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Method-2-Listener-%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">Method 2. Listener 注解式声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-6-Spring-AMQP-%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-text">1.2.6 Spring AMQP 消息转换器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Spring-AMQP-%E5%AE%9E%E6%88%98%EF%BC%9A%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9B%BF%E6%8D%A2-OpenFeign-%E5%90%8C%E6%AD%A5%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-text">1.3 Spring AMQP 实战：消息中间件替换 OpenFeign 同步远程调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-MQ-%E8%BF%9B%E9%98%B6%EF%BC%9A%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">Chapter 2. MQ 进阶：消息可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E6%96%B9%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9A%E9%87%8D%E8%BF%9E%E4%B8%8E%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">2.1 消息发布方的可靠性：重连与确认机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%8F%91%E9%80%81%E8%80%85%E9%87%8D%E8%BF%9E-%E6%80%A7%E8%83%BD%E8%AD%A6%E5%91%8A"><span class="toc-text">2.1.1 发送者重连 [性能警告]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E5%8F%91%E9%80%81%E8%80%85%E7%A1%AE%E8%AE%A4-%E6%80%A7%E8%83%BD%E8%AD%A6%E5%91%8A"><span class="toc-text">2.1.2 发送者确认 [性能警告]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-MQ-%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">2.2 MQ 的可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-MQ-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-%E9%BB%98%E8%AE%A4"><span class="toc-text">2.2.1 MQ 的数据持久化 [默认]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-Lazy-Queue-%E9%BB%98%E8%AE%A4"><span class="toc-text">2.2.2 Lazy Queue [默认]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">2.3 消费者的可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E6%B6%88%E8%B4%B9%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">2.3.1 消费者确认机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-text">2.3.2 消费者失败重试机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-text">2.4 业务幂等性保证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%94%AF%E4%B8%80%E6%B6%88%E6%81%AF-ID"><span class="toc-text">2.4.1 唯一消息 ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%9C%AC%E8%BA%AB%E5%88%A4%E6%96%AD"><span class="toc-text">2.4.2 业务逻辑本身判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-text">2.5 延迟任务和延迟消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%88dead-letter%EF%BC%89"><span class="toc-text">2.5.1 死信交换机（dead-letter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-Rabbit-MQ-%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%8F%92%E4%BB%B6"><span class="toc-text">2.5.2 Rabbit MQ 延时任务插件</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/redis-starter/" title="Redis 入门：从实践到理论"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/redis.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 入门：从实践到理论"/></a><div class="content"><a class="title" href="/technical/redis-starter/" title="Redis 入门：从实践到理论">Redis 入门：从实践到理论</a><time datetime="2024-11-12T13:05:37.000Z" title="发表于 2024-11-12 21:05:37">2024-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/python-sci-starter/" title="Python 科学计算入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/python_sci.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 科学计算入门"/></a><div class="content"><a class="title" href="/technical/python-sci-starter/" title="Python 科学计算入门">Python 科学计算入门</a><time datetime="2024-11-03T11:08:13.000Z" title="发表于 2024-11-03 19:08:13">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/hilog-paper/" title="OpenHarmony Hilog 架构趣读"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/hilog-paper.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenHarmony Hilog 架构趣读"/></a><div class="content"><a class="title" href="/technical/hilog-paper/" title="OpenHarmony Hilog 架构趣读">OpenHarmony Hilog 架构趣读</a><time datetime="2024-10-29T05:14:04.000Z" title="发表于 2024-10-29 13:14:04">2024-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/makefile-again/" title="Makefile 快速上手 (again)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/makefile-again.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Makefile 快速上手 (again)"/></a><div class="content"><a class="title" href="/review/makefile-again/" title="Makefile 快速上手 (again)">Makefile 快速上手 (again)</a><time datetime="2024-10-11T02:05:34.000Z" title="发表于 2024-10-11 10:05:34">2024-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/xss/" title="XSS 是什么？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/xss.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="XSS 是什么？"/></a><div class="content"><a class="title" href="/technical/xss/" title="XSS 是什么？">XSS 是什么？</a><time datetime="2024-10-04T04:15:33.000Z" title="发表于 2024-10-04 12:15:33">2024-10-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By SJTU-XHW  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Powered By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.sjtuxhw.top',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.sjtuxhw.top',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>