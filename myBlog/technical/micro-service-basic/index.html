<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>微服务初探 | SJTU-XHW's blog</title><meta name="author" content="SJTU-XHW,sjtuxhw12345@sjtu.edu.cn"><meta name="copyright" content="SJTU-XHW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chapter 0. 基本概念 微服务是一种软件架构风格。专注于单一职责的小型业务为基础，组成复杂大型应用。 需要解决的问题：服务拆分、远程调用（RPC）、服务治理（可用性与调度）、请求路由、身份认证、配置管 理、分布式事务（一致性问题）、异步通信…… 优点和特征：粒度小、单服务开发便捷，团队自治，服务自治，系统耦合性低； 缺点：跨模块开发难度大，运维成本高；   对比而言，单体架构：  优点：架">
<meta property="og:type" content="article">
<meta property="og:title" content="微服务初探">
<meta property="og:url" content="https://blog.sjtuxhw.top/technical/micro-service-basic/index.html">
<meta property="og:site_name" content="SJTU-XHW&#39;s blog">
<meta property="og:description" content="Chapter 0. 基本概念 微服务是一种软件架构风格。专注于单一职责的小型业务为基础，组成复杂大型应用。 需要解决的问题：服务拆分、远程调用（RPC）、服务治理（可用性与调度）、请求路由、身份认证、配置管 理、分布式事务（一致性问题）、异步通信…… 优点和特征：粒度小、单服务开发便捷，团队自治，服务自治，系统耦合性低； 缺点：跨模块开发难度大，运维成本高；   对比而言，单体架构：  优点：架">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/micro.jpg">
<meta property="article:published_time" content="2024-05-21T03:27:40.000Z">
<meta property="article:modified_time" content="2024-10-25T14:02:45.129Z">
<meta property="article:author" content="SJTU-XHW">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="Microservice">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/micro.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/technical/micro-service-basic/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '微服务初探',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><link rel="stylesheet" href="/css/talk.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SJTU-XHW's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/micro.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SJTU-XHW's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">微服务初探</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">微服务初探</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-21T03:27:40.000Z" title="发表于 2024-05-21 11:27:40">2024-05-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T14:02:45.129Z" title="更新于 2024-10-25 22:02:45">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/technical/micro-service-basic/#post-comment"><span class="waline-comment-count" data-path="/technical/micro-service-basic/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Chapter-0-基本概念"><a href="#Chapter-0-基本概念" class="headerlink" title="Chapter 0. 基本概念"></a>Chapter 0. 基本概念</h1><ul>
<li>微服务是一种软件架构风格。专注于单一职责的小型业务为基础，组成复杂大型应用。</li>
<li>需要解决的问题：服务拆分、远程调用（RPC）、服务治理（可用性与调度）、请求路由、身份认证、配置管 理、分布式事务（一致性问题）、异步通信……</li>
<li>优点和特征：粒度小、单服务开发便捷，团队自治，服务自治，系统耦合性低；</li>
<li>缺点：跨模块开发难度大，运维成本高；</li>
</ul>
<blockquote>
<p>对比而言，单体架构：</p>
<ul>
<li>优点：架构简单、部署成本低（适用于开发功能相对简单、规模较小的项目）；</li>
<li>缺点：团队协作成本高，系统发布效率低、系统可用性差（软件可靠性差）；</li>
</ul>
</blockquote>
<ul>
<li>对应框架：Spring Cloud，全球范围广泛使用的微服务框架；<ul>
<li>服务注册发现组件：Eureka、Nacos、Consul……</li>
<li>服务远程调用（RPC）；OpenFeign、Dubbo……</li>
<li>服务链路监控：Zipkin、Sleuth……</li>
<li>统一配置管理：Spring Cloud Config、Nacos……</li>
<li>统一网关路由：Spring Cloud Gateway、Zuul……</li>
<li>流控、降级、保护：Hystix、Sentinel……</li>
</ul>
</li>
</ul>
<h1 id="Chapter-1-基于实践学习：将单体架构拆分"><a href="#Chapter-1-基于实践学习：将单体架构拆分" class="headerlink" title="Chapter 1. 基于实践学习：将单体架构拆分"></a>Chapter 1. 基于实践学习：将单体架构拆分</h1><h2 id="1-1-基本思路"><a href="#1-1-基本思路" class="headerlink" title="1.1 基本思路"></a>1.1 基本思路</h2><ul>
<li>拆分时机：<ul>
<li>创业项目：先使用单体架构，快速开发、试错；规模扩大后再拆分；</li>
<li>确定的大型项目：资金充足，目标明确，直接选择微服务架构；</li>
</ul>
</li>
<li>拆分原则：<ul>
<li>高内聚：每个微服务的职责尽量单一，包含的业务相互关联度高、<strong>完整度高</strong>；</li>
<li>低耦合：每个微服务的功能要相对独立，尽量减少对其他微服务的依赖；</li>
</ul>
</li>
<li>拆分方式：<ul>
<li>纵向拆分：按业务模块拆分（用户认证管理、订单管理……）；</li>
<li>横向拆分：抽取公共服务，提高复用性（用户登录、订单管理中有公共服务，例如风控、日志服务）；</li>
</ul>
</li>
</ul>
<blockquote>
<p>具体如何拆分何种模式？</p>
<ul>
<li><p>独立 Project：一个单体架构的项目拆分后，将每个 service 放在一个独立 Project 内；</p>
<p>优点：相当解耦，关联度更低；</p>
<p>缺点：对于小型项目而言仓库管理臃肿费力；</p>
<p>适用：大型项目，每个 service 的业务逻辑相当复杂；</p>
</li>
<li><p>Maven 聚合：一个单体项目拆分后，所有 service 都存放在一个 project 中，这个 project 专门用于管理依赖，每个 service 都是 project 的一个 module；</p>
<p>适用：中小型项目，敏捷开发；</p>
</li>
</ul>
</blockquote>
<h2 id="1-2-远程调用-RPC：以-Spring-RestTemplate-为例"><a href="#1-2-远程调用-RPC：以-Spring-RestTemplate-为例" class="headerlink" title="1.2 远程调用 RPC：以 Spring RestTemplate 为例"></a>1.2 远程调用 RPC：以 Spring <code>RestTemplate</code> 为例</h2><p>拆分的问题：经常会遇到一个服务依赖另一个服务的情况。这可以直接通过服务间远程调用（RPC）来完成。</p>
<blockquote>
<p>远程调用 RPC 更像是一种软件协议，能<strong><u>让一个程序和本地执行流程一样，在远端执行一段代码</u></strong>。</p>
<p>在软件工程原理的 23 个设计模式中，更像是利用了 Proxy 设计模式。调用者无需关心远程信息交互的具体细节，只需按照接口像调用本地服务一样即可完成目标。</p>
</blockquote>
<p>在 Spring 中，一种轻量级的远程调用的方法是，使用接口：<code>RestTemplate</code>，调用它就相当于在 Java 代码中向 RESTful API 发送网络请求并且获取回复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">exchange</span><span class="params">(</span></span><br><span class="line"><span class="params">    String url,</span></span><br><span class="line"><span class="params">    HttpMethod method,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> HttpEntity&lt;?&gt; requestEntity,    <span class="comment">/* request body */</span></span></span><br><span class="line"><span class="params">       Class&lt;T&gt; responseType,</span></span><br><span class="line"><span class="params">    Map&lt;String, ?&gt; uriVariables</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>规避类型擦除：<code>new ParameterizedTypeReference&lt;T&gt;() &#123;&#125;</code>；</p>
</blockquote>
<p>但是有一些不可避免的问题：</p>
<ul>
<li>若代码中写死 <code>url</code>，则 负载均衡、可用性轮换等等策略全部失效；</li>
<li>若业务逻辑中的远程调用的部分较多，则 <code>RestTemplate</code> 对象散落各处不方便维护；</li>
<li>……</li>
</ul>
<p>于是我们需要更严格、复杂的架构将服务间的远程调用管理起来。一种思路就是 “<strong><u>发布-订阅者模式</u></strong>”；</p>
<h2 id="1-3-微服务的注册与发现机制"><a href="#1-3-微服务的注册与发现机制" class="headerlink" title="1.3 微服务的注册与发现机制"></a>1.3 微服务的注册与发现机制</h2><h3 id="1-3-1-发布-订阅模式（架构）"><a href="#1-3-1-发布-订阅模式（架构）" class="headerlink" title="1.3.1 发布-订阅模式（架构）"></a>1.3.1 发布-订阅模式（架构）</h3><p>发布-订阅者模式（pub-sub pattern）；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/pub-sub.png"></p>
<p>The Pub/Sub (Publisher/Subscriber) model is a messaging pattern used in software architecture to facilitate asynchronous communication between different components or systems. In this model, publishers produce messages that are then consumed by subscribers.</p>
<p>发布-订阅模型，作为一种消息传递模式，用在一些软件架构中，来实现不同组件、系统间的<strong><u>异步通信</u></strong>。</p>
<ul>
<li><p>subscribers：消息的获取方，publishers：消息生产方；</p>
</li>
<li><p>topics：一种订阅频道 / 分类（channels / categories）；</p>
<p>发布者可以按照消息的业务含义为消息打上话题标签（并且无需知道订阅者的特性），而订阅者可以按照 topics 来订阅、获取部分感兴趣的消息（并且无需知道发布者的特性）；</p>
<p>Topics help categorize messages and enable targeted message delivery to interested subscribers.</p>
</li>
<li><p>message brokers：一种中间件/中间人（intermediaries），负责在 publishers 和 subscribers 间使用合适的策略传递消息（调度队列、延时……）；</p>
<ul>
<li>message brokers 可以按 topics 维护一些消息队列；</li>
<li>确保消息发送给正确的订阅者，并且提供额外的特性：<strong><u>消息持久化、可扩展性、可靠性</u></strong>；</li>
</ul>
</li>
<li><p>message：可以是任何形式的数据信息（text, JSON, binary, etc）；</p>
</li>
<li><p>subscription：订阅代表了 subscriber 和某个 topics 建立的一个关联。它定义了：</p>
<ul>
<li>订阅者订阅了什么 topic 的消息；</li>
<li>订阅设置，例如是否事务、是否有订阅内容保证（at-most-once / at-least-once）等等；</li>
</ul>
</li>
</ul>
<p>发布-订阅模型的理论过程：</p>
<ol>
<li>发布者创建并发送消息给 pub/sub system，并且根据消息内容类型放入指定 topic 或者说 channel 中；</li>
<li>订阅者向 pub/sub system 表达需要订阅某个/些 topic 的意愿，有信息就会收到；</li>
<li><p>message brokers 根据收到发布者的 topic 对收到的消息分类，再根据所有 topics 的订阅情况 forward 给所有订阅了这个 topic 的 subscribers；</p>
</li>
<li><p>以上过程全部异步，发布者不需要关心订阅者的状态即可发布；订阅者无需关心发布者的状态即可接受消息。</p>
</li>
</ol>
<p>发布-订阅模型的优势：</p>
<ul>
<li>decoupling &amp; scalability：将消息生产方和消息接受方解耦，不仅无需关心对方状态和交互细节，而且 scalable，便捷地增减 publishers 和 subscribers 的数量而无需影响现有组件；</li>
<li>asynchronous communication：异步通信能力；</li>
<li>event-driven architecture：发布者和订阅者互不耦合，但发布者的事件行为可以影响订阅者；</li>
<li>dynamic subscription：允许运行时动态更换订阅，去耦合，全面的灵活性；</li>
</ul>
<p>发布-订阅模型的适用场景：</p>
<ul>
<li>消息队列系统；</li>
<li>需要构建 scalable web app 的时候，尤其是在线文档、实时更新的场景；</li>
<li>微服务架构间的远程通信；</li>
<li>……</li>
</ul>
<p>发布-订阅模型不应该使用的场景：</p>
<ul>
<li>对交互时延有极强需求的场景，例如游戏；</li>
<li>低复杂度的交互场景，例如系统只有两个组件间的交互，贸然引入会增大不必要的复杂度；</li>
<li>……</li>
</ul>
<p>回到微服务远程调用的主题上。为了确保服务远程调用的灵活性、可用性，我们可以借鉴 发布-订阅者模式，通过注册、发现、订阅的流程，动态调度服务的访问方式。</p>
<p>这样既可以有效地、统一地管理远程访问，提升可维护性，又可以便捷地进行调度，充分利用服务资源。</p>
<h3 id="1-3-2-注册中心"><a href="#1-3-2-注册中心" class="headerlink" title="1.3.2 注册中心"></a>1.3.2 注册中心</h3><p>在微服务架构中，规避微服务间直接远程调用缺陷的一种方式就是引入注册中心机制，借鉴发布-订阅模式，引入注册中心后的主要步骤如下：</p>
<ol>
<li>服务发布者向注册中心注册服务信息（提供何种服务，即 topic，还有地址在哪里）；</li>
<li>服务订阅者向注册中心订阅感兴趣的服务。此时注册中心可以将<strong><u>当前可用的</u></strong>发布者信息告诉订阅者；</li>
<li>订阅者（或者注册中心）可以进行负载均衡，选择一个发布者向其请求服务（远程调用）。</li>
</ol>
<p>由于我们利用了发布-订阅模式，所以即便是已经获取服务列表的订阅者，也能从注册中心实时获取当前发布者的可用情况。例如：</p>
<blockquote>
<p>假设订阅者从注册中心获取了 3 个可能的服务发布者，但是一段时间后其中一个服务提供方 A 宕机。</p>
<p>这个时候 A 不再通过注册中心的 health check（heart beat），注册中心认为 A 不再有效，于是向所有订阅了 A 服务所在 topic 的所有订阅者推送变更。</p>
<p>这就保证了订阅者订阅列表的有效性。创建了新的服务实例也是如此！实现了 scalable service，随意增减服务实例数量、负载均衡。</p>
</blockquote>
<hr>
<p>在代码方面，我们知道在 Spring Cloud 中，注册中心有很多实现，例如 Alibaba 的 Nacos，Netflix 的 Eureka。我们就以其中的 Nacos 为例。我们只需要将注册中心部署在固定 IP 的服务器上即可。</p>
<p>配置好 Nacos，在注册服务客户端（也就是提供服务方）引入 nacos 注册发现服务，还需要对 Spring 进行配置，指定 registry server 的地址和需要的服务名。最后启动这个服务实例即可完成注册！</p>
<p>而在服务调用端，需要在项目中引入 Nacos Client，它实现了 Spring Cloud 的 <code>DiscoveryClient</code> 接口。</p>
<p>我们直接注入 <code>DiscoverClient</code>，使用如下方法：</p>
<ul>
<li><code>DiscoverClient.getInstances(String serviceName) -&gt; List&lt;ServiceInstance&gt;</code>，<code>serviceName</code> 是服务提供方在 Nacos 中注册的服务名；</li>
<li>而我们可以通过 <code>ServiceInstance</code> 获取 <code>uri / host / port</code> 信息，手动写负载均衡或其他处理工作。</li>
</ul>
<blockquote>
<p>注：Nacos 需要导入依赖 <code>spring-cloud-starter-alibaba-nacos-discovery</code>，并且进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">nacos.server-addr:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-3-3-更优雅的远程调用：OpenFeign"><a href="#1-3-3-更优雅的远程调用：OpenFeign" class="headerlink" title="1.3.3 更优雅的远程调用：OpenFeign"></a>1.3.3 更优雅的远程调用：OpenFeign</h3><h4 id="初步认识-OpenFeign"><a href="#初步认识-OpenFeign" class="headerlink" title="初步认识 OpenFeign"></a>初步认识 OpenFeign</h4><p>但是这里有个问题，我们通过 <code>DiscoverClient</code> 获取可用服务列表，然后再处理一系列可能的异常，然后还要手写 <code>RestTemplate</code> 进行远程调用，最后才能访问服务！</p>
<p>如此繁琐的远程调用，我们应该进行封装！好在同样有框架能够更轻松地帮助我们完成远程调用：OpenFeign；</p>
<blockquote>
<p>注：我们还要对负载均衡算法进行封装。使用 Spring cloud load balancer 就能解决问题。</p>
</blockquote>
<p>引入 OpenFeign 的方法如下：</p>
<ul>
<li><p>引入 OpenFeign 依赖；</p>
</li>
<li><p>在 Springboot Application 启动类注解 <code>@EnableFeignClients</code> 启用 OpenFeign 的特性；</p>
</li>
<li><p>定义接口，用于指定要远程调用的服务名、远程调用服务名的 endpoint。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;)</span>    <span class="comment">/* 需要向注册中心申请的服务名 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 告诉 OpenFeign 需要连接远程服务的 endpoint 相当于指定 RestTemplate 的 uri 和 HttpMethod */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    <span class="comment">/* 告诉 OpenFeign 的传入参数、请求体信息，以及服务返回 JSON 对应的类型，相当于指定 RestTemplate 的 RequestEntity，responseType，uriVariables */</span></span><br><span class="line">    List&lt;ItemDto&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样相当于实现了 proxy 设计模式（这个 interface 对应 Spring 生成的实例就是 proxy），在调用远程服务就像调用本地服务一样简单！</p>
<h4 id="OpenFeign-连接池优化"><a href="#OpenFeign-连接池优化" class="headerlink" title="OpenFeign 连接池优化"></a>OpenFeign 连接池优化</h4><p>OpenFeign 的底层实现非常类似我们手动使用 <code>DiscoverClient</code>，并且考虑负载均衡、服务异常的情况。</p>
<p>感兴趣的同学可以步进调试观察其底层行为。</p>
<p>值得注意的是，OpenFeign 底层默认的远程调用的方式是利用 <code>HttpURLConnection</code> 类（位于 <code>FeignBlockingLoadBalancerClient</code> 的 <code>delegate</code> 成员变量），而这个 Java 内置类比较底层，不支持连接池，不像 apache 的 <code>HttpClient</code> 和 <code>OkHttp</code>，可能造成资源利用率较低。</p>
<p>好在我们可以为 OpenFeign 的底层请求更换具有连接池的连接类，这样可以减小创建和销毁连接的开销，有助于提升程序性能。只需导入依赖相应依赖（例如 <code>feign-okhttp</code>），并且在 <code>application.yaml/properties</code> 中配置开启即可（例如 <code>feign.okhttp.enabled = true</code>）；</p>
<blockquote>
<p>注意，是在 OpenFeign 调用方模块设定才有效！</p>
</blockquote>
<h4 id="OpenFeign-最佳实践"><a href="#OpenFeign-最佳实践" class="headerlink" title="OpenFeign 最佳实践"></a>OpenFeign 最佳实践</h4><p>到这里仍然没有结束，我们还需要知道 OpenFeign 框架的最佳实践。</p>
<p>上面介绍引入 OpenFeign 的方法实际上是有严重问题的。我们发现，当单体架构的程序被拆成微服务后，有可能多个服务依赖同一个微服务，难不成所有用到的微服务都要定义一遍像 <code>ItemClient</code> 一样的接口？</p>
<p>我们知道，代码重复是大忌，这不仅降低了可维护性（增添维护人员心智负担）、可扩展性（修改繁琐，不对修改开发），还降低了代码可读性和正确性。</p>
<p>正确使用 OpenFeign 的方案有几种：</p>
<ul>
<li><p>直接交给服务提供方编写 Feign Client，将服务提供方拆成 3 个模块：</p>
<ul>
<li><code>DTO</code> 中包含向服务调用方返回的数据类型；</li>
<li><code>api</code> 中包含 <code>FeignClient</code> 接口以供调用；</li>
<li><code>blz</code> 中包含原先的代码业务逻辑；</li>
</ul>
<p>最后其他服务只需引用该服务为依赖即可。</p>
<p>优点：代码逻辑更合理，易于维护，耦合度更低；</p>
<p>缺点：项目结构更复杂、编写麻烦；</p>
</li>
<li><p>创建一个不属于任何一个微服务模块的、同级的 <code>api</code> module，专门管理 <code>FeignClient</code>，主要包含：</p>
<ul>
<li><code>client</code>：所有微服务想要向外暴露的 <code>FeignClient</code>；</li>
<li><code>config</code>：所有微服务的配置类；</li>
<li><code>dto</code>：所有微服务想要返回的数据类型；</li>
</ul>
<p>优点：项目结构清晰，无需改动原先微服务；</p>
<p>缺点：代码耦合度增加，每个微服务模块都需要引入该模块为依赖（而前一种方法只需引入需要用的模块就行），所有微服务都需要和 <code>api</code> 一起开发；</p>
<p>但是如果以这种方式创建 <code>FeignClient</code>，没法完成依赖注入（因为 Spring Application 没法自主扫描本包以外的 bean），就需要手动指定接口类型，并将其纳入 IoC Container 中。两种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 SpringApplication 启动类启用 FeignClient 时显示指定 bean 类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方法一：为 Spring 指定 bean 扫描的包名（精确到子包） */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &lt;package name&gt;)</span></span><br><span class="line"><span class="comment">/* 方法二：利用反射手动指定 bean 对应接口的 Class 类型 */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(clients = &#123; &lt;classname&gt;.class &#125;)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="OpenFeign-日志管理"><a href="#OpenFeign-日志管理" class="headerlink" title="OpenFeign 日志管理"></a>OpenFeign 日志管理</h4><p>OpenFeign 框架默认情况下仅在 <code>FeignClient</code> 所在包配置的日志级别为 <code>DEBUG</code> 时才会输出日志，并且自身的日志级别是 <code>NONE</code>（不输出），故需要我们手动配置。</p>
<blockquote>
<p>注：OpenFeign 自身的日志级别有 4 种：<code>NONE / BASIC / HEADERS / FULL</code>；</p>
</blockquote>
<p>定义 OpenFeign 的日志级别需要完成两件事：</p>
<ol>
<li><p>定义配置类，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 没有 @Configuration / @Service 等注解，该 @Bean 不会被纳入 IoC Container */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将配置类配置给指定 / 全局的 <code>FeignClient</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指定 FeignClient */</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;...&quot;, configuration = FeignConfig.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局 FeignClient 默认 */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = FeignConfig.class)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="1-4-微服务网关"><a href="#1-4-微服务网关" class="headerlink" title="1.4 微服务网关"></a>1.4 微服务网关</h2><p>在大致拆好微服务后，有个问题就随之出现：前端应该如何访问后端服务？难道前端还需要动态获取各个服务的地址？</p>
<p>肯定不能这样，我们的期望是前后端的解耦，就是说单体架构和微服务架构下，前端是无需改变的，只需要向固定的地址发送不同请求就能得到对应的响应，这就需要一个中间层来完成这个任务。</p>
<p>这个能将不同服务转发给某个符合条件的微服务的中间层就是网关。网关不仅能完成前面的 forward 的功能，还能<strong><u>配合注册中心</u></strong>进行负载均衡。</p>
<blockquote>
<p>功能：</p>
<ul>
<li>请求路由（路径针对什么微服务？）；</li>
<li>转发（帮忙将 HTTP 请求 forward 给某个动态地址的实例）；</li>
<li>身份校验（检查请求的 <code>Authorization</code> 是否合法）；</li>
</ul>
</blockquote>
<p>这样，我们就不需要在每个微服务中进行身份校验等繁琐工作了。更安全的是，后端微服务甚至不需要向外暴露端口了，只需暴露网关，大大增强安全性。</p>
<p>此外，引入网关后，后端实现了封装和解耦，在前端看来这和单体架构别无二致。</p>
<h3 id="1-4-1-微服务网关框架：Spring-Cloud-Gateway"><a href="#1-4-1-微服务网关框架：Spring-Cloud-Gateway" class="headerlink" title="1.4.1 微服务网关框架：Spring Cloud Gateway"></a>1.4.1 微服务网关框架：Spring Cloud Gateway</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Spring Cloud Gateway</th>
<th>Netflix Zuul</th>
</tr>
</thead>
<tbody>
<tr>
<td>基于 <code>WebFlux</code> 响应式编程</td>
<td>基于 <code>Servlet</code> 阻塞式编程</td>
</tr>
<tr>
<td>无需调优即有很好性能</td>
<td>需要调优才有接近Spring Cloud Gateway 的性能</td>
</tr>
<tr>
<td>正常维护</td>
<td>更新较慢</td>
</tr>
</tbody>
</table>
</div>
<p>基于上述特点，我们以 Spring Cloud Gateway 为例。</p>
<p>它的使用很简单：导入依赖、编写启动类、编写配置。</p>
<h4 id="Spring-Cloud-Gateway-配置示例"><a href="#Spring-Cloud-Gateway-配置示例" class="headerlink" title="Spring Cloud Gateway 配置示例"></a>Spring Cloud Gateway 配置示例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">gateway:</span></span><br><span class="line">            <span class="attr">routes:</span>		<span class="comment"># 路由规则列表</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">&lt;Route</span> <span class="string">ID&gt;</span> <span class="comment"># 独一无二的路由 ID</span></span><br><span class="line">                  <span class="attr">uri:</span> <span class="string">lb://&lt;service</span> <span class="string">name&gt;</span> <span class="comment"># load balance，到指定服务</span></span><br><span class="line">                  <span class="attr">predicates:</span>	<span class="comment"># 筛选断言条件（列表）</span></span><br><span class="line">                  	<span class="bullet">-</span> <span class="string">Path=/xx/**</span>	<span class="comment"># 支持通配符</span></span><br><span class="line">                  <span class="attr">filters:</span></span><br><span class="line">                  	<span class="bullet">-</span> [<span class="string">...</span>]<span class="string">=[...]</span></span><br><span class="line">            <span class="attr">default-filters:</span></span><br><span class="line">                <span class="bullet">-</span> [<span class="string">...</span>]<span class="string">=[...]</span></span><br></pre></td></tr></table></figure>
<p>众所周知，<code>application.yaml</code> 中的配置内容相当于 XML Bean，都在向 Spring 框架的类型中填写初始化属性罢了。这里 <code>spring.cloud.gateway.routes</code> 对应的是 <code>Collection&lt;RouteDefinition&gt;</code> 类型。</p>
<p>其中，<code>predicates</code> 属性可取以下值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>After</td>
<td>是某个时间点后的请求</td>
<td>After=2037-01-20T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td>Before</td>
<td>是某个时间点之前的请求</td>
<td>Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td>
</tr>
<tr>
<td>Between</td>
<td>是某两个时间点之前的请求</td>
<td>Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td>Cookie</td>
<td>请求必须包含某些cookie</td>
<td>Cookie=chocolate, ch.p</td>
</tr>
<tr>
<td>Header</td>
<td>请求必须包含某些header</td>
<td>Header=X-Request-Id, \d+</td>
</tr>
<tr>
<td>Host</td>
<td>请求必须是访问某个host（域名）</td>
<td>Host=**.somehost.org,**.anotherhost.org</td>
</tr>
<tr>
<td>Method</td>
<td>请求方式必须是指定方式</td>
<td>Method=GET,POST</td>
</tr>
<tr>
<td>Path</td>
<td>请求路径必须符合指定规则</td>
<td>Path=/red/{segment},/blue/**</td>
</tr>
<tr>
<td>Query</td>
<td>请求参数必须包含指定参数</td>
<td>Query=name, Jack 或者 Query=name</td>
</tr>
<tr>
<td>RemoteAddr</td>
<td>请求者的ip必须是指定范围</td>
<td>RemoteAddr=192.168.1.1/24</td>
</tr>
<tr>
<td>Weight</td>
<td>权重处理</td>
<td>Weight=group1, 2</td>
</tr>
<tr>
<td>X-Forwarded Remote Addr</td>
<td>基于请求的来源IP做判断</td>
<td>XForwardedRemoteAddr=192.168.1.1/24</td>
</tr>
</tbody>
</table>
</div>
<p><code>filters</code> 可取以下值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>AddRequestHeader</td>
<td>给当前请求添加一个请求头</td>
<td>AddrequestHeader=headerName,headerValue</td>
</tr>
<tr>
<td>RemoveRequestHeader</td>
<td>移除请求中的一个请求头</td>
<td>RemoveRequestHeader=headerName</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>给响应结果中添加一个响应头</td>
<td>AddResponseHeader=headerName,headerValue</td>
</tr>
<tr>
<td>RemoveResponseHeader</td>
<td>从响应结果中移除有一个响应头</td>
<td>RemoveResponseHeader=headerName</td>
</tr>
<tr>
<td>RewritePath</td>
<td>请求路径重写（ant path 语法）</td>
<td>RewritePath=/red/?(?\&lt;segment\</td>
<td>.*), /\\{segment}</td>
</tr>
<tr>
<td>StripPrefix</td>
<td>去除请求路径中的N段前缀</td>
<td>StripPrefix=1，则路径/a/b转发时只保留/b</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>一共有 33 种，详见官网。</p>
</blockquote>
<p>值得注意的是，filter 是基于 router 生效的、作用于 router 的。Spring Cloud 中的 filter 分为两种：</p>
<ul>
<li>GlobalFilter：全局过滤器，作用于所有路由，在声明该过滤器后无需激活即可生效；</li>
<li>GatewayFilter：路由过滤器，共 33 种，作用于指定路由，默认不生效。上面的在<strong><u>配置文件</u></strong>中写的 <code>filters</code> 就是这个过滤器！</li>
</ul>
<h4 id="Spring-Cloud-Gateway-过滤机制-以及-Spring-Security-对比"><a href="#Spring-Cloud-Gateway-过滤机制-以及-Spring-Security-对比" class="headerlink" title="Spring Cloud Gateway 过滤机制 以及 Spring Security 对比"></a>Spring Cloud Gateway 过滤机制 以及 Spring Security 对比</h4><p>这里只介绍了网关 forward 的配置，那么如果想对网关做更进一步的配置（例如身份验证），应该怎么操作？</p>
<p>首先需要了解 Spring Cloud Gateway 的底层机制。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='imgs/gateway-filters.png'></p>
<p>这里的思路几乎和 Spring Security 的过滤器链一模一样（责任链模式）。</p>
<p>因此我们想加入身份验证功能，就需要在 Filter 的 <code>PRE</code> 部分定义检查逻辑。如果符合条件，则允许通过 <code>NettyRoutingFilter</code> 进行转发；否则抛出异常立即拒绝请求。</p>
<p>现在做身份验证的思路就非常清楚了：自定义一个 Filter 类，最好像 Spring Security 的 <code>OncePerRequestFilter</code> 一样每次请求仅通过一次，插入到 <code>NettyRoutingFilter</code> 之前，就能完成任务。</p>
<p><strong><u>但是有几点和之前的微服务架构截然不同</u></strong>！！！</p>
<p>考虑第一点：网关如何向微服务传递当前登录用户的信息？</p>
<p>注意到现在网关、各个微服务都是独立的服务了，和单体架构不同，我们<strong>不能</strong>通过保存在类似于 <code>SecurityContext</code> 这样的单线程上下文（<code>ThreadLocal</code>）中，把网关中检查的用户信息传给 forward 的目标服务了。</p>
<p>回忆一下，网关向微服务 forward 实际上已经是一次新的 HTTP 请求了，而且我们之前在 Gateway 的 filters 参数中看到，gateway 可以配置额外添加请求头信息。因此不难想到，我们可以通过在网关的自定义 filter 中加入关于用户信息的请求头就能解决这个问题！</p>
<p>但再考虑第二个问题：既然网关和微服务间通过传递请求头来完成用户信息传递，那微服务之间相互调用也很频繁，它们默认还是原来的请求方式（<code>Nacos + OpenFeign</code>），没有请求头，难道要更改原来的代码，每个微服务请求 Client Proxy 时还要主动记录和传递用户信息？</p>
<p>是的！不过幸好 <code>OpenFeign</code> 有另一套方法帮我们加上这个请求头，所以不必担心。</p>
<p>下面我们来认识一下如何自定义 filter，并且完成身份认证的功能。</p>
<h4 id="自定义-Global-Filter"><a href="#自定义-Global-Filter" class="headerlink" title="自定义 Global Filter"></a>自定义 Global Filter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义 PRE 部分的 Gateway Global Filter </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 经过该 filter 时，过滤器链的请求上下文，包括 request、response、前面的 filter 写入的信息；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 过滤器链中下一条要执行的 filter</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 类似 JavaScript 中的回调函数。采用了 WebFlux 的非阻塞的、响应式接口，因为 PRE 和 POST 间时间可能很长，所以实际上 POST 部分 filter 是通过定义这个回调的行为来完成的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">    <span class="comment">/* 合理的做法是，和 Spring Security 类似，返回 chain.filter(exchange)，将 filter 链委托给下一级 */</span></span><br><span class="line">    <span class="comment">/* 如果想要阻止请求（例如未认证），那么请拿到 response，set response code，并且返回一个 response.setComplete() 标识请求已经回复（拒绝） */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还需要注意的是：</p>
<ul>
<li>global filter 需要继承于 <code>Ordered</code> 接口；</li>
<li>并且重写 <code>int getOrder()</code> 方法，这样能为 filter 安排插入顺序。注意：返回的整型越小优先级越高，并且 <code>NettyRoutingFilter</code> 的 order 是最大整型，因此任意一个不是 <code>INT_MAX</code> 的 order 都会让 filter 排在它的前面；</li>
<li>最后需要使用 <code>@Component</code> 纳入 Spring IoC Container 管理；</li>
<li>最后还要选一个配置类，使用 <code>@Bean</code> 提供一个 <code>GlobalFilter</code> 实例！！</li>
</ul>
<h4 id="自定义-Gateway-Filter"><a href="#自定义-Gateway-Filter" class="headerlink" title="自定义 Gateway Filter"></a>自定义 Gateway Filter</h4><p>这就是我们自定义写在 <code>filters</code> 配置文件中的 filter。本部分为进阶功能，一般使用不到。</p>
<p>我们需要继承于 <code>AbstractGatewayFilterFactory&lt;Object&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title class_">AbtractGatewayFilterFactory</span>&lt;Config&gt; &#123;</span><br><span class="line">    <span class="comment">/* config 类型请使用你想要的，例如 List 或者自定义类型 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;<span class="keyword">void</span>&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">/* same as Global Filter */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 定义传给 config 的数据类型 */</span></span><br><span class="line">    <span class="meta">@Data</span>    <span class="comment">// lombok</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String a;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        <span class="keyword">private</span> String c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 定义配置参数缩写名（类似设定命令行参数缩写） */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用构造函数告诉 AbstractGatewayFilterFactory config 的配置类型 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintAnyGatewayFilterFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>Config</code> 类型可以换成任何的自定义类型，以完成参数配置需求。如果不需要任何参数，直接使用 <code>Object</code> 类型，后面 3 个函数也就没有必要了。</p>
<p>这样前缀 <code>PrintAny</code>（去除 <code>GatewayFilterFactory</code>）就是配置名，我们就能自定义 filters 参数了：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">gateway:</span></span><br><span class="line">            <span class="attr">routes:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">...</span></span><br><span class="line">                  <span class="attr">uri:</span> <span class="string">...</span></span><br><span class="line">             	  <span class="attr">predicates:</span> <span class="string">...</span></span><br><span class="line">             	  <span class="attr">filters: PrintAny:</span> <span class="string">&lt;config&gt;</span>	<span class="comment"># 需要和自己定义的 config 类型匹配</span></span><br></pre></td></tr></table></figure>
<p>此外，对于 <code>GatewayFilter</code> 如果想指定顺序，请使用 <code>OrderedGatewayFilter</code> 包装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedGatewayFilter</span>(<span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Mono&lt;<span class="keyword">void</span>&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">            <span class="comment">/* same as Global Filter */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="comment">/* order */</span> <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下，<code>GatewayFilter</code> 的定义使用了抽象工厂模式，满足了多样化定制需求。</p>
<h4 id="Spring-Cloud-Gateway-传递用户信息"><a href="#Spring-Cloud-Gateway-传递用户信息" class="headerlink" title="Spring Cloud Gateway 传递用户信息"></a>Spring Cloud Gateway 传递用户信息</h4><p>现在我们来解决之前提到的两个问题：</p>
<ul>
<li>网关如何向微服务传递当前登录用户的信息？</li>
<li>微服务之间相互调用如何使用 <code>OpenFeign</code> 传递用户信息？</li>
</ul>
<p>对第一个问题，我们采用如下思路：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/g2m.png"></p>
<p>这样我们微服务中的业务在本微服务内就沿用之前的 context 方案，无需更改，只需要修改进入微服务的拦截器即可；</p>
<p>先看如何更改 <code>GlobalFilter</code> 的请求内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ServerWebExchange.mutate() 方法可以返回已初始化的对象的 builder 以供修改 */</span></span><br><span class="line">exchange.mutate()</span><br><span class="line">    <span class="comment">/* 传递修改 request 的 build 方法 */</span></span><br><span class="line">    .request(builder -&gt; builder.head(<span class="string">&quot;info&quot;</span>, info))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>对于新建拦截器，我们不必在每个微服务中都写一遍，只需在共同依赖的模块中写入即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 识别信息并保存到 context，不作拦截 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 请求结束后，请销毁 context */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记得把 Interceptor 配置到 Spring 中，在每次请求前进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="comment">/* 拦截器实例 */</span>);</span><br><span class="line">            <span class="comment">/* .addPathPattern() 可以选择作用的 path pattern，不写就是作用全部 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是还需要注意，这里的 Bean 现在没法被其他用到的模块扫描到，我们需要在这个模块的 <code>resources/META_INF/spring.factories</code> 中，配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">    &lt;package name&gt;.MvcConfig</span></span><br></pre></td></tr></table></figure>
<p>这样使得在该项目中， Spring 默认会将这个类加入 IoC Container。</p>
<blockquote>
<p>注意：在 Spring 3.x 以后，已经全面取消 <code>spring.factories</code> 中的 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 键的作用了。</p>
<p>在 Spring 3.x 的项目中，上面的配置是无效的，Spring 是不会扫描并且自动装配你指定的类的。</p>
<p>你需要在 <code>META-INT/spring/</code> 目录下新建一个文件 ``</p>
</blockquote>
<p>但是需要注意，这里采用的 <code>WebMvcConfigurer</code> 只能在微服务中生效，不能在 Gateway 中生效（因为 Gateway 是 <code>WebFlux</code> 非阻塞式接口，不能引入 Spring MVC 的接口），所以我们需要条件装配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 MvcConfig 前面的加入注解 */</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span>    <span class="comment">/* 该类是 Spring MVC 的核心 API */</span></span><br></pre></td></tr></table></figure>
<p>对于第二个问题，我们只需要对 <code>OpenFeign</code> 的请求进行定义：让每次 <code>OpenFeign</code> 触发微服务间调用时，都带上一个自定义的请求头，就像网关传给微服务一样。这里使用 <code>OpenFeign</code> 给的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这同样要定义在所有微服务中都依赖的模块中（因为是配置，所以用 bean 注入）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在某个配置 Feign 的类中 */</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">            <span class="comment">/* 配置请求头 */</span></span><br><span class="line">            template.header(&lt;header name str&gt;, &lt;context&gt; <span class="comment">/* 位于同线程，可用 */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个配置类需要显式配置给 <code>OpenFeign</code>（就像之前配置 Feign 日志的全局配置一样）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(value = ..., defaultConfiguration = 该类名)</span></span><br></pre></td></tr></table></figure>
<h1 id="Chapter-2-微服务理论"><a href="#Chapter-2-微服务理论" class="headerlink" title="Chapter 2. 微服务理论"></a>Chapter 2. 微服务理论</h1><h2 id="2-1-微服务雪崩"><a href="#2-1-微服务雪崩" class="headerlink" title="2.1 微服务雪崩"></a>2.1 微服务雪崩</h2><p>在微服务相互调用中，服务提供者出现故障或阻塞。并且：</p>
<ul>
<li>服务调用者没有做好异常处理，导致自身故障；</li>
<li>或者访问连接一直保持 / 请求速度大于处理速率，致使请求不断堆积在 tomcat 中导致资源耗尽；</li>
</ul>
<p>最终，调用链中的所有服务级联失败，导致整个集群故障。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='imgs/avalanche.png' width="500px"></p>
<p>解决微服务雪崩的思路主要如下：</p>
<ol>
<li>尝试避免出现故障 / 阻塞；<ul>
<li>保证代码的健壮性；</li>
<li>保证网络畅通；</li>
<li>能应对较高的并发请求；</li>
<li><strong>微服务保护</strong>：保护服务提供方；</li>
</ul>
</li>
<li>局部出现故障 / 阻塞后，及时做好预备方案（积极有效的错误处理）；<ul>
<li><strong>微服务保护</strong>：保护服务调用方；</li>
</ul>
</li>
</ol>
<h2 id="2-2-微服务保护"><a href="#2-2-微服务保护" class="headerlink" title="2.2 微服务保护"></a>2.2 微服务保护</h2><p>为了应对微服务雪崩，我们有许多解决方案。其中，微服务保护是在业务逻辑代码层面以外的一种重要方案。</p>
<p>微服务保护有以下一些思路：</p>
<ul>
<li><p>请求限流：保护服务提供方。限制访问微服务的请求的并发量，避免服务因流量激增出现故障（<strong>应对访问模式：spike 型</strong>）；</p>
</li>
<li><p>线程隔离（舱壁模式）：保护服务消费方。通过限定每个业务能使用的线程数量而将故障业务隔离，避免故障扩散；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/thread-isolation.png" width="400px"></p>
</li>
<li><p>快速失败 和 服务熔断：</p>
<ul>
<li>快速失败：给业务编写一个调用失败时的处理的逻辑，称为 <code>fallback</code>。当调用出现故障（比如无线程可用）时，按照失败处理逻辑执行业务并返回，而不是直接抛出异常；</li>
<li>由<strong>断路器</strong>统计请求的异常比例或慢调用比例，如果超出阈值，则认为<strong>某个微服务业务所对应的所有实例都不可用</strong>，熔断该业务，则拦截该接口的请求。熔断期间，所有请求均 <code>fallback</code> 为快速失败逻辑；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/fuse.png" width="400px"></p>
</li>
</ul>
<p>以上微服务保护的策略可以使用 <code>Sentinel</code> / <code>Hystrix</code> 框架完成。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Metrics or Feature</th>
<th><code>Sentinel</code></th>
<th><code>Hystrix</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Belong to</td>
<td>Spring Cloud Alibaba</td>
<td>Spring Cloud Netflix</td>
</tr>
<tr>
<td>Thread Isolation</td>
<td>信号量隔离</td>
<td>线程池隔离/信号量隔离</td>
</tr>
<tr>
<td>Fuse Policy</td>
<td>基于慢调用比例或异常比例</td>
<td>基于异常比率</td>
</tr>
<tr>
<td>Traffic Limiting</td>
<td>基于 QPS，支持流量整形</td>
<td>支持</td>
</tr>
<tr>
<td>Fallback</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Configuration Method</td>
<td>基于控制台，重启后失效</td>
<td>基于注解或配置文件，永久生效</td>
</tr>
</tbody>
</table>
</div>
<p>想了解微服务保护框架具体如何使用，请参见官网样例或官方文档。</p>
<h2 id="2-3-微服务分布式事务"><a href="#2-3-微服务分布式事务" class="headerlink" title="2.3 微服务分布式事务"></a>2.3 微服务分布式事务</h2><blockquote>
<p>在分布式系统中，如果一个业务需要多个服务合作完成，而且每一个服务都有事务，多个事务必须同时成功或失败，这样的事务就是<strong><u>分布式事务</u></strong>。其中的每个服务的事务就是一个<strong>分支事务</strong>。整个业务称为<strong>全局事务</strong>。</p>
</blockquote>
<p>除了微服务雪崩的问题外，微服务设计中还存在一个重难点：如何保证微服务数据 ACID 的性质（如何正确进行分布式事务）。</p>
<p>以一个商品订单服务为例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imgs/inconsistency.png" width="600px"></p>
<p>如果最终库存服务失败，那么虽然订单服务可能可以识别到错误并且回滚，但是购物车服务与库存服务间没有关系，极有可能不会回滚，造成数据的不一致性。这就是没有保证分布式事务一致性。</p>
<p>那么我们应该如何保证微服务流程的一致性？</p>
<p>这个时候需要引入一个分布式事务的协调组件，让各个子事务（分支事务）感知到彼此的事务状态，根据总体的事务状态进行判断，协调全局事务的提交或回滚，这样就能保证事务状态和数据的一致性。</p>
<p>这个分布式事务的协调组件被称为：<strong>事务协调者（Transaction Coordinator，TC）</strong>；</p>
<p>除了事务协调者，还需要有一个组件，用于定义单个全局事务的范围（从哪个子事务开始，到哪个子事务结束）。这个组件就被称为：<strong>事务管理器（Transaction Manager，TM）</strong>；</p>
<p>有了 TC 和 TM，就能准确地定义一个全局事务； </p>
<p>为了进一步从业务逻辑中解耦，我们额外增添一个组件用于说明某个子事务的事务状态。它的作用是，向 TC 注册子事务，并且报告子事务的事务状态。这就被称为：<strong>资源管理器（Resource Manager，RM</strong>）；</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SJTU-XHW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/technical/micro-service-basic/">https://blog.sjtuxhw.top/technical/micro-service-basic/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SJTU-XHW's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Web/">Web</a><a class="post-meta__tags" href="/tags/Microservice/">Microservice</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/micro.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/technical/rabbit-mq/" title="Introduction to Rabbit MQ"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/rabbit.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Introduction to Rabbit MQ</div></div><div class="info-2"><div class="info-item-1">Chapter 0. 背景0.1 同步消息和异步消息微服务架构下存在很多服务间相互调用的情况。 我们知道可以通过 OpenFeign 的方式来获取远程服务的响应，但是 OpenFeign 的远程调用是同步的，其优点是同步调用时效强，等待结果返回。但同时会导致：  代码可扩展性差。 性能堪忧。相较于相同项目实现的单体架构，同步的微服务调用方式会多出网络等待时间。  于是我们需要异步调用的方式，这里使用到了发布-订阅者模式。 异步调用的优势是，  模块间进一步解耦（发布者和订阅者间无需知道相互之间的信息）； 可拓展性强（scalable），添加实例无需更改代码； 异步性能有明显提升； 故障隔离（最终一致性保证）； 缓存消息，实现流量削峰填谷；  但是缺点也很明显：  异步实现无法立即得到结果，时效性差，可能导致数据不一致性； 不作额外措施，则不能保证最终一致性（下游业务是否成功）。所以业务安全依赖于 broker 的可靠性；  0.2 Message Queue...</div></div></div></a><a class="pagination-related" href="/technical/semaphore-mutex-and-cv/" title="Semaphore, Mutex, CV"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/smc.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Semaphore, Mutex, CV</div></div><div class="info-2"><div class="info-item-1">学习 ICS 的并行一章之后，笔者有些疑惑，semaphore（信号量）、mutex（互斥锁）、conditional variables（条件变量）这 3 者之间究竟该怎么区分它们的使用场景？ 首先我们需要去阐述清楚它们各自的定义和效果。 学术界认为 mutex 是 semaphore 的特例，因此像著名的书籍 CSAPP 就先以 semaphore 为例讲了讲并发程序的资源控制问题。但是实际上有相当一部分实践派和语义派认为二者不应该混为一谈。像 Linus 本人在一次将 Linux 内核的一部分 semaphore 重构为 mutex 后，发现不仅改善了代码语义，还在一定程度上提升了性能。这件事也说明了，虽然在理论上一方可以替代另一方，但实践上它们各有所长。 Semaphore vs Mutex我们先讨论 semaphore。 CSAPP 中先从 “线程间变量共享” 的情况说起，它指出，程序对内存的更改并不直接在内存上完成，在汇编中可以看到，大致经历了 load（从内存到 CPU 寄存器）、update（在 CPU 寄存器内更新数据）、store（将 CPU...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/technical/rabbit-mq/" title="Introduction to Rabbit MQ"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/rabbit.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-01</div><div class="info-item-2">Introduction to Rabbit MQ</div></div><div class="info-2"><div class="info-item-1">Chapter 0. 背景0.1 同步消息和异步消息微服务架构下存在很多服务间相互调用的情况。 我们知道可以通过 OpenFeign 的方式来获取远程服务的响应，但是 OpenFeign 的远程调用是同步的，其优点是同步调用时效强，等待结果返回。但同时会导致：  代码可扩展性差。 性能堪忧。相较于相同项目实现的单体架构，同步的微服务调用方式会多出网络等待时间。  于是我们需要异步调用的方式，这里使用到了发布-订阅者模式。 异步调用的优势是，  模块间进一步解耦（发布者和订阅者间无需知道相互之间的信息）； 可拓展性强（scalable），添加实例无需更改代码； 异步性能有明显提升； 故障隔离（最终一致性保证）； 缓存消息，实现流量削峰填谷；  但是缺点也很明显：  异步实现无法立即得到结果，时效性差，可能导致数据不一致性； 不作额外措施，则不能保证最终一致性（下游业务是否成功）。所以业务安全依赖于 broker 的可靠性；  0.2 Message Queue...</div></div></div></a><a class="pagination-related" href="/technical/js-basic-2/" title="JavaScript入门笔记-(2)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/javascript2.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-25</div><div class="info-item-2">JavaScript入门笔记-(2)</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference: 《Professional JavaScript for Web Developers》 3rd Edition 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 7. 简单使用 DOM假设你学习了初级数据结构，那么把 HTML 页面想象成一个以元素为结点的一般树。JavaScript DOM 操作就是操作这个文档树，达到改变前端页面的目的。 在浏览器运行的 JavaScript 引擎中，全局运行环境中会自动设置一个变量 document（DOM 对象），操作它就是在动态操作 HTML 页面。 7.1 基本操作 假设你学习了 CSS 的基础用法。   document.querySelector(&lt;selectorStr&gt;)：JavaScript DOM 中的重要方法，document 对象的 按选择器查找 HTML 中的元素（CSS 中有效的所有选择器，除了伪类选择器都行）；  如果有多个符合选择器的对象，那么只会返回一个。想要返回全部，请使用...</div></div></div></a><a class="pagination-related" href="/technical/js-basic/" title="JavaScript入门笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/javascript.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-20</div><div class="info-item-2">JavaScript入门笔记</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference: 《Professional JavaScript for Web Developers》 3rd Edition 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 0. JavaScript 起源0.1 历史 Web 流行早期（上世纪末），Internet 用户上网速度 28.8 KB/s，但网页的大小和复杂性却不断增加。为完成简单的表单验证而频繁地与服务器交换数据只会加重用户的负担。于是，为了开发一种客户端语言，仅用来处理表单的简单验证工作，Netscape 公司在其发布的应用 Netscape Navigator 2 上加入一种脚本语言 LiveScript，认为是 JavaScript 的前身之一；  1995 年 2 月，Netscape 与 Sun 合作，为了搭上媒体热炒 Java 的顺风车，临时把 LiveScript 改名为 JavaScript，这就是 JavaScript 1.0；  其后不久，微软在自家作品 IE 3 中加入 JScript（是...</div></div></div></a><a class="pagination-related" href="/technical/react-quick-start/" title="React框架速通"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/react.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-27</div><div class="info-item-2">React框架速通</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference:  MDN Doc &amp;&amp; React Doc 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 0. 5 分钟速通 React 框架 如果你只有 5 分钟时间，则只需阅读这一章；否则请从 Chapter 1 开始。 建议有一定的原生 JavaScript 基础，至少包括：JS 基本类型、内置引用类型、函数表达式的各种操作，简单 DOM 操作，JavaScript 事件，JavaScript 异步（Promise）。  0.1 基本概念 React 应用程序是由 组件 组成的。  一个组件是 UI 的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。   React 组件是返回标签的 JavaScript 函数。 12345function MyButton() &#123;    return (        &lt;button&gt;I&#x27;m a button&lt;/button&gt;    );&#125;; React...</div></div></div></a><a class="pagination-related" href="/technical/redis-starter/" title="Redis 入门：从实践到理论"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/redis.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-12</div><div class="info-item-2">Redis 入门：从实践到理论</div></div><div class="info-2"><div class="info-item-1">Chapter 1. 基本概念和 CLI 使用1.1 NoSQL用于存储非结构化数据，不保证 ACID 事务特性（仅有最终一致性 Weak Consistency Model）。 Redis（Remote Dictionary Server）就是一类基于内存的键值型 NoSQL，不保证数据一致性，但可以保证性能。  一种 KVStore System，可以方便的存放非结构化数据，这对于缓存各异性数据非常有帮助；  Handle 网络请求多线程。处理指令单线程，单个指令具有原子性；  低延迟，利用 I/O Multiplexing 在单线程中处理多个请求； 支持数据持久化； 支持主从集群（从备份，读写分离）和分片集群（数据拆分，存储上限提高）；  1.2 Redis Data StructureRedis Key 一般使用 String，Value 支持：  基本类型：String、Hash、List、Set、SortedSet； 特殊类型：GEO（地理位置信息格式）、BitMap（位图）、HyperLog；  1.3 Basic Redis CLI Commands1.3.1...</div></div></div></a><a class="pagination-related" href="/technical/typescript-basic/" title="TypeScript笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/typescript.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-18</div><div class="info-item-2">TypeScript笔记</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference:  MDN Doc &amp;&amp; TypeScript Doc 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 1. 与 JS 比较：类型声明 与 作用域TypeScript 是个静态类型语言，变量类型/对象成员/函数签名 在定义后就不能更改！  定义变量时，请使用规范的类型声明定义方式： 1234567/* Variable */var foo: number;var bar: string = &quot;Hello, TypeScript!&quot;;/* Function */function toString(num: number): string &#123;    return String(num);&#125;  天大的福音：只声明变量、不赋值就使用会报错！这下不用担心讨厌的 undefined 了； 12let x: number;console.log(x); // TypeError 而且开启了编译选项 strictNullChecks...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SJTU-XHW</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">Chapter 0. 基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-%E5%9F%BA%E4%BA%8E%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%B0%86%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%8B%86%E5%88%86"><span class="toc-text">Chapter 1. 基于实践学习：将单体架构拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-text">1.1 基本思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8-RPC%EF%BC%9A%E4%BB%A5-Spring-RestTemplate-%E4%B8%BA%E4%BE%8B"><span class="toc-text">1.2 远程调用 RPC：以 Spring RestTemplate 为例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">1.3 微服务的注册与发现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%9E%B6%E6%9E%84%EF%BC%89"><span class="toc-text">1.3.1 发布-订阅模式（架构）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-text">1.3.2 注册中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%EF%BC%9AOpenFeign"><span class="toc-text">1.3.3 更优雅的远程调用：OpenFeign</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86-OpenFeign"><span class="toc-text">初步认识 OpenFeign</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenFeign-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BC%98%E5%8C%96"><span class="toc-text">OpenFeign 连接池优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenFeign-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">OpenFeign 最佳实践</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenFeign-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86"><span class="toc-text">OpenFeign 日志管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3"><span class="toc-text">1.4 微服务网关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E6%A1%86%E6%9E%B6%EF%BC%9ASpring-Cloud-Gateway"><span class="toc-text">1.4.1 微服务网关框架：Spring Cloud Gateway</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Cloud-Gateway-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B"><span class="toc-text">Spring Cloud Gateway 配置示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Cloud-Gateway-%E8%BF%87%E6%BB%A4%E6%9C%BA%E5%88%B6-%E4%BB%A5%E5%8F%8A-Spring-Security-%E5%AF%B9%E6%AF%94"><span class="toc-text">Spring Cloud Gateway 过滤机制 以及 Spring Security 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Global-Filter"><span class="toc-text">自定义 Global Filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Gateway-Filter"><span class="toc-text">自定义 Gateway Filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Cloud-Gateway-%E4%BC%A0%E9%80%92%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">Spring Cloud Gateway 传递用户信息</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA"><span class="toc-text">Chapter 2. 微服务理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9"><span class="toc-text">2.1 微服务雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4"><span class="toc-text">2.2 微服务保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">2.3 微服务分布式事务</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/java-adv-3/" title="Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/java-adv-3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI"/></a><div class="content"><a class="title" href="/technical/java-adv-3/" title="Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI">Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI</a><time datetime="2025-01-06T05:44:06.000Z" title="发表于 2025-01-06 13:44:06">2025-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/algo-desgin-table/" title="算法设计知识点自查表"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/algo-design-table.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法设计知识点自查表"/></a><div class="content"><a class="title" href="/review/algo-desgin-table/" title="算法设计知识点自查表">算法设计知识点自查表</a><time datetime="2024-12-31T14:47:03.000Z" title="发表于 2024-12-31 22:47:03">2024-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/redis-starter/" title="Redis 入门：从实践到理论"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/redis.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 入门：从实践到理论"/></a><div class="content"><a class="title" href="/technical/redis-starter/" title="Redis 入门：从实践到理论">Redis 入门：从实践到理论</a><time datetime="2024-11-12T13:05:37.000Z" title="发表于 2024-11-12 21:05:37">2024-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/python-sci-starter/" title="Python 科学计算入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/python_sci.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 科学计算入门"/></a><div class="content"><a class="title" href="/technical/python-sci-starter/" title="Python 科学计算入门">Python 科学计算入门</a><time datetime="2024-11-03T11:08:13.000Z" title="发表于 2024-11-03 19:08:13">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/hilog-paper/" title="OpenHarmony Hilog 架构趣读"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/hilog-paper.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenHarmony Hilog 架构趣读"/></a><div class="content"><a class="title" href="/technical/hilog-paper/" title="OpenHarmony Hilog 架构趣读">OpenHarmony Hilog 架构趣读</a><time datetime="2024-10-29T05:14:04.000Z" title="发表于 2024-10-29 13:14:04">2024-10-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SJTU-XHW  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Powered By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>