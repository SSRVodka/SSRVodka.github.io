<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CMake 进阶 | SJTU-XHW's blog</title><meta name="author" content="SJTU-XHW,sjtuxhw12345@sjtu.edu.cn"><meta name="copyright" content="SJTU-XHW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="written by SJTU-XHW Reference:  CMake Tutor 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 本文目标：在前文（GNU Tutor）初步了解 CMake、C++ 编译过程后，继续深入学习 CMake 在 C++ 构建中的使用；">
<meta property="og:type" content="article">
<meta property="og:title" content="CMake 进阶">
<meta property="og:url" content="https://blog.sjtuxhw.top/technical/cmake-advanced/index.html">
<meta property="og:site_name" content="SJTU-XHW&#39;s blog">
<meta property="og:description" content="written by SJTU-XHW Reference:  CMake Tutor 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 本文目标：在前文（GNU Tutor）初步了解 CMake、C++ 编译过程后，继续深入学习 CMake 在 C++ 构建中的使用；">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/cmake.png">
<meta property="article:published_time" content="2023-07-21T13:41:05.000Z">
<meta property="article:modified_time" content="2024-10-25T13:53:42.454Z">
<meta property="article:author" content="SJTU-XHW">
<meta property="article:tag" content="CMake">
<meta property="article:tag" content="GNU">
<meta property="article:tag" content="Programmimg">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/cmake.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/technical/cmake-advanced/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CMake 进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-25 21:53:42'
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SJTU-XHW's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/cmake.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SJTU-XHW's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">CMake 进阶</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CMake 进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-21T13:41:05.000Z" title="发表于 2023-07-21 21:41:05">2023-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T13:53:42.454Z" title="更新于 2024-10-25 21:53:42">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/technical/cmake-advanced/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><i>written by SJTU-XHW</i></p>
<p><i>Reference: </i> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMake Tutor</a></p>
<p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p>
<p>本文目标：在前文（GNU Tutor）<strong>初步了解 CMake、C++ 编译过程后</strong>，继续深入学习 CMake 在 C++ 构建中的使用；</p>
<hr>
<span id="more"></span>
<blockquote>
<p>⚠ <strong>劝退警告：如果你只想用 IDE 一键编译运行，而不想了解构建和编译细节，那么这篇文章不是为你准备的！</strong></p>
</blockquote>
<h2 id="Chapter-0-Make-介绍"><a href="#Chapter-0-Make-介绍" class="headerlink" title="Chapter 0. Make 介绍"></a>Chapter 0. Make 介绍</h2><blockquote>
<p><strong>对 Make 没兴趣的这章可以跳过</strong>！</p>
<p>CMake 生成的 Makefile 究竟是什么？语法是怎样？为什么要有它？</p>
<p>由于现在是 21 世纪 20 年代，所以像 <code>make</code> 这样底层的古董就点到为止；；</p>
</blockquote>
<ul>
<li><p>地位：GNU 计划的一个开源程序；</p>
</li>
<li><p>作用</p>
<ol>
<li>制定整个项目的<strong>编译规则</strong>（利用 <code>Makefile</code> 定义整个编译流程以及各个目标文件与源文件之间的依赖关系），自动化编译步骤，以此提高开发效率；</li>
<li>二次编译时，仅重新编译你的修改会影响到的部分，从而降低编译的时间；</li>
</ol>
</li>
<li><p>劣势：为什么上面说 “点到为止”？因为它比较底层，导致抽象层级不高，<strong>不能跨平台</strong>，每个平台有各自的 make 程序，导致编写 <code>Makefile</code> 较为繁琐；</p>
<blockquote>
<p>例如在 前文 “GNU Tutor” 中提到的 MinGW 编译器中的 make 和 Unix 系统下的 make 就有所差别；</p>
</blockquote>
<p><strong>这一劣势将由 CMake 进行弥补</strong>，之后讨论；</p>
</li>
</ul>
<h3 id="0-1-Makefile-的规则"><a href="#0-1-Makefile-的规则" class="headerlink" title="0.1 Makefile 的规则"></a>0.1 Makefile 的规则</h3><h4 id="0-1-1-显式规则"><a href="#0-1-1-显式规则" class="headerlink" title="0.1.1 显式规则"></a>0.1.1 显式规则</h4><ul>
<li><p>定义：显式规则说明了如何生成一个或多个目标文件。这是由 Makefile 的书写者明显指出要生成的文件、文件的依赖文件和生成的命令；</p>
</li>
<li><p>基本语法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt;</span><br><span class="line">    &lt;command&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># And   &lt;-- Makefile 的行注释是 “#” 字符</span></span><br><span class="line"></span><br><span class="line">&lt;pTarget&gt; :</span><br><span class="line">    &lt;command&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>target</code>：可以是一个object file（<code>*.o</code>），也可以是一个执行文件（最终目标）；</p>
</li>
<li><p><code>pTarget</code>：在一个 makefile 中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等；被称为<strong>伪目标</strong>；</p>
<blockquote>
<p><code>pTarget</code> 部分在运行 <code>make</code> 的时候不会自动调用，外界可以使用 <code>make [pTargetName]</code> 来手动调用，例如：<code>make clean</code>，<code>make install</code> （如果 Makefile 中定义了的话）</p>
</blockquote>
</li>
<li><p><code>prerequisites</code>：生成该 <code>target</code> 所依赖的文件<strong>和</strong> <code>target</code>；</p>
</li>
<li><p><code>command</code>：该 <code>target</code> 或 <code>motion</code> 要执行的命令（任意的 shell 命令）</p>
</li>
</ul>
<p><strong>这指明了文件的依赖关系，即：<code>target</code> 这一个或多个的目标文件依赖于 <code>prerequisites</code> 中的文件，其生成规则定义在 <code>command</code> 中。</strong></p>
<blockquote>
<p>有有同学会问，Make 是怎么做到 <strong>上面的第二条作用（仅重新编译修改的部分）</strong>的呢？</p>
<p>很简单，如果 <code>prerequisites</code> 文件的日期要比 <code>targets</code> 文件的日期要新，或者 <code>target</code> 不存在的话，那么，make 就会执行后续定义的 <code>command</code>；</p>
</blockquote>
</li>
<li><p>示例：这个例子可以不需要了解项目依赖关系；废话少说，上栗子🌰：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设有一个项目包含 3 个头文件、8个源文件（名称如下）：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终目标 edit</span></span><br><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间目标</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪目标</span></span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">backup :</span><br><span class="line">    cp edit main.o kbd.o command.o display.o \</span><br><span class="line">     insert.o search.o files.o utils.o /opt/</span><br><span class="line">install :</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>中间目标一般都是 <code>*.o</code> ；最终目标视需求而定，可以是可执行文件，也可以是动/静态链接库；</p>
</li>
<li><p><code>prerequisites</code> 是目标的依赖，一般是 <code>*.h/c/cpp</code>；</p>
</li>
<li><p><code>command</code> 是获得目标 / 完成动作的操作；上面的例子中，<strong><code>cc</code> 是 C 的编译器命令，<code>cp</code> 和 <code>rm</code> 是 Unix 系统的命令</strong>；</p>
<blockquote>
<ol>
<li><strong>必须以制表符（或者说 <code>\t</code>、Tab 键）开头</strong>；</li>
<li>默认工作目录为 Makefile 所在目录；</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>（规范）伪目标声明</strong>：对于<strong>伪目标</strong>而言，应该使用 <code>.PHONY</code> 关键字声明，更符合规范；</p>
<p>例如上面例子的规范写法应该加上：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean backup install</span><br></pre></td></tr></table></figure>
<p>另外，规范来说，请将所有伪目标写在后面，以防读者误认为最终目标；</p>
<ul>
<li><p>作用：防止与文件名/最终目标重名，增强可读性；</p>
</li>
<li><p>特点：伪目标<strong>可以有依赖</strong>，这样相当于是<strong>委托调用</strong>，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">    rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">    rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">    rm *.diff</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>指定文件查找目录：<code>VPATH</code> 关键字（知道就行）；</p>
</li>
</ul>
<h4 id="0-1-2-隐晦规则"><a href="#0-1-2-隐晦规则" class="headerlink" title="0.1.2 隐晦规则"></a>0.1.2 隐晦规则</h4><blockquote>
<p>作用：make 有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile；</p>
</blockquote>
<ol>
<li>生成 <code>*.o</code> 时，默认将同名的 <code>*.c/cpp</code> 加入依赖中，同时<strong>省去相应的编译命令</strong>；</li>
<li>当 make 在 Makefile 中找不到与目标同名的 <code>*.c/cpp</code>，那么 make 认为这个目标为伪目标；</li>
</ol>
<p>因此，利用隐晦规则，最开始的例子可以简化为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">    </span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：上面的 “<code>-rm edit</code>” 前面有个 “-”，表示中间如果出现错误，也请继续进行的意思（忽略错误）；</p>
<p>这里正好补充一下 Makefile 的变量使用：</p>
<ul>
<li>定义：<code>name=value</code>；调用：<code>$&#123;variableName&#125;</code>；</li>
<li><strong>类似 C++ 中的宏替换</strong>（后面介绍赋值运算符）；</li>
</ul>
</blockquote>
<h4 id="0-1-3-文件指示-和-编译设置"><a href="#0-1-3-文件指示-和-编译设置" class="headerlink" title="0.1.3 文件指示 和 编译设置"></a>0.1.3 文件指示 和 编译设置</h4><p><strong>文件指示一共包含 3 个部分</strong>：</p>
<ol>
<li><strong>在一个 Makefile 中引用另一个 Makefile</strong>，就像 C 语言中的 #include 一样；</li>
<li>根据某些情况<strong>指定 Makefile 中的有效部分</strong>，就像 C 语言中的预编译 #if 一样；</li>
<li>还有就是<strong>定义一个多行的命令</strong>，不会深入介绍，感兴趣请查看 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://seisman.github.io/how-to-write-makefile/index.html">教程</a>；</li>
</ol>
<p>这里就介绍第一个：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make *.mk $&#123;bar&#125;</span><br></pre></td></tr></table></figure>
<p>上面这行代码的含义是：包含 <code>foo.make</code>，所有后缀为 <code>mk</code> 的，和在变量 <code>$&#123;bar&#125;</code> 中的文件作为 Makefile；</p>
<p>此外，以 UNIX 为例，make 自动包含了 <code>/usr/local/bin</code> 和 <code>/usr/include</code> 中的文件；</p>
<p>还可以加上 “-” 表示读取错误全部忽略：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> foo.make *.mk $&#123;bar&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译设置</strong> 最常用的是设置 C++ 编译器，可以由修改内置变量完成：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC := clang</span><br><span class="line">CXX := clang++</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的代码含义是：<strong>将 C 编译器改为 <code>clang</code>，将 C++ 编译器改为 <code>clang++</code></strong>；</p>
</blockquote>
<h4 id="0-1-4-赋值运算符"><a href="#0-1-4-赋值运算符" class="headerlink" title="0.1.4 赋值运算符"></a>0.1.4 赋值运算符</h4><blockquote>
<p>看到上面的例子，大家可能有些疑惑，<code>:=</code> 和 <code>=</code> 赋值有区别吗？答案是，有的。</p>
</blockquote>
<ul>
<li><p><code>=</code> 是<strong>保留计算式</strong>的赋值；</p>
</li>
<li><p><code>:=</code> 是<strong>立刻计算结果</strong>并覆盖原来的值；</p>
</li>
<li><p><code>?=</code> 是如果没有被赋值过就赋予等号后面的值；</p>
</li>
<li><p><code>+=</code> 是添加等号后面的值；</p>
</li>
</ul>
<p>举个例子体会一下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = foo</span><br><span class="line">y = <span class="variable">$(x)</span> bar</span><br><span class="line">x = xyz</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="string">&quot;<span class="variable">$(y)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := xyz</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="string">&quot;<span class="variable">$(y)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面一段 Makefile 运行 <code>make all</code> 会输出：<code>xyz bar</code>；</p>
<p>而下面一段会输出：<code>foo bar</code>；</p>
<h4 id="0-1-5-小结：Make-的工作方式"><a href="#0-1-5-小结：Make-的工作方式" class="headerlink" title="0.1.5 小结：Make 的工作方式"></a>0.1.5 小结：Make 的工作方式</h4><ol>
<li><p>读入所有的 Makefile；</p>
</li>
<li><p>读入被 include 的其它 Makefile；</p>
</li>
<li><p>初始化文件中的变量；</p>
</li>
<li><p>推导隐晦规则，并分析所有规则；</p>
</li>
<li><p>为所有的目标文件创建依赖关系链；</p>
</li>
<li><p>根据依赖关系，决定哪些目标要重新生成；</p>
</li>
<li><p>执行生成命令；</p>
</li>
</ol>
<h3 id="0-2-Make-命令的使用"><a href="#0-2-Make-命令的使用" class="headerlink" title="0.2 Make 命令的使用"></a>0.2 Make 命令的使用</h3><ul>
<li>Windows 上如果安装 <code>MinGW</code> 编译器套件，那么应该使用 <code>mingw32-make</code> 来进行；不讨论 <code>MSVC</code> 编译器套件 ~ 用它的大多数是用了微软的 Visual Studio 的套件；</li>
<li>Linux 本身就是 GNU 产物，直接安装 <code>make</code> 就能用了；</li>
</ul>
<h2 id="Chapter-1-CMake-命令使用"><a href="#Chapter-1-CMake-命令使用" class="headerlink" title="Chapter 1. CMake 命令使用"></a>Chapter 1. CMake 命令使用</h2><p>众所周知，CMake 可以完成 2 步：① 将 CMakeLists.txt 翻译生成 Makefile；② 代替 make 完成编译构建；</p>
<p>下面我们特指 ① 为 <strong>生成</strong>，② 为 <strong>编译/构建</strong>；</p>
<h3 id="1-1-生成指令"><a href="#1-1-生成指令" class="headerlink" title="1.1 生成指令"></a>1.1 生成指令</h3><p>总体语法：<code>cmake [options] &lt;projectDir&gt;</code>（<code>projectDir</code> 需含有 <code>CMakeLists.txt</code>）；</p>
<p>下面介绍 <code>[options]</code>：</p>
<ul>
<li><p>指定生成 Makefile 等中间文件的目录（生成时会将所有文件放入该目录）：<code>-B &lt;dirName&gt;</code>（<code>dirName</code> 默认当前目录，下同）；</p>
</li>
<li><p><strong>指定生成的 Makefile 种类</strong>：<code>-G &lt;Makefile-Type&gt;</code>；</p>
<blockquote>
<p>这里 Unix 类系统（macOS 和 Linux）会默认 <code>&quot;Unix Makefiles&quot;</code>，<strong>大多数情况下无需更改</strong>，因为<strong>使用 Unix 内置的 GNU/Make 程序和 GNU/GCC 编译器</strong>；</p>
<p>这里<strong>对于 Windows 用户很重要</strong>，因为 Windows 的 make 工具种类很多，针对您所安装的编译器对应的 <code>make</code>，需要进行合理选择，取值有（有空格，命令行里记得加双引号）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Visual Studio 17 2022        &lt;--- 使用 VS IDE 的同学不需要指定，IDE 会自动设置</span><br><span class="line">Visual Studio 16 2019</span><br><span class="line">Visual Studio 15 2017 [arch]</span><br><span class="line">Visual Studio 14 2015 [arch]</span><br><span class="line">Visual Studio 12 2013 [arch]</span><br><span class="line">Visual Studio 11 2012 [arch]</span><br><span class="line">Visual Studio 9 2008 [arch]</span><br><span class="line">Borland Makefiles</span><br><span class="line">NMake Makefiles            &lt;--- 使用 nmake 的同学选这个</span><br><span class="line">NMake Makefiles JOM</span><br><span class="line">MSYS Makefiles</span><br><span class="line">MinGW Makefiles            &lt;--- 使用正宗 MinGW 编译器的同学选这个</span><br><span class="line">Green Hills MULTI</span><br><span class="line">Unix Makefiles            &lt;--- Unix 系统的同学不需要指定，系统会自动设置</span><br><span class="line">Ninja                    &lt;--- 使用 Ninja 的同学选这个</span><br><span class="line">Ninja Multi-Config</span><br><span class="line">Watcom WMake</span><br><span class="line">CodeBlocks - MinGW Makefiles    &lt;--- 你的 codeblocks 装了什么编译器？</span><br><span class="line">CodeBlocks - NMake Makefiles</span><br><span class="line">CodeBlocks - NMake Makefiles JOM</span><br><span class="line">CodeBlocks - Ninja</span><br><span class="line">CodeBlocks - Unix Makefiles</span><br><span class="line">CodeLite - MinGW Makefiles</span><br><span class="line">CodeLite - NMake Makefiles</span><br><span class="line">CodeLite - Ninja</span><br><span class="line">CodeLite - Unix Makefiles</span><br><span class="line">Eclipse CDT4 - NMake Makefiles</span><br><span class="line">Eclipse CDT4 - MinGW Makefiles</span><br><span class="line">Eclipse CDT4 - Ninja</span><br><span class="line">Eclipse CDT4 - Unix Makefiles</span><br><span class="line">Kate - MinGW Makefiles</span><br><span class="line">Kate - NMake Makefiles</span><br><span class="line">Kate - Ninja</span><br><span class="line">Kate - Ninja Multi-Config</span><br><span class="line">Kate - Unix Makefiles</span><br><span class="line">Sublime Text 2 - MinGW Makefiles</span><br><span class="line">Sublime Text 2 - NMake Makefiles</span><br><span class="line">Sublime Text 2 - Ninja</span><br><span class="line">Sublime Text 2 - Unix Makefiles</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="1-2-编译构建指令"><a href="#1-2-编译构建指令" class="headerlink" title="1.2 编译构建指令"></a>1.2 编译构建指令</h3><ul>
<li><p><strong>构建编译</strong>（可代替 <code>make</code>）：<code>cmake --build &lt;dirName&gt;</code>；</p>
<blockquote>
<p>和 Make 一样，可以仅重新编译你的修改会影响到的部分，从而降低编译的时间；</p>
</blockquote>
</li>
</ul>
<h2 id="Chapter-2-CMakeList-常见函数"><a href="#Chapter-2-CMakeList-常见函数" class="headerlink" title="Chapter 2. CMakeList 常见函数"></a>Chapter 2. CMakeList 常见函数</h2><blockquote>
<p>注：CMake 的函数名不区分大小写；</p>
<p>以下函数分为 3 个等级：optional 可选、recommended 推荐书写、necessary 必要；</p>
<p>众所周知，C++ 项目的编译和构建的目标可以是 <strong>可执行文件</strong>，也可以是<strong>静/动态链接库</strong>；以下函数如果仅用于某个特定目标，那么会标注 <strong>in EXE Project</strong> 或 <strong>in LIB Project</strong>；</p>
</blockquote>
<ul>
<li><p>【optional】指定 CMake 版本，可选低于版本产生致命错误：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ver 建议是当前系统中的 CMake 版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION &lt;ver&gt; [FATAL_ERROR])</span><br><span class="line"><span class="comment"># 例如我的 CMake 版本是 3.12，并且想让其他人生成时，CMake低于这个版本就报错，那么这么写：</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span> FATAL_ERROR)</span><br></pre></td></tr></table></figure>
</li>
<li><p>【recommended】指定 Project 名称、使用编译器语言（不填写也可自动识别）：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span> (&lt;projectName&gt; [LANGUAGES CXX])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意，这里指定项目名称后，变量 <code>$&#123;PROJECT_NAME&#125;</code> 就被设定了，可以在后面使用</strong>；</p>
</blockquote>
</li>
<li><p>【optional】告诉编译器从哪里寻找非标准 C++ 的头文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span> (&lt;dir&gt;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以理解为：</p>
<p>Makefile 中的 include 关键字：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;dir&gt;/*</span><br></pre></td></tr></table></figure>
<p>或者 g++ 中的 <code>-I</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ [...] -I&lt;<span class="built_in">dir</span>&gt; [...]</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>【optional】向指定目标规定寻找非标准 C++ 头文件路径：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TARGET_INCLUDE_DIRECTORIES</span> (&lt;targetName&gt; [INTERFACE | PRIVATE | PUBLIC] &lt;dir&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PUBLIC 表示这个项目的外部使用者能看到</span></span><br><span class="line"><span class="comment"># PRIVATE 则对外部完全隐藏，即不希望调用这个项目目标的使用者知道“这个项目引入了该头文件”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><code>INCLUDE_DIRECTORIES</code> 和 <code>TARGET_INCLUDE_DIRECTORIES</code> 比较：</strong></p>
<p>前者是向整个项目（包括子目录和库）添加了寻找头文件的寻找路径；</p>
<p>后者是向特定目标添加了寻找头文件的寻找路径，<strong>同时可以指定暴露级别</strong>；</p>
<p><strong>这就和不同范围设置 C++ 标准异曲同工</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_STANDARD <span class="number">11</span>)        <span class="comment"># 全局设置 C++ 规范</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">TARGET_COMPILE_FEATURES</span> (&lt;targetName&gt; [...] cxx_std_11)    <span class="comment"># 设置特定库的规范</span></span><br></pre></td></tr></table></figure>
<p>从项目规范性上说，<strong>建议使用 <code>TARGET_INCLUDE_DIRECTORY</code> 而非 <code>INCLUDE_DIRECTORY</code></strong>；</p>
</blockquote>
</li>
<li><p>【necessary <strong>in EXE Project</strong>】将指定源文件加入构建为 <strong>可执行文件</strong> 的目标中：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (&lt;exeName&gt; &lt;sourceFileNames&gt;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>位于 <code>TARGET_LINK_LIBRARIES</code> 前，在其他函数之后；</p>
<p><strong>注意，和 Make 的隐晦规则恰好相反，如果这个头文件被某一源文件引入的话，可以省略对应的头文件</strong>；</p>
</blockquote>
</li>
<li><p>【recommended】查找指定目录下的所有源文件，并将文件名存入变量：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (&lt;dir&gt; &lt;variableName&gt;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此后就能使用变量：<code>$&#123;&lt;variableName&gt;&#125;</code>；</p>
</blockquote>
</li>
<li><p>【optional】给项目加入子目录（<strong>即读取这个目录下的 <code>CMakeLists.txt</code></strong>）：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span> (&lt;dir&gt;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>书写这个函数后，在主 <code>CMakeLists.txt</code> 中就可以直接指明子目录下生成的目标名，<strong>这在导入并链接自己编写的 动/静态链接库 时用的较多</strong>；</p>
</blockquote>
</li>
<li><p>【necessary <strong>in LIB Project</strong>】将指定源文件加入构建为 <strong>链接库</strong> 的目标中：</p>
<blockquote>
<p>请大家复习一下什么是 “静态链接库”、什么是 “动态链接库”：</p>
<p>静态链接库是 <strong>运行前、编译时可以链接进入到目标文件中</strong>，优点是分发时文件个数少，不依赖外部文件；缺点是修改了静态链接库的内容的话程序整体需要重新编译；</p>
<p>动态链接库是 <strong>运行时才链接到目标文件中</strong>，优点是只要 API 不变，修改动态链接库可以单独进行编译，并且节省内存（仅在调用库函数时才加载到内存中）；缺点是文件分发数多，不便管理；</p>
<p><strong>注：C++ 的库的隐含规则——链接库文件名是 “lib” + 库名 + 后缀</strong>；</p>
</blockquote>
<ol>
<li><p><strong>目标为静态链接库</strong>（后缀名可能是 <code>*.a</code>、<code>*.lib</code>，<strong>和操作系统、编译器类型都有关系</strong>）：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_LIBRARY</span> (&lt;libName&gt; [STATIC] &lt;sourceFileNames&gt;)    <span class="comment"># 默认 STATIC</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>目标为动态链接库</strong>（后缀名可能是 <code>*.so</code>、<code>*.dll</code>、<code>*.dylib</code>）：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态链接库一般不和主程序一起编译，因为这样还不如用静态链接库</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span> (&lt;libName&gt; SHARED &lt;sourceFileNames&gt;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>【optional】告诉编译器从哪里寻找非标准 C++ 的<strong>动态链接库</strong>，<strong>一般也同时指定非标准头文件查找目录（include_directories 或 target_include_directories）</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LINK_DIRECTORIES</span> (&lt;dir&gt;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以理解为 g++ 的 <code>-L</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ [...] -L &lt;<span class="built_in">dir</span>&gt; [...]</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>【optional】<strong>向 可执行文件目标 或 链接库目标 链接一些库</strong>：</p>
<blockquote>
<p>众所周知，想要链接库，必须要有 <strong>头文件、动/静态链接库文件</strong>，并且把它们都引入自己的项目中</p>
</blockquote>
<ol>
<li><p><strong>要链接的库是自己编写的 / 第三方静态链接库</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是自己编写的静态链接库，请确保使用了 add_subdirectory 引入该库的 CMakeLists</span></span><br><span class="line"><span class="comment"># 或者在当前 CMakeLists 中指定编译的库，需要 add_library</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是第三方静态链接库，则建议引入头文件，使用 include_directory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (&lt;targetName&gt; &lt;libName/libFileName&gt;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>要链接的库是动态链接库</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span> (&lt;dir&gt;)    <span class="comment"># 引入非标准头文件查找目录</span></span><br><span class="line"><span class="keyword">LINK_DIRECTORIES</span> (&lt;dir&gt;)    <span class="comment"># 引入非标准链接库查找目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果最终目标是可执行文件，那么 add_executable 应该写在这里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (&lt;targetName&gt; &lt;libName/libFileName&gt;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>要链接的库是标准 C++ 库</strong>（一般这种情况是这个标准 C++ 库不在标准位置，<strong>最常见的是官方的 C++ 扩充，例如 Qt 的库</strong>）：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定标准库名，如果它在环境变量中，那么就不需要后面的 PATHS 参数</span></span><br><span class="line"><span class="keyword">FIND_PACKAGE</span> (&lt;stdLibDirName&gt; [REQUIRED] [PATHS &lt;dir&gt;])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定标准库以何种形式链接到目标中</span></span><br><span class="line"><span class="comment"># PUBLIC 和 PRIVATE 含义和之前的 TARGET_INCLUDE 的含义相同</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (&lt;targetName&gt; [PUBLIC | PRIVATE] &lt;stdLibDirName::stdLibName&gt;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="Chapter-3-CMakeLists-变量控制"><a href="#Chapter-3-CMakeLists-变量控制" class="headerlink" title="Chapter 3. CMakeLists 变量控制"></a>Chapter 3. CMakeLists 变量控制</h2><h3 id="3-1-常用内置变量"><a href="#3-1-常用内置变量" class="headerlink" title="3.1 常用内置变量"></a>3.1 常用内置变量</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>        <span class="comment"># 这是 CMakeLists.txt 所在目录</span></span><br><span class="line"><span class="variable">$&#123;PROJECT_NAME&#125;</span>                    <span class="comment"># 项目名称，上面介绍了</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;CMAKE_CXX_STANDARD&#125;</span>            <span class="comment"># 这是 C++ 标准设置，如果要使用新特性，例如 auto 出现在 </span></span><br><span class="line">                                <span class="comment"># C++ 11 中，那么应该指定标准版本为 11，否则会报错</span></span><br><span class="line"><span class="variable">$&#123;CMAKE_C_FLAGS&#125;</span></span><br><span class="line"><span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span>                <span class="comment"># 这两个变量是传给 gcc/g++ 的编译器参数，</span></span><br><span class="line">                                <span class="comment"># 一些常用的参数例如 -Wall 警告、-ggdb 调试行号</span></span><br><span class="line"><span class="comment"># 使用的规范是在后面添加，例如：</span></span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall -ggdb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;CMAKE_BUILD_TYPE&#125;</span>                <span class="comment"># 这是设置编译类型，可以是 Release | Debug</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-赋值和使用"><a href="#3-2-赋值和使用" class="headerlink" title="3.2 赋值和使用"></a>3.2 赋值和使用</h3><p>CMake 变量赋值函数 <code>SET</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> (&lt;variableName&gt; &lt;value&gt; [CACHE] [<span class="keyword">STRING</span> | BOOL] [Description])</span><br></pre></td></tr></table></figure>
<p>使用直接：<code>$&#123;&lt;variableName&gt;&#125;</code>；</p>
<h3 id="3-3-编译时宏定义"><a href="#3-3-编译时宏定义" class="headerlink" title="3.3 编译时宏定义"></a>3.3 编译时宏定义</h3><blockquote>
<p>假设程序中有一个量，不希望其他人知道，但其他代码都可以开源——那么需要实现：仅编译时将这个量传入；假设这个量在源码中以 <code>APP_ID</code> 表示，那么 CMakeLists.txt 应该这么写：</p>
</blockquote>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> (</span><br><span class="line">    _APP_ID		<span class="comment"># 设置 CMakeLists 临时环境变量</span></span><br><span class="line">    CACHE <span class="keyword">STRING</span></span><br><span class="line">    &lt;Description&gt;</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 要求必须传入这个量，否则报错</span></span><br><span class="line"><span class="keyword">IF</span> (_APP_ID <span class="keyword">STREQUAL</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span> (SEND_ERROR &lt;prompt&gt;)</span><br><span class="line"><span class="keyword">ENDIF</span> ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译时宏定义，相当于编译前加入了：#define APP_ID &lt;值&gt;</span></span><br><span class="line"><span class="keyword">TARGET_COMPILE_DEFINITIONS</span> (&lt;targetName&gt; PRIVATE APP_ID=<span class="string">&quot;$&#123;_APP_ID&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这是传入临时值的方法是 cmake 的 <code>-D&lt;env=value&gt;</code> 参数，例如上面的<strong>生成指令</strong>应该这么写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -D_APP_ID=<span class="string">&quot;XXX&quot;</span> &lt;Dir&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Chapter-4-CMakeLists-常见模板"><a href="#Chapter-4-CMakeLists-常见模板" class="headerlink" title="Chapter 4. CMakeLists 常见模板"></a>Chapter 4. CMakeLists 常见模板</h2><blockquote>
<p>下面模板的项目依赖极其简单，但不能照抄，需要根据项目实际依赖情况进行调整；</p>
</blockquote>
<h3 id="4-1-普通-C-项目"><a href="#4-1-普通-C-项目" class="headerlink" title="4.1 普通 C++ 项目"></a>4.1 普通 C++ 项目</h3><p>项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.    # C++ 标准 11</span><br><span class="line">|</span><br><span class="line">|--- main.cpp</span><br><span class="line">|--- App.h</span><br><span class="line">|--- App.cpp</span><br><span class="line">|--- CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>模板：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (myApp)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp App.cpp)</span><br></pre></td></tr></table></figure>
<h3 id="4-2-多个目录的-C-项目"><a href="#4-2-多个目录的-C-项目" class="headerlink" title="4.2 多个目录的 C++ 项目"></a>4.2 多个目录的 C++ 项目</h3><blockquote>
<p>多个目录可以考虑使用静态链接库，下面展示一种自定义静态链接库的 CMakeLists.txt 写法</p>
</blockquote>
<p>项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.    # 这个项目需要 Debug 模式构建，并且增添编译参数 “-Wall” 和 “-ggdb”</span><br><span class="line">|</span><br><span class="line">|--- main.cpp</span><br><span class="line">|--- App.h</span><br><span class="line">|--- App.cpp</span><br><span class="line">|--- CMakeLists.txt</span><br><span class="line">|--- src/                # 这个目录需要编译为静态链接库并同时链接到主程序</span><br><span class="line">        |</span><br><span class="line">        |--- Manager.h</span><br><span class="line">        |--- Manager.cpp</span><br><span class="line">        |--- CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>在项目根目录下的 CMakeLists.txt：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (myApp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAG&#125; -Wall -ggdb&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_BUILD_TYPE Debug)</span><br><span class="line"></span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (. MAIN_SRC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span> (src/)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;MAIN_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> myLib)</span><br></pre></td></tr></table></figure>
<p>在 <code>src/</code> 目录下的 CMakeLists.txt：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (. LIB_SRC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span> (myLib <span class="variable">$&#123;LIB_SRC&#125;</span>)    <span class="comment"># 默认静态链接库</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-使用动态链接库的-C-项目"><a href="#4-3-使用动态链接库的-C-项目" class="headerlink" title="4.3 使用动态链接库的 C++ 项目"></a>4.3 使用动态链接库的 C++ 项目</h3><p>项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.    # 项目使用 C++ 11 规范</span><br><span class="line">|</span><br><span class="line">|--- main.cpp</span><br><span class="line">|--- App.cpp</span><br><span class="line">|--- App.h</span><br><span class="line">|--- CMakeLists.txt</span><br><span class="line">|--- core/                # 这个 core 目录要求链接到主程序</span><br><span class="line">        |</span><br><span class="line">        |--- lib/</span><br><span class="line">        |		|</span><br><span class="line">        |		|--- libManager.so</span><br><span class="line">        |</span><br><span class="line">        |--- include/</span><br><span class="line">                |</span><br><span class="line">                |--- Manager.h</span><br></pre></td></tr></table></figure>
<p>项目根目录下的 CMakeLists.txt 写法：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (myApp)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (. SRC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">LINK_DIRECTORIES</span> (<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/core/lib/)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_INCLUDE_DIRECTORIES</span> (</span><br><span class="line">    <span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/core/<span class="keyword">include</span>/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> libManager.so)</span><br></pre></td></tr></table></figure>
<p>或者不用 <code>LINK_DIRECTORIES</code>，直接改为单独设置库的代码：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span> (VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (myApp)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span> (. SRC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span> (Manager STATIC IMPORTED)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span> (Manager</span><br><span class="line">    PROPERTIES</span><br><span class="line">        IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/core/lib/libManager.so</span><br><span class="line">        INTERFACE_INCLUDE_DIRECTORIES <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/core/<span class="keyword">include</span>/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span> (<span class="variable">$&#123;PROJECT_NAME&#125;</span> Manager)</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SJTU-XHW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/technical/cmake-advanced/">https://blog.sjtuxhw.top/technical/cmake-advanced/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SJTU-XHW's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CMake/">CMake</a><a class="post-meta__tags" href="/tags/GNU/">GNU</a><a class="post-meta__tags" href="/tags/Programmimg/">Programmimg</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/cmake.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/technical/qt-for-beginners-1/" title="从C++入门Qt（一）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/qt1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">从C++入门Qt（一）</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~   Chapter 0 前置知识0.1 C++ 基础 和 面向对象编程0.2 C++ 的宏（macro） 宏的定义非常自由甚至可以把一个符号定义为一个很长的字符串，甚至代码；主要是因为宏的工作原理是编译前将宏直接原封不动地替换；例如下面的极端例子：  123456789101112131415// 直接把 HELLO 定义为一串代码#define HELLO \    QLabel* label = new QLabel(&quot;&lt;h2&gt;&lt;i&gt;Hello,&lt;/i&gt;&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;&quot;);\   ...</div></div></div></a><a class="pagination-related" href="/technical/fiddler-everywhere/" title="Fiddler Everywhere的crack实践"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/fiddler-crack.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Fiddler Everywhere的crack实践</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW 本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！ 本文如有侵权，请联系作者删除   众所周知，Fiddler 是一个无比好用的、免费的网络调试代理工具，可以方便地进行抓包、代理服务等基本操作。最近在看到一些文章介绍 Fiddler 的使用时无意间发现 Fiddler everywhere 的软件，UI 制作更加用心，而且功能更加强大，可惜的是会订阅收费。在受到 Github@msojocs（好像停更了）的指引下，我开始了对 Fiddler-Everywhere 软件的 “学习”。  声明：本文不含有实际的观点导向 或者 建议，如有侵权，请联系删除； 在尽情使用的同时，欢迎大家订阅官网正版的 Fiddler everywhere；  工作环境准备要进行 crack 实践，必然得从反编译入手； 首先了解到 Fiddler Everywhere 是使用 C# 编写的程序，所以事先必须准备关于 C# 的运行环境 和 反编译程序； Windows 自带 .net 运行库不够用，需要下载...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/review/csapp-basic/" title="CSAPP Notes Basic"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="info-item-2">CSAPP Notes Basic</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference:  CMU - 213, Computer Systems A Programmer’s Perspective 3rd Edition by Randal Bryant, David O’Hallaron 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 内容很长，写起来很慢 😳   Chapter 0. Intro0.1 Ints are not Integers, Floats are not Reals $x^2\ge 0$：int（32-bit）may overflow； $a+(b+c)=(a+b)+c$：floats may discard some “unsignificant” digits；  0.2 Learn Assembly but never write it0.3 Memory Matters: Unbounded1234567891011121314typedef struct &#123;    int a[2];    double d;&#125;...</div></div></div></a><a class="pagination-related" href="/review/csapp-ecf-io/" title="CSAPP Notes: ECF &amp; I&#x2F;O"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-ecf.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-16</div><div class="info-item-2">CSAPP Notes: ECF &amp; I&#x2F;O</div></div><div class="info-2"><div class="info-item-1">Chapter 13. Exceptional Control Flow 对应书中第 8 章。  异常控制流是现代计算机系统的一个相当重要的部分。 13.1 Control Flow 控制流：从机器打开到关闭的过程中，处理器只做一件事：读指令、执行指令，一个周期做一个指令。多核的机器则每个核心依次交替执行指令。这些指令序列被称为控制流。硬件正在执行的实际指令序列就被称为物理控制流。  改变内存中控制流的方法：分支 &amp; 跳转，过程调用 &amp; 返回（Branches &amp; Jumps &amp; Procedure call and return）；  都是对于程序状态变化的处理。    但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）； 什么是 “系统级别的状态变化”？  数据从磁盘 / 网卡到达内存中； I/O 设备输入...</div></div></div></a><a class="pagination-related" href="/review/csapp-mm-cache/" title="CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-mh.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-10</div><div class="info-item-2">CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt</div></div><div class="info-2"><div class="info-item-1">Chapter 10. The Memory Hierarchy 本章将介绍系统的内存分层架构。  之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。 正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。 10.1 Storage Technologies &amp; Trends在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。 10.1.1 Random-Access Memory (RAM)当前大多数人所熟知的 “内存” 的一部分就是随机访问存储器（RAM），它具有以下的特征：  RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；  RAM 常常被打包放在 CPU 芯片中；  RAM 中每一个基本的存储单元被称为 单元胞（Cell），一个单元胞中存放 1 bit 数据；  很多个 RAM 芯片共同工作，组成了计算机的...</div></div></div></a><a class="pagination-related" href="/review/csapp-sched-arch/" title="CSAPP Notes: Scheduler &amp; Arch"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_p2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-11</div><div class="info-item-2">CSAPP Notes: Scheduler &amp; Arch</div></div><div class="info-2"><div class="info-item-1">Chapter 8. Scheduler in OS为操作系统的调度环境作出假设：  Each job runs for the same amount of time All jobs arrive at the same time Once started, each job runs to completion All jobs only use the CPU  i.e., they perform no I/O   The run-time of each job is known  引入调度优劣衡量指标：周转时间，$T_{turnaround}=T_{completion}-T_{arrival}$； Strategy 1: FIFO（FCFS，First Come First Served） Implementation: queue； 消除假设 1：若短时任务排在长时任务之后，则平均周转时间效果很差；  Strategy 2 : SJF（Shortest Job First） 内容：对于同时到达的任务，优先选择总时长小的任务。 作用：（应对假设 1...</div></div></div></a><a class="pagination-related" href="/technical/gnu-tutor/" title="GNU-Tutor"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/GNU-Tutor.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="info-item-2">GNU-Tutor</div></div><div class="info-2"><div class="info-item-1">基础：C/C++的源文件编译过程 想要代码在操作系统上运行，需要进行以下编译步骤，从高级语言转机器语言，以下任务gcc/g++均能完成：  预编译（.c/cpp &amp; .h —&gt; .i ）：*对应gcc/g++命令：gcc -E [xxx] -o [output.i] 展开所有宏定义#define（字符替换）； 处理所有条件预编译命令（#ifdef、#ifndef、#endif等）； 处理#include，具体操作是将指向的文件直接插入到文件的这一行（严格遵循上一步的条件）； 删除所有注释； 添加行号、文件标识，以便调试/编译出错时及时指出； 保留#pragma指令，以供编译器使用；   编译（.i —&gt; .s ，即高级语言转汇编语言）：对应gcc/g++命令：gcc -S [xxx] -o...</div></div></div></a><a class="pagination-related" href="/technical/semaphore-mutex-and-cv/" title="Semaphore, Mutex, CV"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/smc.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-11</div><div class="info-item-2">Semaphore, Mutex, CV</div></div><div class="info-2"><div class="info-item-1">学习 ICS 的并行一章之后，笔者有些疑惑，semaphore（信号量）、mutex（互斥锁）、conditional variables（条件变量）这 3 者之间究竟该怎么区分它们的使用场景？ 首先我们需要去阐述清楚它们各自的定义和效果。 学术界认为 mutex 是 semaphore 的特例，因此像著名的书籍 CSAPP 就先以 semaphore 为例讲了讲并发程序的资源控制问题。但是实际上有相当一部分实践派和语义派认为二者不应该混为一谈。像 Linus 本人在一次将 Linux 内核的一部分 semaphore 重构为 mutex 后，发现不仅改善了代码语义，还在一定程度上提升了性能。这件事也说明了，虽然在理论上一方可以替代另一方，但实践上它们各有所长。 Semaphore vs Mutex我们先讨论 semaphore。 CSAPP 中先从 “线程间变量共享” 的情况说起，它指出，程序对内存的更改并不直接在内存上完成，在汇编中可以看到，大致经历了 load（从内存到 CPU 寄存器）、update（在 CPU 寄存器内更新数据）、store（将 CPU...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SJTU-XHW</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-0-Make-%E4%BB%8B%E7%BB%8D"><span class="toc-text">Chapter 0. Make 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-Makefile-%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">0.1 Makefile 的规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1-1-%E6%98%BE%E5%BC%8F%E8%A7%84%E5%88%99"><span class="toc-text">0.1.1 显式规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1-2-%E9%9A%90%E6%99%A6%E8%A7%84%E5%88%99"><span class="toc-text">0.1.2 隐晦规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1-3-%E6%96%87%E4%BB%B6%E6%8C%87%E7%A4%BA-%E5%92%8C-%E7%BC%96%E8%AF%91%E8%AE%BE%E7%BD%AE"><span class="toc-text">0.1.3 文件指示 和 编译设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1-4-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">0.1.4 赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1-5-%E5%B0%8F%E7%BB%93%EF%BC%9AMake-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">0.1.5 小结：Make 的工作方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-2-Make-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">0.2 Make 命令的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-1-CMake-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8"><span class="toc-text">Chapter 1. CMake 命令使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%94%9F%E6%88%90%E6%8C%87%E4%BB%A4"><span class="toc-text">1.1 生成指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%BC%96%E8%AF%91%E6%9E%84%E5%BB%BA%E6%8C%87%E4%BB%A4"><span class="toc-text">1.2 编译构建指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-2-CMakeList-%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0"><span class="toc-text">Chapter 2. CMakeList 常见函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-CMakeLists-%E5%8F%98%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">Chapter 3. CMakeLists 变量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="toc-text">3.1 常用内置变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%B5%8B%E5%80%BC%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">3.2 赋值和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BC%96%E8%AF%91%E6%97%B6%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">3.3 编译时宏定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-4-CMakeLists-%E5%B8%B8%E8%A7%81%E6%A8%A1%E6%9D%BF"><span class="toc-text">Chapter 4. CMakeLists 常见模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%99%AE%E9%80%9A-C-%E9%A1%B9%E7%9B%AE"><span class="toc-text">4.1 普通 C++ 项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95%E7%9A%84-C-%E9%A1%B9%E7%9B%AE"><span class="toc-text">4.2 多个目录的 C++ 项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84-C-%E9%A1%B9%E7%9B%AE"><span class="toc-text">4.3 使用动态链接库的 C++ 项目</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/algo-in-ai/" title="Algorithms in AI"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/algo-in-ai.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Algorithms in AI"/></a><div class="content"><a class="title" href="/technical/algo-in-ai/" title="Algorithms in AI">Algorithms in AI</a><time datetime="2024-07-20T07:23:40.000Z" title="发表于 2024-07-20 15:23:40">2024-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/convex-opt/" title="Convex &amp; Optimizations"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/convex.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Convex &amp; Optimizations"/></a><div class="content"><a class="title" href="/review/convex-opt/" title="Convex &amp; Optimizations">Convex &amp; Optimizations</a><time datetime="2024-06-15T07:18:39.000Z" title="发表于 2024-06-15 15:18:39">2024-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/numeric-analysis/" title="Numeric Analysis for Beginners"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/numeric-analysis.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Numeric Analysis for Beginners"/></a><div class="content"><a class="title" href="/review/numeric-analysis/" title="Numeric Analysis for Beginners">Numeric Analysis for Beginners</a><time datetime="2024-06-12T05:11:56.000Z" title="发表于 2024-06-12 13:11:56">2024-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/rabbit-mq/" title="Introduction to Rabbit MQ"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/rabbit.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Introduction to Rabbit MQ"/></a><div class="content"><a class="title" href="/technical/rabbit-mq/" title="Introduction to Rabbit MQ">Introduction to Rabbit MQ</a><time datetime="2024-06-01T08:31:33.000Z" title="发表于 2024-06-01 16:31:33">2024-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/micro-service-basic/" title="微服务初探"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/micro.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微服务初探"/></a><div class="content"><a class="title" href="/technical/micro-service-basic/" title="微服务初探">微服务初探</a><time datetime="2024-05-21T03:27:40.000Z" title="发表于 2024-05-21 11:27:40">2024-05-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By SJTU-XHW  |  tech SJTU saves the world</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> &nbsp;|&nbsp;&nbsp;本网站由 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.sjtuxhw.top',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.sjtuxhw.top',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>