<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SQL学习笔记-第一部分 | SSRVodka's blog</title><meta name="author" content="SSRVodka,xhwpro@gmail.com"><meta name="copyright" content="SSRVodka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="written by SJTU-XHW 本部分文章是 SQL 的基础部分，纪念我丢掉的 SQL 笔记 😭 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ Reference: 《 SQL 必知必会 (第 5 版 ) 》  使用前须知本系列文章的 “章末习题” 使用的数据库和表的关系如下图所示；  这里提供创建表和数据的 SQL 文本（以 MySQL 为例）：generate.sql，可以在搭">
<meta property="og:type" content="article">
<meta property="og:title" content="SQL学习笔记-第一部分">
<meta property="og:url" content="https://blog.sjtuxhw.top/technical/sql-basic-1/index.html">
<meta property="og:site_name" content="SSRVodka&#39;s blog">
<meta property="og:description" content="written by SJTU-XHW 本部分文章是 SQL 的基础部分，纪念我丢掉的 SQL 笔记 😭 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ Reference: 《 SQL 必知必会 (第 5 版 ) 》  使用前须知本系列文章的 “章末习题” 使用的数据库和表的关系如下图所示；  这里提供创建表和数据的 SQL 文本（以 MySQL 为例）：generate.sql，可以在搭">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/sql-1.jpg">
<meta property="article:published_time" content="2023-06-28T13:35:08.000Z">
<meta property="article:modified_time" content="2024-10-25T14:01:25.691Z">
<meta property="article:author" content="SSRVodka">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="SQL">
<meta property="article:tag" content="Database">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/sql-1.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/technical/sql-basic-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/css/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SQL学习笔记-第一部分',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SSRVodka's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/sql-1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SSRVodka's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">SQL学习笔记-第一部分</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">SQL学习笔记-第一部分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-28T13:35:08.000Z" title="发表于 2023-06-28 21:35:08">2023-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T14:01:25.691Z" title="更新于 2024-10-25 22:01:25">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/technical/sql-basic-1/#post-comment"><span class="waline-comment-count" data-path="/technical/sql-basic-1/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><i>written by SJTU-XHW</i></p>
<p><i>本部分文章是 SQL 的基础部分，纪念我丢掉的 SQL 笔记</i> 😭</p>
<p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p>
<p>Reference: 《 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://forta.com/books/0135182794/">SQL 必知必会 (第 5 版 )</a> 》</p>
<hr>
<h1 id="使用前须知"><a href="#使用前须知" class="headerlink" title="使用前须知"></a>使用前须知</h1><p>本系列文章的 “章末习题” 使用的数据库和表的关系如下图所示；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./sample_tables.jpg"></p>
<p>这里提供创建表和数据的 SQL 文本（以 MySQL 为例）：<a href="./generate.sql">generate.sql</a>，可以在搭建好 MySQL 环境后直接导入它，以备后面章末习题使用；</p>
<h1 id="Chapter-0-数据库的基本概念"><a href="#Chapter-0-数据库的基本概念" class="headerlink" title="Chapter 0 数据库的基本概念"></a>Chapter 0 数据库的基本概念</h1><ul>
<li><p>数据库（从 SQL 角度看）：<strong>以某种有组织的方式存储的数据集合</strong>；</p>
</li>
<li><p>关系型数据库 &amp; 非关系型数据库</p>
<ul>
<li>关系型数据库：采用关系模型、遵循关系代数模式来组织数据的数据库（例如 MySQL、PostgreSQL等）；<strong>关系模型类似二维表，允许表间数据相互关联，支持多表查询</strong>；</li>
<li>非关系型数据库（No SQL）：不依赖关系模型的、分布式的数据库（例如 MongoDB、Redis 等）；<strong>以键值来存储，结构不稳定，每个元组的字段可以不相同，可以面向高并发key-value读写 / 面向文档</strong>；</li>
</ul>
<div style="text-align: center;">表一 关系型数据库 &amp; 非关系型数据库比</div>

<table>
    <tr>
        <td>项目</td>
        <td>RDB</td>
        <td>NOSQL(Not Only SQL)</td>
    </tr>
    <tr>
        <td>是否依赖关系模型</td>
        <td>是，二维表容易理解</td>
        <td>否，key-value 存储较为零散</td>
    </tr>
    <tr>
        <td>是否有通用的 SQL</td>
        <td>有，使用方便</td>
        <td>无，无法提供WHERE字段查询</td>
    </tr>
    <tr>
        <td>事务的一致性</td>
        <td>强，ACID属性易于维护</td>
        <td>弱，适宜面向网络/文档/高并发读写等场景</td>
    </tr>
    <tr>
        <td>拓展能力</td>
        <td>纵向，依赖处理能力提升</td>
        <td>横向，天然分布式</td>
    </tr>
    <tr>
        <td>存储数据</td>
        <td>适宜结构化数据，例如账户、地址</td>
        <td>适宜非结构化数据，例如文章、评论</td>
    </tr>
</table>


</li>
</ul>
<p>  注：一般生产环境会使用 <code>RDB + NoSQL</code> 组合方案，互相取长补短；</p>
<p>  ⚠ <strong>本文章仅讨论关系型数据库中的 标准 SQL</strong>；</p>
<ul>
<li><p>数据库管理系统（DBMS）：俗称数据库管理系统；<strong>数据库是通过 DBMS 创建和操纵的容器</strong>；</p>
<blockquote>
<p>MySQL、mariaDB、mongoDB、SQLite 等等都是 DBMS，而它们创建的数据库才是真正的 “数据库”；</p>
</blockquote>
</li>
<li><p>表（table）：某种特定类型数据的结构化清单；</p>
<blockquote>
<p><strong>根据定义，可以理解为：在数据库（相当于文件柜）中，存放文件需要放在特定的档案中，这个“文件柜”中的“档案”就是表；</strong></p>
<p><strong>表存储的是同一种类型的数据或清单，<u>便于归类和查找</u></strong></p>
</blockquote>
</li>
<li><p>表名：表的唯一标识符（ID），在一个数据库中唯一，但不同数据库的表之间名字可以相同；</p>
</li>
<li><p>模式（schema）：关于数据库和表的布局及特性的信息；</p>
<blockquote>
<p><strong>描述数据库中特定的表，或者描述整个数据库及表的关系</strong>；</p>
<p>包括：储存什么数据？数据如何分解（parse）？各部分信息如何命名？……</p>
</blockquote>
</li>
<li><p>列（column）：表中的一个字段，存储表的某一个部分/领域（field）的信息；</p>
<blockquote>
<p><strong>所有表都是由一个或多个列组成</strong>；</p>
<p><strong>正确地按需求对数据列分解对于分类、过滤意义重大</strong>；例如，将国家和省市信息组合在一个列中，那么仅按省市查找的难度就比 “国家、省市信息分开在两列中” 的情况更大；</p>
</blockquote>
</li>
<li><p>数据类型：每一列需要有相应的数据类型，限制该列存储的数据（以方便分类和查找）；</p>
<blockquote>
<p>对表的各列设计数据类型也是重要的：正确地设计数据类型不仅可以帮助正确分类和查找，还可以优化磁盘容量；</p>
</blockquote>
<p>⚠ <strong>因为有些 DBMS 中同一个数据类型的名称不一样（数据类型兼容问题），即便名称相同，定义可能不一样，所以应该总是查阅文档、学习和应用时需要注意</strong>；</p>
</li>
<li><p>行：表中的一个记录（从技术上说，行才是正确的术语）；</p>
</li>
<li><p>主键（primary key）：表中的每一行都<u>应该</u>有一列（或几列）可以<strong>唯一标识自己（ID）</strong>；</p>
<blockquote>
<p><strong>没有主键，更新、删除数据库表的特定行就极其困难，不能保证没有误操作</strong>；</p>
<p>所以规范来说，表应该总是定义主键；</p>
</blockquote>
<p><strong>主键的要求</strong>：</p>
<ol>
<li><strong>互异性</strong>：表的任意两行都不具有相同主键值；</li>
<li><strong>非空性</strong>：每一行必须具有一个主键值（不允许为 NULL 空值）；</li>
<li><strong>固定性</strong>：主键列中的值不允许修改和更新；</li>
<li><strong>不可重用性</strong>：如果表的一行从表中被删除，那么它的主键不能赋给以后的新行；</li>
</ol>
</li>
<li><p>SQL：<code>Structured Query Language</code>，结构化查询语言（专门用来与数据库沟通的语言）；</p>
<ol>
<li>不是某个数据库厂商、某类 DBMS 特有的语言；</li>
<li>关键字数量极少，但功能强大；</li>
</ol>
<blockquote>
<p>本文章不考虑某些 DBMS 的 SQL 扩展（某个厂商独有、独自开发的），仅讨论标准 SQL（ANSI SQL）；</p>
</blockquote>
</li>
<li><p>SQL 的关键字：作为 SQL 组成部分的保留字，不能用作表 / 列的名字；会在以后章节中逐渐提及；</p>
</li>
<li><p>SQL 语言注意事项</p>
<ol>
<li><p>SQL 语句的结束：以分号结尾；</p>
</li>
<li><p>SQL 语句不区分大小写，但习惯上约定俗成：关键字大写、列/表名小写；</p>
</li>
<li><p>在一个 SQL 语句未结束时，可以在两个词间添加换行，不会有影响，一般是方便阅读；</p>
</li>
<li><p>SQL 语言的索引<strong>从0开始</strong>，因此也是一种 <strong>0-index 语言</strong>；</p>
</li>
<li><p>注释方式：行内注释 <code>--</code>（后面跟一个空格）、单行注释 <code>#</code> （某些 DBMS 不支持）、多行注释 <code>/* [contents] */</code>；</p>
<blockquote>
<p>好习惯：和 其他所有编程语言一样，必要时多加注释；</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h1 id="Chapter-1-数据检索"><a href="#Chapter-1-数据检索" class="headerlink" title="Chapter 1 数据检索"></a>Chapter 1 数据检索</h1><h2 id="1-1-SELECT-语句"><a href="#1-1-SELECT-语句" class="headerlink" title="1.1 SELECT 语句"></a>1.1 SELECT 语句</h2><ul>
<li><p>用途：从一个或多个表中检索信息；</p>
</li>
<li><p>语法</p>
<ul>
<li><p>检索某一个表的 <strong>某一个列</strong>：<code>SELECT &lt;column_name&gt; FROM &lt;table_name&gt;;</code></p>
</li>
<li><p>同时检索 <strong>多个列</strong>：<code>SELECT &lt;col_name1, [col_name2, ...]&gt; FORM &lt;table_name&gt;;</code></p>
</li>
<li><p>检索 <strong>所有的的列</strong>：<code>SELECT * FORM &lt;table_name&gt;;</code></p>
<blockquote>
<p><strong>谨慎使用通配符（*），除非真的需要，或者不知道需要列的列名</strong>；</p>
</blockquote>
</li>
<li><p>检索表中 <strong>某列不同的值</strong>（<code>DISTINCT</code> 关键字）：<code>SELECT DISTINCT &lt;col_name&gt; FROM &lt;table_name&gt;;</code></p>
<p>⚠ <strong>不可以部分使用 <code>DISTINCT</code> 关键字，例如：<code>SELECT DISTINCT &lt;col_name1, col_name2&gt; FROM &lt;table_name&gt;;</code></strong></p>
<p>因为 <code>DISTINCT</code> 作用于所有的列！部分使用会导致失去想要的结果（SQL 需要同时考虑其他列也有 <code>DISTINCT</code>，最后会出现组合的现象）；（而且这么做不符合逻辑）</p>
<p>ℹ <strong>和 <code>DISTINCT</code>  相反的是 <code>ALL</code>，一般无需指定，因为这是默认行为</strong>；</p>
</li>
<li><p>检索 <strong>结果限制</strong>（用来缩小范围找到想要的数据）</p>
<ol>
<li><p>限制仅查询 N 行</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">MySQL</button><button type="button" class="tab">Oracle</button><button type="button" class="tab">SQL-server</button><button type="button" class="tab">DB2</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>col_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">LIMIT N;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>col_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> <span class="number">5</span>;    <span class="comment">-- 行计数器</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">5</span> <span class="operator">&lt;</span>col_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>col_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">5</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><strong>以下仅以常见的 <code>MySQL</code>、<code>MariaDB</code>为例，不再赘述</strong>；</p>
</li>
<li><p>限制指定行：<code>M ~ M+N</code></p>
<p>⚠ <strong>SQL 语言 0-index</strong>；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;col_name&gt;</span><br><span class="line">FROM &lt;table_name&gt;</span><br><span class="line">LIMIT N OFFSET M; -- 即 0+M ~ 0+M+N</span><br><span class="line">-- 或者</span><br><span class="line">LIMIT M,N;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p>习题</p>
<ol>
<li><p>从 <code>customers</code> 表中检索所有的 <code>cust_id</code> 列的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id</span><br><span class="line"><span class="keyword">FROM</span> customers;</span><br></pre></td></tr></table></figure>
</li>
<li><p>已知表 <code>OrderItems</code> （订单表）中存在一列 <code>prod_id</code>（产品 ID），问所有出现在订单中的产品 ID，要求每个产品 ID 仅显示一次：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> prod_id</span><br><span class="line"><span class="keyword">FROM</span> OrderItems;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检索 <code>customers</code> 表中所有的列，再检索其中列 <code>cust_id</code>、<code>cust_name</code>、<code>cust_country</code> 的第 5~9 行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers;</span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_country</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line">LIMIT <span class="number">5</span> <span class="keyword">OFFSET</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="1-2-排序已检索数据"><a href="#1-2-排序已检索数据" class="headerlink" title="1.2 排序已检索数据"></a>1.2 排序已检索数据</h2><blockquote>
<p>主要内容：<code>SELECT</code> 的 <code>ORDER BY</code> 子句；</p>
</blockquote>
<ul>
<li><p>子句（clause）的定义：SQL 语句由子句构成；</p>
<blockquote>
<ol>
<li>有些子句是必需的，有些是可选的；</li>
<li>一个子句通常是由一个关键字 + 所提供的数据组成；</li>
</ol>
</blockquote>
<p>举例：SELECT 语句的 <code>FROM</code> 子句、<code>LIMIT</code> 子句、<code>ORDER BY</code> 子句等；</p>
</li>
<li><p>语法</p>
<ul>
<li><p>检索时 <strong>按某一列排序</strong>：<code>SELECT &lt;col_name1[, col_name2, ...]&gt; FROM &lt;tb_name&gt; ORDER BY &lt;col_nameN&gt;;</code></p>
<p>⚠ <strong>必须保证 <code>ORDER BY</code> 子句为 <code>SELECT</code> 语句的最后一句，否则会出错！</strong> </p>
<p>ℹ 排序依据的列可以不是选择列（即 <code>col_nameN</code> 可以不在 <code>col_name1, col_name2,...</code>中）；</p>
</li>
<li><p>检索时 <strong>按多个列排序</strong>：<code>SELECT &lt;col_name1[, col_name2, ...]&gt; FROM &lt;tb_name&gt; ORDER BY &lt;col_nameN1, col_nameN2, ...&gt;;</code></p>
<blockquote>
<p>含义：首先按 <code>col_nameN1</code> 排序，再按 <code>col_nameN2</code> 排序，有点像高考录取排序方法；</p>
</blockquote>
</li>
<li><p>检索时 <strong>使用已选择列的列号排序</strong>（仅仅是一种简化方法）：<code>SELECT &lt;col_Name1[, ...]&gt; FROM &lt;tb_name&gt; ORDER BY &lt;col_num1[, ...]&gt;;</code></p>
</li>
<li><p>检索时 <strong>指定排序方向</strong>：<code>SELECT &lt;col_name1[, ...]&gt; FROM &lt;tb_name&gt; ORDER BY &lt;col_nameN1[ASC/DESC][, ...]&gt;;</code></p>
<blockquote>
<p>关键字 <code>ASC</code>（Ascending，<strong>默认升序</strong>）、<code>DESC</code>（Descending）；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>习题</p>
<ol>
<li><p>从 <code>Customers</code> 表中检索所有的顾客名称（<code>cust_names</code>），并按从 Z 到 A 的顺序显示结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_names</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_names <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 <code>Orders</code> 表中检索顾客 ID（<code>cust_id</code>）和订单号（<code>order_num</code>），并先按顾客 ID 对结果进行排序，再按订单日期（<code>order_date</code>）倒序排列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_id <span class="keyword">ASC</span>, order_date <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="1-3-过滤已检索数据"><a href="#1-3-过滤已检索数据" class="headerlink" title="1.3 过滤已检索数据"></a>1.3 过滤已检索数据</h2><blockquote>
<p>主要内容：<code>SELECT</code> 的 <code>WHERE</code> 子句、<code>SELECT</code> 的 <code>LIKE</code> 子句（模糊过滤）；</p>
</blockquote>
<ul>
<li><p><span id="principle">应用须知：<strong>对数据的过滤操作应该交给 SQL，而非上层的应用程序（开发语言）</strong>；</span></p>
<blockquote>
<p>原因：</p>
<ol>
<li>数据库 SQL 对于数据过滤优化力度远远大于你自己在外层写的，造成性能资源浪费；</li>
<li>降低上层应用程序的可移植性、可读性、可维护性；</li>
</ol>
</blockquote>
</li>
<li><p>过滤条件：也称“搜索条件”，用于根据特定操作提取表数据的子句；</p>
<p>模糊过滤条件：使用类似正则式的方式确定过滤条件（仅适用于文本-string）；</p>
</li>
<li><p>谓词（predicate）：某些关键字不是操作符，而是作为谓词使用，例如 <code>LIKE</code>；</p>
</li>
<li><p>语法</p>
<ul>
<li>在检索时 <strong>过滤条件</strong>：<code>SELECT &lt;col_name[, ...]&gt; FROM &lt;tb_name&gt; WHERE &lt;cond&gt;;</code></li>
<li>在检索时 <strong>使用模糊过滤条件</strong>：<code>SELECT &lt;col_name[, ...]&gt; FROM &lt;tb_name&gt; WHERE &lt;col_str&gt; LIKE &lt;pattern&gt;;</code></li>
</ul>
</li>
<li><p><code>WHERE &lt;cond&gt;</code> 子句判断操作符：小于(等于)、大于(等于)（与普通编程语言相同），<strong>等于（<code>=</code>）</strong>，不等于（<code>!=</code> 或 <code>&lt;&gt;</code>），不小于（<code>!&lt;</code>），不大于（<code>!&gt;</code>）；</p>
<blockquote>
<p>另外：在指定两个值之间使用关键字操作符 <code>BETWEEN...AND...</code>，判断是否为 NULL <code>IS NULL</code>；</p>
<p>以上操作符有冗余，有些 DBMS 不支持，请自行判断；</p>
</blockquote>
<p>⚠ <strong>注意1：NULL（空值）和字段包含0、空字符串、仅含空格的情况都不一样</strong>；</p>
<p>⚠ <strong>注意2：只要使用了过滤条件，除了 <code>IS NULL</code> 操作符，其他的匹配无法选中匹配列记录为 NULL 的记录！</strong></p>
<p>⚠ <strong>注意3：等于操作符和主流编程语言不一样，只有一个等号！</strong></p>
</li>
<li><p><code>WHERE &lt;cond&gt;</code>  子句条件操作符：<code>AND</code>、<code>OR</code>、<code>NOT</code>、圆括号（改变运算顺序）；</p>
<blockquote>
<p>运算顺序同主流编程语言；</p>
</blockquote>
</li>
<li><p><code>WHERE &lt;cond&gt;</code> 子句包含操作符：<code>IN</code>、定元组（例如：<code>(&#39;DLL01&#39;, &#39;BRS01&#39;)</code>）；</p>
<blockquote>
<p>建议能用 <code>IN</code>，就用它：</p>
<p>（例如：<code>SELECT prod_name FROM products WHERE prod_id == &#39;DLL01&#39; OR prod_id == &#39;BRS01&#39;;</code> 不如 <code>SELECT prod_name FROM products WHERE prod_id in (&#39;DLL01&#39;, &#39;BRS01&#39;);</code>）</p>
<p>因为它有好处：</p>
<ol>
<li><code>IN</code> 操作符可读性更强；</li>
<li>数据库底层优化 <code>IN</code> 可以使用一次 HASH 操作，效率高于 <code>OR</code> 连接的运算；</li>
<li><code>IN</code> 操作符可以实现 <code>WHERE</code> 子句的嵌套（后面讨论）；</li>
</ol>
</blockquote>
</li>
<li><p><code>WHERE</code> 子句的 <code>pattern</code>：</p>
<div style="text-align: center;">表二 SQL pattern 和 正则式对比</div>

<table>
    <tr>
        <td>SQL pattern</td>
        <td>% (NULL excluded)</td>
        <td>_</td>
        <td>[char set]</td>
        <td>[^char set]</td>
    </tr>
    <tr>
        <td>Regex</td>
        <td>.?</td>
        <td>.</td>
        <td>.[char set]</td>
        <td>.[^char set]</td>
    </tr>
</table>


</li>
</ul>
<p>  ⚠ <strong>注意1：在 <code>LIKE</code> 匹配时，<code>pattern</code> 区分大小写！</strong></p>
<p>  ⚠ <strong>注意2：在有些数据库的数据中，对于字符串数据类型按指定位存储时，不满位数的会填充以空格，因此 pattern 可能很难匹配到；正确做法是利用 SQL 自带函数去除字符串两边空格，后面讨论；</strong>、</p>
<p>  ⚠ <strong>注意3：不宜过度使用通配符、不宜将通配符作为靠前的搜索条件；</strong></p>
<ul>
<li><p>习题</p>
<ol>
<li><p>从Products 表中检索产品ID（<code>prod_id</code>）和产品名称（<code>prod_name</code>），只返回价格（<code>prod_price</code>）为 9 或更高的产品：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 <code>OrderItems</code> 表中检索出所有不同订单号（<code>order_num</code>），其中包含产品个数（<code>quantity</code>）在 100 个至 200 个之间：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> quantity <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">WHERE</span> quantity <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">AND</span> quantity <span class="operator">&lt;=</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回 <code>Products</code> 表中所有价格在 3 美元到 6 美元之间的产品的名称（<code>prod_name</code>）和价格（<code>prod_price</code>），然后先按价格、后按 ID （<code>prod_id</code>）对结果都进行降序排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">6</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name <span class="keyword">DESC</span>, prod_id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找所有至少订购了总量（<code>quantity</code>） 100 个的，ID 为 <code>BR01</code>、<code>BR02</code> 或 <code>BR03</code> 的订单。你需要返回<code>OrderItems</code> 表的订单号（<code>order_num</code>）、产品ID（<code>prod_id</code>）和数量，并按产品 ID 和数量进行升序排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, prod_id</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> quantity <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">AND</span> prod_id <span class="keyword">IN</span> (<span class="string">&#x27;BR01&#x27;</span>, <span class="string">&#x27;BR02&#x27;</span>, <span class="string">&#x27;BR03&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_id, quantity;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回描述中未出现 <code>toy</code> 一词的产品。要求按产品名称对结果进行排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_desc</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> (prod_desc <span class="keyword">LIKE</span> <span class="string">&#x27;%toy%&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回在描述<br>中以先后顺序同时出现 <code>toy</code> 和 <code>carrots</code> 的产品：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_desc</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_desc <span class="keyword">LIKE</span> <span class="string">&#x27;%toy%carrots%&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h1 id="Chapter-2-字段格式化输出"><a href="#Chapter-2-字段格式化输出" class="headerlink" title="Chapter 2 字段格式化输出"></a>Chapter 2 字段格式化输出</h1><blockquote>
<p>表中的列称为列，而在“计算字段”（格式化字段）中称为字段（field）；</p>
<p><strong>格式化输出的思想也遵循<a href="#principle">本思想🔗</a></strong></p>
</blockquote>
<h2 id="2-1-字段拼接"><a href="#2-1-字段拼接" class="headerlink" title="2.1 字段拼接"></a>2.1 字段拼接</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">MySQL</button><button type="button" class="tab">SQL-Server</button><button type="button" class="tab">DB2/SQLite</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Concat(col_name1<span class="operator">/</span><span class="string">&#x27;string1&#x27;</span>[, ...])</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_name1<span class="operator">/</span><span class="string">&#x27;string1&#x27;</span> <span class="operator">+</span> ... <span class="operator">+</span> col_nameN<span class="operator">/</span><span class="string">&#x27;stringN&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_name1<span class="operator">/</span><span class="string">&#x27;string1&#x27;</span> <span class="operator">||</span> ... <span class="operator">||</span> col_nameN<span class="operator">/</span><span class="string">&#x27;stringN&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="2-2-简单算术运算和-strip"><a href="#2-2-简单算术运算和-strip" class="headerlink" title="2.2 简单算术运算和 strip"></a>2.2 简单算术运算和 strip</h2><p><code>+-*/</code> 和简单函数 <code>LTRIM(str)</code>（去左空格）、<code>RTRIM(str)</code>（去右空格）、<code>TRIM(str)</code>（去两边空格）；</p>
<p>常见数学函数几乎都与主流编程语言相同（<code>SIN()</code>、<code>EXP()</code>、<code>ABS()</code> 等）；</p>
<p>常量：<code>PI()</code>；</p>
<p>⚠ <strong>以上描述都没有提及别名（alias，又称导出列，derived column），其实规范来说，对于所有的格式化输出（包括以后提及的），都应该设置别名，好处如下：</strong></p>
<ol>
<li>方便客户端引用。没有别名的格式化列无法被某些客户端使用，有些操作会变得困难；</li>
<li>重命名包含不合法字符的原列名；</li>
<li>提升可读性。在原来的列名含混、意义不清晰时扩充、具体化它；</li>
</ol>
<h2 id="2-3-普通函数处理"><a href="#2-3-普通函数处理" class="headerlink" title="2.3 普通函数处理"></a>2.3 普通函数处理</h2><p>⚠ <strong>本部分内容的可移植性会受到不同 DBMS 对函数名称和定义的影响</strong>；</p>
<p>⚠ <strong>函数名称也不区分大小写</strong>；</p>
<div style="text-align: center;">表三 SQL 普通函数对比</div>

<table style="text-align: center;">
    <tr>
        <th rowspan=2>函数用法</th>
        <th colspan=5>函数语法</th>
    </tr>
    <tr>
        <th>MySQL</th>
        <th>SQL Server</th>
        <th>DB2</th>
        <th>SQLite</th>
        <th>Oracle</th>
    </tr>
    <tr>
        <td>字符串子串</td>
        <td colspan=2>SUBSTRING()</td>
        <td colspan=3>SUBSTR()</td>
    </tr>
    <tr>
        <td>数据类型转换</td>
        <td colspan=2>CONVERT()</td>
        <td>CAST()</td>
        <td colspan=2>因类型不同</td>
    </tr>
    <tr>
        <td>取日期</td>
        <td>CURDATE()</td>
        <td>GETDATE()</td>
        <td>CURRENT_DATE</td>
        <td>DATE()</td>
        <td>SYSDATE</td>
    </tr>
    <tr>
        <td>格式化日期</td>
        <td>YEAR()等</td>
        <td>DATEPART(yy, DATE)</td>
        <td>同 MySQL</td>
        <td>strftime(strf, DATE)</td>
        <td>EXTRACT(year FROM DATE)</td>
    </tr>
    <tr>
        <td>去空格</td>
        <td colspan=5>LTRIM()、RTRIM()、TRIM()</td>
    </tr>
    <tr>
        <td>求字符串长度</td>
        <td>CHAR_LENGTH()</td>
        <td>LEN()</td>
        <td>STRING-LEGTH()</td>
        <td colspan=2>LENGTH()</td>
    </tr>
    <tr>
        <td>求数据所占Byte</td>
        <td>LENGTH()</td>
        <td>DATALENGTH()</td>
        <td>同 MySQL</td>
        <td>TYPEOF()对应的Byte</td>
        <td>LENGTHB()</td>
    </tr>
</table>

<p>tips 1. <code>SUBSTRING(str, start, end)</code>，其中 <code>end</code> 包含，且此处函数面向用户，是 <strong>1-index</strong>；</p>
<p><strong>tips 2. 还有些通用性比较好的函数：<code>UPPER()/LOWER()</code>（取大/小写）、<code>SOUNDEX()</code>（返回字符串的 <code>SOUNDEX</code> 值）</strong>;</p>
<p><strong><code>SOUNDEX()</code> 适用于英文，实质是一种将单词转化为描述发音的字母数字算法，可以找出发音近似或相同的单词，在有一些误输入的查找中有用，比如顾客名 <code>Michael</code> 误输入为 <code>Michelle</code>，但二者的 <code>SOUNDEX()</code> 相同，因此可以匹配</strong>；</p>
<h2 id="2-4-聚集函数"><a href="#2-4-聚集函数" class="headerlink" title="2.4 聚集函数"></a>2.4 聚集函数</h2><ul>
<li><p>定义：对表的<strong>某个列</strong>（某一行数据类型很可能不相同）运行的函数，仅计算返回一个值；</p>
</li>
<li><p><code>AVG()</code> 平均值函数</p>
<ol>
<li><p><strong>仅能针对单个列使用！！！</strong>如果需要多个列，请依次书写；</p>
<blockquote>
<p>仅有一种特例（实质还是一个列——导出列）：<strong>列以算术运算符连接</strong>；</p>
</blockquote>
</li>
<li><p><strong>忽略值为 <code>NULL</code> 的行</strong>；</p>
</li>
</ol>
</li>
<li><p><code>COUNT()</code> 计数函数</p>
<ol>
<li><code>COUNT(*)</code>：<strong>给表中的行计数，不忽略 <code>NULL</code></strong>；</li>
<li><code>COUNT(column)</code>：<strong>给特定列的行计数，忽略 <code>NULL</code></strong>；</li>
</ol>
</li>
<li><p><code>MAX()/MIN()</code> 最值函数：<strong>返回升序 / 降序排序后的第一行</strong>；</p>
</li>
<li><p><code>SUM()</code> 求和函数；</p>
</li>
<li><p>注意事项</p>
<ol>
<li><strong>允许列结合算数运算符</strong>；</li>
<li><strong>聚集不同值</strong>：如果对某列要按不同值进行聚集，应该在列名前指定 <code>DISTINCT</code>；</li>
<li><strong>使用聚集函数时强烈建议取别名</strong>；</li>
</ol>
</li>
</ul>
<h2 id="2-5-数据分组"><a href="#2-5-数据分组" class="headerlink" title="2.5 数据分组"></a>2.5 数据分组</h2><blockquote>
<p>主要内容：<code>SELECT</code> 的 <code>GROUP BY</code> 子句 和 <code>HAVING</code> 子句；</p>
</blockquote>
<ul>
<li><p>需求：在 2.4 中的聚集函数一般都是面向整个一列，或者一列的特定部分（如果使用了 <code>DISTINCT</code>、<code>WHERE</code> 约束）；但没法<strong>按照分类组来统计、聚集数据</strong>（例如按照 <code>date</code> 时间段分组求最大值），所以引入了<strong>数据分组</strong>；</p>
</li>
<li><p>创建分组：<code>SELECT &lt;col_name-X, [AgFuctions]&gt; FROM &lt;tb_name&gt; GROUP BY &lt;col_name-X&gt;;</code></p>
<blockquote>
<p>以上语句的含义指：将 <code>col_name-X</code> 先 <code>DISTINCT</code> 一下（<strong>所以上面的列名仅推荐使用 <code>col_name-X</code></strong>，即<strong>选择的列</strong>），再按 <code>col_name-X</code> 分组（内部完成），<strong>这时通配符 <code>*</code> 指代的对象会变成：<u>当前选择列中</u> 各自分好的组（意味着 <code>col_name-X</code> 只能有一个，否则不能使用通配符 <code>*</code>）</strong>！</p>
<p>ℹ 你可以使用聚集函数的 <code>*</code> 来试一试上面的理论；</p>
</blockquote>
</li>
<li><p>分组的性质</p>
<ol>
<li><p>数据列中 <code>NULL</code> 会被分为一组；</p>
</li>
<li><p><strong><code>GROUP BY</code> 子句必须在 <code>WHERE</code> 子句后，在 <code>ORDER BY</code> 子句之后</strong>；</p>
<blockquote>
<p><code>GROUP BY</code> 必须在 <code>WHERE</code> 之后的原因：</p>
<p><strong><code>GROUP BY</code> 产生内部分组，而 <code>WHERE</code> 只能对所有行筛选，<u>完全没有分组的概念</u></strong>，所以 <code>WHERE</code> 不能筛选分组（否则造成意想不到的结果）！</p>
<p>应该使用可以筛选分组的子句：<code>HAVING</code>（这个子句除了<strong>多了一个“可以筛选分组”的功能</strong>，其他使用与 <code>WHERE</code> 几乎一致、可以替代；但标准来说只有 <code>GROUP BY</code> + 需要筛选时才用到 <code>HAVING</code>）</p>
</blockquote>
</li>
<li><p><code>GROUP BY</code>  子句允许嵌套分组；</p>
</li>
</ol>
</li>
<li><p>过滤分组：<code>SELECT &lt;col_name-X [AgFunctions]&gt; FROM &lt;tb_name&gt; GROUP BY &lt;col_name-X&gt; HAVING &lt;cond&gt;;</code></p>
</li>
<li><p>排序分组：<code>SELECT &lt;col_name-X [AgFunctions]&gt; FROM &lt;tb_name&gt; GROUP BY &lt;col_name-X&gt; ORDER BY &lt;col_name-X&gt;;</code></p>
<p>⚠ 虽然你可能发现 <code>GROUP BY</code> 本身就可以按分组后的结果排序，但这个行为不在 SQL 规范中，<strong>所以如果有需要对分组进行排序，仍需要 <code>ORDER BY</code> 子句</strong>，不能仅仅依赖 <code>GROUP BY</code>；</p>
</li>
</ul>
<h2 id="2-6-本章习题"><a href="#2-6-本章习题" class="headerlink" title="2.6 本章习题"></a>2.6 本章习题</h2><ol>
<li><p>从 <code>Vendors</code> 表中检索 <code>vend_id</code>、<code>vend_name</code>、<code>vend_address</code> 和 <code>vend_city</code>，将 <code>vend_name</code> 重命名为 <code>vname</code>，将 <code>vend_city</code> 重命名为 <code>vcity</code>，将 <code>vend_address</code> 重命名为 <code>vaddress</code>。再按供应商名称对结果进行排序。注意所有的字符串变量的存储都有定长、记录前可能有空格：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,</span><br><span class="line">    <span class="built_in">TRIM</span>(vend_name) <span class="keyword">AS</span> vname,</span><br><span class="line">    <span class="built_in">TRIM</span>(vend_city) <span class="keyword">AS</span> vcity,</span><br><span class="line">    <span class="built_in">TRIM</span>(vend_address) <span class="keyword">AS</span> vaddress</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vname;</span><br></pre></td></tr></table></figure>
</li>
<li><p>商店正在进行打折促销，所有产品均降价 10%. 编写 SQL 语句，从 <code>Products</code> 表中返回 <code>prod_id</code>、<code>prod_price</code> 和 <code>sale_price</code>，其中<code>sale_price</code> 是一个包含促销价格的计算字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price,</span><br><span class="line">    prod_price<span class="operator">*</span><span class="number">0.9</span> <span class="keyword">AS</span> sale_price</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设商店已经上线了，正在创建顾客账户。所有用户都需要登录名，默认登录名是其名称和所在城市的组合。在表 <code>Customers</code> 中编写 SQL 语句，返回顾客 ID（<code>cust_id</code>）、顾客名称（<code>cust_name</code>）和登录名（<code>user_login</code>），其中登录名全部为大写字母，并由顾客联系人的前两个字符（<code>cust_contact</code>）和其所在城市的前三个字符（<code>cust_city</code>）组成。例如，我的登录名是 <code>BEOAK</code>（<code>Ben Forta</code>，居住在 <code>Oak Park</code>）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name,</span><br><span class="line">    <span class="built_in">UPPER</span>(</span><br><span class="line">        CONCAT(</span><br><span class="line">            <span class="built_in">SUBSTRING</span>(cust_contact, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            <span class="built_in">SUBSTRING</span>(cust_city, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        )</span><br><span class="line">    ) <span class="keyword">AS</span> user_login</span><br><span class="line"><span class="keyword">FROM</span> Customers;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 SQL 语句，返回 2020 年 1 月的所有订单（<code>Orders</code> 表）的订单号（<code>order_num</code>）和订单日期（<code>order_date</code>），并按订单日期排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, order_date</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> date_format(order_date, <span class="string">&#x27;%Y-%m&#x27;</span>) <span class="operator">=</span> <span class="string">&#x27;2020-01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 SQL 语句，找出 <code>Products</code> 表中的 <code>num_items</code> 项的总个数（不包括 <code>NULL</code>）、值不同的个数、最小、最大、平均值，列在一个表格中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(num_items) <span class="keyword">AS</span> total_cnt,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> num_items) <span class="keyword">AS</span> dist_cnt,</span><br><span class="line">    <span class="built_in">MIN</span>(num_items) <span class="keyword">AS</span> min_items,</span><br><span class="line">    <span class="built_in">MAX</span>(num_items) <span class="keyword">AS</span> max_items,</span><br><span class="line">    <span class="built_in">AVG</span>(num_items) <span class="keyword">AS</span> avg_items</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算 <code>OrderItems</code> 表中各行所要花费的金钱总和（物品数量 <code>quantity</code> * 物品价格 <code>item_price</code> 再求和）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(quantity <span class="operator">*</span> item_price) <span class="keyword">AS</span> total_cost <span class="keyword">FROM</span> OrderItems;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 SQL 语句，确定 <code>Products</code> 表中价格不超过 10 美元的最贵产品的价格（<code>prod_price</code>）。将计算所得的字段命名为 <code>max_price</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(prod_price) <span class="keyword">AS</span> max_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 SQL 语句，要求统计 <code>Products</code> 表的供应商 ID <code>vend_id</code> 各自提供的商品个数（即每个供应商在 <code>Product</code> 中含有的数据行数），按 “ID、个数（列名 <code>num_prods</code>）” 顺序输出：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 SQL 语句，要求找出 <code>Orders</code> 表中订单数不少于 2 的顾客 ID（<code>cust_id</code>），即每个 <code>cust_id</code> 在表中含有的数据行数，按 “ID、订单数” 顺序输出：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_orders</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 SQL 语句，要求找出 <code>Products</code> 表中 “提供 2 个及以上的、价格（<code>prod_price</code>）不少于4 的产品” 的供应商，按 “供应商ID（<code>vend_id</code>）、满足条件的产品数（列名 <code>num_prods</code>）” 顺序输出：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span> <span class="number">4</span>    <span class="comment">-- 注意：在这里非分组筛选需要在分组前进行</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>OrderItems</code> 表包含每个订单的每个产品。编写SQL 语句，返回每个订单号（<code>order_num</code>）各有多少行数（<code>order_lines</code>），并按 <code>order_lines</code> 对结果进行升序排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> order_lines</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_lines;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 SQL 语句，返回名为 <code>cheapest_item</code> 的字段，该字段包含每个供应商（<code>vend_id</code>）成本最低的产品（使用 <code>Products</code> 表中的 <code>prod_price</code>），然后从最低成本到最高成本对结果进行排序（按 “供应商 ID、<code>cheapest_item</code>” 输出）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注意：此处 prod_price 已不再是整个列，而是各分组的 prod_price，对它用聚集函数会得到各列的结果</span><br><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">MIN</span>(prod_price) <span class="keyword">AS</span> cheapest_item</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cheapeset_item;</span><br></pre></td></tr></table></figure>
</li>
<li><p>商店经营中，确定最佳顾客非常重要。有一个店主想出 2 种方法来确定他的最佳顾客：</p>
<p>Ⅰ. 找出满足 “所有订购产品的数量不少于 100” 的订单，至少持有一个这样订单的顾客是 “最佳顾客”；（注：在 <code>OrderItems</code> 表中特定的订单号 <code>order_num</code>、本订单订购商品名 <code>order_item</code>下的商品数量 <code>quantity</code>，是 “这个订单中 这个产品的数量”）</p>
<blockquote>
<p>所以请编写 SQL 语句，只需找出满足上述条件的这个订单，输出订单号即可；</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(quantity) <span class="operator">&gt;=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>Ⅱ. 找出满足 “总价（包含不同的商品）至少为 1000” 的订单，至少持有一个这样订单的顾客是 “最佳顾客”；（注：对于一个订单中的一个商品而言，需要在 <code>OrderItems</code> 表中计算 <code>item_price * quantity</code> 来获得订单中一类商品的总价格）</p>
<blockquote>
<p>所以请编写 SQL 语句，找出满足上述条件的订单，以降序输出订单号（<code>order_num</code>），按 “订单号、总价（列名 <code>total_price</code>）” 输出；</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">SUM</span>(item_price <span class="operator">*</span> quantity) <span class="keyword">AS</span> total_price</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> total_price <span class="operator">&gt;=</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_num <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在不运行下列语句的前提下，指出下列语句的错误：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> items</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> items</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> items, order_num;</span><br></pre></td></tr></table></figure>
<p><strong>Answer：<code>GROUP BY</code> 语句不能对聚合函数分组！</strong>从分组聚合的含义上来说，<code>COUNT(*)</code> 是对分组后的组进行计数，这样是循环指代，从逻辑上行不通；</p>
<p><strong>改正方案：将 <code>GROUP BY items</code> 分组依据改成 <code>GROUP BY order_num</code> 就正确了，如下：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> items</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> items, order_num;</span><br></pre></td></tr></table></figure>
<p><strong>这段语句的含义是：找出所有满足 “包含不少于 3 种商品” 的订单，并按 “订单所含商品种类数、订单号” 输出（最后按种类数，再按订单号升序排序）；</strong></p>
</li>
</ol>
<h1 id="EX-1-第一部分语法总结"><a href="#EX-1-第一部分语法总结" class="headerlink" title="EX-1 第一部分语法总结"></a>EX-1 第一部分语法总结</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>col_name1[, ...]<span class="operator">&gt;</span> [<span class="keyword">AS</span> new_name]</span><br><span class="line">[<span class="keyword">FROM</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>cond<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>col_name1<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">HAVING</span> <span class="operator">&lt;</span>cond<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>col_name<span class="operator">-</span>N<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SSRVodka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/technical/sql-basic-1/">https://blog.sjtuxhw.top/technical/sql-basic-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SSRVodka's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Programming/">Programming</a><a class="post-meta__tags" href="/tags/SQL/">SQL</a><a class="post-meta__tags" href="/tags/Database/">Database</a><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/sql-1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/technical/docker-basic/" title="Docker 基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/docker.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Docker 基础</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference：Docker 官方文档 本人学识有限，解析难免有错，恳请读者能够批评指正，本人将不胜感激！    前置知识：Linux、Git、虚拟机、略懂操作系统；  Chapter 0. Docker 安装Mac 安装1brew install --cask docker Linux 任何 distribution 自动安装12curl -fsSL get.docker.com -o get-docker.sh    # 自动安装脚本sudo sh get-docker.sh --mirror Aliyun # 国内阿里云，如果你在国外，删除 --mirror参数 Ubuntu 手动安装 卸载旧版本 123sudo apt-get remove docker \               docker-engine \               docker.io  安装 HTTPS 必要软件包 和 CA 证书防止安装包篡改 12345678sudo apt-get updatesudo apt-get install \  ...</div></div></div></a><a class="pagination-related" href="/technical/matlab-review/" title="Matlab 复习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/matlab.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Matlab 复习</div></div><div class="info-2"><div class="info-item-1">Written by SJTU_XHW Version: Matlab R2020b References: MATLAB Documentation (mathworks.com)   Chapter0 Matlab is a 1-index languageChapter1 Basic Operations1.1 operators: numerical { +-*/^() } ；logical { ~ || &amp;&amp; &gt; &lt; ==（按位运算须函数） }；1.2 variables: do not need to be declaed before assignment (类似Python)1.3 numeric variable type：logical、char、numeric、cell、struct、scalar1.4 constants：ans，i/j，Inf，eps（2.2204e-016），NaN，pi1.5 keywords：iskeyword1.6 calling priority local variable $\gt$...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/review/csapp-basic/" title="CSAPP Notes Basic"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="info-item-2">CSAPP Notes Basic</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference:  CMU - 213, Computer Systems A Programmer’s Perspective 3rd Edition by Randal Bryant, David O’Hallaron 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 内容很长，写起来很慢 😳   Chapter 0. Intro0.1 Ints are not Integers, Floats are not Reals $x^2\ge 0$：int（32-bit）may overflow； $a+(b+c)=(a+b)+c$：floats may discard some “unsignificant” digits；  0.2 Learn Assembly but never write it0.3 Memory Matters: Unbounded1234567891011121314typedef struct &#123;    int a[2];    double d;&#125;...</div></div></div></a><a class="pagination-related" href="/review/csapp-ecf-io/" title="CSAPP Notes: ECF &amp; I&#x2F;O"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-ecf.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-16</div><div class="info-item-2">CSAPP Notes: ECF &amp; I&#x2F;O</div></div><div class="info-2"><div class="info-item-1">Chapter 13. Exceptional Control Flow 对应书中第 8 章。  异常控制流是现代计算机系统的一个相当重要的部分。 13.1 Control Flow 控制流：从机器打开到关闭的过程中，处理器只做一件事：读指令、执行指令，一个周期做一个指令。多核的机器则每个核心依次交替执行指令。这些指令序列被称为控制流。硬件正在执行的实际指令序列就被称为物理控制流。  改变内存中控制流的方法：分支 &amp; 跳转，过程调用 &amp; 返回（Branches &amp; Jumps &amp; Procedure call and return）；  都是对于程序状态变化的处理。    但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）； 什么是 “系统级别的状态变化”？  数据从磁盘 / 网卡到达内存中； I/O 设备输入...</div></div></div></a><a class="pagination-related" href="/review/csapp-mm-cache/" title="CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-mh.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-10</div><div class="info-item-2">CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt</div></div><div class="info-2"><div class="info-item-1">Chapter 10. The Memory Hierarchy 本章将介绍系统的内存分层架构。  之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。 正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。 10.1 Storage Technologies &amp; Trends在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。 10.1.1 Random-Access Memory (RAM)当前大多数人所熟知的 “内存” 的一部分就是随机访问存储器（RAM），它具有以下的特征：  RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；  RAM 常常被打包放在 CPU 芯片中；  RAM 中每一个基本的存储单元被称为 单元胞（Cell），一个单元胞中存放 1 bit 数据；  很多个 RAM 芯片共同工作，组成了计算机的...</div></div></div></a><a class="pagination-related" href="/review/csapp-sched-arch/" title="CSAPP Notes: Scheduler &amp; Arch"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_p2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-11</div><div class="info-item-2">CSAPP Notes: Scheduler &amp; Arch</div></div><div class="info-2"><div class="info-item-1">Chapter 8. Scheduler in OS为操作系统的调度环境作出假设：  Each job runs for the same amount of time All jobs arrive at the same time Once started, each job runs to completion All jobs only use the CPU  i.e., they perform no I/O   The run-time of each job is known  引入调度优劣衡量指标：周转时间，$T_{turnaround}=T_{completion}-T_{arrival}$； Strategy 1: FIFO（FCFS，First Come First Served） Implementation: queue； 消除假设 1：若短时任务排在长时任务之后，则平均周转时间效果很差；  Strategy 2 : SJF（Shortest Job First） 内容：对于同时到达的任务，优先选择总时长小的任务。 作用：（应对假设 1...</div></div></div></a><a class="pagination-related" href="/technical/gnu-tutor/" title="GNU-Tutor"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/GNU-Tutor.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="info-item-2">GNU-Tutor</div></div><div class="info-2"><div class="info-item-1">基础：C/C++的源文件编译过程 想要代码在操作系统上运行，需要进行以下编译步骤，从高级语言转机器语言，以下任务gcc/g++均能完成：  预编译（.c/cpp &amp; .h —&gt; .i ）：*对应gcc/g++命令：gcc -E [xxx] -o [output.i] 展开所有宏定义#define（字符替换）； 处理所有条件预编译命令（#ifdef、#ifndef、#endif等）； 处理#include，具体操作是将指向的文件直接插入到文件的这一行（严格遵循上一步的条件）； 删除所有注释； 添加行号、文件标识，以便调试/编译出错时及时指出； 保留#pragma指令，以供编译器使用；   编译（.i —&gt; .s ，即高级语言转汇编语言）：对应gcc/g++命令：gcc -S [xxx] -o...</div></div></div></a><a class="pagination-related" href="/technical/git-learning/" title="Git学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/git.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="info-item-2">Git学习笔记</div></div><div class="info-2"><div class="info-item-1">Chapter 0. The history of version control systems Local Version Control Systems  downsides: It is easy to forget which directory you’re in and accidentally write to the wrong file or copy over files you don’t mean to.   Centralized Version Control Systems  downsides:   the single point of failure that the centralized server represents  if the hard disk the central database is on becomes corrupted, and  proper backups haven’t been kept, you lose absolutely everything (Local VCSs suffer from...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="xhw-card-content"><div class="xhw-avatar-group"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="xhw-sticker"><img class="sticker-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/smile.avif" alt="emoji-sticker"/></div></div></div><div class="author-info-name">SSRVodka</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span><a class="service-status-badge" id="serviceStatusBadge" href="https://status.sjtuxhw.top" rel="external nofollow noreferrer" target="_blank"><span class="status-loading"></span><span class="status-text">loading...</span></a></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E9%A1%BB%E7%9F%A5"><span class="toc-text">使用前须知</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">Chapter 0 数据库的基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2"><span class="toc-text">Chapter 1 数据检索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-SELECT-%E8%AF%AD%E5%8F%A5"><span class="toc-text">1.1 SELECT 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%8E%92%E5%BA%8F%E5%B7%B2%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="toc-text">1.2 排序已检索数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%BF%87%E6%BB%A4%E5%B7%B2%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="toc-text">1.3 过滤已检索数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-%E5%AD%97%E6%AE%B5%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">Chapter 2 字段格式化输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%AD%97%E6%AE%B5%E6%8B%BC%E6%8E%A5"><span class="toc-text">2.1 字段拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%AE%80%E5%8D%95%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%92%8C-strip"><span class="toc-text">2.2 简单算术运算和 strip</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-text">2.3 普通函数处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-text">2.4 聚集函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84"><span class="toc-text">2.5 数据分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%9C%AC%E7%AB%A0%E4%B9%A0%E9%A2%98"><span class="toc-text">2.6 本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EX-1-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">EX-1 第一部分语法总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/2025-ccf/" title="CCF 2025 会议笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ccf-2025.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CCF 2025 会议笔记"/></a><div class="content"><a class="title" href="/technical/2025-ccf/" title="CCF 2025 会议笔记">CCF 2025 会议笔记</a><time datetime="2025-08-03T03:36:45.000Z" title="发表于 2025-08-03 11:36:45">2025-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/transformer.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Transformer 论文精读 + 代码实现"/></a><div class="content"><a class="title" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现">Transformer 论文精读 + 代码实现</a><time datetime="2025-07-20T15:15:10.000Z" title="发表于 2025-07-20 23:15:10">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/sc.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"/></a><div class="content"><a class="title" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</a><time datetime="2025-07-01T10:14:11.000Z" title="发表于 2025-07-01 18:14:11">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ml-roadmap.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识图谱：Machine Learning Roadmap"/></a><div class="content"><a class="title" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap">知识图谱：Machine Learning Roadmap</a><time datetime="2025-06-08T06:59:31.000Z" title="发表于 2025-06-08 14:59:31">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"/></a><div class="content"><a class="title" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</a><time datetime="2025-05-30T08:49:12.000Z" title="发表于 2025-05-30 16:49:12">2025-05-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SSRVodka  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-image"><a class="rightMenu-item" href="javascript:rmf.copyImageUrl();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制图片地址</span></a><a class="rightMenu-item" href="javascript:rmf.downloadImage();" rel="external nofollow noreferrer"><i class="fa-solid fa-download"></i><span>保存图片</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-link"><a class="rightMenu-item" href="javascript:rmf.copyLink();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制链接地址</span></a><a class="rightMenu-item" href="javascript:rmf.openLinkNewTab();" rel="external nofollow noreferrer"><i class="fa-solid fa-external-link-alt"></i><span>在新标签页打开</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script src="/js/status_badge.js"></script><script defer src="/js/console_welcome.js"></script><script async data-pjax src="/js/bsz.build-20250729.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>