<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TypeScript笔记 | SSRVodka's blog</title><meta name="author" content="SSRVodka,xhwpro@gmail.com"><meta name="copyright" content="SSRVodka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Written by SJTU-XHW Reference:  MDN Doc &amp;&amp; TypeScript Doc 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript笔记">
<meta property="og:url" content="https://blog.sjtuxhw.top/technical/typescript-basic/index.html">
<meta property="og:site_name" content="SSRVodka&#39;s blog">
<meta property="og:description" content="Written by SJTU-XHW Reference:  MDN Doc &amp;&amp; TypeScript Doc 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/typescript.png">
<meta property="article:published_time" content="2024-03-18T14:56:29.000Z">
<meta property="article:modified_time" content="2024-10-25T14:01:35.568Z">
<meta property="article:author" content="SSRVodka">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="TypeScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/typescript.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/technical/typescript-basic/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/css/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TypeScript笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SSRVodka's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">78</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/typescript.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SSRVodka's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TypeScript笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://notes.sjtuxhw.top"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> Notes</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fa-solid fa-train-subway"></i><span> Travelling</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TypeScript笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-18T14:56:29.000Z" title="发表于 2024-03-18 22:56:29">2024-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T14:01:35.568Z" title="更新于 2024-10-25 22:01:35">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/technical/typescript-basic/#post-comment"><span class="waline-comment-count" data-path="/technical/typescript-basic/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><i>Written by SJTU-XHW</i></p>
<p><i>Reference: </i> MDN Doc &amp;&amp; TypeScript Doc</p>
<p><i>本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！</i></p>
<hr>
<span id="more"></span>
<h1 id="Chapter-1-与-JS-比较：类型声明-与-作用域"><a href="#Chapter-1-与-JS-比较：类型声明-与-作用域" class="headerlink" title="Chapter 1. 与 JS 比较：类型声明 与 作用域"></a>Chapter 1. 与 JS 比较：类型声明 与 作用域</h1><p>TypeScript 是个静态类型语言，<strong>变量类型/对象成员/函数签名 在定义后就不能更改！</strong></p>
<ul>
<li><p>定义变量时，请使用规范的类型声明定义方式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Variable */</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">bar</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, TypeScript!&quot;</span>;</span><br><span class="line"><span class="comment">/* Function */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>天大的福音：<strong>只声明变量、不赋值就使用会报错！这下不用担心讨厌的 <code>undefined</code> 了</strong>；</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>而且开启了编译选项 <code>strictNullChecks</code> 后，<code>undefined</code> 也是个独立的类型，不能赋给除了 <code>undefined</code> 类型以外的其他类型！</p>
</li>
<li><p>不允许给变量中途赋予不同类型的值；</p>
</li>
</ul>
<p>此外，<strong>比 JavaScript 更加暖心的操作是：TypeScript 全面支持 <u>块级作用域</u>！</strong>定义在块级作用域内的变量、类型等等不再能被外界读到了！</p>
<h1 id="Chapter-2-TypeScript-编译"><a href="#Chapter-2-TypeScript-编译" class="headerlink" title="Chapter 2. TypeScript 编译"></a>Chapter 2. TypeScript 编译</h1><p>TypeScript 不提供运行环境，全部交给 JavaScript，自己只提供转换为 JavaScript 的编译器 <code>tsc</code>，甚至这个编译器也是 JavaScript 的一个库，可以用 <code>npm</code> 安装。</p>
<p>编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。</p>
<p>因此，TypeScript 的类型检查只是编译时的类型检查，而不是运行时的类型检查。一旦代码编译为 JavaScript，运行时就不再检查类型了。</p>
<p>TypeScript 的编译器 <code>tsc</code> 的简单使用如下：</p>
<ul>
<li><p>安装：<code>npm install -g typescript</code>；</p>
</li>
<li><p>编译单个 TS 文件，或多个没有层次依赖关系的 TS 文件：<code>tsc a.ts[, b.ts, ...]</code>；</p>
<blockquote>
<p>分别生成 <code>a.js, b.js, ...</code>；</p>
</blockquote>
</li>
<li><p><code>--outFile</code> 编译为一个指定的 JavaScript：<code>tsc a.ts[, b.ts, ...] --outFile XXX.js</code>；</p>
</li>
<li><p><code>--outDir</code> 指定输出目录；</p>
</li>
<li><p><code>--target</code> 指定编译 JavaScript 标准（建议 <code>es2015</code> 及以上）；</p>
</li>
</ul>
<p>如果项目更复杂一点，就需要 <code>tsconfig.json</code> 管理编译过程（考虑 Java 的 Gradle 和 C++ 的 CMakeLists）。其简单结构如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;file1.ts&quot;</span><span class="punctuation">,</span> <span class="string">&quot;file2.ts&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/app.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这时候直接运行 <code>tsc</code> 等价于原来的 <code>tsc file1.ts file2.ts --outFile dist/app.js</code>；</p>
<p>更复杂的使用以后介绍。</p>
<h1 id="Chapter-3-TypeScript-类型系统"><a href="#Chapter-3-TypeScript-类型系统" class="headerlink" title="Chapter 3. TypeScript 类型系统"></a>Chapter 3. TypeScript 类型系统</h1><h2 id="3-1-新的辅助类型"><a href="#3-1-新的辅助类型" class="headerlink" title="3.1 新的辅助类型"></a>3.1 新的辅助类型</h2><p>和 JavaScript 不一样的是，TypeScript 提供了 3 种特殊类型：<code>any</code>、<code>unknown</code>、<code>never</code>，它们是为了配合静态类型系统更好的发挥功能而创造出来的。</p>
<h3 id="3-1-1-Any-类型"><a href="#3-1-1-Any-类型" class="headerlink" title="3.1.1 Any 类型"></a>3.1.1 Any 类型</h3><p>当给变量声明 <code>any</code> 类型时，<strong>TypeScript 会关闭这个变量的类型检查，这个变量单独变为 “动态类型”</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">x</span>(<span class="number">1</span>); <span class="comment">// OK</span></span><br><span class="line">x.<span class="property">foo</span> = <span class="number">100</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="string">&quot;foo&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>如你所见，肯定要避免使用 <code>any</code> 类型，不然你为什么不用 JavaScript？</p>
<p>频繁使用 <code>any</code> 会导致 TypeScript 丧失静态类型的优势，具体来说有几个坏处：</p>
<ul>
<li><p>干扰类型推断和编译前错误检查：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">any</span>, y: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>静态类型污染：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 不报错</span></span><br><span class="line"></span><br><span class="line">y * <span class="number">123</span>; <span class="comment">// 不报错</span></span><br><span class="line">y.<span class="title function_">toFixed</span>(); <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>即使你不使用 <code>any</code> 类型，也要注意编译器可能<strong>自动推断 <code>any</code> 类型</strong>，这通常是因为开发者不良开发习惯所导致的 —— <strong>声明、定义变量 / 定义函数 时，不进行类型标注</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">let</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上变量、函数声明全部会被编译器推断为 <code>any</code>，从而干扰类型检查！</p>
<p>总之，<u>对于 TypeScript 的 <code>any</code> 类型，请敬而远之！自己不写 <code>any</code>，也别让编译器推断出 <code>any</code></u>。这是编译器实在没法进行类型检查时候的下下策。</p>
<blockquote>
<p>还是那句话，不然你为什么不直接用 JavaScript？</p>
</blockquote>
<h3 id="3-1-2-Unknown-类型"><a href="#3-1-2-Unknown-类型" class="headerlink" title="3.1.2 Unknown 类型"></a>3.1.2 Unknown 类型</h3><p>为了防止 <code>any</code> 的类型污染等问题，人们定义了一种比 <code>any</code> 类型严格的辅助类型 <code>unknown</code>，规则如下：</p>
<ul>
<li>允许给 <code>unknown</code> 类型变量赋予任何类型的值；</li>
<li><strong>不允许将 <code>unknown</code> 类型变量赋予其他确定类型（即除了 <code>any</code> 和 <code>unknown</code>）的值</strong>；</li>
<li><strong>不允许使用 <code>unknown</code> 类型的方法、属性</strong>；</li>
<li>只能对 <code>unknown</code> 类型进行有限的运算：逻辑运算、判断相等运算、<code>typeof</code>、<code>instanceof</code>，其他运算均不可以；</li>
</ul>
<p>违反以上规则，编译器会抛出错误。</p>
<p>但是 <code>unknown</code> <strong>允许<u>类型缩窄</u></strong>（比如一开始没法确定这个数据的类型，但是后面要处理时确定了，这种情况就不需要使用 <code>any</code> 了），如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: <span class="built_in">unknown</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> s === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">  s.<span class="property">length</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在作用域中，<code>s</code> 类型被缩窄为 <code>string</code>，变成了确定类型，就可以使用确定类型的一切方法和属性了。</p>
<p>总之，<strong>某些逻辑下，实在无法确定类型，应该优先使用 <code>unknown</code> 类型，避免 <code>any</code> 出现</strong>。</p>
<h3 id="3-1-3-Never-类型"><a href="#3-1-3-Never-类型" class="headerlink" title="3.1.3 Never 类型"></a>3.1.3 Never 类型</h3><p>从集合论的角度，人们定义了这个类型，含义是 <strong>空类型</strong>，可以赋给任何类型的变量。</p>
<p>你可能会好奇，那被赋予 <code>never</code> 类型的变量内部的值怎么办？</p>
<p>问出这个问题说明你还没有明白 <code>never</code> 的使用场景：<strong>在函数中，它标识控制流永远无法到达函数返回的时候；在变量中，它标识永远都不会用到该变量</strong>。</p>
<p>例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, TypeScript!&quot;</span>);    <span class="comment">// 编译器会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是错误的，因为函数能够执行到最后，返回的是 <code>undefined</code> 类型的对象，而不是空。</p>
<blockquote>
<p>如果你只是想标识函数不返回值，请使用 <code>undefined</code> / <code>void</code> 作为返回类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, TypeScript!&quot;</span>);  <span class="comment">// Correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样才是正确使用方式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    <span class="comment">/* Control Never Reaches Here! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-新的基本类型-和-引用类型"><a href="#3-2-新的基本类型-和-引用类型" class="headerlink" title="3.2 新的基本类型 和 引用类型"></a>3.2 新的基本类型 和 引用类型</h2><p>复习一下 JavaScript 中有几种基本类型和引用类型：</p>
<p><code>boolean</code>、<code>string</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>、<code>object</code>（狭义对象类型也是个基本类型，和广义对象类型 <code>Object</code> 不同，仅包含所有引用类型，如 Array 等内置引用类型）、<code>undefined</code>、<code>null</code>；</p>
<blockquote>
<p>补充 JavaScript 不常用的类型使用方法：</p>
<ul>
<li><code>bigint</code>：<strong>在 JavaScript 中，使用 <code>bigint</code> 需要数字尾缀 <code>n</code></strong>，例如 <code>123n</code>；</li>
</ul>
</blockquote>
<h3 id="3-2-1-TypeScript-的对象"><a href="#3-2-1-TypeScript-的对象" class="headerlink" title="3.2.1 TypeScript 的对象"></a>3.2.1 TypeScript 的对象</h3><p>这里得说明一下，对象（引用类型）的定义和 JavaScript <strong>显著不同</strong>。</p>
<p>因为 TypeScript 作为一种静态类型语言，不允许定以后更改数据成员。因此你这么写，编译器会报错：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">o1</span>: <span class="title class_">Object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">o2</span>: <span class="built_in">object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">o1.<span class="property">foo</span>; <span class="comment">// TypeError</span></span><br><span class="line">o2.<span class="property">foo</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>因为你定义的 <code>o1/o2</code> 类型是原生的 <code>object/Object</code>，都只有原生的属性和方法，<code>foo</code> 属性在赋值时就被抛弃了。</p>
<p><strong>要想自定义对象的属性和方法，要么定义对象类型，要么定义 <code>class</code>（TypeScript 的类，后面讲）</strong>；</p>
<h3 id="3-2-2-TypeScript-值类型"><a href="#3-2-2-TypeScript-值类型" class="headerlink" title="3.2.2 TypeScript 值类型"></a>3.2.2 TypeScript 值类型</h3><p>TypeScript 规定，单个值也是一种类型，称为“值类型”，不常用，它常常用在联合 / 交叉类型中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">name</span>: <span class="string">&quot;Hello&quot;</span>;    <span class="comment">// 只能被赋予 &quot;Hello&quot;，其他内容都会报错。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-TypeScript-常量类型"><a href="#3-2-3-TypeScript-常量类型" class="headerlink" title="3.2.3 TypeScript 常量类型"></a>3.2.3 TypeScript 常量类型</h3><p>所有使用 <code>const</code> 关键字修饰的 TypeScript 的变量都是常量，它们不能被更改。</p>
<p>你可以把这个变量理解为 <strong>以初次赋予的值为值类型的变量</strong>。</p>
<h3 id="3-2-4-TypeScript-对象类型"><a href="#3-2-4-TypeScript-对象类型" class="headerlink" title="3.2.4 TypeScript 对象类型"></a>3.2.4 TypeScript 对象类型</h3><h4 id="3-2-4-1-使用方法"><a href="#3-2-4-1-使用方法" class="headerlink" title="3.2.4.1 使用方法"></a>3.2.4.1 使用方法</h4><p>而 “对象类型” 则<strong>可以很方便地（无需定义接口 interface、类型 class）定义对象并指定临时类型</strong>，如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">testFunc1</span>(<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">testFunc2</span>: <span class="function">(<span class="params">c: <span class="built_in">string</span>, d: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">boolean</span>;    <span class="comment">// 箭头函数式声明</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    <span class="title function_">testFunc1</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? a.<span class="title function_">toString</span>() : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    testFunc2 = <span class="keyword">function</span>(<span class="params">c, d</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c === d.<span class="built_in">parseInt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-4-2-对象类型的特性"><a href="#3-2-4-2-对象类型的特性" class="headerlink" title="3.2.4.2 对象类型的特性"></a>3.2.4.2 对象类型的特性</h4><p>一旦声明某个对象的对象类型后，赋值一定要分毫不差地按照类型来，否则编译器不会接受，即<u><strong>不允许</strong></u>以下行为：</p>
<ul>
<li>增添对象类型中不存在的字段、删除对象类型中已有的字段；</li>
<li>定义+赋值时，少给一个成员赋值，或者给不存在的成员赋值；</li>
</ul>
<p>但是它也允许一些特性以在合理的范围内支持灵活性：</p>
<ul>
<li><p>允许数据域添加 可选修饰符 <code>?</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span> | <span class="literal">undefined</span>; <span class="comment">// 注意进行类型缩窄</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>允许数据域添加 只读修饰符 <code>readonly</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">resident</span>: &#123;	<span class="comment">// 只读数据域如果是对象，则允许更改数据域，不允许更改对象引用</span></span><br><span class="line">        <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">        <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只读数据域和普通数据域间传递，与 C 的 <code>const</code> 修饰类型和普通类型的方法一样，不再赘述。</p>
</li>
<li><p>允许 <u><strong>数据域索引</strong></u>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TestObjT</span> = &#123;</span><br><span class="line">    [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>TestObjT</code> 的含义是，<strong>不管这个对象有多少属性，只要属性名为字符串，且属性值也是字符串，就符合这个类型声明</strong>，比如可以这么定义：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">tobj</span>: <span class="title class_">TestObjT</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="attr">baz</span>: <span class="string">&quot;3&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此外，对象类型的数据域索引中 property 类型允许 <code>string</code>、<code>number</code>、<code>symbol</code>；</p>
<p>不过这个特性不建议使用，因为对类型的约束过于宽泛。</p>
</li>
</ul>
<h4 id="3-2-4-3-解构赋值-与-对象类型"><a href="#3-2-4-3-解构赋值-与-对象类型" class="headerlink" title="3.2.4.3 解构赋值 与 对象类型"></a>3.2.4.3 解构赋值 与 对象类型</h4><p>和 python 的解构语法类似，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, axe = matplotlib.pyplot.subplots()</span><br><span class="line">[a, _] = curStr.split(<span class="string">&#x27;/&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>TypeScript 的解构要求指定 <strong>对象类型</strong>，其实有两种语法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 obj **按序**解构到指定的变量，必须声明成对象的对象类型（type of obj）</span></span><br><span class="line">&lt;qualifiers&gt; &#123;var1, var2, ...&#125;: &lt;type of obj&gt; = obj;</span><br><span class="line">// 自定义解构顺序</span><br><span class="line">&lt;qualifiers&gt; &#123;objProp1: var1, objProp2: var2, ...&#125;: &lt;type of obj&gt; = obj；</span><br></pre></td></tr></table></figure>
<p>第一种语法很好理解，比如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  id,</span><br><span class="line">  name,</span><br><span class="line">  price,</span><br><span class="line">&#125;: &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = product;</span><br></pre></td></tr></table></figure>
<p>但我们发现 “自定义解构顺序” 的写法非常迷惑，因为大括号内的冒号不再指类型，而是指数据域的映射关系，例如很多新手会这么写：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">shape</span>: <span class="title class_">Shape</span>;</span><br><span class="line">    <span class="attr">xpos</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">shape</span>: &#123;<span class="attr">width</span>: <span class="number">1</span>, <span class="attr">height</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="attr">xpos</span>: <span class="number">0.0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">shape</span>: <span class="title class_">Shape</span>, <span class="attr">xpos</span>: <span class="built_in">number</span>&#125; = obj;</span><br></pre></td></tr></table></figure>
<p>最后一句话的含义是什么？如果你认为这是第一种语法，按序把 <code>obj</code> 的 <code>shape</code> 和 <code>xpos</code> 属性赋给了外部的 <code>shape</code>、<code>xpos</code> 变量，<strong>那么就大错特错了！</strong></p>
<p>因为要牢记：<u><strong>解构语法中的冒号不再作为类型尾缀，而是作为数据域映射的含义</strong></u>，在这里，解构语法一旦出现冒号，就一定是第二条语法。</p>
<p>上面的最后一条语句的真正含义是，<strong>将 <code>obj</code> 的 <code>shape</code> 数据域赋给外围以 “Shape” 为变量名的变量，它的类型名也是 <code>Shape</code>！</strong>（number 同理）</p>
<h4 id="3-2-4-4-对象类型的结构类型原则（Structual-Typing-Principle）"><a href="#3-2-4-4-对象类型的结构类型原则（Structual-Typing-Principle）" class="headerlink" title="3.2.4.4 对象类型的结构类型原则（Structual Typing Principle）"></a>3.2.4.4 对象类型的结构类型原则（Structual Typing Principle）</h4><p>只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structual typing）。</p>
<p>例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">A</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">B</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象 B 满足 A 的结构特征，说明 B 的对象类型 <strong>兼容</strong> A 的对象类型，因此 B 可以直接赋给 A，但反过来不行。</p>
<h4 id="3-2-4-5-对象类型的最小可选属性规则"><a href="#3-2-4-5-对象类型的最小可选属性规则" class="headerlink" title="3.2.4.5 对象类型的最小可选属性规则"></a>3.2.4.5 对象类型的最小可选属性规则</h4><p>如果一个对象类型所有属性都由 可选修饰符 修饰，按语义理解的话，所有对象都会符合这个定义。</p>
<p>TypeScript 为了防止类型模糊，规定：</p>
<p>当一个对象类型所有属性都由 可选修饰符 修饰，那么要定义一个该类型的对象，<strong>至少要含有一个可选属性</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Options</span> = &#123;</span><br><span class="line">    a?: <span class="built_in">number</span>;</span><br><span class="line">    b?: <span class="built_in">number</span>;</span><br><span class="line">    c?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">Options</span> = &#123;</span><br><span class="line">    <span class="attr">d</span>: <span class="number">123</span>, <span class="comment">// TypeError</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: <span class="title class_">Options</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>;    <span class="comment">// Correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-5-TypeScript-的联合类型-与-交叉类型"><a href="#3-2-5-TypeScript-的联合类型-与-交叉类型" class="headerlink" title="3.2.5 TypeScript 的联合类型 与 交叉类型"></a>3.2.5 TypeScript 的联合类型 与 交叉类型</h3><p>联合类型 <code>var x: A | B</code> 表示 <code>x</code> 既可以是 <code>A</code> 类型，又可以是 <code>B</code> 类型；</p>
<p>这其实是暂时无法判断类型的最正确的处理方法。</p>
<p>它仅允许使用二者类型共同的属性或方法，否则编译器会抛出错误。必须使用 <strong>缩窄类型</strong> 才可以针对性地使用属性和方法。</p>
<p>交叉类型 <code>var y: A &amp; B</code> 表示 <code>x</code> 必须既是 <code>A</code> 类型，又是 <code>B</code> 类型，<strong>最常见用作对象属性的临时合成</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span> &amp; <span class="built_in">string</span>;    <span class="comment">// 编译器认为无法取得，是 never 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123; <span class="attr">foo</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">bar</span>: <span class="built_in">string</span> &#125;;    <span class="comment">// 具有 foo, bar 两个数据成员的对象类型</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-6-TypeScript-类型别名"><a href="#3-2-6-TypeScript-类型别名" class="headerlink" title="3.2.6 TypeScript 类型别名"></a>3.2.6 TypeScript 类型别名</h3><p>TypeScript 中的关键字 <code>type</code>，现在完全可以理解为 C 的 <code>typedef</code>，就是<strong>定义一个类型（值类型、对象类型、联合类型、交叉类型，等等）的别名</strong>，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">TA</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">testFunc1</span>(<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">testFunc2</span>: <span class="function">(<span class="params">c: <span class="built_in">string</span>, d: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">TB</span> = <span class="variable constant_">TA</span> &amp; &#123; <span class="attr">z</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="variable constant_">TB</span> = &#123;</span><br><span class="line">    <span class="comment">/* Definitions */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p><strong>别名不允许重名！</strong></p>
</li>
<li><p>别名的有效范围是当前的块级作用域（例如定义在大括号内、函数内，在外面就没有效用了）；</p>
</li>
<li><p>别名支持使用表达式定义，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">World</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="string">`hello <span class="subst">$&#123;World&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>别名是类型相关代码，因此在编译为 JavaScript 后会被完全清除。</p>
</li>
</ul>
<h3 id="3-2-7-TypeScript-typeof-运算符"><a href="#3-2-7-TypeScript-typeof-运算符" class="headerlink" title="3.2.7 TypeScript typeof 运算符"></a>3.2.7 TypeScript <code>typeof</code> 运算符</h3><p>JavaScript 的 <code>typeof</code> 返回的是对应类型的字符串；</p>
<p>实际上，在 TypeScript 中保留了 JavaScript 的 <code>typeof</code>，又增添了一个新的 <code>typeof</code> 运算符，返回的是 <strong>TypeScript 类型（比如基本类型、值类型、对象类型等等）</strong>，由于是类型，因此这种运算符不能用于值运算，只能放在类型推导中。</p>
<p>举个例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="keyword">typeof</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个 <code>typeof</code> 是 TypeScript 新增的返回类型的 <code>typeof</code>，只能用于类型推导，参数不能是<strong>表达式</strong>（前面的类型别名可以）。在编译后会被完全清除；</p>
<p>第二个 <code>typeof</code> 是 JavaScript 原生的 <code>typeof</code>，返回的是字符串，可以用于值运算。</p>
<h2 id="3-3-TypeScript-中的数组：基本类型和内置引用类型"><a href="#3-3-TypeScript-中的数组：基本类型和内置引用类型" class="headerlink" title="3.3 TypeScript 中的数组：基本类型和内置引用类型"></a>3.3 TypeScript 中的数组：基本类型和内置引用类型</h2><h3 id="3-3-1-定义和使用"><a href="#3-3-1-定义和使用" class="headerlink" title="3.3.1 定义和使用"></a>3.3.1 定义和使用</h3><p>这里和 JavaScript 动态类型语言不像，而是更接近 Java 的静态类型。</p>
<p><strong>TypeScript 数组所有成员的类型必须相同，但是成员数量是不确定的</strong>，<u>不论是基本类型数组 <code>type[]</code> 还是 内置类型 <code>Array&lt;Type&gt;</code></u>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">arr</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>内置类型 Array 被改成了更像 Java 的泛型，方法和 JavaScript 原生都是一样的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">arr</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>和 JavaScript 一样，可以通过修改 <code>length</code> 属性直接增减成员。</p>
<p>由于长度不定，因此 <strong>TypeScript 的数组越界也不会报错</strong>，只会返回 <code>undefined</code>；</p>
<p><code>Array</code> 内置类型和 JavaScript 原生用法几乎一致，方法不再赘述。</p>
<h3 id="3-3-2-只读数组"><a href="#3-3-2-只读数组" class="headerlink" title="3.3.2 只读数组"></a>3.3.2 只读数组</h3><p>不仅是 JavaScript，大多数语言都认为数组及其他形式的对象都是 <strong>可变数据类型</strong>，因此把数组本身定义为 <code>const</code> 是不会阻止数组被修改的。我们以 C++ 为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">size_t</span> s): <span class="built_in">arrSize</span>(s), <span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[s] &#123;<span class="number">0</span>&#125;) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;<span class="keyword">delete</span>[] arr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> arrSize;</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setter</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        arr[idx] = val;    <span class="comment">// OK！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>setter</code> 函数使用 <code>const</code> 修饰，也没能阻止数组被修改。</p>
<p>为了限制可变数据类型的修改问题，C++ 采用的是常量指针的方法，声明不允许修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 上面的 arr 声明改成： */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> <span class="type">const</span>* arr;</span><br></pre></td></tr></table></figure>
<p>这样数组就不再可以被修改，上面的 <code>setter</code> 也会让编译器报错。</p>
<p>那么 TypeScript 是怎么做的？答案是加 <code>readonly</code> 关键字：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">0</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>这样无论是使用删除、修改、新增数组成员的方法都会报错。我们可以将 <code>readonly number[]</code> 和 <code>number[]</code> 视为两个类型。</p>
<p>为此，TypeScript 设计了泛型 <code>Readonly&lt;T&gt;</code> 和 <code>ReadonlyArray&lt;T&gt;</code>，效果类似。</p>
<h3 id="3-3-3-多维数组"><a href="#3-3-3-多维数组" class="headerlink" title="3.3.3 多维数组"></a>3.3.3 多维数组</h3><p>和 Java 定义很像，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">multi</span>: <span class="built_in">number</span>[][] = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>]</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java 写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] multi = &#123;</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="type">int</span>[][] multi = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-4-TypeScript-元组"><a href="#3-4-TypeScript-元组" class="headerlink" title="3.4 TypeScript 元组"></a>3.4 TypeScript 元组</h2><p>和 Python 的思想一样，允许在一个组内放入不同类型的数据。</p>
<p>一般情况下，<strong><u>元组的长度是确定的、每个元素的类型必须明确指定</u>，因此越界访问、不按定义的类型来赋值都会报错</strong>。</p>
<p>其类型定义的方法和数组不一样：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];    <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>] = [<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="literal">true</span>];    <span class="comment">// 元组</span></span><br></pre></td></tr></table></figure>
<p>有时候不能省略类型定义，特别是只有一个元素的时候，因为可能会被编译器误判为数组：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>];    <span class="comment">// 编译器认为是数组</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">b</span>: [<span class="built_in">number</span>] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p><strong>不过 “元组长度是确定的”，而不是 “固定的”</strong>，是因为有 2 个例外：</p>
<ul>
<li><p>可选类型修饰符 <code>?</code>（<strong>只能位于元组类型列表尾部</strong>）：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>?] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符（又称 REST 运算符），表示不限制数量的同类元素，可以不位于类型列表尾部，在一个类型声明中只能使用一次：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]];    <span class="comment">// 注意，这不是数组。数组请用 ...&lt;T&gt;[][]</span></span><br><span class="line"><span class="keyword">type</span> t2 = [<span class="built_in">string</span>, ...<span class="built_in">boolean</span>[], <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> t3 = [...<span class="built_in">boolean</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果没有使用扩展运算符，那么元组的长度就能确定，<strong>可以使用 <code>length</code> 进行长度推断</strong>：</p>
<p>如果使用了扩展运算符，<code>length</code> 推断就会被看作数组。</p>
<h2 id="3-5-TypeScript-函数"><a href="#3-5-TypeScript-函数" class="headerlink" title="3.5 TypeScript 函数"></a>3.5 TypeScript 函数</h2><h3 id="3-5-1-定义与使用"><a href="#3-5-1-定义与使用" class="headerlink" title="3.5.1 定义与使用"></a>3.5.1 定义与使用</h3><p>定义方法和 JavaScript 一样，但是类型声明是有讲究的。</p>
<p>普通定义方法这么加类型声明：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">txt: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>赋值函数表达式这么加：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">hello</span>: <span class="function">(<span class="params">txt: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> = <span class="keyword">function</span>(<span class="params">txt</span>) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="keyword">var</span> hello = <span class="keyword">function</span>(<span class="params">txt: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>技巧：想要套用其他函数的签名，就用 <code>typeof</code> 运算符，如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">myAdd</span>: <span class="keyword">typeof</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>箭头函数这么加：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = (<span class="attr">txt</span>: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>由于函数也是一个对象，所以我们可以这么自定义函数的类型（在想要给函数加属性的时候有用）：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line">f.<span class="property">version</span> = <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   (参数列表): 返回值</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">add</span>: &#123;</span><br><span class="line">  (<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125; = f;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-2-可选参数-与-默认值"><a href="#3-5-2-可选参数-与-默认值" class="headerlink" title="3.5.2 可选参数 与 默认值"></a>3.5.2 可选参数 与 默认值</h3><p>TypeScript 在静态类型的同时允许参数可选、默认值（它们肯定不能同时使用）：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFunc</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">myFunc = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y === <span class="literal">undefined</span>) &#123;    <span class="comment">// 用到可选参数时请判断</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params">x: <span class="built_in">number</span> = <span class="number">0</span>, y: <span class="built_in">number</span> = <span class="number">0</span></span>): [<span class="built_in">number</span>, <span class="built_in">number</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，传入 <code>undefined</code> 参数就能触发默认值（如果有的话）。</p>
<h3 id="3-5-3-参数解构-解包"><a href="#3-5-3-参数解构-解包" class="headerlink" title="3.5.3 参数解构 (解包)"></a>3.5.3 参数解构 (解包)</h3><p>JavaScript 原生支持参数解构。在 TypeScript 中则需要声明类型才能使用。</p>
<p>要解构的参数大多数情况下，要么是对象，要么是数组 / 元组，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[x, y]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">s</span>(<span class="params">&#123; a, b, c &#125;: &#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; c: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法请类比 “对象类型” 一节的解构赋值，也要注意两类语法的区别。</p>
<h3 id="3-5-4-剩余参数-args"><a href="#3-5-4-剩余参数-args" class="headerlink" title="3.5.4 剩余参数 (args)"></a>3.5.4 剩余参数 (args)</h3><p>使用之前在元组一节提到的 REST 运算符即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rest 参数被包装成数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">joinNumbers</span>(<span class="params">...nums: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest 参数被包装成元组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">...args: [<span class="built_in">boolean</span>, <span class="built_in">number</span>?]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 rest 参数被包装成元组，其中的元素也可以是可选参数。</p>
<h3 id="3-5-5-只读参数"><a href="#3-5-5-只读参数" class="headerlink" title="3.5.5 只读参数"></a>3.5.5 只读参数</h3><p>和 C++ 的 <code>const</code> 修饰参数一模一样。不多赘述：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arraySum</span>(<span class="params">arr: <span class="keyword">readonly</span> <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-6-函数重载"><a href="#3-5-6-函数重载" class="headerlink" title="3.5.6 函数重载"></a>3.5.6 函数重载</h3><p>TypeScript 因为有类型，所以支持了 JavaScript 所不支持的 重载。</p>
<p>使用方法很简单，要注意的点和其他静态类型语言一样（避免签名模糊等问题）。</p>
<p>不过 TypeScript 中，如果能用联合类型避免重载，就用联合类型。</p>
<h2 id="3-6-TypeScript-的类"><a href="#3-6-TypeScript-的类" class="headerlink" title="3.6 TypeScript 的类"></a>3.6 TypeScript 的类</h2><p>TypeScript 作为真正的静态类型语言，和 JavaScript 相比，最大的差异是引入了真正的开发者可定义的类。</p>
<h3 id="3-6-1-定义"><a href="#3-6-1-定义" class="headerlink" title="3.6.1 定义"></a>3.6.1 定义</h3><p>下面的示例概括了 TypeScript 类基本的使用方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">string</span> = <span class="string">&quot;abc&quot;</span>;        <span class="comment">// 允许类内初始化</span></span><br><span class="line">    p!: <span class="built_in">number</span>;                <span class="comment">// ！修饰符告诉编译器该类型不为空，可以不在类内、构造函数内初始化</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">q</span>: <span class="built_in">number</span>;        <span class="comment">// 和 Java 的 const 一样，仅允许初始化一次</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类的构造函数名只能是 construtor，允许可选、默认参数</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">_x: <span class="built_in">number</span>, _y: <span class="built_in">number</span>, _q: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="comment">// 类内的 this 对象就和其他面向对象的静态语言一样含义。具体含义见章末</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = _x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = _y;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">q</span> = _q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类中的方法不需要 function 修饰。但方法一定需要定义在类内</span></span><br><span class="line">    <span class="comment">// 如果要定义在类外，就是在初始化为对象后再进行赋值了</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">a</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类中的构造函数、其他方法都允许重载</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">r</span>: <span class="built_in">number</span>, <span class="attr">s</span>: <span class="built_in">number</span>, ...<span class="attr">args</span>: <span class="built_in">number</span>[]): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="attr">init</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span> + r + s + args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, init);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-2-类的可见性修饰符"><a href="#3-6-2-类的可见性修饰符" class="headerlink" title="3.6.2 类的可见性修饰符"></a>3.6.2 类的可见性修饰符</h3><p>TypeScript 的类更像 C++ 的结构体，<strong>不加可见性修饰符，默认 <code>public</code></strong>。</p>
<p>使用方法同其他面向对象的静态类型语言，略。</p>
<h3 id="3-6-3-类的访问器"><a href="#3-6-3-类的访问器" class="headerlink" title="3.6.3 类的访问器"></a>3.6.3 类的访问器</h3><p>如果你学过 Python，那么恭喜，TypeScript 的访问器 <code>set</code>、<code>get</code> 可以<strong>完全按照</strong> Python 的装饰器 <code>@setter</code>、<code>@getter</code> 理解。</p>
<p>定义方法如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> _name!: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问器前加入 get / set 关键字</span></span><br><span class="line">    <span class="comment">// 访问器的名字必须与要定义的属性名相同</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="title class_">String</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外访问，直接当作普通属性使用，但会调用 get 实时计算</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">test</span>: T = <span class="keyword">new</span> T;</span><br><span class="line">test.<span class="property">name</span> = <span class="string">&quot;Hello&quot;</span>;    <span class="comment">// 调用了 set 访问器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">name</span>);    <span class="comment">// 调用了 get 访问器</span></span><br></pre></td></tr></table></figure>
<p>根据它们的用途，可以很显然地知道：</p>
<ul>
<li><code>get</code> 访问器不能有参数；</li>
<li>如果一个属性不存在 <code>set</code> 访问器，那么这个参数只读，等价于被 <code>readonly</code> 修饰；</li>
</ul>
<h3 id="3-6-4-类的静态成员"><a href="#3-6-4-类的静态成员" class="headerlink" title="3.6.4 类的静态成员"></a>3.6.4 类的静态成员</h3><p>和 Java、C++ 一样，使用 <code>static</code> 关键字修饰静态变量。</p>
<p>但是！和其他语言不太一样，TypeScript 的静态成员（属性和方法）不能由实例调用，只能由类名调用：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">printX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">t</span>: <span class="title class_">MyClass</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>;</span><br><span class="line">t.<span class="title function_">printX</span>();    <span class="comment">// TypeError</span></span><br><span class="line">t.<span class="property">x</span>;        <span class="comment">// TypeError</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">printX</span>();    <span class="comment">// Correct</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">x</span>;            <span class="comment">// Correct</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6-5-类的继承"><a href="#3-6-5-类的继承" class="headerlink" title="3.6.5 类的继承"></a>3.6.5 类的继承</h3><p>和 Java 一样，TypeScript 使用 <code>extend</code> 关键字进行类的继承。</p>
<p>还是和 Java 一样，TypeScript 也有 <code>super</code> 关键字，可以 <strong>用来调用父类构造函数、调用父类中已被重写的方法等等</strong>。</p>
<p>类继承时，不同可见性修饰符下对应数据域的继承原则与 Java、C++ 类似，但是有差别：</p>
<ul>
<li><p>父类 protected 的数据成员，子类 <strong>可以转为 public，但不能转为 private</strong>；</p>
</li>
<li><p>子类可以定义与父类同名不同类型的属性，但是如果希望它们的赋值关联，则需要 <code>declare</code> 关键字修饰；</p>
</li>
</ul>
<h3 id="3-6-6-抽象类"><a href="#3-6-6-抽象类" class="headerlink" title="3.6.6 抽象类"></a>3.6.6 抽象类</h3><p>和 C++ / Java 一样，TypeScript 中的抽象类关键字也是 <code>abstract</code>、也不允许实例化、不允许 <code>private</code> 修饰、抽象成员不允许有实现。</p>
<p>同时，TypeScript 允许使用 <code>abstract</code> 修饰抽象类的<strong>数据成员（Java 和 C++ 做不到）</strong>、成员函数，强制要求子类（非抽象类）实现。</p>
<p>值得注意的是，<strong>一个类最多只能继承于一个抽象类（再多就应该用接口 interface 了）</strong>。</p>
<h3 id="3-6-7-FAQ-类中的-this-在-TypeScript-里究竟是什么"><a href="#3-6-7-FAQ-类中的-this-在-TypeScript-里究竟是什么" class="headerlink" title="3.6.7 FAQ: 类中的 this 在 TypeScript 里究竟是什么"></a>3.6.7 FAQ: 类中的 <code>this</code> 在 TypeScript 里究竟是什么</h3><p>我们知道，在 JavaScript 中，<code>this</code> 含义丰富：</p>
<ul>
<li><p>在方法中，this 表示该方法所属的对象；</p>
</li>
<li><p>如果单独使用，this 表示全局对象；</p>
</li>
<li><p>在函数中，this 表示全局对象（严格模式下为 <code>undefined</code>）；</p>
</li>
</ul>
<p>那么在 TypeScript 的类中，含义就和其他面向对象语言类似，是指 “该方法所在类的当前对象”。</p>
<p>实际上，这里还有几个问题没有解决：</p>
<ol>
<li>在 JavaScript 中允许定义一个原型，充当面向对象编程的工具。它允许将一个对象的方法赋给另一个变量，<strong>赋予后，<code>this</code> 将跟随新的变量脱离原来的作用域</strong>。在 TypeScript 中，这种行为是怎样的？</li>
<li>如果在 JavaScript 的原型中使用闭包/箭头函数，那么在其中的 <code>this</code> 将不再指代当前对象，除非手动传递 <code>this</code> 的值。在 TypeScript 中的行为是怎样的？</li>
</ol>
<p>针对第一个问题，TypeScript 为了防止改变函数语义（本来的 <code>this</code> 是类中对象，如果将函数赋给其他变量后 <code>this</code> 就成为了新变量作用域中的 <code>this</code>），<strong>允许类中方法第一参数声明 <code>this</code> 类型（就像 Python 的 <code>self</code>）</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> tt = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">test</span>(<span class="attr">this</span>: <span class="title class_">Test</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">tt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无论在哪里，只要 typescript 检测到第一个参数是 this，就会自动将当前环境 this 填充进去，并且不会在 JavaScript 中展现出来。</p>
</blockquote>
<p>这样，如果赋给其他变量后，一旦涉及改变了 <code>this</code> 的函数调用，编译器会指出错误：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="title class_">Test</span>.<span class="property">test</span>;</span><br><span class="line"></span><br><span class="line">b.();    <span class="comment">// TypeError, 因为此时的 this 是全局对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>该参数可以省略（但省略后会回到 JavaScript 的行为）。</p>
</blockquote>
<p>当然，你可以在构造函数中，使用 JavaScript 原生方法 <code>bind</code> 将方法与类的 <code>this</code> 环境绑定，这样无论怎么赋值，都是那个对象对应的方法了 —— 这也是最稳妥的做法。</p>
<p>对第二个问题，TypeScript 也需要担心语义问题，因此如果你打开了 <code>noImplicitThis</code> 编译选项，那么 TypeScript 编译器会直接报错。否则其行为和 JavaScript 一致。</p>
<hr>
<p>最后补充一个 TypeScript 的小特性：</p>
<p>TypeScript 中的类能作为类型使用，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="attr">value</span>: <span class="built_in">string</span>): <span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-7-TypeScript-的接口"><a href="#3-7-TypeScript-的接口" class="headerlink" title="3.7 TypeScript 的接口"></a>3.7 TypeScript 的接口</h2><h3 id="3-7-1-定义和使用"><a href="#3-7-1-定义和使用" class="headerlink" title="3.7.1 定义和使用"></a>3.7.1 定义和使用</h3><p>TypeScript 的接口和 Java 非常类似：接口和抽象类一样抽象，<strong>方法全是抽象方法（不能有实现）</strong>、可省略所有的 <code>abstract</code> 关键字。但是属性不是常量属性（只读）而是抽象属性（不允许赋值），因为在 TypeScript 中 <code>abstract</code> 可以修饰数据成员。</p>
<p>如下由于接口算是个抽象类，因此接口间可以继承，和 Java 的接口继承一样，要注意冲突问题。</p>
<p>此外，接口还可以继承于 <code>type</code>（类型别名，它和接口的区别是什么？接下来再讨论）。</p>
<p>甚至接口还能继承于普通的 <code>class</code>。此时 <code>class</code> 中所有的属性、方法全部保持类型，变成对应的抽象属性、抽象方法。<strong>这里我们可以知道，被接口继承的类不能有 <code>private</code>/<code>protected</code> 修饰的成员，因为这样会导致 “无法实现的抽象成员” 的出现</strong>。</p>
<h3 id="3-7-2-接口合并"><a href="#3-7-2-接口合并" class="headerlink" title="3.7.2 接口合并"></a>3.7.2 接口合并</h3><p>这只是个特性，并不希望你为了使用它而使用，只是在必须的时候才使用。因为这样会降低你的代码可读性。</p>
<ul>
<li><p>情况 1：如果你重复定义了接口，那么这两次定义的内容会合并：</p>
<ul>
<li>同名函数 -&gt; 重载，同名属性 -&gt; 联合类型，不同名的直接并列；</li>
<li><strong>如果有不能联合/重载的部分</strong>，编译器会抛出错误；</li>
</ul>
</li>
<li><p>情况 2：如果你对某几个不同名的接口使用了类型联合运算符，如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">s</span>: <span class="title class_">Inter1</span> | <span class="title class_">Inter2</span>;</span><br></pre></td></tr></table></figure>
<p>这就相当于显示将不同名的接口合并为一个接口 <code>s</code>，合并规则和同名接口合并相同；</p>
</li>
</ul>
<h3 id="3-7-3-接口-Interface-和类型别名-type-的异同"><a href="#3-7-3-接口-Interface-和类型别名-type-的异同" class="headerlink" title="3.7.3 接口 (Interface) 和类型别名 (type) 的异同"></a>3.7.3 接口 (Interface) 和类型别名 (type) 的异同</h3><p>相同点：都能创建一个类型、定义方式极其类似。</p>
<p>不同点：</p>
<ul>
<li><code>type</code> 可以定义非对象类型，而 <code>interface</code> 只能定义对象类型；</li>
<li><p><code>interface</code> <strong>可以继承、合并</strong>，而 <code>type</code> 不行，重复定义同名 <code>type</code> 会报错；</p>
</li>
<li><p><code>type</code> 内部不能使用 <code>this</code> 指代当前对象，<code>interface</code> 则可以；</p>
</li>
</ul>
<p>总结：除去一些复杂的类型运算，其他情况优先使用 <code>interface</code>；</p>
<h2 id="3-8-TypeScript-的泛型"><a href="#3-8-TypeScript-的泛型" class="headerlink" title="3.8 TypeScript 的泛型"></a>3.8 TypeScript 的泛型</h2><p>TypeScript 的泛型定义、使用方法与 Java 相同，可以用在类、函数、接口、类型别名、对象上，并且<strong>可以指定默认类型</strong>，如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;<span class="title class_">NumType</span> = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  value!: <span class="title class_">NumType</span>;</span><br><span class="line">  add!: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> <span class="title class_">NumType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"></span><br><span class="line">foo.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">foo.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TypeScript 中，<strong>泛型的另一种常用方式是：作为类型参数的约束条件</strong>。</p>
<p>如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> comp&lt;T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: T) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样约束了 <strong>传入的类型必须是具有 <code>length: number</code> 字段的对象</strong>，减少了代码犯错的概率。</p>
<p>我们可以总结为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">TypeParam</span> <span class="keyword">extends</span> <span class="title class_">ConstraintType</span>&gt;</span><br></pre></td></tr></table></figure>
<p>表示类型参数必须是 <code>ConstraintType</code> 的子类型。</p>
<p>不过为了代码可读性，还是提出以下建议：</p>
<ul>
<li>尽量少用泛型：降低了代码可读性；</li>
<li>泛型的类型参数越少越好；</li>
</ul>
<h2 id="3-9-TypeScript-Enum-类型"><a href="#3-9-TypeScript-Enum-类型" class="headerlink" title="3.9 TypeScript Enum 类型"></a>3.9 TypeScript Enum 类型</h2><h3 id="3-9-1-定义与使用"><a href="#3-9-1-定义与使用" class="headerlink" title="3.9.1 定义与使用"></a>3.9.1 定义与使用</h3><p>和其他大多数静态语言一样，TypeScript 也有枚举类型。它的枚举类型更像 C++ 11 的 <code>enum Class</code>，定义如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title class_">Red</span>,</span><br><span class="line">    <span class="title class_">Green</span>,</span><br><span class="line">    <span class="title class_">Blue</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>值从 0 递增，但值不重要；</li>
<li>是个类型也是值（变量不能和枚举类型同名），因此可以 <code>Color.Red</code> 这样调用，增强代码可读性；</li>
<li>枚举值只读，可以是自身类型（<code>Color</code>）也可以是 <code>number</code>（因此枚举类型做参数时，传入一切 <code>number</code> 都不报错）；</li>
</ul>
<p>通常建议枚举类型前加 <code>const</code> 修饰，这样可以帮助编译器优化代码，提升性能：<code>const enum</code>；</p>
<h3 id="3-9-2-特性"><a href="#3-9-2-特性" class="headerlink" title="3.9.2 特性"></a>3.9.2 特性</h3><ul>
<li><p>同名枚举类型会像同名接口的行为一样合并；</p>
</li>
<li><p>允许字符串做枚举类型的值，要设置，则全员都设置，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">MediaTypes</span> &#123;</span><br><span class="line">    <span class="title class_">JSON</span> = <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="variable constant_">XML</span> = <span class="string">&quot;application/xml&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="title class_">Accept</span>: <span class="title class_">MediaTypes</span>.<span class="property">JSON</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串枚举可以由联合类型代表：<code>function move(where: &quot;Up&quot; | &quot;Down&quot; | &quot;Left&quot; | &quot;Right&quot;);</code></p>
</li>
<li><p>在 C++ 的枚举类型中，有很多人抱怨不方便通过枚举值打印出枚举成员的字符串名。在 TypeScript 中就有方法：<strong>反向映射</strong>，我们调用 <code>EnumClass[n]</code> 就能得到索引为 <code>n</code> 的枚举成员的字符串名。</p>
<blockquote>
<p>这与 TypeScript 编译器将 <code>enum</code> 翻译成 JavaScript 的方式有关：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="title class_">Apple</span>,</span><br><span class="line"> <span class="title class_">Banana</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被编译为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Test</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Test</span>) &#123;</span><br><span class="line"> <span class="comment">// 相当于两句赋值：Test[&quot;Apple&quot;] = 0, Test[0] = &quot;Apple&quot;;</span></span><br><span class="line"> <span class="title class_">Test</span>[<span class="title class_">Test</span>[<span class="string">&quot;Apple&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"> <span class="title class_">Test</span>[<span class="title class_">Test</span>[<span class="string">&quot;Banana&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Test</span> || <span class="title class_">Test</span> = &#123;&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="3-9-3-keyof-关键字与枚举类型"><a href="#3-9-3-keyof-关键字与枚举类型" class="headerlink" title="3.9.3 keyof 关键字与枚举类型"></a>3.9.3 <code>keyof</code> 关键字与枚举类型</h3><p>在 TypeScript 中，<code>keyof</code> 关键字有点类似 Python 的 <code>__dict__</code> 属性，<strong>针对对象 / 类，返回对应类型的所有属性、方法名</strong>，不过 TypeScript 的返回是 “<strong>属性/方法名字符串组成的联合类型</strong>”（就是个字符串枚举类型！），而 Python 返回的是对象数组。</p>
<p>还有一点值得注意，TypeScript 枚举类型想要使用 <code>keyof</code> 获取成员名字符串联合类型，必须加 <code>typeof</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  B = <span class="string">&quot;b&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;A&#x27;|&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="keyword">typeof</span> <span class="title class_">MyEnum</span>;</span><br></pre></td></tr></table></figure>
<p>否则会被编译器当作 <code>number</code> 类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot; |</span></span><br><span class="line"><span class="comment">// &quot;toPrecision&quot; | &quot;valueOf&quot; | &quot;toLocaleString&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="title class_">MyEnum</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-10-TypeScript-的类型断言"><a href="#3-10-TypeScript-的类型断言" class="headerlink" title="3.10 TypeScript 的类型断言"></a>3.10 TypeScript 的类型断言</h2><p>类型断言的存在，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型（而不是改变这个值的类型）。<u>TypeScript 一旦发现存在类型断言，<strong>并且 原类型 兼容 断言的类型</strong>，就不再对该值进行类型推断，而是直接采用断言给出的类型</u>。</p>
<blockquote>
<p>再次强调：<strong>断言的前提是 原类型 兼容 断言的类型</strong>！</p>
</blockquote>
<p>由于 TypeScript 新版本支持了 React 的 JSX 语法，因此如果你要使用 JSX，则不能用旧语法（<code>&lt;assertType&gt;value</code>，这里的尖括号是真的尖括号），应该使用新语法：<code>value as assertType</code>；</p>
<p>那么你可能会问，TypeScript 编译器的类型推断不是已经足够了吗？虽然它增强了语言灵活性，但让人来控制类型推断不会导致出错可能性增加？</p>
<p><strong>确实！它不能乱用，否则会出大问题。</strong></p>
<p>但是只要在适当的场合使用就能发挥它的优势。以下是常用场景：</p>
<h3 id="3-10-1-代替明确的类型缩窄"><a href="#3-10-1-代替明确的类型缩窄" class="headerlink" title="3.10.1 代替明确的类型缩窄"></a>3.10.1 代替明确的类型缩窄</h3><p>早在 3.2.5 节中就提到，对于一些联合类型，我们必须使用类型缩窄，才能使用某个特定类型的方法，以此避免运行时的类型错误，如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>): <span class="built_in">string</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 可能返回 null，也可能返回 string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">test</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="title function_">doSomething</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型缩窄</span></span><br><span class="line"><span class="keyword">if</span> (test !== <span class="literal">null</span>)</span><br><span class="line">    test.<span class="title function_">toUpperCase</span>();</span><br></pre></td></tr></table></figure>
<p>现在，假设 <strong>我们根据代码逻辑，<u>明确知道</u> <code>test</code> 肯定不会为 <code>null</code>，但是编译器不知道</strong>，还以为可能是 <code>null</code>。</p>
<p>这个时候我们可以明确告诉编译器，它不可能为 <code>null</code>，于是这么用就无需使用类型缩窄了：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">test</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="title function_">doSomething</span>();</span><br><span class="line"></span><br><span class="line">(test <span class="keyword">as</span> <span class="built_in">string</span>).<span class="title function_">toUpperCase</span>();</span><br></pre></td></tr></table></figure>
<h3 id="3-10-2-直接量的常量断言"><a href="#3-10-2-直接量的常量断言" class="headerlink" title="3.10.2 直接量的常量断言"></a>3.10.2 直接量的常量断言</h3><h4 id="基本类型直接量"><a href="#基本类型直接量" class="headerlink" title="基本类型直接量"></a>基本类型直接量</h4><p>我们知道，TypeScript 的常量是不能被改变的量，那么常量声明语法 <code>as const</code> 就可以<strong>将基本类型直接量变为对应的值类型</strong>，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;TypeScript&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>这样在编译时，TypeScript 编译器会将 <code>s</code> 看作 <code>&quot;TypeScript&quot;</code> 值类型。这样有什么用呢？<strong>对 直接量 的常量断言，是<u>看作对应的值类型</u></strong>。例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;JavaScript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lang</span> = <span class="string">&quot;JavaScript&quot;</span> | <span class="string">&quot;TypeScript&quot;</span> | <span class="string">&quot;Python&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setLang</span>(<span class="params">language: Lang</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setLang</span>(s); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>这里 <code>Lang</code> 类型是等价于枚举类型，如果传入普通字符串，即便值和枚举量一致，但编译器没法保证类型正确性。</p>
<p>所以我们可以这么做：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;JavaScript&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>这样编译器会将 <code>s</code> 看作 <code>&quot;JavaScript&quot;</code> 值类型，保证以后也不会更改，因此修复了这个问题。当然也与直接用 <code>const</code> 等价：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&quot;JavaScript&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>不过值得注意的是：<strong>常量断言不能用于 已被赋值（定义）的变量！</strong>因为 TypeScript 不允许中途更改变量的读写性质。</p>
<h4 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h4><p>如果将 <code>as const</code> 类型断言修饰对象，那么和修饰基本类型直接量的行为就有些不同了。</p>
<p><u><strong>也就是说，这个时候 <code>const</code> 修饰符和 <code>as const</code> 断言就有区别了！</strong></u></p>
<ul>
<li><code>const</code> 修饰对象直接量时，只是不允许更改对象引用，但其中数据可更改（因为是可变数据类型）；</li>
<li><code>as const</code> 断言对象直接量时，<strong>其中所有数据域 / 成员都改为只读属性</strong>。</li>
</ul>
<p>例如：</p>
<ul>
<li><p>数组 / 元组直接量 -&gt; <u><strong>只读元组</strong></u>（同时确定了长度、类型 和值）；</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a1 的类型推断为 number[]</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a2 的类型推断为 readonly [1, 2, 3] （元组）</span></span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象直接量 -&gt; 数据域全部只读；</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: number; y: number; &#125;，普通对象常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: 1; y: number; &#125;，数据域直接量常量断言 的 对象常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v3 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 类型是 &#123; readonly x: 1; readonly y: 2; &#125;，常量断言 的 对象常量</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>那么这样做有什么用？举个例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">nums</span>: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">add</span>(...nums);        <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>如果我想<strong>将已知长度的数组解构传给函数</strong>，但 <code>const</code> 修饰，甚至是 <code>readonly</code> 修饰，也并不能说明这是个定长度为 2、定内容的数组，只能说明这个数组对象引用不会变，所以编译器认为不行。</p>
<p>这个时候使用 <code>as const</code> 断言就能提示编译器这个数组是<strong>只读元组</strong>，并且长度为 2，每个位置上的类型都是值类型，能作为参数传递而不出问题。</p>
<h3 id="3-10-3-非空断言"><a href="#3-10-3-非空断言" class="headerlink" title="3.10.3 非空断言"></a>3.10.3 非空断言</h3><p>和 “明确缩窄类型” 的作用很像，但非空断言只针对 “空类型的类型缩窄”。就是根据代码逻辑，明确知道某些对象的类型不可能为 <code>null / undefined</code>，<strong>在节省不必要的判断的同时，让编译器不报错</strong>。</p>
<p>但请注意！<strong>一定要确定 “肯定非空” 的逻辑！</strong>否则会出现运行时问题。</p>
<p><strong>如果不能确保，就请通过手动检查来缩窄类型！</strong></p>
<p>使用非空断言的语法就是前面提到的：尾缀非空断言运算符 <code>!</code>；</p>
<p>举个例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)!;</span><br></pre></td></tr></table></figure>
<p>表示 <code>document</code> 中肯定有 ID 为 <code>root</code> 的元素，不用考虑空的情况了。</p>
<p>还有种场景是在之前提到过的，如果类中有些属性要在类外、构造函数外初始化，需要给该属性加非空断言，不然编译器认为没有初始化实例属性（如果你的属性定义没有 <code>null</code> 类型的话）而报错：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>; <span class="comment">// TypeError</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Empty</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x!: <span class="built_in">number</span>; <span class="comment">// Correct</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Empty</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-4-类型断言函数"><a href="#3-10-4-类型断言函数" class="headerlink" title="3.10.4 类型断言函数"></a>3.10.4 类型断言函数</h3><p>一类函数，如果它的作用是：“保证参数符合某种类型，不符合就抛出错误，符合就什么都不做”，那么就将这类函数称为 “类型断言函数”。</p>
<p>由于断言函数要么不返回（<code>void</code>），要么抛出错误（<code>never</code>），因此为了断言函数的语义清晰性，TypeScript 3.7 引入了断言函数声明写法，以判断字符串类型为例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value: <span class="built_in">unknown</span></span>): asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;string&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Not a string&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样如果断言函数返回结果（不符合断言函数标准的行为），也会报错。</p>
<p>如果是判断真值（不为 <code>false</code>、<code>undefined</code>、<code>null</code>）的话，断言函数还能更简单地书写：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">condition: <span class="built_in">unknown</span>, message: <span class="built_in">string</span></span>): asserts condition &#123;</span><br><span class="line">    <span class="keyword">if</span> (!condition) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样这个函数就和 Python 的 <code>assert</code> 关键字行为类似了。</p>
<hr>
<p>补充：TypeScript 的 <code>is</code> 关键字</p>
<p>TypeScript 中，<code>is</code> 除了充当类型断言函数的尾缀关系，还能作为<strong>类型判断函数（用于判断参数类型，返回值一定为 <code>boolean</code> 类型）</strong>的尾缀关系，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">pet: Fish | Bird</span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但 <code>is</code> 关键字也<strong>仅限于</strong>这两类判断函数的尾缀，以此更清晰地表示这类函数的逻辑。</p>
<h1 id="Chapter-4-TypeScript-模块与命名空间"><a href="#Chapter-4-TypeScript-模块与命名空间" class="headerlink" title="Chapter 4. TypeScript 模块与命名空间"></a>Chapter 4. TypeScript 模块与命名空间</h1><h2 id="4-1-模块"><a href="#4-1-模块" class="headerlink" title="4.1 模块"></a>4.1 模块</h2><h3 id="4-1-1-定义"><a href="#4-1-1-定义" class="headerlink" title="4.1.1 定义"></a>4.1.1 定义</h3><p>TypeScript 文件有 2 类：</p>
<ul>
<li>一种是全局的脚本文件。<strong>类似 <code>shell</code> 脚本，其中的变量、函数等等内容可以直接被其他接下来调用的所有文件访问到</strong>；</li>
<li>另一种是 TypeScript 模块。模块内部的变量、函数、类只在内部可见，对于模块外部是不可见的，这就相当于 C++ 这类语言的普通文件。</li>
</ul>
<p>Q: 这两种文件如何区分？</p>
<p>A: <strong>任何包含 import 或 export 语句的文件，就是一个模块（module）。相应地，如果文件不包含 export 语句，就是一个全局的脚本文件。</strong></p>
<p>Q: 既然模块对外部具有封装性，那么它们间如何相互调用？</p>
<p>A: 答案很简单，模块暴露给外部的接口，必须用 <code>export</code> 命令声明；如果其他文件要使用模块的接口，必须用 <code>import</code> 命令来输入。</p>
<h3 id="4-1-2-特性"><a href="#4-1-2-特性" class="headerlink" title="4.1.2 特性"></a>4.1.2 特性</h3><ul>
<li><code>export &#123;&#125;;</code> 语句不会进行任何操作，但是这个文件的内部变量对外不再可见；</li>
<li>TypeScript 允许导入导出 <code>type</code>（类型别名），需要 <code>export type &lt;typename&gt;</code>；</li>
<li>TypeScript 也允许 <strong>默认导出、命名导出</strong>，用法和 JavaScript 类似；<ul>
<li><strong>但是导入类型别名时，需要加 <code>type</code> 关键字前缀</strong>；</li>
<li>导入接口、类时，和 JavaScript 普通对象的导入方法相同；</li>
</ul>
</li>
</ul>
<h3 id="4-1-3-CommonJS-模块支持"><a href="#4-1-3-CommonJS-模块支持" class="headerlink" title="4.1.3 CommonJS 模块支持"></a>4.1.3 CommonJS 模块支持</h3><p>众所周知，NodeJS 有专门的模块格式，与 ECMAScript 原生脚本不兼容。但是 TypeScript 兼容了 CommonJS 模块的导入：</p>
<ul>
<li><code>import &lt;name&gt; = require(&quot;&lt;moduleName&gt;&quot;);</code></li>
<li><code>export = &lt;exportObj&gt;</code>；</li>
</ul>
<h3 id="4-1-4-编译时模块定位-Module-Resolution"><a href="#4-1-4-编译时模块定位-Module-Resolution" class="headerlink" title="4.1.4 编译时模块定位 (Module Resolution)"></a>4.1.4 编译时模块定位 (Module Resolution)</h3><p>几乎所有要编译的语言，其源文件的编译都要考虑一个问题：如何组织模块间相互位置关系、如何找模块 / 库的位置。</p>
<p>C++ 中，要么你把源文件全部放在固定目录中，然后用相对路径手动引用。<strong>缺点是一改文件位置就要重写，非常麻烦</strong>；另一种方法是 使用 CMake/Makefile 之类的项目管理工具指定编译操作的过程。</p>
<p>在 TypeScript 中，也有两种方法。</p>
<h4 id="引用时手动指定模块路径"><a href="#引用时手动指定模块路径" class="headerlink" title="引用时手动指定模块路径"></a>引用时手动指定模块路径</h4><p>我们在引用模块时可能会这么写：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TypeA</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;    <span class="comment">// 省略后缀名，则可查找 *.ts / *.d.ts / *.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;/mod&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>前两种利用相对路径指定模块位置的方法是 <strong>相对模块表示法</strong>；</p>
<p>后两种不带有路径信息地指定模块地方法是 <strong>非相对模块表示法</strong>。</p>
<p>那么 TypeScript 如何查找以上手动指定的模块？由于 NodeJS 引入的 CommonJS 模块，因此有两种查找方式：一种称为 Classic 方法，另一种称为 Node 方法。可以使用编译参数 <code>moduleResolution</code>，指定使用哪一种方法。</p>
<p>对于 Classic 方法（原生 JavaScript、TypeScript 默认的方法），步骤就非常简单：</p>
<ul>
<li><p>对于相对模块表示法，<strong>按照当前模块的位置为基准路径计算相对路径</strong>；</p>
<blockquote>
<p>例如 <code>import &#123; t &#125; from &quot;../t&quot;</code> 就从当前脚本，找上个目录里的 <code>t.ts</code>；</p>
</blockquote>
</li>
<li><p>对于非相对模块表示法，<strong>会以当前模块位置为起点，层层向上查找目录</strong>；</p>
</li>
</ul>
<p>对于 Node 方法就有些复杂：</p>
<ul>
<li>对于相对模块表示法，例如 <code>let x = require(&quot;./b&quot;)</code>，会进行以下查找步骤：<ol>
<li>找当前目录的 <code>b.ts</code>、<code>b.tsx</code>、<code>b.d.ts</code>；</li>
<li>找当前目录的子目录是否有 <code>package.json</code>，这个文件中有无 <code>types</code> 字段，如果有则递归查找；</li>
<li>找当前目录的 名为 <code>b</code> 的子目录是否包括 <code>index.ts/.tsx/.d.ts</code>；</li>
</ol>
</li>
<li>对于非相对模块表示法，例如 <code>let x = require(&quot;b&quot;)</code>，会进行以下查找步骤：<ol>
<li>子目录 <code>node_modules</code> 是否包含 <code>b.ts/.tsx/.d.ts</code>；</li>
<li>子目录 <code>node_modules</code> 中是否存在 <code>package.json</code>，是否有 <code>types</code> 字段，如果有则递归查找；</li>
<li>子目录 <code>node_modules</code> 中是否存在子目录 <code>@types</code>，如有，则查找其中的 <code>b.d.ts</code>；</li>
<li>子目录 <code>node_modules</code> 中是否存在子目录 <code>b</code>，其中是否包括  <code>index.ts/.tsx/.d.ts</code>；</li>
<li>进入上层目录，充分上述步骤，直至找到。</li>
</ol>
</li>
</ul>
<h4 id="tsconfig-json-配置模块路径"><a href="#tsconfig-json-配置模块路径" class="headerlink" title="tsconfig.json 配置模块路径"></a><code>tsconfig.json</code> 配置模块路径</h4><p>TypeScript 允许开发者在<code>tsconfig.json</code>文件里面，手动指定脚本模块的路径，这样做在一些大型的、依赖关系复杂的项目中就比较方便。</p>
<p>有如下配置字段可以设置编译器的查找过程：</p>
<ul>
<li><p><code>compilerOptions.baseUrl</code>：指定脚本模块的基准目录（<u>该项目的所有源文件的基准位置都被设置在此</u>）。例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>表示将 <code>tsconfig.json</code> 所在的目录为基准目录；</p>
</li>
<li><p><code>compilerOptions.paths</code>：<strong>指定<u>非相对路径表示法的模块与实际路径的映射</u></strong>。例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;jquery&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;node_modules/jquery/dist/jquery&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上例的 <code>jquery</code> 属性的值是一个数组，可以指定多个路径。如果第一个脚本路径不存在，那么就加载第二个路径，以此类推。</p>
</li>
<li><p><code>compilerOptions.rootDirs</code>：<strong>指定无论查找什么模块，必须要额外查找的其他目录</strong>。例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rootDirs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/zh&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/de&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/#&#123;locale&#125;&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>此外，如果你发现自己指定了一些路径，编译器就是找不到。那么你可以使用 <code>--traceResolution</code> 编译器选项，让编译器在命令行中打印搜索的路径，相当于一种调试。</p>
<h2 id="4-2-命名空间"><a href="#4-2-命名空间" class="headerlink" title="4.2 命名空间"></a>4.2 命名空间</h2><p>评价是和 C++ 的 <code>namespace</code> 很类似。使用也很像：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  <span class="title function_">isString</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Utils</span>.<span class="title function_">isString</span>(<span class="string">&quot;no&quot;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>哪怕在一个文件中，也必须 <code>export</code> 才能被外部使用：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="title class_">Utility</span>.<span class="title function_">log</span>(<span class="string">&quot;Call me&quot;</span>);</span><br><span class="line"><span class="title class_">Utility</span>.<span class="title function_">error</span>(<span class="string">&quot;maybe!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>命名空间本身能被 <code>export</code>、也允许合并（行为类似 interface）；</p>
<h1 id="Chapter-5-TypeScript-装饰器"><a href="#Chapter-5-TypeScript-装饰器" class="headerlink" title="Chapter 5. TypeScript 装饰器"></a>Chapter 5. TypeScript 装饰器</h1><blockquote>
<p>TypeScript 曾有旧式语法，这里不再作介绍。本章只介绍 TypeScript 5.0 以后的新式装饰器。</p>
<p>如果你想使用旧式语法，请向编译器传递 <code>--experimentalDecorators</code> 参数。</p>
</blockquote>
<h2 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h2><p>TypeScript 的装饰器的定义 和 Python 的装饰器的定义一致，和 Java 的装饰器类似。或者说，“装饰器” 的概念是跨语言的、抽象概念。主要内容是：</p>
<ul>
<li>前缀是 <code>@</code>，后面必须是一种特殊表达式。这个表达式要求：<strong>要么就是个函数名，要么表达式执行后返回一个函数</strong>；</li>
<li>这个通过后面表达式所得到的函数称为<u><strong>装饰器函数</strong></u>。装饰器函数可以接受所修饰对象的一些相关值作为参数，<strong>并且要么不返回值（装饰过程），要么返回新对象用来替换原来的目标对象（装饰对象）</strong>。</li>
</ul>
<p>装饰器的作用是，<u><strong>通过类似 “外部注入” 的方式，改变被装饰对象的行为</strong></u>。</p>
<p>比如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样使用类 <code>A</code> 的时候，其行为就会被装饰器 <code>Injectable</code> 所改变。</p>
<h2 id="5-2-源码定义"><a href="#5-2-源码定义" class="headerlink" title="5.2 源码定义"></a>5.2 源码定义</h2><p>我们从概念中可知，要了解 TypeScript 装饰器怎么用、机制是什么，最主要看装饰器函数。它在 TypeScript 中的定义如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Decorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="built_in">string</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer?(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      get?(): <span class="built_in">unknown</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">      set?(value: <span class="built_in">unknown</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span> | <span class="title class_">ReplacementValue</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Decorator</code> 是一个函数类型，它接收两个参数：</p>
<ul>
<li><p><code>value</code>：<strong>所装饰的对象</strong>，在使用 <code>@Decorator</code> 时，相当于语法糖，<strong>自动将修饰对象传递到此参数</strong>；</p>
</li>
<li><p><code>context</code>：上下文对象，看起来有很多内容，实际上是为了适应多种装饰器的类别而定义的（很多可选参数，只需要记住几种常用的装饰器类别就行）；</p>
<blockquote>
<p>在 TypeScript 中，定义了一个原生接口 <code>ClassXXXDecoratorContext</code>，描述的就是 <code>typeof Decorator.context</code>；</p>
</blockquote>
<ul>
<li><code>kind</code>：装饰器类别，<strong>只有 6 种，分别对应了 6 种装饰器</strong>：<code>&quot;class&quot;</code>（类装饰器）、<code>&quot;method&quot;</code>（方法装饰器）、<code>&quot;getter&quot;</code>（读装饰器）、<code>&quot;setter&quot;</code>（写装饰器）、<code>&quot;field&quot;</code>（属性装饰器）、<code>&quot;accessor&quot;</code>（访问装饰器）；</li>
<li><code>name</code>：所装饰对象的名称（例如类名、函数名、属性名等等）；</li>
<li><code>addInitializer()</code>：<strong>添加被修饰对象初始化后的逻辑</strong>；</li>
<li><code>private</code>：<strong>所装饰对象是不是一个类的私有成员</strong>；</li>
<li><code>static</code>：<strong>所装饰对象是不是一个类的静态成员</strong>；</li>
<li><code>access</code>：<strong>包含所修饰对象的访问器 <code>get</code> 和 <code>set</code></strong>；</li>
</ul>
</li>
</ul>
<h3 id="5-2-1-类装饰器"><a href="#5-2-1-类装饰器" class="headerlink" title="5.2.1 类装饰器"></a>5.2.1 类装饰器</h3><p>类装饰器是 <code>context.kind</code> 字段为 <code>&quot;class&quot;</code> 的装饰器，<strong>用来装饰 TypeScript 类</strong>。</p>
<p><u><strong>它只需定义装饰器 <code>context</code> 可选成员的 <code>addInitializer()</code></strong></u>，用在类上就是 <strong>类完全定义后、构造函数前执行的 <code>initializer</code> 函数</strong>。</p>
<p>如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;class&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
<p>常见的使用场景有：</p>
<ol>
<li><p>向类中添加一个外部方法；</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&quot;class&quot;</span>) &#123;</span><br><span class="line">        value.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Greeter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">u.<span class="title function_">greet</span>();    <span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>
<p><strong>作用原理是，向传入其中的类调用 <code>prototype</code> 获取类的原型，添加方法 <code>greet</code></strong>；</p>
</li>
<li><p>替换被修饰类的构造函数（例如添加一些 side effects）/ 直接替换被修饰的类；</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params">value: <span class="built_in">any</span>, context: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> wrapper = <span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    instanceCount++;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">value</span>(...args);</span><br><span class="line">    instance.<span class="property">count</span> = instanceCount;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">MyClass</span>;</span><br><span class="line"></span><br><span class="line">  wrapper.<span class="property"><span class="keyword">prototype</span></span> = value.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// A</span></span><br><span class="line">  <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@countInstances</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">inst1 <span class="keyword">instanceof</span> <span class="title class_">MyClass</span>; <span class="comment">// true</span></span><br><span class="line">inst1.<span class="property">count</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>解释一下，因为 JavaScript 和 TypeScript 中的类型 <code>class</code>，只要<strong>是个构造函数就能用 <code>class</code> 声明</strong>。借助这个特性，我们能更换被修饰类的构造函数。</p>
<p>在装饰器内定义一个闭包（新的构造函数，<code>new</code> 调用了原来构造函数），最后将函数的 <code>prototype</code> 属性统一，再返回就是新的构造函数了。</p>
<p>这个时候，返回的构造函数就替换了原来的构造函数（也就是替换了类）。按这种思想，<strong>如果你不想用 <code>prototype</code> 这种原生 JavaScript 的内容，你还可以直接返回一个临时子类，来实现同样效果</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params">value: <span class="built_in">any</span>, context: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> value &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(...args);</span><br><span class="line">      instanceCount++;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = instanceCount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改被修饰类的创建行为（修改 <code>new</code> 的行为）；</p>
<p>我们注意到，JavaScript 的构造函数中，有 <code>new</code> 对象可供使用，<code>new.target</code> 表示使用 <code>new</code> 调用这个构造函数的目标对象。我们可以借此控制 <code>new</code> 的行为，例如禁止 <code>new</code> 新建实例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionCallable</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value <span class="keyword">as</span> <span class="built_in">any</span>, &#123;kind&#125; <span class="keyword">as</span> <span class="built_in">any</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&#x27;class&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;This function can’t be new-invoked&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">value</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@functionCallable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> robin = <span class="title class_">Person</span>(<span class="string">&#x27;Robin&#x27;</span>);</span><br><span class="line">robin.<span class="property">name</span> <span class="comment">// &#x27;Robin&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在类的定义后、类实例初始化前追加行为；</p>
<p>这里就需要使用到装饰器 <code>addInitializer</code>，<strong>这个函数将在 类的定义结束后（不是实例的定义结束后！） 执行</strong>，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addInitializeWrapper</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params">value: <span class="built_in">any</span>, context: ClassDecoratorContext</span>) &#123;</span><br><span class="line">        context.<span class="title function_">addInitializer</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addInitializeWrapper</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="keyword">var</span> t2 = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br></pre></td></tr></table></figure>
<p>会在 <code>Test</code> 定义结束后打印一次 <code>Hello</code>；</p>
</li>
</ol>
<h3 id="5-2-2-方法装饰器"><a href="#5-2-2-方法装饰器" class="headerlink" title="5.2.2 方法装饰器"></a>5.2.2 方法装饰器</h3><p>方法装饰器是 <code>context.kind</code> 字段为 <code>&quot;method&quot;</code> 的装饰器，用来装饰 TypeScript 类中的方法。</p>
<p>需要指定 <code>static</code>（该方法是否在类中为静态方法）、<code>private</code>（该方法是否在类中为私有方法）、<code>access.get</code>（该方法的读访问器）、<code>addInitializer</code>（该方法定义后的初始化逻辑），如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassMethodDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;method&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
<p>常见使用场景有：</p>
<ol>
<li><p>直接替换被修饰的方法；</p>
<p>这种使用方法很简单，就是装饰器函数返回一个新的函数/方法就行，这就算替换了原来的方法，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceWithHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">n: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@replaceWithHello</span></span><br><span class="line">    <span class="title function_">echoName</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给被修饰的方法添加额外逻辑（例如打印日志、延时执行、计时、绑定 <code>this</code> 环境等等）；</p>
<p>这里就举这 3 个例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给被装饰方法添加日志</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addLog</span>(<span class="params">originMethod: <span class="built_in">Function</span>, context: ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> methodName = <span class="title class_">String</span>(context.<span class="property">name</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DEBUG] Entering method: <span class="subst">$&#123;methodName&#125;</span>`</span>);</span><br><span class="line">        <span class="comment">// 在原有作用域 this 下执行</span></span><br><span class="line">        <span class="keyword">const</span> result = originMethod.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DEBUG] Exiting method: <span class="subst">$&#123;methodName&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给被装饰方法延迟执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">millisecond: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 无论在哪里，只要 typescript 检测到第一个参数是 this，就会自动将当前环境 this 填充进去，不在 JavaScript 中展现出来。</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, value: <span class="built_in">Function</span>, context: ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&#x27;method&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 和 call 一样，在指定作用域下执行</span></span><br><span class="line">                    value.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">                &#125;, millisecond);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给被装饰方法自动绑定 this 环境，可以解决 “实例方法被赋给其他变量后语义改变 / 报错” 的问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">boundThis</span>(<span class="params">value: <span class="built_in">Function</span>, context: ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> methodName = context.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">private</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`不能绑定私有方法 <span class="subst">$&#123;methodName <span class="keyword">as</span> <span class="built_in">string</span>&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context.<span class="title function_">addInitializer</span>(<span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[methodName] = <span class="variable language_">this</span>[methodName].<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5-2-3-属性装饰器"><a href="#5-2-3-属性装饰器" class="headerlink" title="5.2.3 属性装饰器"></a>5.2.3 属性装饰器</h3><p>属性装饰器是 <code>context.kind</code> 字段为 <code>&quot;field&quot;</code> 的装饰器，用来装饰定义在类中的属性。</p>
<p>它需要指定 <code>static</code>、<code>private</code>、<code>addInitializer</code>、<code>access.get</code> 和 <code>access.set</code>（比方法装饰器多了写访问器）；</p>
<p>另外它还有一个与其他装饰器不同点是，它要么不返回值，要么返回一个函数，该函数会自动执行，用来对所装饰属性进行初始化。该函数的参数是所装饰属性的初始值，该函数的返回值是该属性的最终值。</p>
<p>所以，这下你能明白属性装饰器的作用了吗？在初始化该属性时会触发一次属性装饰器。定义如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassFieldDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;field&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span>; set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="function">(<span class="params">initialValue: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">unknown</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
<p>我们还注意到，<code>value</code> 是 <code>undefined</code> 类型，这意味着 <strong>属性装饰器不会自动将属性传给内部（因为没有必要，考虑赋给该属性的值 <code>initialValue</code> 即可）</strong>。</p>
<p>常见的使用场景和类的访问器类似，不再赘述，只是介绍一个样例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logged</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; kind, name &#125; = context;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&quot;field&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">initialValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DEBUG] initializing <span class="subst">$&#123;name&#125;</span> with value <span class="subst">$&#123;initialValue&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> initialValue;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="meta">@logged</span> name = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line"><span class="comment">// &quot;[DEBUG] initializing name with value green&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-4-getter-装饰器、setter-装饰器"><a href="#5-2-4-getter-装饰器、setter-装饰器" class="headerlink" title="5.2.4 getter 装饰器、setter 装饰器"></a>5.2.4 getter 装饰器、setter 装饰器</h3><p>它们是 <code>context.kind</code> 字段为 <code>&quot;getter&quot;/&quot;setter&quot;</code> 的装饰器，是<strong>专门用来装饰类访问器</strong>的装饰器。</p>
<p>描述如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassGetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;getter&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ClassSetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;setter&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
<p>这两个装饰器要么不返回值，要么返回一个函数，取代原来的取值器或存值器。</p>
<p>为什么要对访问器进行装饰？比如懒加载的特性：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@lazy</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Time Consuming Result&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lazy</span>(<span class="params">value: <span class="built_in">any</span>, &#123; kind, name &#125;: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&quot;getter&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = value.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, name, &#123;</span><br><span class="line">        <span class="attr">value</span>: result,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">inst.<span class="property">value</span>;</span><br><span class="line"><span class="comment">// Calculating...</span></span><br><span class="line"><span class="comment">// &#x27;Time Consuming Result&#x27;</span></span><br><span class="line">inst.<span class="property">value</span>;</span><br><span class="line"><span class="comment">// &#x27;Time Consuming Result&#x27;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>还有一个 <code>accessor</code> 装饰器不常用，在这里不再赘述，有兴趣请查看官方文档。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SSRVodka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/technical/typescript-basic/">https://blog.sjtuxhw.top/technical/typescript-basic/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SSRVodka's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Web/">Web</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/TypeScript/">TypeScript</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/typescript.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/review/csapp-mm-cache/" title="CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-mh.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CSAPP Notes: Memory Hierarchy & Cache & Opt</div></div><div class="info-2"><div class="info-item-1">Chapter 10. The Memory Hierarchy 本章将介绍系统的内存分层架构。  之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。 正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。 10.1 Storage Technologies &amp; Trends在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。 10.1.1 Random-Access Memory (RAM)当前大多数人所熟知的 “内存” 的一部分就是随机访问存储器（RAM），它具有以下的特征：  RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；  RAM 常常被打包放在 CPU 芯片中；  RAM 中每一个基本的存储单元被称为 单元胞（Cell），一个单元胞中存放 1 bit 数据；  很多个 RAM 芯片共同工作，组成了计算机的...</div></div></div></a><a class="pagination-related" href="/technical/react-quick-start/" title="React框架速通"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/react.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">React框架速通</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference:  MDN Doc &amp;&amp; React Doc 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 0. 5 分钟速通 React 框架 如果你只有 5 分钟时间，则只需阅读这一章；否则请从 Chapter 1 开始。 建议有一定的原生 JavaScript 基础，至少包括：JS 基本类型、内置引用类型、函数表达式的各种操作，简单 DOM 操作，JavaScript 事件，JavaScript 异步（Promise）。  0.1 基本概念 React 应用程序是由 组件 组成的。  一个组件是 UI 的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。   React 组件是返回标签的 JavaScript 函数。 12345function MyButton() &#123;    return (        &lt;button&gt;I&#x27;m a button&lt;/button&gt;    );&#125;; React...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/technical/js-basic-2/" title="JavaScript入门笔记-(2)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/javascript2.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-25</div><div class="info-item-2">JavaScript入门笔记-(2)</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference: 《Professional JavaScript for Web Developers》 3rd Edition 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 7. 简单使用 DOM假设你学习了初级数据结构，那么把 HTML 页面想象成一个以元素为结点的一般树。JavaScript DOM 操作就是操作这个文档树，达到改变前端页面的目的。 在浏览器运行的 JavaScript 引擎中，全局运行环境中会自动设置一个变量 document（DOM 对象），操作它就是在动态操作 HTML 页面。 7.1 基本操作 假设你学习了 CSS 的基础用法。   document.querySelector(&lt;selectorStr&gt;)：JavaScript DOM 中的重要方法，document 对象的 按选择器查找 HTML 中的元素（CSS 中有效的所有选择器，除了伪类选择器都行）；  如果有多个符合选择器的对象，那么只会返回一个。想要返回全部，请使用...</div></div></div></a><a class="pagination-related" href="/technical/js-basic/" title="JavaScript入门笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/javascript.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-20</div><div class="info-item-2">JavaScript入门笔记</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference: 《Professional JavaScript for Web Developers》 3rd Edition 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 0. JavaScript 起源0.1 历史 Web 流行早期（上世纪末），Internet 用户上网速度 28.8 KB/s，但网页的大小和复杂性却不断增加。为完成简单的表单验证而频繁地与服务器交换数据只会加重用户的负担。于是，为了开发一种客户端语言，仅用来处理表单的简单验证工作，Netscape 公司在其发布的应用 Netscape Navigator 2 上加入一种脚本语言 LiveScript，认为是 JavaScript 的前身之一；  1995 年 2 月，Netscape 与 Sun 合作，为了搭上媒体热炒 Java 的顺风车，临时把 LiveScript 改名为 JavaScript，这就是 JavaScript 1.0；  其后不久，微软在自家作品 IE 3 中加入 JScript（是...</div></div></div></a><a class="pagination-related" href="/technical/react-quick-start/" title="React框架速通"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/react.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-27</div><div class="info-item-2">React框架速通</div></div><div class="info-2"><div class="info-item-1">Written by SJTU-XHW Reference:  MDN Doc &amp;&amp; React Doc 本人学识有限，笔记难免有错，恳请读者能够批评指正，本人将不胜感激！   Chapter 0. 5 分钟速通 React 框架 如果你只有 5 分钟时间，则只需阅读这一章；否则请从 Chapter 1 开始。 建议有一定的原生 JavaScript 基础，至少包括：JS 基本类型、内置引用类型、函数表达式的各种操作，简单 DOM 操作，JavaScript 事件，JavaScript 异步（Promise）。  0.1 基本概念 React 应用程序是由 组件 组成的。  一个组件是 UI 的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。   React 组件是返回标签的 JavaScript 函数。 12345function MyButton() &#123;    return (        &lt;button&gt;I&#x27;m a button&lt;/button&gt;    );&#125;; React...</div></div></div></a><a class="pagination-related" href="/technical/rabbit-mq/" title="Introduction to Rabbit MQ"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/rabbit.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-01</div><div class="info-item-2">Introduction to Rabbit MQ</div></div><div class="info-2"><div class="info-item-1">Chapter 0. 背景0.1 同步消息和异步消息微服务架构下存在很多服务间相互调用的情况。 我们知道可以通过 OpenFeign 的方式来获取远程服务的响应，但是 OpenFeign 的远程调用是同步的，其优点是同步调用时效强，等待结果返回。但同时会导致：  代码可扩展性差。 性能堪忧。相较于相同项目实现的单体架构，同步的微服务调用方式会多出网络等待时间。  于是我们需要异步调用的方式，这里使用到了发布-订阅者模式。 异步调用的优势是，  模块间进一步解耦（发布者和订阅者间无需知道相互之间的信息）； 可拓展性强（scalable），添加实例无需更改代码； 异步性能有明显提升； 故障隔离（最终一致性保证）； 缓存消息，实现流量削峰填谷；  但是缺点也很明显：  异步实现无法立即得到结果，时效性差，可能导致数据不一致性； 不作额外措施，则不能保证最终一致性（下游业务是否成功）。所以业务安全依赖于 broker 的可靠性；  0.2 Message Queue...</div></div></div></a><a class="pagination-related" href="/technical/redis-starter/" title="Redis 入门：从实践到理论"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/redis.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-12</div><div class="info-item-2">Redis 入门：从实践到理论</div></div><div class="info-2"><div class="info-item-1">Chapter 1. 基本概念和 CLI 使用1.1 NoSQL用于存储非结构化数据，不保证 ACID 事务特性（仅有最终一致性 Weak Consistency Model）。 Redis（Remote Dictionary Server）就是一类基于内存的键值型 NoSQL，不保证数据一致性，但可以保证性能。  一种 KVStore System，可以方便的存放非结构化数据，这对于缓存各异性数据非常有帮助；  Handle 网络请求多线程。处理指令单线程，单个指令具有原子性；  低延迟，利用 I/O Multiplexing 在单线程中处理多个请求； 支持数据持久化； 支持主从集群（从备份，读写分离）和分片集群（数据拆分，存储上限提高）；  1.2 Redis Data StructureRedis Key 一般使用 String，Value 支持：  基本类型：String、Hash、List、Set、SortedSet； 特殊类型：GEO（地理位置信息格式）、BitMap（位图）、HyperLog；  1.3 Basic Redis CLI Commands1.3.1...</div></div></div></a><a class="pagination-related" href="/technical/xss/" title="XSS 是什么？"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/xss.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-04</div><div class="info-item-2">XSS 是什么？</div></div><div class="info-2"><div class="info-item-1">最近一个同学和我讨论一个问题，说到了 XSS 跨站攻击，我恰好对这块不是很熟，于是整理一下相关的资料，希望在编写互联网应用的时候多加注意。 同时，笔者会讨论具体的防护措施，希望大家都不会受到此类攻击的困扰。注意，下文涉及的技术细节仅供学习之用。 OverviewCross Site Scripting (XSS) attacks 是一类代码注入攻击。攻击者利用了互联网应用的安全漏洞将恶意代码（通常是浏览器端脚本）插入正常可信的网站，甚至篡改网页内容。由于其他终端用户的浏览器认为脚本来自可信网站，因此直接执行，最终所有 cookies/session tokens 或其他敏感信息悉数被窃取，从而达到攻击其他终端用户（其他访问者）的目的。 而让这些攻击成为可能的 “安全漏洞”，或者说缺陷，在互联网应用中广泛存在，尤其是对前端接受用户输入的部分不做检查和编码的情况下。 MechanismsXSS 的攻击方式是怎样的？通常它有以下两个步骤：  数据通过不受信任的来源（最常见的是 Web 请求）进入 Web 应用程序； 可能存在恶意代码的数据包含在动态内容中发送给 Web...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="xhw-card-content"><div class="xhw-avatar-group"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="xhw-sticker"><img class="sticker-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/smile.avif" alt="emoji-sticker"/></div></div></div><div class="author-info-name">SSRVodka</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">78</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span><a class="service-status-badge" id="serviceStatusBadge" href="https://status.sjtuxhw.top" rel="external nofollow noreferrer" target="_blank"><span class="status-loading"></span><span class="status-text">loading...</span></a></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-%E4%B8%8E-JS-%E6%AF%94%E8%BE%83%EF%BC%9A%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E-%E4%B8%8E-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">Chapter 1. 与 JS 比较：类型声明 与 作用域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-TypeScript-%E7%BC%96%E8%AF%91"><span class="toc-text">Chapter 2. TypeScript 编译</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-TypeScript-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-text">Chapter 3. TypeScript 类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%96%B0%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.1 新的辅助类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-Any-%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.1.1 Any 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-Unknown-%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.1.2 Unknown 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-Never-%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.1.3 Never 类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E5%92%8C-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.2 新的基本类型 和 引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-TypeScript-%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.2.1 TypeScript 的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-TypeScript-%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.2.2 TypeScript 值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-TypeScript-%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.2.3 TypeScript 常量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-TypeScript-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.2.4 TypeScript 对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-1-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">3.2.4.1 使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-2-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">3.2.4.2 对象类型的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-3-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC-%E4%B8%8E-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.2.4.3 解构赋值 与 对象类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-4-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%88%99%EF%BC%88Structual-Typing-Principle%EF%BC%89"><span class="toc-text">3.2.4.4 对象类型的结构类型原则（Structual Typing Principle）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-5-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7%E8%A7%84%E5%88%99"><span class="toc-text">3.2.4.5 对象类型的最小可选属性规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-TypeScript-%E7%9A%84%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B-%E4%B8%8E-%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.2.5 TypeScript 的联合类型 与 交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-6-TypeScript-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">3.2.6 TypeScript 类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-7-TypeScript-typeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">3.2.7 TypeScript typeof 运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-TypeScript-%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%86%85%E7%BD%AE%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.3 TypeScript 中的数组：基本类型和内置引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">3.3.1 定义和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%8F%AA%E8%AF%BB%E6%95%B0%E7%BB%84"><span class="toc-text">3.3.2 只读数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">3.3.3 多维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-TypeScript-%E5%85%83%E7%BB%84"><span class="toc-text">3.4 TypeScript 元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-TypeScript-%E5%87%BD%E6%95%B0"><span class="toc-text">3.5 TypeScript 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">3.5.1 定义与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0-%E4%B8%8E-%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-text">3.5.2 可选参数 与 默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84-%E8%A7%A3%E5%8C%85"><span class="toc-text">3.5.3 参数解构 (解包)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0-args"><span class="toc-text">3.5.4 剩余参数 (args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5-%E5%8F%AA%E8%AF%BB%E5%8F%82%E6%95%B0"><span class="toc-text">3.5.5 只读参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-6-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">3.5.6 函数重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-TypeScript-%E7%9A%84%E7%B1%BB"><span class="toc-text">3.6 TypeScript 的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">3.6.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E7%B1%BB%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">3.6.2 类的可见性修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-3-%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="toc-text">3.6.3 类的访问器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-4-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">3.6.4 类的静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-5-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">3.6.5 类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-6-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">3.6.6 抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-7-FAQ-%E7%B1%BB%E4%B8%AD%E7%9A%84-this-%E5%9C%A8-TypeScript-%E9%87%8C%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">3.6.7 FAQ: 类中的 this 在 TypeScript 里究竟是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-TypeScript-%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.7 TypeScript 的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">3.7.1 定义和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-%E6%8E%A5%E5%8F%A3%E5%90%88%E5%B9%B6"><span class="toc-text">3.7.2 接口合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-%E6%8E%A5%E5%8F%A3-Interface-%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D-type-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">3.7.3 接口 (Interface) 和类型别名 (type) 的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-TypeScript-%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">3.8 TypeScript 的泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-TypeScript-Enum-%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.9 TypeScript Enum 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">3.9.1 定义与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-2-%E7%89%B9%E6%80%A7"><span class="toc-text">3.9.2 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-3-keyof-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.9.3 keyof 关键字与枚举类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-TypeScript-%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">3.10 TypeScript 的类型断言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-1-%E4%BB%A3%E6%9B%BF%E6%98%8E%E7%A1%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%A9%E7%AA%84"><span class="toc-text">3.10.1 代替明确的类型缩窄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-2-%E7%9B%B4%E6%8E%A5%E9%87%8F%E7%9A%84%E5%B8%B8%E9%87%8F%E6%96%AD%E8%A8%80"><span class="toc-text">3.10.2 直接量的常量断言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9B%B4%E6%8E%A5%E9%87%8F"><span class="toc-text">基本类型直接量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E9%87%8F"><span class="toc-text">对象直接量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-3-%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80"><span class="toc-text">3.10.3 非空断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-4-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%87%BD%E6%95%B0"><span class="toc-text">3.10.4 类型断言函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4-TypeScript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">Chapter 4. TypeScript 模块与命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%A8%A1%E5%9D%97"><span class="toc-text">4.1 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">4.1.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E7%89%B9%E6%80%A7"><span class="toc-text">4.1.2 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-CommonJS-%E6%A8%A1%E5%9D%97%E6%94%AF%E6%8C%81"><span class="toc-text">4.1.3 CommonJS 模块支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E7%BC%96%E8%AF%91%E6%97%B6%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%BD%8D-Module-Resolution"><span class="toc-text">4.1.4 编译时模块定位 (Module Resolution)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%97%B6%E6%89%8B%E5%8A%A8%E6%8C%87%E5%AE%9A%E6%A8%A1%E5%9D%97%E8%B7%AF%E5%BE%84"><span class="toc-text">引用时手动指定模块路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tsconfig-json-%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97%E8%B7%AF%E5%BE%84"><span class="toc-text">tsconfig.json 配置模块路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">4.2 命名空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5-TypeScript-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">Chapter 5. TypeScript 装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">5.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%BA%90%E7%A0%81%E5%AE%9A%E4%B9%89"><span class="toc-text">5.2 源码定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">5.2.1 类装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E6%96%B9%E6%B3%95%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">5.2.2 方法装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E5%B1%9E%E6%80%A7%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">5.2.3 属性装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-getter-%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81setter-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">5.2.4 getter 装饰器、setter 装饰器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/transformer.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Transformer 论文精读 + 代码实现"/></a><div class="content"><a class="title" href="/technical/transformer/" title="Transformer 论文精读 + 代码实现">Transformer 论文精读 + 代码实现</a><time datetime="2025-07-20T15:15:10.000Z" title="发表于 2025-07-20 23:15:10">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/sc.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阅读: A Hardware-Software Co-Design for Efficient Secure Containers"/></a><div class="content"><a class="title" href="/technical/sc-paper/" title="阅读: A Hardware-Software Co-Design for Efficient Secure Containers">阅读: A Hardware-Software Co-Design for Efficient Secure Containers</a><time datetime="2025-07-01T10:14:11.000Z" title="发表于 2025-07-01 18:14:11">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/ml-roadmap.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识图谱：Machine Learning Roadmap"/></a><div class="content"><a class="title" href="/technical/ml-roadmap/" title="知识图谱：Machine Learning Roadmap">知识图谱：Machine Learning Roadmap</a><time datetime="2025-06-08T06:59:31.000Z" title="发表于 2025-06-08 14:59:31">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/os-sum.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例"/></a><div class="content"><a class="title" href="/review/os-el-and-mem/" title="OS 的特权级切换与内存管理总览：以 Linux AArch64 为例">OS 的特权级切换与内存管理总览：以 Linux AArch64 为例</a><time datetime="2025-05-30T08:49:12.000Z" title="发表于 2025-05-30 16:49:12">2025-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/tee-lab.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机密计算与TEE：知识整理和试验笔记"/></a><div class="content"><a class="title" href="/technical/tee-lab/" title="机密计算与TEE：知识整理和试验笔记">机密计算与TEE：知识整理和试验笔记</a><time datetime="2025-04-17T15:31:36.000Z" title="发表于 2025-04-17 23:31:36">2025-04-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SSRVodka  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-image"><a class="rightMenu-item" href="javascript:rmf.copyImageUrl();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制图片地址</span></a><a class="rightMenu-item" href="javascript:rmf.downloadImage();" rel="external nofollow noreferrer"><i class="fa-solid fa-download"></i><span>保存图片</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-link"><a class="rightMenu-item" href="javascript:rmf.copyLink();" rel="external nofollow noreferrer"><i class="fa-solid fa-link"></i><span>复制链接地址</span></a><a class="rightMenu-item" href="javascript:rmf.openLinkNewTab();" rel="external nofollow noreferrer"><i class="fa-solid fa-external-link-alt"></i><span>在新标签页打开</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script src="/js/status_badge.js"></script><script defer src="/js/console_welcome.js"></script><script async data-pjax src="/js/bsz.build-20250729.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>