<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>从C++入门Qt（一） | SJTU-XHW's blog</title><meta name="author" content="SJTU-XHW,sjtuxhw12345@sjtu.edu.cn"><meta name="copyright" content="SJTU-XHW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~">
<meta property="og:type" content="article">
<meta property="og:title" content="从C++入门Qt（一）">
<meta property="og:url" content="https://blog.sjtuxhw.top/technical/qt-for-beginners-1/index.html">
<meta property="og:site_name" content="SJTU-XHW&#39;s blog">
<meta property="og:description" content="written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.sjtuxhw.top/cover_imgs/qt1.jpg">
<meta property="article:published_time" content="2023-07-28T06:44:12.000Z">
<meta property="article:modified_time" content="2024-10-25T14:01:57.555Z">
<meta property="article:author" content="SJTU-XHW">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Qt">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.sjtuxhw.top/cover_imgs/qt1.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.sjtuxhw.top/technical/qt-for-beginners-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功 ヾ(≧∇≦*)ゝ',
    error: '复制失败 (#`皿´)',
    noSupport: '浏览器不支持 ╮(╯_╰)╭'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#333","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从C++入门Qt（一）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/mouseConfig.css"/><link rel="stylesheet" href="/css/rightmenu.css"/><link rel="stylesheet" href="/css/custom_music.css"/><link rel="stylesheet" href="/css/addFonts.css"/><link rel="stylesheet" href="/css/titleFonts.css"/><link rel="stylesheet" href="/css/talk.css"/><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SJTU-XHW's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div id="main-loading-bg"><div class="truckWrapper"><div class="truckBody"><svg class="trucksvg" viewBox="0 0 198 93" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M135 22.5H177.264C178.295 22.5 179.22 23.133 179.594 24.0939L192.33 56.8443C192.442 57.1332 192.5 57.4404 192.5 57.7504V89C192.5 90.3807 191.381 91.5 190 91.5H135C133.619 91.5 132.5 90.3807 132.5 89V25C132.5 23.6193 133.619 22.5 135 22.5Z" fill="currentColor" stroke="#282828" stroke-width="3"></path><path d="M146 33.5H181.741C182.779 33.5 183.709 34.1415 184.078 35.112L190.538 52.112C191.16 53.748 189.951 55.5 188.201 55.5H146C144.619 55.5 143.5 54.3807 143.5 53V36C143.5 34.6193 144.619 33.5 146 33.5Z" fill="#7D7C7C" stroke="#282828" stroke-width="3"></path><path d="M150 65C150 65.39 149.763 65.8656 149.127 66.2893C148.499 66.7083 147.573 67 146.5 67C145.427 67 144.501 66.7083 143.873 66.2893C143.237 65.8656 143 65.39 143 65C143 64.61 143.237 64.1344 143.873 63.7107C144.501 63.2917 145.427 63 146.5 63C147.573 63 148.499 63.2917 149.127 63.7107C149.763 64.1344 150 64.61 150 65Z" fill="#282828" stroke="#282828" stroke-width="2"></path><rect x="187" y="63" width="5" height="7" rx="1" fill="#FFFCAB" stroke="#282828" stroke-width="2"></rect><rect x="193" y="81" width="4" height="11" rx="1" fill="#282828" stroke="#282828" stroke-width="2"></rect><rect x="6.5" y="1.5" width="121" height="90" rx="2.5" fill="#DFDFDF" stroke="#282828" stroke-width="3"></rect><rect x="1" y="84" width="6" height="4" rx="2" fill="#DFDFDF" stroke="#282828" stroke-width="2"></rect></svg></div><div class="truckTires"><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg><svg class="tiresvg" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="13.5" fill="#282828" stroke="#282828" stroke-width="3"></circle><circle cx="15" cy="15" r="7" fill="#DFDFDF"></circle></svg></div><div class="road"></div><svg class="lampPost" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 453.459 453.459" xml:space="preserve"><path d="M252.882,0c-37.781,0-68.686,29.953-70.245,67.358h-6.917v8.954c-26.109,2.163-45.463,10.011-45.463,19.366h9.993 c-1.65,5.146-2.507,10.54-2.507,16.017c0,28.956,23.558,52.514,52.514,52.514c28.956,0,52.514-23.558,52.514-52.514 c0-5.478-0.856-10.872-2.506-16.017h9.992c0-9.354-19.352-17.204-45.463-19.366v-8.954h-6.149C200.189,38.779,223.924,16,252.882,16 c29.952,0,54.32,24.368,54.32,54.32c0,28.774-11.078,37.009-25.105,47.437c-17.444,12.968-37.216,27.667-37.216,78.884v113.914 h-0.797c-5.068,0-9.174,4.108-9.174,9.177c0,2.844,1.293,5.383,3.321,7.066c-3.432,27.933-26.851,95.744-8.226,115.459v11.202h45.75 v-11.202c18.625-19.715-4.794-87.527-8.227-115.459c2.029-1.683,3.322-4.223,3.322-7.066c0-5.068-4.107-9.177-9.176-9.177h-0.795 V196.641c0-43.174,14.942-54.283,30.762-66.043c14.793-10.997,31.559-23.461,31.559-60.277C323.202,31.545,291.656,0,252.882,0z M232.77,111.694c0,23.442-19.071,42.514-42.514,42.514c-23.442,0-42.514-19.072-42.514-42.514c0-5.531,1.078-10.957,3.141-16.017 h78.747C231.693,100.736,232.77,106.162,232.77,111.694z"></path></svg></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
      setTimeout(() => {
        $loadingBox.style.display = 'none'
      }, 800)
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()
</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.sjtuxhw.top/cover_imgs/qt1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_icon.png" alt="Logo"><span class="site-name">SJTU-XHW's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">从C++入门Qt（一）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/dailyQ/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> DailyQuestion</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gamepad"></i><span> ACG-Lab</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ACGLab/MikuTap/"><i class="fa-fw fas fa-music"></i><span> MikuTap</span></a></li><li><a class="site-page child" href="/ACGLab/Live2D/"><i class="fa-fw fa-solid fa-face-kiss-wink-heart"></i><span> Live2D</span></a></li><li><a class="site-page child" href="/ACGLab/Folio-2019/"><i class="fa-fw fa-solid fa-car-side"></i><span> Folio-2019</span></a></li><li><a class="site-page child" href="/ACGLab/Cube/"><i class="fa-fw fa-solid fa-cube"></i><span> Cube</span></a></li><li><a class="site-page child" href="/ACGLab/TowerBlocks/"><i class="fa-fw fa-solid fa-gopuram"></i><span> TBlocks</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friend-links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">从C++入门Qt（一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-28T06:44:12.000Z" title="发表于 2023-07-28 14:44:12">2023-07-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T14:01:57.555Z" title="更新于 2024-10-25 22:01:57">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/">technical</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/technical/qt-for-beginners-1/#post-comment"><span class="waline-comment-count" data-path="/technical/qt-for-beginners-1/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><i>written by SJTU-XHW</i></p>
<p><i>Reference: C++ GUI Programming with Qt 4 (2nd Edition) </i></p>
<p><i>注意：本文章将讲解 <strong>Qt 5</strong> 入门知识，需要一定的 C++ 基础</i></p>
<p><i>本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！</i></p>
<p><strong>观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~</strong></p>
<hr>
<span id="more"></span>
<h1 id="Chapter-0-前置知识"><a href="#Chapter-0-前置知识" class="headerlink" title="Chapter 0 前置知识"></a>Chapter 0 前置知识</h1><h2 id="0-1-C-基础-和-面向对象编程"><a href="#0-1-C-基础-和-面向对象编程" class="headerlink" title="0.1 C++ 基础 和 面向对象编程"></a>0.1 C++ 基础 和 面向对象编程</h2><h2 id="0-2-C-的宏（macro）"><a href="#0-2-C-的宏（macro）" class="headerlink" title="0.2 C++ 的宏（macro）"></a>0.2 C++ 的宏（macro）</h2><ul>
<li>宏的定义非常自由甚至可以把一个符号定义为一个很长的字符串，甚至代码；主要是因为宏的工作原理是<strong>编译前将宏直接原封不动地替换</strong>；例如下面的极端例子：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接把 HELLO 定义为一串代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLO \</span></span><br><span class="line"><span class="meta">    QLabel* label = new QLabel(<span class="string">&quot;&lt;h2&gt;&lt;i&gt;Hello,&lt;/i&gt;&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;&quot;</span>);\</span></span><br><span class="line"><span class="meta">    QPushButton* btn = new QPushButton(<span class="string">&quot;Quit&quot;</span>);\</span></span><br><span class="line"><span class="meta">    QObject::connect(btn, SIGNAL(clicked()), &amp;app, SLOT(quit()));\</span></span><br><span class="line"><span class="meta">    label-&gt;show();\</span></span><br><span class="line"><span class="meta">    btn-&gt;show();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接写 HELLO 就相当于替换了</span></span><br><span class="line">    HELLO</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0-3-Qt-环境配置"><a href="#0-3-Qt-环境配置" class="headerlink" title="0.3 Qt 环境配置"></a>0.3 Qt 环境配置</h2><blockquote>
<p>Unix 系统：不是安装完就能在命令行里用了吗？</p>
</blockquote>
<p>Windows 系统：在下载安装的 Qt 目录中找到编译器文件夹（安装时应该提醒你设置过了），把编译器目录下 <code>bin</code> 文件夹目录添加到 <strong>用户/系统环境变量 <code>Path</code></strong> 中；</p>
<h1 id="Chapter-1-Qt-初认识"><a href="#Chapter-1-Qt-初认识" class="headerlink" title="Chapter 1 Qt 初认识"></a>Chapter 1 Qt 初认识</h1><h2 id="1-1-简单示例"><a href="#1-1-简单示例" class="headerlink" title="1.1 简单示例"></a>1.1 简单示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span>    <span class="comment">// Qt 中一些类的定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QApplication 支持两个参数，说明 Qt 也有自己的命令行参数</span></span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;    <span class="comment">// 创建 QApplication 对象，用于管理程序资源</span></span><br><span class="line">    <span class="comment">// 创建了显示 “……” 的 QLabel 窗口部件(widget)</span></span><br><span class="line">    QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, Qt!&quot;</span>);</span><br><span class="line">    <span class="comment">// 显示该 widget，详见 tips2.</span></span><br><span class="line">    label-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// 将应用程序的控制权传递给 Qt，程序进入循环等待状态，监听用户动作并根据代码作出反应</span></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="comment">// 此处不考虑内存泄漏，因为整个程序结束后，空间能直接被操作系统回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>widget：窗口部件，指用户界面中的一个可视化元素，相当于 Windows 中的控件、容器。按钮、菜单、滚动条、框架等都是窗口部件。</p>
<p>tips 1. <strong>绝大多数应用程序会使用 <code>QMainWindow</code> 或 <code>QDialog</code> 作为窗口</strong>；而且在 Qt 中很灵活，甚至可以使用 QLabel 窗口部件来作为窗口（如上例）；</p>
<p>tips 2. <strong>创建 widget 时，大多都是“隐藏”属性，这可以使得我们先更改一些性质，在手动显示它们</strong>；</p>
<p>tips 3. <code>QLabel</code> 类的初始化参数的字符串<strong>允许简单 HTML 文本</strong>！例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLabel* label = <span class="built_in">QLabel</span>(<span class="string">&quot;&lt;h2&gt;&lt;i&gt;Hello,&lt;/i&gt;&lt;/h2&gt;&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="1-2-要点：通过命令行（qmake）创建、编译-Qt-工程"><a href="#1-2-要点：通过命令行（qmake）创建、编译-Qt-工程" class="headerlink" title="1.2 要点：通过命令行（qmake）创建、编译 Qt 工程"></a>1.2 要点：通过命令行（qmake）创建、编译 Qt 工程</h2><p>本文单独提出为一个小节足以证明重要性，这里不会，连程序都跑不起来……</p>
<p>【⚠ 劝退警告】了解 Qt 前，本文默认大家已经对 C++ 从编码到编译运行的过程都基本了解；</p>
<blockquote>
<p>不了解就想学 Qt，只能说你是抱着没打算学透彻的心态，或者是只会用 IDE，一碰到报错就四处提问，，建议直奔 B 站 “1天速成”，或者某 CSDN 看“教程”；</p>
<p>但如果想要了解这方面内容可以参见博客 “GNU Tutor” 来入门，或者配合 GCC、CMake 相关课程学习（当然要先学会 C++ 基础）；</p>
</blockquote>
<p>从现在开始将使用 Qt 的用户分为 2 类（和操作系统环境无关）：</p>
<ol>
<li><p>使用 Qt Creator 的用户（即在官网安装 Qt Creator IDE 及 全套 Qt 运行环境的用户），<strong>以后称这类用户为 “IDE 用户”</strong>；</p>
<blockquote>
<p>这很像 C++ 使用 VS、VSCode、CLion 等 IDE（集成开发环境） 一键编译运行的用户；</p>
</blockquote>
</li>
<li><p>使用单独的 Qt Designer 的用户（即 Qt 库 + 命令行编译 + Qt Designer 的用户），<strong>以后称这类用户为 “非 IDE 用户”</strong>；</p>
<blockquote>
<p>这很像 C++ 使用<strong>编辑器</strong>写代码、手动使用 CMake/Make/GCC 编译、使用命令行运行的<strong>亲力亲为</strong>的用户；</p>
</blockquote>
</li>
</ol>
<h3 id="非-IDE-用户如何创建、编译运行-Qt-项目"><a href="#非-IDE-用户如何创建、编译运行-Qt-项目" class="headerlink" title="非 IDE 用户如何创建、编译运行 Qt 项目"></a>非 IDE 用户如何创建、编译运行 Qt 项目</h3><blockquote>
<p>由于手动编译更困难、更接近 Qt 运行的原理，所以优先介绍非 IDE 用户的做法；</p>
<p>劝退警告：Windows 环境配置复杂于 Linux，不过能让你更好了解 Qt 项目编译全过程，如果感兴趣可以使用这种方法；本人在开发 Windows 桌面应用时就采用这种方法</p>
</blockquote>
<ul>
<li><p><span id="script-env">【此步仅 Windows 用户】</span>确认编译器环境：Windows 中你可能在之前就有一个 C++ 编译器，并且已经配置在环境变量里，例如 MSVC 或者 minGW，所以为了防止手动编译用错了编译器，导致报错，<strong>这步是必须的</strong>；</p>
<p>在编译前，需要<strong>临时加入2个环境变量，来确保覆盖系统内其他C++编译器的环境变量</strong>：</p>
<ol>
<li><p>和 Qt 库配套的 C++ 编译器目录。如果你安装了 Qt Creator，那么在安装时应该顺带让你设置并安装了对应版本的 minGW 编译器，它的位置和 Qt 是放在一起的；</p>
<p><strong>通常位置是：<code>&lt;Qt安装根目录&gt;\Tools\mingw&lt;版本号&gt;\bin</code></strong>;</p>
<p>例如本人的位置：<code>D:\Qt5.14.2\Tools\mingw730_64\bin</code>；</p>
</li>
<li><p>Qt 库引入新的编译器，例如 <code>moc</code> 编译器、<code>uic</code> 编译器（后面会说），所在的目录；</p>
<p><strong>通常位置是：<code>&lt;Qt安装根目录&gt;\&lt;Qt版本号&gt;\mingw&lt;版本号&gt;\bin</code></strong>；</p>
<p>例如本人的位置：<code>D:\Qt5.14.2\5.14.2\mingw73_64\bin</code>；</p>
</li>
</ol>
<p>为了在手动编译完项目后，不影响其他C++编译器的正常使用，应该把这两个环境变量设置为临时环境变量，最方便的做法是<strong>写成 BAT 脚本</strong>，在命令行窗口中使用，只保留到本次会话结束；<strong>坏处是每次编译前都要运行这个脚本</strong>；例如本人的脚本应该这么写：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File: addEnv.bat</span></span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> PATH=D:\Qt5.<span class="number">14.2</span>\<span class="number">5.14</span>.<span class="number">2</span>\mingw73_64\bin;D:\Qt5.<span class="number">14.2</span>\Tools\mingw730_64\bin;%PATH%</span><br></pre></td></tr></table></figure>
<p>你可以将这个脚本保存在你的项目目录，或者其他目录，编译前运行一下就行，<strong>注意必须用命令行运行，而且编译必须使用这个命令行，不能关闭，否则临时环境变量会丢失，需要重新运行</strong>；</p>
<blockquote>
<p><strong>当然，如果你十分肯定系统中唯一的 C++ 编译器就是 Qt 安装的这个编译器，并且还在环境变量里，那么这一整个步骤就不用做了</strong>；</p>
</blockquote>
</li>
<li><p>创建工程：在<strong>已安排源文件（你已经创建了一些 <code>*.h/cpp</code>）的目录</strong>下执行：<code>qmake -project</code>，生成 <code>*.pro</code> 文件，与平台无关的项目文件；</p>
<blockquote>
<p>或者你想让项目目录干净点可以新建一个 build 文件夹，将命令行切入 build 中，再执行 <code>qmake -project &lt;你的项目目录&gt;</code></p>
</blockquote>
</li>
<li><p>添加 Qt 库：如果这个项目除了 <code>QtCore</code>、<code>QtGui</code>（默认包含） 以外，还想添加额外的 Qt 库，例如常用的 <code>QtWidgets</code>，<code>QtNetwork</code>，那么在 <code>*.pro</code> 文件的合适位置添加：<code>QT += widgets</code>、<code>QT += network</code>；</p>
<blockquote>
<p>想要了解更详细的 <code>*.pro</code> 文件的编写规则，请查阅<a target="_blank" rel="noopener external nofollow noreferrer" href="https://doc.qt.io/qt-5/qmake-manual.html">官方文档</a>；</p>
<p><span id="important1"><strong>不过除了添加 Qt 库，其他应该很少会直接修改 <code>pro</code> 文件，例如引入项目文件就不用</strong>：</span></p>
<ul>
<li>IDE 用户可以在 Qt Creator 左侧文件栏右击添加文件，会自动更新 pro 文件；</li>
<li>非 IDE 用户只需在相同文件夹下重新运行 <code>qmake -project</code> 即可更新 pro 文件；</li>
</ul>
</blockquote>
</li>
<li><p>编译工程：使用 <code>qmake *.pro</code> 将一般项目文件编译为与平台相关的 <code>makefile</code> 文件；最后运行<code>make</code> 直接编译即可；</p>
<blockquote>
<p><code>qmake *.pro</code> 的过程有点像 CMake 对照 CMakeLists.txt 生成 Makefile 的过程；</p>
<p>注：Windows 下稍微麻烦一点，在项目目录下：</p>
<ol>
<li><p>运行 <code>qmake *.pro -spec win32-g++ &quot;CONFIG+=debug&quot; &quot;CONFIG += qml_debug&quot;</code></p>
</li>
<li><p>运行 <code>mingw32-make.exe</code>，这就相当于 Unix 系统下的 <code>make</code>；</p>
</li>
</ol>
</blockquote>
<ol>
<li><p>⚠ <strong>当你在生成 <code>makefile</code> 后，又向程序中加入一些新的包或函数，那么可能需要再次运行 <code>qmake</code> 来生成 新的 <code>makefile</code>，以防编译器无法找到新文件</strong>；</p>
</li>
<li><p><strong>有同学可能会问，能不能不用 <code>qmake</code>，就用 <code>cmake</code>？这个可以，下一节就说！</strong></p>
</li>
</ol>
</li>
</ul>
<h3 id="IDE-用户如何创建、编译运行-Qt-项目"><a href="#IDE-用户如何创建、编译运行-Qt-项目" class="headerlink" title="IDE 用户如何创建、编译运行 Qt 项目"></a>IDE 用户如何创建、编译运行 Qt 项目</h3><ul>
<li>法1（纯 IDE 法）：打开 Qt Creator -&gt; 新建项目 -&gt; 按指示配置环境（界面中 Qt Application 模板对新手不友好，可能需要思考一会项目结构） -&gt; 编写项目 -&gt; 编译运行就交给 IDE 吧~；</li>
<li>法2（命令行法，比较自由）：新建一个项目文件夹 -&gt; 按需创建 <code>*.cpp</code> <code>*.h</code> 等项目文件 -&gt; 命令行进入该目录运行 <code>qmake -project</code> -&gt; 进入生成的 <code>*.pro</code> 按需添加所需 Qt 库 -&gt; 双击 pro 文件/进入 Qt Creator 打开项目 -&gt; 编写项目 -&gt; 编译运行就交给 IDE 吧~；</li>
</ul>
<h2 id="1-2-EX-使用-CMake-代替-qmake-构建项目"><a href="#1-2-EX-使用-CMake-代替-qmake-构建项目" class="headerlink" title="1.2-EX 使用 CMake 代替 qmake 构建项目"></a>1.2-EX 使用 CMake 代替 qmake 构建项目</h2><p><strong>使用 IDE 的小伙伴就可以跳过了哦 ~ 因为你们只需要在创建项目时，选择 “项目构建系统” 为CMake，就完成了！</strong></p>
<p>下面，在原来的 CMake 语法的基础上（基础语法不作介绍，可以看本站以前的文章，或者网上学习），本人仅会介绍 <strong>和普通 C++ 项目构建的不同之处</strong>：</p>
<ol>
<li><p><strong>【必要】添加 Qt 专属编译器</strong>（这些编译器在后面会一一介绍，学完可以回来看看）：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动调用 uic 编译器处理 *.ui</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"><span class="comment"># 自动调用 moc 编译器处理 Qt 宏和关键字</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="comment"># 自动处理 *.qrc Qt 资源文件</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>【必要】</strong>如果 你在 qmake 中需要添加诸如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += widgets network    // *.pro 的写法</span><br></pre></td></tr></table></figure>
<p>的 Qt 库，在 CMake 中需要这么写：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $ENV&#123;&#125; 调用系统环境变量，这个 Qt_HOME 需要自己设置在系统环境变量里</span></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Widgets Network REQUIRED PATHS $ENV&#123;Qt_HOME&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>很遗憾，CMake 没有 qmake 的默认设置，qmake 默认加入的 <code>Gui</code>、<code>Core</code> 库需要在 CMakeLists 中手动加入</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Core Gui REQUIRED)</span><br></pre></td></tr></table></figure>
<p><strong>而且在最后还要手动链接库</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(exeName PRIVATE Qt5::Widgets Qt5::Core Qt5::Gui)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>【注意】</strong>：在 CMake 中，由于之前添加了专属编译器，所以 <code>*.ui</code> 和 <code>*.h/cpp</code> 一样，都需要在 <code>add_executable</code> 或 <code>add_library</code> 构建目标时，<strong>作为源文件加入进去</strong>；</p>
</li>
</ol>
<p><strong>最后，以一个示例项目为例子（不同的项目没法照抄哦~）</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">PROJECT</span>(HelloWorld)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【optional】设置工程包含当前目录</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_INCLUDE_CURRENT_DIR <span class="keyword">ON</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FIND_PACKAGE</span>(Qt5 COMPONENTS Widgets Gui Core REQUIRED PATHS $ENV&#123;Qt5_HOME&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前文件夹中的所有相关文件</span></span><br><span class="line"><span class="keyword">FILE</span>(GLOB SOURCE_FILES <span class="string">&quot;./*.cpp&quot;</span>) </span><br><span class="line"><span class="keyword">FILE</span>(GLOB HEADER_FILES <span class="string">&quot;./*.h&quot;</span>) </span><br><span class="line"><span class="keyword">FILE</span>(GLOB UI_FILES <span class="string">&quot;./*.ui&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过Ui文件生成对应的头文件</span></span><br><span class="line">QT5_WRAP_UI(WRAP_FILES <span class="variable">$&#123;UI_FILES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加资源文件</span></span><br><span class="line"><span class="keyword">SET</span>(RCC_FILES rcc.qrc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【optional】生成UI文件夹</span></span><br><span class="line"><span class="keyword">SOURCE_GROUP</span>(<span class="string">&quot;UI&quot;</span> FILES <span class="variable">$&#123;UI_FILES&#125;</span> <span class="variable">$&#123;WRAP_FILES&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件，需添加RCC_FILES、WRAP_FILES</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SOURCE_FILES&#125;</span> <span class="variable">$&#123;HEADER_FILES&#125;</span> <span class="variable">$&#123;RCC_FILES&#125;</span> <span class="variable">$&#123;WRAP_FILES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Qt5依赖项</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> Qt5::Widgets Qt5::Core Qt5::Gui)</span><br></pre></td></tr></table></figure>
<h2 id="1-3-建立连接"><a href="#1-3-建立连接" class="headerlink" title="1.3 建立连接"></a>1.3 建立连接</h2><blockquote>
<p>之前我们认识了简单 Qt 程序的基本运作，那么如何实现 <strong>Qt 响应用户的动作呢？</strong></p>
</blockquote>
<h3 id="1-3-1-信号与槽的原理"><a href="#1-3-1-信号与槽的原理" class="headerlink" title="1.3.1. 信号与槽的原理"></a>1.3.1. 信号与槽的原理</h3><ul>
<li><p>Qt 的 widget 通过<strong>发射信号</strong>（signal，实质是一个函数，和操作系统的信号无关）来表明用户的某个动作已发生，或者状态已改变；</p>
<blockquote>
<p>举例：用户点击按钮类 <code>QPushButton</code> 时，按钮会发射 <code>clicked()</code> 信号；</p>
</blockquote>
</li>
<li><p>Qt 的 <strong>槽（slot）能够接收信号</strong>，是一个实际上的函数，一旦触发该信号，slot 会自动执行；</p>
<p>⚠<strong>注意：槽就是函数！一个类如果具有一个方法，那么它就可以作为这个类的槽</strong>；</p>
</li>
<li><p>Qt 通过宏（macro）来将 click() 等对象转化为信号str、将函数 F() 转化为槽，并使用 <code>QObject::connect</code> 函数进行绑定；</p>
<blockquote>
<p><strong>宏转化的时候，如果信号 / 槽对应的函数有参数，务必填入参数类型，例如：</strong></p>
<p><code>SIGNAL(valueChanged(int))</code></p>
</blockquote>
</li>
</ul>
<p>ℹ 这里简单带过一下，给读者一个初印象，以后会详细深入介绍 信号-槽机制；</p>
<h3 id="1-3-2-示例代码"><a href="#1-3-2-示例代码" class="headerlink" title="1.3.2. 示例代码"></a>1.3.2. 示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QPushButton* btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;quit&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用 connect 静态成员函数，其参数原型为：</span></span><br><span class="line">    <span class="comment">// QObject::connect(QObject* p1, SIGNAL, QObject* p2, SLOT)</span></span><br><span class="line">    <span class="comment">// 其中 p1 是指向发送信号的widget指针，p2 是指向接受信号的函数槽**所在的widget**指针，这里是 含有quit()方法 的 QApplication 对象；</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(btn, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), &amp;app, <span class="built_in">SLOT</span>(<span class="built_in">quit</span>()));</span><br><span class="line">    button-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-Qt-窗口的布局设计"><a href="#1-4-Qt-窗口的布局设计" class="headerlink" title="1.4 Qt 窗口的布局设计"></a>1.4 Qt 窗口的布局设计</h2><h3 id="1-4-1-widget-间的父子关系"><a href="#1-4-1-widget-间的父子关系" class="headerlink" title="1.4.1 widget 间的父子关系"></a>1.4.1 widget 间的父子关系</h3><blockquote>
<p>当需要在一个窗口中，<strong>合理地</strong>安排各种 widget 的摆放时，需要考虑这些 widget 间的层次关系；</p>
<p>Qt 中，和其他类的 GUI 设计库类似的做法是，<strong>引入 widget 间的父子关系</strong>；表示：<strong>A 是 B 的子控件 就可以理解为 A 是布局在 B 上的 控件</strong>；</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="layout.png" height="100px"></p>
<p>比如，想要制作如上图的应用界面，就需要遵循这样的步骤（仅供参考，其他方法也能实现）：</p>
<ol>
<li><p>在窗口最顶层设置一个 <code>QWidget</code> 类对象的抽象的 widget，用来盛放其他 widget，可以理解现实中的一个 “桌布”；</p>
</li>
<li><p>以 <code>QWidget</code> 类对象为父控件（QWidget 自己没有父控件，它就是顶层窗口），设置 <code>QSpinbox</code> 和 <code>QSlider</code> 对象（分别是 微调框 控件类、滑动条 控件类）;</p>
<blockquote>
<p><strong>一般情况下，QWidget 及其子类设置父控件的方法是通过布局管理器实现</strong>；理解为“用布局管理器打包在一起”；</p>
</blockquote>
</li>
<li><p>绑定内部信号-槽的关联；</p>
</li>
<li><p>最后<strong>使用布局管理器</strong>将子控件<strong>按指定“摆放方式”</strong>显式加入父控件，显示顶层 widget 即可；</p>
</li>
</ol>
<p>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QHBoxLayout&gt;</span>    <span class="comment">// 引入 布局管理器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QSlider&gt;</span>        <span class="comment">// 引入 滑动条控件类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Qtwidgets/QSpinBox&gt;</span>        <span class="comment">// 引入 微调框控件类</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    QWidget* mainWindow = <span class="keyword">new</span> QWidget;</span><br><span class="line">    mainWindow-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;Enter your age&quot;</span>);    <span class="comment">// QWidget 类具有成员函数 setWindowTitle</span></span><br><span class="line">    </span><br><span class="line">    QSpinBox* spinBox = <span class="keyword">new</span> QSpinBox;</span><br><span class="line">    QSlider* slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal);    <span class="comment">// QSlider 的构造函数的第一个参数可以使用 Qt 枚举量 Horizontal 设置滑动方向</span></span><br><span class="line">    spinBox-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">130</span>);</span><br><span class="line">    slider-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">130</span>);    <span class="comment">// 两个类都具有成员函数 setRange</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个类都具有：valueChanged(int) 信号、setValue(int) 槽，因此将两者相互绑定</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(spinBox, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), slider, <span class="built_in">SLOT</span>(<span class="built_in">setValue</span>(<span class="type">int</span>)));</span><br><span class="line">    QObject::<span class="built_in">connect</span>(slider, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), spinBox, <span class="built_in">SLOT</span>(<span class="built_in">setValue</span>(<span class="type">int</span>)));</span><br><span class="line">    </span><br><span class="line">    spinBox-&gt;<span class="built_in">setValue</span>(<span class="number">35</span>);    <span class="comment">// 初始化值为35</span></span><br><span class="line">    </span><br><span class="line">    QHBoxLayout* layout = <span class="keyword">new</span> QHBoxLayout;    <span class="comment">// 初始化布局管理器</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(spinBox);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(slider);    <span class="comment">// 布局管理器将子控件打包在一起</span></span><br><span class="line">    <span class="comment">// QWidget 具有成员函数 setLayout，可以传入布局管理器实现布局设计</span></span><br><span class="line">    window-&gt;<span class="built_in">setLayout</span>(layout);    <span class="comment">// 再将包传给父控件，底层会自动将管理器中的所有子控件定向其父控件</span></span><br><span class="line">    </span><br><span class="line">    window-&gt;<span class="built_in">show</span>();        <span class="comment">// 最后只需展示顶层 widget 即可</span></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-2-布局设计的意义"><a href="#1-4-2-布局设计的意义" class="headerlink" title="1.4.2 布局设计的意义"></a>1.4.2 布局设计的意义</h3><p>有同学会问，为什么需要 layout？<strong>layout 可以让多个 widget 按想要的方式排列在一个窗口上</strong>；如果不这么做，就没法定义摆放方式了！你可以试一试，不用布局管理器，你会发现两个或多个 widget 是分布在不同的窗口下的；</p>
<h3 id="1-4-3-布局管理器的类型"><a href="#1-4-3-布局管理器的类型" class="headerlink" title="1.4.3 布局管理器的类型"></a>1.4.3 布局管理器的类型</h3><p>除了以上例子介绍的 <code>QHBoxLayout</code> 类，还有 <code>QVBoxLayout</code>、<code>QGridLayout</code>，其作用分别是：</p>
<ul>
<li><code>QHBoxLayout</code>：默认在水平方向，从左到右排列 widget；</li>
<li><code>QVBoxLayout</code>：默认在竖直方向，从上到下排列 widget；</li>
<li><code>QGridLayout</code>：将 widget 排列在预设的网格中；</li>
</ul>
<p>常见的使用方法：先声明、在设置属性，最后添加打包到布局管理器中，设置给父控件；</p>
<p><strong>它们都继承于 <code>QLayout</code>，所以它们不是 widget（<code>QWidget</code>），一般也不可见</strong>；</p>
<h2 id="1-5-章末贴士"><a href="#1-5-章末贴士" class="headerlink" title="1.5 章末贴士"></a>1.5 章末贴士</h2><ul>
<li><p>重要：一定要会使用官方文档；</p>
</li>
<li><p>有些同学会想，里面的命令行参数 <code>argc</code> 和 <code>argv</code> 究竟可以做什么？其实，举个例子就明白了，其中一个用途是<strong>设置应用界面的主题</strong>，即：<code>./应用名 -style &lt;style name&gt;</code>，常用的 <code>style name</code> 有：<code>plastique</code>、<code>Cleanlooks</code>、<code>CDE</code>、<code>Motif</code>、<code>Windows</code>、<code>Windows XP</code>、<code>Windows Vista</code>、<code>Mac</code>；</p>
</li>
<li><p>本章涉及到的类和一些方法的总结</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C1.png"></p>
</li>
<li><p><strong>和 Qt 4 比较</strong>：QLabel、QPushButton、QSlider、QSpinBox 都还是 QWidget 的子类，但 Qt 5 类的头文件移动到<strong>单独的 <code>QWidgets</code> 模块中</strong>，即 include 时，需要：<code>#include&lt;QtWidgets/QXXX&gt;</code></p>
<blockquote>
<p>例如 1.4.1 的例子在 Qt 4 环境下应该这么写<strong>【亲测能跑】</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QSpinBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QSlider&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// …… （后面一毛一样）</span></span><br><span class="line"><span class="comment">// 记得在 *.pro 中移除：QT += widgets</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>最后强调一下， Qt 4 到 5、Qt 5 到 6 的很多操作都改变了，所以别轻易更换项目的 Qt 大版本！</strong></p>
</li>
</ul>
<h1 id="Chapter-2-面向对象的-Qt"><a href="#Chapter-2-面向对象的-Qt" class="headerlink" title="Chapter 2 面向对象的 Qt"></a>Chapter 2 面向对象的 Qt</h1><h2 id="2-1-纯代码设计"><a href="#2-1-纯代码设计" class="headerlink" title="2.1 纯代码设计"></a>2.1 纯代码设计</h2><h3 id="2-1-1-示例：以简单对话框为例"><a href="#2-1-1-示例：以简单对话框为例" class="headerlink" title="2.1.1 示例：以简单对话框为例"></a>2.1.1 示例：以简单对话框为例</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="QDiag.png" height="150px"></p>
<blockquote>
<p>想象一下，这是一个庞大应用程序的一个小部分对话框，现在想要单独设计它。但是第一章的代码都写在一个 main 函数中，如果窗口一多，不仅不利于维护，而且容易编写错误；</p>
<p>所以我们从现在开始采用 C++ 中的不同类来编写不同窗口，可以形成很好的封装性，增强可读性；</p>
</blockquote>
<p>下面将这个窗口编写为一个类 <code>findDialog</code>；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: findDialog.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FINDDIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FINDDIALOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QDialog&gt;</span>    <span class="comment">// 包含 Qt 对话的基类，派生于 QWidget，和 1.5 中说的一样，在 Qt 4 中要写 #include&lt;QDialog&gt;，以下不再赘述；</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QCheckBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtWidgets/QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">findDialog</span> : <span class="keyword">public</span> QDialog &#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">// 很重要的一个宏，里面写了 QObject 类的几乎所有信号和槽，还有其他属性和方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这是一个典型的 Qt widget 类的定义方式，第一个参数指定父控件</span></span><br><span class="line">    <span class="built_in">findDialog</span>(QWidget* parent = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 marco 说明以下定义的函数都是 信号函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">// Qt::CaseSensitivity 是 enum 类型，和 C++ 中的 true、false 如出一辙，本身的值也是 0 或 1，用于区分大小写是否敏感的具体情况，含有值 Qt:CaseSensitive 和 Qt::CaseInSensitive</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findNext</span><span class="params">(<span class="type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findPrevious</span><span class="params">(<span class="type">const</span> QString&amp; str, Qt::CaseSensitivity cs)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 声明了私有的槽</span></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findClicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 思考一下，已知 QPushButton 自己有槽函数 setEnabled(bool)，为什么还要包装一层 私有的槽呢？（答案在实现这个槽的时候揭晓）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enabledFindButton</span><span class="params">(<span class="type">const</span> QString&amp; text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLabel* label;</span><br><span class="line">    QLineEdit* lineEdit;</span><br><span class="line">    QCheckBox* caseCheckBox;</span><br><span class="line">    QCheckBox* backwardCheckBox;</span><br><span class="line">    QPushButton* findButton;</span><br><span class="line">    QPushButton* closeButton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这是窗口的实现 cpp：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: findDialog.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtGui&gt;</span>        <span class="comment">// 详见注解 tips 1.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;findDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// findDialog 继承于 QDialog，所以也使用它的一些数据成员，自然需要委托构造</span></span><br><span class="line">findDialog::<span class="built_in">findDialog</span>(QWidget* parent) : <span class="built_in">QDialog</span>(parent) &#123;</span><br><span class="line">    <span class="comment">// 这里有 3 点需要解释，详见 tips 2. 、 tips 3. 和 tips 4.</span></span><br><span class="line">    label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="built_in">tr</span>(<span class="string">&quot;Find &amp;what&quot;</span>));    <span class="comment">// tips2. tips3.</span></span><br><span class="line">    <span class="comment">// 新的类：QLineEdit 类，单行输入框类</span></span><br><span class="line">    lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    label-&gt;<span class="built_in">setBuddy</span>(lineEdit);    <span class="comment">// tips4.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新的类：QCheckBox 类，勾选框类，初始化参数和 QLabel 一样，也是str内容</span></span><br><span class="line">    caseCheckBox = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="built_in">tr</span>(<span class="string">&quot;Match &amp;case&quot;</span>));</span><br><span class="line">    backwardCheckBox = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="built_in">tr</span>(<span class="string">&quot;Search &amp;backward&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    findButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Find&quot;</span>));</span><br><span class="line">    findButton-&gt;<span class="built_in">setDefault</span>(<span class="literal">true</span>);        <span class="comment">// tips 5.</span></span><br><span class="line">    findButton-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);        <span class="comment">// tips 6.</span></span><br><span class="line">    </span><br><span class="line">    closeButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="built_in">tr</span>(<span class="string">&quot;Close&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里不用写作用域 “QObject::”，因为 QDialog 就是 QObject 的子类</span></span><br><span class="line">    <span class="comment">// 详见 tips 7.</span></span><br><span class="line">    <span class="comment">// 还记得之前声明的私有槽吗？（再等会实现定义）这里是将 lineEdit 的文字改变信号连接到 findDiag 窗体的 enabledFindButton(const QString&amp;) 私有槽上；</span></span><br><span class="line">    <span class="built_in">connect</span>(lineEdit, <span class="built_in">SIGNAL</span>(<span class="built_in">textChanged</span>(<span class="type">const</span> QString&amp;)),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">enableFindButton</span>(<span class="type">const</span> QString&amp;)));</span><br><span class="line">    <span class="built_in">connect</span>(findButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">findClicked</span>()));</span><br><span class="line">    <span class="comment">// tips 8.</span></span><br><span class="line">    <span class="built_in">connect</span>(closeButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()),</span><br><span class="line">           <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代码块未完待续----------------------------</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>tips 1.</strong> 头文件 <code>QtGui.h</code> 包含了 Qt GUI 类的 <code>QtCore</code> 和 <code>QtGui</code> 模块的所有类的定义；</p>
<blockquote>
<p><strong>回顾一下 Qt 的主要模块：<code>QtCore</code>、<code>QtGui</code>、<code>QtNetwork</code>、<code>QtOpenGL</code>、<code>QtSql</code>、<code>QtSvg</code>、<code>QtXml</code></strong>；</p>
</blockquote>
<ul>
<li>同学会问，为什么不在 <code>findDialog.h</code> 中直接 <code>#include&lt;QtGui&gt;</code>？<strong>因为这个包比较大，引入他可能造成引用的不清晰，不是一个好习惯；理论上用到什么引入什么</strong>；</li>
</ul>
</li>
<li><p><strong>tip 2.</strong>  在 Qt 中，所有字符串都认为是 <code>QString</code> ——有 <code>tr(QString)</code> 方法可以将它们翻译；这就意味着，<strong>在所有用户可见的字符串周围加上 <code>tr()</code> 函数</strong>是个好习惯；这样方便软件后期的翻译工作，对 <code>tr()</code> 的翻译会在后面介绍；</p>
</li>
<li><p><strong>tips 3.</strong> 如果想在用户可见的字符串中加入<strong>快捷键来控制焦点（选中的区域，意味着用户可以直接输入，或者按 ENTER=点击）</strong>，那么在字符串前中写 <strong>“&amp;”</strong> 符号，表示<strong>将 <code>Alt + 字符串第一个字符</code> 作为快捷键</strong>；</p>
</li>
<li><p><strong>tips 4.</strong> 几乎所有 <code>QWidget</code> 都有一个方法 <code>setBuddy(QWidget* ptr)</code> 用来绑定两个 widget 为兄弟控件，具体表现在<strong>共用同一个快捷键</strong>（这个快捷键会同时聚焦这两个控件）；</p>
</li>
<li><p><strong>tips 5.</strong> 大多数 <code>QWidget</code> 都有一个方法 <code>setDefault(bool flag)</code> 用来指定<strong>刚打开窗口时聚焦的控件</strong>；</p>
</li>
<li><p><strong>tips 6.</strong> <code>QPushButton</code> 有一个特有属性 <code>enabled</code>，如果是 <code>true</code>，则这个按钮是可以点击的，否则按钮呈现灰色不可点击的状态；</p>
</li>
<li><p><strong>tips 7.</strong> 由上面的 <code>connect</code> 函数可以看出，<code>QLineEdit</code> 类有一个 <code>textChanged(const QString&amp;)</code> 信号；</p>
</li>
<li><p><strong>tips 8.</strong> 这里 <code>QDialog</code> 的 <code>close()</code> 方法<strong>继承于 <code>QWidget</code> 类</strong>，默认行为是<strong>将 widget 隐藏起来（而非删除）</strong>，这和 <code>QApplication</code> 类的 <code>quit()</code> 方法不一样，<code>quit()</code> 方法是关闭并删除窗口及其上的所有布局、widget；</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 上接上一个代码块 --------------------------	</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记住在 1.4.1 中说的 4 个基本步骤，这里是倒数第二个：打包布局</span></span><br><span class="line">    <span class="comment">// 这里的案例告诉我们，对于多个 widget 的布局，可以采用多个不同位置、不同类型的布局管理器来进行，这里的具体划分见 tips 9.</span></span><br><span class="line">    QHBoxLayout* topLeftLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    topLeftLayout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">    topLeftLayout-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line">    </span><br><span class="line">    QVBoxLayout* leftLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    <span class="comment">// tip 10.</span></span><br><span class="line">    leftLayout-&gt;<span class="built_in">addLayout</span>(topLeftLayout);</span><br><span class="line">    leftLayout-&gt;<span class="built_in">addWidget</span>(caseCheckBox);</span><br><span class="line">    leftLayout-&gt;<span class="built_in">addWidget</span>(backwardCheckBox);</span><br><span class="line">    </span><br><span class="line">    QVBoxLayout* rightLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    rightLayout-&gt;<span class="built_in">addWidget</span>(findButton);</span><br><span class="line">    rightLayout-&gt;<span class="built_in">addWidget</span>(closeButton);</span><br><span class="line">    <span class="comment">// tip 11.</span></span><br><span class="line">    rightLayout-&gt;<span class="built_in">addStretch</span>();</span><br><span class="line">    </span><br><span class="line">    QHBoxLayout* mainLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(leftLayout);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(rightLayout);</span><br><span class="line">    <span class="comment">// 回想之前在 1.4.1 中对 QWidget 顶层窗口使用 setLayout</span></span><br><span class="line">    <span class="built_in">setLayout</span>(mainLayout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和 1.4.1 中一样，这里是 QWidget 派生来的方法</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Find&quot;</span>));</span><br><span class="line">    <span class="comment">// tip 12.</span></span><br><span class="line">    <span class="built_in">setFixedHeight</span>(<span class="built_in">sizeHint</span>().<span class="built_in">height</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>tips 9.</strong> 此处的布局划分的方式如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="QLayout.png" height="200px"></p>
<p>这样的划分思路很类似 HTML 的设计框架布局，<strong>先划分大的区域，再根据功能或对齐位置逐个 “切开” </strong>；</p>
</li>
<li><p><strong>tips 10.</strong> <code>QLayout</code> 类的对象都有 <code>addLayout(QLayout* ptr)</code>，与 <code>addWidget(QWidget* ptr)</code> 类似；前者可以将布局嵌套布局，形成更复杂的结构；</p>
</li>
<li><p><strong>tips 11.</strong> <code>QLayout</code> 类中的 <code>addStretch()</code> 方法，如 tip9 中的图片中的 “分隔符” 的作用，用来撑开当前的 <code>Layout</code>，与同级的 <code>Layout</code> 高度或宽度对齐适应，同时使之前加入布局管理器的 widget 更加紧凑；</p>
</li>
<li><p><strong>tips 12.</strong> <code>setFixedHeight(int h)</code> 是 <code>QWidget</code> 类的方法，可以设定一个固定的 widget 高度，<code>QWidget::sizeHint()</code> 可以计算当前 widget 中各个布局管理器中各子 widget 默认 size，从而得出比较适宜的高度；</p>
</li>
</ul>
<p><strong>写完构造函数，无需写析构函数。因为：Qt 在删除父对象时，会自动删除所有子 widget 和 子布局；</strong></p>
<p>下面<strong>定义之前声明的私有槽</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">findDialog::findClicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取当前 lineEdit 中的字符串到 text 中</span></span><br><span class="line">    QString text = lineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="comment">// tips 13.</span></span><br><span class="line">    Qt::CaseSensitivity cs = </span><br><span class="line">        caseCheckBox-&gt;<span class="built_in">isChecked</span>() ? Qt:CaseSensitive : Qt:CaseInSensitive;</span><br><span class="line">    <span class="keyword">if</span> (backwardCheckBox-&gt;<span class="built_in">isChecked</span>())</span><br><span class="line">        <span class="comment">// tips 14.</span></span><br><span class="line">        <span class="function">emit <span class="title">findPrevious</span><span class="params">(text, cs)</span></span>;</span><br><span class="line">    <span class="keyword">else</span> emit <span class="built_in">findNext</span>(text, cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findDialog::enableFindButton</span><span class="params">(<span class="type">const</span> QString&amp; text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代码块 1 中的疑问，答案揭晓：tips 15.</span></span><br><span class="line">    findButton-&gt;<span class="built_in">setEnabled</span>(!text.<span class="built_in">isEmpty</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>tips 13.</strong> <code>QCheckBox</code> 具有方法 <code>isChecked()</code>，指示这个选择框有没有被选中；</p>
</li>
<li><p><strong>tips 14.</strong> <code>emit &lt;function&gt;</code> 是 Qt 的关键字之一，<strong>表示向函数 <code>function</code> 发射信号</strong>；</p>
</li>
<li><p><strong>tips 15.</strong> 之所以要单独设计一个私有槽，是因为考虑到不仅仅是在输入变换的时候，使这个按钮处于 enable 状态，还要考虑<strong>在文本框为空的时候，使按钮再次 disable</strong>，而这需要额外的逻辑设计；这里就是 <code>!text.isEmpty()</code> 这个方法；</p>
<blockquote>
<p>整体逻辑：如果改变了文本，就调用 <code>enableFindButton</code> 槽；如果文本为空，就 disable “Find” 按钮；</p>
</blockquote>
</li>
</ul>
<p>这下将所有的部件放在一起：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;findDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    findDialog* dialog = <span class="keyword">new</span> findDialog;</span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⚠注意：因为这里没有实际应用场景，所以以上代码的信号 <code>findPrevious(str, cs)</code> 和 <code>findNext(str, cs)</code> 暂时没有应用，以后继续补充</strong>；</p>
<h3 id="2-1-2-进一步了解信号-槽机制"><a href="#2-1-2-进一步了解信号-槽机制" class="headerlink" title="2.1.2 进一步了解信号-槽机制"></a>2.1.2 进一步了解信号-槽机制</h3><ul>
<li><p>槽（<code>slot</code>）：和普通 C++ 成员函数<strong>几乎一模一样</strong>：可以是虚函数、可以被重载、可以是 <code>public/protected/private</code>、可以被其他 C++ 成员函数之间调用、参数可以是任意类型；唯一不同的就是<strong>槽可以和信号连接在一起</strong>，只要 <code>emit</code> 了对应的信号，就会自动调用这个槽；</p>
<blockquote>
<p><strong>当普通 C++ 函数变成槽调用时，一般会忽略原本的返回值</strong>；</p>
</blockquote>
</li>
<li><p>信号 - 槽的连接的函数：<code>QObject::connect(QObject* sender, SIGNAL(signal), QObject* receiver, SLOT(slot))</code></p>
<blockquote>
<p>其中宏 <code>SIGNAL()</code> 和 <code>SLOT()</code> <strong>会将它们的参数转换成相应的字符串</strong>（暂时不必了解这些字符串的结构）；</p>
</blockquote>
</li>
<li><p>信号-槽连接的<strong>要求</strong>：要想信号和槽成功连接，<strong>它们的参数必须有相同的顺序和相同的类型</strong>；</p>
<blockquote>
<p>有一种情况例外：<strong>信号的参数多于槽的参数，但对应的参数类型相同</strong>（这样多余的参数会被简单地忽略掉）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ftp, <span class="built_in">SIGNAL</span>(<span class="built_in">rawCommnadReply</span>(<span class="type">int</span>, <span class="type">const</span> QString&amp;)),</span><br><span class="line">    <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">checkErrorCode</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>信号-槽连接的<strong>特性</strong></p>
<ol>
<li><p><strong>一个信号可以连接多个槽</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这个例子中，如果信号 slider 被 emit，那么会以不确定的顺序一个接着一个调用这些槽（setValue(int) 和 updateStatusBarIndicator(int)，可以不止两个）</span></span><br><span class="line"><span class="built_in">connect</span>(slider, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)),</span><br><span class="line">        spinBox, <span class="built_in">SLOT</span>(<span class="built_in">setValue</span>(<span class="type">int</span>)));</span><br><span class="line"><span class="built_in">connect</span>(slider, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)),</span><br><span class="line">       <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">updateStatusBarIndicator</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多个信号可以连接一个槽</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论发射其中的哪一个信号，都会调用这个槽</span></span><br><span class="line"><span class="built_in">connect</span>(lcd, <span class="built_in">SIGNAL</span>(<span class="built_in">overflow</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleMathError</span>()));</span><br><span class="line"><span class="built_in">connect</span>(calc, <span class="built_in">SIGNAL</span>(<span class="built_in">divisionByZero</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleMathError</span>()));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>一个信号可以连接另一个信号</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// emit 第一个信号，就会触发 emit 第二个信号</span></span><br><span class="line"><span class="built_in">connect</span>(lineEdit, <span class="built_in">SIGNAL</span>(<span class="built_in">textChanged</span>(<span class="type">const</span> QString&amp;)),</span><br><span class="line">       <span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">updateRecord</span>(<span class="type">const</span> QString&amp;)));</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接可以被移除：<strong>这种情况应用较少，因为 <code>Qt</code> 在移除对象时，会自动移除和对象相关的所有连接</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(lcd, <span class="built_in">SINGAL</span>(<span class="built_in">overflow</span>()),</span><br><span class="line">          <span class="keyword">this</span>, <span class="built_in">handlerMathError</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>信号-槽不仅可以应用在图形化界面的编写中，在哪怕不是为了设计 GUI，在类中声明宏 <code>Q_OBJECT</code> 也可以实现信号-槽机制</strong>；</p>
</li>
</ol>
</li>
</ul>
<h3 id="2-1-3-Qt-的元对象编译器-moc-和-元对象系统"><a href="#2-1-3-Qt-的元对象编译器-moc-和-元对象系统" class="headerlink" title="2.1.3 Qt 的元对象编译器 moc 和 元对象系统"></a>2.1.3 Qt 的元对象编译器 moc 和 元对象系统</h3><p>在我一开始尝试写一些基本的程序的时候，一直很疑惑，Qt 的宏 <code>slots</code>、<code>signal</code>、<code>Q_OBJECT</code> 究竟是什么？因为我不理解这其中的原理，所以犯过一个低级的错误——将声明成信号（<code>signal</code>）的函数加以定义，像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: XXX.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XXX</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">signal:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">signalA</span><span class="params">(Type1 p1, Type2 p2)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File: XXX.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XXX::signalA</span><span class="params">(Type1 p1, Type2 p2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 某些代码逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写实际上会在 <code>make</code> 编译是报 <code>multiple definition</code> 的错误，我正纳闷，为啥会 “重复定义” 呢？再一看报错的信息：<strong>重复定义的位置位于 <code>moc_XXX.cpp</code> </strong>，我再想，我也没有写过 <code>moc_XXX.cpp</code> 呀？于是就引出了 <strong><code>Qt</code> 中相当重要的概念：<code>moc</code> 元对象编译器</strong>；</p>
<p>Qt 的主要成就之一就是使用一种机制对 C++ 进行了扩展，并且使用这种机制创建了软件组件；</p>
<p>这种机制叫做 “元对象系统（meta-object system）”，它提供了关键的 2 项技术：<strong>信号-槽机制</strong> 和 <strong>内省（introspection）</strong>；</p>
<p>内省功能对于实现信号和槽是必需的，还允许开发人员获得有关 <code>QObject</code> 子类的 “元信息（meta-information，<strong>包含一些类名和它所支持的信号-槽列表</strong>）”，还支持 Qt 设计师属性（<strong>下一节将提到</strong>）和文本翻译（之前所说的 <code>tr()</code>），为 <code>QScript</code> 模块奠定基础（不过目前接触不到）；</p>
<p>但以上提到的这些，标准 C++ 没有，这意味着用普通的 C++ 编译器一定没法实现；所以 Qt 引入了新的编译器：<code>moc</code> 元对象编译器；</p>
<p>因此，Qt 整个编码到运行的工作流程是：</p>
<ol>
<li><code>qmake</code> 效仿 <code>cmake</code> ，以平台无关的方式指定了程序编译所需的库，这里包含了标准 C++ 所没有的 Qt 的库；最后生成了普通的 <code>Makefile</code>；</li>
<li><code>moc</code> 元对象编译器一边识别 Qt 特定的宏或关键字（例如 <code>QObject</code>、<code>slots</code>、<code>signal</code>），添加特定内容（例如自动实现信号函数），一边和普通 C++ 编译器一样，编译链接源文件；</li>
<li><code>moc</code> 元对象编译器在编译时还会补充 <code>QObject</code> 的 内省函数，完成特殊的触发工作；</li>
</ol>
<p>以上内容一般很少需要开发者去考虑，都封装在 <code>qmake</code>、<code>moc</code>、<code>QObject</code>内部；如果感兴趣，可以阅读有关 <code>QMetaObject</code> 文档，或者是前面提到的 <code>moc</code> 自动生成的 C++ 源码 <code>moc_XXX.cpp/h</code>；</p>
<h2 id="2-2-Qt-Designer：UI-快速设计"><a href="#2-2-Qt-Designer：UI-快速设计" class="headerlink" title="2.2 Qt Designer：UI 快速设计"></a>2.2 Qt Designer：UI 快速设计</h2><p>在上面一些纯代码设计的例子中，我们会发现 GUI 的设计遵循一些基本的规律定式：</p>
<ol>
<li>创建、初始化（例如设置文本内容）子窗口部件；</li>
<li>将 widget 放置到布局中；</li>
<li>设置 Tab 键顺序；</li>
<li>建立信号 — 槽连接；</li>
<li>实现自定义槽；</li>
</ol>
<p>现在，可以使用 Qt Designer 将图形化设计的一部分（指前三步）交给图形界面；</p>
<h3 id="2-2-1-Qt-Designer-的基本使用"><a href="#2-2-1-Qt-Designer-的基本使用" class="headerlink" title="2.2.1 Qt Designer 的基本使用"></a>2.2.1 Qt Designer 的基本使用</h3><blockquote>
<p>本部分将介绍 Qt Designer 如何设计基本 UI 界面，完成上面所提到的 <strong>前3步</strong>，同时<strong>回顾之前所学到的方法</strong>；</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="cellDialog.png"></p>
<p>以上面的窗体为目标设计一个窗口类；</p>
<ul>
<li><p>打开 Qt Designer：在进行此步前，建议按之前的方法先创建一个 Qt 项目；</p>
<ul>
<li>IDE 用户可以在 Qt Creator 中右击创建 <code>Qt 设计师文件</code> （<strong>文件名很重要，将要作为这个窗体的变量名，需要记住，下面提到</strong>），在左边栏的列表中直接双击打开 <code>*.ui</code>；</li>
<li>非 IDE 用户可以直接进入 Qt Designer 按所需模板新建一个 <code>ui</code> 文件（<strong>文件名很重要，需要记住，下面提到</strong>）；</li>
</ul>
</li>
<li><p>创建、初始化子窗口部件 和 部分常用属性</p>
<ol>
<li><code>text</code> 属性：大部分组件的显示内容（还记得之前 <code>QPushButton</code>、<code>QLabel</code> 的初始化参数吗？），拖动出来双击就可以编辑；</li>
<li><code>objectName</code> 属性：<strong>这个名字建议自己设置，需要记住，因为这是控件的变量名，之后设计信号-槽时需要用到</strong>；</li>
<li><code>default</code> 属性：记得之前的方法 <code>QWidget::setDefault</code> 吗？这就是它的图形化；</li>
<li><code>enabled</code> 属性（<code>QPushButton</code>）：相当于在创建 widget 的同时指定 <code>btn-&gt;setEnabled(bool)</code>；</li>
<li><code>windowTitle</code> 属性（<code>QMainWindow</code>，这里点击窗体在右边栏就能搜到）：相当于 <code>win-&gt;setWindowTitle(str)</code>；</li>
</ol>
</li>
<li><p>Qt Designer 设计模式</p>
<ul>
<li>Edit Widgets 模式：默认模式，可以直接编辑上述部件及其属性，在程序顶部“Edit”菜单可以点击进入；</li>
<li>Edit Buddies 模式：点击顶部菜单栏相应按钮进入。此模式下，点击控件并拖到另一个部件上可以完成<strong>部件伙伴的设置</strong>，就是之前设置的 <code>widget1-&gt;setBuddy(widget2)</code>；</li>
<li>Edit Tab Order 模式：点击顶部菜单栏相应按钮进入。此模式下可以<strong>设置 Tab 键顺序</strong>；</li>
</ul>
</li>
<li><p>Qt Designer 中的布局设置</p>
<ul>
<li>方法1：使用左边栏的 Layout 控件；</li>
<li>方法2：按住 CTRL 选中一些 widget，点击顶部菜单栏中的 <code>Lay out Vertically/Horizontally</code>；</li>
</ul>
<blockquote>
<p>注：在布局中加入左边栏中的 <code>Spacer</code> 就等价于之前设置的 <code>layout-&gt;addStretch()</code></p>
</blockquote>
</li>
<li><p>Qt Designer 中的窗口大小设计</p>
<p>可以点击顶部菜单栏中的 <code>Adjust size</code>（调整大小），可以自动将窗体大小定义为最佳形式（等价于之前的 <code>setFixedHeight(sizeHint().height())</code>）</p>
</li>
</ul>
<h3 id="2-2-2-Qt-Designer-的运行原理【重要】"><a href="#2-2-2-Qt-Designer-的运行原理【重要】" class="headerlink" title="2.2.2 Qt Designer 的运行原理【重要】"></a>2.2.2 Qt Designer 的运行原理【重要】</h3><p>说了这么多 Qt Designer 的基本使用，那么它是怎么将 图形界面中设计的 UI 转换为之前的纯代码，并交给 <code>moc</code> 编译器 和 C++ 编译器的呢？</p>
<p>细心的同学可能以文本形式打开过 <code>*.ui</code> ，会发现里面的格式是 <code>XML</code> 文件格式，那么它又是如何转化为 <code>*.h/cpp</code> 的呢？<strong>下面先从非 IDE 用户的视角讲述，IDE 用户也建议看一下，因为 Qt Creator IDE 的自动操作比较奇怪，可能不好理解</strong>；</p>
<p> 以下的案例以名为 <code>myDialog</code> 的主窗口 <code>MainWindow</code> 的设计为例；</p>
<h4 id="非-IDE-用户的视角"><a href="#非-IDE-用户的视角" class="headerlink" title="非 IDE 用户的视角"></a>非 IDE 用户的视角</h4><p>首先，我们向项目中导入这个 <code>myDialog.ui</code> 文件（创建文件并 <code>qmake -project</code>，即前面的<a href="#important1">要点🔗</a>）；</p>
<p>你会发现，<code>qmake</code> 自动更新了 pro 文件：<code>FORM += myDialog.ui</code>（不用自己写）；</p>
<p>紧接着运行 <code>qmake myDialog.pro</code> 生成 <code>Makefile</code> 的同时，<code>qmake</code> 智能识别 <code>myDialog.ui</code>，会在 Makefile 中加入配置规则 <strong>调用 Qt 的新的一种编译器，这不是 GCC，也不是 <code>moc</code>，而是 Qt 用户界面编译器（user interface compiler，uic）</strong>；它会将 <code>myDialog.ui</code> 转换为 C++ 代码存储于 <code>ui_myDialog.h</code> 中；</p>
<p>在 <code>ui_myDialog.h</code> 会生成一个类，类名是 <code>myDialog</code>，<strong>位于 <code>Ui</code> 命名空间</strong>（命名空间 <code>Ui</code> 是 Qt 中用于存放各种 UI 类 的命名空间，通常存放在里面是一种规范）</p>
<blockquote>
<p>⚠ <strong>注意：这里 <code>ui</code> 文件名 <code>XXX.ui</code>、生成的 <code>ui_XXX.h</code> 中的 <code>XXX</code>、生成的类名 <code>XXX</code> 应该是一个名字！！！</strong></p>
<p>不建议轻易修改，不然有可能在下次编译时，编译器找不到相应组件；</p>
<p>这也是为什么之前提醒 “创建 <code>*.ui</code> 文件的文件名很重要”；</p>
</blockquote>
<p><code>ui_myDialog.h</code> 中自动生成的类看起来像：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// #include something</span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE    <span class="comment">// Qt 独有的宏，将其中的类加入特定的namespace中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ui_myDialog</span> &#123;        <span class="comment">// 生成类，由于它谁都不继承，功能少，通常作为中间类使用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Widgets</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setupUi</span><span class="params">(QMainWindow* myDialog)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// realize ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">myDialog</span>: <span class="keyword">public</span> ui_myDialog &#123;&#125;;    <span class="comment">// Qt 自动在 Ui 命名空间中</span></span><br><span class="line">&#125;                                <span class="comment">// 定义了继承于 ui_myDialog 的类 myDialog</span></span><br></pre></td></tr></table></figure>
<p>而真正想要应用这个窗口类，需要进行<strong>多继承</strong>，使用它和 <code>QMainWindow</code> 的子类——<strong>毕竟这个类不是 <code>QObject</code>，没有办法完成信号-槽的创建</strong>；</p>
<p>所以一般情况下将 <code>ui_myDialog</code> 类作为中间类，再<strong>手动</strong>为这个窗口创建 <code>myDialog.h</code> 和 <code>myDialog.cpp</code>，分别书写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: myDialog.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_myDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请注意！！！这里的 myDialog 和之前定义在 ui_myDialog.h 文件中 Ui 命名空间中的类 myDialog 不一样！</span></span><br><span class="line"><span class="comment">// 这里的 myDialog 和 Ui::myDialog 类进行了继承，使 myDialog 具有了 Ui::myDialog 类一样的控件作为属性</span></span><br><span class="line"><span class="comment">// 同时 myDialog 还和 QMainWindow 进行多继承，使 myDialog 还具有 QMainWindow的属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myDialog</span> : <span class="keyword">public</span> QMainWindow, <span class="keyword">public</span> Ui::myDialog &#123;</span><br><span class="line">    Q_OBJECT        <span class="comment">// 为何需要继承 Ui::myDialog，组合不行吗？不行。</span></span><br><span class="line"><span class="keyword">public</span>:                <span class="comment">// 因为需要修改信号-槽连接，涉及其中的控件</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">myDialog</span><span class="params">(QWidget* parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: myDialog.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 myDialog 是 QMainWindow 的子类，因此想要重用它的属性，</span></span><br><span class="line"><span class="comment">// 需要委托调用父类的构造函数：QMainWindow(parent)；</span></span><br><span class="line"><span class="comment">// 此外，setupUi(this) 是以当前窗口为顶级控件，按 UI 设计部署控件</span></span><br><span class="line">myDialog::<span class="built_in">myDialog</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，一个只有图形界面、没有添加 槽-函数 连接的主窗口类 <code>myDialog</code> 就设计完成了；</p>
<blockquote>
<p>提示：除了上面的继承方法，还可以把 <code>Ui::myDialog</code> 作为 <code>myDialog</code> 的一个数据成员使用。</p>
</blockquote>
<h4 id="IDE-用户视角"><a href="#IDE-用户视角" class="headerlink" title="IDE 用户视角"></a>IDE 用户视角</h4><p>事实上，使用 Qt Creator 的用户在一开始，<strong>向项目中添加 <code>UI 设计师文件</code></strong>，IDE 会提示用户起名的时候，就会同时创建 <code>myDialog.ui</code>、<code>myDialog.h</code>、<code>myDialog.cpp</code> 三个文件，并更新 <code>&lt;项目名称&gt;.pro</code> 文件，直接省去非 IDE 方法中所有步骤；</p>
<p>值得一提的是，Qt Creator 在编译时生成的 <code>ui_myDialog.h</code> 不在项目目录中（也许是考虑到相关性），而藏在上层 build_XXX 目录里，不过使用的时候也无需注意，因为引入工作已经在自动生成的 <code>myDialog.h</code> 中写好了；</p>
<p>这下关于 Qt Designer 的运行机制、IDE 封装的机制是不是更清楚了呢？</p>
<h3 id="2-2-3-案例演示"><a href="#2-2-3-案例演示" class="headerlink" title="2.2.3 案例演示"></a>2.2.3 案例演示</h3><blockquote>
<p>本节将一步步地完成 2.2.1 中的窗体设计目标；将以非 IDE 的方式完成（IDE 的操作简单就不演示了）（<strong>注意，它的角色是子窗口</strong>）</p>
</blockquote>
<ol>
<li><p>创建一个项目目录：新建项目文件夹 <code>testUI</code>，创建文件 <code>main.cpp</code>、<code>GoToCellDialog.cpp</code>、<code>GoToCellDialog.h</code>；</p>
</li>
<li><p>打开 Qt Designer，选择 <code>Dialog without button</code> 模板，按照图中要求设计出 UI，窗体命名为 <code>GoToCellDialog</code>（<code>objectName</code>），保存文件为 <code>GoToCellDialog.ui</code>，记得保存在项目目录中；</p>
</li>
<li><p>命令行切换至项目目录，新建目录 build（为了让项目目录更干净，build 就设置在项目目录里面，你也可以设置在其他地方，比如上层目录——Qt Creator IDE 就是这么干的），命令行切入，运行 <code>qmake -project ../</code>，向 生成的 <code>testUI.pro</code> 中添加 <code>QT += widgets</code>；</p>
</li>
<li><p>编写 Go to Cell 窗体的主要逻辑代码（包括信号-槽的定义）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: GoToCellDialog.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_GoToCellDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoToCellDialog</span> : <span class="keyword">public</span> QDialog, <span class="keyword">public</span> Ui::GoToCellDialog &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoToCellDialog</span>(QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 自定义槽</span></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="comment">// 注意：这么命名是有讲究的！！！</span></span><br><span class="line">    <span class="comment">// 在 uic 和 moc 编译时，会识别所有 on_&lt;objectName&gt;_&lt;signalName&gt;() 命名的函数，自动连接：</span></span><br><span class="line">    <span class="comment">// connect(lineEdit, SIGNAL(textChanged(const QString&amp;)),</span></span><br><span class="line">    <span class="comment">//             this, SLOT(on_lineEdit_textChanged()));</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_lineEdit_textChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: GoToCellDialog.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GoToCellDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数中的 widget 变量名就是之前你在 GoToCellDialog.ui 设计中的 objectName</span></span><br><span class="line">GoToCellDialog::<span class="built_in">GoToCellDialog</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setupUi</span>(<span class="keyword">this</span>);    <span class="comment">// 以当前对象为父 widget 初始化窗体部件</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">QRegExp <span class="title">reg</span><span class="params">(<span class="string">&quot;[a-zA-Z][1-9][0-9]&#123;0,2&#125;&quot;</span>)</span></span>;        <span class="comment">// 正则表达式类</span></span><br><span class="line">    <span class="comment">// 新方法：为 QLineEdit 类设置正则可接受检验器</span></span><br><span class="line">    <span class="comment">// QRegExpValidator 的构造函数 第一个参数是 QRegExp（正则Pattern）</span></span><br><span class="line">    <span class="comment">// 第二个参数是 parent，使 QRegExpValidator 对象成为 parent 的</span></span><br><span class="line">    <span class="comment">// 子控件，这样就不要手动 delete，在父控件析构时，子控件一起析构了（之前提过）</span></span><br><span class="line">    lineEdit-&gt;<span class="built_in">setValidator</span>(<span class="keyword">new</span> <span class="built_in">QRegExpValidator</span>(reg, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置信号-槽</span></span><br><span class="line">    <span class="comment">// 这里的 accept() 和 reject() 槽是 QDialog 的固有槽，</span></span><br><span class="line">    <span class="comment">// 触发这两槽之一都会关闭窗口，但是分别会修改：</span></span><br><span class="line">    <span class="comment">// QDialog::Accepted 和 QDialog::Rejected 数据成员的值，</span></span><br><span class="line">    <span class="comment">// 以便主窗口判断用户执行了什么操作</span></span><br><span class="line">    <span class="built_in">connect</span>(okBtn, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">accept</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(cancelBtn, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">reject</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是指，当文本框改变，就进入这个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoToCellDialog::on_lineEdit_textChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果经过 QRegExpValidator 检查符合，那么激活 okBtn，否则禁用</span></span><br><span class="line">    okBtn-&gt;<span class="built_in">setEnabled</span>(lineEdit-&gt;<span class="built_in">hasAcceptableInput</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GoToCellDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    GoToCellDialog* dialog = <span class="keyword">new</span> GoToCellDialog;</span><br><span class="line">    </span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 <code>qmake testUI.pro</code>；</p>
</li>
<li><p><strong>Windows 用户</strong>请按照之前所说的，在当前命令行运行 <a href="#script-env">配置临时环境变量的脚本🔗</a> ；</p>
</li>
<li><p>Unix 用户 执行 <code>make</code>，Windows 用户执行 <code>mingw32-make</code>，构建完成；</p>
</li>
</ol>
<p>如此一来，一个子窗口类的演示就做好了；</p>
<h1 id="Chapter-3-Qt：样式更丰富的子窗口"><a href="#Chapter-3-Qt：样式更丰富的子窗口" class="headerlink" title="Chapter 3 Qt：样式更丰富的子窗口"></a>Chapter 3 Qt：样式更丰富的子窗口</h1><blockquote>
<p>前面几章，只是零碎地介绍基本编写方法；</p>
<p>在 1.4 中，初步学习了 面向过程的简单<strong>主窗口纯代码</strong>设计；</p>
<p>在 2.1 中，初步学习了 面向对象的简单<strong>子窗口纯代码</strong>设计；</p>
<p>在 2.2 中，初步学习了 面向对象的简单<strong>子窗口快速 UI</strong> 设计；</p>
<p>本章将介绍更多其他样式的子窗口的设计；</p>
</blockquote>
<h2 id="3-1-扩展对话框"><a href="#3-1-扩展对话框" class="headerlink" title="3.1 扩展对话框"></a>3.1 扩展对话框</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="externDialog.png" height="300px"></p>
<p>本节技术栈并没有拓展，还是之前的 Qt Creator、Qt Designer 使用技术；</p>
<p>此处仅会提及新出现的控件属性或方法等信息；</p>
<ul>
<li><code>QPushButton</code> 的属性 <code>checkable</code> ：如果修改为 <code>true</code>，则在用户点击一下后持续有效（相当于 <code>checkBox</code>），再次点击才会还原；</li>
<li><code>QPushButton</code> 的槽 <code>toggled(bool)</code>：当按钮 <code>enabled</code> 属性被改变时，<code>toggle</code> 会发射信号，参数就不用说了吧，，这个槽在按钮为 <code>checkable</code> 时有用；</li>
<li><code>QPushButton</code> 的槽 <code>setText(QString)</code>：可以在中途改变按钮的文本；</li>
<li><code>QGridLayout</code> 布局管理器：在 1.4.3 中介绍过，如果发现按钮较多，而且摆不整齐的时候可以尝试这个布局，它可以使控件按照行、列的规则摆放；</li>
<li><strong>有些人会疑惑水平/竖直分隔符（spacer）有什么用</strong>，其实它就像 Qt Designer 上画的一样，用来在窗口伸缩时，调节控件之间的位置关系的；</li>
<li>在 2.2.1 中，其实还有一种 <strong>Qt Designer 设计模式没有介绍到：Edit Signals/Slots</strong>，在此模式下可以<strong>直接编辑信号-槽连接</strong>，无需手动写 <code>connect</code> 函数；使用方法 和 Edit Buddy 模式类似，感兴趣可以尝试一下；</li>
<li><strong>新的类 <code>QGroupBox</code> 组群盒</strong>：如上图，就是那一个个小方框；</li>
<li>大多数 Widget 都有一个槽：<code>QWidget::setVisible(bool)</code>，可以理解为<strong>含参数、可重用的 <code>QWidget::close()</code>槽</strong>；</li>
<li>快捷复制：按住 CTRL，单击要复制的控件，再拖动就能复制了 ~</li>
<li><strong>新的类 <code>QComboBox</code> 下拉栏选择器</strong><ul>
<li>具有方法 <code>clear()</code>，常用在初始化时，清空选项；</li>
<li>具有方法 <code>addItem(QString)</code>，添加下拉栏内容，一般在 Qt Designer 里添加，也可自己在代码里写；</li>
<li>具有方法 <code>setMinimumSize(int)</code>，设置下拉栏的最小大小值；</li>
</ul>
</li>
<li><p><strong>新的类 <code>QChar</code> 字符类</strong></p>
<ul>
<li>具有方法 <code>unicode()</code>：转化为 unicode 码，可以运算；</li>
<li>可以作为 <code>QString</code> 的初始化参数；</li>
</ul>
</li>
<li><p><strong>设置窗口固定尺寸的常用方法：<code>layoutName-&gt;setSizeConstraint(QLayout::SetFixedSize)</code></strong>；</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: SortDialog.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_SortDialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortDialog</span> : <span class="keyword">public</span> QDialog, <span class="keyword">public</span> Ui::SortDialog &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SortDialog</span>(QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// Initialize the content of each column comboBox</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColumnRange</span><span class="params">(QChar first, QChar last)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: SortDialog.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortDialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtGui&gt;</span></span></span><br><span class="line"></span><br><span class="line">SortDialog::<span class="built_in">SortDialog</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent) &#123;</span><br><span class="line">    <span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// Hide the group box first,</span></span><br><span class="line">    <span class="comment">// Because the setVisible(bool) function hasn&#x27;t been called.</span></span><br><span class="line">    secondaryGroupBox-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    tertiaryGroupBox-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="comment">// Fix the size of the window</span></span><br><span class="line">    <span class="built_in">layout</span>()-&gt;<span class="built_in">setSizeConstraint</span>(QLayout::SetFixedSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setColumnRange</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortDialog::setColumnRange</span><span class="params">(QChar first, QChar last)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clear the content of each comboBox</span></span><br><span class="line">    primaryColCombo-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    secondaryColCombo-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    tertiaryColCombo-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional</span></span><br><span class="line">    secondaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">tr</span>(<span class="string">&quot;None&quot;</span>));</span><br><span class="line">    tertiaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">tr</span>(<span class="string">&quot;None&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于 primaryColCombo 中显示单字符时，展示的宽度小于</span></span><br><span class="line">    <span class="comment">// secondary 和 tertiary ColCombo 显示的 “None”，所以设置</span></span><br><span class="line">    <span class="comment">// primaryColCombo 的最小宽度，防止宽度不相同的现象</span></span><br><span class="line">    primaryColCombo-&gt;<span class="built_in">setMinimumSize</span>(secondaryColCombo-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line"></span><br><span class="line">    QChar ch = first;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= last) &#123;</span><br><span class="line">        primaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">QString</span>(ch));</span><br><span class="line">        secondaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">QString</span>(ch));</span><br><span class="line">        tertiaryColCombo-&gt;<span class="built_in">addItem</span>(<span class="built_in">QString</span>(ch));</span><br><span class="line">        ch = ch.<span class="built_in">unicode</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortDialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    SortDialog* dialog = <span class="keyword">new</span> SortDialog;</span><br><span class="line">    <span class="comment">// 测试函数是否能用</span></span><br><span class="line">    dialog-&gt;<span class="built_in">setColumnRange</span>(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行项目即可；</p>
<h2 id="3-2-Qt-内置的更多部件和对话框"><a href="#3-2-Qt-内置的更多部件和对话框" class="headerlink" title="3.2 Qt 内置的更多部件和对话框"></a>3.2 Qt 内置的更多部件和对话框</h2><blockquote>
<p>这里仅作初步介绍，在完整项目的应用中会进一步介绍使用方法，因为一次性看完很可能记不住……</p>
</blockquote>
<ul>
<li><p>Qt 中的按钮类</p>
<ul>
<li>QPushButton：之前演示的普通按钮；</li>
<li>QToolButton：具有图标的功能按钮；</li>
<li>QCheckBox：复选框类；</li>
<li>QRadioButton：单选框类，只能在一组中选一个激活；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="btns.png" height="100px"></p>
</li>
<li><p>Qt 中的单页容器部件</p>
<ul>
<li>QGroupBox：之前演示的群组框；</li>
<li>QFrame：QLabel 的父类，可以用来展示图片、文字等信息（所以 QLabel 也行）；</li>
</ul>
</li>
<li><p>Qt 中的多页容器部件</p>
<ul>
<li>QTabWidget：切换多个 Tab 的窗口控件；</li>
<li>QToolBox：切换不同工具分类的窗口控件；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="multiPWidgets.png" height="200"></p>
</li>
<li><p>Qt 中的显示窗口部件：<code>QLabel</code>、<code>QLCDNumber</code>、<code>QProgressBar</code>、<code>QTextBrowser</code></p>
<p>注：QTextBrowser 是只读的 QTextEdit 子类，也可以显示带格式的文本，<strong>建议处理大型格式化文本</strong>，因为它和 QLabel 不同，可以在必要时自动提供滚动条；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="showWidgets.png"></p>
</li>
<li><p>Qt 中的输入窗口部件：<code>QSpinBox</code>、<code>QDoubleSpinBox</code>、<code>QComboBox</code>、<code>QDateEdit</code>、<code>QTimeEdit</code>、<code>QDateTimeEdit</code>、<code>QScrollBar</code>、<code>QSlider</code>、<code>QTextEdit</code>、<code>QLineEdit</code>、<code>QDial</code></p>
<p>注：QTextEdit 支持输入掩码、检验器（2.2.3 已演示）等功能；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="inputWidgets.png"></p>
</li>
<li><p>Qt 的反馈对话框：<code>QInputDialog</code>、<code>QProgressDialog</code>、<code>QMessageBox</code>、<code>QErrorMessage</code>、<code>QColorDialog</code>、<code>QFontDialog</code>、<code>QFileDialog</code>、<code>QPrintDialog</code> 等；</p>
</li>
</ul>
<h2 id="3-3-Qt-类的第二次总结-amp-下文预告"><a href="#3-3-Qt-类的第二次总结-amp-下文预告" class="headerlink" title="3.3 Qt 类的第二次总结 &amp; 下文预告"></a>3.3 Qt 类的第二次总结 &amp; 下文预告</h2><blockquote>
<p>学完了以上的知识，目前使用到的 Qt 类的框架如下图所示：</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C3.png"></p>
<p><strong>同系列下一篇文章预告：将会是 第一个完整的 Qt 入门项目（会非常地长，比本篇还长），目的是通过实战来学习 Qt 的更多类的用法，源代码和程序 届时会放在仓库，以供读者参考。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top">SJTU-XHW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.sjtuxhw.top/technical/qt-for-beginners-1/">https://blog.sjtuxhw.top/technical/qt-for-beginners-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.sjtuxhw.top" target="_blank">SJTU-XHW's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Programming/">Programming</a><a class="post-meta__tags" href="/tags/Qt/">Qt</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.sjtuxhw.top/cover_imgs/qt1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/literary/2023-hdc/" title="2023 HDC 参会笔记与感悟"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/2023-HDC.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">2023 HDC 参会笔记与感悟</div></div><div class="info-2"><div class="info-item-1">Author: SJTU-XHW Language: Simple Chinese License: CC BY 4.0 本人学识有限，内容难免有错，恳请读者能够批评指正，本人将不胜感激！ 注：在笔记的 这里 你可以体验有趣的 WebXR 的项目 Demo ~  8 月 4 日主会场：HarmonyOS 4 与 SDK 主题演讲一、 Harmony 4 UX 设计 系统输入法表情更新：上千个专属定制的 unicode 表情符号，精细化表情符号所代表的语义；  举例：一碗面条所对应的表情就有 4 种之多，提供 “宽面”、“窄面”，“拌面”、“汤面” 之选择；   结合 HarmonyOS 4 图像识别处理的技术，用户可以 定制 “以自己主角” 的壁纸、主题，体现个性化界面设计之美； 系统界面 UI 焕然一新，同时给用户和开发者提供更多不同的窗口组件；  二、 Security 细化权限控制粒度，最小化权限给予。将应用权限交由用户决定；  举例：用户不允许透露的信息（如通讯录），可以采取提交 “虚假信息”...</div></div></div></a><a class="pagination-related" href="/technical/cmake-advanced/" title="CMake 进阶"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/cmake.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CMake 进阶</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference:  CMake Tutor 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 本文目标：在前文（GNU Tutor）初步了解 CMake、C++ 编译过程后，继续深入学习 CMake 在 C++ 构建中的使用；    ⚠ 劝退警告：如果你只想用 IDE 一键编译运行，而不想了解构建和编译细节，那么这篇文章不是为你准备的！  Chapter 0. Make 介绍 对 Make 没兴趣的这章可以跳过！ CMake 生成的 Makefile 究竟是什么？语法是怎样？为什么要有它？ 由于现在是 21 世纪 20 年代，所以像 make 这样底层的古董就点到为止；；   地位：GNU 计划的一个开源程序；  作用  制定整个项目的编译规则（利用 Makefile 定义整个编译流程以及各个目标文件与源文件之间的依赖关系），自动化编译步骤，以此提高开发效率； 二次编译时，仅重新编译你的修改会影响到的部分，从而降低编译的时间；   劣势：为什么上面说 “点到为止”？因为它比较底层，导致抽象层级不高，不能跨平台，每个平台有各自的...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/technical/qt-for-beginners-3/" title="从C++入门Qt（三）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/qt3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="info-item-2">从C++入门Qt（三）</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~   前面 4 章节的内容都是从具体项目来学习 Qt 的方法，也已经让我们初步认识了 Qt 的使用方法，下面的内容将按类分块来介绍，文章的篇幅也会短一些。 Chapter 5. Qt 常用事件Qt 中常用的 Event 主要有：鼠标事件、键盘事件、内部事件。其中内部事件绝大多数都交给 信号-槽 来处理，少部分的内部事件在特定情况需要重写，例如 QPaintEvent（下一章说）、 QCloseEvent 关闭事件（实现关闭前确认）。前两个事件是输入事件，都继承于 QInputEvent。 5.1 内部事件前面介绍过，对于内部事件（特指关闭事件），QCloseEvent 的使用方法也很简单，重写 void...</div></div></div></a><a class="pagination-related" href="/technical/qt-for-beginners-2/" title="从C++入门Qt（二）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/qt2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-16</div><div class="info-item-2">从C++入门Qt（二）</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference: C++ GUI Programming with Qt 4 (2nd Edition)  注意：本文章将讲解 Qt 5 入门知识，需要一定的 C++ 基础 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 观前提示：本系列的所有完整代码在整理好后，都会存放在仓库中，有需要可以自取 ~   Chapter 4 第一个完整的 Qt 入门项目 在完成以上的学习过程后，在座诸位都具有独立写出一个极简的、较为完整 Qt 项目的能力； 以下，本人将用 纯代码方式 方式完成这个项目； 本章末，会总结到目前为止学到的所有 Qt 类的继承/思维图。  观前提示：本项目的设计思路很长，完整源代码放在 仓库 里，有需要可以取出查看 ~ 本章的目的是为了学习 Qt 一些组件的用法而已 ~ 项目目标：模仿 Microsoft Excel 设计一个表格应用程序。 4.1 创建主窗口 UI4.1.1 子类化 QMainWindow创建一个主窗口最方便的方法是利用 Qt 库中已有的设计类：QMainWindow。 QMainWindow 和...</div></div></div></a><a class="pagination-related" href="/review/csapp-basic/" title="CSAPP Notes Basic"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_123.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="info-item-2">CSAPP Notes Basic</div></div><div class="info-2"><div class="info-item-1">written by SJTU-XHW Reference:  CMU - 213, Computer Systems A Programmer’s Perspective 3rd Edition by Randal Bryant, David O’Hallaron 本人知识浅薄，文章难免有问题或缺漏，欢迎批评指正！ 内容很长，写起来很慢 😳   Chapter 0. Intro0.1 Ints are not Integers, Floats are not Reals $x^2\ge 0$：int（32-bit）may overflow； $a+(b+c)=(a+b)+c$：floats may discard some “unsignificant” digits；  0.2 Learn Assembly but never write it0.3 Memory Matters: Unbounded1234567891011121314typedef struct &#123;    int a[2];    double d;&#125;...</div></div></div></a><a class="pagination-related" href="/review/csapp-ecf-io/" title="CSAPP Notes: ECF &amp; I&#x2F;O"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-ecf.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-16</div><div class="info-item-2">CSAPP Notes: ECF &amp; I&#x2F;O</div></div><div class="info-2"><div class="info-item-1">Chapter 13. Exceptional Control Flow 对应书中第 8 章。  异常控制流是现代计算机系统的一个相当重要的部分。 13.1 Control Flow 控制流：从机器打开到关闭的过程中，处理器只做一件事：读指令、执行指令，一个周期做一个指令。多核的机器则每个核心依次交替执行指令。这些指令序列被称为控制流。硬件正在执行的实际指令序列就被称为物理控制流。  改变内存中控制流的方法：分支 &amp; 跳转，过程调用 &amp; 返回（Branches &amp; Jumps &amp; Procedure call and return）；  都是对于程序状态变化的处理。    但以上的简单的改变控制流的方法对于处理复杂的系统级别的状态变化时，就显得非常拙劣。（例如 OS 协同软硬件的通信，如果还是以 if-else 的方法，那将会非常差劲）； 什么是 “系统级别的状态变化”？  数据从磁盘 / 网卡到达内存中； I/O 设备输入...</div></div></div></a><a class="pagination-related" href="/review/csapp-mm-cache/" title="CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp-mh.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-10</div><div class="info-item-2">CSAPP Notes: Memory Hierarchy &amp; Cache &amp; Opt</div></div><div class="info-2"><div class="info-item-1">Chapter 10. The Memory Hierarchy 本章将介绍系统的内存分层架构。  之前几章，我们对于内存的理解就是一个很大的字节数组，可以用地址作为下标进行访问。但事实上，真正的计算机的存储系统背后的设备层次结构设计远比这层抽象要复杂。 正是计算机的存储系统的层次结构对有限、离散资源的管理和抽象，才能让程序的内存看起来呈现出这种线性的数组结构。本章就来讨论计算机存储系统背后的层次结构。 10.1 Storage Technologies &amp; Trends在正式学习存储系统的层次结构前，有必要稍微弄清楚底层硬件的情况。 10.1.1 Random-Access Memory (RAM)当前大多数人所熟知的 “内存” 的一部分就是随机访问存储器（RAM），它具有以下的特征：  RAM 是个存储元件，I/O 吞吐速率快于绝大多数硬盘固件/磁盘（称为 “外存”）；  RAM 常常被打包放在 CPU 芯片中；  RAM 中每一个基本的存储单元被称为 单元胞（Cell），一个单元胞中存放 1 bit 数据；  很多个 RAM 芯片共同工作，组成了计算机的...</div></div></div></a><a class="pagination-related" href="/review/csapp-sched-arch/" title="CSAPP Notes: Scheduler &amp; Arch"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/csapp_p2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-11</div><div class="info-item-2">CSAPP Notes: Scheduler &amp; Arch</div></div><div class="info-2"><div class="info-item-1">Chapter 8. Scheduler in OS为操作系统的调度环境作出假设：  Each job runs for the same amount of time All jobs arrive at the same time Once started, each job runs to completion All jobs only use the CPU  i.e., they perform no I/O   The run-time of each job is known  引入调度优劣衡量指标：周转时间，$T_{turnaround}=T_{completion}-T_{arrival}$； Strategy 1: FIFO（FCFS，First Come First Served） Implementation: queue； 消除假设 1：若短时任务排在长时任务之后，则平均周转时间效果很差；  Strategy 2 : SJF（Shortest Job First） 内容：对于同时到达的任务，优先选择总时长小的任务。 作用：（应对假设 1...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SJTU-XHW</div><div class="author-info-description">A blog to document learning and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/SSRVodka"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SSRVodka" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sjtuxhw12345@sjtu.edu.cn" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.sjtuxhw.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #a200ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Thanks for visiting! |•'-'•) ✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-0-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">Chapter 0 前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-C-%E5%9F%BA%E7%A1%80-%E5%92%8C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-text">0.1 C++ 基础 和 面向对象编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-2-C-%E7%9A%84%E5%AE%8F%EF%BC%88macro%EF%BC%89"><span class="toc-text">0.2 C++ 的宏（macro）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-3-Qt-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">0.3 Qt 环境配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-Qt-%E5%88%9D%E8%AE%A4%E8%AF%86"><span class="toc-text">Chapter 1 Qt 初认识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">1.1 简单示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%A6%81%E7%82%B9%EF%BC%9A%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88qmake%EF%BC%89%E5%88%9B%E5%BB%BA%E3%80%81%E7%BC%96%E8%AF%91-Qt-%E5%B7%A5%E7%A8%8B"><span class="toc-text">1.2 要点：通过命令行（qmake）创建、编译 Qt 工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E-IDE-%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E3%80%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-Qt-%E9%A1%B9%E7%9B%AE"><span class="toc-text">非 IDE 用户如何创建、编译运行 Qt 项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDE-%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E3%80%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-Qt-%E9%A1%B9%E7%9B%AE"><span class="toc-text">IDE 用户如何创建、编译运行 Qt 项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-EX-%E4%BD%BF%E7%94%A8-CMake-%E4%BB%A3%E6%9B%BF-qmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">1.2-EX 使用 CMake 代替 qmake 构建项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-text">1.3 建立连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">1.3.1. 信号与槽的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">1.3.2. 示例代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Qt-%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1"><span class="toc-text">1.4 Qt 窗口的布局设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-widget-%E9%97%B4%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB"><span class="toc-text">1.4.1 widget 间的父子关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">1.4.2 布局设计的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.4.3 布局管理器的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E7%AB%A0%E6%9C%AB%E8%B4%B4%E5%A3%AB"><span class="toc-text">1.5 章末贴士</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84-Qt"><span class="toc-text">Chapter 2 面向对象的 Qt</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%BA%AF%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.1 纯代码设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BB%A5%E7%AE%80%E5%8D%95%E5%AF%B9%E8%AF%9D%E6%A1%86%E4%B8%BA%E4%BE%8B"><span class="toc-text">2.1.1 示例：以简单对话框为例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3%E4%BF%A1%E5%8F%B7-%E6%A7%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">2.1.2 进一步了解信号-槽机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-Qt-%E7%9A%84%E5%85%83%E5%AF%B9%E8%B1%A1%E7%BC%96%E8%AF%91%E5%99%A8-moc-%E5%92%8C-%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F"><span class="toc-text">2.1.3 Qt 的元对象编译器 moc 和 元对象系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Qt-Designer%EF%BC%9AUI-%E5%BF%AB%E9%80%9F%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.2 Qt Designer：UI 快速设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-Qt-Designer-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">2.2.1 Qt Designer 的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-Qt-Designer-%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91"><span class="toc-text">2.2.2 Qt Designer 的运行原理【重要】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E-IDE-%E7%94%A8%E6%88%B7%E7%9A%84%E8%A7%86%E8%A7%92"><span class="toc-text">非 IDE 用户的视角</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IDE-%E7%94%A8%E6%88%B7%E8%A7%86%E8%A7%92"><span class="toc-text">IDE 用户视角</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-text">2.2.3 案例演示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-Qt%EF%BC%9A%E6%A0%B7%E5%BC%8F%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%AD%90%E7%AA%97%E5%8F%A3"><span class="toc-text">Chapter 3 Qt：样式更丰富的子窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%89%A9%E5%B1%95%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-text">3.1 扩展对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Qt-%E5%86%85%E7%BD%AE%E7%9A%84%E6%9B%B4%E5%A4%9A%E9%83%A8%E4%BB%B6%E5%92%8C%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-text">3.2 Qt 内置的更多部件和对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Qt-%E7%B1%BB%E7%9A%84%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%80%BB%E7%BB%93-amp-%E4%B8%8B%E6%96%87%E9%A2%84%E5%91%8A"><span class="toc-text">3.3 Qt 类的第二次总结 &amp; 下文预告</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/technical/pytorch-dim/" title="如何理解 PyTorch 函数的 dim 参数"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/pth_dim.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何理解 PyTorch 函数的 dim 参数"/></a><div class="content"><a class="title" href="/technical/pytorch-dim/" title="如何理解 PyTorch 函数的 dim 参数">如何理解 PyTorch 函数的 dim 参数</a><time datetime="2025-02-18T12:17:05.000Z" title="发表于 2025-02-18 20:17:05">2025-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/java-adv-3/" title="Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/java-adv-3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI"/></a><div class="content"><a class="title" href="/technical/java-adv-3/" title="Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI">Java 进阶（三）：垃圾回收、并发、JDNI &amp; SPI</a><time datetime="2025-01-06T05:44:06.000Z" title="发表于 2025-01-06 13:44:06">2025-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/review/algo-desgin-table/" title="算法设计知识点自查表"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/algo-design-table.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法设计知识点自查表"/></a><div class="content"><a class="title" href="/review/algo-desgin-table/" title="算法设计知识点自查表">算法设计知识点自查表</a><time datetime="2024-12-31T14:47:03.000Z" title="发表于 2024-12-31 22:47:03">2024-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/redis-starter/" title="Redis 入门：从实践到理论"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/redis.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 入门：从实践到理论"/></a><div class="content"><a class="title" href="/technical/redis-starter/" title="Redis 入门：从实践到理论">Redis 入门：从实践到理论</a><time datetime="2024-11-12T13:05:37.000Z" title="发表于 2024-11-12 21:05:37">2024-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/technical/python-sci-starter/" title="Python 科学计算入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sjtuxhw.top/cover_imgs/python_sci.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 科学计算入门"/></a><div class="content"><a class="title" href="/technical/python-sci-starter/" title="Python 科学计算入门">Python 科学计算入门</a><time datetime="2024-11-03T11:08:13.000Z" title="发表于 2024-11-03 19:08:13">2024-11-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By SJTU-XHW  |  tech SJTU saves the world</div><div class="framework-info"><span>Built With love &amp; </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Powered By </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="display:flex;flex-flow:row;justify-content:center;align-items:center;"> <a href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" id="beian" target="_blank">ICP备案：沪ICP备2023012264-1号</a> <span class="footer-separator">|</span> <a style="display:flex;flex-flow:row;align-items:center;" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noreferrer" target="_blank"> 本网站由 <img style="margin:0 3px;" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/upCloud_logo_blue.png" title="upcloud" alt="upcloud" height="30px"> 提供CDN加速/云存储服务 </a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;" rel="external nofollow noreferrer"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/tw-emoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],"locale":{"reactionTitle":"你认为这篇文章怎么样？","placeholder":"给大佬递笔 XP\n[ Akismet AI Filter 🤖 ON ]"},"reaction":["https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsup.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_thumbsdown.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_antic.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_cool.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_sleepy.gif","https://unpkg.com/@waline/emojis@1.2.0/qq/qq_emm.gif"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline.sjtuxhw.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/rightmenu.js"></script><script src="/js/mourn.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>